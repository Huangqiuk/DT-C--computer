; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\gd32f10x_fmc.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\gd32f10x_fmc.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.3\Device\Include -D__MICROLIB -D__UVISION_VERSION=539 -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\gd32f10x_fmc.crf Libraries\src\gd32f10x_fmc.c]
                          THUMB

                          AREA ||i.fmc_bank0_erase||, CODE, READONLY, ALIGN=2

                  fmc_bank0_erase PROC
;;;272    */
;;;273    fmc_state_enum fmc_bank0_erase(void)
000000  b530              PUSH     {r4,r5,lr}
;;;274    {
;;;275        fmc_state_enum fmc_state = FMC_READY;
;;;276        /* wait for the FMC ready */
;;;277        fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT);
000002  f44f2570          MOV      r5,#0xf0000
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       fmc_bank0_ready_wait
;;;278    
;;;279        if(FMC_READY == fmc_state){
00000c  2800              CMP      r0,#0
00000e  d10f              BNE      |L1.48|
;;;280            /* start FMC bank0 erase */
;;;281            FMC_CTL0 |= FMC_CTL0_MER;
000010  4c08              LDR      r4,|L1.52|
000012  6920              LDR      r0,[r4,#0x10]
000014  f0400004          ORR      r0,r0,#4
000018  6120              STR      r0,[r4,#0x10]
;;;282            FMC_CTL0 |= FMC_CTL0_START;
00001a  6920              LDR      r0,[r4,#0x10]
00001c  f0400040          ORR      r0,r0,#0x40
000020  6120              STR      r0,[r4,#0x10]
;;;283            /* wait for the FMC ready */
;;;284            fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT);
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       fmc_bank0_ready_wait
;;;285            /* reset the MER bit */
;;;286            FMC_CTL0 &= ~FMC_CTL0_MER;
000028  6921              LDR      r1,[r4,#0x10]
00002a  f0210104          BIC      r1,r1,#4
00002e  6121              STR      r1,[r4,#0x10]
                  |L1.48|
;;;287        }
;;;288        /* return the fmc state */
;;;289        return fmc_state;
;;;290    }
000030  bd30              POP      {r4,r5,pc}
;;;291    
                          ENDP

000032  0000              DCW      0x0000
                  |L1.52|
                          DCD      0x40022000

                          AREA ||i.fmc_bank0_lock||, CODE, READONLY, ALIGN=2

                  fmc_bank0_lock PROC
;;;142    */
;;;143    void fmc_bank0_lock(void)
000000  4802              LDR      r0,|L2.12|
;;;144    {
;;;145        /* set the LK bit*/
;;;146        FMC_CTL0 |= FMC_CTL0_LK;
000002  6901              LDR      r1,[r0,#0x10]
000004  f0410180          ORR      r1,r1,#0x80
000008  6101              STR      r1,[r0,#0x10]
;;;147    }
00000a  4770              BX       lr
;;;148    
                          ENDP

                  |L2.12|
                          DCD      0x40022000

                          AREA ||i.fmc_bank0_ready_wait||, CODE, READONLY, ALIGN=1

                  fmc_bank0_ready_wait PROC
;;;924    */
;;;925    fmc_state_enum fmc_bank0_ready_wait(uint32_t timeout)
000000  b500              PUSH     {lr}
;;;926    {
000002  4603              MOV      r3,r0
                  |L3.4|
;;;927        fmc_state_enum fmc_state = FMC_BUSY;
;;;928      
;;;929        /* wait for FMC ready */
;;;930        do{
;;;931            /* get FMC state */
;;;932            fmc_state = fmc_bank0_state_get();
000004  f7fffffe          BL       fmc_bank0_state_get
;;;933            timeout--;
000008  1e5b              SUBS     r3,r3,#1
;;;934        }while((FMC_BUSY == fmc_state) && (0x00U != timeout));
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L3.18|
00000e  2b00              CMP      r3,#0
000010  d1f8              BNE      |L3.4|
                  |L3.18|
;;;935        
;;;936        if(FMC_BUSY == fmc_state){
000012  2801              CMP      r0,#1
000014  d100              BNE      |L3.24|
;;;937            fmc_state = FMC_TOERR;
000016  2004              MOVS     r0,#4
                  |L3.24|
;;;938        }
;;;939        /* return the FMC state */
;;;940        return fmc_state;
;;;941    }
000018  bd00              POP      {pc}
;;;942    
                          ENDP


                          AREA ||i.fmc_bank0_state_get||, CODE, READONLY, ALIGN=2

                  fmc_bank0_state_get PROC
;;;873    */
;;;874    fmc_state_enum fmc_bank0_state_get(void)
000000  2000              MOVS     r0,#0
;;;875    {
;;;876        fmc_state_enum fmc_state = FMC_READY;
;;;877      
;;;878        if((uint32_t)0x00U != (FMC_STAT0 & FMC_STAT0_BUSY)){
000002  4908              LDR      r1,|L4.36|
000004  68ca              LDR      r2,[r1,#0xc]
000006  07d2              LSLS     r2,r2,#31
000008  d001              BEQ      |L4.14|
;;;879            fmc_state = FMC_BUSY;
00000a  2001              MOVS     r0,#1
;;;880        }else{
;;;881            if((uint32_t)0x00U != (FMC_STAT0 & FMC_STAT0_WPERR)){
;;;882                fmc_state = FMC_WPERR;
;;;883            }else{
;;;884                if((uint32_t)0x00U != (FMC_STAT0 & (FMC_STAT0_PGERR))){
;;;885                    fmc_state = FMC_PGERR; 
;;;886                }
;;;887            }
;;;888        }
;;;889        /* return the FMC state */
;;;890        return fmc_state;
;;;891    }
00000c  4770              BX       lr
                  |L4.14|
00000e  68ca              LDR      r2,[r1,#0xc]          ;881
000010  06d2              LSLS     r2,r2,#27             ;881
000012  d501              BPL      |L4.24|
000014  2003              MOVS     r0,#3                 ;882
                  |L4.22|
000016  4770              BX       lr
                  |L4.24|
000018  68c9              LDR      r1,[r1,#0xc]          ;884
00001a  0749              LSLS     r1,r1,#29             ;884
00001c  d5fb              BPL      |L4.22|
00001e  2002              MOVS     r0,#2                 ;885
000020  4770              BX       lr
;;;892    
                          ENDP

000022  0000              DCW      0x0000
                  |L4.36|
                          DCD      0x40022000

                          AREA ||i.fmc_bank0_unlock||, CODE, READONLY, ALIGN=2

                  fmc_bank0_unlock PROC
;;;91     */
;;;92     void fmc_bank0_unlock(void)
000000  4804              LDR      r0,|L5.20|
;;;93     {
;;;94         if((RESET != (FMC_CTL0 & FMC_CTL0_LK))){
000002  6901              LDR      r1,[r0,#0x10]
000004  0609              LSLS     r1,r1,#24
000006  d503              BPL      |L5.16|
;;;95             /* write the FMC unlock key */
;;;96             FMC_KEY0 = UNLOCK_KEY0;
000008  4903              LDR      r1,|L5.24|
00000a  6041              STR      r1,[r0,#4]
;;;97             FMC_KEY0 = UNLOCK_KEY1;
00000c  4903              LDR      r1,|L5.28|
00000e  6041              STR      r1,[r0,#4]
                  |L5.16|
;;;98         }
;;;99     }
000010  4770              BX       lr
;;;100    
                          ENDP

000012  0000              DCW      0x0000
                  |L5.20|
                          DCD      0x40022000
                  |L5.24|
                          DCD      0x45670123
                  |L5.28|
                          DCD      0xcdef89ab

                          AREA ||i.fmc_bank1_erase||, CODE, READONLY, ALIGN=2

                  fmc_bank1_erase PROC
;;;297    */
;;;298    fmc_state_enum fmc_bank1_erase(void)
000000  b530              PUSH     {r4,r5,lr}
;;;299    {
;;;300        fmc_state_enum fmc_state = FMC_READY;
;;;301        /* wait for the FMC ready */
;;;302        fmc_state = fmc_bank1_ready_wait(FMC_TIMEOUT_COUNT);
000002  f44f2570          MOV      r5,#0xf0000
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       fmc_bank1_ready_wait
;;;303      
;;;304       if(FMC_READY == fmc_state){
00000c  2800              CMP      r0,#0
00000e  d10f              BNE      |L6.48|
;;;305            /* start FMC bank1 erase */
;;;306            FMC_CTL1 |= FMC_CTL1_MER;
000010  4c08              LDR      r4,|L6.52|
000012  6d20              LDR      r0,[r4,#0x50]
000014  f0400004          ORR      r0,r0,#4
000018  6520              STR      r0,[r4,#0x50]
;;;307            FMC_CTL1 |= FMC_CTL1_START;
00001a  6d20              LDR      r0,[r4,#0x50]
00001c  f0400040          ORR      r0,r0,#0x40
000020  6520              STR      r0,[r4,#0x50]
;;;308            /* wait for the FMC ready */
;;;309            fmc_state = fmc_bank1_ready_wait(FMC_TIMEOUT_COUNT);
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       fmc_bank1_ready_wait
;;;310            /* reset the MER bit */
;;;311            FMC_CTL1 &= ~FMC_CTL1_MER;
000028  6d21              LDR      r1,[r4,#0x50]
00002a  f0210104          BIC      r1,r1,#4
00002e  6521              STR      r1,[r4,#0x50]
                  |L6.48|
;;;312        }
;;;313        /* return the fmc state */
;;;314        return fmc_state;
;;;315    }
000030  bd30              POP      {r4,r5,pc}
;;;316    
                          ENDP

000032  0000              DCW      0x0000
                  |L6.52|
                          DCD      0x40022000

                          AREA ||i.fmc_bank1_lock||, CODE, READONLY, ALIGN=2

                  fmc_bank1_lock PROC
;;;155    */
;;;156    void fmc_bank1_lock(void)
000000  4802              LDR      r0,|L7.12|
;;;157    {
;;;158        /* set the LK bit*/
;;;159        FMC_CTL1 |= FMC_CTL1_LK;
000002  6d01              LDR      r1,[r0,#0x50]
000004  f0410180          ORR      r1,r1,#0x80
000008  6501              STR      r1,[r0,#0x50]
;;;160    }
00000a  4770              BX       lr
;;;161    
                          ENDP

                  |L7.12|
                          DCD      0x40022000

                          AREA ||i.fmc_bank1_ready_wait||, CODE, READONLY, ALIGN=1

                  fmc_bank1_ready_wait PROC
;;;948    */
;;;949    fmc_state_enum fmc_bank1_ready_wait(uint32_t timeout)
000000  b500              PUSH     {lr}
;;;950    {
000002  4603              MOV      r3,r0
                  |L8.4|
;;;951        fmc_state_enum fmc_state = FMC_BUSY;
;;;952      
;;;953        /* wait for FMC ready */
;;;954        do{
;;;955            /* get FMC state */
;;;956            fmc_state = fmc_bank1_state_get();
000004  f7fffffe          BL       fmc_bank1_state_get
;;;957            timeout--;
000008  1e5b              SUBS     r3,r3,#1
;;;958        }while((FMC_BUSY == fmc_state) && (0x00U != timeout));
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L8.18|
00000e  2b00              CMP      r3,#0
000010  d1f8              BNE      |L8.4|
                  |L8.18|
;;;959        
;;;960        if(FMC_BUSY == fmc_state){
000012  2801              CMP      r0,#1
000014  d100              BNE      |L8.24|
;;;961            fmc_state = FMC_TOERR;
000016  2004              MOVS     r0,#4
                  |L8.24|
;;;962        }
;;;963        /* return the FMC state */
;;;964        return fmc_state;
;;;965    }
000018  bd00              POP      {pc}
                          ENDP


                          AREA ||i.fmc_bank1_state_get||, CODE, READONLY, ALIGN=2

                  fmc_bank1_state_get PROC
;;;898    */
;;;899    fmc_state_enum fmc_bank1_state_get(void)
000000  2000              MOVS     r0,#0
;;;900    {
;;;901        fmc_state_enum fmc_state = FMC_READY;
;;;902    
;;;903        if((uint32_t)0x00U != (FMC_STAT1 & FMC_STAT1_BUSY)){
000002  4908              LDR      r1,|L9.36|
000004  6cca              LDR      r2,[r1,#0x4c]
000006  07d2              LSLS     r2,r2,#31
000008  d001              BEQ      |L9.14|
;;;904            fmc_state = FMC_BUSY;
00000a  2001              MOVS     r0,#1
;;;905        }else{
;;;906            if((uint32_t)0x00U != (FMC_STAT1 & FMC_STAT1_WPERR)){
;;;907                fmc_state = FMC_WPERR;
;;;908            }else{
;;;909                if((uint32_t)0x00U != (FMC_STAT1 & FMC_STAT1_PGERR)){
;;;910                    fmc_state = FMC_PGERR; 
;;;911                }
;;;912            }
;;;913        }
;;;914    
;;;915        /* return the FMC state */
;;;916        return fmc_state;
;;;917    }
00000c  4770              BX       lr
                  |L9.14|
00000e  6cca              LDR      r2,[r1,#0x4c]         ;906
000010  06d2              LSLS     r2,r2,#27             ;906
000012  d501              BPL      |L9.24|
000014  2003              MOVS     r0,#3                 ;907
                  |L9.22|
000016  4770              BX       lr
                  |L9.24|
000018  6cc9              LDR      r1,[r1,#0x4c]         ;909
00001a  0749              LSLS     r1,r1,#29             ;909
00001c  d5fb              BPL      |L9.22|
00001e  2002              MOVS     r0,#2                 ;910
000020  4770              BX       lr
;;;918    
                          ENDP

000022  0000              DCW      0x0000
                  |L9.36|
                          DCD      0x40022000

                          AREA ||i.fmc_bank1_unlock||, CODE, READONLY, ALIGN=2

                  fmc_bank1_unlock PROC
;;;107    */
;;;108    void fmc_bank1_unlock(void)
000000  4804              LDR      r0,|L10.20|
;;;109    {
;;;110        if((RESET != (FMC_CTL1 & FMC_CTL1_LK))){
000002  6d01              LDR      r1,[r0,#0x50]
000004  0609              LSLS     r1,r1,#24
000006  d503              BPL      |L10.16|
;;;111            /* write the FMC unlock key */
;;;112            FMC_KEY1 = UNLOCK_KEY0;
000008  4903              LDR      r1,|L10.24|
00000a  6441              STR      r1,[r0,#0x44]
;;;113            FMC_KEY1 = UNLOCK_KEY1;
00000c  4903              LDR      r1,|L10.28|
00000e  6441              STR      r1,[r0,#0x44]
                  |L10.16|
;;;114        }
;;;115    }
000010  4770              BX       lr
;;;116    
                          ENDP

000012  0000              DCW      0x0000
                  |L10.20|
                          DCD      0x40022000
                  |L10.24|
                          DCD      0x45670123
                  |L10.28|
                          DCD      0xcdef89ab

                          AREA ||i.fmc_flag_clear||, CODE, READONLY, ALIGN=2

                  fmc_flag_clear PROC
;;;807    */
;;;808    void fmc_flag_clear(uint32_t flag)
000000  4905              LDR      r1,|L11.24|
;;;809    {
;;;810        FMC_REG_VAL(flag) |= BIT(FMC_BIT_POS(flag));
000002  eb011190          ADD      r1,r1,r0,LSR #6
000006  680a              LDR      r2,[r1,#0]
000008  f000031f          AND      r3,r0,#0x1f
00000c  2001              MOVS     r0,#1
00000e  4098              LSLS     r0,r0,r3
000010  4302              ORRS     r2,r2,r0
000012  600a              STR      r2,[r1,#0]
;;;811    }
000014  4770              BX       lr
;;;812    
                          ENDP

000016  0000              DCW      0x0000
                  |L11.24|
                          DCD      0x40022000

                          AREA ||i.fmc_flag_get||, CODE, READONLY, ALIGN=2

                  fmc_flag_get PROC
;;;785    */
;;;786    FlagStatus fmc_flag_get(uint32_t flag)
000000  4a06              LDR      r2,|L12.28|
;;;787    {
;;;788        if(RESET != (FMC_REG_VAL(flag) & BIT(FMC_BIT_POS(flag)))){
000002  eb021190          ADD      r1,r2,r0,LSR #6
000006  6809              LDR      r1,[r1,#0]
000008  f000021f          AND      r2,r0,#0x1f
00000c  2001              MOVS     r0,#1
00000e  4090              LSLS     r0,r0,r2
000010  4201              TST      r1,r0
000012  d001              BEQ      |L12.24|
;;;789            return SET;
000014  2001              MOVS     r0,#1
;;;790        }else{
;;;791            return RESET;
;;;792        }
;;;793    }
000016  4770              BX       lr
                  |L12.24|
000018  2000              MOVS     r0,#0                 ;791
00001a  4770              BX       lr
;;;794    
                          ENDP

                  |L12.28|
                          DCD      0x40022000

                          AREA ||i.fmc_halfword_program||, CODE, READONLY, ALIGN=2

                  fmc_halfword_program PROC
;;;376    */
;;;377    fmc_state_enum fmc_halfword_program(uint32_t address, uint16_t data)
000000  b5f0              PUSH     {r4-r7,lr}
;;;378    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;379        fmc_state_enum fmc_state = FMC_READY;
;;;380        if(FMC_BANK0_SIZE > FMC_SIZE){
000006  4820              LDR      r0,|L13.136|
;;;381            if(FMC_BANK0_END_ADDRESS > address){
;;;382                fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT); 
;;;383      
;;;384                if(FMC_READY == fmc_state){
;;;385                    /* set the PG bit to start program */
;;;386                    FMC_CTL0 |= FMC_CTL0_PG;
000008  4e20              LDR      r6,|L13.140|
00000a  f44f2770          MOV      r7,#0xf0000           ;382
00000e  8800              LDRH     r0,[r0,#0]            ;380
000010  f5b07f00          CMP      r0,#0x200             ;380
000014  d226              BCS      |L13.100|
000016  481e              LDR      r0,|L13.144|
000018  4284              CMP      r4,r0                 ;381
00001a  d211              BCS      |L13.64|
00001c  4638              MOV      r0,r7                 ;382
00001e  f7fffffe          BL       fmc_bank0_ready_wait
000022  2800              CMP      r0,#0                 ;384
000024  d10b              BNE      |L13.62|
000026  6930              LDR      r0,[r6,#0x10]
000028  f0400001          ORR      r0,r0,#1
00002c  6130              STR      r0,[r6,#0x10]
;;;387                    REG16(address) = data;
00002e  8025              STRH     r5,[r4,#0]
;;;388                    /* wait for the FMC ready */
;;;389                    fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT);
000030  4638              MOV      r0,r7
000032  f7fffffe          BL       fmc_bank0_ready_wait
;;;390                    /* reset the PG bit */
;;;391                    FMC_CTL0 &= ~FMC_CTL0_PG;
000036  6931              LDR      r1,[r6,#0x10]
000038  f0210101          BIC      r1,r1,#1
00003c  6131              STR      r1,[r6,#0x10]
                  |L13.62|
;;;392                }
;;;393            }else{
;;;394                fmc_state = fmc_bank1_ready_wait(FMC_TIMEOUT_COUNT); 
;;;395      
;;;396                if(FMC_READY == fmc_state){
;;;397                    /* set the PG bit to start program */
;;;398                    FMC_CTL1 |= FMC_CTL1_PG;
;;;399                    REG16(address) = data;
;;;400                    /* wait for the FMC ready */
;;;401                    fmc_state = fmc_bank1_ready_wait(FMC_TIMEOUT_COUNT);
;;;402                    /* reset the PG bit */
;;;403                    FMC_CTL1 &= ~FMC_CTL1_PG;
;;;404                }
;;;405            }
;;;406        }else{
;;;407            fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT);
;;;408      
;;;409            if(FMC_READY == fmc_state){
;;;410                /* set the PG bit to start program */
;;;411                FMC_CTL0 |= FMC_CTL0_PG;
;;;412                REG16(address) = data;
;;;413                /* wait for the FMC ready */
;;;414                fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT);
;;;415                /* reset the PG bit */
;;;416                FMC_CTL0 &= ~FMC_CTL0_PG;
;;;417            } 
;;;418        }
;;;419        /* return the FMC state */
;;;420        return fmc_state;
;;;421    }
00003e  bdf0              POP      {r4-r7,pc}
                  |L13.64|
000040  4638              MOV      r0,r7                 ;394
000042  f7fffffe          BL       fmc_bank1_ready_wait
000046  2800              CMP      r0,#0                 ;396
000048  d1f9              BNE      |L13.62|
00004a  6d30              LDR      r0,[r6,#0x50]         ;398
00004c  f0400001          ORR      r0,r0,#1              ;398
000050  6530              STR      r0,[r6,#0x50]         ;398
000052  8025              STRH     r5,[r4,#0]            ;399
000054  4638              MOV      r0,r7                 ;401
000056  f7fffffe          BL       fmc_bank1_ready_wait
00005a  6d31              LDR      r1,[r6,#0x50]         ;403
00005c  f0210101          BIC      r1,r1,#1              ;403
000060  6531              STR      r1,[r6,#0x50]         ;403
                  |L13.98|
000062  bdf0              POP      {r4-r7,pc}
                  |L13.100|
000064  4638              MOV      r0,r7                 ;407
000066  f7fffffe          BL       fmc_bank0_ready_wait
00006a  2800              CMP      r0,#0                 ;409
00006c  d1f9              BNE      |L13.98|
00006e  6930              LDR      r0,[r6,#0x10]         ;411
000070  f0400001          ORR      r0,r0,#1              ;411
000074  6130              STR      r0,[r6,#0x10]         ;411
000076  8025              STRH     r5,[r4,#0]            ;412
000078  4638              MOV      r0,r7                 ;414
00007a  f7fffffe          BL       fmc_bank0_ready_wait
00007e  6931              LDR      r1,[r6,#0x10]         ;416
000080  f0210101          BIC      r1,r1,#1              ;416
000084  6131              STR      r1,[r6,#0x10]         ;416
000086  bdf0              POP      {r4-r7,pc}
;;;422    
                          ENDP

                  |L13.136|
                          DCD      0x1ffff7e0
                  |L13.140|
                          DCD      0x40022000
                  |L13.144|
                          DCD      0x0807ffff

                          AREA ||i.fmc_interrupt_disable||, CODE, READONLY, ALIGN=2

                  fmc_interrupt_disable PROC
;;;764    */
;;;765    void fmc_interrupt_disable(uint32_t interrupt)
000000  4905              LDR      r1,|L14.24|
;;;766    {
;;;767        FMC_REG_VAL(interrupt) &= ~BIT(FMC_BIT_POS(interrupt));
000002  eb011190          ADD      r1,r1,r0,LSR #6
000006  680a              LDR      r2,[r1,#0]
000008  f000031f          AND      r3,r0,#0x1f
00000c  2001              MOVS     r0,#1
00000e  4098              LSLS     r0,r0,r3
000010  4382              BICS     r2,r2,r0
000012  600a              STR      r2,[r1,#0]
;;;768    }
000014  4770              BX       lr
;;;769    
                          ENDP

000016  0000              DCW      0x0000
                  |L14.24|
                          DCD      0x40022000

                          AREA ||i.fmc_interrupt_enable||, CODE, READONLY, ALIGN=2

                  fmc_interrupt_enable PROC
;;;748    */
;;;749    void fmc_interrupt_enable(uint32_t interrupt)
000000  4905              LDR      r1,|L15.24|
;;;750    {
;;;751        FMC_REG_VAL(interrupt) |= BIT(FMC_BIT_POS(interrupt));
000002  eb011190          ADD      r1,r1,r0,LSR #6
000006  680a              LDR      r2,[r1,#0]
000008  f000031f          AND      r3,r0,#0x1f
00000c  2001              MOVS     r0,#1
00000e  4098              LSLS     r0,r0,r3
000010  4302              ORRS     r2,r2,r0
000012  600a              STR      r2,[r1,#0]
;;;752    }
000014  4770              BX       lr
;;;753    
                          ENDP

000016  0000              DCW      0x0000
                  |L15.24|
                          DCD      0x40022000

                          AREA ||i.fmc_interrupt_flag_clear||, CODE, READONLY, ALIGN=2

                  fmc_interrupt_flag_clear PROC
;;;862    */
;;;863    void fmc_interrupt_flag_clear(fmc_interrupt_flag_enum flag)
000000  4905              LDR      r1,|L16.24|
;;;864    {
;;;865        FMC_REG_VALS(flag) |= BIT(FMC_BIT_POS0(flag));
000002  eb013110          ADD      r1,r1,r0,LSR #12
000006  680a              LDR      r2,[r1,#0]
000008  f3c01384          UBFX     r3,r0,#6,#5
00000c  2001              MOVS     r0,#1
00000e  4098              LSLS     r0,r0,r3
000010  4302              ORRS     r2,r2,r0
000012  600a              STR      r2,[r1,#0]
;;;866    }
000014  4770              BX       lr
;;;867    
                          ENDP

000016  0000              DCW      0x0000
                  |L16.24|
                          DCD      0x40022000

                          AREA ||i.fmc_interrupt_flag_get||, CODE, READONLY, ALIGN=2

                  fmc_interrupt_flag_get PROC
;;;825    */
;;;826    FlagStatus fmc_interrupt_flag_get(fmc_interrupt_flag_enum flag)
000000  b570              PUSH     {r4-r6,lr}
;;;827    {
;;;828        uint32_t ret1 = RESET;
;;;829        uint32_t ret2 = RESET;
;;;830        
;;;831        if(FMC_STAT0_REG_OFFSET == FMC_REG_OFFSET_GET(flag)){
;;;832            /* get the staus of interrupt flag */
;;;833            ret1 = (uint32_t)(FMC_REG_VALS(flag) & BIT(FMC_BIT_POS0(flag)));
000002  f3c01584          UBFX     r5,r0,#6,#5
000006  2201              MOVS     r2,#1
000008  fa02f105          LSL      r1,r2,r5
00000c  4c0c              LDR      r4,|L17.64|
;;;834            /* get the staus of interrupt enale bit */
;;;835            ret2 = (uint32_t)(FMC_CTL0 & BIT(FMC_BIT_POS1(flag)));
00000e  f000051f          AND      r5,r0,#0x1f
000012  260c              MOVS     r6,#0xc               ;831
000014  40aa              LSLS     r2,r2,r5
000016  eb043310          ADD      r3,r4,r0,LSR #12      ;833
00001a  ebb63f10          CMP      r6,r0,LSR #12         ;831
00001e  d104              BNE      |L17.42|
000020  6818              LDR      r0,[r3,#0]            ;833
000022  4008              ANDS     r0,r0,r1              ;833
000024  6921              LDR      r1,[r4,#0x10]
000026  4011              ANDS     r1,r1,r2
000028  e003              B        |L17.50|
                  |L17.42|
;;;836        }else{
;;;837            /* get the staus of interrupt flag */
;;;838            ret1 = (uint32_t)(FMC_REG_VALS(flag) & BIT(FMC_BIT_POS0(flag)));
00002a  6818              LDR      r0,[r3,#0]
00002c  4008              ANDS     r0,r0,r1
;;;839            /* get the staus of interrupt enale bit */
;;;840            ret2 = (uint32_t)(FMC_CTL1 & BIT(FMC_BIT_POS1(flag)));
00002e  6d21              LDR      r1,[r4,#0x50]
000030  4011              ANDS     r1,r1,r2
                  |L17.50|
;;;841        }
;;;842    
;;;843        if(ret1 && ret2){
000032  b110              CBZ      r0,|L17.58|
000034  b109              CBZ      r1,|L17.58|
;;;844            return SET;
000036  2001              MOVS     r0,#1
;;;845        }else{
;;;846            return RESET;
;;;847        }
;;;848    }
000038  bd70              POP      {r4-r6,pc}
                  |L17.58|
00003a  2000              MOVS     r0,#0                 ;846
00003c  bd70              POP      {r4-r6,pc}
;;;849    
                          ENDP

00003e  0000              DCW      0x0000
                  |L17.64|
                          DCD      0x40022000

                          AREA ||i.fmc_lock||, CODE, READONLY, ALIGN=2

                  fmc_lock PROC
;;;122    */
;;;123    void fmc_lock(void)
000000  4807              LDR      r0,|L18.32|
;;;124    {
;;;125        /* set the LK bit */
;;;126        FMC_CTL0 |= FMC_CTL0_LK;
000002  6901              LDR      r1,[r0,#0x10]
000004  f0410180          ORR      r1,r1,#0x80
000008  6101              STR      r1,[r0,#0x10]
;;;127        
;;;128        if(FMC_BANK0_SIZE < FMC_SIZE){
00000a  4906              LDR      r1,|L18.36|
00000c  8809              LDRH     r1,[r1,#0]
00000e  f5b17f00          CMP      r1,#0x200
000012  d903              BLS      |L18.28|
;;;129            /* set the LK bit */
;;;130            FMC_CTL1 |= FMC_CTL1_LK;
000014  6d01              LDR      r1,[r0,#0x50]
000016  f0410180          ORR      r1,r1,#0x80
00001a  6501              STR      r1,[r0,#0x50]
                  |L18.28|
;;;131        }
;;;132    }
00001c  4770              BX       lr
;;;133    
                          ENDP

00001e  0000              DCW      0x0000
                  |L18.32|
                          DCD      0x40022000
                  |L18.36|
                          DCD      0x1ffff7e0

                          AREA ||i.fmc_mass_erase||, CODE, READONLY, ALIGN=2

                  fmc_mass_erase PROC
;;;224    */
;;;225    fmc_state_enum fmc_mass_erase(void)
000000  b530              PUSH     {r4,r5,lr}
;;;226    {
;;;227        fmc_state_enum fmc_state;
;;;228        if(FMC_BANK0_SIZE < FMC_SIZE){
000002  4822              LDR      r0,|L19.140|
;;;229            /* wait for the FMC ready */
;;;230            fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT);
;;;231            if(FMC_READY == fmc_state){
;;;232                /* start whole chip erase */
;;;233                FMC_CTL0 |= FMC_CTL0_MER;
000004  4c22              LDR      r4,|L19.144|
000006  f44f2570          MOV      r5,#0xf0000           ;230
00000a  8800              LDRH     r0,[r0,#0]            ;228
00000c  f5b07f00          CMP      r0,#0x200             ;228
000010  d927              BLS      |L19.98|
000012  4628              MOV      r0,r5                 ;230
000014  f7fffffe          BL       fmc_bank0_ready_wait
000018  b970              CBNZ     r0,|L19.56|
00001a  6920              LDR      r0,[r4,#0x10]
00001c  f0400004          ORR      r0,r0,#4
000020  6120              STR      r0,[r4,#0x10]
;;;234                FMC_CTL0 |= FMC_CTL0_START;
000022  6920              LDR      r0,[r4,#0x10]
000024  f0400040          ORR      r0,r0,#0x40
000028  6120              STR      r0,[r4,#0x10]
;;;235                /* wait for the FMC ready */
;;;236                fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT);
00002a  4628              MOV      r0,r5
00002c  f7fffffe          BL       fmc_bank0_ready_wait
;;;237                /* reset the MER bit */
;;;238                FMC_CTL0 &= ~FMC_CTL0_MER;
000030  6920              LDR      r0,[r4,#0x10]
000032  f0200004          BIC      r0,r0,#4
000036  6120              STR      r0,[r4,#0x10]
                  |L19.56|
;;;239            }
;;;240            fmc_state = fmc_bank1_ready_wait(FMC_TIMEOUT_COUNT);
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       fmc_bank1_ready_wait
;;;241            if(FMC_READY == fmc_state){
00003e  2800              CMP      r0,#0
000040  d10e              BNE      |L19.96|
;;;242                /* start whole chip erase */
;;;243                FMC_CTL1 |= FMC_CTL1_MER;
000042  6d20              LDR      r0,[r4,#0x50]
000044  f0400004          ORR      r0,r0,#4
000048  6520              STR      r0,[r4,#0x50]
;;;244                FMC_CTL1 |= FMC_CTL1_START;
00004a  6d20              LDR      r0,[r4,#0x50]
00004c  f0400040          ORR      r0,r0,#0x40
000050  6520              STR      r0,[r4,#0x50]
;;;245                /* wait for the FMC ready */
;;;246                fmc_state = fmc_bank1_ready_wait(FMC_TIMEOUT_COUNT);
000052  4628              MOV      r0,r5
000054  f7fffffe          BL       fmc_bank1_ready_wait
;;;247                /* reset the MER bit */
;;;248                FMC_CTL1 &= ~FMC_CTL1_MER;
000058  6d21              LDR      r1,[r4,#0x50]
00005a  f0210104          BIC      r1,r1,#4
00005e  6521              STR      r1,[r4,#0x50]
                  |L19.96|
;;;249            }
;;;250        }else{
;;;251            fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT);
;;;252      
;;;253            if(FMC_READY == fmc_state){
;;;254                /* start whole chip erase */
;;;255                FMC_CTL0 |= FMC_CTL0_MER;
;;;256                FMC_CTL0 |= FMC_CTL0_START;    
;;;257                /* wait for the FMC ready */
;;;258                fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT);
;;;259                /* reset the MER bit */
;;;260                FMC_CTL0 &= ~FMC_CTL0_MER;
;;;261            }
;;;262        }
;;;263        /* return the FMC state  */
;;;264        return fmc_state;
;;;265    }
000060  bd30              POP      {r4,r5,pc}
                  |L19.98|
000062  4628              MOV      r0,r5                 ;251
000064  f7fffffe          BL       fmc_bank0_ready_wait
000068  2800              CMP      r0,#0                 ;253
00006a  d1f9              BNE      |L19.96|
00006c  6920              LDR      r0,[r4,#0x10]         ;255
00006e  f0400004          ORR      r0,r0,#4              ;255
000072  6120              STR      r0,[r4,#0x10]         ;255
000074  6920              LDR      r0,[r4,#0x10]         ;256
000076  f0400040          ORR      r0,r0,#0x40           ;256
00007a  6120              STR      r0,[r4,#0x10]         ;256
00007c  4628              MOV      r0,r5                 ;258
00007e  f7fffffe          BL       fmc_bank0_ready_wait
000082  6921              LDR      r1,[r4,#0x10]         ;260
000084  f0210104          BIC      r1,r1,#4              ;260
000088  6121              STR      r1,[r4,#0x10]         ;260
00008a  bd30              POP      {r4,r5,pc}
;;;266    
                          ENDP

                  |L19.140|
                          DCD      0x1ffff7e0
                  |L19.144|
                          DCD      0x40022000

                          AREA ||i.fmc_page_erase||, CODE, READONLY, ALIGN=2

                  fmc_page_erase PROC
;;;167    */
;;;168    fmc_state_enum fmc_page_erase(uint32_t page_address)
000000  b570              PUSH     {r4-r6,lr}
;;;169    {
000002  4604              MOV      r4,r0
;;;170        fmc_state_enum fmc_state;
;;;171        
;;;172        if(FMC_BANK0_SIZE < FMC_SIZE){
000004  4828              LDR      r0,|L20.168|
;;;173            if(FMC_BANK0_END_ADDRESS > page_address){
;;;174                fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT);
;;;175                /* if the last operation is completed, start page erase */
;;;176                if(FMC_READY == fmc_state){
;;;177                    FMC_CTL0 |= FMC_CTL0_PER;
000006  4d29              LDR      r5,|L20.172|
000008  f44f2670          MOV      r6,#0xf0000           ;174
00000c  8800              LDRH     r0,[r0,#0]            ;172
00000e  f5b07f00          CMP      r0,#0x200             ;172
000012  d932              BLS      |L20.122|
000014  4826              LDR      r0,|L20.176|
000016  4284              CMP      r4,r0                 ;173
000018  d215              BCS      |L20.70|
00001a  4630              MOV      r0,r6                 ;174
00001c  f7fffffe          BL       fmc_bank0_ready_wait
000020  2800              CMP      r0,#0                 ;176
000022  d10f              BNE      |L20.68|
000024  6928              LDR      r0,[r5,#0x10]
000026  f0400002          ORR      r0,r0,#2
00002a  6128              STR      r0,[r5,#0x10]
;;;178                    FMC_ADDR0 = page_address;
00002c  616c              STR      r4,[r5,#0x14]
;;;179                    FMC_CTL0 |= FMC_CTL0_START;
00002e  6928              LDR      r0,[r5,#0x10]
000030  f0400040          ORR      r0,r0,#0x40
000034  6128              STR      r0,[r5,#0x10]
;;;180                    /* wait for the FMC ready */
;;;181                    fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT);
000036  4630              MOV      r0,r6
000038  f7fffffe          BL       fmc_bank0_ready_wait
;;;182                    /* reset the PER bit */
;;;183                    FMC_CTL0 &= ~FMC_CTL0_PER;
00003c  6929              LDR      r1,[r5,#0x10]
00003e  f0210102          BIC      r1,r1,#2
000042  6129              STR      r1,[r5,#0x10]
                  |L20.68|
;;;184                }
;;;185            }else{
;;;186                /* wait for the FMC ready */
;;;187                fmc_state = fmc_bank1_ready_wait(FMC_TIMEOUT_COUNT);
;;;188                /* if the last operation is completed, start page erase */
;;;189                if(FMC_READY == fmc_state){
;;;190                    FMC_CTL1 |= FMC_CTL1_PER;
;;;191                    FMC_ADDR1 = page_address;
;;;192                    if(FMC_OBSTAT & FMC_OBSTAT_SPC){
;;;193                        FMC_ADDR0 = page_address;
;;;194                    }
;;;195                    FMC_CTL1 |= FMC_CTL1_START;
;;;196                    /* wait for the FMC ready */
;;;197                    fmc_state = fmc_bank1_ready_wait(FMC_TIMEOUT_COUNT);
;;;198                    /* reset the PER bit */
;;;199                    FMC_CTL1 &= ~FMC_CTL1_PER;
;;;200                }
;;;201            }
;;;202        }else{
;;;203            fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT);
;;;204            /* if the last operation is completed, start page erase */
;;;205            if(FMC_READY == fmc_state){
;;;206                FMC_CTL0 |= FMC_CTL0_PER;
;;;207                FMC_ADDR0 = page_address;
;;;208                FMC_CTL0 |= FMC_CTL0_START;
;;;209                /* wait for the FMC ready */
;;;210                fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT);
;;;211                /* reset the PER bit */
;;;212                FMC_CTL0 &= ~FMC_CTL0_PER;
;;;213            }
;;;214        }
;;;215        /* return the FMC state */
;;;216        return fmc_state;
;;;217    }
000044  bd70              POP      {r4-r6,pc}
                  |L20.70|
000046  4630              MOV      r0,r6                 ;187
000048  f7fffffe          BL       fmc_bank1_ready_wait
00004c  2800              CMP      r0,#0                 ;189
00004e  d1f9              BNE      |L20.68|
000050  6d28              LDR      r0,[r5,#0x50]         ;190
000052  f0400002          ORR      r0,r0,#2              ;190
000056  6528              STR      r0,[r5,#0x50]         ;190
000058  656c              STR      r4,[r5,#0x54]         ;191
00005a  69e8              LDR      r0,[r5,#0x1c]         ;192
00005c  0780              LSLS     r0,r0,#30             ;192
00005e  d500              BPL      |L20.98|
000060  616c              STR      r4,[r5,#0x14]         ;193
                  |L20.98|
000062  6d28              LDR      r0,[r5,#0x50]         ;195
000064  f0400040          ORR      r0,r0,#0x40           ;195
000068  6528              STR      r0,[r5,#0x50]         ;195
00006a  4630              MOV      r0,r6                 ;197
00006c  f7fffffe          BL       fmc_bank1_ready_wait
000070  6d29              LDR      r1,[r5,#0x50]         ;199
000072  f0210102          BIC      r1,r1,#2              ;199
000076  6529              STR      r1,[r5,#0x50]         ;199
                  |L20.120|
000078  bd70              POP      {r4-r6,pc}
                  |L20.122|
00007a  4630              MOV      r0,r6                 ;203
00007c  f7fffffe          BL       fmc_bank0_ready_wait
000080  2800              CMP      r0,#0                 ;205
000082  d1f9              BNE      |L20.120|
000084  6928              LDR      r0,[r5,#0x10]         ;206
000086  f0400002          ORR      r0,r0,#2              ;206
00008a  6128              STR      r0,[r5,#0x10]         ;206
00008c  616c              STR      r4,[r5,#0x14]         ;207
00008e  6928              LDR      r0,[r5,#0x10]         ;208
000090  f0400040          ORR      r0,r0,#0x40           ;208
000094  6128              STR      r0,[r5,#0x10]         ;208
000096  4630              MOV      r0,r6                 ;210
000098  f7fffffe          BL       fmc_bank0_ready_wait
00009c  6929              LDR      r1,[r5,#0x10]         ;212
00009e  f0210102          BIC      r1,r1,#2              ;212
0000a2  6129              STR      r1,[r5,#0x10]         ;212
0000a4  bd70              POP      {r4-r6,pc}
;;;218    
                          ENDP

0000a6  0000              DCW      0x0000
                  |L20.168|
                          DCD      0x1ffff7e0
                  |L20.172|
                          DCD      0x40022000
                  |L20.176|
                          DCD      0x0807ffff

                          AREA ||i.fmc_unlock||, CODE, READONLY, ALIGN=2

                  fmc_unlock PROC
;;;65     */
;;;66     void fmc_unlock(void)
000000  4809              LDR      r0,|L21.40|
;;;67     {
;;;68         if((RESET != (FMC_CTL0 & FMC_CTL0_LK))){
000002  6901              LDR      r1,[r0,#0x10]
;;;69             /* write the FMC unlock key */
;;;70             FMC_KEY0 = UNLOCK_KEY0;
000004  4a09              LDR      r2,|L21.44|
000006  060b              LSLS     r3,r1,#24             ;68
;;;71             FMC_KEY0 = UNLOCK_KEY1;
000008  4909              LDR      r1,|L21.48|
00000a  d501              BPL      |L21.16|
00000c  6042              STR      r2,[r0,#4]            ;70
00000e  6041              STR      r1,[r0,#4]
                  |L21.16|
;;;72         }
;;;73     
;;;74         if(FMC_BANK0_SIZE < FMC_SIZE){
000010  4b08              LDR      r3,|L21.52|
000012  881b              LDRH     r3,[r3,#0]
000014  f5b37f00          CMP      r3,#0x200
000018  d904              BLS      |L21.36|
;;;75             /* write the FMC unlock key */
;;;76             if(RESET != (FMC_CTL1 & FMC_CTL1_LK)){
00001a  6d03              LDR      r3,[r0,#0x50]
00001c  061b              LSLS     r3,r3,#24
00001e  d501              BPL      |L21.36|
;;;77                 FMC_KEY1 = UNLOCK_KEY0;
000020  6442              STR      r2,[r0,#0x44]
;;;78                 FMC_KEY1 = UNLOCK_KEY1;
000022  6441              STR      r1,[r0,#0x44]
                  |L21.36|
;;;79             }
;;;80         }
;;;81     }
000024  4770              BX       lr
;;;82     
                          ENDP

000026  0000              DCW      0x0000
                  |L21.40|
                          DCD      0x40022000
                  |L21.44|
                          DCD      0x45670123
                  |L21.48|
                          DCD      0xcdef89ab
                  |L21.52|
                          DCD      0x1ffff7e0

                          AREA ||i.fmc_word_program||, CODE, READONLY, ALIGN=2

                  fmc_word_program PROC
;;;323    */
;;;324    fmc_state_enum fmc_word_program(uint32_t address, uint32_t data)
000000  b5f0              PUSH     {r4-r7,lr}
;;;325    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;326        fmc_state_enum fmc_state = FMC_READY;
;;;327        if(FMC_BANK0_SIZE < FMC_SIZE){
000006  4820              LDR      r0,|L22.136|
;;;328            if(FMC_BANK0_END_ADDRESS > address){
;;;329                fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT); 
;;;330      
;;;331                if(FMC_READY == fmc_state){
;;;332                    /* set the PG bit to start program */
;;;333                    FMC_CTL0 |= FMC_CTL0_PG;
000008  4e20              LDR      r6,|L22.140|
00000a  f44f2770          MOV      r7,#0xf0000           ;329
00000e  8800              LDRH     r0,[r0,#0]            ;327
000010  f5b07f00          CMP      r0,#0x200             ;327
000014  d926              BLS      |L22.100|
000016  481e              LDR      r0,|L22.144|
000018  4284              CMP      r4,r0                 ;328
00001a  d211              BCS      |L22.64|
00001c  4638              MOV      r0,r7                 ;329
00001e  f7fffffe          BL       fmc_bank0_ready_wait
000022  2800              CMP      r0,#0                 ;331
000024  d10b              BNE      |L22.62|
000026  6930              LDR      r0,[r6,#0x10]
000028  f0400001          ORR      r0,r0,#1
00002c  6130              STR      r0,[r6,#0x10]
;;;334                    REG32(address) = data;
00002e  6025              STR      r5,[r4,#0]
;;;335                    /* wait for the FMC ready */
;;;336                    fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT);
000030  4638              MOV      r0,r7
000032  f7fffffe          BL       fmc_bank0_ready_wait
;;;337                    /* reset the PG bit */
;;;338                    FMC_CTL0 &= ~FMC_CTL0_PG;
000036  6931              LDR      r1,[r6,#0x10]
000038  f0210101          BIC      r1,r1,#1
00003c  6131              STR      r1,[r6,#0x10]
                  |L22.62|
;;;339                }
;;;340            }else{
;;;341                fmc_state = fmc_bank1_ready_wait(FMC_TIMEOUT_COUNT); 
;;;342      
;;;343                if(FMC_READY == fmc_state){
;;;344                    /* set the PG bit to start program */
;;;345                    FMC_CTL1 |= FMC_CTL1_PG;
;;;346                    REG32(address) = data;
;;;347                    /* wait for the FMC ready */
;;;348                    fmc_state = fmc_bank1_ready_wait(FMC_TIMEOUT_COUNT);
;;;349                    /* reset the PG bit */
;;;350                    FMC_CTL1 &= ~FMC_CTL1_PG;
;;;351                }
;;;352            }
;;;353        }else{
;;;354            fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT);
;;;355      
;;;356            if(FMC_READY == fmc_state){
;;;357                /* set the PG bit to start program */
;;;358                FMC_CTL0 |= FMC_CTL0_PG;
;;;359                REG32(address) = data;
;;;360                /* wait for the FMC ready */
;;;361                fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT);
;;;362                /* reset the PG bit */
;;;363                FMC_CTL0 &= ~FMC_CTL0_PG;
;;;364            } 
;;;365        }
;;;366        /* return the FMC state */
;;;367        return fmc_state;
;;;368    }
00003e  bdf0              POP      {r4-r7,pc}
                  |L22.64|
000040  4638              MOV      r0,r7                 ;341
000042  f7fffffe          BL       fmc_bank1_ready_wait
000046  2800              CMP      r0,#0                 ;343
000048  d1f9              BNE      |L22.62|
00004a  6d30              LDR      r0,[r6,#0x50]         ;345
00004c  f0400001          ORR      r0,r0,#1              ;345
000050  6530              STR      r0,[r6,#0x50]         ;345
000052  6025              STR      r5,[r4,#0]            ;346
000054  4638              MOV      r0,r7                 ;348
000056  f7fffffe          BL       fmc_bank1_ready_wait
00005a  6d31              LDR      r1,[r6,#0x50]         ;350
00005c  f0210101          BIC      r1,r1,#1              ;350
000060  6531              STR      r1,[r6,#0x50]         ;350
                  |L22.98|
000062  bdf0              POP      {r4-r7,pc}
                  |L22.100|
000064  4638              MOV      r0,r7                 ;354
000066  f7fffffe          BL       fmc_bank0_ready_wait
00006a  2800              CMP      r0,#0                 ;356
00006c  d1f9              BNE      |L22.98|
00006e  6930              LDR      r0,[r6,#0x10]         ;358
000070  f0400001          ORR      r0,r0,#1              ;358
000074  6130              STR      r0,[r6,#0x10]         ;358
000076  6025              STR      r5,[r4,#0]            ;359
000078  4638              MOV      r0,r7                 ;361
00007a  f7fffffe          BL       fmc_bank0_ready_wait
00007e  6931              LDR      r1,[r6,#0x10]         ;363
000080  f0210101          BIC      r1,r1,#1              ;363
000084  6131              STR      r1,[r6,#0x10]         ;363
000086  bdf0              POP      {r4-r7,pc}
;;;369    
                          ENDP

                  |L22.136|
                          DCD      0x1ffff7e0
                  |L22.140|
                          DCD      0x40022000
                  |L22.144|
                          DCD      0x0807ffff

                          AREA ||i.fmc_wscnt_set||, CODE, READONLY, ALIGN=2

                  fmc_wscnt_set PROC
;;;49     */
;;;50     void fmc_wscnt_set(uint32_t wscnt)
000000  4a03              LDR      r2,|L23.16|
;;;51     {
;;;52         uint32_t reg;
;;;53         
;;;54         reg = FMC_WS;
000002  6811              LDR      r1,[r2,#0]
;;;55         /* set the wait state counter value */
;;;56         reg &= ~FMC_WS_WSCNT;
000004  f0210107          BIC      r1,r1,#7
;;;57         FMC_WS = (reg | wscnt);
000008  4301              ORRS     r1,r1,r0
00000a  6011              STR      r1,[r2,#0]
;;;58     }
00000c  4770              BX       lr
;;;59     
                          ENDP

00000e  0000              DCW      0x0000
                  |L23.16|
                          DCD      0x40022000

                          AREA ||i.ob_data_get||, CODE, READONLY, ALIGN=2

                  ob_data_get PROC
;;;702    */
;;;703    uint16_t ob_data_get(void)
000000  4802              LDR      r0,|L24.12|
;;;704    {
;;;705        return (uint16_t)(FMC_OBSTAT >> 10U);
000002  69c0              LDR      r0,[r0,#0x1c]
000004  f3c0208f          UBFX     r0,r0,#10,#16
;;;706    }
000008  4770              BX       lr
;;;707    
                          ENDP

00000a  0000              DCW      0x0000
                  |L24.12|
                          DCD      0x40022000

                          AREA ||i.ob_data_program||, CODE, READONLY, ALIGN=2

                  ob_data_program PROC
;;;663    */
;;;664    fmc_state_enum ob_data_program(uint32_t address, uint8_t data)
000000  b5f0              PUSH     {r4-r7,lr}
;;;665    {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;666        fmc_state_enum fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT);
000006  f44f2770          MOV      r7,#0xf0000
00000a  4638              MOV      r0,r7
00000c  f7fffffe          BL       fmc_bank0_ready_wait
;;;667    
;;;668        if(FMC_READY == fmc_state){
000010  2800              CMP      r0,#0
000012  d10e              BNE      |L25.50|
;;;669            /* set the OBPG bit */
;;;670            FMC_CTL0 |= FMC_CTL0_OBPG; 
000014  4c07              LDR      r4,|L25.52|
000016  6920              LDR      r0,[r4,#0x10]
000018  f0400010          ORR      r0,r0,#0x10
00001c  6120              STR      r0,[r4,#0x10]
;;;671            REG16(address) = data;
00001e  8035              STRH     r5,[r6,#0]
;;;672        
;;;673            /* wait for the FMC ready */
;;;674            fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT);
000020  4638              MOV      r0,r7
000022  f7fffffe          BL       fmc_bank0_ready_wait
;;;675        
;;;676            if(FMC_TOERR != fmc_state){
000026  2804              CMP      r0,#4
000028  d003              BEQ      |L25.50|
;;;677                /* reset the OBPG bit */
;;;678                FMC_CTL0 &= ~FMC_CTL0_OBPG;
00002a  6921              LDR      r1,[r4,#0x10]
00002c  f0210110          BIC      r1,r1,#0x10
000030  6121              STR      r1,[r4,#0x10]
                  |L25.50|
;;;679            }
;;;680        }
;;;681        /* return the FMC state */
;;;682        return fmc_state;
;;;683    }
000032  bdf0              POP      {r4-r7,pc}
;;;684    
                          ENDP

                  |L25.52|
                          DCD      0x40022000

                          AREA ||i.ob_erase||, CODE, READONLY, ALIGN=2

                  ob_erase PROC
;;;460    */
;;;461    fmc_state_enum ob_erase(void)
000000  b570              PUSH     {r4-r6,lr}
;;;462    {
;;;463        uint16_t temp_spc = FMC_NSPC;
000002  24a5              MOVS     r4,#0xa5
;;;464    
;;;465        fmc_state_enum fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT);
000004  f44f2670          MOV      r6,#0xf0000
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       fmc_bank0_ready_wait
00000e  4602              MOV      r2,r0
;;;466    
;;;467        /* check the option byte security protection value */
;;;468        if(RESET != ob_spc_get()){
000010  f7fffffe          BL       ob_spc_get
000014  b100              CBZ      r0,|L26.24|
;;;469            temp_spc = FMC_USPC;  
000016  24bb              MOVS     r4,#0xbb
                  |L26.24|
;;;470        }
;;;471    
;;;472        if(FMC_READY == fmc_state){
000018  b99a              CBNZ     r2,|L26.66|
;;;473    
;;;474            /* start erase the option byte */
;;;475            FMC_CTL0 |= FMC_CTL0_OBER;
00001a  4d15              LDR      r5,|L26.112|
00001c  6928              LDR      r0,[r5,#0x10]
00001e  f0400020          ORR      r0,r0,#0x20
000022  6128              STR      r0,[r5,#0x10]
;;;476            FMC_CTL0 |= FMC_CTL0_START;
000024  6928              LDR      r0,[r5,#0x10]
000026  f0400040          ORR      r0,r0,#0x40
00002a  6128              STR      r0,[r5,#0x10]
;;;477    
;;;478            /* wait for the FMC ready */
;;;479            fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT);
00002c  4630              MOV      r0,r6
00002e  f7fffffe          BL       fmc_bank0_ready_wait
000032  4602              MOV      r2,r0
;;;480        
;;;481            if(FMC_READY == fmc_state){
000034  b13a              CBZ      r2,|L26.70|
;;;482                /* reset the OBER bit */
;;;483                FMC_CTL0 &= ~FMC_CTL0_OBER;
;;;484                /* set the OBPG bit */
;;;485                FMC_CTL0 |= FMC_CTL0_OBPG;
;;;486                /* no security protection */
;;;487                OB_SPC = (uint16_t)temp_spc; 
;;;488                /* wait for the FMC ready */
;;;489                fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT); 
;;;490                if(FMC_TOERR != fmc_state){
;;;491                    /* reset the OBPG bit */
;;;492                    FMC_CTL0 &= ~FMC_CTL0_OBPG;
;;;493                }
;;;494            }else{
;;;495                if(FMC_TOERR != fmc_state){
000036  2a04              CMP      r2,#4
000038  d003              BEQ      |L26.66|
;;;496                    /* reset the OBPG bit */
;;;497                    FMC_CTL0 &= ~FMC_CTL0_OBPG;
00003a  6928              LDR      r0,[r5,#0x10]
00003c  f0200010          BIC      r0,r0,#0x10
000040  6128              STR      r0,[r5,#0x10]
                  |L26.66|
;;;498                }
;;;499            }
;;;500        }
;;;501        /* return the FMC state */
;;;502        return fmc_state;
000042  4610              MOV      r0,r2
;;;503    }
000044  bd70              POP      {r4-r6,pc}
                  |L26.70|
000046  6928              LDR      r0,[r5,#0x10]         ;483
000048  f0200020          BIC      r0,r0,#0x20           ;483
00004c  6128              STR      r0,[r5,#0x10]         ;483
00004e  6928              LDR      r0,[r5,#0x10]         ;485
000050  f0400010          ORR      r0,r0,#0x10           ;485
000054  6128              STR      r0,[r5,#0x10]         ;485
000056  4807              LDR      r0,|L26.116|
000058  8004              STRH     r4,[r0,#0]            ;487
00005a  4630              MOV      r0,r6                 ;489
00005c  f7fffffe          BL       fmc_bank0_ready_wait
000060  4602              MOV      r2,r0                 ;489
000062  2a04              CMP      r2,#4                 ;490
000064  d0ed              BEQ      |L26.66|
000066  6928              LDR      r0,[r5,#0x10]         ;492
000068  f0200010          BIC      r0,r0,#0x10           ;492
00006c  6128              STR      r0,[r5,#0x10]         ;492
00006e  e7e8              B        |L26.66|
;;;504    
                          ENDP

                  |L26.112|
                          DCD      0x40022000
                  |L26.116|
                          DCD      0x1ffff800

                          AREA ||i.ob_lock||, CODE, READONLY, ALIGN=2

                  ob_lock PROC
;;;447    */
;;;448    void ob_lock(void)
000000  4802              LDR      r0,|L27.12|
;;;449    {
;;;450        /* reset the OBWEN bit */
;;;451        FMC_CTL0 &= ~FMC_CTL0_OBWEN;
000002  6901              LDR      r1,[r0,#0x10]
000004  f4217100          BIC      r1,r1,#0x200
000008  6101              STR      r1,[r0,#0x10]
;;;452    }
00000a  4770              BX       lr
;;;453    
                          ENDP

                  |L27.12|
                          DCD      0x40022000

                          AREA ||i.ob_security_protection_config||, CODE, READONLY, ALIGN=2

                  ob_security_protection_config PROC
;;;574    */
;;;575    fmc_state_enum ob_security_protection_config(uint8_t ob_spc)
000000  b570              PUSH     {r4-r6,lr}
;;;576    {
000002  4605              MOV      r5,r0
;;;577        fmc_state_enum fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT);
000004  f44f2670          MOV      r6,#0xf0000
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       fmc_bank0_ready_wait
;;;578    
;;;579        if(FMC_READY == fmc_state){
00000e  2800              CMP      r0,#0
000010  d112              BNE      |L28.56|
;;;580            FMC_CTL0 |= FMC_CTL0_OBER;
000012  4c14              LDR      r4,|L28.100|
000014  6920              LDR      r0,[r4,#0x10]
000016  f0400020          ORR      r0,r0,#0x20
00001a  6120              STR      r0,[r4,#0x10]
;;;581            FMC_CTL0 |= FMC_CTL0_START;
00001c  6920              LDR      r0,[r4,#0x10]
00001e  f0400040          ORR      r0,r0,#0x40
000022  6120              STR      r0,[r4,#0x10]
;;;582        
;;;583            /* wait for the FMC ready */
;;;584            fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT);
000024  4630              MOV      r0,r6
000026  f7fffffe          BL       fmc_bank0_ready_wait
;;;585        
;;;586            if(FMC_READY == fmc_state){
00002a  b130              CBZ      r0,|L28.58|
;;;587                /* reset the OBER bit */
;;;588                FMC_CTL0 &= ~FMC_CTL0_OBER;
;;;589          
;;;590                /* start the option byte program */
;;;591                FMC_CTL0 |= FMC_CTL0_OBPG;
;;;592           
;;;593                OB_SPC = (uint16_t)ob_spc;
;;;594    
;;;595                /* wait for the FMC ready */
;;;596                fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT); 
;;;597        
;;;598                if(FMC_TOERR != fmc_state){
;;;599                    /* reset the OBPG bit */
;;;600                    FMC_CTL0 &= ~FMC_CTL0_OBPG;
;;;601                }
;;;602            }else{
;;;603                if(FMC_TOERR != fmc_state){
00002c  2804              CMP      r0,#4
00002e  d003              BEQ      |L28.56|
;;;604                    /* reset the OBER bit */
;;;605                    FMC_CTL0 &= ~FMC_CTL0_OBER;
000030  6921              LDR      r1,[r4,#0x10]
000032  f0210120          BIC      r1,r1,#0x20
000036  6121              STR      r1,[r4,#0x10]
                  |L28.56|
;;;606                }
;;;607            }
;;;608        }
;;;609        /* return the FMC state */
;;;610        return fmc_state;
;;;611    }
000038  bd70              POP      {r4-r6,pc}
                  |L28.58|
00003a  6920              LDR      r0,[r4,#0x10]         ;588
00003c  f0200020          BIC      r0,r0,#0x20           ;588
000040  6120              STR      r0,[r4,#0x10]         ;588
000042  6920              LDR      r0,[r4,#0x10]         ;591
000044  f0400010          ORR      r0,r0,#0x10           ;591
000048  6120              STR      r0,[r4,#0x10]         ;591
00004a  4807              LDR      r0,|L28.104|
00004c  8005              STRH     r5,[r0,#0]            ;593
00004e  4630              MOV      r0,r6                 ;596
000050  f7fffffe          BL       fmc_bank0_ready_wait
000054  2804              CMP      r0,#4                 ;598
000056  d0ef              BEQ      |L28.56|
000058  6921              LDR      r1,[r4,#0x10]         ;600
00005a  f0210110          BIC      r1,r1,#0x10           ;600
00005e  6121              STR      r1,[r4,#0x10]         ;600
000060  bd70              POP      {r4-r6,pc}
;;;612    
                          ENDP

000062  0000              DCW      0x0000
                  |L28.100|
                          DCD      0x40022000
                  |L28.104|
                          DCD      0x1ffff800

                          AREA ||i.ob_spc_get||, CODE, READONLY, ALIGN=2

                  ob_spc_get PROC
;;;725    */
;;;726    FlagStatus ob_spc_get(void)
000000  2000              MOVS     r0,#0
;;;727    {
;;;728        FlagStatus spc_state = RESET;
;;;729    
;;;730        if(RESET != (FMC_OBSTAT & FMC_OBSTAT_SPC)){
000002  4903              LDR      r1,|L29.16|
000004  69c9              LDR      r1,[r1,#0x1c]
000006  0789              LSLS     r1,r1,#30
000008  d500              BPL      |L29.12|
;;;731            spc_state = SET;
00000a  2001              MOVS     r0,#1
                  |L29.12|
;;;732        }else{
;;;733            spc_state = RESET;
;;;734        }
;;;735        return spc_state;
;;;736    }
00000c  4770              BX       lr
;;;737    
                          ENDP

00000e  0000              DCW      0x0000
                  |L29.16|
                          DCD      0x40022000

                          AREA ||i.ob_unlock||, CODE, READONLY, ALIGN=2

                  ob_unlock PROC
;;;428    */
;;;429    void ob_unlock(void)
000000  4805              LDR      r0,|L30.24|
;;;430    {
;;;431        if(RESET == (FMC_CTL0 & FMC_CTL0_OBWEN)){
000002  6901              LDR      r1,[r0,#0x10]
000004  0589              LSLS     r1,r1,#22
000006  d403              BMI      |L30.16|
;;;432            /* write the FMC key */
;;;433            FMC_OBKEY = UNLOCK_KEY0;
000008  4904              LDR      r1,|L30.28|
00000a  6081              STR      r1,[r0,#8]
;;;434            FMC_OBKEY = UNLOCK_KEY1;
00000c  4904              LDR      r1,|L30.32|
00000e  6081              STR      r1,[r0,#8]
                  |L30.16|
;;;435        }
;;;436    
;;;437        /* wait until OBWEN bit is set by hardware */
;;;438        while(RESET == (FMC_CTL0 & FMC_CTL0_OBWEN)){
000010  6901              LDR      r1,[r0,#0x10]
000012  0589              LSLS     r1,r1,#22
000014  d5fc              BPL      |L30.16|
;;;439        }
;;;440    }
000016  4770              BX       lr
;;;441    
                          ENDP

                  |L30.24|
                          DCD      0x40022000
                  |L30.28|
                          DCD      0x45670123
                  |L30.32|
                          DCD      0xcdef89ab

                          AREA ||i.ob_user_get||, CODE, READONLY, ALIGN=2

                  ob_user_get PROC
;;;690    */
;;;691    uint8_t ob_user_get(void)
000000  4802              LDR      r0,|L31.12|
;;;692    {
;;;693        /* return the FMC user option byte value */
;;;694        return (uint8_t)(FMC_OBSTAT >> 2U);
000002  69c0              LDR      r0,[r0,#0x1c]
000004  f3c00087          UBFX     r0,r0,#2,#8
;;;695    }
000008  4770              BX       lr
;;;696    
                          ENDP

00000a  0000              DCW      0x0000
                  |L31.12|
                          DCD      0x40022000

                          AREA ||i.ob_user_write||, CODE, READONLY, ALIGN=2

                  ob_user_write PROC
;;;629    */
;;;630    fmc_state_enum ob_user_write(uint8_t ob_fwdgt, uint8_t ob_deepsleep, uint8_t ob_stdby, uint8_t ob_boot)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;631    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4691              MOV      r9,r2
00000a  461d              MOV      r5,r3
;;;632        fmc_state_enum fmc_state = FMC_READY;
;;;633        uint8_t temp;
;;;634    
;;;635        /* wait for the FMC ready */
;;;636        fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT);
00000c  f44f2870          MOV      r8,#0xf0000
000010  4640              MOV      r0,r8
000012  f7fffffe          BL       fmc_bank0_ready_wait
;;;637      
;;;638        if(FMC_READY == fmc_state){
000016  2800              CMP      r0,#0
000018  d115              BNE      |L32.70|
;;;639            /* set the OBPG bit*/
;;;640            FMC_CTL0 |= FMC_CTL0_OBPG; 
00001a  4c0c              LDR      r4,|L32.76|
00001c  6920              LDR      r0,[r4,#0x10]
00001e  f0400010          ORR      r0,r0,#0x10
000022  6120              STR      r0,[r4,#0x10]
;;;641    
;;;642            temp = ((uint8_t)((uint8_t)((uint8_t)(ob_boot | ob_fwdgt) | ob_deepsleep) | ob_stdby) | OB_USER_MASK);
000024  4335              ORRS     r5,r5,r6
000026  433d              ORRS     r5,r5,r7
000028  ea450509          ORR      r5,r5,r9
00002c  f04500f0          ORR      r0,r5,#0xf0
;;;643            OB_USER = (uint16_t)temp;
000030  4907              LDR      r1,|L32.80|
000032  8008              STRH     r0,[r1,#0]
;;;644        
;;;645            /* wait for the FMC ready */
;;;646            fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT);
000034  4640              MOV      r0,r8
000036  f7fffffe          BL       fmc_bank0_ready_wait
;;;647    
;;;648            if(FMC_TOERR != fmc_state){
00003a  2804              CMP      r0,#4
00003c  d003              BEQ      |L32.70|
;;;649                /* reset the OBPG bit */
;;;650                FMC_CTL0 &= ~FMC_CTL0_OBPG;
00003e  6921              LDR      r1,[r4,#0x10]
000040  f0210110          BIC      r1,r1,#0x10
000044  6121              STR      r1,[r4,#0x10]
                  |L32.70|
;;;651            }
;;;652        }
;;;653        /* return the FMC state */
;;;654        return fmc_state;
;;;655    }
000046  e8bd83f0          POP      {r4-r9,pc}
;;;656    
                          ENDP

00004a  0000              DCW      0x0000
                  |L32.76|
                          DCD      0x40022000
                  |L32.80|
                          DCD      0x1ffff802

                          AREA ||i.ob_write_protection_enable||, CODE, READONLY, ALIGN=2

                  ob_write_protection_enable PROC
;;;515    */
;;;516    fmc_state_enum ob_write_protection_enable(uint32_t ob_wp)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;517    {
000004  4604              MOV      r4,r0
;;;518        uint16_t temp_wp0, temp_wp1, temp_wp2, temp_wp3;
;;;519    
;;;520        fmc_state_enum fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT);
000006  f44f2870          MOV      r8,#0xf0000
00000a  4640              MOV      r0,r8
00000c  f7fffffe          BL       fmc_bank0_ready_wait
;;;521    
;;;522        ob_wp = (uint32_t)(~ob_wp);
000010  43e1              MVNS     r1,r4
;;;523        temp_wp0 = (uint16_t)(ob_wp & OB_WP0_WP0);
000012  b2ca              UXTB     r2,r1
;;;524        temp_wp1 = (uint16_t)((ob_wp & OB_WP1_WP1) >> 8U);
000014  f3c12407          UBFX     r4,r1,#8,#8
;;;525        temp_wp2 = (uint16_t)((ob_wp & OB_WP2_WP2) >> 16U);
000018  f3c14507          UBFX     r5,r1,#16,#8
;;;526        temp_wp3 = (uint16_t)((ob_wp & OB_WP3_WP3) >> 24U);
00001c  0e0e              LSRS     r6,r1,#24
;;;527    
;;;528        if(FMC_READY == fmc_state){
00001e  2800              CMP      r0,#0
000020  d12c              BNE      |L33.124|
;;;529        
;;;530            /* set the OBPG bit*/
;;;531            FMC_CTL0 |= FMC_CTL0_OBPG;
000022  4f17              LDR      r7,|L33.128|
000024  6939              LDR      r1,[r7,#0x10]
000026  f0410110          ORR      r1,r1,#0x10
00002a  6139              STR      r1,[r7,#0x10]
;;;532    
;;;533            if(0xFFU != temp_wp0){
00002c  2aff              CMP      r2,#0xff
00002e  d004              BEQ      |L33.58|
;;;534                OB_WP0 = temp_wp0;
000030  4814              LDR      r0,|L33.132|
000032  8002              STRH     r2,[r0,#0]
;;;535          
;;;536                /* wait for the FMC ready */
;;;537                fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT);
000034  4640              MOV      r0,r8
000036  f7fffffe          BL       fmc_bank0_ready_wait
                  |L33.58|
;;;538            }
;;;539            if((FMC_READY == fmc_state) && (0xFFU != temp_wp1)){
00003a  b938              CBNZ     r0,|L33.76|
00003c  2cff              CMP      r4,#0xff
00003e  d005              BEQ      |L33.76|
;;;540                OB_WP1 = temp_wp1;
000040  4810              LDR      r0,|L33.132|
000042  1c80              ADDS     r0,r0,#2
000044  8004              STRH     r4,[r0,#0]
;;;541          
;;;542                /* wait for the FMC ready */
;;;543                fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT);
000046  4640              MOV      r0,r8
000048  f7fffffe          BL       fmc_bank0_ready_wait
                  |L33.76|
;;;544            }
;;;545            if((FMC_READY == fmc_state) && (0xFFU != temp_wp2)){
00004c  b938              CBNZ     r0,|L33.94|
00004e  2dff              CMP      r5,#0xff
000050  d005              BEQ      |L33.94|
;;;546                OB_WP2 = temp_wp2;
000052  480c              LDR      r0,|L33.132|
000054  1d00              ADDS     r0,r0,#4
000056  8005              STRH     r5,[r0,#0]
;;;547          
;;;548                /* wait for the FMC ready */
;;;549                fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT);
000058  4640              MOV      r0,r8
00005a  f7fffffe          BL       fmc_bank0_ready_wait
                  |L33.94|
;;;550            }
;;;551            if((FMC_READY == fmc_state) && (0xFFU != temp_wp3)){
00005e  b938              CBNZ     r0,|L33.112|
000060  2eff              CMP      r6,#0xff
000062  d005              BEQ      |L33.112|
;;;552                OB_WP3 = temp_wp3;
000064  4807              LDR      r0,|L33.132|
000066  1d80              ADDS     r0,r0,#6
000068  8006              STRH     r6,[r0,#0]
;;;553          
;;;554                /* wait for the FMC ready */
;;;555                fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT);
00006a  4640              MOV      r0,r8
00006c  f7fffffe          BL       fmc_bank0_ready_wait
                  |L33.112|
;;;556            }
;;;557            if(FMC_TOERR != fmc_state){
000070  2804              CMP      r0,#4
000072  d003              BEQ      |L33.124|
;;;558                /* reset the OBPG bit */
;;;559                FMC_CTL0 &= ~FMC_CTL0_OBPG;
000074  6939              LDR      r1,[r7,#0x10]
000076  f0210110          BIC      r1,r1,#0x10
00007a  6139              STR      r1,[r7,#0x10]
                  |L33.124|
;;;560            }
;;;561        } 
;;;562        /* return the FMC state */
;;;563        return fmc_state;
;;;564    }
00007c  e8bd81f0          POP      {r4-r8,pc}
;;;565    
                          ENDP

                  |L33.128|
                          DCD      0x40022000
                  |L33.132|
                          DCD      0x1ffff808

                          AREA ||i.ob_write_protection_get||, CODE, READONLY, ALIGN=2

                  ob_write_protection_get PROC
;;;713    */
;;;714    uint32_t ob_write_protection_get(void)
000000  4801              LDR      r0,|L34.8|
;;;715    {
;;;716        /* return the FMC write protection option byte value */
;;;717        return FMC_WP;
000002  6a00              LDR      r0,[r0,#0x20]
;;;718    }
000004  4770              BX       lr
;;;719    
                          ENDP

000006  0000              DCW      0x0000
                  |L34.8|
                          DCD      0x40022000

;*** Start embedded assembler ***

#line 1 "Libraries\\src\\gd32f10x_fmc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_gd32f10x_fmc_c_2e62a613____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___14_gd32f10x_fmc_c_2e62a613____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_gd32f10x_fmc_c_2e62a613____REVSH|
#line 128
|__asm___14_gd32f10x_fmc_c_2e62a613____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
