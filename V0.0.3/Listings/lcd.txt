; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\lcd.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\lcd.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.1\Device\Include -D__MICROLIB -D__UVISION_VERSION=534 -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\lcd.crf User\lcd.c]
                          THUMB

                          AREA ||i.LCD_ColorInverse||, CODE, READONLY, ALIGN=1

                  LCD_ColorInverse PROC
;;;80     // 颜色翻转开关
;;;81     void LCD_ColorInverse(BOOL onoff)
000000  f04f41c0          MOV      r1,#0x60000000
;;;82     {
;;;83     	if(onoff)
000004  2800              CMP      r0,#0
000006  d002              BEQ      |L1.14|
;;;84     	{
;;;85     		LCD_CMD=0x21;
000008  2021              MOVS     r0,#0x21
00000a  8008              STRH     r0,[r1,#0]
;;;86     	}
;;;87     	else
;;;88     	{
;;;89     		LCD_CMD=0x20;
;;;90     	}
;;;91     }
00000c  4770              BX       lr
                  |L1.14|
00000e  2020              MOVS     r0,#0x20              ;89
000010  8008              STRH     r0,[r1,#0]            ;89
000012  4770              BX       lr
;;;92     
                          ENDP


                          AREA ||i.LCD_CtrlPortInit||, CODE, READONLY, ALIGN=2

                  LCD_CtrlPortInit PROC
;;;227    // LCD控制端口初始化
;;;228    void LCD_CtrlPortInit(void)
000000  b510              PUSH     {r4,lr}
;;;229    {
;;;230    	// 使能端口时钟
;;;231    	rcu_periph_clock_enable(RCU_GPIOA);
000002  f2406002          MOV      r0,#0x602
000006  f7fffffe          BL       rcu_periph_clock_enable
;;;232    	rcu_periph_clock_enable(RCU_GPIOB);
00000a  f2406003          MOV      r0,#0x603
00000e  f7fffffe          BL       rcu_periph_clock_enable
;;;233    	rcu_periph_clock_enable(RCU_GPIOD);
000012  f2406005          MOV      r0,#0x605
000016  f7fffffe          BL       rcu_periph_clock_enable
;;;234    	rcu_periph_clock_enable(RCU_GPIOE);
00001a  f2406006          MOV      r0,#0x606
00001e  f7fffffe          BL       rcu_periph_clock_enable
;;;235    
;;;236    	// LCD背光控制端口设置为输出
;;;237    	gpio_init(GPIOA, GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_8);
000022  f44f7380          MOV      r3,#0x100
000026  2203              MOVS     r2,#3
000028  2110              MOVS     r1,#0x10
00002a  480c              LDR      r0,|L2.92|
00002c  f7fffffe          BL       gpio_init
;;;238    	
;;;239    	// LCD复位信号控制端口设置为输出
;;;240    	gpio_init(GPIOB, GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_0); 
000030  2301              MOVS     r3,#1
000032  2203              MOVS     r2,#3
000034  2110              MOVS     r1,#0x10
000036  480a              LDR      r0,|L2.96|
000038  f7fffffe          BL       gpio_init
;;;241    
;;;242    	// 设置 PD.00(D2), PD.01(D3), PD.04(NOE-RD), PD.05(NWE-WR), PD.07(NE1-CS)，PD.08(D13), PD.09(D14),
;;;243    	// PD.10(D15), PD.12(A17-RS), PD.14(D0), PD.15(D1) 为复用推挽输出
;;;244    	gpio_init(GPIOD, GPIO_MODE_AF_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_0 | 
00003c  f64c73b3          MOV      r3,#0xcfb3
000040  2203              MOVS     r2,#3
000042  2118              MOVS     r1,#0x18
000044  4807              LDR      r0,|L2.100|
000046  f7fffffe          BL       gpio_init
;;;245    														GPIO_PIN_1 |
;;;246    														GPIO_PIN_4 |
;;;247    														GPIO_PIN_5 |
;;;248    														GPIO_PIN_7 |
;;;249    														GPIO_PIN_8 |
;;;250    														GPIO_PIN_9 |
;;;251    														GPIO_PIN_10 |
;;;252    														GPIO_PIN_11 |
;;;253    														GPIO_PIN_14 |
;;;254    														GPIO_PIN_15);
;;;255    
;;;256    	gpio_init(GPIOE, GPIO_MODE_AF_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_7 |
00004a  2203              MOVS     r2,#3
00004c  e8bd4010          POP      {r4,lr}
000050  f64f7380          MOV      r3,#0xff80
000054  2118              MOVS     r1,#0x18
000056  4804              LDR      r0,|L2.104|
000058  f7ffbffe          B.W      gpio_init
;;;257    														GPIO_PIN_8 |
;;;258    														GPIO_PIN_9 |
;;;259    														GPIO_PIN_10 |
;;;260    														GPIO_PIN_11 |
;;;261    														GPIO_PIN_12 |
;;;262    														GPIO_PIN_13 |
;;;263    														GPIO_PIN_14 |
;;;264    														GPIO_PIN_15);
;;;265    }
;;;266    
                          ENDP

                  |L2.92|
                          DCD      0x40010800
                  |L2.96|
                          DCD      0x40010c00
                  |L2.100|
                          DCD      0x40011400
                  |L2.104|
                          DCD      0x40011800

                          AREA ||i.LCD_DisplayOnOff||, CODE, READONLY, ALIGN=1

                  LCD_DisplayOnOff PROC
;;;93     // 显示开关
;;;94     void LCD_DisplayOnOff(BOOL onoff)
000000  f04f41c0          MOV      r1,#0x60000000
;;;95     {
;;;96     	if(onoff)
000004  2800              CMP      r0,#0
000006  d002              BEQ      |L3.14|
;;;97     	{
;;;98     		LCD_CMD=0x29;
000008  2029              MOVS     r0,#0x29
00000a  8008              STRH     r0,[r1,#0]
;;;99     	}
;;;100    	else
;;;101    	{
;;;102    		LCD_CMD=0x28;
;;;103    	}
;;;104    }
00000c  4770              BX       lr
                  |L3.14|
00000e  2028              MOVS     r0,#0x28              ;102
000010  8008              STRH     r0,[r1,#0]            ;102
000012  4770              BX       lr
;;;105    
                          ENDP


                          AREA ||i.LCD_DotDynamicShow||, CODE, READONLY, ALIGN=2

                  LCD_DotDynamicShow PROC
;;;685    // .动态显示
;;;686    void LCD_DotDynamicShow(uint32 param)
000000  b5f8              PUSH     {r3-r7,lr}
;;;687    {
;;;688    	static uint8 count;
;;;689    	
;;;690    	if(3 == count)
000002  4d14              LDR      r5,|L4.84|
000004  2400              MOVS     r4,#0
000006  7828              LDRB     r0,[r5,#0]  ; count
000008  2803              CMP      r0,#3
00000a  d100              BNE      |L4.14|
;;;691    	{
;;;692    		count = 0;
00000c  702c              STRB     r4,[r5,#0]
                  |L4.14|
;;;693    	}
;;;694    	if(0 == count)
00000e  7828              LDRB     r0,[r5,#0]  ; count
;;;695    	{
;;;696    		LCD_PrintString(122 + count, 160, ".  ", LCD_COLOR_WHITE, LCD_OPERATOR_MODE_DRAW);
000010  f64f76ff          MOV      r6,#0xffff
000014  b930              CBNZ     r0,|L4.36|
000016  4633              MOV      r3,r6
000018  a20f              ADR      r2,|L4.88|
00001a  21a0              MOVS     r1,#0xa0
00001c  207a              MOVS     r0,#0x7a
00001e  9400              STR      r4,[sp,#0]
000020  f7fffffe          BL       LCD_PrintString
                  |L4.36|
;;;697    	}
;;;698    	if(1 == count)
000024  7828              LDRB     r0,[r5,#0]  ; count
000026  2801              CMP      r0,#1
000028  d106              BNE      |L4.56|
;;;699    	{
;;;700    		LCD_PrintString(122 + count, 160, ".. ", LCD_COLOR_WHITE, LCD_OPERATOR_MODE_DRAW);
00002a  4633              MOV      r3,r6
00002c  a20b              ADR      r2,|L4.92|
00002e  21a0              MOVS     r1,#0xa0
000030  207b              MOVS     r0,#0x7b
000032  9400              STR      r4,[sp,#0]
000034  f7fffffe          BL       LCD_PrintString
                  |L4.56|
;;;701    	}
;;;702    	if(2 == count)
000038  7828              LDRB     r0,[r5,#0]  ; count
00003a  2802              CMP      r0,#2
00003c  d106              BNE      |L4.76|
;;;703    	{
;;;704    		LCD_PrintString(122 + count, 160, "...", LCD_COLOR_WHITE, LCD_OPERATOR_MODE_DRAW);
00003e  4633              MOV      r3,r6
000040  a207              ADR      r2,|L4.96|
000042  21a0              MOVS     r1,#0xa0
000044  207c              MOVS     r0,#0x7c
000046  9400              STR      r4,[sp,#0]
000048  f7fffffe          BL       LCD_PrintString
                  |L4.76|
;;;705    	}
;;;706    	count++;
00004c  7828              LDRB     r0,[r5,#0]  ; count
00004e  1c40              ADDS     r0,r0,#1
000050  7028              STRB     r0,[r5,#0]
;;;707    }
000052  bdf8              POP      {r3-r7,pc}
;;;708    
                          ENDP

                  |L4.84|
                          DCD      ||.data||
                  |L4.88|
000058  2e202000          DCB      ".  ",0
                  |L4.92|
00005c  2e2e2000          DCB      ".. ",0
                  |L4.96|
000060  2e2e2e00          DCB      "...",0

                          AREA ||i.LCD_DrawAreaColor||, CODE, READONLY, ALIGN=2

                  LCD_DrawAreaColor PROC
;;;446    // 在指定区域显示指定的颜色
;;;447    void LCD_DrawAreaColor(uint16 x, uint16 y, uint16 w, uint16 h, uint16 data)
000000  b530              PUSH     {r4,r5,lr}
;;;448    {
000002  9d03              LDR      r5,[sp,#0xc]
;;;449    	uint32 i;
;;;450    	uint32 size = w * h;	
000004  fb02f403          MUL      r4,r2,r3
;;;451    
;;;452    	/* 需要添加参数判断 */
;;;453    	CHECK_PARAM_OVER_RETURN(w,LCD_WIDTH);
000008  2af0              CMP      r2,#0xf0
00000a  d80b              BHI      |L5.36|
;;;454    	CHECK_PARAM_OVER_RETURN(h,LCD_HEIGHT);
00000c  f5b37fa0          CMP      r3,#0x140
000010  d808              BHI      |L5.36|
;;;455    	
;;;456    	LCD_SetAreaByPointAndSize(x, y, w, h);
000012  f7fffffe          BL       LCD_SetAreaByPointAndSize
;;;457    
;;;458    	for(i=0; i<size; i++)
000016  2000              MOVS     r0,#0
;;;459    	{
;;;460    		LCD_WriteColor(data);
000018  4903              LDR      r1,|L5.40|
00001a  e001              B        |L5.32|
                  |L5.28|
00001c  800d              STRH     r5,[r1,#0]
00001e  1c40              ADDS     r0,r0,#1              ;458
                  |L5.32|
000020  42a0              CMP      r0,r4                 ;458
000022  d3fb              BCC      |L5.28|
                  |L5.36|
;;;461    	}
;;;462    }
000024  bd30              POP      {r4,r5,pc}
;;;463    
                          ENDP

000026  0000              DCW      0x0000
                  |L5.40|
                          DCD      0x60020000

                          AREA ||i.LCD_DrawButton||, CODE, READONLY, ALIGN=2

                  LCD_DrawButton PROC
;;;464    // 在指定区域显示指定的颜色
;;;465    void LCD_DrawButton(uint16 x, uint16 y, uint16 w, uint16 h, uint16 data)
000000  e92d4ffc          PUSH     {r2-r11,lr}
;;;466    {
000004  4681              MOV      r9,r0
000006  9c0b              LDR      r4,[sp,#0x2c]
000008  468a              MOV      r10,r1
;;;467    	uint32 i;
;;;468    	uint32 size = w * h;	
;;;469    
;;;470    	/* 需要添加参数判断 */
;;;471    	CHECK_PARAM_OVER_RETURN(w,LCD_WIDTH);
00000a  2af0              CMP      r2,#0xf0
00000c  d83e              BHI      |L6.140|
;;;472    	CHECK_PARAM_OVER_RETURN(h,LCD_HEIGHT);
00000e  f5b37fa0          CMP      r3,#0x140
000012  d83b              BHI      |L6.140|
;;;473    
;;;474    	w = 20;
;;;475    	h = 10;
;;;476    	size = (w - 4) * (h - 4);
000014  f04f0b10          MOV      r11,#0x10
000018  2760              MOVS     r7,#0x60
;;;477    	
;;;478    	LCD_DrawLine(x, y, x, y + h, data, 1);
00001a  f04f0801          MOV      r8,#1
00001e  e9cd4800          STRD     r4,r8,[sp,#0]
000022  f10a050a          ADD      r5,r10,#0xa
000026  b2ab              UXTH     r3,r5
000028  464a              MOV      r2,r9
00002a  4651              MOV      r1,r10
00002c  4648              MOV      r0,r9
00002e  f7fffffe          BL       LCD_DrawLine
;;;479    	LCD_DrawLine(x + w, y, x + w, y + h, data, 1);
000032  f1090614          ADD      r6,r9,#0x14
000036  e9cd4800          STRD     r4,r8,[sp,#0]
00003a  b2ab              UXTH     r3,r5
00003c  b2b2              UXTH     r2,r6
00003e  b2b0              UXTH     r0,r6
000040  4651              MOV      r1,r10
000042  f7fffffe          BL       LCD_DrawLine
;;;480    
;;;481    	LCD_DrawLine(x, y, x + w, y, data, 1);
000046  e9cd4800          STRD     r4,r8,[sp,#0]
00004a  b2b2              UXTH     r2,r6
00004c  4653              MOV      r3,r10
00004e  4651              MOV      r1,r10
000050  4648              MOV      r0,r9
000052  f7fffffe          BL       LCD_DrawLine
;;;482    	LCD_DrawLine(x, y + h, x + w, y + h, data, 1);
000056  e9cd4800          STRD     r4,r8,[sp,#0]
00005a  b2ab              UXTH     r3,r5
00005c  b2b2              UXTH     r2,r6
00005e  b2a9              UXTH     r1,r5
000060  4648              MOV      r0,r9
000062  f7fffffe          BL       LCD_DrawLine
;;;483    
;;;484    	LCD_SetAreaByPointAndSize(x+3, y+3, w-4, h-4);
000066  f10a0a03          ADD      r10,r10,#3
00006a  f1090903          ADD      r9,r9,#3
00006e  fa1ff18a          UXTH     r1,r10
000072  fa1ff089          UXTH     r0,r9
000076  2306              MOVS     r3,#6
000078  465a              MOV      r2,r11
00007a  f7fffffe          BL       LCD_SetAreaByPointAndSize
;;;485    	for(i=0; i<size; i++)
00007e  2000              MOVS     r0,#0
;;;486    	{
;;;487    		LCD_WriteColor(data);
000080  4903              LDR      r1,|L6.144|
000082  e001              B        |L6.136|
                  |L6.132|
000084  800c              STRH     r4,[r1,#0]
000086  1c40              ADDS     r0,r0,#1              ;485
                  |L6.136|
000088  42b8              CMP      r0,r7                 ;485
00008a  d3fb              BCC      |L6.132|
                  |L6.140|
;;;488    	}
;;;489    }
00008c  e8bd8ffc          POP      {r2-r11,pc}
;;;490    
                          ENDP

                  |L6.144|
                          DCD      0x60020000

                          AREA ||i.LCD_DrawLine||, CODE, READONLY, ALIGN=1

                  LCD_DrawLine PROC
;;;492    // 画直线
;;;493    void LCD_DrawLine(uint16 x1, uint16 y1, uint16 x2, uint16 y2, uint16 usColor, uint16 usLineWidth)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;494    {
;;;495    
;;;496    	uint16 t; 
;;;497    
;;;498    	int xerr=0,yerr=0,delta_x,delta_y,distance; 
000004  2500              MOVS     r5,#0
000006  2600              MOVS     r6,#0
;;;499    
;;;500    	int incx,incy,uRow,uCol; 
;;;501    
;;;502    	delta_x=x2-x1; //计算坐标增量 
000008  1a17              SUBS     r7,r2,r0
;;;503    
;;;504    	delta_y=y2-y1; 
00000a  eba30801          SUB      r8,r3,r1
;;;505    
;;;506    	uRow=x1; 
00000e  4681              MOV      r9,r0
;;;507    
;;;508    	uCol=y1; 
000010  468a              MOV      r10,r1
;;;509    
;;;510    	if(delta_x>0)
;;;511    	{
;;;512    		incx=1; //设置单步方向 
;;;513    	}
;;;514    	else if(delta_x==0)
;;;515    	{
;;;516    		incx=0;//垂直线 
;;;517    	}
;;;518    	else
;;;519    	{
;;;520    		incx=-1;
000012  1e68              SUBS     r0,r5,#1
000014  2f00              CMP      r7,#0                 ;510
000016  dd03              BLE      |L7.32|
000018  f04f0101          MOV      r1,#1                 ;512
00001c  9102              STR      r1,[sp,#8]            ;512
00001e  e007              B        |L7.48|
                  |L7.32|
000020  d103              BNE      |L7.42|
000022  f04f0100          MOV      r1,#0                 ;516
000026  9102              STR      r1,[sp,#8]            ;516
000028  e002              B        |L7.48|
                  |L7.42|
00002a  9002              STR      r0,[sp,#8]
;;;521    		delta_x=-delta_x;
00002c  f1c70700          RSB      r7,r7,#0
                  |L7.48|
;;;522    	} 
;;;523    
;;;524    	if(delta_y>0)
000030  f1b80f00          CMP      r8,#0
000034  dd03              BLE      |L7.62|
;;;525    	{
;;;526    		incy=1; 
000036  f04f0001          MOV      r0,#1
00003a  9001              STR      r0,[sp,#4]
00003c  e007              B        |L7.78|
                  |L7.62|
;;;527    	}
;;;528    	else if(delta_y==0)
00003e  d103              BNE      |L7.72|
;;;529    	{
;;;530    		incy=0;//水平线 
000040  f04f0000          MOV      r0,#0
000044  9001              STR      r0,[sp,#4]
000046  e002              B        |L7.78|
                  |L7.72|
;;;531    	}
;;;532    	else
;;;533    	{
;;;534    		incy=-1;
000048  9001              STR      r0,[sp,#4]
;;;535    		delta_y=-delta_y;
00004a  f1c80800          RSB      r8,r8,#0
                  |L7.78|
;;;536    	} 
;;;537    
;;;538    	if(delta_x>delta_y)
00004e  4547              CMP      r7,r8
000050  dd01              BLE      |L7.86|
;;;539    	{
;;;540    		distance=delta_x; //选取基本增量坐标轴 
000052  463c              MOV      r4,r7
000054  e000              B        |L7.88|
                  |L7.86|
;;;541    	}
;;;542    	else 
;;;543    	{
;;;544    		distance=delta_y; 
000056  4644              MOV      r4,r8
                  |L7.88|
;;;545    	}
;;;546    
;;;547    	for(t=0;t<=distance+1;t++)//画线输出 
000058  f04f0b00          MOV      r11,#0
00005c  1c60              ADDS     r0,r4,#1
00005e  9003              STR      r0,[sp,#0xc]
000060  e019              B        |L7.150|
                  |L7.98|
;;;548    	{  
;;;549    
;;;550    		LCD_DrawAreaColor(uRow,uCol, 3, 3, usColor);//画点 
000062  980d              LDR      r0,[sp,#0x34]
000064  9000              STR      r0,[sp,#0]
000066  2303              MOVS     r3,#3
000068  fa1ff18a          UXTH     r1,r10
00006c  fa1ff089          UXTH     r0,r9
000070  461a              MOV      r2,r3
000072  f7fffffe          BL       LCD_DrawAreaColor
;;;551    
;;;552    		xerr+=delta_x ; 
000076  443d              ADD      r5,r5,r7
;;;553    
;;;554    		yerr+=delta_y ; 
000078  4446              ADD      r6,r6,r8
;;;555    
;;;556    		if(xerr>distance) 
00007a  42a5              CMP      r5,r4
00007c  dd02              BLE      |L7.132|
;;;557    		{ 
;;;558    
;;;559    			xerr-=distance; 
00007e  1b2d              SUBS     r5,r5,r4
;;;560    
;;;561    			uRow+=incx; 
000080  9802              LDR      r0,[sp,#8]
000082  4481              ADD      r9,r9,r0
                  |L7.132|
;;;562    
;;;563    		} 
;;;564    
;;;565    		if(yerr>distance) 
000084  42a6              CMP      r6,r4
000086  dd02              BLE      |L7.142|
;;;566    		{ 
;;;567    
;;;568    			yerr-=distance; 
000088  1b36              SUBS     r6,r6,r4
;;;569    
;;;570    			uCol+=incy; 
00008a  9801              LDR      r0,[sp,#4]
00008c  4482              ADD      r10,r10,r0
                  |L7.142|
00008e  f10b0b01          ADD      r11,r11,#1            ;547
000092  fa1ffb8b          UXTH     r11,r11               ;547
                  |L7.150|
000096  9803              LDR      r0,[sp,#0xc]          ;547
000098  4583              CMP      r11,r0                ;547
00009a  dde2              BLE      |L7.98|
;;;571    		} 
;;;572    	}  
;;;573    }  
00009c  e8bd8fff          POP      {r0-r11,pc}
;;;574    
                          ENDP


                          AREA ||i.LCD_DrawPic||, CODE, READONLY, ALIGN=2

                  LCD_DrawPic PROC
;;;421    // 在指定位置显示指定的图片
;;;422    void LCD_DrawPic(uint16 x, uint16 y, const uint16* pData)
000000  b530              PUSH     {r4,r5,lr}
;;;423    {
000002  4614              MOV      r4,r2
;;;424    	uint16 width=0, height=0;
;;;425    	uint32 i;
;;;426    	uint32 size;
;;;427    	
;;;428    	if(NULL == pData)
000004  2c00              CMP      r4,#0
000006  d00f              BEQ      |L8.40|
;;;429    	{
;;;430    		return;
;;;431    	}
;;;432    
;;;433    	width = pData[0];
000008  8822              LDRH     r2,[r4,#0]
;;;434    	height = pData[1];
00000a  8863              LDRH     r3,[r4,#2]
;;;435    	size = width;
;;;436    	size *= height;
00000c  fb02f503          MUL      r5,r2,r3
;;;437    
;;;438    	LCD_SetAreaByPointAndSize(x, y, width, height);
000010  f7fffffe          BL       LCD_SetAreaByPointAndSize
;;;439    
;;;440    	for(i=0; i<size; i++)
000014  2000              MOVS     r0,#0
;;;441    	{
;;;442    		LCD_WriteColor(pData[2+i]);
000016  4905              LDR      r1,|L8.44|
000018  e004              B        |L8.36|
                  |L8.26|
00001a  1c82              ADDS     r2,r0,#2
00001c  f8342012          LDRH     r2,[r4,r2,LSL #1]
000020  800a              STRH     r2,[r1,#0]
000022  1c40              ADDS     r0,r0,#1              ;440
                  |L8.36|
000024  42a8              CMP      r0,r5                 ;440
000026  d3f8              BCC      |L8.26|
                  |L8.40|
;;;443    	}
;;;444    }
000028  bd30              POP      {r4,r5,pc}
;;;445    
                          ENDP

00002a  0000              DCW      0x0000
                  |L8.44|
                          DCD      0x60020000

                          AREA ||i.LCD_DrawPicFromAddress||, CODE, READONLY, ALIGN=2

                  LCD_DrawPicFromAddress PROC
;;;347    // 显示指定位置的图片数据，在参数中给出要显示的图片数据在SPI Flash中的首地址
;;;348    void LCD_DrawPicFromAddress(uint16 x, uint16 y, uint16 w, uint16 h, uint32 addr)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;349    {
000004  4607              MOV      r7,r0
000006  9e06              LDR      r6,[sp,#0x18]
000008  460d              MOV      r5,r1
00000a  4614              MOV      r4,r2
00000c  4698              MOV      r8,r3
;;;350    #if 0	// NO DMA
;;;351    	uint32 size		= 0;
;;;352    	uint8  data[2];
;;;353    
;;;354    	/* 设定操作区域 */
;;;355    	LCD_SetAreaByPointAndSize(x, y, w, h);
;;;356    
;;;357    	/* 根据图片尺寸与数据作图 */
;;;358    	size = w * h;	
;;;359    
;;;360    	// 片选
;;;361    	SPI_FLASH_CS_L();
;;;362    
;;;363    	// 发送读取命令
;;;364    	(void)SPI_FLASH_SendByte(CMD_READ_BYTE);
;;;365    
;;;366    	// 发送24位起始地址
;;;367    	(void)SPI_FLASH_SendByte((addr & 0xFF0000) >> 16);
;;;368    	(void)SPI_FLASH_SendByte((addr& 0xFF00) >> 8);
;;;369    	(void)SPI_FLASH_SendByte(addr & 0xFF);
;;;370    
;;;371    	// 一直读取完指定的数量为止
;;;372    	while(size--)
;;;373    	{
;;;374    		// 读取一个字节
;;;375    		data[1] = SPI_FLASH_SendByte(0);
;;;376    		data[0] = SPI_FLASH_SendByte(0);
;;;377    
;;;378    		LCD_WriteColor( *((uint16*)data) );
;;;379    	}
;;;380    
;;;381    	// 释放
;;;382    	SPI_FLASH_CS_H();
;;;383    	
;;;384    #else	// DMA
;;;385    	uint32 size = 0, offset = 0;
;;;386    	uint32 srcAddr = addr;
;;;387    
;;;388    	/* 设定操作区域 */
;;;389    	LCD_SetAreaByPointAndSize( x, y, w, h );
00000e  4643              MOV      r3,r8
000010  4622              MOV      r2,r4
000012  4629              MOV      r1,r5
000014  4638              MOV      r0,r7
000016  f7fffffe          BL       LCD_SetAreaByPointAndSize
;;;390    
;;;391    	/* 根据图片尺寸与数据作图 */
;;;392    	size = w;
;;;393    	size *= h;
00001a  fb04f408          MUL      r4,r4,r8
;;;394    	offset = y;
;;;395    	offset *= LCD_WIDTH;
00001e  ebc51005          RSB      r0,r5,r5,LSL #4
000022  0100              LSLS     r0,r0,#4
;;;396    	offset += x;
000024  19c5              ADDS     r5,r0,r7
;;;397    
;;;398    #define _DMA_MOVE_BYTES_COUNT_TOP_			0xE000
;;;399    	while(size > 0)
;;;400    	{
;;;401    		// 超过搬运上限，分多次
;;;402    		if(size > _DMA_MOVE_BYTES_COUNT_TOP_)
000026  f44f4860          MOV      r8,#0xe000
;;;403    		{
;;;404    			SPIx_DMAy_Read(srcAddr, (LCD_DAT_ADDR+offset), _DMA_MOVE_BYTES_COUNT_TOP_);			
00002a  4f0e              LDR      r7,|L9.100|
00002c  e00e              B        |L9.76|
                  |L9.46|
00002e  4642              MOV      r2,r8                 ;402
000030  4294              CMP      r4,r2                 ;402
000032  d90f              BLS      |L9.84|
000034  19e9              ADDS     r1,r5,r7
000036  4630              MOV      r0,r6
000038  f7fffffe          BL       SPIx_DMAy_Read
;;;405    			srcAddr += _DMA_MOVE_BYTES_COUNT_TOP_;
00003c  f5064660          ADD      r6,r6,#0xe000
;;;406    			srcAddr += _DMA_MOVE_BYTES_COUNT_TOP_;
000040  f5064660          ADD      r6,r6,#0xe000
;;;407    			size -= _DMA_MOVE_BYTES_COUNT_TOP_;
000044  f5a44460          SUB      r4,r4,#0xe000
;;;408    			offset += _DMA_MOVE_BYTES_COUNT_TOP_;
000048  f5054560          ADD      r5,r5,#0xe000
                  |L9.76|
00004c  2c00              CMP      r4,#0                 ;399
00004e  d1ee              BNE      |L9.46|
;;;409    		}
;;;410    		// 不超过搬运上限，一次完成
;;;411    		else
;;;412    		{
;;;413    			SPIx_DMAy_Read(srcAddr, (LCD_DAT_ADDR+offset), size);
;;;414    			break;
;;;415    		}
;;;416    	}
;;;417    #undef _DMA_MOVE_BYTES_COUNT_TOP_
;;;418    #endif
;;;419    }
000050  e8bd81f0          POP      {r4-r8,pc}
                  |L9.84|
000054  b2a2              UXTH     r2,r4                 ;413
000056  19e9              ADDS     r1,r5,r7              ;413
000058  4630              MOV      r0,r6                 ;413
00005a  e8bd41f0          POP      {r4-r8,lr}            ;413
00005e  f7ffbffe          B.W      SPIx_DMAy_Read
;;;420    
                          ENDP

000062  0000              DCW      0x0000
                  |L9.100|
                          DCD      0x60020000

                          AREA ||i.LCD_DrawPixel||, CODE, READONLY, ALIGN=2

                  LCD_DrawPixel PROC
;;;106    // 绘制一个像素
;;;107    void LCD_DrawPixel(uint16 x, uint16 y, uint16 color)
000000  b510              PUSH     {r4,lr}
;;;108    {	   
000002  4614              MOV      r4,r2
;;;109    	LCD_SetCursor(x, y);
000004  f7fffffe          BL       LCD_SetCursor
;;;110    
;;;111    	LCD_CMD = 0x002C;
000008  202c              MOVS     r0,#0x2c
00000a  06c1              LSLS     r1,r0,#27
00000c  8008              STRH     r0,[r1,#0]
;;;112    	LCD_WriteColor(color);
00000e  4801              LDR      r0,|L10.20|
000010  8004              STRH     r4,[r0,#0]
;;;113    }	
000012  bd10              POP      {r4,pc}
;;;114    
                          ENDP

                  |L10.20|
                          DCD      0x60020000

                          AREA ||i.LCD_DrawRect||, CODE, READONLY, ALIGN=2

                  LCD_DrawRect PROC
;;;664    // 在指定位置绘制正方形
;;;665    void LCD_DrawRect(uint16 x, uint16 y, uint8 width, uint16 color)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;666    {
000004  b081              SUB      sp,sp,#4
000006  4617              MOV      r7,r2
000008  469b              MOV      r11,r3
;;;667    	uint8 i, j;
;;;668    	uint8 xPos, yPos;
;;;669    	
;;;670    	for(i=0; i<width; i++)
00000a  2600              MOVS     r6,#0
00000c  e01d              B        |L11.74|
                  |L11.14|
;;;671    	{
;;;672    		xPos = x;
00000e  9801              LDR      r0,[sp,#4]
000010  b2c4              UXTB     r4,r0
;;;673    		yPos = y+i;
000012  9802              LDR      r0,[sp,#8]
000014  4430              ADD      r0,r0,r6
000016  b2c0              UXTB     r0,r0
000018  9000              STR      r0,[sp,#0]
;;;674    		for(j=0; j<width; j++)
00001a  2500              MOVS     r5,#0
;;;675    		{
;;;676    			LCD_SetCursor(xPos++, yPos);
;;;677    
;;;678    			LCD_CMD = 0x002C;
00001c  f04f082c          MOV      r8,#0x2c
000020  f04f49c0          MOV      r9,#0x60000000
;;;679    
;;;680    			LCD_WriteColor(color);
000024  f8dfa02c          LDR      r10,|L11.84|
000028  e00b              B        |L11.66|
                  |L11.42|
00002a  4620              MOV      r0,r4                 ;676
00002c  1c64              ADDS     r4,r4,#1              ;676
00002e  b2e4              UXTB     r4,r4                 ;676
000030  9900              LDR      r1,[sp,#0]            ;676
000032  f7fffffe          BL       LCD_SetCursor
000036  f8a98000          STRH     r8,[r9,#0]            ;678
00003a  f8aab000          STRH     r11,[r10,#0]
00003e  1c6d              ADDS     r5,r5,#1              ;674
000040  b2ed              UXTB     r5,r5                 ;674
                  |L11.66|
000042  42bd              CMP      r5,r7                 ;674
000044  d3f1              BCC      |L11.42|
000046  1c76              ADDS     r6,r6,#1              ;670
000048  b2f6              UXTB     r6,r6                 ;670
                  |L11.74|
00004a  42be              CMP      r6,r7                 ;670
00004c  d3df              BCC      |L11.14|
;;;681    		}
;;;682    	}
;;;683    }
00004e  b005              ADD      sp,sp,#0x14
000050  e8bd8ff0          POP      {r4-r11,pc}
;;;684    
                          ENDP

                  |L11.84|
                          DCD      0x60020000

                          AREA ||i.LCD_DriverInit||, CODE, READONLY, ALIGN=2

                  LCD_DriverInit PROC
;;;132    // LCD驱动芯片初始化
;;;133    void LCD_DriverInit(void)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;134    {
;;;135    	LCD_RST_H();
000004  4c5b              LDR      r4,|L12.372|
000006  2101              MOVS     r1,#1
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       gpio_bit_set
;;;136    	Delayms(1);
00000e  2001              MOVS     r0,#1
000010  f7fffffe          BL       Delayms
;;;137    	LCD_RST_L();
000014  2101              MOVS     r1,#1
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       gpio_bit_reset
;;;138    	Delayms(10);
00001c  200a              MOVS     r0,#0xa
00001e  f7fffffe          BL       Delayms
;;;139    	LCD_RST_H();
000022  2101              MOVS     r1,#1
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       gpio_bit_set
;;;140    	Delayms(120);
00002a  2078              MOVS     r0,#0x78
00002c  f7fffffe          BL       Delayms
;;;141    
;;;142    	// 北极光 京东方玻璃  色彩值 05 （较鲜艳） 白团修复 版本
;;;143    	LCD_CMD = (0x11);
000030  2011              MOVS     r0,#0x11
000032  04e4              LSLS     r4,r4,#19
000034  8020              STRH     r0,[r4,#0]
;;;144    	Delayms(120);
000036  2078              MOVS     r0,#0x78
000038  f7fffffe          BL       Delayms
;;;145    	LCD_CMD = (0x36);
00003c  2036              MOVS     r0,#0x36
00003e  8020              STRH     r0,[r4,#0]
;;;146    	LCD_DAT = (0x00);
000040  484d              LDR      r0,|L12.376|
000042  2100              MOVS     r1,#0
000044  8001              STRH     r1,[r0,#0]
;;;147    	LCD_CMD = (0x3a);
000046  223a              MOVS     r2,#0x3a
000048  8022              STRH     r2,[r4,#0]
;;;148    	LCD_DAT = (0x05);
00004a  2205              MOVS     r2,#5
00004c  8002              STRH     r2,[r0,#0]
;;;149    	LCD_CMD = (0x21);
00004e  2221              MOVS     r2,#0x21
000050  8022              STRH     r2,[r4,#0]
;;;150    	LCD_CMD = (0xE7);
000052  22e7              MOVS     r2,#0xe7
000054  8022              STRH     r2,[r4,#0]
;;;151    	LCD_DAT = (0x00);	 //10h-2 data;00h-1data
000056  8001              STRH     r1,[r0,#0]
;;;152    	LCD_CMD = (0x2a);
000058  222a              MOVS     r2,#0x2a
00005a  8022              STRH     r2,[r4,#0]
;;;153    	LCD_DAT = (0x00);
00005c  8001              STRH     r1,[r0,#0]
;;;154    	LCD_DAT = (0x00);
00005e  8001              STRH     r1,[r0,#0]
;;;155    	LCD_DAT = (0x00);
000060  8001              STRH     r1,[r0,#0]
;;;156    	LCD_DAT = (0xef);
000062  22ef              MOVS     r2,#0xef
000064  8002              STRH     r2,[r0,#0]
;;;157    	LCD_CMD = (0x2b);
000066  222b              MOVS     r2,#0x2b
000068  8022              STRH     r2,[r4,#0]
;;;158    	LCD_DAT = (0x00);
00006a  8001              STRH     r1,[r0,#0]
;;;159    	LCD_DAT = (0x00);
00006c  8001              STRH     r1,[r0,#0]
;;;160    	LCD_DAT = (0x00);
00006e  8001              STRH     r1,[r0,#0]
;;;161    	LCD_DAT = (0xef);
000070  22ef              MOVS     r2,#0xef
000072  8002              STRH     r2,[r0,#0]
;;;162    	//---ST7789V Frame rate setting------//
;;;163    	LCD_CMD = (0xb2);
000074  22b2              MOVS     r2,#0xb2
000076  8022              STRH     r2,[r4,#0]
;;;164    	LCD_DAT = (0x0c);
000078  220c              MOVS     r2,#0xc
00007a  8002              STRH     r2,[r0,#0]
;;;165    	LCD_DAT = (0x0c);
00007c  8002              STRH     r2,[r0,#0]
;;;166    	LCD_DAT = (0x00);
00007e  8001              STRH     r1,[r0,#0]
;;;167    	LCD_DAT = (0x33);
000080  2133              MOVS     r1,#0x33
000082  8001              STRH     r1,[r0,#0]
;;;168    	LCD_DAT = (0x33);
000084  8001              STRH     r1,[r0,#0]
;;;169    	LCD_CMD = (0xb7);
000086  22b7              MOVS     r2,#0xb7
000088  8022              STRH     r2,[r4,#0]
;;;170    	LCD_DAT = (0x35);
00008a  2235              MOVS     r2,#0x35
00008c  8002              STRH     r2,[r0,#0]
;;;171    	//--------ST7789V Power setting--------//
;;;172    	LCD_CMD = (0xbb);
00008e  22bb              MOVS     r2,#0xbb
000090  8022              STRH     r2,[r4,#0]
;;;173    	LCD_DAT = (0x2a);
000092  222a              MOVS     r2,#0x2a
000094  8002              STRH     r2,[r0,#0]
;;;174    	LCD_CMD = (0xc0);
000096  22c0              MOVS     r2,#0xc0
000098  8022              STRH     r2,[r4,#0]
;;;175    	LCD_DAT = (0x2c);
00009a  222c              MOVS     r2,#0x2c
00009c  8002              STRH     r2,[r0,#0]
;;;176    	LCD_CMD = (0xc2);
00009e  22c2              MOVS     r2,#0xc2
0000a0  8022              STRH     r2,[r4,#0]
;;;177    	LCD_DAT = (0x01);
0000a2  2201              MOVS     r2,#1
0000a4  8002              STRH     r2,[r0,#0]
;;;178    	LCD_CMD = (0xc3);		// 伽马
0000a6  22c3              MOVS     r2,#0xc3
0000a8  8022              STRH     r2,[r4,#0]
;;;179    	LCD_DAT = (0x05);
0000aa  2205              MOVS     r2,#5
0000ac  8002              STRH     r2,[r0,#0]
;;;180    	LCD_CMD = (0xc4);
0000ae  22c4              MOVS     r2,#0xc4
0000b0  8022              STRH     r2,[r4,#0]
;;;181    	LCD_DAT = (0x20);
0000b2  2220              MOVS     r2,#0x20
0000b4  8002              STRH     r2,[r0,#0]
;;;182    	LCD_CMD = (0xc6);
0000b6  22c6              MOVS     r2,#0xc6
0000b8  8022              STRH     r2,[r4,#0]
;;;183    	LCD_DAT = (0x0f);
0000ba  220f              MOVS     r2,#0xf
0000bc  8002              STRH     r2,[r0,#0]
;;;184    	LCD_CMD = (0xd0);
0000be  22d0              MOVS     r2,#0xd0
0000c0  8022              STRH     r2,[r4,#0]
;;;185    	LCD_DAT = (0xa4);
0000c2  22a4              MOVS     r2,#0xa4
0000c4  8002              STRH     r2,[r0,#0]
;;;186    	LCD_DAT = (0xa1);
0000c6  22a1              MOVS     r2,#0xa1
0000c8  8002              STRH     r2,[r0,#0]
;;;187    	LCD_CMD = (0xe9);
0000ca  22e9              MOVS     r2,#0xe9
0000cc  8022              STRH     r2,[r4,#0]
;;;188    	LCD_DAT = (0x11);
0000ce  2211              MOVS     r2,#0x11
0000d0  8002              STRH     r2,[r0,#0]
;;;189    	LCD_DAT = (0x11);
0000d2  8002              STRH     r2,[r0,#0]
;;;190    	LCD_DAT = (0x03);	
0000d4  2203              MOVS     r2,#3
0000d6  8002              STRH     r2,[r0,#0]
;;;191    	
;;;192    	//--------------ST7789V
;;;193    	LCD_CMD = (0xe0);
0000d8  22e0              MOVS     r2,#0xe0
0000da  8022              STRH     r2,[r4,#0]
;;;194    	LCD_DAT = (0xf0);
0000dc  22f0              MOVS     r2,#0xf0
0000de  8002              STRH     r2,[r0,#0]
;;;195    	LCD_DAT = (0x09);
0000e0  2209              MOVS     r2,#9
0000e2  8002              STRH     r2,[r0,#0]
;;;196    	LCD_DAT = (0x13);
0000e4  2313              MOVS     r3,#0x13
0000e6  8003              STRH     r3,[r0,#0]
;;;197    	LCD_DAT = (0x0a);
0000e8  250a              MOVS     r5,#0xa
0000ea  8005              STRH     r5,[r0,#0]
;;;198    	LCD_DAT = (0x0b);
0000ec  260b              MOVS     r6,#0xb
0000ee  8006              STRH     r6,[r0,#0]
;;;199    	LCD_DAT = (0x06);
0000f0  2706              MOVS     r7,#6
0000f2  8007              STRH     r7,[r0,#0]
;;;200    	LCD_DAT = (0x38);
0000f4  f04f0c38          MOV      r12,#0x38
0000f8  f8a0c000          STRH     r12,[r0,#0]
;;;201    	LCD_DAT = (0x33);
0000fc  8001              STRH     r1,[r0,#0]
;;;202    	LCD_DAT = (0x4f);
0000fe  f04f084f          MOV      r8,#0x4f
000102  f8a08000          STRH     r8,[r0,#0]
;;;203    	LCD_DAT = (0x04);
000106  f04f0904          MOV      r9,#4
00010a  f8a09000          STRH     r9,[r0,#0]
;;;204    	LCD_DAT = (0x0d);
00010e  f04f0a0d          MOV      r10,#0xd
000112  f8a0a000          STRH     r10,[r0,#0]
;;;205    	LCD_DAT = (0x19);
000116  f04f0b19          MOV      r11,#0x19
00011a  f8a0b000          STRH     r11,[r0,#0]
;;;206    	LCD_DAT = (0x2e);
00011e  222e              MOVS     r2,#0x2e
000120  8002              STRH     r2,[r0,#0]
;;;207    	LCD_DAT = (0x2f);
000122  f04f0e2f          MOV      lr,#0x2f
000126  f8a0e000          STRH     lr,[r0,#0]
;;;208    	LCD_CMD = (0xe1);
00012a  f04f0ee1          MOV      lr,#0xe1
00012e  f8a4e000          STRH     lr,[r4,#0]
;;;209    	LCD_DAT = (0xf0);
000132  f04f0ef0          MOV      lr,#0xf0
000136  f8a0e000          STRH     lr,[r0,#0]
;;;210    	LCD_DAT = (0x09);
00013a  f04f0e09          MOV      lr,#9
00013e  f8a0e000          STRH     lr,[r0,#0]
;;;211    	LCD_DAT = (0x13);
000142  8003              STRH     r3,[r0,#0]
;;;212    	LCD_DAT = (0x0a);
000144  8005              STRH     r5,[r0,#0]
;;;213    	LCD_DAT = (0x0b);
000146  8006              STRH     r6,[r0,#0]
;;;214    	LCD_DAT = (0x06);
000148  8007              STRH     r7,[r0,#0]
;;;215    	LCD_DAT = (0x38);
00014a  f8a0c000          STRH     r12,[r0,#0]
;;;216    	LCD_DAT = (0x33);
00014e  8001              STRH     r1,[r0,#0]
;;;217    	LCD_DAT = (0x4f);
000150  f8a08000          STRH     r8,[r0,#0]
;;;218    	LCD_DAT = (0x04);
000154  f8a09000          STRH     r9,[r0,#0]
;;;219    	LCD_DAT = (0x0d);
000158  f8a0a000          STRH     r10,[r0,#0]
;;;220    	LCD_DAT = (0x19);
00015c  f8a0b000          STRH     r11,[r0,#0]
;;;221    	LCD_DAT = (0x2e);
000160  8002              STRH     r2,[r0,#0]
;;;222    	LCD_DAT = (0x2f);
000162  212f              MOVS     r1,#0x2f
000164  8001              STRH     r1,[r0,#0]
;;;223    	Delayms(150);
000166  2096              MOVS     r0,#0x96
000168  f7fffffe          BL       Delayms
;;;224    	LCD_CMD = (0x29);
00016c  2029              MOVS     r0,#0x29
00016e  8020              STRH     r0,[r4,#0]
;;;225    }
000170  e8bd9ff0          POP      {r4-r12,pc}
;;;226    
                          ENDP

                  |L12.372|
                          DCD      0x40010c00
                  |L12.376|
                          DCD      0x60020000

                          AREA ||i.LCD_FSMCInit||, CODE, READONLY, ALIGN=1

                  LCD_FSMCInit PROC
;;;272    ********************************************************************************/ 
;;;273    void LCD_FSMCInit(void)
000000  b500              PUSH     {lr}
;;;274    {
000002  b097              SUB      sp,sp,#0x5c
;;;275        // GD32
;;;276        exmc_norsram_parameter_struct lcd_init_struct;
;;;277        exmc_norsram_timing_parameter_struct lcd_timing_init_struct;	
;;;278    
;;;279    	// 使能FSMC时钟
;;;280    	rcu_periph_clock_enable(RCU_EXMC);
000004  f44f60a1          MOV      r0,#0x508
000008  f7fffffe          BL       rcu_periph_clock_enable
;;;281    	exmc_norsram_deinit(EXMC_BANK0_NORSRAM_REGION0);
00000c  2000              MOVS     r0,#0
00000e  f7fffffe          BL       exmc_norsram_deinit
;;;282    
;;;283        /*-- FSMC Configuration ------------------------------------------------------*/
;;;284        /* FSMC_Bank1_NORSRAM1 configuration */
;;;285    	lcd_timing_init_struct.asyn_address_setuptime = 1;
000012  2101              MOVS     r1,#1
000014  9107              STR      r1,[sp,#0x1c]
;;;286    	lcd_timing_init_struct.asyn_address_holdtime = 0;
000016  2000              MOVS     r0,#0
000018  9006              STR      r0,[sp,#0x18]
;;;287    	lcd_timing_init_struct.asyn_data_setuptime = 2;
00001a  2202              MOVS     r2,#2
00001c  9205              STR      r2,[sp,#0x14]
;;;288    	lcd_timing_init_struct.bus_latency = 0;
00001e  9004              STR      r0,[sp,#0x10]
;;;289    	lcd_timing_init_struct.syn_clk_division = EXMC_SYN_CLOCK_RATIO_DISABLE;
000020  9003              STR      r0,[sp,#0xc]
;;;290    	lcd_timing_init_struct.syn_data_latency = EXMC_DATALAT_2_CLK;
000022  9002              STR      r0,[sp,#8]
;;;291    	lcd_timing_init_struct.asyn_access_mode = EXMC_ACCESS_MODE_B;
000024  070a              LSLS     r2,r1,#28
000026  9201              STR      r2,[sp,#4]
;;;292    
;;;293        /* Color LCD configuration ------------------------------------
;;;294         LCD configured as follow:
;;;295            - Data/Address MUX = Disable
;;;296            - Memory Type = SRAM
;;;297            - Data Width = 16bit
;;;298            - Write Operation = Enable
;;;299            - Extended Mode = Enable
;;;300            - Asynchronous Wait = Disable */
;;;301    	lcd_init_struct.norsram_region = EXMC_BANK0_NORSRAM_REGION0;
000028  9008              STR      r0,[sp,#0x20]
;;;302    	lcd_init_struct.address_data_mux = DISABLE;
00002a  9014              STR      r0,[sp,#0x50]
;;;303       	lcd_init_struct.memory_type = EXMC_MEMORY_TYPE_PSRAM;	
00002c  2204              MOVS     r2,#4
00002e  9213              STR      r2,[sp,#0x4c]
;;;304    	lcd_init_struct.asyn_wait = DISABLE;
000030  900b              STR      r0,[sp,#0x2c]
;;;305    	lcd_init_struct.databus_width = EXMC_NOR_DATABUS_WIDTH_16B;
000032  2210              MOVS     r2,#0x10
000034  9212              STR      r2,[sp,#0x48]
;;;306    	lcd_init_struct.burst_mode = DISABLE;
000036  9011              STR      r0,[sp,#0x44]
;;;307    	lcd_init_struct.nwait_polarity = EXMC_NWAIT_POLARITY_LOW;
000038  9010              STR      r0,[sp,#0x40]
;;;308    	lcd_init_struct.wrap_burst_mode = DISABLE;	
00003a  900f              STR      r0,[sp,#0x3c]
;;;309    	lcd_init_struct.nwait_config = EXMC_NWAIT_CONFIG_BEFORE;	
00003c  900e              STR      r0,[sp,#0x38]
;;;310    	lcd_init_struct.memory_write = ENABLE;
00003e  910d              STR      r1,[sp,#0x34]
;;;311        lcd_init_struct.nwait_signal = DISABLE;
000040  900c              STR      r0,[sp,#0x30]
;;;312    	lcd_init_struct.extended_mode = DISABLE;
000042  900a              STR      r0,[sp,#0x28]
;;;313    	lcd_init_struct.write_mode = EXMC_ASYN_WRITE;								// 异步写
000044  9009              STR      r0,[sp,#0x24]
;;;314        lcd_init_struct.read_write_timing = &lcd_timing_init_struct;
000046  a801              ADD      r0,sp,#4
000048  9015              STR      r0,[sp,#0x54]
;;;315        lcd_init_struct.write_timing = &lcd_timing_init_struct;
00004a  9016              STR      r0,[sp,#0x58]
;;;316    	exmc_norsram_init(&lcd_init_struct);
00004c  a808              ADD      r0,sp,#0x20
00004e  f7fffffe          BL       exmc_norsram_init
;;;317    
;;;318    	/* - BANK 1 (of NOR/SRAM Bank 0~3) is enabled */
;;;319        exmc_norsram_enable(EXMC_BANK0_NORSRAM_REGION0);
000052  2000              MOVS     r0,#0
000054  f7fffffe          BL       exmc_norsram_enable
;;;320    }
000058  b017              ADD      sp,sp,#0x5c
00005a  bd00              POP      {pc}
;;;321    
                          ENDP


                          AREA ||i.LCD_FillColor||, CODE, READONLY, ALIGN=2

                  LCD_FillColor PROC
;;;115    // 填充指定的颜色
;;;116    void LCD_FillColor(uint16 color)
000000  b570              PUSH     {r4-r6,lr}
;;;117    {
000002  4604              MOV      r4,r0
;;;118    	uint16 i,j;
;;;119    
;;;120    	// 从原点开始扫描
;;;121    	LCD_SetAreaByPointAndSize(0, 0, LCD_WIDTH, LCD_HEIGHT);
000004  f44f76a0          MOV      r6,#0x140
000008  2100              MOVS     r1,#0
00000a  4633              MOV      r3,r6
00000c  22f0              MOVS     r2,#0xf0
00000e  4608              MOV      r0,r1
000010  f7fffffe          BL       LCD_SetAreaByPointAndSize
;;;122    
;;;123    	for (i=0;i<LCD_HEIGHT;i++)
000014  2200              MOVS     r2,#0
;;;124    	{
;;;125    		for (j=0;j<LCD_WIDTH;j++)
;;;126    		{
;;;127    			LCD_WriteColor(color);
000016  4d06              LDR      r5,|L14.48|
                  |L14.24|
000018  2100              MOVS     r1,#0                 ;125
                  |L14.26|
00001a  802c              STRH     r4,[r5,#0]
00001c  1c49              ADDS     r1,r1,#1              ;125
00001e  b289              UXTH     r1,r1                 ;125
000020  29f0              CMP      r1,#0xf0              ;125
000022  d3fa              BCC      |L14.26|
000024  1c52              ADDS     r2,r2,#1              ;123
000026  b292              UXTH     r2,r2                 ;123
000028  42b2              CMP      r2,r6                 ;123
00002a  d3f5              BCC      |L14.24|
;;;128    		}
;;;129    	}
;;;130    }
00002c  bd70              POP      {r4-r6,pc}
;;;131    
                          ENDP

00002e  0000              DCW      0x0000
                  |L14.48|
                          DCD      0x60020000

                          AREA ||i.LCD_Init||, CODE, READONLY, ALIGN=2

                  LCD_Init PROC
;;;322    // LCD驱动模块初始化
;;;323    void LCD_Init(void)
000000  b510              PUSH     {r4,lr}
;;;324    {
;;;325    	LCD_CtrlPortInit();
000002  f7fffffe          BL       LCD_CtrlPortInit
;;;326    
;;;327    	LCD_FSMCInit();
000006  f7fffffe          BL       LCD_FSMCInit
;;;328    
;;;329    	LCD_DriverInit();
00000a  f7fffffe          BL       LCD_DriverInit
;;;330    
;;;331    	LCD_FillColor(LCD_COLOR_BLACK);
00000e  2000              MOVS     r0,#0
000010  f7fffffe          BL       LCD_FillColor
;;;332    
;;;333    	// LCD背光关闭
;;;334    	LCD_BL_OFF();
000014  e8bd4010          POP      {r4,lr}
000018  f44f7180          MOV      r1,#0x100
00001c  4801              LDR      r0,|L15.36|
00001e  f7ffbffe          B.W      gpio_bit_reset
;;;335    //	LCD_BL_ON();
;;;336    //	
;;;337    //	LCD_FillColor(LCD_COLOR_RED);
;;;338    //	LCD_FillColor(LCD_COLOR_GREEN);
;;;339    //	LCD_FillColor(LCD_COLOR_BLUE);
;;;340    }
;;;341    
                          ENDP

000022  0000              DCW      0x0000
                  |L15.36|
                          DCD      0x40010800

                          AREA ||i.LCD_PrintChar||, CODE, READONLY, ALIGN=2

                  LCD_PrintChar PROC
;;;575    // 在指定坐标位置打印一个字符
;;;576    void LCD_PrintChar(uint16 x, uint16 y, uint8 ch, uint16 color, LCD_OPERATOR_MODE_E mode)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;577    {
000004  4681              MOV      r9,r0
000006  468a              MOV      r10,r1
000008  4610              MOV      r0,r2
00000a  4698              MOV      r8,r3
;;;578    	uint16 width=0, height=0;
;;;579    	uint32 i, j;
;;;580    	uint32 size;
;;;581    	uint16* pData = FONT_GetAsciiDataPtr(ch);
00000c  f7fffffe          BL       FONT_GetAsciiDataPtr
000010  4607              MOV      r7,r0
;;;582    	uint16 mask=0x0001;
000012  2401              MOVS     r4,#1
;;;583    	
;;;584    	width = 6;//FONT_WIDTH();
000014  2506              MOVS     r5,#6
;;;585    	height = 16;//FONT_HEIGHT();
000016  2610              MOVS     r6,#0x10
;;;586    
;;;587    	size = width;
;;;588    	size *= height;
;;;589    
;;;590    	LCD_SetAreaByPointAndSize(x, y, width, height);
000018  4633              MOV      r3,r6
00001a  462a              MOV      r2,r5
00001c  4651              MOV      r1,r10
00001e  4648              MOV      r0,r9
000020  f7fffffe          BL       LCD_SetAreaByPointAndSize
;;;591    
;;;592    	for(i=0; i<height; i++)
000024  2100              MOVS     r1,#0
;;;593    	{
;;;594    		for(j=0; j<width; j++)
;;;595    		{
;;;596    			if((*(pData+j)) & mask)
;;;597    			{
;;;598    				LCD_WriteColor(color);
000026  4a0d              LDR      r2,|L16.92|
000028  2300              MOVS     r3,#0
;;;599    			}
;;;600    			else
;;;601    			{
;;;602    				LCD_WriteColor(0);
;;;603    			}
;;;604    		}
;;;605    
;;;606    		mask <<= 1;
00002a  f64f7cff          MOV      r12,#0xffff
00002e  e010              B        |L16.82|
                  |L16.48|
000030  2000              MOVS     r0,#0                 ;594
000032  e009              B        |L16.72|
                  |L16.52|
000034  f8379010          LDRH     r9,[r7,r0,LSL #1]     ;596
000038  ea190f04          TST      r9,r4                 ;596
00003c  d002              BEQ      |L16.68|
00003e  f8a28000          STRH     r8,[r2,#0]            ;598
000042  e000              B        |L16.70|
                  |L16.68|
000044  8013              STRH     r3,[r2,#0]            ;602
                  |L16.70|
000046  1c40              ADDS     r0,r0,#1              ;594
                  |L16.72|
000048  42a8              CMP      r0,r5                 ;594
00004a  d3f3              BCC      |L16.52|
00004c  ea0c0444          AND      r4,r12,r4,LSL #1
000050  1c49              ADDS     r1,r1,#1              ;592
                  |L16.82|
000052  42b1              CMP      r1,r6                 ;592
000054  d3ec              BCC      |L16.48|
;;;607    	}
;;;608    }
000056  e8bd87f0          POP      {r4-r10,pc}
;;;609    
                          ENDP

00005a  0000              DCW      0x0000
                  |L16.92|
                          DCD      0x60020000

                          AREA ||i.LCD_PrintString||, CODE, READONLY, ALIGN=1

                  LCD_PrintString PROC
;;;610    // 从指定位置开始，打印一个字符串
;;;611    void LCD_PrintString(uint16 x, uint16 y, char* pStr, uint16 color, LCD_OPERATOR_MODE_E mode)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;612    {
000004  4614              MOV      r4,r2
000006  9e08              LDR      r6,[sp,#0x20]
000008  4698              MOV      r8,r3
;;;613    	uint16 xPos=x, yPos=y;
00000a  4605              MOV      r5,r0
00000c  460f              MOV      r7,r1
;;;614    	
;;;615    	if(NULL == pStr)
00000e  2c00              CMP      r4,#0
000010  d011              BEQ      |L17.54|
;;;616    	{
;;;617    		return;
;;;618    	}
;;;619    
;;;620    	if((x >= LCD_WIDTH)||(y >= LCD_HEIGHT))
000012  28f0              CMP      r0,#0xf0
000014  d20f              BCS      |L17.54|
000016  f5b17fa0          CMP      r1,#0x140
00001a  d20c              BCS      |L17.54|
00001c  e008              B        |L17.48|
                  |L17.30|
;;;621    	{
;;;622    		return;
;;;623    	}
;;;624    
;;;625    	while(0 != *pStr)
;;;626    	{
;;;627    		LCD_PrintChar(xPos, yPos, *pStr, color, mode);
00001e  4643              MOV      r3,r8
000020  4639              MOV      r1,r7
000022  4628              MOV      r0,r5
000024  9600              STR      r6,[sp,#0]
000026  f7fffffe          BL       LCD_PrintChar
;;;628    
;;;629    		xPos += FONT_WIDTH();
00002a  1dad              ADDS     r5,r5,#6
00002c  b2ad              UXTH     r5,r5
;;;630    		pStr ++;
00002e  1c64              ADDS     r4,r4,#1
                  |L17.48|
000030  7822              LDRB     r2,[r4,#0]            ;625
000032  2a00              CMP      r2,#0                 ;625
000034  d1f3              BNE      |L17.30|
                  |L17.54|
;;;631    	}
;;;632    }
000036  e8bd83f8          POP      {r3-r9,pc}
;;;633    
                          ENDP


                          AREA ||i.LCD_PrintStringNum||, CODE, READONLY, ALIGN=2

                  LCD_PrintStringNum PROC
;;;654    // 从指定位置开始，打印数字
;;;655    void LCD_PrintStringNum(uint16 x, uint16 y, uint32 u8Num, uint16 color, LCD_OPERATOR_MODE_E mode)
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;656    {
000004  4605              MOV      r5,r0
000006  9c0a              LDR      r4,[sp,#0x28]
000008  460e              MOV      r6,r1
00000a  4610              MOV      r0,r2
00000c  461f              MOV      r7,r3
;;;657    	char outStr[10];
;;;658    	
;;;659    	itoa(u8Num,outStr);
00000e  a901              ADD      r1,sp,#4
000010  f7fffffe          BL       itoa
;;;660    	LCD_PrintString(x, y, "             ",color , mode);
000014  463b              MOV      r3,r7
000016  a207              ADR      r2,|L18.52|
000018  4631              MOV      r1,r6
00001a  4628              MOV      r0,r5
00001c  9400              STR      r4,[sp,#0]
00001e  f7fffffe          BL       LCD_PrintString
;;;661    	LCD_PrintString(x, y, outStr,color , mode);
000022  463b              MOV      r3,r7
000024  aa01              ADD      r2,sp,#4
000026  4631              MOV      r1,r6
000028  4628              MOV      r0,r5
00002a  9400              STR      r4,[sp,#0]
00002c  f7fffffe          BL       LCD_PrintString
;;;662    }
000030  e8bd81ff          POP      {r0-r8,pc}
;;;663    
                          ENDP

                  |L18.52|
000034  20202020          DCB      "             ",0
000038  20202020
00003c  20202020
000040  2000    
000042  00                DCB      0
000043  00                DCB      0

                          AREA ||i.LCD_Process||, CODE, READONLY, ALIGN=1

                  LCD_Process PROC
;;;342    // LCD处理过程函数
;;;343    void LCD_Process(void)
000000  4770              BX       lr
;;;344    {
;;;345    }
;;;346    
                          ENDP


                          AREA ||i.LCD_SetAreaBy2Point||, CODE, READONLY, ALIGN=2

                  LCD_SetAreaBy2Point PROC
;;;44     // 设定操作区域，输入参数为起始x坐标、结束x坐标、起始y坐标、结束y坐标
;;;45     void LCD_SetAreaBy2Point(uint16 startX, uint16 startY, uint16 endX, uint16 endY)
000000  b570              PUSH     {r4-r6,lr}
;;;46     {
;;;47     	LCD_CMD = 0x002A;
000002  f04f45c0          MOV      r5,#0x60000000
000006  242a              MOVS     r4,#0x2a
000008  802c              STRH     r4,[r5,#0]
;;;48     	LCD_DAT = startX>>8;
00000a  4c0b              LDR      r4,|L20.56|
00000c  0a06              LSRS     r6,r0,#8
00000e  8026              STRH     r6,[r4,#0]
;;;49     	LCD_DAT = startX&0XFF;
000010  b2c0              UXTB     r0,r0
000012  8020              STRH     r0,[r4,#0]
;;;50     	LCD_DAT = endX>>8;
000014  0a10              LSRS     r0,r2,#8
000016  8020              STRH     r0,[r4,#0]
;;;51     	LCD_DAT = endX&0XFF;
000018  b2d0              UXTB     r0,r2
00001a  8020              STRH     r0,[r4,#0]
;;;52     
;;;53     	LCD_CMD = 0x002B;
00001c  202b              MOVS     r0,#0x2b
00001e  8028              STRH     r0,[r5,#0]
;;;54     	LCD_DAT = startY>>8;
000020  0a08              LSRS     r0,r1,#8
000022  8020              STRH     r0,[r4,#0]
;;;55     	LCD_DAT = startY&0XFF;
000024  b2c8              UXTB     r0,r1
000026  8020              STRH     r0,[r4,#0]
;;;56     	LCD_DAT = endY>>8;
000028  0a18              LSRS     r0,r3,#8
00002a  8020              STRH     r0,[r4,#0]
;;;57     	LCD_DAT = endY&0XFF;
00002c  b2d8              UXTB     r0,r3
00002e  8020              STRH     r0,[r4,#0]
;;;58     
;;;59     	LCD_WriteGRAM();
000030  202c              MOVS     r0,#0x2c
000032  8028              STRH     r0,[r5,#0]
;;;60     }
000034  bd70              POP      {r4-r6,pc}
;;;61     
                          ENDP

000036  0000              DCW      0x0000
                  |L20.56|
                          DCD      0x60020000

                          AREA ||i.LCD_SetAreaByPointAndSize||, CODE, READONLY, ALIGN=2

                  LCD_SetAreaByPointAndSize PROC
;;;62     // 设定操作区域，输入参数为起始x坐标、起始y坐标、区域宽、区域高
;;;63     void LCD_SetAreaByPointAndSize(uint16 startX, uint16 startY, uint16 width, uint16 height)
000000  b570              PUSH     {r4-r6,lr}
;;;64     {
;;;65     	LCD_CMD = 0x002A;
000002  f04f45c0          MOV      r5,#0x60000000
000006  242a              MOVS     r4,#0x2a
000008  802c              STRH     r4,[r5,#0]
;;;66     	LCD_DAT = startX>>8;
00000a  4c0d              LDR      r4,|L21.64|
00000c  0a06              LSRS     r6,r0,#8
00000e  8026              STRH     r6,[r4,#0]
;;;67     	LCD_DAT = startX&0XFF;
000010  b2c6              UXTB     r6,r0
000012  8026              STRH     r6,[r4,#0]
;;;68     	LCD_DAT = (startX+width-1)>>8;
000014  4410              ADD      r0,r0,r2
000016  1e40              SUBS     r0,r0,#1
000018  0a02              LSRS     r2,r0,#8
00001a  8022              STRH     r2,[r4,#0]
;;;69     	LCD_DAT = (startX+width-1)&0XFF;
00001c  b2c0              UXTB     r0,r0
00001e  8020              STRH     r0,[r4,#0]
;;;70     
;;;71     	LCD_CMD = 0x002B;
000020  202b              MOVS     r0,#0x2b
000022  8028              STRH     r0,[r5,#0]
;;;72     	LCD_DAT = startY>>8;
000024  0a08              LSRS     r0,r1,#8
000026  8020              STRH     r0,[r4,#0]
;;;73     	LCD_DAT = startY&0XFF;
000028  b2c8              UXTB     r0,r1
00002a  8020              STRH     r0,[r4,#0]
;;;74     	LCD_DAT = (startY+height-1)>>8;
00002c  18c8              ADDS     r0,r1,r3
00002e  1e40              SUBS     r0,r0,#1
000030  0a01              LSRS     r1,r0,#8
000032  8021              STRH     r1,[r4,#0]
;;;75     	LCD_DAT = (startY+height-1)&0XFF;
000034  b2c0              UXTB     r0,r0
000036  8020              STRH     r0,[r4,#0]
;;;76     
;;;77     	LCD_WriteGRAM();
000038  202c              MOVS     r0,#0x2c
00003a  8028              STRH     r0,[r5,#0]
;;;78     }
00003c  bd70              POP      {r4-r6,pc}
;;;79     
                          ENDP

00003e  0000              DCW      0x0000
                  |L21.64|
                          DCD      0x60020000

                          AREA ||i.LCD_SetCursor||, CODE, READONLY, ALIGN=2

                  LCD_SetCursor PROC
;;;30     // 设定起始扫描坐标
;;;31     void LCD_SetCursor(uint16 x, uint16 y)
000000  b510              PUSH     {r4,lr}
;;;32     {
;;;33     	LCD_CMD = 0x002A;
000002  f04f43c0          MOV      r3,#0x60000000
000006  222a              MOVS     r2,#0x2a
000008  801a              STRH     r2,[r3,#0]
;;;34     	LCD_DAT = x>>8;
00000a  4a07              LDR      r2,|L22.40|
00000c  0a04              LSRS     r4,r0,#8
00000e  8014              STRH     r4,[r2,#0]
;;;35     	LCD_DAT = x&0XFF;
000010  b2c0              UXTB     r0,r0
000012  8010              STRH     r0,[r2,#0]
;;;36     
;;;37     	LCD_CMD = 0x002B;
000014  202b              MOVS     r0,#0x2b
000016  8018              STRH     r0,[r3,#0]
;;;38     	LCD_DAT = y>>8;
000018  0a08              LSRS     r0,r1,#8
00001a  8010              STRH     r0,[r2,#0]
;;;39     	LCD_DAT = y&0XFF;
00001c  b2c8              UXTB     r0,r1
00001e  8010              STRH     r0,[r2,#0]
;;;40     
;;;41     	LCD_WriteGRAM();
000020  202c              MOVS     r0,#0x2c
000022  8018              STRH     r0,[r3,#0]
;;;42     }
000024  bd10              POP      {r4,pc}
;;;43     
                          ENDP

000026  0000              DCW      0x0000
                  |L22.40|
                          DCD      0x60020000

                          AREA ||i.itoa||, CODE, READONLY, ALIGN=1

                  itoa PROC
;;;633    
;;;634    void itoa(uint32 n,char outStr[])
000000  b5f0              PUSH     {r4-r7,lr}
;;;635    {
000002  b085              SUB      sp,sp,#0x14
;;;636    	int i,j,sign;
;;;637    	uint8 s[20];
;;;638    	i=0;
000004  2200              MOVS     r2,#0
;;;639    	do{
;;;640    		s[i++]=n%10+'0';
000006  230a              MOVS     r3,#0xa
000008  466c              MOV      r4,sp                 ;637
                  |L23.10|
00000a  fbb0f5f3          UDIV     r5,r0,r3
00000e  fb030515          MLS      r5,r3,r5,r0
000012  3530              ADDS     r5,r5,#0x30
000014  4617              MOV      r7,r2
000016  1c52              ADDS     r2,r2,#1
000018  55e5              STRB     r5,[r4,r7]
;;;641    	}
;;;642    	while((n/=10)>0);
00001a  fbb0f0f3          UDIV     r0,r0,r3
00001e  2800              CMP      r0,#0
000020  d1f3              BNE      |L23.10|
;;;643    	
;;;644    	if(sign<0)
000022  2e00              CMP      r6,#0
000024  da03              BGE      |L23.46|
;;;645    	s[i++]='-';
000026  232d              MOVS     r3,#0x2d
000028  4610              MOV      r0,r2
00002a  1c52              ADDS     r2,r2,#1
00002c  5423              STRB     r3,[r4,r0]
                  |L23.46|
;;;646    	s[i]='\0';
00002e  2500              MOVS     r5,#0
000030  54a5              STRB     r5,[r4,r2]
;;;647    	j=i;
;;;648    	i=0;
000032  2000              MOVS     r0,#0
;;;649    	for(;j>0;j--)
000034  e006              B        |L23.68|
                  |L23.54|
;;;650    		outStr[i++] = s[j-1];
000036  18a3              ADDS     r3,r4,r2
000038  f8136c01          LDRB     r6,[r3,#-1]
00003c  4603              MOV      r3,r0
00003e  1c40              ADDS     r0,r0,#1
000040  54ce              STRB     r6,[r1,r3]
000042  1e52              SUBS     r2,r2,#1              ;649
                  |L23.68|
000044  2a00              CMP      r2,#0                 ;649
000046  dcf6              BGT      |L23.54|
;;;651    	outStr[i] = '\0';
000048  540d              STRB     r5,[r1,r0]
;;;652    } 
00004a  b005              ADD      sp,sp,#0x14
00004c  bdf0              POP      {r4-r7,pc}
;;;653    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=0

                  count
000000  00                DCB      0x00

                          AREA ||area_number.27||, DATA, ALIGN=1

                          EXPORTAS ||area_number.27||, ||.data||
                  lcdCB
000000  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "User\\lcd.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_lcd_c_f9d25535____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___5_lcd_c_f9d25535____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_lcd_c_f9d25535____REVSH|
#line 128
|__asm___5_lcd_c_f9d25535____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
