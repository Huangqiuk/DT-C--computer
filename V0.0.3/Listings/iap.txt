; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\iap.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\iap.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.3\Device\Include -D__MICROLIB -D__UVISION_VERSION=539 -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\iap.crf User\iap.c]
                          THUMB

                          AREA ||i.IAP_BleWriteAppBin||, CODE, READONLY, ALIGN=2

                  IAP_BleWriteAppBin PROC
;;;204    *******************************************************************************/
;;;205    BOOL IAP_BleWriteAppBin(uint32 appAddr, uint8 *appBuf, uint32 appSize)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;206    {
000004  460c              MOV      r4,r1
000006  4690              MOV      r8,r2
;;;207    	uint16 i = 0;
000008  2500              MOVS     r5,#0
;;;208    	uint16 j = 0;
00000a  2600              MOVS     r6,#0
;;;209    	uint32 curAppAddr = appAddr; 	// 当前写入的地址
00000c  4681              MOV      r9,r0
;;;210    	uint32 *iapBuf = NULL;
;;;211    	BOOL writeStatus;
;;;212    	
;;;213    	// 参数判断
;;;214    	if (NULL == appBuf)
00000e  2c00              CMP      r4,#0
000010  d009              BEQ      |L1.38|
;;;215    	{
;;;216    		return FALSE;
;;;217    	}
;;;218    
;;;219    	// 参数检验是否非法，地址不能是IAP本身代码地址，绝对不能自己把自己擦掉
;;;220    	if ((appAddr < IAP_FLASH_APP1_ADDR) || ((appAddr + appSize) > (IAP_GD32_FLASH_BASE+IAP_GD32_FLASH_SIZE)))
000012  491a              LDR      r1,|L1.124|
000014  4288              CMP      r0,r1
000016  d303              BCC      |L1.32|
000018  4919              LDR      r1,|L1.128|
00001a  4440              ADD      r0,r0,r8
00001c  4288              CMP      r0,r1
00001e  d904              BLS      |L1.42|
                  |L1.32|
;;;221    	{
;;;222    		return FALSE;		// 非法地址
000020  2000              MOVS     r0,#0
                  |L1.34|
;;;223    	}
;;;224    
;;;225    	// 开辟临时内存
;;;226    	iapBuf = (uint32 *)malloc(1024);
;;;227    	if (NULL == iapBuf)
;;;228    	{
;;;229    		return FALSE;
;;;230    	}
;;;231    	
;;;232    	// 循环写入
;;;233    	for (i = 0, j = 0; j < appSize; j += 4)
;;;234    	{
;;;235    		// 字节整合
;;;236    		iapBuf[i++] = (uint32)(*appBuf) + ((uint32)(*(appBuf+1)) << 8) + ((uint32)(*(appBuf+2)) << 16) + ((uint32)(*(appBuf+3)) << 24);
;;;237    		// 偏移4个字节
;;;238    		appBuf += 4;
;;;239    	}      
;;;240    	
;;;241    	// 直接写入FLASH
;;;242    	writeStatus = IAP_FlashWriteWordArray(curAppAddr, iapBuf, appSize/4);	
;;;243    	
;;;244    	// 释放内存
;;;245    	free(iapBuf);
;;;246    	
;;;247    	return writeStatus;
;;;248    }
000022  e8bd87f0          POP      {r4-r10,pc}
                  |L1.38|
000026  2000              MOVS     r0,#0                 ;216
000028  e7fb              B        |L1.34|
                  |L1.42|
00002a  f44f6080          MOV      r0,#0x400             ;226
00002e  f7fffffe          BL       malloc
000032  4607              MOV      r7,r0                 ;226
000034  0038              MOVS     r0,r7                 ;227
000036  d112              BNE      |L1.94|
000038  e7f3              B        |L1.34|
                  |L1.58|
00003a  7820              LDRB     r0,[r4,#0]            ;236
00003c  7861              LDRB     r1,[r4,#1]            ;236
00003e  78e2              LDRB     r2,[r4,#3]            ;236
000040  eb002001          ADD      r0,r0,r1,LSL #8       ;236
000044  78a1              LDRB     r1,[r4,#2]            ;236
000046  0409              LSLS     r1,r1,#16             ;236
000048  eb016102          ADD      r1,r1,r2,LSL #24      ;236
00004c  4401              ADD      r1,r1,r0              ;236
00004e  4628              MOV      r0,r5                 ;236
000050  1c6d              ADDS     r5,r5,#1              ;236
000052  b2ad              UXTH     r5,r5                 ;236
000054  f8471020          STR      r1,[r7,r0,LSL #2]     ;236
000058  1d24              ADDS     r4,r4,#4              ;238
00005a  1d36              ADDS     r6,r6,#4              ;233
00005c  b2b6              UXTH     r6,r6                 ;233
                  |L1.94|
00005e  4546              CMP      r6,r8                 ;233
000060  d3eb              BCC      |L1.58|
000062  f3c8028f          UBFX     r2,r8,#2,#16          ;242
000066  4639              MOV      r1,r7                 ;242
000068  4648              MOV      r0,r9                 ;242
00006a  f7fffffe          BL       IAP_FlashWriteWordArray
00006e  4604              MOV      r4,r0                 ;242
000070  4638              MOV      r0,r7                 ;245
000072  f7fffffe          BL       free
000076  4620              MOV      r0,r4                 ;247
000078  e7d3              B        |L1.34|
;;;249    
                          ENDP

00007a  0000              DCW      0x0000
                  |L1.124|
                          DCD      0x08008000
                  |L1.128|
                          DCD      0x08040000

                          AREA ||i.IAP_CheckApp1FlashIsBlank||, CODE, READONLY, ALIGN=1

                  IAP_CheckApp1FlashIsBlank PROC
;;;285    // 查询Flash是否为空
;;;286    BOOL IAP_CheckApp1FlashIsBlank(void)
000000  b570              PUSH     {r4-r6,lr}
;;;287    {
;;;288    	uint16 i;
;;;289    	uint16 j;
;;;290    	uint16 readHalfWord;
;;;291    	uint32 readAddr;
;;;292    	
;;;293    	for (i = (IAP_FLASH_ADRESS_APP1_OFFSET/IAP_STM32_PAGE_SIZE); i < ((IAP_FLASH_ADRESS_APP1_OFFSET + IAP_GD32_APP1_SIZE)/IAP_STM32_PAGE_SIZE); i++)
000002  2210              MOVS     r2,#0x10
;;;294    	{
;;;295    		// 页地址
;;;296    		readAddr = i*IAP_STM32_PAGE_SIZE + IAP_GD32_FLASH_BASE;
000004  05d6              LSLS     r6,r2,#23
;;;297    
;;;298    		for (j = 0; j < IAP_STM32_PAGE_SIZE; j += 2)
;;;299    		{
;;;300    			readHalfWord = IAP_FlashReadHalfWord(readAddr);	// 读
;;;301    		  	readAddr += 2;
;;;302    
;;;303    			// 全为0xFFFF说明为空
;;;304    			if (readHalfWord == 0xFFFF)
000006  f64f74ff          MOV      r4,#0xffff
00000a  01d5              LSLS     r5,r2,#7              ;298
                  |L2.12|
00000c  eb0623c2          ADD      r3,r6,r2,LSL #11      ;296
000010  2100              MOVS     r1,#0                 ;298
                  |L2.18|
000012  4618              MOV      r0,r3                 ;300
000014  f7fffffe          BL       IAP_FlashReadHalfWord
000018  1c9b              ADDS     r3,r3,#2              ;301
00001a  42a0              CMP      r0,r4
00001c  d109              BNE      |L2.50|
00001e  1c89              ADDS     r1,r1,#2              ;298
000020  b289              UXTH     r1,r1                 ;298
000022  42a9              CMP      r1,r5                 ;298
;;;305    			{
;;;306    				continue;
000024  d3f5              BCC      |L2.18|
000026  1c52              ADDS     r2,r2,#1              ;293
000028  b292              UXTH     r2,r2                 ;293
00002a  2a80              CMP      r2,#0x80              ;293
00002c  d3ee              BCC      |L2.12|
;;;307    			}
;;;308    			else
;;;309    			{
;;;310    				return FALSE;
;;;311    			}
;;;312    		}  
;;;313    		
;;;314    	}
;;;315    
;;;316    	return TRUE;
00002e  2001              MOVS     r0,#1
;;;317    }
000030  bd70              POP      {r4-r6,pc}
                  |L2.50|
000032  2000              MOVS     r0,#0                 ;310
000034  bd70              POP      {r4-r6,pc}
;;;318    
                          ENDP


                          AREA ||i.IAP_CheckApp2FlashIsBlank||, CODE, READONLY, ALIGN=1

                  IAP_CheckApp2FlashIsBlank PROC
;;;319    // 查询Flash是否为空
;;;320    BOOL IAP_CheckApp2FlashIsBlank(void)
000000  b570              PUSH     {r4-r6,lr}
;;;321    {
;;;322    	uint16 i;
;;;323    	uint16 j;
;;;324    	uint16 readHalfWord;
;;;325    	uint32 readAddr;
;;;326    	
;;;327    	for (i = (IAP_FLASH_ADRESS_APP2_OFFSET/IAP_STM32_PAGE_SIZE); i < ((IAP_FLASH_ADRESS_APP2_OFFSET + IAP_GD32_APP2_SIZE)/IAP_STM32_PAGE_SIZE); i++)
000002  2220              MOVS     r2,#0x20
;;;328    	{
;;;329    		// 页地址
;;;330    		readAddr = i*IAP_STM32_PAGE_SIZE + IAP_GD32_FLASH_BASE;
000004  0596              LSLS     r6,r2,#22
;;;331    
;;;332    		for (j = 0; j < IAP_STM32_PAGE_SIZE; j += 2)
;;;333    		{
;;;334    			readHalfWord = IAP_FlashReadHalfWord(readAddr);	// 读
;;;335    		  	readAddr += 2;
;;;336    
;;;337    			// 全为0xFFFF说明为空
;;;338    			if (readHalfWord == 0xFFFF)
000006  f64f74ff          MOV      r4,#0xffff
00000a  0195              LSLS     r5,r2,#6              ;332
                  |L3.12|
00000c  eb0623c2          ADD      r3,r6,r2,LSL #11      ;330
000010  2100              MOVS     r1,#0                 ;332
                  |L3.18|
000012  4618              MOV      r0,r3                 ;334
000014  f7fffffe          BL       IAP_FlashReadHalfWord
000018  1c9b              ADDS     r3,r3,#2              ;335
00001a  42a0              CMP      r0,r4
00001c  d109              BNE      |L3.50|
00001e  1c89              ADDS     r1,r1,#2              ;332
000020  b289              UXTH     r1,r1                 ;332
000022  42a9              CMP      r1,r5                 ;332
;;;339    			{
;;;340    				continue;
000024  d3f5              BCC      |L3.18|
000026  1c52              ADDS     r2,r2,#1              ;327
000028  b292              UXTH     r2,r2                 ;327
00002a  2a80              CMP      r2,#0x80              ;327
00002c  d3ee              BCC      |L3.12|
;;;341    			}
;;;342    			else
;;;343    			{
;;;344    				return FALSE;
;;;345    			}
;;;346    		}
;;;347    		
;;;348    	}
;;;349    
;;;350    	return TRUE;
00002e  2001              MOVS     r0,#1
;;;351    }
000030  bd70              POP      {r4-r6,pc}
                  |L3.50|
000032  2000              MOVS     r0,#0                 ;344
000034  bd70              POP      {r4-r6,pc}
;;;352    
                          ENDP


                          AREA ||i.IAP_CheckAppRightful||, CODE, READONLY, ALIGN=2

                  IAP_CheckAppRightful PROC
;;;115    // 判断指定地址APP是否合法
;;;116    uint8 IAP_CheckAppRightful(uint32 addr)
000000  4a08              LDR      r2,|L4.36|
;;;117    {
;;;118    	// 检查栈顶地址是否合法.
;;;119    	if(((*(uint32*)addr) & 0x2FFE0000) != 0x20000000)	
000002  6801              LDR      r1,[r0,#0]
000004  4011              ANDS     r1,r1,r2
000006  f1b15f00          CMP      r1,#0x20000000
00000a  d001              BEQ      |L4.16|
;;;120    	{
;;;121    		return 0;
00000c  2000              MOVS     r0,#0
;;;122    	}
;;;123    
;;;124    	// APP无效
;;;125    	if (((*(uint32*)(addr+4)) & 0xFFF80000) != 0x08000000)
;;;126    	{
;;;127    		return 0;
;;;128    	}
;;;129    
;;;130    	return 1;
;;;131    }
00000e  4770              BX       lr
                  |L4.16|
000010  6840              LDR      r0,[r0,#4]            ;125
000012  f44f7180          MOV      r1,#0x100             ;125
000016  ebb14fd0          CMP      r1,r0,LSR #19         ;125
00001a  d001              BEQ      |L4.32|
00001c  2000              MOVS     r0,#0                 ;127
00001e  4770              BX       lr
                  |L4.32|
000020  2001              MOVS     r0,#1                 ;130
000022  4770              BX       lr
;;;132    
                          ENDP

                  |L4.36|
                          DCD      0x2ffe0000

                          AREA ||i.IAP_CheckFlashIsBlank||, CODE, READONLY, ALIGN=1

                  IAP_CheckFlashIsBlank PROC
;;;251    // 查询Flash是否为空
;;;252    BOOL IAP_CheckFlashIsBlank(void)
000000  b570              PUSH     {r4-r6,lr}
;;;253    {
;;;254    	uint16 i;
;;;255    	uint16 j;
;;;256    	uint16 readHalfWord;
;;;257    	uint32 readAddr;
;;;258    	
;;;259    	for (i = (IAP_FLASH_ADRESS_APP1_OFFSET/IAP_STM32_PAGE_SIZE); i < (IAP_GD32_FLASH_SIZE/IAP_STM32_PAGE_SIZE); i++)
000002  2210              MOVS     r2,#0x10
;;;260    	{
;;;261    		// 页地址
;;;262    		readAddr = i*IAP_STM32_PAGE_SIZE + IAP_GD32_FLASH_BASE;
000004  05d6              LSLS     r6,r2,#23
;;;263    
;;;264    		for (j = 0; j < IAP_STM32_PAGE_SIZE; j += 2)
;;;265    		{
;;;266    			readHalfWord = IAP_FlashReadHalfWord(readAddr);	// 读
;;;267    		  	readAddr += 2;
;;;268    
;;;269    			// 全为0xFFFF说明为空
;;;270    			if (readHalfWord == 0xFFFF)
000006  f64f74ff          MOV      r4,#0xffff
00000a  01d5              LSLS     r5,r2,#7              ;264
                  |L5.12|
00000c  eb0623c2          ADD      r3,r6,r2,LSL #11      ;262
000010  2100              MOVS     r1,#0                 ;264
                  |L5.18|
000012  4618              MOV      r0,r3                 ;266
000014  f7fffffe          BL       IAP_FlashReadHalfWord
000018  1c9b              ADDS     r3,r3,#2              ;267
00001a  42a0              CMP      r0,r4
00001c  d109              BNE      |L5.50|
00001e  1c89              ADDS     r1,r1,#2              ;264
000020  b289              UXTH     r1,r1                 ;264
000022  42a9              CMP      r1,r5                 ;264
;;;271    			{
;;;272    				continue;
000024  d3f5              BCC      |L5.18|
000026  1c52              ADDS     r2,r2,#1              ;259
000028  b292              UXTH     r2,r2                 ;259
00002a  2a80              CMP      r2,#0x80              ;259
00002c  d3ee              BCC      |L5.12|
;;;273    			}
;;;274    			else
;;;275    			{
;;;276    				return FALSE;
;;;277    			}
;;;278    		}  
;;;279    		
;;;280    	}
;;;281    
;;;282    	return TRUE;
00002e  2001              MOVS     r0,#1
;;;283    }
000030  bd70              POP      {r4-r6,pc}
                  |L5.50|
000032  2000              MOVS     r0,#0                 ;276
000034  bd70              POP      {r4-r6,pc}
;;;284    
                          ENDP


                          AREA ||i.IAP_EraseAPP1Area||, CODE, READONLY, ALIGN=1

                  IAP_EraseAPP1Area PROC
;;;395    // 擦除APP1所有页
;;;396    BOOL IAP_EraseAPP1Area(void)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;397    {
;;;398    	uint16 i;
;;;399    	fmc_state_enum status = FMC_READY;
;;;400    	BOOL eraseStatus = TRUE;
000004  2501              MOVS     r5,#1
;;;401    
;;;402    	DI();				// 关闭总中断
000006  b672              CPSID    i
;;;403    	fmc_unlock();		// 解锁
000008  f7fffffe          BL       fmc_unlock
;;;404    
;;;405    	// 清除所有挂起标志位
;;;406        fmc_flag_clear(FMC_FLAG_BANK0_END);
00000c  f2403705          MOV      r7,#0x305
000010  4638              MOV      r0,r7
000012  f7fffffe          BL       fmc_flag_clear
;;;407        fmc_flag_clear(FMC_FLAG_BANK0_WPERR);
000016  f44f7841          MOV      r8,#0x304
00001a  4640              MOV      r0,r8
00001c  f7fffffe          BL       fmc_flag_clear
;;;408        fmc_flag_clear(FMC_FLAG_BANK0_PGERR);
000020  f2403902          MOV      r9,#0x302
000024  4648              MOV      r0,r9
000026  f7fffffe          BL       fmc_flag_clear
;;;409    	
;;;410    	// 擦除APP所有页
;;;411    	for (i = (IAP_FLASH_ADRESS_APP1_OFFSET/IAP_STM32_PAGE_SIZE); i < ((IAP_FLASH_ADRESS_APP1_OFFSET + IAP_GD32_APP1_SIZE)/IAP_STM32_PAGE_SIZE); i++)
00002a  2410              MOVS     r4,#0x10
;;;412    	{
;;;413    		status = fmc_page_erase(i*IAP_STM32_PAGE_SIZE + IAP_GD32_FLASH_BASE);
00002c  05e6              LSLS     r6,r4,#23
                  |L6.46|
00002e  eb0620c4          ADD      r0,r6,r4,LSL #11
000032  f7fffffe          BL       fmc_page_erase
000036  4682              MOV      r10,r0
;;;414    
;;;415    		fmc_flag_clear(FMC_FLAG_BANK0_END);
000038  4638              MOV      r0,r7
00003a  f7fffffe          BL       fmc_flag_clear
;;;416            fmc_flag_clear(FMC_FLAG_BANK0_WPERR);
00003e  4640              MOV      r0,r8
000040  f7fffffe          BL       fmc_flag_clear
;;;417            fmc_flag_clear(FMC_FLAG_BANK0_PGERR);
000044  4648              MOV      r0,r9
000046  f7fffffe          BL       fmc_flag_clear
;;;418    		
;;;419    		if (FMC_READY != status)
00004a  f1ba0f00          CMP      r10,#0
00004e  d001              BEQ      |L6.84|
;;;420    		{
;;;421    			eraseStatus = FALSE;
000050  2500              MOVS     r5,#0
;;;422    
;;;423    			break;
000052  e005              B        |L6.96|
                  |L6.84|
;;;424    		}
;;;425    
;;;426    		// 清看门狗
;;;427    		WDT_Clear();
000054  f7fffffe          BL       WDT_Clear
000058  1c64              ADDS     r4,r4,#1              ;411
00005a  b2a4              UXTH     r4,r4                 ;411
00005c  2c80              CMP      r4,#0x80              ;411
00005e  d3e6              BCC      |L6.46|
                  |L6.96|
;;;428    	}
;;;429    
;;;430    	fmc_lock();			// 上锁
000060  f7fffffe          BL       fmc_lock
;;;431    	EI(); 				// 开启总中断
000064  b662              CPSIE    i
;;;432    
;;;433    	return eraseStatus;
000066  4628              MOV      r0,r5
;;;434    }
000068  e8bd87f0          POP      {r4-r10,pc}
;;;435    
                          ENDP


                          AREA ||i.IAP_EraseAPP2Area||, CODE, READONLY, ALIGN=1

                  IAP_EraseAPP2Area PROC
;;;436    // 擦除APP2所有页
;;;437    BOOL IAP_EraseAPP2Area(void)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;438    {
;;;439    	uint16 i;
;;;440    	fmc_state_enum status = FMC_READY;
;;;441    	BOOL eraseStatus = TRUE;
000004  2501              MOVS     r5,#1
;;;442    
;;;443    	DI();				// 关闭总中断
000006  b672              CPSID    i
;;;444    	fmc_unlock();		// 解锁
000008  f7fffffe          BL       fmc_unlock
;;;445    
;;;446    	// 清除所有挂起标志位
;;;447        fmc_flag_clear(FMC_FLAG_BANK0_END);
00000c  f2403705          MOV      r7,#0x305
000010  4638              MOV      r0,r7
000012  f7fffffe          BL       fmc_flag_clear
;;;448        fmc_flag_clear(FMC_FLAG_BANK0_WPERR);
000016  f44f7841          MOV      r8,#0x304
00001a  4640              MOV      r0,r8
00001c  f7fffffe          BL       fmc_flag_clear
;;;449        fmc_flag_clear(FMC_FLAG_BANK0_PGERR);
000020  f2403902          MOV      r9,#0x302
000024  4648              MOV      r0,r9
000026  f7fffffe          BL       fmc_flag_clear
;;;450    	
;;;451    	// 擦除APP所有页
;;;452    	for (i = (IAP_FLASH_ADRESS_APP2_OFFSET/IAP_STM32_PAGE_SIZE); i < ((IAP_FLASH_ADRESS_APP2_OFFSET + IAP_GD32_APP2_SIZE)/IAP_STM32_PAGE_SIZE); i++)
00002a  2420              MOVS     r4,#0x20
;;;453    	{
;;;454    		status = fmc_page_erase(i*IAP_STM32_PAGE_SIZE + IAP_GD32_FLASH_BASE);
00002c  05a6              LSLS     r6,r4,#22
                  |L7.46|
00002e  eb0620c4          ADD      r0,r6,r4,LSL #11
000032  f7fffffe          BL       fmc_page_erase
000036  4682              MOV      r10,r0
;;;455    
;;;456    		fmc_flag_clear(FMC_FLAG_BANK0_END);
000038  4638              MOV      r0,r7
00003a  f7fffffe          BL       fmc_flag_clear
;;;457            fmc_flag_clear(FMC_FLAG_BANK0_WPERR);
00003e  4640              MOV      r0,r8
000040  f7fffffe          BL       fmc_flag_clear
;;;458            fmc_flag_clear(FMC_FLAG_BANK0_PGERR);
000044  4648              MOV      r0,r9
000046  f7fffffe          BL       fmc_flag_clear
;;;459    
;;;460    		if (FMC_READY != status)
00004a  f1ba0f00          CMP      r10,#0
00004e  d001              BEQ      |L7.84|
;;;461    		{
;;;462    			eraseStatus = FALSE;
000050  2500              MOVS     r5,#0
;;;463    
;;;464    			break;
000052  e005              B        |L7.96|
                  |L7.84|
;;;465    		}
;;;466    		
;;;467    		// 清看门狗
;;;468    		WDT_Clear();
000054  f7fffffe          BL       WDT_Clear
000058  1c64              ADDS     r4,r4,#1              ;452
00005a  b2a4              UXTH     r4,r4                 ;452
00005c  2c80              CMP      r4,#0x80              ;452
00005e  d3e6              BCC      |L7.46|
                  |L7.96|
;;;469    	}
;;;470    
;;;471    	fmc_lock();			// 上锁
000060  f7fffffe          BL       fmc_lock
;;;472    	EI(); 				// 开启总中断
000064  b662              CPSIE    i
;;;473    
;;;474    	return eraseStatus;
000066  4628              MOV      r0,r5
;;;475    }
000068  e8bd87f0          POP      {r4-r10,pc}
;;;476    
                          ENDP


                          AREA ||i.IAP_EraseAPPArea||, CODE, READONLY, ALIGN=1

                  IAP_EraseAPPArea PROC
;;;354    // 擦除APP所有页
;;;355    BOOL IAP_EraseAPPArea(void)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;356    {
;;;357    	uint16 i;
;;;358    	fmc_state_enum status = FMC_READY;
;;;359    	BOOL eraseStatus = TRUE;
000004  2501              MOVS     r5,#1
;;;360    
;;;361    	DI();				// 关闭总中断
000006  b672              CPSID    i
;;;362    	fmc_unlock();		// 解锁
000008  f7fffffe          BL       fmc_unlock
;;;363    
;;;364    	// 清除所有挂起标志位
;;;365        fmc_flag_clear(FMC_FLAG_BANK0_END);
00000c  f2403705          MOV      r7,#0x305
000010  4638              MOV      r0,r7
000012  f7fffffe          BL       fmc_flag_clear
;;;366        fmc_flag_clear(FMC_FLAG_BANK0_WPERR);
000016  f44f7841          MOV      r8,#0x304
00001a  4640              MOV      r0,r8
00001c  f7fffffe          BL       fmc_flag_clear
;;;367        fmc_flag_clear(FMC_FLAG_BANK0_PGERR);
000020  f2403902          MOV      r9,#0x302
000024  4648              MOV      r0,r9
000026  f7fffffe          BL       fmc_flag_clear
;;;368    	
;;;369    	// 擦除APP所有页
;;;370    	for (i = (IAP_FLASH_ADRESS_APP1_OFFSET/IAP_STM32_PAGE_SIZE); i < (IAP_GD32_FLASH_SIZE/IAP_STM32_PAGE_SIZE); i++)
00002a  2410              MOVS     r4,#0x10
;;;371    	{
;;;372    		status = fmc_page_erase(i*IAP_STM32_PAGE_SIZE + IAP_GD32_FLASH_BASE);
00002c  05e6              LSLS     r6,r4,#23
                  |L8.46|
00002e  eb0620c4          ADD      r0,r6,r4,LSL #11
000032  f7fffffe          BL       fmc_page_erase
000036  4682              MOV      r10,r0
;;;373    
;;;374    		fmc_flag_clear(FMC_FLAG_BANK0_END);
000038  4638              MOV      r0,r7
00003a  f7fffffe          BL       fmc_flag_clear
;;;375            fmc_flag_clear(FMC_FLAG_BANK0_WPERR);
00003e  4640              MOV      r0,r8
000040  f7fffffe          BL       fmc_flag_clear
;;;376            fmc_flag_clear(FMC_FLAG_BANK0_PGERR);
000044  4648              MOV      r0,r9
000046  f7fffffe          BL       fmc_flag_clear
;;;377    		
;;;378    		if (FMC_READY != status)
00004a  f1ba0f00          CMP      r10,#0
00004e  d001              BEQ      |L8.84|
;;;379    		{
;;;380    			eraseStatus = FALSE;
000050  2500              MOVS     r5,#0
;;;381    
;;;382    			break;
000052  e005              B        |L8.96|
                  |L8.84|
;;;383    		}
;;;384    
;;;385    		// 清看门狗
;;;386    		WDT_Clear();
000054  f7fffffe          BL       WDT_Clear
000058  1c64              ADDS     r4,r4,#1              ;370
00005a  b2a4              UXTH     r4,r4                 ;370
00005c  2c80              CMP      r4,#0x80              ;370
00005e  d3e6              BCC      |L8.46|
                  |L8.96|
;;;387    	}
;;;388    
;;;389    	fmc_lock();		// 上锁
000060  f7fffffe          BL       fmc_lock
;;;390    	EI(); 				// 开启总中断
000064  b662              CPSIE    i
;;;391    
;;;392    	return eraseStatus;
000066  4628              MOV      r0,r5
;;;393    }
000068  e8bd87f0          POP      {r4-r10,pc}
;;;394    
                          ENDP


                          AREA ||i.IAP_FlashReadForCrc8||, CODE, READONLY, ALIGN=2

                  IAP_FlashReadForCrc8 PROC
;;;1000   *******************************************************************************/
;;;1001   uint8 IAP_FlashReadForCrc8(uint32 datalen)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1002   {
000002  4601              MOV      r1,r0
;;;1003   	uint8 crc = 0;
000004  2000              MOVS     r0,#0
;;;1004   	uint8 i,j;
;;;1005   	uint8 buf[4] = {0};
000006  2200              MOVS     r2,#0
000008  9200              STR      r2,[sp,#0]
;;;1006   	uint32 addrIndex = 0;
00000a  2300              MOVS     r3,#0
;;;1007   	uint32 dataTemp;
;;;1008   	uint32 len = datalen/4;
00000c  088c              LSRS     r4,r1,#2
00000e  e021              B        |L9.84|
                  |L9.16|
;;;1009   
;;;1010   	while (len--)
;;;1011   	{
;;;1012   		dataTemp = *(volatile uint32*)(addrIndex + IAP_FLASH_APP1_ADDR);
000010  4912              LDR      r1,|L9.92|
000012  5859              LDR      r1,[r3,r1]
;;;1013   		addrIndex += 4;
000014  1d1b              ADDS     r3,r3,#4
;;;1014   		// 小端模式
;;;1015   		buf[3] = (uint8)(dataTemp >> 24);
000016  0e0a              LSRS     r2,r1,#24
000018  f88d2003          STRB     r2,[sp,#3]
;;;1016   		buf[2] = (uint8)(dataTemp >> 16);
00001c  0c0a              LSRS     r2,r1,#16
00001e  f88d2002          STRB     r2,[sp,#2]
;;;1017   		buf[1] = (uint8)(dataTemp >> 8);
000022  0a0a              LSRS     r2,r1,#8
000024  f88d2001          STRB     r2,[sp,#1]
;;;1018   		buf[0] = (uint8)dataTemp;
000028  f88d1000          STRB     r1,[sp,#0]
;;;1019   		
;;;1020   		for(j = 0; j < 4; j++)
00002c  2200              MOVS     r2,#0
00002e  466e              MOV      r6,sp                 ;1005
;;;1021   		{
;;;1022   			crc ^= buf[j];
;;;1023   			
;;;1024   			for (i = 0; i < 8; i++)
;;;1025   			{
;;;1026   				if (crc & 0x01)
;;;1027   				{
;;;1028   					crc = (crc >> 1) ^ 0x8C;
000030  258c              MOVS     r5,#0x8c
                  |L9.50|
000032  5cb1              LDRB     r1,[r6,r2]            ;1022
000034  4048              EORS     r0,r0,r1              ;1022
000036  2100              MOVS     r1,#0                 ;1024
                  |L9.56|
000038  07c7              LSLS     r7,r0,#31             ;1026
00003a  d002              BEQ      |L9.66|
00003c  ea850050          EOR      r0,r5,r0,LSR #1
000040  e000              B        |L9.68|
                  |L9.66|
;;;1029   				}
;;;1030   				else
;;;1031   				{
;;;1032   					crc >>= 1;
000042  0840              LSRS     r0,r0,#1
                  |L9.68|
000044  1c49              ADDS     r1,r1,#1              ;1024
000046  b2c9              UXTB     r1,r1                 ;1024
000048  2908              CMP      r1,#8                 ;1024
00004a  d3f5              BCC      |L9.56|
00004c  1c52              ADDS     r2,r2,#1              ;1020
00004e  b2d2              UXTB     r2,r2                 ;1020
000050  2a04              CMP      r2,#4                 ;1020
000052  d3ee              BCC      |L9.50|
                  |L9.84|
000054  1e64              SUBS     r4,r4,#1              ;1010
000056  1c61              ADDS     r1,r4,#1              ;1010
000058  d1da              BNE      |L9.16|
;;;1033   				}
;;;1034   			}
;;;1035   		}
;;;1036   	}
;;;1037   	return crc;
;;;1038   }
00005a  bdf8              POP      {r3-r7,pc}
;;;1039   
                          ENDP

                  |L9.92|
                          DCD      0x08008000

                          AREA ||i.IAP_FlashReadHalfWord||, CODE, READONLY, ALIGN=1

                  IAP_FlashReadHalfWord PROC
;;;482    *******************************************************************************/
;;;483    uint16 IAP_FlashReadHalfWord(uint32 flashAddr)
000000  8800              LDRH     r0,[r0,#0]
;;;484    {
;;;485    	return *(volatile uint16*)flashAddr; 
;;;486    }
000002  4770              BX       lr
;;;487    
                          ENDP


                          AREA ||i.IAP_FlashReadHalfWordArray||, CODE, READONLY, ALIGN=1

                  IAP_FlashReadHalfWordArray PROC
;;;700    *******************************************************************************/
;;;701    void IAP_FlashReadHalfWordArray(uint32 readAddr, uint16 *pBuffer, uint16 numToRead)   	
000000  b510              PUSH     {r4,lr}
;;;702    {
000002  4604              MOV      r4,r0
;;;703    	uint16 i;
;;;704    
;;;705    	// 参数判断
;;;706    	if (NULL == pBuffer)
000004  2900              CMP      r1,#0
000006  d010              BEQ      |L11.42|
;;;707    	{
;;;708    		return;
;;;709    	}
;;;710    
;;;711    	// 参数检验是否非法
;;;712    	if ((readAddr < IAP_GD32_FLASH_BASE) || (readAddr >= (IAP_GD32_FLASH_BASE+IAP_GD32_FLASH_SIZE)))
000008  f1a46000          SUB      r0,r4,#0x8000000
00000c  f5b02f80          CMP      r0,#0x40000
000010  d20b              BCS      |L11.42|
;;;713    	{
;;;714    		return;	// 非法地址
;;;715    	}
;;;716    	
;;;717    	for (i = 0; i < numToRead; i++)
000012  2300              MOVS     r3,#0
000014  e007              B        |L11.38|
                  |L11.22|
;;;718    	{
;;;719    		pBuffer[i] = IAP_FlashReadHalfWord(readAddr);	// 读取2个字节.
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       IAP_FlashReadHalfWord
00001c  f8210013          STRH     r0,[r1,r3,LSL #1]
;;;720    		readAddr += 2; 									// 偏移2个字节.	
000020  1ca4              ADDS     r4,r4,#2
000022  1c5b              ADDS     r3,r3,#1              ;717
000024  b29b              UXTH     r3,r3                 ;717
                  |L11.38|
000026  4293              CMP      r3,r2                 ;717
000028  d3f5              BCC      |L11.22|
                  |L11.42|
;;;721    	}
;;;722    }
00002a  bd10              POP      {r4,pc}
;;;723    
                          ENDP


                          AREA ||i.IAP_FlashReadWord||, CODE, READONLY, ALIGN=1

                  IAP_FlashReadWord PROC
;;;849    *******************************************************************************/
;;;850    uint32 IAP_FlashReadWord(uint32 flashAddr)
000000  6800              LDR      r0,[r0,#0]
;;;851    {
;;;852    	return *(volatile uint32*)flashAddr; 
;;;853    }
000002  4770              BX       lr
;;;854    
                          ENDP


                          AREA ||i.IAP_FlashReadWordArray||, CODE, READONLY, ALIGN=2

                  IAP_FlashReadWordArray PROC
;;;820    *******************************************************************************/
;;;821    void IAP_FlashReadWordArray(uint32 readAddr, uint32 *pBuffer, uint16 numToRead)   	
000000  b510              PUSH     {r4,lr}
;;;822    {
000002  4604              MOV      r4,r0
;;;823    	uint16 i;
;;;824    
;;;825    	// 参数判断
;;;826    	if (NULL == pBuffer)
000004  2900              CMP      r1,#0
000006  d012              BEQ      |L13.46|
;;;827    	{
;;;828    		return;
;;;829    	}
;;;830    
;;;831    	// 参数检验是否非法
;;;832    	if ((readAddr < IAP_GD32_FLASH_BASE) || ((readAddr + numToRead) > (IAP_GD32_FLASH_BASE+IAP_GD32_FLASH_SIZE+1024UL)))
000008  f1b46f00          CMP      r4,#0x8000000
00000c  d30f              BCC      |L13.46|
00000e  4b08              LDR      r3,|L13.48|
000010  18a0              ADDS     r0,r4,r2
000012  4298              CMP      r0,r3
000014  d80b              BHI      |L13.46|
;;;833    	{
;;;834    		return;	// 非法地址
;;;835    	}
;;;836    	
;;;837    	for (i = 0; i < numToRead; i++)
000016  2300              MOVS     r3,#0
000018  e007              B        |L13.42|
                  |L13.26|
;;;838    	{
;;;839    		pBuffer[i] = IAP_FlashReadWord(readAddr);	// 读取4个字节.
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       IAP_FlashReadWord
000020  f8410023          STR      r0,[r1,r3,LSL #2]
;;;840    		readAddr += 4;								// 偏移4个字节.	
000024  1d24              ADDS     r4,r4,#4
000026  1c5b              ADDS     r3,r3,#1              ;837
000028  b29b              UXTH     r3,r3                 ;837
                  |L13.42|
00002a  4293              CMP      r3,r2                 ;837
00002c  d3f5              BCC      |L13.26|
                  |L13.46|
;;;841    	}
;;;842    }
00002e  bd10              POP      {r4,pc}
;;;843    
                          ENDP

                  |L13.48|
                          DCD      0x08040400

                          AREA ||i.IAP_FlashWriteHalfWordArray||, CODE, READONLY, ALIGN=1

                  IAP_FlashWriteHalfWordArray PROC
;;;540    *******************************************************************************/
;;;541    BOOL IAP_FlashWriteHalfWordArray(uint32 writeAddr, uint16 *pBuffer, uint16 numToWrite)	
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;542    {
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
;;;543    #if 0
;;;544    
;;;545    	uint32 secpos;	    // 扇区地址
;;;546    	uint16 secoff;	    // 扇区内偏移地址(16位字计算)
;;;547    	uint16 secremain;  	// 扇区内剩余地址(16位字计算)	   
;;;548     	uint16 i;    
;;;549    	uint32 offaddr;    	// 去掉0X08000000后的地址
;;;550    	BOOL writeStatus = FALSE;
;;;551    	FLASH_Status status = FLASH_COMPLETE;
;;;552    	static uint16 iapFlashBuf[IAP_STM32_PAGE_SIZE/2];	// 最多是2K字节
;;;553    
;;;554    	// 参数检验是否非法
;;;555    	if ((writeAddr < IAP_GD32_FLASH_BASE) || (writeAddr >= (IAP_GD32_FLASH_BASE+IAP_GD32_FLASH_SIZE)))
;;;556    	{
;;;557    		return FALSE;	// 非法地址
;;;558    	}
;;;559    	
;;;560    	DI();			// 关闭总中断
;;;561    	FLASH_Unlock();	// 解锁
;;;562    
;;;563    	// 清除所有挂起标志位
;;;564    	FLASH_ClearFlag(FLASH_FLAG_EOP | FLASH_FLAG_PGERR | FLASH_FLAG_WRPRTERR);
;;;565    	
;;;566    	offaddr = writeAddr-IAP_GD32_FLASH_BASE;			// 实际偏移地址.
;;;567    	secpos = offaddr/IAP_STM32_PAGE_SIZE;				// 扇区地址  0~127 for STM32F103RBT6
;;;568    	secoff = (offaddr%IAP_STM32_PAGE_SIZE)/2;			// 在扇区内的偏移(2个字节为基本单位.)
;;;569    	secremain = IAP_STM32_PAGE_SIZE/2 - secoff;			// 扇区剩余空间大小 
;;;570    
;;;571    	// 不大于该扇区范围
;;;572    	if (numToWrite <= secremain) 
;;;573    	{
;;;574    		secremain = numToWrite;
;;;575    	}
;;;576    	
;;;577    	while (1)
;;;578    	{
;;;579    		// 读出整个扇区的内容
;;;580    		IAP_FlashReadHalfWordArray((secpos*IAP_STM32_PAGE_SIZE+IAP_GD32_FLASH_BASE),
;;;581    									iapFlashBuf,
;;;582    									IAP_STM32_PAGE_SIZE/2);
;;;583    
;;;584    		// 校验数据
;;;585    		for (i = 0; i < secremain; i++)
;;;586    		{
;;;587    			if (iapFlashBuf[secoff + i] != 0xFFFF)
;;;588    			{
;;;589    				// 里面的数据不全是0xFFFF，说明需要擦除
;;;590    				break;
;;;591    			}
;;;592    		}
;;;593    
;;;594    		// 需要擦除
;;;595    		if (i < secremain)
;;;596    		{
;;;597    			// 擦除这个扇区
;;;598    			status = FLASH_ErasePage(secpos*IAP_STM32_PAGE_SIZE+IAP_STM32_FLASH_BASE);
;;;599    
;;;600    			if (FLASH_COMPLETE != status)
;;;601    			{
;;;602    				return FALSE;
;;;603    			}
;;;604    			
;;;605    			for (i = 0; i < secremain; i++) // 复制
;;;606    			{
;;;607    				iapFlashBuf[i + secoff] = pBuffer[i];	  
;;;608    			}
;;;609    
;;;610    			// 写入整个扇区
;;;611    			writeStatus = IAP_FlashWriteHalfWordArrayAndCheck((secpos*IAP_STM32_PAGE_SIZE+IAP_GD32_FLASH_BASE), 
;;;612    																iapFlashBuf, 
;;;613    																IAP_STM32_PAGE_SIZE/2);
;;;614    		}
;;;615    		// 不需要擦除
;;;616    		else
;;;617    		{
;;;618    			writeStatus = IAP_FlashWriteHalfWordArrayAndCheck(writeAddr,pBuffer,secremain); //写已经擦除了的,直接写入扇区剩余区间. 
;;;619    		}
;;;620    		
;;;621    		if (!writeStatus)
;;;622    		{
;;;623    			break;
;;;624    		}
;;;625    		
;;;626    		// 写入结束了
;;;627    		if (numToWrite == secremain)
;;;628    		{
;;;629    			break;
;;;630    		}
;;;631    		// 写入未结束
;;;632    		else 
;;;633    		{
;;;634    			secpos++;							// 扇区地址增1
;;;635    			secoff = 0;							// 偏移位置为0 	 
;;;636    		 	pBuffer += secremain;  	     		// 指针偏移
;;;637    			writeAddr += secremain;				// 写地址偏移	   
;;;638    		  	numToWrite -= secremain;			// 字节(16位)数递减
;;;639    
;;;640    		  	// 下一个扇区还是写不完
;;;641    			if (numToWrite > (IAP_STM32_PAGE_SIZE/2))
;;;642    			{
;;;643    				secremain = IAP_STM32_PAGE_SIZE/2;	
;;;644    			}
;;;645    			// 下一个扇区可以写完了
;;;646    			else 
;;;647    			{
;;;648    				secremain = numToWrite;
;;;649    			}
;;;650    		}	 
;;;651    	}
;;;652    	
;;;653    	FLASH_Lock();		// 上锁
;;;654    	EI(); 				// 开启总中断
;;;655    	
;;;656    	return writeStatus;
;;;657    
;;;658    #else
;;;659    	BOOL writeStatus = TRUE;
00000a  2401              MOVS     r4,#1
;;;660    	
;;;661    	// 参数判断
;;;662    	if (NULL == pBuffer)
00000c  2d00              CMP      r5,#0
00000e  d007              BEQ      |L14.32|
;;;663    	{
;;;664    		return FALSE;
;;;665    	}
;;;666    
;;;667    	// 参数检验是否非法
;;;668    	if ((writeAddr < IAP_GD32_FLASH_BASE) || (writeAddr >= (IAP_GD32_FLASH_BASE+IAP_GD32_FLASH_SIZE)))
000010  f1a66000          SUB      r0,r6,#0x8000000
000014  f5b02f80          CMP      r0,#0x40000
000018  d304              BCC      |L14.36|
;;;669    	{
;;;670    		return FALSE;	// 非法地址
00001a  2000              MOVS     r0,#0
                  |L14.28|
;;;671    	}
;;;672    	
;;;673    	DI();				// 关闭总中断
;;;674    	fmc_unlock();		// 解锁
;;;675    
;;;676    	// 清除所有挂起标志位
;;;677    	fmc_flag_clear(FMC_FLAG_BANK0_END);
;;;678        fmc_flag_clear(FMC_FLAG_BANK0_WPERR);
;;;679        fmc_flag_clear(FMC_FLAG_BANK0_PGERR);
;;;680    	
;;;681    	// 写入页
;;;682    	if (!IAP_FlashWriteHalfWordArrayAndCheck(writeAddr, pBuffer, numToWrite))	
;;;683    	{
;;;684    		writeStatus = FALSE;
;;;685    	}
;;;686    
;;;687    	fmc_lock();		// 上锁
;;;688    	EI(); 			// 开启总中断
;;;689    	
;;;690    	return writeStatus;
;;;691    
;;;692    #endif
;;;693    }
00001c  e8bd81f0          POP      {r4-r8,pc}
                  |L14.32|
000020  2000              MOVS     r0,#0                 ;664
000022  e7fb              B        |L14.28|
                  |L14.36|
000024  b672              CPSID    i                     ;673
000026  f7fffffe          BL       fmc_unlock
00002a  f2403005          MOV      r0,#0x305             ;677
00002e  f7fffffe          BL       fmc_flag_clear
000032  f44f7041          MOV      r0,#0x304             ;678
000036  f7fffffe          BL       fmc_flag_clear
00003a  f2403002          MOV      r0,#0x302             ;679
00003e  f7fffffe          BL       fmc_flag_clear
000042  463a              MOV      r2,r7                 ;682
000044  4629              MOV      r1,r5                 ;682
000046  4630              MOV      r0,r6                 ;682
000048  f7fffffe          BL       IAP_FlashWriteHalfWordArrayAndCheck
00004c  b900              CBNZ     r0,|L14.80|
00004e  2400              MOVS     r4,#0                 ;684
                  |L14.80|
000050  f7fffffe          BL       fmc_lock
000054  b662              CPSIE    i                     ;688
000056  4620              MOV      r0,r4                 ;690
000058  e7e0              B        |L14.28|
;;;694    
                          ENDP


                          AREA ||i.IAP_FlashWriteHalfWordArrayAndCheck||, CODE, READONLY, ALIGN=1

                  IAP_FlashWriteHalfWordArrayAndCheck PROC
;;;494    *******************************************************************************/
;;;495    BOOL IAP_FlashWriteHalfWordArrayAndCheck(uint32 writeAddr, uint16 *pBuffer, uint16 numToWrite)   
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;496    { 			 		 
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;497    	uint16 i;
;;;498    	uint16 readHalfWord;
;;;499    
;;;500    	// 参数判断
;;;501    	if (NULL == pBuffer)
00000a  2e00              CMP      r6,#0
00000c  d007              BEQ      |L15.30|
;;;502    	{
;;;503    		return FALSE;
;;;504    	}
;;;505    
;;;506    	// 参数检验是否非法
;;;507    	if ((writeAddr < IAP_GD32_FLASH_BASE) || (writeAddr >= (IAP_GD32_FLASH_BASE+IAP_GD32_FLASH_SIZE)))
00000e  f1a56000          SUB      r0,r5,#0x8000000
000012  f5b02f80          CMP      r0,#0x40000
000016  d304              BCC      |L15.34|
;;;508    	{
;;;509    		return FALSE;	// 非法地址
000018  2000              MOVS     r0,#0
                  |L15.26|
;;;510    	}
;;;511    	
;;;512    	for (i = 0; i < numToWrite; i++)
;;;513    	{
;;;514    		fmc_halfword_program(writeAddr, pBuffer[i]);		// 写
;;;515    		readHalfWord = IAP_FlashReadHalfWord(writeAddr);	// 读
;;;516    	  	writeAddr += 2;
;;;517    
;;;518    		fmc_flag_clear(FMC_FLAG_BANK0_END);
;;;519            fmc_flag_clear(FMC_FLAG_BANK0_WPERR);
;;;520            fmc_flag_clear(FMC_FLAG_BANK0_PGERR); 
;;;521    		
;;;522    	  	// 写入FLASH中的缓冲区数据与读取的数据是否匹配
;;;523    		if (readHalfWord == pBuffer[i])
;;;524    		{
;;;525    			continue;
;;;526    		}
;;;527    		else
;;;528    		{
;;;529    			return FALSE;
;;;530    		}
;;;531    	}  
;;;532    	return TRUE;
;;;533    } 
00001a  e8bd9ff0          POP      {r4-r12,pc}
                  |L15.30|
00001e  2000              MOVS     r0,#0                 ;503
000020  e7fb              B        |L15.26|
                  |L15.34|
000022  2400              MOVS     r4,#0                 ;512
000024  f2403805          MOV      r8,#0x305             ;518
000028  f44f7941          MOV      r9,#0x304             ;519
00002c  f2403a02          MOV      r10,#0x302            ;520
000030  e018              B        |L15.100|
                  |L15.50|
000032  f8361014          LDRH     r1,[r6,r4,LSL #1]     ;514
000036  4628              MOV      r0,r5                 ;514
000038  f7fffffe          BL       fmc_halfword_program
00003c  4628              MOV      r0,r5                 ;515
00003e  f7fffffe          BL       IAP_FlashReadHalfWord
000042  4683              MOV      r11,r0                ;515
000044  1cad              ADDS     r5,r5,#2              ;516
000046  4640              MOV      r0,r8                 ;518
000048  f7fffffe          BL       fmc_flag_clear
00004c  4648              MOV      r0,r9                 ;519
00004e  f7fffffe          BL       fmc_flag_clear
000052  4650              MOV      r0,r10                ;520
000054  f7fffffe          BL       fmc_flag_clear
000058  f8360014          LDRH     r0,[r6,r4,LSL #1]     ;523
00005c  4558              CMP      r0,r11                ;523
00005e  d105              BNE      |L15.108|
000060  1c64              ADDS     r4,r4,#1              ;512
000062  b2a4              UXTH     r4,r4                 ;512
                  |L15.100|
000064  42bc              CMP      r4,r7                 ;512
000066  d3e4              BCC      |L15.50|
000068  2001              MOVS     r0,#1                 ;532
00006a  e7d6              B        |L15.26|
                  |L15.108|
00006c  2000              MOVS     r0,#0                 ;529
00006e  e7d4              B        |L15.26|
;;;534    
                          ENDP


                          AREA ||i.IAP_FlashWriteWordArray||, CODE, READONLY, ALIGN=2

                  IAP_FlashWriteWordArray PROC
;;;730    *******************************************************************************/
;;;731    BOOL IAP_FlashWriteWordArray(uint32 writeAddr, uint32 *pBuffer, uint16 numToWrite)	
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;732    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;733    	BOOL writeStatus = TRUE;
00000a  2501              MOVS     r5,#1
;;;734    	
;;;735    	// 参数判断
;;;736    	if (NULL == pBuffer)
00000c  2e00              CMP      r6,#0
00000e  d009              BEQ      |L16.36|
;;;737    	{
;;;738    		return FALSE;
;;;739    	}
;;;740    
;;;741    	// 参数检验是否非法
;;;742    	if ((writeAddr < IAP_GD32_FLASH_BASE) || ((writeAddr + numToWrite) > (IAP_GD32_FLASH_BASE+IAP_GD32_FLASH_SIZE)))
000010  f1b46f00          CMP      r4,#0x8000000
000014  d303              BCC      |L16.30|
000016  4912              LDR      r1,|L16.96|
000018  19e0              ADDS     r0,r4,r7
00001a  4288              CMP      r0,r1
00001c  d904              BLS      |L16.40|
                  |L16.30|
;;;743    	{
;;;744    		return FALSE;	// 非法地址
00001e  2000              MOVS     r0,#0
                  |L16.32|
;;;745    	}
;;;746    	
;;;747    	DI();				// 关闭总中断
;;;748    	fmc_unlock();		// 解锁
;;;749    
;;;750    	// 清除所有挂起标志位
;;;751    	fmc_flag_clear(FMC_FLAG_BANK0_END);
;;;752        fmc_flag_clear(FMC_FLAG_BANK0_WPERR);
;;;753        fmc_flag_clear(FMC_FLAG_BANK0_PGERR);
;;;754    
;;;755    
;;;756    	// 写入页
;;;757    	if (!IAP_FlashWriteWordArrayAndCheck(writeAddr, pBuffer, numToWrite))	
;;;758    	{
;;;759    		writeStatus = FALSE;
;;;760    	}
;;;761    
;;;762    	fmc_lock();			// 上锁
;;;763    	EI(); 				// 开启总中断
;;;764    	
;;;765    	return writeStatus;
;;;766    }
000020  e8bd81f0          POP      {r4-r8,pc}
                  |L16.36|
000024  2000              MOVS     r0,#0                 ;738
000026  e7fb              B        |L16.32|
                  |L16.40|
000028  b672              CPSID    i                     ;747
00002a  f7fffffe          BL       fmc_unlock
00002e  f2403005          MOV      r0,#0x305             ;751
000032  f7fffffe          BL       fmc_flag_clear
000036  f44f7041          MOV      r0,#0x304             ;752
00003a  f7fffffe          BL       fmc_flag_clear
00003e  f2403002          MOV      r0,#0x302             ;753
000042  f7fffffe          BL       fmc_flag_clear
000046  463a              MOV      r2,r7                 ;757
000048  4631              MOV      r1,r6                 ;757
00004a  4620              MOV      r0,r4                 ;757
00004c  f7fffffe          BL       IAP_FlashWriteWordArrayAndCheck
000050  b900              CBNZ     r0,|L16.84|
000052  2500              MOVS     r5,#0                 ;759
                  |L16.84|
000054  f7fffffe          BL       fmc_lock
000058  b662              CPSIE    i                     ;763
00005a  4628              MOV      r0,r5                 ;765
00005c  e7e0              B        |L16.32|
;;;767    
                          ENDP

00005e  0000              DCW      0x0000
                  |L16.96|
                          DCD      0x08040000

                          AREA ||i.IAP_FlashWriteWordArrayAndCheck||, CODE, READONLY, ALIGN=2

                  IAP_FlashWriteWordArrayAndCheck PROC
;;;774    *******************************************************************************/
;;;775    BOOL IAP_FlashWriteWordArrayAndCheck(uint32 writeAddr, uint32 *pBuffer, uint16 numToWrite)   
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;776    { 			 		 
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;777    	uint16 i;
;;;778    	uint32 readWord;
;;;779    
;;;780    	// 参数判断
;;;781    	if (NULL == pBuffer)
00000a  2e00              CMP      r6,#0
00000c  d009              BEQ      |L17.34|
;;;782    	{
;;;783    		return FALSE;
;;;784    	}
;;;785    
;;;786    	// 参数检验是否非法
;;;787    	if ((writeAddr < IAP_GD32_FLASH_BASE) || ((writeAddr + numToWrite) > (IAP_GD32_FLASH_BASE+IAP_GD32_FLASH_SIZE+1024UL)))
00000e  f1b56f00          CMP      r5,#0x8000000
000012  d303              BCC      |L17.28|
000014  4917              LDR      r1,|L17.116|
000016  19e8              ADDS     r0,r5,r7
000018  4288              CMP      r0,r1
00001a  d904              BLS      |L17.38|
                  |L17.28|
;;;788    	{
;;;789    		return FALSE;	// 非法地址
00001c  2000              MOVS     r0,#0
                  |L17.30|
;;;790    	}
;;;791    	
;;;792    	for (i = 0; i < numToWrite; i++)
;;;793    	{
;;;794    		fmc_word_program(writeAddr, pBuffer[i]);		// 写
;;;795    		readWord = IAP_FlashReadWord(writeAddr);		// 读
;;;796    	  	writeAddr += 4;
;;;797    
;;;798    		fmc_flag_clear(FMC_FLAG_BANK0_END);
;;;799            fmc_flag_clear(FMC_FLAG_BANK0_WPERR);
;;;800            fmc_flag_clear(FMC_FLAG_BANK0_PGERR); 
;;;801    
;;;802    	  	// 写入FLASH中的缓冲区数据与读取的数据是否匹配
;;;803    		if (readWord == pBuffer[i])
;;;804    		{
;;;805    			continue;
;;;806    		}
;;;807    		else
;;;808    		{
;;;809    			return FALSE;
;;;810    		}
;;;811    	}  
;;;812    	return TRUE;
;;;813    } 
00001e  e8bd9ff0          POP      {r4-r12,pc}
                  |L17.34|
000022  2000              MOVS     r0,#0                 ;783
000024  e7fb              B        |L17.30|
                  |L17.38|
000026  2400              MOVS     r4,#0                 ;792
000028  f2403805          MOV      r8,#0x305             ;798
00002c  f44f7941          MOV      r9,#0x304             ;799
000030  f2403a02          MOV      r10,#0x302            ;800
000034  e018              B        |L17.104|
                  |L17.54|
000036  f8561024          LDR      r1,[r6,r4,LSL #2]     ;794
00003a  4628              MOV      r0,r5                 ;794
00003c  f7fffffe          BL       fmc_word_program
000040  4628              MOV      r0,r5                 ;795
000042  f7fffffe          BL       IAP_FlashReadWord
000046  4683              MOV      r11,r0                ;795
000048  1d2d              ADDS     r5,r5,#4              ;796
00004a  4640              MOV      r0,r8                 ;798
00004c  f7fffffe          BL       fmc_flag_clear
000050  4648              MOV      r0,r9                 ;799
000052  f7fffffe          BL       fmc_flag_clear
000056  4650              MOV      r0,r10                ;800
000058  f7fffffe          BL       fmc_flag_clear
00005c  f8560024          LDR      r0,[r6,r4,LSL #2]     ;803
000060  4558              CMP      r0,r11                ;803
000062  d105              BNE      |L17.112|
000064  1c64              ADDS     r4,r4,#1              ;792
000066  b2a4              UXTH     r4,r4                 ;792
                  |L17.104|
000068  42bc              CMP      r4,r7                 ;792
00006a  d3e4              BCC      |L17.54|
00006c  2001              MOVS     r0,#1                 ;812
00006e  e7d6              B        |L17.30|
                  |L17.112|
000070  2000              MOVS     r0,#0                 ;809
000072  e7d4              B        |L17.30|
;;;814    
                          ENDP

                  |L17.116|
                          DCD      0x08040400

                          AREA ||i.IAP_FlashWriteWordArrayWithErase||, CODE, READONLY, ALIGN=2

                  IAP_FlashWriteWordArrayWithErase PROC
;;;860    *******************************************************************************/
;;;861    BOOL IAP_FlashWriteWordArrayWithErase(uint32 writeAddr, uint32 *pBuffer, uint16 NumWordToWrite)	
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;862    {
000004  4682              MOV      r10,r0
000006  4689              MOV      r9,r1
;;;863    	BOOL writeStatus = TRUE;
000008  2001              MOVS     r0,#1
00000a  9000              STR      r0,[sp,#0]
;;;864    	uint32 pagePos = 0;						// 扇区地址
;;;865    	uint16 pageOffsent = 0;					// 在扇区内的偏移
;;;866    	uint16 pageRemain = 0;  				// 扇区剩余空间大小 
;;;867    	uint32 offaddr;    						// 去掉0X08000000后的地址
;;;868     	uint16 i = 0;
;;;869     	uint32 * pFlashBuff = NULL;				// 保存读取扇区的数据
;;;870     	uint16 numByteToWrite = NumWordToWrite * 4;
00000c  f64f70ff          MOV      r0,#0xffff
000010  ea000582          AND      r5,r0,r2,LSL #2
;;;871    	
;;;872    	// 参数判断
;;;873    	if (NULL == pBuffer|| (NULL == numByteToWrite))
000014  f1b90f00          CMP      r9,#0
000018  d00b              BEQ      |L18.50|
00001a  b155              CBZ      r5,|L18.50|
;;;874    	{
;;;875    		return FALSE;
;;;876    	}
;;;877    
;;;878    	// 参数检验是否非法
;;;879    	if ((writeAddr < IAP_GD32_FLASH_BASE) || ((writeAddr + numByteToWrite) > (IAP_GD32_FLASH_BASE+IAP_GD32_FLASH_SIZE + 1024UL)))
00001c  f1ba6f00          CMP      r10,#0x8000000
000020  d304              BCC      |L18.44|
000022  4947              LDR      r1,|L18.320|
000024  eb0a0005          ADD      r0,r10,r5
000028  4288              CMP      r0,r1
00002a  d904              BLS      |L18.54|
                  |L18.44|
;;;880    	{
;;;881    		return FALSE;	// 非法地址
00002c  2000              MOVS     r0,#0
                  |L18.46|
;;;882    	}
;;;883    
;;;884    	// 申请1024Byte空间保存页数据
;;;885    	pFlashBuff = (uint32 *)malloc(IAP_STM32_PAGE_SIZE);
;;;886    	if (NULL == pFlashBuff)
;;;887    	{
;;;888    		return FALSE;
;;;889    	}
;;;890    
;;;891    	offaddr = writeAddr - IAP_GD32_FLASH_BASE;		// 实际偏移地址
;;;892    	pagePos = offaddr / IAP_STM32_PAGE_SIZE;		// 页地址
;;;893    	pageOffsent = offaddr % IAP_STM32_PAGE_SIZE;	// 在页内偏移
;;;894    	pageRemain = IAP_STM32_PAGE_SIZE - pageOffsent;	// 页剩余空间大小
;;;895    
;;;896    	if (numByteToWrite <= pageRemain)
;;;897    	{
;;;898    		pageRemain = numByteToWrite;				// 不大于该页范围
;;;899    	}
;;;900    	
;;;901    	DI();				// 关闭总中断
;;;902    	fmc_unlock();		// 解锁
;;;903    
;;;904    	// 清除所有挂起标志位
;;;905    	fmc_flag_clear(FMC_FLAG_BANK0_END);
;;;906        fmc_flag_clear(FMC_FLAG_BANK0_WPERR);
;;;907        fmc_flag_clear(FMC_FLAG_BANK0_PGERR);
;;;908    
;;;909    	
;;;910    	while(1)
;;;911    	{
;;;912    		// 读出整个页的内容
;;;913    		IAP_FlashReadWordArray(pagePos*IAP_STM32_PAGE_SIZE+IAP_STM32_PAGE_SIZE, pFlashBuff, IAP_STM32_PAGE_SIZE/4);
;;;914    
;;;915    		for (i = 0; i < pageRemain/4; i++)	// 校验数据
;;;916    		{
;;;917    			if (pFlashBuff[pageOffsent/4 + i] != 0xFFFFFFFF)
;;;918    			{
;;;919    				// 里面的数据不全是0xFFFFFFFF，说明需要擦除
;;;920    				break;
;;;921    			}
;;;922    		}
;;;923    
;;;924    		if (i < pageRemain/4)					// 需要擦除
;;;925    		{
;;;926    			// 擦除这个页
;;;927    			//IAP_PageErase(pagePos * IAP_STM32_PAGE_SIZE + IAP_GD32_FLASH_BASE);
;;;928    			fmc_page_erase(pagePos * IAP_STM32_PAGE_SIZE + IAP_GD32_FLASH_BASE);
;;;929    
;;;930    			// 复制
;;;931    			for (i = 0; i < pageRemain/4; i++)
;;;932    			{
;;;933    				pFlashBuff[i + pageOffsent/4] = pBuffer[i]; 
;;;934    			}
;;;935    
;;;936    			// 写入整页
;;;937    			if (!IAP_FlashWriteWordArrayAndCheck(pagePos * IAP_STM32_PAGE_SIZE + IAP_GD32_FLASH_BASE, pFlashBuff, IAP_STM32_PAGE_SIZE/4))	
;;;938    			{
;;;939    				// 释放数据缓存区
;;;940    				free(pFlashBuff);
;;;941    
;;;942    				fmc_lock();			// 上锁
;;;943    				EI();				// 开启总中断
;;;944    				writeStatus = FALSE;
;;;945    				return writeStatus;
;;;946    			}
;;;947    		}
;;;948    		else 
;;;949    		{
;;;950    			// 写已经擦除了的,直接写入扇区剩余区间.
;;;951    			if (!IAP_FlashWriteWordArrayAndCheck(writeAddr, pBuffer, pageRemain/4))	
;;;952    			{
;;;953    				// 释放数据缓存区
;;;954    				free(pFlashBuff);
;;;955    
;;;956    				fmc_lock();			// 上锁
;;;957    				EI(); 				// 开启总中断
;;;958    				writeStatus = FALSE;
;;;959    				return writeStatus;
;;;960    			}
;;;961    		}
;;;962    		
;;;963    		if (numByteToWrite == pageRemain)
;;;964    		{
;;;965    			break;									// 写入结束了
;;;966    		}
;;;967    		else										// 写入未结束
;;;968    		{
;;;969    			pagePos++;								// 扇区地址增1
;;;970    			pageOffsent = 0;						// 偏移位置为0 	 
;;;971    
;;;972    		   	pBuffer += (pageRemain/4);  			// 指针偏移
;;;973    			writeAddr += pageRemain;				// 写地址偏移	   
;;;974    		   	numByteToWrite -= pageRemain;			// 字节数递减
;;;975    		   	
;;;976    			if (numByteToWrite > IAP_STM32_PAGE_SIZE)
;;;977    			{
;;;978    				pageRemain = IAP_STM32_PAGE_SIZE;	// 下一个扇区还是写不完
;;;979    			}
;;;980    			else
;;;981    			{
;;;982    				pageRemain = numByteToWrite;		// 下一个扇区可以写完了	
;;;983    			}
;;;984    		}	
;;;985    		
;;;986    	}
;;;987    
;;;988    	// 释放数据缓存区
;;;989    	free(pFlashBuff);	
;;;990    	fmc_lock();			// 上锁
;;;991    	EI(); 				// 开启总中断
;;;992    	return writeStatus;
;;;993    }
00002e  e8bd8ff8          POP      {r3-r11,pc}
                  |L18.50|
000032  2000              MOVS     r0,#0                 ;875
000034  e7fb              B        |L18.46|
                  |L18.54|
000036  f44f6000          MOV      r0,#0x800             ;885
00003a  f7fffffe          BL       malloc
00003e  4680              MOV      r8,r0                 ;885
000040  ea5f0008          MOVS     r0,r8                 ;886
000044  d023              BEQ      |L18.142|
000046  f1aa6000          SUB      r0,r10,#0x8000000     ;891
00004a  0ac7              LSRS     r7,r0,#11             ;892
00004c  f3c0060a          UBFX     r6,r0,#0,#11          ;893
000050  f5c66400          RSB      r4,r6,#0x800          ;894
000054  42a5              CMP      r5,r4                 ;896
000056  d800              BHI      |L18.90|
000058  462c              MOV      r4,r5                 ;898
                  |L18.90|
00005a  b672              CPSID    i                     ;901
00005c  f7fffffe          BL       fmc_unlock
000060  f2403005          MOV      r0,#0x305             ;905
000064  f7fffffe          BL       fmc_flag_clear
000068  f44f7041          MOV      r0,#0x304             ;906
00006c  f7fffffe          BL       fmc_flag_clear
000070  f2403002          MOV      r0,#0x302             ;907
000074  f7fffffe          BL       fmc_flag_clear
                  |L18.120|
000078  f44f6000          MOV      r0,#0x800             ;913
00007c  eb0020c7          ADD      r0,r0,r7,LSL #11      ;913
000080  f44f7200          MOV      r2,#0x200             ;913
000084  4641              MOV      r1,r8                 ;913
000086  f7fffffe          BL       IAP_FlashReadWordArray
00008a  2000              MOVS     r0,#0                 ;915
00008c  e009              B        |L18.162|
                  |L18.142|
00008e  2000              MOVS     r0,#0                 ;888
000090  e7cd              B        |L18.46|
                  |L18.146|
000092  eb000196          ADD      r1,r0,r6,LSR #2       ;917
000096  f8581021          LDR      r1,[r8,r1,LSL #2]     ;917
00009a  1c49              ADDS     r1,r1,#1              ;917
00009c  d104              BNE      |L18.168|
00009e  1c40              ADDS     r0,r0,#1              ;915
0000a0  b280              UXTH     r0,r0                 ;915
                  |L18.162|
0000a2  ebb00f94          CMP      r0,r4,LSR #2          ;915
0000a6  d3f4              BCC      |L18.146|
                  |L18.168|
0000a8  ebb00f94          CMP      r0,r4,LSR #2          ;924
0000ac  d222              BCS      |L18.244|
0000ae  f04f6000          MOV      r0,#0x8000000         ;928
0000b2  eb002bc7          ADD      r11,r0,r7,LSL #11     ;928
0000b6  4658              MOV      r0,r11                ;928
0000b8  f7fffffe          BL       fmc_page_erase
0000bc  2000              MOVS     r0,#0                 ;931
0000be  e007              B        |L18.208|
                  |L18.192|
0000c0  eb000296          ADD      r2,r0,r6,LSR #2       ;933
0000c4  f8591020          LDR      r1,[r9,r0,LSL #2]     ;933
0000c8  f8481022          STR      r1,[r8,r2,LSL #2]     ;933
0000cc  1c40              ADDS     r0,r0,#1              ;931
0000ce  b280              UXTH     r0,r0                 ;931
                  |L18.208|
0000d0  ebb00f94          CMP      r0,r4,LSR #2          ;931
0000d4  d3f4              BCC      |L18.192|
0000d6  4658              MOV      r0,r11                ;937
0000d8  f44f7200          MOV      r2,#0x200             ;937
0000dc  4641              MOV      r1,r8                 ;937
0000de  f7fffffe          BL       IAP_FlashWriteWordArrayAndCheck
0000e2  b968              CBNZ     r0,|L18.256|
0000e4  4640              MOV      r0,r8                 ;940
0000e6  f7fffffe          BL       free
0000ea  f7fffffe          BL       fmc_lock
0000ee  b662              CPSIE    i                     ;943
0000f0  2000              MOVS     r0,#0                 ;944
0000f2  e79c              B        |L18.46|
                  |L18.244|
0000f4  08a2              LSRS     r2,r4,#2              ;951
0000f6  4649              MOV      r1,r9                 ;951
0000f8  4650              MOV      r0,r10                ;951
0000fa  f7fffffe          BL       IAP_FlashWriteWordArrayAndCheck
0000fe  b148              CBZ      r0,|L18.276|
                  |L18.256|
000100  42a5              CMP      r5,r4                 ;963
000102  d10f              BNE      |L18.292|
000104  4640              MOV      r0,r8                 ;989
000106  f7fffffe          BL       free
00010a  f7fffffe          BL       fmc_lock
00010e  b662              CPSIE    i                     ;991
000110  9800              LDR      r0,[sp,#0]            ;965
000112  e78c              B        |L18.46|
                  |L18.276|
000114  4640              MOV      r0,r8                 ;954
000116  f7fffffe          BL       free
00011a  f7fffffe          BL       fmc_lock
00011e  b662              CPSIE    i                     ;957
000120  2000              MOVS     r0,#0                 ;958
000122  e784              B        |L18.46|
                  |L18.292|
000124  1c7f              ADDS     r7,r7,#1              ;969
000126  2600              MOVS     r6,#0                 ;970
000128  f0240003          BIC      r0,r4,#3              ;972
00012c  4481              ADD      r9,r9,r0              ;972
00012e  44a2              ADD      r10,r10,r4            ;973
000130  1b28              SUBS     r0,r5,r4              ;974
000132  b285              UXTH     r5,r0                 ;974
000134  f44f6400          MOV      r4,#0x800             ;976
000138  42a5              CMP      r5,r4                 ;976
00013a  d89d              BHI      |L18.120|
00013c  462c              MOV      r4,r5                 ;982
00013e  e79b              B        |L18.120|
;;;994    
                          ENDP

                  |L18.320|
                          DCD      0x08040400

                          AREA ||i.IAP_Init||, CODE, READONLY, ALIGN=2

                  IAP_Init PROC
;;;139    *******************************************************************************/
;;;140    void IAP_Init(void)
000000  4808              LDR      r0,|L19.36|
;;;141    {		
;;;142    	iapCB.mcuUID.sn0 = *(uint32*)(0x1FFFF7E8); 
000002  6801              LDR      r1,[r0,#0]
000004  4808              LDR      r0,|L19.40|
000006  6041              STR      r1,[r0,#4]  ; iapCB
;;;143    	iapCB.mcuUID.sn1 = *(uint32*)(0x1FFFF7EC); 
000008  4906              LDR      r1,|L19.36|
00000a  1d09              ADDS     r1,r1,#4
00000c  6809              LDR      r1,[r1,#0]
00000e  6081              STR      r1,[r0,#8]  ; iapCB
;;;144    	iapCB.mcuUID.sn2 = *(uint32*)(0x1FFFF7F0);
000010  4904              LDR      r1,|L19.36|
000012  3108              ADDS     r1,r1,#8
000014  6809              LDR      r1,[r1,#0]
000016  60c1              STR      r1,[r0,#0xc]  ; iapCB
;;;145    	
;;;146    	// 设置中断向量起始位置
;;;147    	nvic_vector_table_set(NVIC_VECTTAB_FLASH,0x0000);
000018  2100              MOVS     r1,#0
00001a  f04f6000          MOV      r0,#0x8000000
00001e  f7ffbffe          B.W      nvic_vector_table_set
;;;148    	
;;;149    //	TIMER_AddTask(TIMER_ID_IAP_ECO_REQUEST,
;;;150    //					50,
;;;151    //					IAP_CTRL_UART_SendCmdProjectApply,
;;;152    //					IAP_CTRL_UART_CMD_UP_PROJECT_APPLY,
;;;153    //					3,
;;;154    //					ACTION_MODE_ADD_TO_QUEUE);
;;;155    }
;;;156    
                          ENDP

000022  0000              DCW      0x0000
                  |L19.36|
                          DCD      0x1ffff7e8
                  |L19.40|
                          DCD      ||.bss||

                          AREA ||i.IAP_JumpToAppFun||, CODE, READONLY, ALIGN=2

                  IAP_JumpToAppFun PROC
;;;96     // 窗口时间到跳转到APP代码区运行
;;;97     void IAP_JumpToAppFun(uint32 param)
000000  4a07              LDR      r2,|L20.32|
;;;98     {
;;;99     	// 检查栈顶地址是否合法.
;;;100    	if(((*(uint32*)param) & 0x2FFE0000) != 0x20000000)	
000002  6801              LDR      r1,[r0,#0]
000004  4011              ANDS     r1,r1,r2
000006  f1b15f00          CMP      r1,#0x20000000
00000a  d107              BNE      |L20.28|
;;;101    	{
;;;102    		return;
;;;103    	}
;;;104    
;;;105    	// APP无效
;;;106    	if (((*(uint32*)(param+4)) & 0xFFF80000) != 0x08000000)
00000c  6841              LDR      r1,[r0,#4]
00000e  f44f7280          MOV      r2,#0x100
000012  ebb24fd1          CMP      r2,r1,LSR #19
000016  d101              BNE      |L20.28|
;;;107    	{
;;;108    		return;
;;;109    	}
;;;110    	
;;;111    	// 执行APP程序
;;;112    	IAP_RunAPP(param);
000018  f7ffbffe          B.W      IAP_RunAPP
                  |L20.28|
;;;113    }
00001c  4770              BX       lr
;;;114    
                          ENDP

00001e  0000              DCW      0x0000
                  |L20.32|
                          DCD      0x2ffe0000

                          AREA ||i.IAP_RunAPP||, CODE, READONLY, ALIGN=2

                  IAP_RunAPP PROC
;;;65     *******************************************************************************/
;;;66     void IAP_RunAPP(uint32 appAddr)
000000  b430              PUSH     {r4,r5}
;;;67     {
;;;68         // appAddr存放的是用户程序Flash的首地址，(*(vu32*)appAddr的意思是取用户程序首地址里面的数据，该数据是用户程序的堆栈地址
;;;69         // 堆栈地址指向RAM,而RAM的起始地址是0x20000000,因此上面的判断语句执行:判断用户代码的堆栈地址是否落在:0x20000000~0x2001ffff区间中，
;;;70         // 这个区间的大小较多落在<128K RAM的区间，因此需要进行下面的判断
;;;71     
;;;72     	//定义一个函数类型的参数	
;;;73     	typedef void (*IAP_Func)(void);
;;;74     	IAP_Func jumpToApp;
;;;75     
;;;76     	if(((*(uint32*)appAddr) & 0x2FFE0000) == 0x20000000)	// 检查栈顶地址是否合法.
000002  4a10              LDR      r2,|L21.68|
000004  6801              LDR      r1,[r0,#0]
000006  4011              ANDS     r1,r1,r2
000008  f1b15f00          CMP      r1,#0x20000000
00000c  d118              BNE      |L21.64|
;;;77     	{ 
;;;78     		if (((*(uint32*)(appAddr+4)) & 0xFFF80000) != 0x08000000)   // APP无效
00000e  6841              LDR      r1,[r0,#4]
000010  f44f7280          MOV      r2,#0x100
000014  ebb24fd1          CMP      r2,r1,LSR #19
000018  d112              BNE      |L21.64|
;;;79     		{
;;;80     			return;
;;;81     		}
;;;82     
;;;83     		// 跳转之前关总中断，复位外设为默认值
;;;84     		DI();
00001a  b672              CPSID    i
;;;85     		RCU_APB2RST |= 0xFFFFFFFF;
00001c  490a              LDR      r1,|L21.72|
00001e  68ca              LDR      r2,[r1,#0xc]
000020  f04f32ff          MOV      r2,#0xffffffff
000024  60ca              STR      r2,[r1,#0xc]
;;;86     		RCU_APB2RST &= ~0xFFFFFFFF;
000026  68cb              LDR      r3,[r1,#0xc]
000028  2300              MOVS     r3,#0
00002a  60cb              STR      r3,[r1,#0xc]
;;;87     		RCU_APB1RST |= 0xFFFFFFFF;
00002c  690c              LDR      r4,[r1,#0x10]
00002e  610a              STR      r2,[r1,#0x10]
;;;88     		RCU_APB1RST &= ~0xFFFFFFFF;
000030  690a              LDR      r2,[r1,#0x10]
000032  610b              STR      r3,[r1,#0x10]
;;;89     		
;;;90     		jumpToApp = (IAP_Func)*(uint32*)(appAddr+4);		// 用户代码区第二个字为程序开始地址(复位地址)		
000034  6841              LDR      r1,[r0,#4]
;;;91     	  	__set_MSP(*(uint32*)appAddr);						// 初始化用户程序的堆栈指针
000036  6800              LDR      r0,[r0,#0]
000038  f3808808          MSR      MSP,r0
;;;92     		jumpToApp();									// 跳转到用户程序APP
00003c  bc30              POP      {r4,r5}
00003e  4708              BX       r1
                  |L21.64|
;;;93     	}
;;;94     }
000040  bc30              POP      {r4,r5}
000042  4770              BX       lr
;;;95     
                          ENDP

                  |L21.68|
                          DCD      0x2ffe0000
                  |L21.72|
                          DCD      0x40021000

                          AREA ||i.IAP_WriteAppBin||, CODE, READONLY, ALIGN=2

                  IAP_WriteAppBin PROC
;;;162    *******************************************************************************/
;;;163    BOOL IAP_WriteAppBin(uint32 appAddr, uint8 *appBuf, uint32 appSize)
000000  b5f0              PUSH     {r4-r7,lr}
;;;164    {
000002  f6ad0d04          SUB      sp,sp,#0x804
;;;165    	uint16 i = 0;
000006  2400              MOVS     r4,#0
;;;166    	uint16 j = 0;
000008  2300              MOVS     r3,#0
;;;167    	uint32 curAppAddr = appAddr; 	// 当前写入的地址
;;;168    	uint16 iapBuf[1024];			// 此16位数据需要和串口通讯协议一帧最长字节有关126*2=252个字节
;;;169    	BOOL writeStatus;
;;;170    	
;;;171    	// 参数判断
;;;172    	if (NULL == appBuf)
00000a  2900              CMP      r1,#0
00000c  d008              BEQ      |L22.32|
;;;173    	{
;;;174    		return FALSE;
;;;175    	}
;;;176    
;;;177    	// 参数检验是否非法，地址不能是IAP本身代码地址，绝对不能自己把自己擦掉
;;;178    	if ((appAddr < IAP_FLASH_APP1_ADDR) || (appAddr >= (IAP_GD32_FLASH_BASE+IAP_GD32_FLASH_SIZE)))
00000e  4e10              LDR      r6,|L22.80|
000010  1985              ADDS     r5,r0,r6
000012  f5b53f60          CMP      r5,#0x38000
000016  d305              BCC      |L22.36|
;;;179    	{
;;;180    		return FALSE;	// 非法地址
000018  2000              MOVS     r0,#0
                  |L22.26|
;;;181    	}
;;;182    	
;;;183    	// 循环写入
;;;184    	for (j = 0; j < appSize; j += 2)
;;;185    	{
;;;186    		// 字节整合
;;;187    		iapBuf[i++] = (uint16)(*appBuf) + ((uint16)(*(appBuf+1)) << 8);
;;;188    		// 偏移2个字节
;;;189    		appBuf += 2;
;;;190    	}
;;;191    
;;;192    	// 直接写入FLASH
;;;193    	writeStatus = IAP_FlashWriteHalfWordArray(curAppAddr, iapBuf, appSize/2);	
;;;194    
;;;195    	return writeStatus;
;;;196    }
00001a  f60d0d04          ADD      sp,sp,#0x804
00001e  bdf0              POP      {r4-r7,pc}
                  |L22.32|
000020  2000              MOVS     r0,#0                 ;174
000022  e7fa              B        |L22.26|
                  |L22.36|
000024  af01              ADD      r7,sp,#4              ;168
000026  e00b              B        |L22.64|
                  |L22.40|
000028  780d              LDRB     r5,[r1,#0]            ;187
00002a  784e              LDRB     r6,[r1,#1]            ;187
00002c  eb052506          ADD      r5,r5,r6,LSL #8       ;187
000030  4626              MOV      r6,r4                 ;187
000032  1c64              ADDS     r4,r4,#1              ;187
000034  b2a4              UXTH     r4,r4                 ;187
000036  f8275016          STRH     r5,[r7,r6,LSL #1]     ;187
00003a  1c89              ADDS     r1,r1,#2              ;189
00003c  1c9b              ADDS     r3,r3,#2              ;184
00003e  b29b              UXTH     r3,r3                 ;184
                  |L22.64|
000040  4293              CMP      r3,r2                 ;184
000042  d3f1              BCC      |L22.40|
000044  f3c2024f          UBFX     r2,r2,#1,#16          ;193
000048  a901              ADD      r1,sp,#4              ;193
00004a  f7fffffe          BL       IAP_FlashWriteHalfWordArray
00004e  e7e4              B        |L22.26|
;;;197    
                          ENDP

                  |L22.80|
                          DCD      0xf7ff8000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  iapCB
                          %        16

;*** Start embedded assembler ***

#line 1 "User\\iap.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_iap_c_c37294e4____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___5_iap_c_c37294e4____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_iap_c_c37294e4____REVSH|
#line 128
|__asm___5_iap_c_c37294e4____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
