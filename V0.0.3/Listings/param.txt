; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\param.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\param.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.3\Device\Include -D__MICROLIB -D__UVISION_VERSION=539 -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\param.crf User\param.c]
                          THUMB

                          AREA ||i.FACTORY_NVM_SetDirtyFlag||, CODE, READONLY, ALIGN=2

                  FACTORY_NVM_SetDirtyFlag PROC
;;;307    
;;;308    void FACTORY_NVM_SetDirtyFlag(BOOL req)
000000  4902              LDR      r1,|L1.12|
;;;309    {
;;;310    	paramCB.factoryNvmWriteRequest = TRUE;
000002  2001              MOVS     r0,#1
000004  f8810194          STRB     r0,[r1,#0x194]
;;;311    }
000008  4770              BX       lr
;;;312    
                          ENDP

00000a  0000              DCW      0x0000
                  |L1.12|
                          DCD      ||.bss||

                          AREA ||i.PARAM_CmpareN||, CODE, READONLY, ALIGN=1

                  PARAM_CmpareN PROC
;;;292    
;;;293    uint8 PARAM_CmpareN(const uint8 *str1, const uint8 *str2, uint8 len)
000000  b530              PUSH     {r4,r5,lr}
;;;294    {
;;;295    	uint16 i = 0;
000002  2300              MOVS     r3,#0
000004  e007              B        |L2.22|
                  |L2.6|
;;;296    
;;;297    	while(i < len)
;;;298    	{
;;;299    		if(*(str1 +i) != *(str2 +i))
000006  5cc4              LDRB     r4,[r0,r3]
000008  5ccd              LDRB     r5,[r1,r3]
00000a  42ac              CMP      r4,r5
00000c  d001              BEQ      |L2.18|
;;;300    		{
;;;301    			return 0;
00000e  2000              MOVS     r0,#0
;;;302    		}
;;;303    		i++;
;;;304    	}
;;;305    	return 1;
;;;306    }
000010  bd30              POP      {r4,r5,pc}
                  |L2.18|
000012  1c5b              ADDS     r3,r3,#1              ;303
000014  b29b              UXTH     r3,r3                 ;303
                  |L2.22|
000016  4293              CMP      r3,r2                 ;297
000018  d3f5              BCC      |L2.6|
00001a  2001              MOVS     r0,#1                 ;305
00001c  bd30              POP      {r4,r5,pc}
;;;307    
                          ENDP


                          AREA ||i.PARAM_Init||, CODE, READONLY, ALIGN=2

                  PARAM_Init PROC
;;;190    **********************************************************************/
;;;191    void PARAM_Init(void)
000000  b510              PUSH     {r4,lr}
;;;192    {
;;;193    	// 设置默认的运行数据
;;;194    	PARAM_SetDefaultRunningData();
000002  f7fffffe          BL       PARAM_SetDefaultRunningData
;;;195    
;;;196    	// 出厂参数
;;;197    	SPI_FLASH_ReadArray(paramCB.factoryNvm.array, SPI_FLASH_FACTORY_PARAM_ADDEESS, PARAM_FACTORY_NVM_DATA_SIZE);
000006  4c07              LDR      r4,|L3.36|
000008  2210              MOVS     r2,#0x10
00000a  4621              MOV      r1,r4
00000c  4806              LDR      r0,|L3.40|
00000e  f7fffffe          BL       SPI_FLASH_ReadArray
;;;198    	SPI_FLASH_ReadArray(paramCB.preFactoryValue, SPI_FLASH_FACTORY_PARAM_ADDEESS, PARAM_FACTORY_NVM_DATA_SIZE);
000012  4621              MOV      r1,r4
000014  4804              LDR      r0,|L3.40|
000016  2210              MOVS     r2,#0x10
000018  e8bd4010          POP      {r4,lr}
00001c  3010              ADDS     r0,r0,#0x10
00001e  f7ffbffe          B.W      SPI_FLASH_ReadArray
;;;199    }
;;;200    
                          ENDP

000022  0000              DCW      0x0000
                  |L3.36|
                          DCD      0x003fb000
                  |L3.40|
                          DCD      ||.bss||+0x174

                          AREA ||i.PARAM_SetDefaultRunningData||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_sizespec
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  PARAM_SetDefaultRunningData PROC
;;;23     // 默认运行参数
;;;24     void PARAM_SetDefaultRunningData(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;25     {
000004  b090              SUB      sp,sp,#0x40
;;;26     	uint8 length = 0;
000006  2500              MOVS     r5,#0
000008  950f              STR      r5,[sp,#0x3c]
;;;27     	uint8 buf[50];
;;;28     	uint8 i;
;;;29     	uint8 * pBuff;
;;;30     	
;;;31     	// ■■ 不需要保存至NVM的参数 ■■
;;;32     	
;;;33     	paramCB.runtime.jumpFlag = (BOOL)0;
00000a  4c72              LDR      r4,|L4.468|
00000c  f8845169          STRB     r5,[r4,#0x169]
;;;34     	
;;;35     	// 固件版本号
;;;36     	for (i = 0;i < 3;i++)
000010  2000              MOVS     r0,#0
                  |L4.18|
;;;37     	{
;;;38     		paramCB.runtime.devVersion[i] = DEV_VERSION[i];
000012  a171              ADR      r1,|L4.472|
000014  1822              ADDS     r2,r4,r0
000016  5c09              LDRB     r1,[r1,r0]
000018  f882116a          STRB     r1,[r2,#0x16a]
00001c  1c40              ADDS     r0,r0,#1              ;36
00001e  b2c0              UXTB     r0,r0                 ;36
000020  2803              CMP      r0,#3                 ;36
000022  d3f6              BCC      |L4.18|
;;;39     		
;;;40     	}
;;;41     	paramCB.runtime.fwBinNum = FW_BINNUM;
000024  34cc              ADDS     r4,r4,#0xcc
000026  f8a450a2          STRH     r5,[r4,#0xa2]
;;;42     	paramCB.runtime.fwBinVersion.devVersionRemain = DEV_VERSION_REMAIN;
00002a  f88450a4          STRB     r5,[r4,#0xa4]
;;;43     	paramCB.runtime.fwBinVersion.devReleaseVersion = DEV_RELEASE_VERSION;
00002e  f88450a5          STRB     r5,[r4,#0xa5]
;;;44     	paramCB.runtime.fwBinVersion.fwUpdateVersion = FW_UPDATE_VERSION;
000032  f88450a6          STRB     r5,[r4,#0xa6]
;;;45     	paramCB.runtime.fwBinVersion.fwDebugReleaseVersion = FW_DEBUG_RELEASE_VERSION;
000036  f88450a7          STRB     r5,[r4,#0xa7]
;;;46     	
;;;47     	// 仪表唯一序列号
;;;48     	paramCB.runtime.watchUid.sn0 = *(uint32*)(0x1FFFF7E8); 
00003a  4868              LDR      r0,|L4.476|
00003c  6800              LDR      r0,[r0,#0]
00003e  6760              STR      r0,[r4,#0x74]  ; paramCB
;;;49     	paramCB.runtime.watchUid.sn1 = *(uint32*)(0x1FFFF7EC); 
000040  4966              LDR      r1,|L4.476|
000042  1d09              ADDS     r1,r1,#4
000044  680b              LDR      r3,[r1,#0]
000046  67a3              STR      r3,[r4,#0x78]  ; paramCB
;;;50     	paramCB.runtime.watchUid.sn2 = *(uint32*)(0x1FFFF7F0);
000048  1d09              ADDS     r1,r1,#4
00004a  680a              LDR      r2,[r1,#0]
00004c  67e2              STR      r2,[r4,#0x7c]  ; paramCB
;;;51     
;;;52     	sprintf((char*)paramCB.runtime.watchUid.snStr, "%08lX%08lX%08lX", paramCB.runtime.watchUid.sn2, paramCB.runtime.watchUid.sn1, paramCB.runtime.watchUid.sn0);
00004e  9000              STR      r0,[sp,#0]
000050  a163              ADR      r1,|L4.480|
000052  4867              LDR      r0,|L4.496|
000054  f7fffffe          BL       __2sprintf
;;;53     
;;;54     	// 读取标志区数据
;;;55     	SPI_FLASH_ReadArray(paramCB.runtime.flagArr, SPI_FLASH_TEST_FLAG_ADDEESS, 64);
000058  2240              MOVS     r2,#0x40
00005a  4966              LDR      r1,|L4.500|
00005c  485d              LDR      r0,|L4.468|
00005e  f7fffffe          BL       SPI_FLASH_ReadArray
;;;56     
;;;57     	
;;;58     	// 先读取boot信息
;;;59     	paramCB.runtime.bootVersion[0] = IAP_VERSION_LENGTH;
000062  261a              MOVS     r6,#0x1a
000064  f8046c6c          STRB     r6,[r4,#-0x6c]
000068  3ccc              SUBS     r4,r4,#0xcc
;;;60     	for(i = 0; i < IAP_VERSION_LENGTH ; i++)
00006a  2000              MOVS     r0,#0
                  |L4.108|
;;;61     	{
;;;62     		paramCB.runtime.bootVersion[i + 1] = IAP_VERSION[i];
00006c  a162              ADR      r1,|L4.504|
00006e  1822              ADDS     r2,r4,r0
000070  5c09              LDRB     r1,[r1,r0]
000072  f8821061          STRB     r1,[r2,#0x61]
000076  1c40              ADDS     r0,r0,#1              ;60
000078  b2c0              UXTB     r0,r0                 ;60
00007a  281a              CMP      r0,#0x1a              ;60
00007c  d3f6              BCC      |L4.108|
;;;63     	}
;;;64     
;;;65     	// 验证BOOT版本
;;;66     	SPI_FLASH_ReadArray(&length, SPI_FLASH_BOOT_VERSION_ADDEESS, 1);
00007e  f44f14b2          MOV      r4,#0x164000
000082  2201              MOVS     r2,#1
000084  4621              MOV      r1,r4
000086  a80f              ADD      r0,sp,#0x3c
000088  f7fffffe          BL       SPI_FLASH_ReadArray
;;;67     	if (IAP_VERSION_LENGTH != length)
00008c  f89d103c          LDRB     r1,[sp,#0x3c]
000090  291a              CMP      r1,#0x1a
000092  d004              BEQ      |L4.158|
;;;68     	{
;;;69     		length = IAP_VERSION_LENGTH;
000094  4631              MOV      r1,r6
000096  960f              STR      r6,[sp,#0x3c]
;;;70     		SPI_FLASH_WriteByte(SPI_FLASH_BOOT_VERSION_ADDEESS, length);
000098  4620              MOV      r0,r4
00009a  f7fffffe          BL       SPI_FLASH_WriteByte
                  |L4.158|
;;;71     	}
;;;72     	
;;;73     	// 读取BOOT版本字符
;;;74     	SPI_FLASH_ReadArray(buf, SPI_FLASH_BOOT_VERSION_ADDEESS + 1, IAP_VERSION_LENGTH);
00009e  4c5d              LDR      r4,|L4.532|
0000a0  221a              MOVS     r2,#0x1a
0000a2  4621              MOV      r1,r4
0000a4  a802              ADD      r0,sp,#8
0000a6  f7fffffe          BL       SPI_FLASH_ReadArray
;;;75     	
;;;76     	// 如果读取的版本号不符，则强制更新为当前BOOT版本
;;;77     	if (!PARAM_CmpareN((const uint8*)buf, (const uint8*)IAP_VERSION, IAP_VERSION_LENGTH)) 
0000aa  221a              MOVS     r2,#0x1a
0000ac  a152              ADR      r1,|L4.504|
0000ae  a802              ADD      r0,sp,#8
0000b0  f7fffffe          BL       PARAM_CmpareN
0000b4  b920              CBNZ     r0,|L4.192|
;;;78     	{
;;;79     		SPI_FLASH_WriteWithErase((uint8*)IAP_VERSION, SPI_FLASH_BOOT_VERSION_ADDEESS + 1, IAP_VERSION_LENGTH);
0000b6  221a              MOVS     r2,#0x1a
0000b8  4621              MOV      r1,r4
0000ba  a04f              ADR      r0,|L4.504|
0000bc  f7fffffe          BL       SPI_FLASH_WriteWithErase
                  |L4.192|
;;;80     	}
;;;81     
;;;82     	// 读取APP版本字符
;;;83     	pBuff = &(paramCB.runtime.appVersion[0]);
0000c0  4c44              LDR      r4,|L4.468|
0000c2  3440              ADDS     r4,r4,#0x40
;;;84     	pBuff[0] = SPI_FLASH_ReadByte(SPI_FLASH_APP_VERSION_ADDEESS);
0000c4  4854              LDR      r0,|L4.536|
0000c6  f7fffffe          BL       SPI_FLASH_ReadByte
0000ca  7020              STRB     r0,[r4,#0]
;;;85     	if (31 < pBuff[0])
;;;86     	{
;;;87     		pBuff[0] = 3;
0000cc  2703              MOVS     r7,#3
;;;88     		pBuff[1] = 'E';
;;;89     		pBuff[2] = 'R';
0000ce  2652              MOVS     r6,#0x52
0000d0  f04f0845          MOV      r8,#0x45              ;88
0000d4  281f              CMP      r0,#0x1f              ;85
0000d6  d906              BLS      |L4.230|
0000d8  7027              STRB     r7,[r4,#0]            ;87
0000da  f8848001          STRB     r8,[r4,#1]            ;88
0000de  70a6              STRB     r6,[r4,#2]
;;;90     		pBuff[3] = 'R';
0000e0  70e6              STRB     r6,[r4,#3]
;;;91     		pBuff[4] = 0;
0000e2  7125              STRB     r5,[r4,#4]
0000e4  e005              B        |L4.242|
                  |L4.230|
;;;92     	}
;;;93     	else
;;;94     	{
;;;95     		SPI_FLASH_ReadArray(&(pBuff[1]), SPI_FLASH_APP_VERSION_ADDEESS + 1, pBuff[0]);
0000e6  494c              LDR      r1,|L4.536|
0000e8  4602              MOV      r2,r0
0000ea  1c49              ADDS     r1,r1,#1
0000ec  1c60              ADDS     r0,r4,#1
0000ee  f7fffffe          BL       SPI_FLASH_ReadArray
                  |L4.242|
;;;96     	}
;;;97     
;;;98     	// 读取二维码版本字符
;;;99     	pBuff = &(paramCB.runtime.qrCodeStr[0]);
0000f2  4c38              LDR      r4,|L4.468|
0000f4  34a0              ADDS     r4,r4,#0xa0
;;;100    	pBuff[0] = SPI_FLASH_ReadByte(SPI_FLASH_NEW_QR_CODE_ADDEESS);
0000f6  4849              LDR      r0,|L4.540|
0000f8  f7fffffe          BL       SPI_FLASH_ReadByte
0000fc  7020              STRB     r0,[r4,#0]
;;;101    	if (63 < pBuff[0])
0000fe  283f              CMP      r0,#0x3f
000100  d906              BLS      |L4.272|
;;;102    	{
;;;103    		pBuff[0] = 3;
000102  7027              STRB     r7,[r4,#0]
;;;104    		pBuff[1] = 'E';
000104  f8848001          STRB     r8,[r4,#1]
;;;105    		pBuff[2] = 'R';
000108  70a6              STRB     r6,[r4,#2]
;;;106    		pBuff[3] = 'R';
00010a  70e6              STRB     r6,[r4,#3]
;;;107    		pBuff[4] = 0;
00010c  7125              STRB     r5,[r4,#4]
00010e  e005              B        |L4.284|
                  |L4.272|
;;;108    	}
;;;109    	else
;;;110    	{
;;;111    		SPI_FLASH_ReadArray(&(pBuff[1]), SPI_FLASH_NEW_QR_CODE_ADDEESS + 1, pBuff[0]);
000110  4942              LDR      r1,|L4.540|
000112  4602              MOV      r2,r0
000114  1c49              ADDS     r1,r1,#1
000116  1c60              ADDS     r0,r4,#1
000118  f7fffffe          BL       SPI_FLASH_ReadArray
                  |L4.284|
;;;112    	}
;;;113    
;;;114    	// 读取UI版本
;;;115    	pBuff = &(paramCB.runtime.uiVersion[0]);
00011c  4c2d              LDR      r4,|L4.468|
00011e  3480              ADDS     r4,r4,#0x80
;;;116    	pBuff[0] = SPI_FLASH_ReadByte(SPI_FLASH_UI_VERSION_ADDEESS);
000120  483e              LDR      r0,|L4.540|
000122  38e0              SUBS     r0,r0,#0xe0
000124  f7fffffe          BL       SPI_FLASH_ReadByte
000128  7020              STRB     r0,[r4,#0]
;;;117    	if (31 < pBuff[0])
00012a  281f              CMP      r0,#0x1f
00012c  d906              BLS      |L4.316|
;;;118    	{
;;;119    		pBuff[0] = 3;
00012e  7027              STRB     r7,[r4,#0]
;;;120    		pBuff[1] = 'E';
000130  f8848001          STRB     r8,[r4,#1]
;;;121    		pBuff[2] = 'R';
000134  70a6              STRB     r6,[r4,#2]
;;;122    		pBuff[3] = 'R';
000136  70e6              STRB     r6,[r4,#3]
;;;123    		pBuff[4] = 0;
000138  7125              STRB     r5,[r4,#4]
00013a  e005              B        |L4.328|
                  |L4.316|
;;;124    	}
;;;125    	else
;;;126    	{
;;;127    		SPI_FLASH_ReadArray(&(pBuff[1]), SPI_FLASH_UI_VERSION_ADDEESS + 1, pBuff[0]);
00013c  4937              LDR      r1,|L4.540|
00013e  4602              MOV      r2,r0
000140  39df              SUBS     r1,r1,#0xdf
000142  1c60              ADDS     r0,r4,#1
000144  f7fffffe          BL       SPI_FLASH_ReadArray
                  |L4.328|
;;;128    	}
;;;129    	
;;;130    	// 读取硬件版本
;;;131    	pBuff = &(paramCB.runtime.hardVersion[0]);
000148  4c29              LDR      r4,|L4.496|
00014a  3c6c              SUBS     r4,r4,#0x6c
;;;132    	pBuff[0] = SPI_FLASH_ReadByte(SPI_FLASH_HW_VERSION_ADDEESS);
00014c  4833              LDR      r0,|L4.540|
00014e  38c0              SUBS     r0,r0,#0xc0
000150  f7fffffe          BL       SPI_FLASH_ReadByte
000154  7020              STRB     r0,[r4,#0]
;;;133    	if (31 < pBuff[0])
000156  281f              CMP      r0,#0x1f
000158  d906              BLS      |L4.360|
;;;134    	{
;;;135    		pBuff[0] = 3;
00015a  7027              STRB     r7,[r4,#0]
;;;136    		pBuff[1] = 'E';
00015c  f8848001          STRB     r8,[r4,#1]
;;;137    		pBuff[2] = 'R';
000160  70a6              STRB     r6,[r4,#2]
;;;138    		pBuff[3] = 'R';
000162  70e6              STRB     r6,[r4,#3]
;;;139    		pBuff[4] = 0;
000164  7125              STRB     r5,[r4,#4]
000166  e005              B        |L4.372|
                  |L4.360|
;;;140    	}
;;;141    	else
;;;142    	{
;;;143    		SPI_FLASH_ReadArray(&(pBuff[1]), SPI_FLASH_HW_VERSION_ADDEESS + 1, pBuff[0]);
000168  492c              LDR      r1,|L4.540|
00016a  4602              MOV      r2,r0
00016c  39bf              SUBS     r1,r1,#0xbf
00016e  1c60              ADDS     r0,r4,#1
000170  f7fffffe          BL       SPI_FLASH_ReadArray
                  |L4.372|
;;;144    	}
;;;145    
;;;146    	// 读取SN号
;;;147    	pBuff = &(paramCB.runtime.snCode[0]);
000174  4c1e              LDR      r4,|L4.496|
000176  3c4c              SUBS     r4,r4,#0x4c
;;;148    	pBuff[0] = SPI_FLASH_ReadByte(SPI_FLASH_SN_ADDEESS);
000178  4828              LDR      r0,|L4.540|
00017a  38a0              SUBS     r0,r0,#0xa0
00017c  f7fffffe          BL       SPI_FLASH_ReadByte
000180  7020              STRB     r0,[r4,#0]
;;;149    	if (31 < pBuff[0])
000182  281f              CMP      r0,#0x1f
000184  d906              BLS      |L4.404|
;;;150    	{
;;;151    		pBuff[0] = 3;
000186  7027              STRB     r7,[r4,#0]
;;;152    		pBuff[1] = 'E';
000188  f8848001          STRB     r8,[r4,#1]
;;;153    		pBuff[2] = 'R';
00018c  70a6              STRB     r6,[r4,#2]
;;;154    		pBuff[3] = 'R';
00018e  70e6              STRB     r6,[r4,#3]
;;;155    		pBuff[4] = 0;
000190  7125              STRB     r5,[r4,#4]
000192  e005              B        |L4.416|
                  |L4.404|
;;;156    	}
;;;157    	else
;;;158    	{
;;;159    		SPI_FLASH_ReadArray(&(pBuff[1]), SPI_FLASH_SN_ADDEESS + 1, pBuff[0]);
000194  4921              LDR      r1,|L4.540|
000196  4602              MOV      r2,r0
000198  399f              SUBS     r1,r1,#0x9f
00019a  1c60              ADDS     r0,r4,#1
00019c  f7fffffe          BL       SPI_FLASH_ReadArray
                  |L4.416|
;;;160    	}
;;;161    
;;;162    	// 读取蓝牙MAC地址
;;;163    	pBuff = &(paramCB.runtime.bluMac[0]);
0001a0  4c13              LDR      r4,|L4.496|
0001a2  3c2c              SUBS     r4,r4,#0x2c
;;;164    	pBuff[0] = SPI_FLASH_ReadByte(SPI_FLASH_BLE_MAC_ADDEESS);
0001a4  481d              LDR      r0,|L4.540|
0001a6  3880              SUBS     r0,r0,#0x80
0001a8  f7fffffe          BL       SPI_FLASH_ReadByte
0001ac  7020              STRB     r0,[r4,#0]
;;;165    	if (31 < pBuff[0])
0001ae  281f              CMP      r0,#0x1f
0001b0  d908              BLS      |L4.452|
;;;166    	{
;;;167    		pBuff[0] = 3;
0001b2  7027              STRB     r7,[r4,#0]
;;;168    		pBuff[1] = 'E';
0001b4  f8848001          STRB     r8,[r4,#1]
;;;169    		pBuff[2] = 'R';
0001b8  70a6              STRB     r6,[r4,#2]
;;;170    		pBuff[3] = 'R';
0001ba  70e6              STRB     r6,[r4,#3]
;;;171    		pBuff[4] = 0;
0001bc  7125              STRB     r5,[r4,#4]
                  |L4.446|
;;;172    	}
;;;173    	else
;;;174    	{
;;;175    		SPI_FLASH_ReadArray(&(pBuff[1]), SPI_FLASH_BLE_MAC_ADDEESS + 1, pBuff[0]);
;;;176    	}	
;;;177    }
0001be  b010              ADD      sp,sp,#0x40
0001c0  e8bd81f0          POP      {r4-r8,pc}
                  |L4.452|
0001c4  4915              LDR      r1,|L4.540|
0001c6  4602              MOV      r2,r0                 ;175
0001c8  397f              SUBS     r1,r1,#0x7f           ;175
0001ca  1c60              ADDS     r0,r4,#1              ;175
0001cc  f7fffffe          BL       SPI_FLASH_ReadArray
0001d0  e7f5              B        |L4.446|
;;;178    
                          ENDP

0001d2  0000              DCW      0x0000
                  |L4.468|
                          DCD      ||.bss||
                  |L4.472|
0001d8  32303100          DCB      "201",0
                  |L4.476|
                          DCD      0x1ffff7e8
                  |L4.480|
0001e0  2530386c          DCB      "%08lX%08lX%08lX",0
0001e4  58253038
0001e8  6c582530
0001ec  386c5800
                  |L4.496|
                          DCD      ||.bss||+0x14c
                  |L4.500|
                          DCD      0x003ff000
                  |L4.504|
0001f8  425f434d          DCB      "B_CM_FW_BL_DT_BC201_V0.0.0",0
0001fc  5f46575f
000200  424c5f44
000204  545f4243
000208  3230315f
00020c  56302e30
000210  2e3000  
000213  00                DCB      0
                  |L4.532|
                          DCD      0x00164001
                  |L4.536|
                          DCD      0x00165000
                  |L4.540|
                          DCD      0x003fe100

                          AREA ||i.Param_Process||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  Param_Process PROC
;;;201    
;;;202    void Param_Process(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;203    {
000002  b0a9              SUB      sp,sp,#0xa4
;;;204    	uint8 i;
;;;205    	uint8 TempStr[140];
;;;206    	uint8 hmiTypeStr[10];
;;;207    	
;;;208    	if ((paramCB.runtime.qrRegEnable) && (bleUartCB.rcvBleMacOK) && (gsmUartCB.rcvIccidOK || gsmUartCB.rcvIccidTimeOut))
000004  4d3b              LDR      r5,|L5.244|
000006  2700              MOVS     r7,#0
000008  f8950168          LDRB     r0,[r5,#0x168]  ; paramCB
00000c  2800              CMP      r0,#0
00000e  d052              BEQ      |L5.182|
000010  4e39              LDR      r6,|L5.248|
000012  f8960222          LDRB     r0,[r6,#0x222]  ; bleUartCB
000016  2800              CMP      r0,#0
000018  d04d              BEQ      |L5.182|
00001a  4c38              LDR      r4,|L5.252|
00001c  f8940049          LDRB     r0,[r4,#0x49]  ; gsmUartCB
000020  b918              CBNZ     r0,|L5.42|
000022  f894004a          LDRB     r0,[r4,#0x4a]  ; gsmUartCB
000026  2800              CMP      r0,#0
000028  d045              BEQ      |L5.182|
                  |L5.42|
;;;209    	{
;;;210    		// 读取HMI类型
;;;211    		/*E2PROM_ReadByteArray(PARAM_NVM_HMI_TYPE_START_ADDRESS, hmiTypeStr, PARAM_NVM_HMI_TYPE_SIZE);
;;;212    		hmiTypeStr[PARAM_NVM_HMI_TYPE_SIZE] = '\0';
;;;213    
;;;214    		// 判断目前仪表是何种类型
;;;215    		if (0 == strcmp((const char*)hmiTypeStr, (const char*)HMI_TYPE_BC18SU))
;;;216    		{}
;;;217    		else if (0 == strcmp((const char*)hmiTypeStr, (const char*)HMI_TYPE_BC18SU))
;;;218    		{}
;;;219    		else if (0 == strcmp((const char*)hmiTypeStr, (const char*)HMI_TYPE_BC28EU))
;;;220    		{}
;;;221    		else if (0 == strcmp((const char*)hmiTypeStr, (const char*)HMI_TYPE_BC28SU))
;;;222    		{}
;;;223    		else if (0 == strcmp((const char*)hmiTypeStr, (const char*)HMI_TYPE_BC28NU))
;;;224    		{}
;;;225    		else if (0 == strcmp((const char*)hmiTypeStr, (const char*)HMI_TYPE_BC18EC))
;;;226    		{}
;;;227    		else if (0 == strcmp((const char*)hmiTypeStr, (const char*)HMI_TYPE_BC28EC))
;;;228    		{}
;;;229    		// 不在支持的仪表类型里面
;;;230    		else
;;;231    		{
;;;232    			// 拷贝字符串
;;;233    			strcpy((char*)hmiTypeStr, (const char*)"BC18Uxx");
;;;234    		}
;;;235    		*/
;;;236    
;;;237    		// 拷贝字符串
;;;238    		strcpy((char*)hmiTypeStr, (const char*)"BC28Uxx");
00002a  a135              ADR      r1,|L5.256|
00002c  a803              ADD      r0,sp,#0xc
00002e  f7fffffe          BL       strcpy
;;;239    	
;;;240    		// 复制MAC地址到SPIflash备份	
;;;241    		paramCB.runtime.bluMac[0] = 17;		// 长度
000032  2011              MOVS     r0,#0x11
000034  f8850120          STRB     r0,[r5,#0x120]
;;;242    		for (i = 0; i < 17; i++)
000038  2000              MOVS     r0,#0
                  |L5.58|
;;;243    		{
;;;244    			paramCB.runtime.bluMac[i+1] = bleUartCB.rx.macBuff[i];
00003a  1831              ADDS     r1,r6,r0
00003c  182a              ADDS     r2,r5,r0
00003e  f891120d          LDRB     r1,[r1,#0x20d]
000042  f8821121          STRB     r1,[r2,#0x121]
000046  1c40              ADDS     r0,r0,#1              ;242
000048  b2c0              UXTB     r0,r0                 ;242
00004a  2811              CMP      r0,#0x11              ;242
00004c  d3f5              BCC      |L5.58|
;;;245    		}
;;;246    		
;;;247    		SPI_FLASH_WriteWithErase(&(paramCB.runtime.bluMac[0]), SPI_FLASH_BLE_MAC_ADDEESS, 17 + 1);
00004e  2212              MOVS     r2,#0x12
000050  492d              LDR      r1,|L5.264|
000052  482e              LDR      r0,|L5.268|
000054  f7fffffe          BL       SPI_FLASH_WriteWithErase
;;;248    		
;;;249    
;;;250    		// 设置无效GSM		
;;;251    		for (i = 0; i < 20; i++)
000058  2000              MOVS     r0,#0
;;;252    		{
;;;253    			gsmUartCB.rx.iccidBuff[i] = '0';
00005a  2130              MOVS     r1,#0x30
                  |L5.92|
00005c  1822              ADDS     r2,r4,r0
00005e  f8821032          STRB     r1,[r2,#0x32]
000062  1c40              ADDS     r0,r0,#1              ;251
000064  b2c0              UXTB     r0,r0                 ;251
000066  2814              CMP      r0,#0x14              ;251
000068  d3f8              BCC      |L5.92|
;;;254    		}
;;;255    		gsmUartCB.rx.iccidBuff[i] = '\0';
00006a  4420              ADD      r0,r0,r4
00006c  f8807032          STRB     r7,[r0,#0x32]
000070  4822              LDR      r0,|L5.252|
000072  4a26              LDR      r2,|L5.268|
;;;256    
;;;257    		
;;;258    		// 存在GSM模块
;;;259    		if ((gsmUartCB.rcvIccidOK) && (!gsmUartCB.rcvIccidTimeOut))
000074  f894c049          LDRB     r12,[r4,#0x49]  ; gsmUartCB
000078  3032              ADDS     r0,r0,#0x32           ;208
00007a  4b25              LDR      r3,|L5.272|
00007c  322c              ADDS     r2,r2,#0x2c           ;208
00007e  a903              ADD      r1,sp,#0xc            ;206
000080  f1bc0f00          CMP      r12,#0
000084  d004              BEQ      |L5.144|
000086  f894c04a          LDRB     r12,[r4,#0x4a]  ; gsmUartCB
00008a  f1bc0f00          CMP      r12,#0
00008e  d027              BEQ      |L5.224|
                  |L5.144|
;;;260    		{
;;;261    			sprintf((char*)TempStr, "%s%s%s%s%s", paramCB.runtime.watchUid.snStr, bleUartCB.rx.macBuff, gsmUartCB.rx.iccidBuff, GPS_TYPE_YES, hmiTypeStr);
;;;262    		}
;;;263    		// 没有GSM模块，超时导致的
;;;264    		else
;;;265    		{	
;;;266    			sprintf((char*)TempStr, "%s%s%s%s%s", paramCB.runtime.watchUid.snStr, bleUartCB.rx.macBuff, gsmUartCB.rx.iccidBuff, GPS_TYPE_NO, hmiTypeStr);
000090  f20f0c80          ADR      r12,|L5.276|
000094  e9cdc101          STRD     r12,r1,[sp,#4]
000098  9000              STR      r0,[sp,#0]
00009a  a11f              ADR      r1,|L5.280|
00009c  a806              ADD      r0,sp,#0x18
00009e  f7fffffe          BL       __2sprintf
                  |L5.162|
;;;267    		}
;;;268    
;;;269    		// 注册二维码参数准备完毕，立刻上报
;;;270    		IAP_CTRL_UART_SendCmdQrRegParam(TempStr);
0000a2  a806              ADD      r0,sp,#0x18
0000a4  f7fffffe          BL       IAP_CTRL_UART_SendCmdQrRegParam
;;;271    
;;;272    		paramCB.runtime.qrRegEnable = FALSE;
0000a8  f8857168          STRB     r7,[r5,#0x168]
;;;273    		bleUartCB.rcvBleMacOK = FALSE;
0000ac  f8867222          STRB     r7,[r6,#0x222]
;;;274    		gsmUartCB.rcvIccidOK = FALSE;
0000b0  f8047f49          STRB     r7,[r4,#0x49]!
;;;275    		gsmUartCB.rcvIccidTimeOut = FALSE;
0000b4  7067              STRB     r7,[r4,#1]
                  |L5.182|
;;;276    	}
;;;277    
;;;278    //=====================================================================================================================
;;;279    	// 出厂参数
;;;280    	if (paramCB.factoryNvmWriteRequest)
0000b6  f8950194          LDRB     r0,[r5,#0x194]  ; paramCB
0000ba  2800              CMP      r0,#0
0000bc  d00e              BEQ      |L5.220|
;;;281    	{
;;;282    		paramCB.factoryNvmWriteRequest = FALSE;
0000be  f8857194          STRB     r7,[r5,#0x194]
;;;283    
;;;284    		// 写入参数
;;;285    		SPI_FLASH_WriteWithErase(paramCB.factoryNvm.array, SPI_FLASH_FACTORY_PARAM_ADDEESS, PARAM_FACTORY_NVM_DATA_SIZE);
0000c2  4c18              LDR      r4,|L5.292|
0000c4  4811              LDR      r0,|L5.268|
0000c6  2210              MOVS     r2,#0x10
0000c8  4621              MOV      r1,r4
0000ca  3054              ADDS     r0,r0,#0x54
0000cc  f7fffffe          BL       SPI_FLASH_WriteWithErase
;;;286    
;;;287    		// 读取出来保存备份
;;;288    		SPI_FLASH_ReadArray(paramCB.preFactoryValue, SPI_FLASH_FACTORY_PARAM_ADDEESS, PARAM_FACTORY_NVM_DATA_SIZE);
0000d0  480e              LDR      r0,|L5.268|
0000d2  2210              MOVS     r2,#0x10
0000d4  4621              MOV      r1,r4
0000d6  3064              ADDS     r0,r0,#0x64
0000d8  f7fffffe          BL       SPI_FLASH_ReadArray
                  |L5.220|
;;;289    	}
;;;290    //=====================================================================================================================
;;;291    }
0000dc  b029              ADD      sp,sp,#0xa4
0000de  bdf0              POP      {r4-r7,pc}
                  |L5.224|
0000e0  f20f0c44          ADR      r12,|L5.296|
0000e4  e9cdc101          STRD     r12,r1,[sp,#4]        ;261
0000e8  9000              STR      r0,[sp,#0]            ;261
0000ea  a10b              ADR      r1,|L5.280|
0000ec  a806              ADD      r0,sp,#0x18           ;261
0000ee  f7fffffe          BL       __2sprintf
0000f2  e7d6              B        |L5.162|
;;;292    
                          ENDP

                  |L5.244|
                          DCD      ||.bss||
                  |L5.248|
                          DCD      bleUartCB
                  |L5.252|
                          DCD      gsmUartCB
                  |L5.256|
000100  42433238          DCB      "BC28Uxx",0
000104  55787800
                  |L5.264|
                          DCD      0x003fe080
                  |L5.268|
                          DCD      ||.bss||+0x120
                  |L5.272|
                          DCD      bleUartCB+0x20d
                  |L5.276|
000114  3000              DCB      "0",0
000116  00                DCB      0
000117  00                DCB      0
                  |L5.280|
000118  25732573          DCB      "%s%s%s%s%s",0
00011c  25732573
000120  257300  
000123  00                DCB      0
                  |L5.292|
                          DCD      0x003fb000
                  |L5.296|
000128  3100              DCB      "1",0
00012a  00                DCB      0
00012b  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  paramCB
                          %        408

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  PARAM_MCU_VERSION_ADDRESS
                          DCD      0x003fe060
                          DCD      0x003fe0e0
                          DCD      0x003fe040
                          DCD      0x00164000
                          DCD      0x00165000
                          DCD      0x003ff080
                          DCD      0x003ff088
                          DCD      0x003fe100
                          DCD      0x003fe020

;*** Start embedded assembler ***

#line 1 "User\\param.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_param_c_02385f21____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___7_param_c_02385f21____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_param_c_02385f21____REVSH|
#line 128
|__asm___7_param_c_02385f21____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
