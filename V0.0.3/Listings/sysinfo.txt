; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\sysinfo.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\sysinfo.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.3\Device\Include -D__MICROLIB -D__UVISION_VERSION=539 -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\sysinfo.crf User\sysInfo.c]
                          THUMB

                          AREA ||i.SYS_INFO_CreateWatchUID||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_sizespec
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  SYS_INFO_CreateWatchUID PROC
;;;11     
;;;12     void SYS_INFO_CreateWatchUID(void)
000000  b508              PUSH     {r3,lr}
;;;13     { 
;;;14     	sysInfoCB.watchUid.sn0 = *(uint32*)(0x1FFFF7E8); 
000002  4809              LDR      r0,|L1.40|
000004  4909              LDR      r1,|L1.44|
000006  6800              LDR      r0,[r0,#0]
000008  6008              STR      r0,[r1,#0]  ; sysInfoCB
;;;15     	sysInfoCB.watchUid.sn1 = *(uint32*)(0x1FFFF7EC); 
00000a  4a07              LDR      r2,|L1.40|
00000c  1d12              ADDS     r2,r2,#4
00000e  6813              LDR      r3,[r2,#0]
000010  604b              STR      r3,[r1,#4]  ; sysInfoCB
;;;16     	sysInfoCB.watchUid.sn2 = *(uint32*)(0x1FFFF7F0);
000012  1d12              ADDS     r2,r2,#4
000014  6812              LDR      r2,[r2,#0]
000016  608a              STR      r2,[r1,#8]  ; sysInfoCB
;;;17     
;;;18     	sprintf((char*)sysInfoCB.watchUid.snStr, "%08lX%08lX%08lX", sysInfoCB.watchUid.sn2, sysInfoCB.watchUid.sn1, sysInfoCB.watchUid.sn0);
000018  9000              STR      r0,[sp,#0]
00001a  4804              LDR      r0,|L1.44|
00001c  a104              ADR      r1,|L1.48|
00001e  300c              ADDS     r0,r0,#0xc
000020  f7fffffe          BL       __2sprintf
;;;19     }
000024  bd08              POP      {r3,pc}
;;;20     
                          ENDP

000026  0000              DCW      0x0000
                  |L1.40|
                          DCD      0x1ffff7e8
                  |L1.44|
                          DCD      ||.bss||
                  |L1.48|
000030  2530386c          DCB      "%08lX%08lX%08lX",0
000034  58253038
000038  6c582530
00003c  386c5800

                          AREA ||i.SYS_INFO_GetSysInfo||, CODE, READONLY, ALIGN=1

                  SYS_INFO_GetSysInfo PROC
;;;20     
;;;21     void SYS_INFO_GetSysInfo(void)
000000  f7ffbffe          B.W      SYS_INFO_CreateWatchUID
;;;22     {
;;;23     	SYS_INFO_CreateWatchUID();
;;;24     }
;;;25     
                          ENDP


                          AREA ||i.SYS_INFO_ParamProcess||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  SYS_INFO_ParamProcess PROC
;;;25     
;;;26     void SYS_INFO_ParamProcess(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;27     {
000002  b0a9              SUB      sp,sp,#0xa4
;;;28     	uint8 TempStr[140];
;;;29     	uint8 hmiTypeStr[10];
;;;30     	
;;;31     	if ((sysInfoCB.qrRegEnable) && (bleUartCB.rcvBleMacOK) && (gsmUartCB.rcvIccidOK || gsmUartCB.rcvIccidTimeOut))
000004  4e35              LDR      r6,|L3.220|
000006  f8960028          LDRB     r0,[r6,#0x28]  ; sysInfoCB
00000a  2800              CMP      r0,#0
00000c  d059              BEQ      |L3.194|
00000e  4f34              LDR      r7,|L3.224|
000010  f8970222          LDRB     r0,[r7,#0x222]  ; bleUartCB
000014  2800              CMP      r0,#0
000016  d054              BEQ      |L3.194|
000018  4d32              LDR      r5,|L3.228|
00001a  f8950049          LDRB     r0,[r5,#0x49]  ; gsmUartCB
00001e  b918              CBNZ     r0,|L3.40|
000020  f895004a          LDRB     r0,[r5,#0x4a]  ; gsmUartCB
000024  2800              CMP      r0,#0
000026  d04c              BEQ      |L3.194|
                  |L3.40|
;;;32     	{
;;;33     		// 读取HMI类型
;;;34     		//E2PROM_ReadByteArray(PARAM_NVM_HMI_TYPE_START_ADDRESS, hmiTypeStr, PARAM_NVM_HMI_TYPE_SIZE);
;;;35     		hmiTypeStr[PARAM_NVM_HMI_TYPE_SIZE] = '\0';
000028  2400              MOVS     r4,#0
00002a  f88d4012          STRB     r4,[sp,#0x12]
;;;36     
;;;37     		// 判断目前仪表是何种类型
;;;38     		if (0 == strcmp((const char*)hmiTypeStr, (const char*)HMI_TYPE_BC18SU))
00002e  a12e              ADR      r1,|L3.232|
000030  a803              ADD      r0,sp,#0xc
000032  f7fffffe          BL       strcmp
000036  b308              CBZ      r0,|L3.124|
;;;39     		{}
;;;40     		else if (0 == strcmp((const char*)hmiTypeStr, (const char*)HMI_TYPE_BC18SU))
000038  a12b              ADR      r1,|L3.232|
00003a  a803              ADD      r0,sp,#0xc
00003c  f7fffffe          BL       strcmp
000040  b1e0              CBZ      r0,|L3.124|
;;;41     		{}
;;;42     		else if (0 == strcmp((const char*)hmiTypeStr, (const char*)HMI_TYPE_BC28EU))
000042  a12b              ADR      r1,|L3.240|
000044  a803              ADD      r0,sp,#0xc
000046  f7fffffe          BL       strcmp
00004a  b1b8              CBZ      r0,|L3.124|
;;;43     		{}
;;;44     		else if (0 == strcmp((const char*)hmiTypeStr, (const char*)HMI_TYPE_BC28SU))
00004c  a12a              ADR      r1,|L3.248|
00004e  a803              ADD      r0,sp,#0xc
000050  f7fffffe          BL       strcmp
000054  b190              CBZ      r0,|L3.124|
;;;45     		{}
;;;46     		else if (0 == strcmp((const char*)hmiTypeStr, (const char*)HMI_TYPE_BC28NU))
000056  a12a              ADR      r1,|L3.256|
000058  a803              ADD      r0,sp,#0xc
00005a  f7fffffe          BL       strcmp
00005e  b168              CBZ      r0,|L3.124|
;;;47     		{}
;;;48     		else if (0 == strcmp((const char*)hmiTypeStr, (const char*)HMI_TYPE_BC18EC))
000060  a129              ADR      r1,|L3.264|
000062  a803              ADD      r0,sp,#0xc
000064  f7fffffe          BL       strcmp
000068  b140              CBZ      r0,|L3.124|
;;;49     		{}
;;;50     		else if (0 == strcmp((const char*)hmiTypeStr, (const char*)HMI_TYPE_BC28EC))
00006a  a129              ADR      r1,|L3.272|
00006c  a803              ADD      r0,sp,#0xc
00006e  f7fffffe          BL       strcmp
000072  b118              CBZ      r0,|L3.124|
;;;51     		{}
;;;52     		// 不在支持的仪表类型里面
;;;53     		else
;;;54     		{
;;;55     			// 拷贝字符串
;;;56     			strcpy((char*)hmiTypeStr, (const char*)HMI_TYPE_BCxxxx);
000074  a128              ADR      r1,|L3.280|
000076  a803              ADD      r0,sp,#0xc
000078  f7fffffe          BL       strcpy
                  |L3.124|
00007c  4819              LDR      r0,|L3.228|
00007e  4a17              LDR      r2,|L3.220|
;;;57     		}
;;;58     		
;;;59     		// 存在GSM模块
;;;60     		if ((gsmUartCB.rcvIccidOK) && (!gsmUartCB.rcvIccidTimeOut))
000080  f895c049          LDRB     r12,[r5,#0x49]  ; gsmUartCB
000084  3032              ADDS     r0,r0,#0x32           ;31
000086  4b26              LDR      r3,|L3.288|
000088  320c              ADDS     r2,r2,#0xc            ;31
00008a  a903              ADD      r1,sp,#0xc            ;29
00008c  f1bc0f00          CMP      r12,#0
000090  d004              BEQ      |L3.156|
000092  f895c04a          LDRB     r12,[r5,#0x4a]  ; gsmUartCB
000096  f1bc0f00          CMP      r12,#0
00009a  d014              BEQ      |L3.198|
                  |L3.156|
;;;61     		{
;;;62     			sprintf((char*)TempStr, "%s%s%s%s%s", sysInfoCB.watchUid.snStr, bleUartCB.rx.macBuff, gsmUartCB.rx.iccidBuff, GPS_TYPE_YES, hmiTypeStr);
;;;63     		}
;;;64     		// 没有GSM模块，超时导致的
;;;65     		else
;;;66     		{
;;;67     			sprintf((char*)TempStr, "%s%s%s%s%s", sysInfoCB.watchUid.snStr, bleUartCB.rx.macBuff, gsmUartCB.rx.iccidBuff, GPS_TYPE_NO, hmiTypeStr);
00009c  f20f0c84          ADR      r12,|L3.292|
0000a0  e9cdc101          STRD     r12,r1,[sp,#4]
0000a4  9000              STR      r0,[sp,#0]
0000a6  a120              ADR      r1,|L3.296|
0000a8  a806              ADD      r0,sp,#0x18
0000aa  f7fffffe          BL       __2sprintf
                  |L3.174|
;;;68     		}
;;;69     
;;;70     		// 注册二维码参数准备完毕，立刻上报
;;;71     		IAP_CTRL_UART_SendCmdQrRegParam(TempStr);
0000ae  a806              ADD      r0,sp,#0x18
0000b0  f7fffffe          BL       IAP_CTRL_UART_SendCmdQrRegParam
;;;72     
;;;73     		sysInfoCB.qrRegEnable = FALSE;
0000b4  f8864028          STRB     r4,[r6,#0x28]
;;;74     		bleUartCB.rcvBleMacOK = FALSE;
0000b8  f8874222          STRB     r4,[r7,#0x222]
;;;75     		gsmUartCB.rcvIccidOK = FALSE;
0000bc  f8054f49          STRB     r4,[r5,#0x49]!
;;;76     		gsmUartCB.rcvIccidTimeOut = FALSE;
0000c0  706c              STRB     r4,[r5,#1]
                  |L3.194|
;;;77     	}
;;;78     }
0000c2  b029              ADD      sp,sp,#0xa4
0000c4  bdf0              POP      {r4-r7,pc}
                  |L3.198|
0000c6  f20f0c6c          ADR      r12,|L3.308|
0000ca  e9cdc101          STRD     r12,r1,[sp,#4]        ;62
0000ce  9000              STR      r0,[sp,#0]            ;62
0000d0  a115              ADR      r1,|L3.296|
0000d2  a806              ADD      r0,sp,#0x18           ;62
0000d4  f7fffffe          BL       __2sprintf
0000d8  e7e9              B        |L3.174|
;;;79     
                          ENDP

0000da  0000              DCW      0x0000
                  |L3.220|
                          DCD      ||.bss||
                  |L3.224|
                          DCD      bleUartCB
                  |L3.228|
                          DCD      gsmUartCB
                  |L3.232|
0000e8  42433138          DCB      "BC18SU",0
0000ec  535500  
0000ef  00                DCB      0
                  |L3.240|
0000f0  42433238          DCB      "BC28EU",0
0000f4  455500  
0000f7  00                DCB      0
                  |L3.248|
0000f8  42433238          DCB      "BC28SU",0
0000fc  535500  
0000ff  00                DCB      0
                  |L3.256|
000100  42433238          DCB      "BC28NU",0
000104  4e5500  
000107  00                DCB      0
                  |L3.264|
000108  42433138          DCB      "BC18EC",0
00010c  454300  
00010f  00                DCB      0
                  |L3.272|
000110  42433238          DCB      "BC28EC",0
000114  454300  
000117  00                DCB      0
                  |L3.280|
000118  42437878          DCB      "BCxxxx",0
00011c  787800  
00011f  00                DCB      0
                  |L3.288|
                          DCD      bleUartCB+0x20d
                  |L3.292|
000124  3000              DCB      "0",0
000126  00                DCB      0
000127  00                DCB      0
                  |L3.296|
000128  25732573          DCB      "%s%s%s%s%s",0
00012c  25732573
000130  257300  
000133  00                DCB      0
                  |L3.308|
000134  3100              DCB      "1",0
000136  00                DCB      0
000137  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  sysInfoCB
                          %        44

;*** Start embedded assembler ***

#line 1 "User\\sysInfo.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_sysInfo_c_c7e86d9a____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___9_sysInfo_c_c7e86d9a____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_sysInfo_c_c7e86d9a____REVSH|
#line 128
|__asm___9_sysInfo_c_c7e86d9a____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
