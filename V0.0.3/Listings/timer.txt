; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\timer.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\timer.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.3\Device\Include -D__MICROLIB -D__UVISION_VERSION=539 -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\timer.crf User\timer.c]
                          THUMB

                          AREA ||i.TIMER1_IRQHandler||, CODE, READONLY, ALIGN=1

                  TIMER1_IRQHandler PROC
;;;28     // 定时器x中断服务程序
;;;29     void TIMER1_IRQHandler(void)	// TIMx硬件定时器中断矢量入口
000000  b510              PUSH     {r4,lr}
;;;30     {
;;;31     	if (timer_interrupt_flag_get(STM32_TIMERx_NUM_DEF, TIMER_INT_FLAG_UP) != RESET)  //检查TIMx更新中断发生与否
000002  2101              MOVS     r1,#1
000004  078c              LSLS     r4,r1,#30
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       timer_interrupt_flag_get
00000c  2800              CMP      r0,#0
00000e  d007              BEQ      |L1.32|
;;;32     	{	
;;;33     		// 清除TIMx更新中断标志  
;;;34     		timer_interrupt_flag_clear(STM32_TIMERx_NUM_DEF, TIMER_INT_FLAG_UP);			
000010  2101              MOVS     r1,#1
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       timer_interrupt_flag_clear
;;;35     		
;;;36     		// 定时器回调函数
;;;37     		TIMER_CALLBACK_OnTimer();		
000018  e8bd4010          POP      {r4,lr}
00001c  f7ffbffe          B.W      TIMER_CALLBACK_OnTimer
                  |L1.32|
;;;38     	}		
;;;39     }
000020  bd10              POP      {r4,pc}
;;;40     
                          ENDP


                          AREA ||i.TIMER_AddTask||, CODE, READONLY, ALIGN=2

                  TIMER_AddTask PROC
;;;85     
;;;86     BOOL TIMER_AddTask(TIMER_ID id, uint32 time, void(*action)(uint32 param), uint32 param, int32 actionTime, ACTION_MODE_E actionMode)
000000  b5f0              PUSH     {r4-r7,lr}
;;;87     {
000002  e9dd6705          LDRD     r6,r7,[sp,#0x14]
;;;88     	// 执行次数为0，不添加
;;;89     	if(0 == actionTime)
000006  2e00              CMP      r6,#0
000008  d019              BEQ      |L2.62|
;;;90     	{
;;;91     		return FALSE;
;;;92     	}
;;;93     
;;;94     	timerCB.top[id] = time/TIMER_TIME;
00000a  f04f0c05          MOV      r12,#5
00000e  fbb1f4fc          UDIV     r4,r1,r12
000012  4d0c              LDR      r5,|L2.68|
000014  f8454020          STR      r4,[r5,r0,LSL #2]
;;;95     	timerCB.action[id] = action;
000018  eb050480          ADD      r4,r5,r0,LSL #2
00001c  6722              STR      r2,[r4,#0x70]
;;;96     	timerCB.param[id] = param;
00001e  f8c430a8          STR      r3,[r4,#0xa8]
;;;97     	timerCB.loopCount[id] = actionTime-1;	// 动作次数减1，即为重复次数
000022  1e76              SUBS     r6,r6,#1
000024  f8c460e0          STR      r6,[r4,#0xe0]
;;;98     	timerCB.count[id] = time/TIMER_TIME; 	// 这条赋值语句放到最后，可以保证在前面参数设置OK以后才启动软件定时器
000028  fbb1f1fc          UDIV     r1,r1,r12
00002c  63a1              STR      r1,[r4,#0x38]
;;;99     	timerCB.actionMode[id] = actionMode;
00002e  4428              ADD      r0,r0,r5
000030  f8807118          STRB     r7,[r0,#0x118]
;;;100    	timerCB.active[id] = TRUE;
000034  2101              MOVS     r1,#1
000036  f8801126          STRB     r1,[r0,#0x126]
;;;101    	
;;;102    	return TRUE;
00003a  2001              MOVS     r0,#1
;;;103    }
00003c  bdf0              POP      {r4-r7,pc}
                  |L2.62|
00003e  2000              MOVS     r0,#0                 ;91
000040  bdf0              POP      {r4-r7,pc}
;;;104    
                          ENDP

000042  0000              DCW      0x0000
                  |L2.68|
                          DCD      ||.bss||

                          AREA ||i.TIMER_AddToQueue||, CODE, READONLY, ALIGN=2

                  TIMER_AddToQueue PROC
;;;134    // 向定时器任务队列中添加一个任务
;;;135    BOOL TIMER_AddToQueue(void(*action)(uint32 param), uint32 param)
000000  b570              PUSH     {r4-r6,lr}
;;;136    {
;;;137    	// 队列满，返回失败信息
;;;138    	if((timerCB.queue.end+1)%TIMER_TASK_QUEUE_SIZE == timerCB.queue.head)
000002  4a13              LDR      r2,|L3.80|
000004  240f              MOVS     r4,#0xf
000006  f89231ad          LDRB     r3,[r2,#0x1ad]  ; timerCB
00000a  461d              MOV      r5,r3
00000c  1c5b              ADDS     r3,r3,#1
00000e  fbb3f6f4          UDIV     r6,r3,r4
000012  fb043316          MLS      r3,r4,r6,r3
000016  f89261ac          LDRB     r6,[r2,#0x1ac]  ; timerCB
00001a  42b3              CMP      r3,r6
00001c  d101              BNE      |L3.34|
;;;139    	{
;;;140    		return FALSE;
00001e  2000              MOVS     r0,#0
;;;141    	}
;;;142    
;;;143    	// 队列未满，添加
;;;144    	timerCB.queue.task[timerCB.queue.end].action = action;
;;;145    	timerCB.queue.task[timerCB.queue.end].param  = param;
;;;146    	timerCB.queue.end ++;
;;;147    	timerCB.queue.end %= TIMER_TASK_QUEUE_SIZE;
;;;148    
;;;149    	return TRUE;
;;;150    }
000020  bd70              POP      {r4-r6,pc}
                  |L3.34|
000022  eb0203c5          ADD      r3,r2,r5,LSL #3       ;144
000026  f8c30134          STR      r0,[r3,#0x134]        ;144
00002a  f89201ad          LDRB     r0,[r2,#0x1ad]        ;145  ; timerCB
00002e  eb0200c0          ADD      r0,r2,r0,LSL #3       ;145
000032  f8c01138          STR      r1,[r0,#0x138]        ;145
000036  f89201ad          LDRB     r0,[r2,#0x1ad]        ;146  ; timerCB
00003a  1c40              ADDS     r0,r0,#1              ;146
00003c  b2c0              UXTB     r0,r0                 ;146
00003e  fbb0f1f4          UDIV     r1,r0,r4              ;147
000042  fb040011          MLS      r0,r4,r1,r0           ;147
000046  f88201ad          STRB     r0,[r2,#0x1ad]        ;147
00004a  2001              MOVS     r0,#1                 ;149
00004c  bd70              POP      {r4-r6,pc}
;;;151    
                          ENDP

00004e  0000              DCW      0x0000
                  |L3.80|
                          DCD      ||.bss||

                          AREA ||i.TIMER_CALLBACK_OnTimer||, CODE, READONLY, ALIGN=2

                  TIMER_CALLBACK_OnTimer PROC
;;;175    
;;;176    void TIMER_CALLBACK_OnTimer(void)
000000  b570              PUSH     {r4-r6,lr}
;;;177    {
;;;178    	uint8 i;
;;;179    	for(i=0; i<TIMER_ID_MAX; i++)
000002  2400              MOVS     r4,#0
;;;180    	{
;;;181    		// 计数值大于0，说明当前定时器处于活动状态，需要进行处理
;;;182    		if(timerCB.count[i] > 0)
000004  4d17              LDR      r5,|L4.100|
                  |L4.6|
000006  eb050284          ADD      r2,r5,r4,LSL #2
00000a  6b90              LDR      r0,[r2,#0x38]
00000c  b300              CBZ      r0,|L4.80|
;;;183    		{
;;;184    			// 跳过被暂停的定时器
;;;185    			if(!timerCB.active[i])
00000e  1929              ADDS     r1,r5,r4
000010  f8910126          LDRB     r0,[r1,#0x126]
000014  b1e0              CBZ      r0,|L4.80|
;;;186    			{
;;;187    				continue;
;;;188    			}
;;;189    			
;;;190    			// 计数值递减
;;;191    			timerCB.count[i] --;
000016  6b90              LDR      r0,[r2,#0x38]
000018  1e40              SUBS     r0,r0,#1
00001a  6390              STR      r0,[r2,#0x38]
;;;192    			// 计数值为0，说明软件定时器时间到
;;;193    			if(0 == timerCB.count[i])
00001c  6b90              LDR      r0,[r2,#0x38]
00001e  b9b8              CBNZ     r0,|L4.80|
;;;194    			{
;;;195    				
;;;196    				// 如果是无限循环，则无条件重新设置计数初值
;;;197    				if(timerCB.loopCount[i] < 0)
000020  f8d200e0          LDR      r0,[r2,#0xe0]
000024  2800              CMP      r0,#0
000026  da03              BGE      |L4.48|
;;;198    				{
;;;199    					timerCB.count[i] = timerCB.top[i];
000028  f8550024          LDR      r0,[r5,r4,LSL #2]
00002c  6390              STR      r0,[r2,#0x38]
00002e  e007              B        |L4.64|
                  |L4.48|
;;;200    				}
;;;201    				// 有限循环
;;;202    				else if(timerCB.loopCount[i] > 0)
000030  dd06              BLE      |L4.64|
;;;203    				{
;;;204    					timerCB.count[i] = timerCB.top[i];
000032  f8553024          LDR      r3,[r5,r4,LSL #2]
000036  6393              STR      r3,[r2,#0x38]
;;;205    					
;;;206    					// 剩余循环次数递减
;;;207    					timerCB.loopCount[i] --;
000038  f1a00001          SUB      r0,r0,#1
00003c  f8c200e0          STR      r0,[r2,#0xe0]
                  |L4.64|
;;;208    				}
;;;209    				// 循环次数为0，不予重复，当前软件定时器资源释放
;;;210    				else{}
;;;211    				
;;;212    				// 执行模式为立即执行，则在中断中执行动作
;;;213    				if (ACTION_MODE_DO_AT_ONCE == timerCB.actionMode[i])
000040  f8910118          LDRB     r0,[r1,#0x118]
000044  b148              CBZ      r0,|L4.90|
;;;214    				{
;;;215    					(*timerCB.action[i])(timerCB.param[i]);
;;;216    				}
;;;217    				// 其它模式，添加到任务队列中，在中断外执行
;;;218    				else
;;;219    				{
;;;220    					TIMER_AddToQueue(timerCB.action[i], timerCB.param[i]);
000046  f8d210a8          LDR      r1,[r2,#0xa8]
00004a  6f10              LDR      r0,[r2,#0x70]
00004c  f7fffffe          BL       TIMER_AddToQueue
                  |L4.80|
000050  1c64              ADDS     r4,r4,#1              ;179
000052  b2e4              UXTB     r4,r4                 ;179
000054  2c0e              CMP      r4,#0xe               ;179
000056  d3d6              BCC      |L4.6|
;;;221    				}	
;;;222    			}
;;;223    		}
;;;224    	}
;;;225    }
000058  bd70              POP      {r4-r6,pc}
                  |L4.90|
00005a  6f11              LDR      r1,[r2,#0x70]         ;215
00005c  f8d200a8          LDR      r0,[r2,#0xa8]         ;215
000060  4788              BLX      r1                    ;215
000062  e7f5              B        |L4.80|
;;;226    
                          ENDP

                  |L4.100|
                          DCD      ||.bss||

                          AREA ||i.TIMER_ChangeTime||, CODE, READONLY, ALIGN=2

                  TIMER_ChangeTime PROC
;;;273    // 改变指定定时器定时时间
;;;274    BOOL TIMER_ChangeTime(TIMER_ID id, uint32 time)
000000  b510              PUSH     {r4,lr}
;;;275    {
;;;276    	timerCB.top[id] = time/TIMER_TIME;
000002  2205              MOVS     r2,#5
000004  fbb1f4f2          UDIV     r4,r1,r2
000008  4b04              LDR      r3,|L5.28|
00000a  f8434020          STR      r4,[r3,r0,LSL #2]
;;;277    	timerCB.count[id] = time/TIMER_TIME;	
00000e  fbb1f1f2          UDIV     r1,r1,r2
000012  eb030080          ADD      r0,r3,r0,LSL #2
000016  6381              STR      r1,[r0,#0x38]
;;;278    		
;;;279    	return TRUE;
000018  2001              MOVS     r0,#1
;;;280    }
00001a  bd10              POP      {r4,pc}
;;;281    
                          ENDP

                  |L5.28|
                          DCD      ||.bss||

                          AREA ||i.TIMER_DoNothing||, CODE, READONLY, ALIGN=1

                  TIMER_DoNothing PROC
;;;58     
;;;59     void TIMER_DoNothing(uint32 param)
000000  4770              BX       lr
;;;60     {}
;;;61     
                          ENDP


                          AREA ||i.TIMER_Init||, CODE, READONLY, ALIGN=2

                  TIMER_Init PROC
;;;61     
;;;62     void TIMER_Init(void)
000000  b570              PUSH     {r4-r6,lr}
;;;63     {
;;;64     	TIMER_ID i;
;;;65     	
;;;66     	for(i=(TIMER_ID)0; i<TIMER_ID_MAX; i++)
000002  2000              MOVS     r0,#0
000004  2200              MOVS     r2,#0
;;;67     	{
;;;68     		timerCB.count[i] = 0;
000006  4b0f              LDR      r3,|L7.68|
;;;69     		timerCB.top[i] = 0;
;;;70     		timerCB.action[i] = TIMER_DoNothing;
000008  4c0f              LDR      r4,|L7.72|
;;;71     		timerCB.param[i] = 0;
;;;72     		timerCB.loopCount[i] = 0;
;;;73     		timerCB.active[i] = TRUE;
00000a  2501              MOVS     r5,#1
                  |L7.12|
00000c  eb030180          ADD      r1,r3,r0,LSL #2       ;68
000010  638a              STR      r2,[r1,#0x38]         ;68
000012  f8432020          STR      r2,[r3,r0,LSL #2]     ;69
000016  670c              STR      r4,[r1,#0x70]         ;70
000018  f8c120a8          STR      r2,[r1,#0xa8]         ;71
00001c  f8c120e0          STR      r2,[r1,#0xe0]         ;72
000020  1819              ADDS     r1,r3,r0
000022  f8815126          STRB     r5,[r1,#0x126]
000026  1c40              ADDS     r0,r0,#1              ;66
000028  b240              SXTB     r0,r0                 ;66
00002a  280e              CMP      r0,#0xe               ;66
00002c  dbee              BLT      |L7.12|
;;;74     	}
;;;75     
;;;76     	timerCB.queue.head = 0;
00002e  f88321ac          STRB     r2,[r3,#0x1ac]
;;;77     	timerCB.queue.end  = 0;
000032  f88321ad          STRB     r2,[r3,#0x1ad]
;;;78     	
;;;79     	// 硬件定时器x初始化
;;;80     	TIMER_InitTimerx();
000036  f7fffffe          BL       TIMER_InitTimerx
;;;81     		
;;;82     	// 启动定时器x
;;;83     	TIMER_StartTimerx();
00003a  e8bd4070          POP      {r4-r6,lr}
00003e  f7ffbffe          B.W      TIMER_StartTimerx
;;;84     }
;;;85     
                          ENDP

000042  0000              DCW      0x0000
                  |L7.68|
                          DCD      ||.bss||
                  |L7.72|
                          DCD      TIMER_DoNothing

                          AREA ||i.TIMER_InitTimerx||, CODE, READONLY, ALIGN=1

                  TIMER_InitTimerx PROC
;;;41     // 初始化定时器
;;;42     void TIMER_InitTimerx(void)
000000  f648419f          MOV      r1,#0x8c9f
;;;43     {	 
;;;44     	TIMx_INT_Init(9, 35999);	 // (35999+1) / 72MHz * (9+1) =  5ms
000004  2009              MOVS     r0,#9
000006  f7ffbffe          B.W      TIMx_INT_Init
;;;45     }
;;;46     
                          ENDP


                          AREA ||i.TIMER_KillAllTimer||, CODE, READONLY, ALIGN=2

                  TIMER_KillAllTimer PROC
;;;249    // 注销所有定时器
;;;250    void TIMER_KillAllTimer(void)
000000  b510              PUSH     {r4,lr}
;;;251    {
;;;252    	TIMER_ID i;
;;;253    		
;;;254    	for(i=(TIMER_ID)0; i<TIMER_ID_MAX; i++)
000002  2000              MOVS     r0,#0
;;;255    	{
;;;256    		timerCB.count[i] = 0;
000004  4b08              LDR      r3,|L9.40|
;;;257    		timerCB.loopCount[i] = 0;
;;;258    		timerCB.queue.task[i].action = TIMER_DoNothing;
000006  4c09              LDR      r4,|L9.44|
000008  2200              MOVS     r2,#0                 ;254
                  |L9.10|
00000a  eb030180          ADD      r1,r3,r0,LSL #2       ;256
00000e  638a              STR      r2,[r1,#0x38]         ;256
000010  f8c120e0          STR      r2,[r1,#0xe0]         ;257
000014  eb0301c0          ADD      r1,r3,r0,LSL #3
000018  f8c14134          STR      r4,[r1,#0x134]
00001c  1c40              ADDS     r0,r0,#1              ;254
00001e  b240              SXTB     r0,r0                 ;254
000020  280e              CMP      r0,#0xe               ;254
000022  dbf2              BLT      |L9.10|
;;;259    	}
;;;260    }
000024  bd10              POP      {r4,pc}
;;;261    
                          ENDP

000026  0000              DCW      0x0000
                  |L9.40|
                          DCD      ||.bss||
                  |L9.44|
                          DCD      TIMER_DoNothing

                          AREA ||i.TIMER_KillTask||, CODE, READONLY, ALIGN=2

                  TIMER_KillTask PROC
;;;105    // 销毁定时器任务
;;;106    void TIMER_KillTask(TIMER_ID id)
000000  b5f0              PUSH     {r4-r7,lr}
;;;107    {
;;;108    	uint8 i;
;;;109    	
;;;110    	if((TIMER_ID_NULL == id)||(id >= TIMER_ID_MAX))
000002  1c41              ADDS     r1,r0,#1
000004  d024              BEQ      |L10.80|
000006  280e              CMP      r0,#0xe
000008  da22              BGE      |L10.80|
;;;111    	{
;;;112    		return;
;;;113    	}
;;;114    	
;;;115    	// 计数值清零，即可将当前软件定时器释放
;;;116    	timerCB.count[id] = 0; // 这条赋值语句放到最前，可以保证在第一时间停止软件定时器
00000a  4c12              LDR      r4,|L10.84|
00000c  2100              MOVS     r1,#0
00000e  eb040380          ADD      r3,r4,r0,LSL #2
000012  6399              STR      r1,[r3,#0x38]
;;;117    
;;;118    	// 同时要删除已添加入任务队列的任务
;;;119    	i= timerCB.queue.head;
000014  f89401ac          LDRB     r0,[r4,#0x1ac]  ; timerCB
;;;120    	while(i != timerCB.queue.end)
;;;121    	{
;;;122    		// 队列中有当前定时器对应的任务，就删除
;;;123    		if((timerCB.queue.task[i].action == timerCB.action[id])&&
;;;124    			(timerCB.queue.task[i].param == timerCB.param[id]))
;;;125    		{
;;;126    			timerCB.queue.task[i].action = TIMER_DoNothing;
000018  4d0f              LDR      r5,|L10.88|
;;;127    		}
;;;128    		
;;;129    		i ++;
;;;130    		i %= TIMER_TASK_QUEUE_SIZE;
00001a  220f              MOVS     r2,#0xf
00001c  e014              B        |L10.72|
                  |L10.30|
00001e  eb0401c0          ADD      r1,r4,r0,LSL #3       ;123
000022  6f1f              LDR      r7,[r3,#0x70]         ;123
000024  f8d16134          LDR      r6,[r1,#0x134]        ;123
000028  42be              CMP      r6,r7                 ;123
00002a  d107              BNE      |L10.60|
00002c  f8d16138          LDR      r6,[r1,#0x138]        ;124
000030  f8d370a8          LDR      r7,[r3,#0xa8]         ;124
000034  42be              CMP      r6,r7                 ;124
000036  d101              BNE      |L10.60|
000038  f8c15134          STR      r5,[r1,#0x134]        ;126
                  |L10.60|
00003c  1c40              ADDS     r0,r0,#1              ;129
00003e  b2c0              UXTB     r0,r0                 ;129
000040  fbb0f1f2          UDIV     r1,r0,r2
000044  fb020011          MLS      r0,r2,r1,r0
                  |L10.72|
000048  f89411ad          LDRB     r1,[r4,#0x1ad]        ;120  ; timerCB
00004c  4281              CMP      r1,r0                 ;120
00004e  d1e6              BNE      |L10.30|
                  |L10.80|
;;;131    	}
;;;132    }
000050  bdf0              POP      {r4-r7,pc}
;;;133    
                          ENDP

000052  0000              DCW      0x0000
                  |L10.84|
                          DCD      ||.bss||
                  |L10.88|
                          DCD      TIMER_DoNothing

                          AREA ||i.TIMER_Pause||, CODE, READONLY, ALIGN=2

                  TIMER_Pause PROC
;;;227    // 暂停指定的定时器
;;;228    void TIMER_Pause(TIMER_ID id)
000000  1c41              ADDS     r1,r0,#1
;;;229    {
000002  d006              BEQ      |L11.18|
;;;230    	if((TIMER_ID_NULL == id)||(id >= TIMER_ID_MAX))
000004  280e              CMP      r0,#0xe
000006  da04              BGE      |L11.18|
;;;231    	{
;;;232    		return;
;;;233    	}
;;;234    
;;;235    	timerCB.active[id] = FALSE;
000008  4a02              LDR      r2,|L11.20|
00000a  2100              MOVS     r1,#0
00000c  4410              ADD      r0,r0,r2
00000e  f8801126          STRB     r1,[r0,#0x126]
                  |L11.18|
;;;236    }
000012  4770              BX       lr
;;;237    
                          ENDP

                  |L11.20|
                          DCD      ||.bss||

                          AREA ||i.TIMER_ResetTimer||, CODE, READONLY, ALIGN=2

                  TIMER_ResetTimer PROC
;;;262    // 复位定时器，重新开始
;;;263    void TIMER_ResetTimer(TIMER_ID id)
000000  1c41              ADDS     r1,r0,#1
;;;264    {
000002  d007              BEQ      |L12.20|
;;;265    	if((TIMER_ID_NULL == id)||(id >= TIMER_ID_MAX))
000004  280e              CMP      r0,#0xe
000006  da05              BGE      |L12.20|
;;;266    	{
;;;267    		return;
;;;268    	}
;;;269    
;;;270    	timerCB.count[id] = timerCB.top[id];
000008  4903              LDR      r1,|L12.24|
00000a  f8512020          LDR      r2,[r1,r0,LSL #2]
00000e  eb010080          ADD      r0,r1,r0,LSL #2
000012  6382              STR      r2,[r0,#0x38]
                  |L12.20|
;;;271    }
000014  4770              BX       lr
;;;272    
                          ENDP

000016  0000              DCW      0x0000
                  |L12.24|
                          DCD      ||.bss||

                          AREA ||i.TIMER_Resume||, CODE, READONLY, ALIGN=2

                  TIMER_Resume PROC
;;;238    // 恢复指定的定时器
;;;239    void TIMER_Resume(TIMER_ID id)
000000  1c41              ADDS     r1,r0,#1
;;;240    {
000002  d006              BEQ      |L13.18|
;;;241    	if((TIMER_ID_NULL == id)||(id >= TIMER_ID_MAX))
000004  280e              CMP      r0,#0xe
000006  da04              BGE      |L13.18|
;;;242    	{
;;;243    		return;
;;;244    	}
;;;245    
;;;246    	timerCB.active[id] = TRUE;
000008  4a02              LDR      r2,|L13.20|
00000a  2101              MOVS     r1,#1
00000c  4410              ADD      r0,r0,r2
00000e  f8801126          STRB     r1,[r0,#0x126]
                  |L13.18|
;;;247    }
000012  4770              BX       lr
;;;248    
                          ENDP

                  |L13.20|
                          DCD      ||.bss||

                          AREA ||i.TIMER_StartTimerx||, CODE, READONLY, ALIGN=1

                  TIMER_StartTimerx PROC
;;;47     // 启动硬件定时器
;;;48     void TIMER_StartTimerx(void)
000000  f04f4080          MOV      r0,#0x40000000
;;;49     {
;;;50     	timer_enable(STM32_TIMERx_NUM_DEF);
000004  f7ffbffe          B.W      timer_enable
;;;51     }
;;;52     
                          ENDP


                          AREA ||i.TIMER_StopTimerx||, CODE, READONLY, ALIGN=1

                  TIMER_StopTimerx PROC
;;;53     // 停止硬件定时器
;;;54     void TIMER_StopTimerx(void)
000000  f04f4080          MOV      r0,#0x40000000
;;;55     {
;;;56     	timer_disable(STM32_TIMERx_NUM_DEF);
000004  f7ffbffe          B.W      timer_disable
;;;57     }
;;;58     
                          ENDP


                          AREA ||i.TIMER_TaskQueueProcess||, CODE, READONLY, ALIGN=2

                  TIMER_TaskQueueProcess PROC
;;;152    // 定时器任务队列处理，在main中调用
;;;153    void TIMER_TaskQueueProcess(void)
000000  b510              PUSH     {r4,lr}
;;;154    {
;;;155    	void(*action)(uint32 param) = NULL;
;;;156    	uint32 param;
;;;157    	TIMER_TASK* pTask = NULL;
;;;158    	
;;;159    	// 队列空，退出
;;;160    	if(timerCB.queue.head == timerCB.queue.end)
000002  4c0d              LDR      r4,|L16.56|
000004  f89401ac          LDRB     r0,[r4,#0x1ac]  ; timerCB
000008  f89411ad          LDRB     r1,[r4,#0x1ad]  ; timerCB
00000c  4288              CMP      r0,r1
00000e  d011              BEQ      |L16.52|
;;;161    	{
;;;162    		return;
;;;163    	}
;;;164    
;;;165    	// 队列非空，取出head处的任务执行之
;;;166    	pTask = &timerCB.queue.task[timerCB.queue.head];
000010  eb0400c0          ADD      r0,r4,r0,LSL #3
000014  f500709a          ADD      r0,r0,#0x134
;;;167    	action = pTask->action;
000018  6801              LDR      r1,[r0,#0]
;;;168    	param  = pTask->param;
00001a  6840              LDR      r0,[r0,#4]
;;;169    	(*action)(param);
00001c  4788              BLX      r1
;;;170    
;;;171    	// 删除任务
;;;172    	timerCB.queue.head ++;
00001e  f89401ac          LDRB     r0,[r4,#0x1ac]  ; timerCB
000022  1c40              ADDS     r0,r0,#1
000024  b2c0              UXTB     r0,r0
;;;173    	timerCB.queue.head %= TIMER_TASK_QUEUE_SIZE;
000026  210f              MOVS     r1,#0xf
000028  fbb0f2f1          UDIV     r2,r0,r1
00002c  fb010012          MLS      r0,r1,r2,r0
000030  f88401ac          STRB     r0,[r4,#0x1ac]
                  |L16.52|
;;;174    }
000034  bd10              POP      {r4,pc}
;;;175    
                          ENDP

000036  0000              DCW      0x0000
                  |L16.56|
                          DCD      ||.bss||

                          AREA ||i.TIMx_INT_Init||, CODE, READONLY, ALIGN=1

                  TIMx_INT_Init PROC
;;;6      // 定时器硬件底层初始化
;;;7      void TIMx_INT_Init(uint16 arr, uint16 psc)
000000  b57f              PUSH     {r0-r6,lr}
;;;8      {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;9      	timer_parameter_struct timer_initpara;
;;;10     	
;;;11     	rcu_periph_clock_enable(RCU_TIMER1);							// 时钟使能
000006  f44f60e0          MOV      r0,#0x700
00000a  f7fffffe          BL       rcu_periph_clock_enable
;;;12     	timer_deinit(STM32_TIMERx_NUM_DEF);
00000e  f04f4680          MOV      r6,#0x40000000
000012  4630              MOV      r0,r6
000014  f7fffffe          BL       timer_deinit
;;;13     	
;;;14     	timer_initpara.prescaler = psc;
000018  f8ad5000          STRH     r5,[sp,#0]
;;;15     	timer_initpara.alignedmode = TIMER_COUNTER_EDGE;
00001c  2100              MOVS     r1,#0
00001e  f8ad1002          STRH     r1,[sp,#2]
;;;16     	timer_initpara.counterdirection = TIMER_COUNTER_UP;
000022  f8ad1004          STRH     r1,[sp,#4]
;;;17     	timer_initpara.period = arr;
000026  9402              STR      r4,[sp,#8]
;;;18     	timer_initpara.clockdivision = TIMER_CKDIV_DIV1;
000028  f8ad100c          STRH     r1,[sp,#0xc]
;;;19     	timer_initpara.repetitioncounter = 0;
00002c  f88d100e          STRB     r1,[sp,#0xe]
;;;20     	timer_init(STM32_TIMERx_NUM_DEF, &timer_initpara);
000030  4669              MOV      r1,sp
000032  4630              MOV      r0,r6
000034  f7fffffe          BL       timer_init
;;;21     
;;;22     	timer_flag_clear(STM32_TIMERx_NUM_DEF, TIMER_FLAG_UP);			// 清除溢出中断标志
000038  2101              MOVS     r1,#1
00003a  4630              MOV      r0,r6
00003c  f7fffffe          BL       timer_flag_clear
;;;23     	timer_interrupt_enable(STM32_TIMERx_NUM_DEF, TIMER_INT_UP);		// 使能指定的TIM1中断,允许更新中断
000040  2101              MOVS     r1,#1
000042  4630              MOV      r0,r6
000044  f7fffffe          BL       timer_interrupt_enable
;;;24     
;;;25     	nvic_irq_enable(STM32_TIMERx_IRQn_DEF, 2, 2);						// 设置中断优先级
000048  2202              MOVS     r2,#2
00004a  4611              MOV      r1,r2
00004c  201c              MOVS     r0,#0x1c
00004e  f7fffffe          BL       nvic_irq_enable
;;;26     }
000052  bd7f              POP      {r0-r6,pc}
;;;27     
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  timerCB
                          %        432

;*** Start embedded assembler ***

#line 1 "User\\timer.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_timer_c_769cd868____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___7_timer_c_769cd868____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_timer_c_769cd868____REVSH|
#line 128
|__asm___7_timer_c_769cd868____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
