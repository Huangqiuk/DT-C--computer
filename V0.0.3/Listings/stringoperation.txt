; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\stringoperation.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\stringoperation.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.3\Device\Include -D__MICROLIB -D__UVISION_VERSION=539 -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\stringoperation.crf User\stringOperation.c]
                          THUMB

                          AREA ||i.STRING_CalculateCh||, CODE, READONLY, ALIGN=1

                  STRING_CalculateCh PROC
;;;164    // 查找字符串中指定字符的个数
;;;165    int16 STRING_CalculateCh(const uint8 *str, uint8 ch)
000000  b510              PUSH     {r4,lr}
;;;166    {
;;;167    	uint16 i = 0;
000002  2200              MOVS     r2,#0
;;;168    	uint16 cnt = 0;
000004  2300              MOVS     r3,#0
;;;169    	
;;;170    	// 参数检验
;;;171    	if (NULL == str)
000006  2800              CMP      r0,#0
000008  d107              BNE      |L1.26|
;;;172    	{
;;;173    		return -1;
00000a  1e40              SUBS     r0,r0,#1
;;;174    	}
;;;175    
;;;176    	while (str[i] != '\0')
;;;177    	{
;;;178    		if (str[i] == ch)
;;;179    		{
;;;180    			cnt++;
;;;181    		}
;;;182    		i++;
;;;183    	}
;;;184    
;;;185    	return cnt;
;;;186    }
00000c  bd10              POP      {r4,pc}
                  |L1.14|
00000e  428c              CMP      r4,r1                 ;178
000010  d101              BNE      |L1.22|
000012  1c5b              ADDS     r3,r3,#1              ;180
000014  b29b              UXTH     r3,r3                 ;180
                  |L1.22|
000016  1c52              ADDS     r2,r2,#1              ;182
000018  b292              UXTH     r2,r2                 ;182
                  |L1.26|
00001a  5c84              LDRB     r4,[r0,r2]            ;176
00001c  2c00              CMP      r4,#0                 ;176
00001e  d1f6              BNE      |L1.14|
000020  b218              SXTH     r0,r3                 ;185
000022  bd10              POP      {r4,pc}
;;;187    
                          ENDP


                          AREA ||i.STRING_CatStr||, CODE, READONLY, ALIGN=1

                  STRING_CatStr PROC
;;;69     // 将两个字符串连接在一起
;;;70     void STRING_CatStr(uint8 *dst, uint8 *src)
000000  b530              PUSH     {r4,r5,lr}
;;;71     {
;;;72     	uint16 i = 0;
000002  2200              MOVS     r2,#0
;;;73     	uint16 j = 0;
000004  2300              MOVS     r3,#0
;;;74     	
;;;75     	// 参数检验
;;;76     	if ((NULL == dst) || (NULL == src))
000006  2800              CMP      r0,#0
000008  d016              BEQ      |L2.56|
00000a  2900              CMP      r1,#0
00000c  d014              BEQ      |L2.56|
00000e  e001              B        |L2.20|
                  |L2.16|
;;;77     	{
;;;78     		return;
;;;79     	}
;;;80     
;;;81     	while (dst[i] != '\0')
;;;82     	{
;;;83     		i++;
000010  1c52              ADDS     r2,r2,#1
000012  b292              UXTH     r2,r2
                  |L2.20|
000014  5c84              LDRB     r4,[r0,r2]            ;81
000016  2c00              CMP      r4,#0                 ;81
000018  d1fa              BNE      |L2.16|
00001a  e007              B        |L2.44|
                  |L2.28|
;;;84     	}
;;;85     
;;;86     	while (src[j] != '\0')
;;;87     	{
;;;88     		dst[i++] = src[j++];
00001c  461c              MOV      r4,r3
00001e  1c5b              ADDS     r3,r3,#1
000020  5d0d              LDRB     r5,[r1,r4]
000022  4614              MOV      r4,r2
000024  1c52              ADDS     r2,r2,#1
000026  b29b              UXTH     r3,r3
000028  b292              UXTH     r2,r2
00002a  5505              STRB     r5,[r0,r4]
                  |L2.44|
00002c  5ccc              LDRB     r4,[r1,r3]            ;86
00002e  2c00              CMP      r4,#0                 ;86
000030  d1f4              BNE      |L2.28|
;;;89     	}
;;;90     	dst[i+j] = '\0';	// 添加字符串结束标志'\0'
000032  441a              ADD      r2,r2,r3
000034  2100              MOVS     r1,#0
000036  5481              STRB     r1,[r0,r2]
                  |L2.56|
;;;91     	
;;;92     }
000038  bd30              POP      {r4,r5,pc}
;;;93     
                          ENDP


                          AREA ||i.STRING_CmpStr||, CODE, READONLY, ALIGN=1

                  STRING_CmpStr PROC
;;;188    // 判断两个字符串是否相等
;;;189    BOOL STRING_CmpStr(const uint8 *str1, const uint8 *str2)
000000  2800              CMP      r0,#0
;;;190    {
000002  d001              BEQ      |L3.8|
;;;191    	uint8 *localStr1 = (uint8*)str1;
;;;192    	uint8 *localStr2 = (uint8*)str2;
;;;193    	
;;;194    	// 参数检验
;;;195    	if ((NULL == str1) || (NULL == str2))
000004  000a              MOVS     r2,r1
000006  d116              BNE      |L3.54|
                  |L3.8|
;;;196    	{
;;;197    		return FALSE;
000008  2000              MOVS     r0,#0
;;;198    	}
;;;199    
;;;200    	while ((*localStr1 != '\0') && (*localStr2 != '\0'))
;;;201    	{
;;;202    		// 不区分大小写，如果是字母，需统一转换为大写
;;;203    		if ((*localStr1 >= 'a')&&(*localStr1 <= 'z'))
;;;204    		{
;;;205    			*localStr1 = *localStr1 - 32;
;;;206    		}
;;;207    
;;;208    		if ((*localStr2 >= 'a')&&(*localStr2 <= 'z'))
;;;209    		{
;;;210    			*localStr2 = *localStr2 - 32;
;;;211    		}
;;;212    
;;;213    		if (*localStr1++ != *localStr2++)
;;;214    		{
;;;215    			return FALSE;
;;;216    		} 
;;;217    	}
;;;218    
;;;219    	if ((*localStr1 == '\0') && (*localStr2 == '\0'))
;;;220    	{
;;;221    		return TRUE;
;;;222    	}
;;;223    
;;;224    	return FALSE;
;;;225    }
00000a  4770              BX       lr
                  |L3.12|
00000c  f1a20361          SUB      r3,r2,#0x61           ;203
000010  2b19              CMP      r3,#0x19              ;203
000012  d801              BHI      |L3.24|
000014  3a20              SUBS     r2,r2,#0x20           ;205
000016  7002              STRB     r2,[r0,#0]            ;205
                  |L3.24|
000018  780a              LDRB     r2,[r1,#0]            ;208
00001a  f1a20361          SUB      r3,r2,#0x61           ;208
00001e  2b19              CMP      r3,#0x19              ;208
000020  d801              BHI      |L3.38|
000022  3a20              SUBS     r2,r2,#0x20           ;210
000024  700a              STRB     r2,[r1,#0]            ;210
                  |L3.38|
000026  f8102b01          LDRB     r2,[r0],#1            ;213
00002a  f8113b01          LDRB     r3,[r1],#1            ;213
00002e  429a              CMP      r2,r3                 ;213
000030  d001              BEQ      |L3.54|
000032  2000              MOVS     r0,#0                 ;215
000034  4770              BX       lr
                  |L3.54|
000036  7802              LDRB     r2,[r0,#0]            ;200
000038  b112              CBZ      r2,|L3.64|
00003a  780b              LDRB     r3,[r1,#0]            ;200
00003c  2b00              CMP      r3,#0                 ;200
00003e  d1e5              BNE      |L3.12|
                  |L3.64|
000040  7800              LDRB     r0,[r0,#0]            ;219
000042  b908              CBNZ     r0,|L3.72|
000044  7808              LDRB     r0,[r1,#0]            ;219
000046  b108              CBZ      r0,|L3.76|
                  |L3.72|
000048  2000              MOVS     r0,#0                 ;224
00004a  4770              BX       lr
                  |L3.76|
00004c  2001              MOVS     r0,#1                 ;221
00004e  4770              BX       lr
;;;226    
                          ENDP


                          AREA ||i.STRING_CmpareN||, CODE, READONLY, ALIGN=1

                  STRING_CmpareN PROC
;;;226    
;;;227    uint8 STRING_CmpareN(const uint8 *str1, const uint8 *str2, uint8 len)
000000  b530              PUSH     {r4,r5,lr}
;;;228    {
;;;229    	uint16 i = 0;
000002  2300              MOVS     r3,#0
000004  e007              B        |L4.22|
                  |L4.6|
;;;230    
;;;231    	while(i < len)
;;;232    	{
;;;233    		if(*(str1 +i) != *(str2 +i))
000006  5cc4              LDRB     r4,[r0,r3]
000008  5ccd              LDRB     r5,[r1,r3]
00000a  42ac              CMP      r4,r5
00000c  d001              BEQ      |L4.18|
;;;234    		{
;;;235    			return 0;
00000e  2000              MOVS     r0,#0
;;;236    		}
;;;237    		i++;
;;;238    	}
;;;239    	return 1;
;;;240    }
000010  bd30              POP      {r4,r5,pc}
                  |L4.18|
000012  1c5b              ADDS     r3,r3,#1              ;237
000014  b29b              UXTH     r3,r3                 ;237
                  |L4.22|
000016  4293              CMP      r3,r2                 ;231
000018  d3f5              BCC      |L4.6|
00001a  2001              MOVS     r0,#1                 ;239
00001c  bd30              POP      {r4,r5,pc}
;;;241    
                          ENDP


                          AREA ||i.STRING_DeleteCh||, CODE, READONLY, ALIGN=1

                  STRING_DeleteCh PROC
;;;243    // 删除指定字符串中的指定字符，返回成功删除的个数
;;;244    uint16 STRING_DeleteCh(uint8 str[], uint8 ch)
000000  b530              PUSH     {r4,r5,lr}
;;;245    {
;;;246    	uint16 i, j;
;;;247    	uint16 cnt = 0;
000002  2400              MOVS     r4,#0
;;;248    	
;;;249    	for (i = 0; str[i] != '\0'; i++)
000004  2300              MOVS     r3,#0
000006  e011              B        |L5.44|
                  |L5.8|
;;;250    	{
;;;251    		if (str[i] == ch) 
000008  428a              CMP      r2,r1
00000a  d10d              BNE      |L5.40|
;;;252    		{
;;;253    			for(j = i; str[j] != '\0'; j++) 
00000c  461a              MOV      r2,r3
00000e  e004              B        |L5.26|
                  |L5.16|
;;;254    			{
;;;255    				str[j] = str[j+1];
000010  1885              ADDS     r5,r0,r2
000012  786d              LDRB     r5,[r5,#1]
000014  5485              STRB     r5,[r0,r2]
000016  1c52              ADDS     r2,r2,#1              ;253
000018  b292              UXTH     r2,r2                 ;253
                  |L5.26|
00001a  5c85              LDRB     r5,[r0,r2]            ;253
00001c  2d00              CMP      r5,#0                 ;253
00001e  d1f7              BNE      |L5.16|
;;;256    			}
;;;257    			cnt++;
000020  1c64              ADDS     r4,r4,#1
000022  b2a4              UXTH     r4,r4
;;;258    			i--;
000024  1e5b              SUBS     r3,r3,#1
000026  b29b              UXTH     r3,r3
                  |L5.40|
000028  1c5b              ADDS     r3,r3,#1              ;249
00002a  b29b              UXTH     r3,r3                 ;249
                  |L5.44|
00002c  5cc2              LDRB     r2,[r0,r3]            ;249
00002e  2a00              CMP      r2,#0                 ;249
000030  d1ea              BNE      |L5.8|
;;;259    		}		 
;;;260    	}
;;;261    
;;;262    	return cnt;
000032  4620              MOV      r0,r4
;;;263    }
000034  bd30              POP      {r4,r5,pc}
;;;264    
                          ENDP


                          AREA ||i.STRING_Find||, CODE, READONLY, ALIGN=1

                  STRING_Find PROC
;;;95     // 在指定的字符串中搜索子串，存在则返回字符串中首次出现子串的下标地址，否则返回-1
;;;96     int16 STRING_Find(const uint8 *mStr, const uint8 *subStr)
000000  b5f8              PUSH     {r3-r7,lr}
;;;97     {
;;;98     	uint8 *pCh = (uint8*)mStr;		
000002  4604              MOV      r4,r0
;;;99     	uint8 *str1, *str2;
;;;100    	volatile uint16 i = 0;	 // 子串在母串中的下标
000004  2200              MOVS     r2,#0
000006  9200              STR      r2,[sp,#0]
;;;101    
;;;102    	// 参数检验
;;;103    	if ((NULL == mStr) || (NULL == subStr))
;;;104    	{
;;;105    		return -1;
000008  1e57              SUBS     r7,r2,#1
00000a  2800              CMP      r0,#0                 ;103
00000c  d005              BEQ      |L6.26|
00000e  b121              CBZ      r1,|L6.26|
;;;106    	}
;;;107    
;;;108    	if ('\0' == *mStr)
000010  7802              LDRB     r2,[r0,#0]
000012  b122              CBZ      r2,|L6.30|
;;;109    	{
;;;110    		return -1;
;;;111    	}
;;;112    
;;;113    	if ('\0' == *subStr)
000014  780a              LDRB     r2,[r1,#0]
000016  b122              CBZ      r2,|L6.34|
000018  e013              B        |L6.66|
                  |L6.26|
00001a  4638              MOV      r0,r7                 ;105
;;;114    	{
;;;115    		return -1;
;;;116    	}
;;;117    
;;;118    	while (*pCh != '\0')
;;;119    	{				 
;;;120    		str1 = pCh; 			   
;;;121    		str2 = (uint8*)subStr;
;;;122    		
;;;123    		while ((*str1 != '\0') && (*str2 != '\0') && (*str1 == *str2))
;;;124    		{
;;;125    			str1++; 
;;;126    			str2++;
;;;127    		}
;;;128    		if (*str2 == '\0') 
;;;129    		{
;;;130    			i = pCh - mStr;
;;;131    
;;;132    			return i;
;;;133    		}
;;;134    		
;;;135    		pCh++;		  
;;;136    	}
;;;137    	
;;;138    	return -1;
;;;139    }
00001c  bdf8              POP      {r3-r7,pc}
                  |L6.30|
00001e  4638              MOV      r0,r7                 ;110
000020  bdf8              POP      {r3-r7,pc}
                  |L6.34|
000022  4638              MOV      r0,r7                 ;115
000024  bdf8              POP      {r3-r7,pc}
                  |L6.38|
000026  4623              MOV      r3,r4                 ;120
000028  460a              MOV      r2,r1                 ;121
00002a  e001              B        |L6.48|
                  |L6.44|
00002c  1c5b              ADDS     r3,r3,#1              ;125
00002e  1c52              ADDS     r2,r2,#1              ;126
                  |L6.48|
000030  781e              LDRB     r6,[r3,#0]            ;123
000032  b11e              CBZ      r6,|L6.60|
000034  7815              LDRB     r5,[r2,#0]            ;123
000036  b10d              CBZ      r5,|L6.60|
000038  42ae              CMP      r6,r5                 ;123
00003a  d0f7              BEQ      |L6.44|
                  |L6.60|
00003c  7812              LDRB     r2,[r2,#0]            ;128
00003e  b12a              CBZ      r2,|L6.76|
000040  1c64              ADDS     r4,r4,#1              ;135
                  |L6.66|
000042  7822              LDRB     r2,[r4,#0]            ;118
000044  2a00              CMP      r2,#0                 ;118
000046  d1ee              BNE      |L6.38|
000048  4638              MOV      r0,r7                 ;138
00004a  bdf8              POP      {r3-r7,pc}
                  |L6.76|
00004c  1a20              SUBS     r0,r4,r0              ;130
00004e  9000              STR      r0,[sp,#0]            ;130
000050  f8bd0000          LDRH     r0,[sp,#0]            ;132
000054  b200              SXTH     r0,r0                 ;132
000056  bdf8              POP      {r3-r7,pc}
;;;140    
                          ENDP


                          AREA ||i.STRING_FindCh||, CODE, READONLY, ALIGN=1

                  STRING_FindCh PROC
;;;141    // 查找字符串中指定字符，成功返回该字符首次出现的下标位置，否则返回-1
;;;142    int16 STRING_FindCh(const uint8 *str, uint8 ch)
000000  b510              PUSH     {r4,lr}
;;;143    {
;;;144    	uint16 i = 0;
000002  2200              MOVS     r2,#0
;;;145    	
;;;146    	// 参数检验
;;;147    	if (NULL == str)
;;;148    	{
;;;149    		return -1;
000004  1e54              SUBS     r4,r2,#1
000006  2800              CMP      r0,#0                 ;147
000008  d107              BNE      |L7.26|
00000a  4620              MOV      r0,r4
;;;150    	}
;;;151    
;;;152    	while (str[i] != '\0')
;;;153    	{
;;;154    		if (str[i] == ch)
;;;155    		{
;;;156    			return i;
;;;157    		}
;;;158    		i++;
;;;159    	}
;;;160    
;;;161    	return -1;
;;;162    }
00000c  bd10              POP      {r4,pc}
                  |L7.14|
00000e  428b              CMP      r3,r1                 ;154
000010  d101              BNE      |L7.22|
000012  b210              SXTH     r0,r2                 ;156
000014  bd10              POP      {r4,pc}
                  |L7.22|
000016  1c52              ADDS     r2,r2,#1              ;158
000018  b292              UXTH     r2,r2                 ;158
                  |L7.26|
00001a  5c83              LDRB     r3,[r0,r2]            ;152
00001c  2b00              CMP      r3,#0                 ;152
00001e  d1f6              BNE      |L7.14|
000020  4620              MOV      r0,r4                 ;161
000022  bd10              POP      {r4,pc}
;;;163    
                          ENDP


                          AREA ||i.STRING_FromTo||, CODE, READONLY, ALIGN=1

                  STRING_FromTo PROC
;;;359    // 从指定的字符串的第一个字符到第二个字符作为一个新的字串
;;;360    BOOL STRING_FromTo(const uint8 *str, uint8 firstChar, uint8 secondChar, uint8 arr[])
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;361    {
000004  460c              MOV      r4,r1
000006  4617              MOV      r7,r2
000008  4699              MOV      r9,r3
;;;362    	uint8 *localStr = (uint8*)str;
00000a  4680              MOV      r8,r0
;;;363    	uint8 *localarr = arr;
;;;364    	uint8 length = strlen((char*)str);
00000c  f7fffffe          BL       strlen
;;;365    	int16 j, k;
;;;366    	uint16 i;
;;;367    
;;;368    	// 参数检验
;;;369    	if ((NULL == localStr) || ('\0' == firstChar) || ('\0' == secondChar))
000010  ea5f0008          MOVS     r0,r8
000014  d00b              BEQ      |L8.46|
000016  b154              CBZ      r4,|L8.46|
000018  b14f              CBZ      r7,|L8.46|
;;;370    	{
;;;371    		return FALSE;
;;;372    	}
;;;373    
;;;374    	if (firstChar == secondChar)
00001a  42bc              CMP      r4,r7
00001c  d109              BNE      |L8.50|
;;;375    	{
;;;376    		// 数量不足2个
;;;377    		if (STRING_CalculateCh(localStr, firstChar) < 2)
00001e  4621              MOV      r1,r4
000020  f7fffffe          BL       STRING_CalculateCh
000024  2802              CMP      r0,#2
000026  da04              BGE      |L8.50|
;;;378    		{
;;;379    			return FALSE;
000028  2000              MOVS     r0,#0
                  |L8.42|
;;;380    		}
;;;381    	}
;;;382    
;;;383    	j = STRING_FindCh(localStr, firstChar);
;;;384    	k = STRING_FindCh(localStr, secondChar);
;;;385    	if ((-1 == j) || (-1 == k))
;;;386    	{
;;;387    		return FALSE;
;;;388    	}
;;;389    	
;;;390    	// 取第二个字符之前的字符作为新字符串
;;;391    	for (i = 0, ++j; localStr[j] != secondChar; i++, j++)
;;;392    	{
;;;393    		localarr[i] = localStr[j];
;;;394    	}
;;;395    	localarr[i] = '\0';
;;;396    
;;;397    	return TRUE;
;;;398    }
00002a  e8bd87f0          POP      {r4-r10,pc}
                  |L8.46|
00002e  2000              MOVS     r0,#0                 ;371
000030  e7fb              B        |L8.42|
                  |L8.50|
000032  4621              MOV      r1,r4                 ;383
000034  4640              MOV      r0,r8                 ;383
000036  f7fffffe          BL       STRING_FindCh
00003a  4605              MOV      r5,r0                 ;383
00003c  4639              MOV      r1,r7                 ;384
00003e  4640              MOV      r0,r8                 ;384
000040  f7fffffe          BL       STRING_FindCh
000044  1c69              ADDS     r1,r5,#1              ;385
000046  d005              BEQ      |L8.84|
000048  1c40              ADDS     r0,r0,#1              ;385
00004a  d003              BEQ      |L8.84|
00004c  2400              MOVS     r4,#0                 ;391
00004e  1c6d              ADDS     r5,r5,#1              ;391
000050  b22d              SXTH     r5,r5                 ;391
000052  e007              B        |L8.100|
                  |L8.84|
000054  2000              MOVS     r0,#0                 ;387
000056  e7e8              B        |L8.42|
                  |L8.88|
000058  f8096004          STRB     r6,[r9,r4]            ;393
00005c  1c64              ADDS     r4,r4,#1              ;391
00005e  b2a4              UXTH     r4,r4                 ;391
000060  1c6d              ADDS     r5,r5,#1              ;391
000062  b22d              SXTH     r5,r5                 ;391
                  |L8.100|
000064  f8186005          LDRB     r6,[r8,r5]            ;391
000068  42be              CMP      r6,r7                 ;391
00006a  d1f5              BNE      |L8.88|
00006c  2000              MOVS     r0,#0                 ;395
00006e  f8090004          STRB     r0,[r9,r4]            ;395
000072  2001              MOVS     r0,#1                 ;397
000074  e7d9              B        |L8.42|
;;;399    
                          ENDP


                          AREA ||i.STRING_GPS_FormCommaStr||, CODE, READONLY, ALIGN=1

                  STRING_GPS_FormCommaStr PROC
;;;428    // 得到指定序号的第m个逗号和n个逗号之间的字符作为新字符串
;;;429    BOOL STRING_GPS_FormCommaStr(const uint8 *str, uint16 mNum, uint16 nNum, uint8 arr[])
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;430    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
00000a  461f              MOV      r7,r3
;;;431    	int16 i, j; 
;;;432    	uint16 len = strlen((char*)str);
00000c  4630              MOV      r0,r6
00000e  f7fffffe          BL       strlen
000012  b280              UXTH     r0,r0
;;;433    
;;;434    	// 参数检验
;;;435    	if ((NULL == str) || (mNum > len) || (nNum > len) || (mNum > nNum))
000014  b12e              CBZ      r6,|L9.34|
000016  4284              CMP      r4,r0
000018  d803              BHI      |L9.34|
00001a  4285              CMP      r5,r0
00001c  d801              BHI      |L9.34|
00001e  42ac              CMP      r4,r5
000020  d902              BLS      |L9.40|
                  |L9.34|
;;;436    	{
;;;437    		return FALSE;
000022  2000              MOVS     r0,#0
                  |L9.36|
;;;438    	}
;;;439    
;;;440    	// 找不到逗号
;;;441    	i = STRING_GPS_GetCommaPosition(str, mNum);
;;;442    	j = STRING_GPS_GetCommaPosition(str, nNum);
;;;443    	if ((i < 0) || (j < 0))
;;;444    	{
;;;445    		return FALSE;
;;;446    	}
;;;447    
;;;448    	// 两个逗号之间无数据
;;;449    	if (1 == (j - i))
;;;450    	{
;;;451    		return FALSE;
;;;452    	}
;;;453    
;;;454    	// 截取两个逗号之间的字符组成新字符串
;;;455    	if (STRING_FromTo(&str[i], ',', ',', arr))
;;;456    	{
;;;457    		return TRUE;
;;;458    	}
;;;459    	else
;;;460    	{
;;;461    		return FALSE;
;;;462    	}
;;;463    }
000024  e8bd81f0          POP      {r4-r8,pc}
                  |L9.40|
000028  4621              MOV      r1,r4                 ;441
00002a  4630              MOV      r0,r6                 ;441
00002c  f7fffffe          BL       STRING_GPS_GetCommaPosition
000030  4604              MOV      r4,r0                 ;441
000032  4629              MOV      r1,r5                 ;442
000034  4630              MOV      r0,r6                 ;442
000036  f7fffffe          BL       STRING_GPS_GetCommaPosition
00003a  2c00              CMP      r4,#0                 ;443
00003c  db01              BLT      |L9.66|
00003e  2800              CMP      r0,#0                 ;443
000040  da01              BGE      |L9.70|
                  |L9.66|
000042  2000              MOVS     r0,#0                 ;445
000044  e7ee              B        |L9.36|
                  |L9.70|
000046  1b00              SUBS     r0,r0,r4              ;449
000048  2801              CMP      r0,#1                 ;449
00004a  d008              BEQ      |L9.94|
00004c  222c              MOVS     r2,#0x2c              ;455
00004e  1930              ADDS     r0,r6,r4              ;455
000050  463b              MOV      r3,r7                 ;455
000052  4611              MOV      r1,r2                 ;455
000054  f7fffffe          BL       STRING_FromTo
000058  b118              CBZ      r0,|L9.98|
00005a  2001              MOVS     r0,#1                 ;457
00005c  e7e2              B        |L9.36|
                  |L9.94|
00005e  2000              MOVS     r0,#0                 ;451
000060  e7e0              B        |L9.36|
                  |L9.98|
000062  2000              MOVS     r0,#0                 ;461
000064  e7de              B        |L9.36|
;;;464    
                          ENDP


                          AREA ||i.STRING_GPS_GetCommaPosition||, CODE, READONLY, ALIGN=1

                  STRING_GPS_GetCommaPosition PROC
;;;400    // 得到指定序号的逗号位置
;;;401    int16 STRING_GPS_GetCommaPosition(const uint8 *str, uint16 num)
000000  b570              PUSH     {r4-r6,lr}
;;;402    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;403    	uint16 i, j;
;;;404    	uint16 len = strlen((char*)str);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       strlen
00000c  b284              UXTH     r4,r0
;;;405    
;;;406    	// 参数检验
;;;407    	if ((NULL == str) || (num > len))
;;;408    	{
;;;409    		return -1;
00000e  f04f30ff          MOV      r0,#0xffffffff
000012  2d00              CMP      r5,#0                 ;407
000014  d00c              BEQ      |L10.48|
000016  42a6              CMP      r6,r4                 ;407
000018  d80a              BHI      |L10.48|
;;;410    	}
;;;411    	
;;;412    	for (i = 0, j = 0; i < len; i++)
00001a  2200              MOVS     r2,#0
00001c  2300              MOVS     r3,#0
00001e  e00a              B        |L10.54|
                  |L10.32|
;;;413    	{
;;;414    		if (str[i] == ',')
000020  5ca9              LDRB     r1,[r5,r2]
000022  292c              CMP      r1,#0x2c
000024  d101              BNE      |L10.42|
;;;415    		{
;;;416    			 j++;
000026  1c5b              ADDS     r3,r3,#1
000028  b29b              UXTH     r3,r3
                  |L10.42|
;;;417    		}
;;;418    
;;;419    		if (j == num)
00002a  42b3              CMP      r3,r6
00002c  d101              BNE      |L10.50|
;;;420    		{
;;;421    			return i;
00002e  b210              SXTH     r0,r2
                  |L10.48|
;;;422    		}
;;;423    	}
;;;424    	
;;;425    	return -1;
;;;426    }
000030  bd70              POP      {r4-r6,pc}
                  |L10.50|
000032  1c52              ADDS     r2,r2,#1              ;412
000034  b292              UXTH     r2,r2                 ;412
                  |L10.54|
000036  42a2              CMP      r2,r4                 ;412
000038  d3f2              BCC      |L10.32|
00003a  bd70              POP      {r4-r6,pc}
;;;427    
                          ENDP


                          AREA ||i.STRING_IntToStr||, CODE, READONLY, ALIGN=1

                  STRING_IntToStr PROC
;;;8      // 整形数转成字符串
;;;9      void STRING_IntToStr(uint32 param, uint8 *str)
000000  b570              PUSH     {r4-r6,lr}
;;;10     {
000002  b08a              SUB      sp,sp,#0x28
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;11     	uint32 localParam = param;
;;;12     	
;;;13     	// param为1个字节的整数倍长度，预留最后一个字节存储'\0'，因此在基础上+1
;;;14     	uint8 tempStr[(sizeof(param)*8+1)] = {0};
000008  2124              MOVS     r1,#0x24
00000a  a801              ADD      r0,sp,#4
00000c  f7fffffe          BL       __aeabi_memclr4
;;;15     	
;;;16     	// 临时字符串区的最后一个为0，代表字符串结尾，按照倒序方式，从倒数第二个位置开始向下标减小的方向填充字符
;;;17     	// 数组个数为sizeof(param)*8+1时，下标为[0,sizeof(param)*8]，因此倒数第二个位置在[sizeof(param)*8+1-2]
;;;18     	int8 index = (sizeof(param)*8+1) - 2;
000010  221f              MOVS     r2,#0x1f
;;;19     	
;;;20     	// 参数检验
;;;21     	if (NULL == str)
000012  2d00              CMP      r5,#0
000014  d01d              BEQ      |L11.82|
;;;22     	{
;;;23     		return;
;;;24     	}
;;;25     
;;;26     	// 从倒数第二个位置开始，向下标减小的方向添加数据
;;;27     	do{
;;;28     		tempStr[index--] = (localParam%10) + '0';
000016  200a              MOVS     r0,#0xa
000018  a901              ADD      r1,sp,#4              ;14
                  |L11.26|
00001a  fbb4f3f0          UDIV     r3,r4,r0
00001e  fb004313          MLS      r3,r0,r3,r4
000022  3330              ADDS     r3,r3,#0x30
000024  4616              MOV      r6,r2
000026  1e52              SUBS     r2,r2,#1
000028  b252              SXTB     r2,r2
00002a  558b              STRB     r3,[r1,r6]
;;;29     		localParam /= 10;
00002c  fbb4f4f0          UDIV     r4,r4,r0
;;;30     	}while((0 != localParam)&&(index > -1));
000030  b10c              CBZ      r4,|L11.54|
000032  2a00              CMP      r2,#0
000034  daf1              BGE      |L11.26|
                  |L11.54|
;;;31     
;;;32     	// 由于经过了上述的运算后，index实际指向了最前面的一个空位置，因此这里++，将其指向第一个非空字符
;;;33     	index++;
000036  1c52              ADDS     r2,r2,#1
000038  b250              SXTB     r0,r2
;;;34     	while(0 != tempStr[index])
00003a  e005              B        |L11.72|
                  |L11.60|
;;;35     	{
;;;36     		*str++ = tempStr[index++];
00003c  4602              MOV      r2,r0
00003e  1c40              ADDS     r0,r0,#1
000040  5c8a              LDRB     r2,[r1,r2]
000042  b240              SXTB     r0,r0
000044  f8052b01          STRB     r2,[r5],#1
                  |L11.72|
000048  5c0a              LDRB     r2,[r1,r0]            ;34
00004a  2a00              CMP      r2,#0                 ;34
00004c  d1f6              BNE      |L11.60|
;;;37     	}
;;;38     	*str = '\0';	// 添加结束符
00004e  2000              MOVS     r0,#0
000050  7028              STRB     r0,[r5,#0]
                  |L11.82|
;;;39     }
000052  b00a              ADD      sp,sp,#0x28
000054  bd70              POP      {r4-r6,pc}
;;;40     
                          ENDP


                          AREA ||i.STRING_Left||, CODE, READONLY, ALIGN=1

                  STRING_Left PROC
;;;293    // 从指定的字符串的开始位置，截取count个字符为子串
;;;294    void STRING_Left(const uint8 *str, uint8 count, uint8 arr[])
000000  b570              PUSH     {r4-r6,lr}
;;;295    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;296    	uint8 *localStr = (uint8*)str;
;;;297    	uint8 length = strlen((char*)str);
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       strlen
00000e  b2c1              UXTB     r1,r0
;;;298    	uint8 i;
;;;299    	
;;;300    	// 参数检验
;;;301    	if (NULL == str)
000010  2c00              CMP      r4,#0
000012  d00d              BEQ      |L12.48|
;;;302    	{
;;;303    		return;
;;;304    	}
;;;305    
;;;306    	// 长度不能越界
;;;307    	if (count > length)
000014  428d              CMP      r5,r1
000016  d900              BLS      |L12.26|
;;;308    	{
;;;309    		count = length;
000018  460d              MOV      r5,r1
                  |L12.26|
;;;310    	}
;;;311    
;;;312    	for (i = 0; i < count; i++)
00001a  2300              MOVS     r3,#0
00001c  e004              B        |L12.40|
                  |L12.30|
;;;313    	{
;;;314    	   arr[i] = *localStr++; 
00001e  f8140b01          LDRB     r0,[r4],#1
000022  54f0              STRB     r0,[r6,r3]
000024  1c5b              ADDS     r3,r3,#1              ;312
000026  b2db              UXTB     r3,r3                 ;312
                  |L12.40|
000028  42ab              CMP      r3,r5                 ;312
00002a  d3f8              BCC      |L12.30|
;;;315    	}
;;;316    	
;;;317    	arr[i] = '\0';
00002c  2000              MOVS     r0,#0
00002e  54f0              STRB     r0,[r6,r3]
                  |L12.48|
;;;318    }
000030  bd70              POP      {r4-r6,pc}
;;;319    
                          ENDP


                          AREA ||i.STRING_Mid||, CODE, READONLY, ALIGN=1

                  STRING_Mid PROC
;;;321    // 从指定的字符串的指定下标位置开始，截取中间count个字符作为子串
;;;322    void STRING_Mid(const uint8 *str, uint8 startNum, int8 count, uint8 arr[])
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;323    {
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
00000a  461c              MOV      r4,r3
;;;324    	uint8 *localStr = (uint8*)str;
;;;325    	uint8 length = strlen((char*)str);
00000c  4638              MOV      r0,r7
00000e  f7fffffe          BL       strlen
000012  b2c2              UXTB     r2,r0
;;;326    	
;;;327    	// 参数检验
;;;328    	if ((NULL == str) || (startNum > length))
000014  2f00              CMP      r7,#0
000016  d01b              BEQ      |L13.80|
000018  4296              CMP      r6,r2
00001a  d819              BHI      |L13.80|
;;;329    	{
;;;330    		return;
;;;331    	}
;;;332    
;;;333    	// 长度不能越界
;;;334    	if (count > length)
00001c  4295              CMP      r5,r2
00001e  dd01              BLE      |L13.36|
;;;335    	{
;;;336    		count = length - startNum; // 从第m个到最后
000020  1b90              SUBS     r0,r2,r6
000022  b245              SXTB     r5,r0
                  |L13.36|
;;;337    	}
;;;338    
;;;339    	localStr += startNum;
000024  19b8              ADDS     r0,r7,r6
;;;340    
;;;341    	if (count > 0)
000026  2d00              CMP      r5,#0
000028  dc03              BGT      |L13.50|
00002a  e00c              B        |L13.70|
                  |L13.44|
;;;342    	{
;;;343    		while ((count--)&&((*localStr) != '\0'))
;;;344    		{
;;;345    		   *arr++ = *localStr++; 
00002c  f8041b01          STRB     r1,[r4],#1
000030  1c40              ADDS     r0,r0,#1
                  |L13.50|
000032  1e6d              SUBS     r5,r5,#1              ;343
000034  b26d              SXTB     r5,r5                 ;343
000036  d309              BCC      |L13.76|
000038  7801              LDRB     r1,[r0,#0]            ;343
00003a  2900              CMP      r1,#0                 ;343
00003c  d1f6              BNE      |L13.44|
00003e  e005              B        |L13.76|
                  |L13.64|
;;;346    		}
;;;347    	}
;;;348    	else
;;;349    	{
;;;350    		while ((*localStr) != '\0')
;;;351    		{
;;;352    		   *arr++ = *localStr++; 
000040  f8041b01          STRB     r1,[r4],#1
000044  1c40              ADDS     r0,r0,#1
                  |L13.70|
000046  7801              LDRB     r1,[r0,#0]            ;350
000048  2900              CMP      r1,#0                 ;350
00004a  d1f9              BNE      |L13.64|
                  |L13.76|
;;;353    		}
;;;354    	}
;;;355    	
;;;356    	*arr = '\0';
00004c  2000              MOVS     r0,#0
00004e  7020              STRB     r0,[r4,#0]
                  |L13.80|
;;;357    }
000050  e8bd81f0          POP      {r4-r8,pc}
;;;358    
                          ENDP


                          AREA ||i.STRING_Right||, CODE, READONLY, ALIGN=1

                  STRING_Right PROC
;;;265    // 从指定的字符串的末尾1开始获取从右向左前 count 个字符
;;;266    void STRING_Right(const char *str, uint8 count, char arr[])
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;267    {
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;268    	uint8 *localStr = (uint8*)str;
;;;269    	uint8 length = strlen((char*)str);
00000a  4638              MOV      r0,r7
00000c  f7fffffe          BL       strlen
000010  b2c5              UXTB     r5,r0
;;;270    	
;;;271    	// 参数检验
;;;272    	if (NULL == str)
000012  2f00              CMP      r7,#0
000014  d00d              BEQ      |L14.50|
;;;273    	{
;;;274    		return;
;;;275    	}
;;;276    
;;;277    	// 长度不能越界
;;;278    	if (count > length)
000016  42ae              CMP      r6,r5
000018  d900              BLS      |L14.28|
;;;279    	{
;;;280    		count = length;
00001a  462e              MOV      r6,r5
                  |L14.28|
;;;281    	}
;;;282    
;;;283    	localStr += (length - count);	// 从右边第n个字符开始，到'\0'结束 
00001c  1ba8              SUBS     r0,r5,r6
00001e  4438              ADD      r0,r0,r7
;;;284    
;;;285    	while (*localStr != '\0')
000020  e002              B        |L14.40|
                  |L14.34|
;;;286    	{
;;;287    		*arr++ = *localStr++;
000022  f8041b01          STRB     r1,[r4],#1
000026  1c40              ADDS     r0,r0,#1
                  |L14.40|
000028  7801              LDRB     r1,[r0,#0]            ;285
00002a  2900              CMP      r1,#0                 ;285
00002c  d1f9              BNE      |L14.34|
;;;288    	}
;;;289    	*arr = '\0';
00002e  2000              MOVS     r0,#0
000030  7020              STRB     r0,[r4,#0]
                  |L14.50|
;;;290    
;;;291    }
000032  e8bd81f0          POP      {r4-r8,pc}
;;;292    
                          ENDP


                          AREA ||i.STRING_StrToVal||, CODE, READONLY, ALIGN=1

                  STRING_StrToVal PROC
;;;41     // 字符串转数值
;;;42     uint32 STRING_StrToVal(uint8 *str)
000000  2200              MOVS     r2,#0
;;;43     {
;;;44     	uint32 value = 0;
;;;45     	uint8 *localStr = str;
;;;46     	
;;;47     	// 参数检验
;;;48     	if (NULL == str)
000002  2800              CMP      r0,#0
000004  d10c              BNE      |L15.32|
;;;49     	{
;;;50     		return 0;
;;;51     	}
;;;52     	
;;;53     	while ('\0' != *localStr)
;;;54     	{
;;;55     		if(((*localStr) < '0') || ((*localStr) > '9'))
;;;56     		{
;;;57     			return 0;
;;;58     		}
;;;59     
;;;60     		value *= 10;
;;;61     		value += (*localStr)-'0';
;;;62     		localStr ++;
;;;63     	}
;;;64     	
;;;65     	return value;
;;;66     }
000006  4770              BX       lr
                  |L15.8|
000008  f1a10330          SUB      r3,r1,#0x30           ;55
00000c  2b0a              CMP      r3,#0xa               ;55
00000e  d301              BCC      |L15.20|
000010  2000              MOVS     r0,#0                 ;57
000012  4770              BX       lr
                  |L15.20|
000014  eb020282          ADD      r2,r2,r2,LSL #2       ;60
000018  0052              LSLS     r2,r2,#1              ;60
00001a  3a30              SUBS     r2,r2,#0x30           ;61
00001c  440a              ADD      r2,r2,r1              ;61
00001e  1c40              ADDS     r0,r0,#1              ;62
                  |L15.32|
000020  7801              LDRB     r1,[r0,#0]            ;53
000022  2900              CMP      r1,#0                 ;53
000024  d1f0              BNE      |L15.8|
000026  4610              MOV      r0,r2                 ;65
000028  4770              BX       lr
;;;67     
                          ENDP


;*** Start embedded assembler ***

#line 1 "User\\stringOperation.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___17_stringOperation_c_afa3751a____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___17_stringOperation_c_afa3751a____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___17_stringOperation_c_afa3751a____REVSH|
#line 128
|__asm___17_stringOperation_c_afa3751a____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
