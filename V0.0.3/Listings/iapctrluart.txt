; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\iapctrluart.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\iapctrluart.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.3\Device\Include -D__MICROLIB -D__UVISION_VERSION=539 -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\iapctrluart.crf User\iapCtrlUart.c]
                          THUMB

                          AREA ||i.IAP_CTRL_UART_CheckSUM||, CODE, READONLY, ALIGN=1

                  IAP_CTRL_UART_CheckSUM PROC
;;;359    // 对传入的命令帧进行校验，返回校验结果
;;;360    BOOL IAP_CTRL_UART_CheckSUM(IAP_CTRL_CMD_FRAME* pCmdFrame)
000000  b530              PUSH     {r4,r5,lr}
;;;361    {
;;;362    	uint8 cc = 0;
000002  2200              MOVS     r2,#0
;;;363    	uint16 i = 0;
000004  2100              MOVS     r1,#0
;;;364    	
;;;365    	if(NULL == pCmdFrame)
000006  2800              CMP      r0,#0
000008  d003              BEQ      |L1.18|
;;;366    	{
;;;367    		return FALSE;
;;;368    	}
;;;369    
;;;370    	// 从命令头开始，到校验码之前的一个字节，依次进行异或运算
;;;371    	for(i=0; i<pCmdFrame->length-1; i++)
00000a  f8b050a0          LDRH     r5,[r0,#0xa0]
00000e  1e6b              SUBS     r3,r5,#1
000010  e005              B        |L1.30|
                  |L1.18|
000012  2000              MOVS     r0,#0                 ;367
;;;372    	{
;;;373    		cc ^= pCmdFrame->buff[i];
;;;374    	}
;;;375    
;;;376    	cc = ~cc;
;;;377    
;;;378    	// 判断计算得到的校验码与命令帧中的校验码是否相同
;;;379    	if(pCmdFrame->buff[pCmdFrame->length-1] != cc)
;;;380    	{
;;;381    		return FALSE;
;;;382    	}
;;;383    	
;;;384    	return TRUE;
;;;385    }
000014  bd30              POP      {r4,r5,pc}
                  |L1.22|
000016  5c44              LDRB     r4,[r0,r1]            ;373
000018  4062              EORS     r2,r2,r4              ;373
00001a  1c49              ADDS     r1,r1,#1              ;371
00001c  b289              UXTH     r1,r1                 ;371
                  |L1.30|
00001e  428b              CMP      r3,r1                 ;371
000020  dcf9              BGT      |L1.22|
000022  43d1              MVNS     r1,r2                 ;376
000024  b2c9              UXTB     r1,r1                 ;376
000026  1e40              SUBS     r0,r0,#1              ;379
000028  5c28              LDRB     r0,[r5,r0]            ;379
00002a  4288              CMP      r0,r1                 ;379
00002c  d001              BEQ      |L1.50|
00002e  2000              MOVS     r0,#0                 ;381
000030  bd30              POP      {r4,r5,pc}
                  |L1.50|
000032  2001              MOVS     r0,#1                 ;384
000034  bd30              POP      {r4,r5,pc}
;;;386    
                          ENDP


                          AREA ||i.IAP_CTRL_UART_CmdFrameProcess||, CODE, READONLY, ALIGN=2

                  IAP_CTRL_UART_CmdFrameProcess PROC
;;;395    // UART命令帧缓冲区处理
;;;396    void IAP_CTRL_UART_CmdFrameProcess(IAP_CTRL_UART_CB* pCB)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;397    {
000004  b08f              SUB      sp,sp,#0x3c
000006  4605              MOV      r5,r0
;;;398    	IAP_CTRL_UART_CMD cmd = IAP_CTRL_UART_CMD_NULL;
;;;399    	IAP_CTRL_CMD_FRAME* pCmdFrame = NULL;
;;;400    	uint32 temp = 0;
000008  2000              MOVS     r0,#0
;;;401    	uint32 temp2= 0;
;;;402    	uint16 length = 0;
;;;403    	uint8 errStatus;
;;;404    	uint16 i;
;;;405    	BOOL bTemp;
;;;406    	uint8* updateBuff = NULL;
;;;407    	uint8 localBuf[50];
;;;408    	uint32 temp3,temp4,temp5;
;;;409    //	IAP_CTRL_UART_SendCmdWithResult(0x78, TRUE);
;;;410    	// 参数合法性检验
;;;411    	if(NULL == pCB)
00000a  2d00              CMP      r5,#0
00000c  d01a              BEQ      |L2.68|
;;;412    	{
;;;413    		return;
;;;414    	}
;;;415    
;;;416    	// 命令帧缓冲区为空，退出
;;;417    	if(pCB->rx.head == pCB->rx.end)
00000e  f8b5142a          LDRH     r1,[r5,#0x42a]
000012  f8b5242c          LDRH     r2,[r5,#0x42c]
000016  4291              CMP      r1,r2
000018  d014              BEQ      |L2.68|
;;;418    	{
;;;419    		return;
;;;420    	}
;;;421    
;;;422    	// 获取当前要处理的命令帧指针
;;;423    	pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.head];
00001a  eb011201          ADD      r2,r1,r1,LSL #4
00001e  eb021281          ADD      r2,r2,r1,LSL #6
000022  eb050442          ADD      r4,r5,r2,LSL #1
000026  f5047480          ADD      r4,r4,#0x100
;;;424    	
;;;425    	// 命令头非法，退出
;;;426    	if(IAP_CTRL_UART_CMD_HEAD != pCmdFrame->buff[IAP_CTRL_UART_CMD_HEAD_INDEX])
;;;427    	{
;;;428    		// 删除命令帧
;;;429    		pCB->rx.head ++;
;;;430    		pCB->rx.head %= IAP_CTRL_UART_RX_QUEUE_SIZE;
00002a  f04f0a05          MOV      r10,#5
00002e  7822              LDRB     r2,[r4,#0]            ;426
000030  2a55              CMP      r2,#0x55              ;426
000032  d00a              BEQ      |L2.74|
000034  1c49              ADDS     r1,r1,#1              ;429
000036  b288              UXTH     r0,r1                 ;429
000038  fbb0f1fa          UDIV     r1,r0,r10
00003c  fb0a0011          MLS      r0,r10,r1,r0
000040  f8a5042a          STRH     r0,[r5,#0x42a]
                  |L2.68|
;;;431    		return;
;;;432    	}
;;;433    
;;;434    	// 命令头合法，则提取命令
;;;435    	cmd = (IAP_CTRL_UART_CMD)pCmdFrame->buff[IAP_CTRL_UART_CMD_CMD_INDEX];
;;;436    	
;;;437    	// 执行命令帧
;;;438    	switch(cmd)
;;;439    	{		
;;;440    		case IAP_CTRL_UART_CMD_NULL:
;;;441    			break;
;;;442    
;;;443    		// 收到对发ECO请求
;;;444    		case IAP_CTRL_UART_CMD_UP_PROJECT_APPLY:
;;;445    			
;;;446    			// 关闭跳入APP1定时器
;;;447    				TIMER_KillTask(TIMER_ID_IAP_RUN_WINDOW_TIME);
;;;448    				
;;;449    	
;;;450    				TIMER_AddTask(TIMER_ID_IAP_RUN_WINDOW_TIME,
;;;451    									500,
;;;452    									IAP_JumpToAppFun,
;;;453    									IAP_FLASH_APP2_ADDR,
;;;454    									1,
;;;455    									ACTION_MODE_ADD_TO_QUEUE);
;;;456    									
;;;457    				UART_PROTOCOL_SendMcuUid(1);
;;;458    				
;;;459    				// 发送MCU_UID
;;;460    				TIMER_AddTask(TIMER_ID_MCU_UID,
;;;461    								50,
;;;462    								UART_PROTOCOL_SendMcuUid,
;;;463    								1,
;;;464    								4,
;;;465    								ACTION_MODE_ADD_TO_QUEUE);		
;;;466    			// 发送结果
;;;467    			//IAP_CTRL_UART_SendCmdWithResult(0x0F, errStatus);
;;;468    			break;
;;;469    			
;;;470    		// 发送MCU_UID
;;;471    		case UART_ECO_CMD_ECO_MCU_UID:
;;;472    		
;;;473    			// 收到此MCU_UID说明ECO申请的命令已经收到了，可以停止该命令发送
;;;474    			TIMER_KillTask(TIMER_ID_IAP_ECO_REQUEST);
;;;475    			TIMER_KillTask(TIMER_ID_MCU_UID);
;;;476    		
;;;477    			// 接受的MCU_UID长度是否等于12
;;;478    			if (UART_PROTOCOL_MCU_UID_BUFF_LENGTH == pCmdFrame->buff[IAP_CTRL_UART_CMD_LENGTH_INDEX])
;;;479    			{
;;;480    				
;;;481    				temp3 = ((uint32)(pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA4_INDEX]) << 24) 
;;;482    						+ ((uint32)(pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA3_INDEX]) << 16) 
;;;483    						+ ((uint32)(pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA2_INDEX]) << 8) 
;;;484    						+ ((uint32)(pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA1_INDEX]));
;;;485    
;;;486    				temp4 = ((uint32)(pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA8_INDEX]) << 24) 
;;;487    						+ ((uint32)(pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA7_INDEX]) << 16) 
;;;488    						+ ((uint32)(pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA6_INDEX]) << 8) 
;;;489    						+ ((uint32)(pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA5_INDEX]));
;;;490    
;;;491    				temp5 = ((uint32)(pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA12_INDEX]) << 24) 
;;;492    						+ ((uint32)(pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA11_INDEX]) << 16) 
;;;493    						+ ((uint32)(pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA10_INDEX]) << 8) 
;;;494    						+ ((uint32)(pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA9_INDEX]));
;;;495    			
;;;496    				// MCU_UID一致则不理会
;;;497    				if ((iapCB.mcuUID.sn0 == temp3) && (iapCB.mcuUID.sn1 == temp4) && (iapCB.mcuUID.sn2 == temp5))
;;;498    				{
;;;499    					break;
;;;500    				}
;;;501    				// MCU_UID不同则写入老化标志
;;;502    				else
;;;503    				{
;;;504    					// 做条件判断是为了只进入一次，防止多次进入
;;;505    					if (0x55AA55BB != iapCtrlUartCB.ageFlag)
;;;506    					{
;;;507    						// 写入老化进入标志
;;;508    						iapCtrlUartCB.ageFlag = 0x55AA55BB;
;;;509    						
;;;510    						SPI_FLASH_WriteWord(SPI_FLASH_TEST_FLAG_ADDEESS, iapCtrlUartCB.ageFlag);
;;;511    					}
;;;512    				}
;;;513    			}
;;;514    			break;
;;;515    
;;;516    		// 工程模式批准
;;;517    		case IAP_CTRL_UART_CMD_DOWN_PROJECT_APPLY_ACK:
;;;518    			// 关闭此定时器
;;;519    			TIMER_KillTask(TIMER_ID_IAP_RUN_WINDOW_TIME);
;;;520    			TIMER_KillTask(TIMER_ID_IAP_ECO_REQUEST);
;;;521    
;;;522    			// 发送结果
;;;523    			IAP_CTRL_UART_SendCmdWithResult(IAP_CTRL_UART_CMD_UP_PROJECT_READY, TRUE);
;;;524    			break;
;;;525    
;;;526    		// 恢复出厂设置
;;;527    		case IAP_CTRL_UART_CMD_DOWN_FACTORY_RESET:
;;;528    			break;
;;;529    
;;;530    		// 设置RTC
;;;531    		case IAP_CTRL_UART_CMD_DOWN_RTC_SET:
;;;532    			break;
;;;533    
;;;534    		// 系统参数写入
;;;535    		case IAP_CTRL_UART_CMD_WRITE_SYS_PARAM:
;;;536    			switch (pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA1_INDEX])
;;;537    			{
;;;538    				case 0:
;;;539    					temp = pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA2_INDEX];
;;;540    					temp <<= 8;
;;;541    					temp |= pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA3_INDEX];
;;;542    					paramCB.factoryNvm.param.sys.newWheelSize = temp;
;;;543    
;;;544    					temp = pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA4_INDEX];
;;;545    					temp <<= 8;
;;;546    					temp |= pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA5_INDEX];
;;;547    					paramCB.factoryNvm.param.sys.newPerimeter = temp;
;;;548    
;;;549    					// 单位
;;;550    					paramCB.factoryNvm.param.sys.unit = pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA6_INDEX];
;;;551    
;;;552    					// 限速
;;;553    					paramCB.factoryNvm.param.sys.speedLimitVal = pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA7_INDEX];
;;;554    
;;;555    					// 测速磁钢
;;;556    					paramCB.factoryNvm.param.sys.steelNumOfSpeedSensor = pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA8_INDEX];
;;;557    
;;;558    					// 背光亮度
;;;559    					paramCB.factoryNvm.param.sys.brightness = pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA9_INDEX];
;;;560    
;;;561    					// 自动关机时间
;;;562    					paramCB.factoryNvm.param.sys.powerOffTime = pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA10_INDEX];
;;;563    
;;;564    					// 协议
;;;565    					paramCB.factoryNvm.param.sys.protocol = pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA11_INDEX];
;;;566    
;;;567    					// 系统电压
;;;568    					paramCB.factoryNvm.param.sys.batVoltage = pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA12_INDEX];
;;;569    
;;;570    					// 电量方式
;;;571    					paramCB.factoryNvm.param.sys.percentageMethod = pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA13_INDEX];
;;;572    
;;;573    					// 推车助力
;;;574    					paramCB.factoryNvm.param.sys.pushAssistSwitch = pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA14_INDEX];
;;;575    
;;;576    					// 默认档位
;;;577    					paramCB.factoryNvm.param.sys.defaultAssist = pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA15_INDEX];
;;;578    
;;;579    					// 最大档位
;;;580    					paramCB.factoryNvm.param.sys.maxAssist = pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA16_INDEX];
;;;581    
;;;582    					// 开关机logo
;;;583    					paramCB.factoryNvm.param.sys.logo = pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA17_INDEX];
;;;584    
;;;585    					// 设置写入标志
;;;586    					FACTORY_NVM_SetDirtyFlag(TRUE);
;;;587    
;;;588    					// 发送应答信号
;;;589    					IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_HEAD);
;;;590    					IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_WRITE_SYS_PARAM);
;;;591    					IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, 2);		// 数据长度
;;;592    					IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, 0);		// 参数名称
;;;593    					IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, TRUE);
;;;594    					IAP_CTRL_UART_TxAddFrame(&iapCtrlUartCB);
;;;595    					break;
;;;596    
;;;597    				default:
;;;598    					break;
;;;599    			}
;;;600    			break;
;;;601    
;;;602    		case IAP_CTRL_UART_CMD_READ_SYS_PARAM:
;;;603    			switch (pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA1_INDEX])
;;;604    			{
;;;605    				case 0:
;;;606    					// 出厂参数
;;;607    					SPI_FLASH_ReadArray(paramCB.factoryNvm.array, SPI_FLASH_FACTORY_PARAM_ADDEESS, PARAM_FACTORY_NVM_DATA_SIZE);
;;;608    					SPI_FLASH_ReadArray(paramCB.preFactoryValue, SPI_FLASH_FACTORY_PARAM_ADDEESS, PARAM_FACTORY_NVM_DATA_SIZE);
;;;609    					
;;;610    					IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_HEAD);
;;;611    					IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_READ_SYS_PARAM);
;;;612    					IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, 1);		// 数据长度
;;;613    					IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, 0);		// 参数名称
;;;614    
;;;615    					IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, paramCB.factoryNvm.param.sys.newWheelSize>>8);
;;;616    					IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, paramCB.factoryNvm.param.sys.newWheelSize>>0);
;;;617    
;;;618    					IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, paramCB.factoryNvm.param.sys.newPerimeter>>8);
;;;619    					IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, paramCB.factoryNvm.param.sys.newPerimeter>>0);
;;;620    
;;;621    					IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, paramCB.factoryNvm.param.sys.unit);
;;;622    
;;;623    					IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, paramCB.factoryNvm.param.sys.speedLimitVal);
;;;624    
;;;625    					IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, paramCB.factoryNvm.param.sys.steelNumOfSpeedSensor);
;;;626    
;;;627    					IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, paramCB.factoryNvm.param.sys.brightness);
;;;628    
;;;629    					IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, paramCB.factoryNvm.param.sys.powerOffTime);
;;;630    
;;;631    					IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, paramCB.factoryNvm.param.sys.protocol);
;;;632    
;;;633    					IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, paramCB.factoryNvm.param.sys.batVoltage);
;;;634    
;;;635    					IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, paramCB.factoryNvm.param.sys.percentageMethod);
;;;636    
;;;637    					IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, paramCB.factoryNvm.param.sys.pushAssistSwitch);
;;;638    
;;;639    					IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, paramCB.factoryNvm.param.sys.defaultAssist);
;;;640    
;;;641    					IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, paramCB.factoryNvm.param.sys.maxAssist);
;;;642    
;;;643    					IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, paramCB.factoryNvm.param.sys.logo);
;;;644    					
;;;645    					
;;;646    					IAP_CTRL_UART_TxAddFrame(&iapCtrlUartCB);
;;;647    					
;;;648    					break;
;;;649    
;;;650    				default:
;;;651    					break;
;;;652    			}
;;;653    			break;
;;;654    
;;;655    		// UI数据擦除
;;;656    		case IAP_CTRL_UART_CMD_DOWN_UI_DATA_ERASE:
;;;657    			// 以块方式擦除
;;;658    #if (0 == SPI_FLASH_ERASE_MODE)
;;;659    			// 扇区擦除
;;;660    			SPI_FLASH_EraseRoom(SPI_FLASH_UI_OFFSET_ADDR, SPI_FLASH_UI_SIZE);
;;;661    			
;;;662    #elif (1 == SPI_FLASH_ERASE_MODE)
;;;663    			// 擦除整个FLASH
;;;664    			SPI_FLASH_EraseChip();
;;;665    			
;;;666    #elif (2 == SPI_FLASH_ERASE_MODE)
;;;667    			SPI_FLASH_EraseRoom(SPI_FLASH_UI_OFFSET_ADDR, SPI_FLASH_UI_SIZE);
;;;668    #endif
;;;669    
;;;670    			// 发送结果
;;;671    			IAP_CTRL_UART_SendCmdWithResult(IAP_CTRL_UART_CMD_UP_UI_DATA_ERASE_ACK, TRUE);
;;;672    			break;
;;;673    
;;;674    		// UI数据写入
;;;675    		case IAP_CTRL_UART_CMD_DOWN_UI_DATA_WRITE:
;;;676    			// 禁止SPI以修改配置
;;;677    			spi_disable(STM32_SPIx_NUM_DEF);
;;;678    			SPIx_ConfigureWorkMode(SPI_TRANSMODE_FULLDUPLEX, SPI_FRAMESIZE_8BIT);
;;;679    			spi_enable(STM32_SPIx_NUM_DEF);
;;;680    			temp  = pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA1_INDEX];
;;;681    			temp <<= 8;
;;;682    			temp += pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA2_INDEX];
;;;683    			temp <<= 8;
;;;684    			temp += pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA3_INDEX];
;;;685    			temp <<= 8;
;;;686    			temp += pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA4_INDEX];
;;;687    
;;;688    			length = pCmdFrame->buff[IAP_CTRL_UART_CMD_LENGTH_INDEX] - 4;
;;;689    
;;;690    			// 写入数据到flash里面
;;;691    			errStatus = SPI_FLASH_WriteWithCheck(SPI_FLASH_UI_OFFSET_ADDR + (uint8*)&pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA5_INDEX], temp, length);
;;;692    
;;;693    			// 发送结果
;;;694    			IAP_CTRL_UART_SendCmdWithResult(IAP_CTRL_UART_CMD_UP_UI_DATA_WRITE_RESULT, errStatus);
;;;695    			break;
;;;696    
;;;697    		// APP擦除
;;;698    		case IAP_CTRL_UART_CMD_DOWN_IAP_ERASE_FLASH:
;;;699    			// 显示uart升级提示
;;;700    			
;;;701    			// 先擦除APP代码区
;;;702    			IAP_EraseAPP1Area();
;;;703    
;;;704    			// 擦除完后需要读出来检查是否为空
;;;705    			errStatus = IAP_CheckApp1FlashIsBlank();
;;;706    
;;;707    			// 发送结果
;;;708    			IAP_CTRL_UART_SendCmdWithResult(IAP_CTRL_UART_CMD_UP_IAP_ERASE_FLASH_RESULT, errStatus);
;;;709    
;;;710    			break;
;;;711    			
;;;712    		// APP数据写入
;;;713    		case IAP_CTRL_UART_CMD_DOWN_IAP_WRITE_FLASH:
;;;714    			{
;;;715    				uint8 encryptionMode;
;;;716    				uint8 key;
;;;717    				static uint8 arrbuf[IAP_CTRL_UART_CMD_LENGTH_MAX];
;;;718    				
;;;719    				encryptionMode = pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA1_INDEX];
;;;720    				key 		   = pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA2_INDEX];
;;;721    
;;;722    				switch (encryptionMode)
;;;723    				{
;;;724    					case 0x00:	// 无加密，【密钥】无意义
;;;725    						temp  = pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA3_INDEX];
;;;726    						temp <<= 8;
;;;727    						temp += pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA4_INDEX];
;;;728    						temp <<= 8;
;;;729    						temp += pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA5_INDEX];
;;;730    						temp <<= 8;
;;;731    						temp += pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA6_INDEX];
;;;732    
;;;733    						length = pCmdFrame->buff[IAP_CTRL_UART_CMD_LENGTH_INDEX] - 6;
;;;734    
;;;735    						// 写入数据
;;;736    						errStatus = IAP_WriteAppBin(temp, (uint8*)&pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA7_INDEX], length);
;;;737    						break;
;;;738    
;;;739    					case 0x01:	// 加密，地址与数据均与【密钥】相亦或后使用
;;;740    						temp  = (pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA3_INDEX] ^ key);
;;;741    						temp <<= 8;
;;;742    						temp += (pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA4_INDEX] ^ key);
;;;743    						temp <<= 8;
;;;744    						temp += (pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA5_INDEX] ^ key);
;;;745    						temp <<= 8;
;;;746    						temp += (pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA6_INDEX] ^ key);
;;;747    
;;;748    						length = pCmdFrame->buff[IAP_CTRL_UART_CMD_LENGTH_INDEX] - 6;
;;;749    
;;;750    						for (i = 0; i < length; i++)
;;;751    						{
;;;752    							arrbuf[i] = pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA7_INDEX + i] ^ key;
;;;753    						}
;;;754    
;;;755    						// 写入数据
;;;756    						errStatus = IAP_WriteAppBin(temp, arrbuf, length);
;;;757    						break;
;;;758    
;;;759    					case 0x02:
;;;760    						errStatus = FALSE;
;;;761    						break;
;;;762    
;;;763    					default:
;;;764    						errStatus = FALSE;
;;;765    						break;
;;;766    				}
;;;767    
;;;768    				// 发送结果
;;;769    				IAP_CTRL_UART_SendCmdWithResult(IAP_CTRL_UART_CMD_UP_IAP_WRITE_FLASH_RESULT, errStatus);
;;;770    			}
;;;771    
;;;772    			break;
;;;773    
;;;774    		// 查空
;;;775    		case IAP_CTRL_UART_CMD_DOWN_CHECK_FALSH_BLANK:
;;;776    			errStatus = IAP_CheckApp2FlashIsBlank();
;;;777    
;;;778    			// 发送结果
;;;779    			IAP_CTRL_UART_SendCmdWithResult(IAP_CTRL_UART_CMD_UP_CHECK_FLASH_BLANK_RESULT, errStatus);
;;;780    			break;
;;;781    
;;;782    		// APP升级完成
;;;783    		case IAP_CTRL_UART_CMD_DOWN_UPDATA_FINISH:
;;;784    			// 串口升级完成需要擦除蓝牙升级标志，否则不会进入应用APP
;;;785    			// 清除蓝牙升级标志
;;;786    			SPI_FLASH_WriteByte(SPI_FLASH_BLE_UPDATA_FLAG_ADDEESS,0xFF);
;;;787    
;;;788    			// 串口升级完成提示
;;;789    			
;;;790    			
;;;791    			// 发送应答
;;;792    			IAP_CTRL_UART_SendCmdNoResult(IAP_CTRL_UART_CMD_UP_UPDATA_FINISH_RESULT);
;;;793    			break;
;;;794    
;;;795    
;;;796    		// 启动二维码注册
;;;797    		case IAP_CTRL_UART_CMD_DOWN_START_QR_REGISTER:
;;;798    			// 使能开始二维码注册
;;;799    			paramCB.runtime.qrRegEnable = TRUE;
;;;800    			
;;;801    			// 注册查询BLE的MAC地址
;;;802    			TIMER_AddTask(TIMER_ID_BLE_CONTROL,
;;;803    							200,
;;;804    							BLE_UART_CALLBALL_GetBleMacAddrRequest,
;;;805    							TRUE,
;;;806    							TIMER_LOOP_FOREVER,
;;;807    							ACTION_MODE_ADD_TO_QUEUE);
;;;808    
;;;809    			// 屏蔽ICCID注册定时器				
;;;810    			gsmUartCB.rcvIccidTimeOut = TRUE;
;;;811    			
;;;812    			/*
;;;813    			// 注册查询ICCID定时器
;;;814    			TIMER_AddTask(TIMER_ID_GSM_CONTROL,
;;;815    							GSM_UART_TX_QUERY_ICCID_TIME,
;;;816    							GSM_UART_CALLBALL_GetSimIccidRequest,
;;;817    							TRUE,
;;;818    							TIMER_LOOP_FOREVER,
;;;819    							ACTION_MODE_ADD_TO_QUEUE);
;;;820    			*/
;;;821    
;;;822    			// gsm模块开关机控制
;;;823    			GSM_UART_GsmPowerOnOff(TRUE);
;;;824    			break;
;;;825    
;;;826    		// 写入二维码数据
;;;827    		case IAP_CTRL_UART_CMD_DOWN_QR_DATA_WRITE:
;;;828    			// 将QR写入指定位置的EEPROM
;;;829    			//E2PROM_WriteByteArray(PARAM_NVM_QR_START_ADDR, (uint8*)&pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA1_INDEX], PARAM_NVM_QR_SIZE);
;;;830    
;;;831    			SPI_FLASH_WriteWithErase((uint8*)&pCmdFrame->buff[IAP_CTRL_UART_CMD_LENGTH_INDEX], SPI_FLASH_NEW_QR_CODE_ADDEESS, PARAM_NVM_QR_SIZE + 1);
;;;832    
;;;833    			// 读出来进行判断
;;;834    			SPI_FLASH_ReadArray(localBuf, SPI_FLASH_NEW_QR_CODE_ADDEESS, PARAM_NVM_QR_SIZE + 1);
;;;835    
;;;836    			// 比较写入的和读出来的是否一致
;;;837    			errStatus = PARAM_CmpareN((const uint8*)(uint8*)&pCmdFrame->buff[IAP_CTRL_UART_CMD_LENGTH_INDEX], (const uint8*)localBuf, PARAM_NVM_QR_SIZE + 1);
;;;838    			
;;;839    			// 发送结果
;;;840    			IAP_CTRL_UART_SendCmdWithResult(IAP_CTRL_UART_CMD_UP_QR_DATA_WRITE_RESULT, errStatus);
;;;841    			break;
;;;842    
;;;843    //==========================================================================
;;;844    //==========================================================================
;;;845    		// SPI 绝对地址擦除
;;;846    		case IAP_CTRL_UART_CMD_SPI_FLASH_ABSOLUTE_ERESE:
;;;847    			// 地址偏移字节数
;;;848    			temp = 0;
;;;849    			for (i = 0; i < 4; i++)
;;;850    			{
;;;851    				temp <<= 8;
;;;852    				temp |= pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA1_INDEX + i];
;;;853    			}
;;;854    			// 字节数
;;;855    			temp2 = 0;
;;;856    			for (i = 0; i < 4; i++)
;;;857    			{
;;;858    				temp2 <<= 8;
;;;859    				temp2 |= pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA5_INDEX + i];
;;;860    			}
;;;861    			
;;;862    			// 擦除指定空间数据
;;;863    			SPI_FLASH_EraseRoom(temp, temp2);
;;;864    				
;;;865    			IAP_CTRL_UART_SendCmdWithResult(IAP_CTRL_UART_CMD_SPI_FLASH_ABSOLUTE_ERESE, TRUE);
;;;866    			break;
;;;867    
;;;868    		// SPI 绝对地址写入
;;;869    		case IAP_CTRL_UART_CMD_SPI_FLASH_ABSOLUTE_WRITE:
;;;870    			// 地址偏移字节数
;;;871    			temp = 0;
;;;872    			for (i = 0; i < 4; i++)
;;;873    			{
;;;874    				temp <<= 8;
;;;875    				temp |= pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA1_INDEX + i];
;;;876    			}
;;;877    			
;;;878    			// 字节数
;;;879    			length = 0;
;;;880    			length = pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA5_INDEX];
;;;881    			
;;;882    			// 写入数据到flash里面
;;;883    			bTemp = SPI_FLASH_WriteWithCheck(&pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA6_INDEX], temp, length);		
;;;884    				
;;;885    			IAP_CTRL_UART_SendCmdWithResult(IAP_CTRL_UART_CMD_SPI_FLASH_ABSOLUTE_WRITE, bTemp);
;;;886    			break;
;;;887    
;;;888    		// SPI 绝对地址读取
;;;889    		case IAP_CTRL_UART_CMD_SPI_FLASH_ABSOLUTE_READ:
;;;890    			// 地址偏移字节数
;;;891    			temp = 0;
;;;892    			for (i = 0; i < 4; i++)
;;;893    			{
;;;894    				temp <<= 8;
;;;895    				temp |= pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA1_INDEX + i];
;;;896    			}
;;;897    			
;;;898    			// 字节数
;;;899    			length = 0;
;;;900    			length = pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA5_INDEX];
;;;901    			
;;;902    			// 从外部flash读取数据上报
;;;903    			IAP_CTRL_UART_SendSpiFlashData(temp, length);
;;;904    			break;
;;;905    
;;;906    		// SPI 绝对地址擦写
;;;907    		case IAP_CTRL_UART_CMD_SPI_FLASH_ABSOLUTE_ER_WR:
;;;908    			// 地址偏移字节数
;;;909    			temp = 0;
;;;910    			for (i = 0; i < 4; i++)
;;;911    			{
;;;912    				temp <<= 8;
;;;913    				temp |= pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA1_INDEX + i];
;;;914    			}
;;;915    			
;;;916    			// 字节数
;;;917    			length = 0;
;;;918    			length = pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA5_INDEX];
;;;919    			
;;;920    			// 写入数据到flash里面
;;;921    			SPI_FLASH_WriteWithErase(&pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA6_INDEX], temp, length);		
;;;922    				
;;;923    			IAP_CTRL_UART_SendCmdWithResult(IAP_CTRL_UART_CMD_SPI_FLASH_ABSOLUTE_ER_WR, TRUE);
;;;924    			break;
;;;925    			
;;;926    		// UI数据擦除
;;;927    		case IAP_CTRL_UART_CMD_SPI_FLASH_UI_ERESE:
;;;928    			// 擦除指定空间大小
;;;929    			SPI_FLASH_EraseRoom(SPI_FLASH_UI_OFFSET_ADDR, SPI_FLASH_UI_SIZE);
;;;930    				
;;;931    			IAP_CTRL_UART_SendCmdWithResult(IAP_CTRL_UART_CMD_SPI_FLASH_UI_ERESE, TRUE);
;;;932    			break;
;;;933    			
;;;934    		// UI数据写入
;;;935    		case IAP_CTRL_UART_CMD_SPI_FLASH_UI_WRITE:
;;;936    			// 地址偏移字节数
;;;937    			temp = 0;
;;;938    			for (i = 0; i < 4; i++)
;;;939    			{
;;;940    				temp <<= 8;
;;;941    				temp |= pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA1_INDEX + i];
;;;942    			}
;;;943    			// 字节数
;;;944    			length = pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA5_INDEX];
;;;945    			
;;;946    			// 写入数据到flash里面
;;;947    			bTemp = SPI_FLASH_WriteWithCheck(&pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA6_INDEX], (SPI_FLASH_UI_OFFSET_ADDR + temp), length);		
;;;948    				
;;;949    			IAP_CTRL_UART_SendCmdWithResult(IAP_CTRL_UART_CMD_SPI_FLASH_UI_WRITE, bTemp);
;;;950    			break;
;;;951    
;;;952    		// UI 写入完成
;;;953    		case IAP_CTRL_UART_CMD_SPI_FLASH_UI_FINISH:
;;;954    			IAP_CTRL_UART_SendCmdNoResult(IAP_CTRL_UART_CMD_SPI_FLASH_UI_FINISH);
;;;955    			break;
;;;956    
;;;957    		// 出厂APP数据擦除
;;;958    		case IAP_CTRL_UART_CMD_SPI_FLASH_APP_FACTORY_ERESE:
;;;959    			// 擦除出厂APP数据
;;;960    			SPI_FLASH_EraseRoom(SPI_FLASH_APP_FACTORY_OFFSET_ADDR, SPI_FLASH_APP_FACTORY_SIZE);
;;;961    				
;;;962    			IAP_CTRL_UART_SendCmdWithResult(IAP_CTRL_UART_CMD_SPI_FLASH_APP_FACTORY_ERESE, TRUE);
;;;963    			break;
;;;964    
;;;965    		// 出厂APP数据写入
;;;966    		case IAP_CTRL_UART_CMD_SPI_FLASH_APP_FACTORY_WRITE:
;;;967    			// 地址偏移字节数
;;;968    			temp = 0;
;;;969    			for (i = 0; i < 4; i++)
;;;970    			{
;;;971    				temp <<= 8;
;;;972    				temp |= pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA1_INDEX + i];
;;;973    			}
;;;974    			// 字节数
;;;975    			length = pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA5_INDEX];
;;;976    			
;;;977    			// 写入数据到flash里面
;;;978    			bTemp = SPI_FLASH_WriteWithCheck(&pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA6_INDEX], (SPI_FLASH_APP_FACTORY_OFFSET_ADDR + temp), length);				
;;;979    				
;;;980    			IAP_CTRL_UART_SendCmdWithResult(IAP_CTRL_UART_CMD_SPI_FLASH_APP_FACTORY_WRITE, bTemp);
;;;981    			break;
;;;982    
;;;983    		// 出厂APP数据写入完成
;;;984    		case IAP_CTRL_UART_CMD_SPI_FLASH_APP_FACTORY_FINISH:	
;;;985    			IAP_CTRL_UART_SendCmdNoResult(IAP_CTRL_UART_CMD_SPI_FLASH_APP_FACTORY_FINISH);
;;;986    			break;
;;;987    
;;;988    		// 升级APP数据擦除
;;;989    		case IAP_CTRL_UART_CMD_SPI_FLASH_APP_UPDATE_ERESE:
;;;990    			// 擦除文件系统
;;;991    			SPI_FLASH_EraseRoom(SPI_FLASH_APP_UPDATE_OFFSET_ADDR, SPI_FLASH_APP_UPDATE_SIZE);
;;;992    				
;;;993    			IAP_CTRL_UART_SendCmdWithResult(IAP_CTRL_UART_CMD_SPI_FLASH_APP_UPDATE_ERESE, TRUE);
;;;994    			break;
;;;995    
;;;996    		// 升级APP数据写入
;;;997    		case IAP_CTRL_UART_CMD_SPI_FLASH_APP_UPDATE_WRITE:
;;;998    			// 地址偏移字节数
;;;999    			temp = 0;
;;;1000   			for (i = 0; i < 4; i++)
;;;1001   			{
;;;1002   				temp <<= 8;
;;;1003   				temp |= pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA1_INDEX + i];
;;;1004   			}
;;;1005   			// 字节数
;;;1006   			length = pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA5_INDEX];
;;;1007   			
;;;1008   			// 写入数据到flash里面
;;;1009   			bTemp = SPI_FLASH_WriteWithCheck(&pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA6_INDEX], (SPI_FLASH_APP_UPDATE_OFFSET_ADDR + temp), length);		
;;;1010   				
;;;1011   			IAP_CTRL_UART_SendCmdWithResult(IAP_CTRL_UART_CMD_SPI_FLASH_APP_UPDATE_WRITE, bTemp);
;;;1012   			break;
;;;1013   
;;;1014   		// 升级APP数据写入完成
;;;1015   		case IAP_CTRL_UART_CMD_SPI_FLASH_APP_UPDATE_FINISH:	
;;;1016   			IAP_CTRL_UART_SendCmdNoResult(IAP_CTRL_UART_CMD_SPI_FLASH_APP_UPDATE_FINISH);
;;;1017   			break;
;;;1018   
;;;1019   		case IAP_CTRL_UART_CMD_SPI_FLASH_WRITE_SPI_TO_MCU:
;;;1020   			// 先擦除APP代码区
;;;1021   			IAP_EraseAPP2Area();
;;;1022   
;;;1023   #define WR_APP_BYTES_ONE_TIME		128	
;;;1024   			// APP数据写入
;;;1025   			updateBuff = (uint8 *)malloc(WR_APP_BYTES_ONE_TIME);
;;;1026   			if (NULL == updateBuff)
;;;1027   			{
;;;1028   				return;
;;;1029   			}
;;;1030   			
;;;1031   			if (1 == pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA1_INDEX])
;;;1032   			{
;;;1033   				temp = SPI_FLASH_APP_FACTORY_OFFSET_ADDR;
;;;1034   			}
;;;1035   			else if(2 == pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA1_INDEX])
;;;1036   			{
;;;1037   				temp = SPI_FLASH_APP_UPDATE_OFFSET_ADDR;
;;;1038   			}
;;;1039   			else
;;;1040   			{
;;;1041   				break;
;;;1042   			}
;;;1043   
;;;1044   			// 限于IAP_WriteAppBin()函数一次只能写252个数据，因此读取与写入只能小于等于252
;;;1045   			for (i = 0; i < SPI_FLASH_APP_UPDATE_SIZE/WR_APP_BYTES_ONE_TIME; i++)
;;;1046   			{
;;;1047   				SPI_FLASH_ReadArray(updateBuff, (temp + i * WR_APP_BYTES_ONE_TIME), WR_APP_BYTES_ONE_TIME);
;;;1048   				IAP_WriteAppBin((IAP_FLASH_APP2_ADDR + i * WR_APP_BYTES_ONE_TIME), updateBuff, WR_APP_BYTES_ONE_TIME);
;;;1049   			}
;;;1050   #undef WR_APP_BYTES_ONE_TIME
;;;1051   
;;;1052   			// 释放该内存
;;;1053   			free(updateBuff);
;;;1054   			
;;;1055   			// 升级完成延时回复后跳转
;;;1056   			TIMER_AddTask(TIMER_ID_ECO_JUMP,
;;;1057   							200,
;;;1058   							IAP_JumpToAppFun,
;;;1059   							IAP_FLASH_ADRESS_APP2_OFFSET,
;;;1060   							1,
;;;1061   							ACTION_MODE_ADD_TO_QUEUE);
;;;1062   
;;;1063   			IAP_CTRL_UART_SendCmdWithResult(IAP_CTRL_UART_CMD_SPI_FLASH_WRITE_SPI_TO_MCU, TRUE);
;;;1064   			break;
;;;1065   
;;;1066   		case IAP_CTRL_UART_CMD_JUMP_TO_BOOT:			
;;;1067   			TIMER_AddTask(TIMER_ID_ECO_JUMP,
;;;1068   							200,
;;;1069   							SYSTEM_Rst,
;;;1070   							temp,
;;;1071   							1,
;;;1072   							ACTION_MODE_ADD_TO_QUEUE);
;;;1073   							
;;;1074   			IAP_CTRL_UART_SendCmdWithResult(IAP_CTRL_UART_CMD_JUMP_TO_BOOT, TRUE);
;;;1075   			
;;;1076   			break;
;;;1077   			
;;;1078   		// 串口命令强制控制BOOT跳转到APP1
;;;1079   		case IAP_CTRL_UART_CMD_JUMP_TO_APP1:
;;;1080   			temp = IAP_FLASH_ADRESS_APP1_OFFSET;
;;;1081   			
;;;1082   			TIMER_AddTask(TIMER_ID_ECO_JUMP,
;;;1083   							200,
;;;1084   							IAP_JumpToAppFun,
;;;1085   							temp,
;;;1086   							1,
;;;1087   							ACTION_MODE_ADD_TO_QUEUE);
;;;1088   							
;;;1089   			IAP_CTRL_UART_SendCmdWithResult(IAP_CTRL_UART_CMD_JUMP_TO_APP1, IAP_CheckAppRightful(temp));
;;;1090   			break;
;;;1091   
;;;1092   		// 串口命令强制控制BOOT跳转到APP2
;;;1093   		case IAP_CTRL_UART_CMD_JUMP_TO_APP2:
;;;1094   			temp = IAP_FLASH_ADRESS_APP2_OFFSET;
;;;1095   			
;;;1096   			TIMER_AddTask(TIMER_ID_ECO_JUMP,
;;;1097   							200,
;;;1098   							IAP_JumpToAppFun,
;;;1099   							temp,
;;;1100   							1,
;;;1101   							ACTION_MODE_ADD_TO_QUEUE);
;;;1102   							
;;;1103   			IAP_CTRL_UART_SendCmdWithResult(IAP_CTRL_UART_CMD_JUMP_TO_APP2, IAP_CheckAppRightful(temp));
;;;1104   			break;
;;;1105   
;;;1106   		// 版本检测命令
;;;1107   		case IAP_CTRL_UART_CMD_CHECK_VERSION:
;;;1108   			if(IAP_CTRL_UART_CHECK_VERSION_ALL == pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA1_INDEX])
;;;1109   			{			
;;;1110   				checkFlag = 0;
;;;1111   				// 升级完成延时回复后跳转
;;;1112   				TIMER_AddTask(TIMER_ID_ECO_JUMP,
;;;1113   								200,
;;;1114   								checkVersion,
;;;1115   								0,
;;;1116   								8,
;;;1117   								ACTION_MODE_ADD_TO_QUEUE);
;;;1118   			}
;;;1119   			else
;;;1120   			{
;;;1121   				IAP_CTRL_UART_SendVersionCheck(pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA1_INDEX]);
;;;1122   			}							
;;;1123   			break;
;;;1124   
;;;1125   		case IAP_CTRL_UART_CMD_FLAG_ARRAY_READ:
;;;1126   			IAP_CTRL_UART_SendFlagCheck(1);
;;;1127   			break;
;;;1128   
;;;1129   		case IAP_CTRL_UART_CMD_FLAG_ARRAY_WRITE:
;;;1130   
;;;1131   			// 写入标志位置
;;;1132   			temp = pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA1_INDEX];
;;;1133   
;;;1134   			// 写入数据到spiflash
;;;1135   			SPI_FLASH_WriteWithErase(&pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA2_INDEX], SPI_FLASH_TEST_FLAG_ADDEESS + temp*4, 4);
;;;1136   
;;;1137   			// 更新标志
;;;1138   			PARAM_Init();
;;;1139   
;;;1140   			IAP_CTRL_UART_SendCmdWithResult(IAP_CTRL_UART_CMD_FLAG_ARRAY_WRITE, TRUE);
;;;1141   			break;
;;;1142   
;;;1143   		case IAP_CTRL_UART_CMD_VERSION_TYPE_WRITE:
;;;1144   			// 第一个写入类型
;;;1145   			temp = pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA1_INDEX];
;;;1146   			
;;;1147   			// 第二个为信息长度
;;;1148   			temp2 = pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA2_INDEX];
;;;1149   
;;;1150   			updateBuff = (uint8 *)malloc(128);
;;;1151   			if (NULL == updateBuff)
;;;1152   			{
;;;1153   				break;
;;;1154   			}
;;;1155   			
;;;1156   			// 清零
;;;1157   			for (i = 0; i < 128; i++)
;;;1158   			{
;;;1159   				updateBuff[i] = 0;
;;;1160   			}
;;;1161   			// 类型信息
;;;1162   			for (i = 0; i < temp2 + 1; i++)
;;;1163   			{
;;;1164   				updateBuff[i] = pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA1_INDEX+1+i];
;;;1165   			}
;;;1166   			
;;;1167   			// 判断类型种类是否合法
;;;1168   			if (16 >= temp)
;;;1169   			{
;;;1170   				SPI_FLASH_WriteWithErase(updateBuff, PARAM_MCU_VERSION_ADDRESS[temp], temp2+1);
;;;1171   				PARAM_Init();
;;;1172   
;;;1173   				bTemp = TRUE;
;;;1174   			}
;;;1175   			else
;;;1176   			{
;;;1177   				bTemp = FALSE;
;;;1178   			}
;;;1179   
;;;1180   			IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_HEAD);
;;;1181   			IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_VERSION_TYPE_WRITE);
;;;1182   			IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, 1);		// 数据长度
;;;1183   			IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, temp);	// 类型
;;;1184   			IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, bTemp);
;;;1185   			IAP_CTRL_UART_TxAddFrame(&iapCtrlUartCB);
;;;1186   			break;
;;;1187   
;;;1188   		case IAP_CTRL_UART_CMD_VERSION_TYPE_READ:
;;;1189   			temp = pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA1_INDEX];
;;;1190   			
;;;1191   			updateBuff = (uint8 *)malloc(128);
;;;1192   			if (NULL == updateBuff)
;;;1193   			{
;;;1194   				break;
;;;1195   			}
;;;1196   			// 清零
;;;1197   			for (i = 0; i < 128; i++)
;;;1198   			{
;;;1199   				updateBuff[i] = 0;
;;;1200   			}
;;;1201   
;;;1202   			// 读取数据
;;;1203   			SPI_FLASH_ReadArray(updateBuff, PARAM_MCU_VERSION_ADDRESS[temp], 64+1);
;;;1204   
;;;1205   			IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_HEAD);
;;;1206   			IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_VERSION_TYPE_READ);
;;;1207   			IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, 1);		// 数据长度
;;;1208   			IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, temp);	// 类型
;;;1209   
;;;1210   			// 根据类型有不同的长度
;;;1211   			switch (temp)
;;;1212   			{
;;;1213   				case 0:
;;;1214   				case 1:
;;;1215   				case 2:
;;;1216   				case 3:
;;;1217   				case 4:
;;;1218   				case 8:
;;;1219   					if ((updateBuff[0] > 0) && (updateBuff[0] <= 64))
;;;1220   					{
;;;1221   						// 信息长度
;;;1222   						IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, updateBuff[0]);
;;;1223   
;;;1224   						// 类型信息
;;;1225   						for (i = 0; i < updateBuff[0]; i++)
;;;1226   						{
;;;1227   							IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, updateBuff[i+1]);
;;;1228   						}
;;;1229   					}
;;;1230   					else
;;;1231   					{
;;;1232   						// 信息长度
;;;1233   						IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, 0);
;;;1234   					}
;;;1235   					break;
;;;1236   
;;;1237   				case 5:
;;;1238   				case 6:
;;;1239   					// 信息长度
;;;1240   					IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, 4);
;;;1241   					
;;;1242   					// 类型信息，高字节在前，低字节在后
;;;1243   					IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, updateBuff[1]);
;;;1244   					IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, updateBuff[2]);
;;;1245   					IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, updateBuff[3]);
;;;1246   					IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, updateBuff[4]);
;;;1247   					break;
;;;1248   					
;;;1249   				case 7:
;;;1250   					// 信息长度
;;;1251   					IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, 32);
;;;1252   
;;;1253   					// 类型信息
;;;1254   					for (i = 0; i < 32; i++)
;;;1255   					{
;;;1256   						IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, updateBuff[i+1]);
;;;1257   					}
;;;1258   					break;
;;;1259   
;;;1260   				default:
;;;1261   					IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, 0);
;;;1262   					break;
;;;1263   			}
;;;1264   			IAP_CTRL_UART_TxAddFrame(&iapCtrlUartCB);
;;;1265   
;;;1266   			free(updateBuff);
;;;1267   			break;
;;;1268   
;;;1269   		// 按键测试
;;;1270   		case IAP_CTRL_UART_CMD_KEY_TESTING:
;;;1271   		
;;;1272   			break;
;;;1273   
;;;1274   		// 显示测试
;;;1275   		case IAP_CTRL_UART_CMD_TEST_LCD:
;;;1276   			// 长度合法
;;;1277   			if (1 == pCmdFrame->buff[IAP_CTRL_UART_CMD_LENGTH_INDEX])
;;;1278   			{
;;;1279   				IAP_CTRL_UART_LcdControl(pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA1_INDEX]);
;;;1280   			}
;;;1281   			else
;;;1282   			{
;;;1283   				IAP_CTRL_UART_LcdControl(0);
;;;1284   			}
;;;1285   			IAP_CTRL_UART_SendCmdNoResult(IAP_CTRL_UART_CMD_TEST_LCD);
;;;1286   			break;
;;;1287   		
;;;1288   		default:
;;;1289   			break;
;;;1290   	}
;;;1291   	
;;;1292   	// 删除命令帧
;;;1293   	pCB->rx.head ++;
;;;1294   	pCB->rx.head %= IAP_CTRL_UART_RX_QUEUE_SIZE;
;;;1295   }
000044  b00f              ADD      sp,sp,#0x3c
000046  e8bd8ff0          POP      {r4-r11,pc}
                  |L2.74|
00004a  7861              LDRB     r1,[r4,#1]            ;435
00004c  2601              MOVS     r6,#1                 ;450
00004e  f8dfb494          LDR      r11,|L2.1252|
000052  f8df9494          LDR      r9,|L2.1256|
000056  f44f1740          MOV      r7,#0x300000          ;667
00005a  2970              CMP      r1,#0x70              ;438
00005c  d07e              BEQ      |L2.348|
00005e  dc2b              BGT      |L2.184|
000060  f8df8488          LDR      r8,|L2.1260|
000064  2924              CMP      r1,#0x24              ;438
000066  d07a              BEQ      |L2.350|
000068  dc11              BGT      |L2.142|
00006a  2908              CMP      r1,#8                 ;438
00006c  d066              BEQ      |L2.316|
00006e  dc05              BGT      |L2.124|
000070  2903              CMP      r1,#3                 ;438
                  |L2.114|
000072  d262              BCS      |L2.314|
000074  e8dff001          TBB      [pc,r1]               ;438
000078  6149b400          DCB      0x61,0x49,0xb4,0x00
                  |L2.124|
00007c  2910              CMP      r1,#0x10              ;438
00007e  d06f              BEQ      |L2.352|
000080  2911              CMP      r1,#0x11              ;438
000082  d06e              BEQ      |L2.354|
000084  2912              CMP      r1,#0x12              ;438
000086  d06d              BEQ      |L2.356|
000088  2914              CMP      r1,#0x14              ;438
                  |L2.138|
00008a  d156              BNE      |L2.314|
00008c  e189              B        |L2.930|
                  |L2.142|
00008e  2942              CMP      r1,#0x42              ;438
000090  d069              BEQ      |L2.358|
000092  dc08              BGT      |L2.166|
000094  2926              CMP      r1,#0x26              ;438
000096  d067              BEQ      |L2.360|
000098  2928              CMP      r1,#0x28              ;438
00009a  d066              BEQ      |L2.362|
00009c  292a              CMP      r1,#0x2a              ;438
00009e  d07d              BEQ      |L2.412|
0000a0  2940              CMP      r1,#0x40              ;438
0000a2  d1f2              BNE      |L2.138|
0000a4  e1fb              B        |L2.1182|
                  |L2.166|
0000a6  2960              CMP      r1,#0x60              ;438
0000a8  d079              BEQ      |L2.414|
0000aa  2961              CMP      r1,#0x61              ;438
0000ac  d078              BEQ      |L2.416|
0000ae  2962              CMP      r1,#0x62              ;438
0000b0  d077              BEQ      |L2.418|
0000b2  2963              CMP      r1,#0x63              ;438
0000b4  d1e9              BNE      |L2.138|
0000b6  e276              B        |L2.1446|
                  |L2.184|
0000b8  2980              CMP      r1,#0x80              ;438
0000ba  d073              BEQ      |L2.420|
0000bc  dc0e              BGT      |L2.220|
0000be  f1a10171          SUB      r1,r1,#0x71           ;438
0000c2  f44f2280          MOV      r2,#0x40000           ;960
0000c6  f44f1850          MOV      r8,#0x340000          ;991
0000ca  2909              CMP      r1,#9                 ;438
0000cc  d2d1              BCS      |L2.114|
0000ce  e8dff001          TBB      [pc,r1]               ;438
0000d2  fdfc              DCB      0xfd,0xfc
0000d4  fbfaf9f8          DCB      0xfb,0xfa,0xf9,0xf8
0000d8  f7f6f500          DCB      0xf7,0xf6,0xf5,0x00
                  |L2.220|
0000dc  2700              MOVS     r7,#0                 ;438
0000de  2992              CMP      r1,#0x92              ;438
0000e0  d078              BEQ      |L2.468|
0000e2  dc08              BGT      |L2.246|
0000e4  2981              CMP      r1,#0x81              ;438
0000e6  d076              BEQ      |L2.470|
0000e8  2982              CMP      r1,#0x82              ;438
0000ea  d075              BEQ      |L2.472|
0000ec  2990              CMP      r1,#0x90              ;438
0000ee  d074              BEQ      |L2.474|
0000f0  2991              CMP      r1,#0x91              ;438
0000f2  d1ca              BNE      |L2.138|
0000f4  e346              B        |L2.1924|
                  |L2.246|
0000f6  4efe              LDR      r6,|L2.1264|
0000f8  2993              CMP      r1,#0x93              ;438
0000fa  d06f              BEQ      |L2.476|
0000fc  2994              CMP      r1,#0x94              ;438
0000fe  d06e              BEQ      |L2.478|
000100  2995              CMP      r1,#0x95              ;438
000102  d01a              BEQ      |L2.314|
000104  2996              CMP      r1,#0x96              ;438
000106  d1c0              BNE      |L2.138|
000108  e3fd              B        |L2.2310|
00010a  2000              MOVS     r0,#0                 ;447
00010c  f7fffffe          BL       TIMER_KillTask
000110  9600              STR      r6,[sp,#0]            ;450
000112  464b              MOV      r3,r9                 ;450
000114  4af7              LDR      r2,|L2.1268|
000116  f44f71fa          MOV      r1,#0x1f4             ;450
00011a  2000              MOVS     r0,#0                 ;450
00011c  9601              STR      r6,[sp,#4]            ;450
00011e  f7fffffe          BL       TIMER_AddTask
000122  2001              MOVS     r0,#1                 ;457
000124  f7fffffe          BL       UART_PROTOCOL_SendMcuUid
000128  2004              MOVS     r0,#4                 ;460
00012a  e9cd0600          STRD     r0,r6,[sp,#0]         ;460
00012e  2301              MOVS     r3,#1                 ;460
000130  4af1              LDR      r2,|L2.1272|
000132  2132              MOVS     r1,#0x32              ;460
000134  2007              MOVS     r0,#7                 ;460
000136  f7fffffe          BL       TIMER_AddTask
                  |L2.314|
00013a  e3f9              B        |L2.2352|
                  |L2.316|
00013c  2002              MOVS     r0,#2                 ;474
00013e  f7fffffe          BL       TIMER_KillTask
000142  2007              MOVS     r0,#7                 ;475
000144  f7fffffe          BL       TIMER_KillTask
000148  78a0              LDRB     r0,[r4,#2]            ;478
00014a  280c              CMP      r0,#0xc               ;478
00014c  d1f5              BNE      |L2.314|
00014e  78e0              LDRB     r0,[r4,#3]            ;481
000150  79a1              LDRB     r1,[r4,#6]            ;481
000152  eb006001          ADD      r0,r0,r1,LSL #24      ;481
000156  7961              LDRB     r1,[r4,#5]            ;481
000158  0409              LSLS     r1,r1,#16             ;481
00015a  e007              B        |L2.364|
                  |L2.348|
00015c  e237              B        |L2.1486|
                  |L2.350|
00015e  e140              B        |L2.994|
                  |L2.352|
000160  e049              B        |L2.502|
                  |L2.354|
000162  e096              B        |L2.658|
                  |L2.356|
000164  e114              B        |L2.912|
                  |L2.358|
000166  e1ad              B        |L2.1220|
                  |L2.360|
000168  e144              B        |L2.1012|
                  |L2.362|
00016a  e188              B        |L2.1150|
                  |L2.364|
00016c  7922              LDRB     r2,[r4,#4]            ;481
00016e  eb012102          ADD      r1,r1,r2,LSL #8       ;481
000172  1842              ADDS     r2,r0,r1              ;481
000174  79e0              LDRB     r0,[r4,#7]            ;486
000176  7aa1              LDRB     r1,[r4,#0xa]          ;486
000178  7a23              LDRB     r3,[r4,#8]            ;486
00017a  eb006001          ADD      r0,r0,r1,LSL #24      ;486
00017e  7a61              LDRB     r1,[r4,#9]            ;486
000180  0409              LSLS     r1,r1,#16             ;486
000182  eb012103          ADD      r1,r1,r3,LSL #8       ;486
000186  4408              ADD      r0,r0,r1              ;486
000188  7ae1              LDRB     r1,[r4,#0xb]          ;491
00018a  7ba3              LDRB     r3,[r4,#0xe]          ;491
00018c  eb016103          ADD      r1,r1,r3,LSL #24      ;491
000190  7b63              LDRB     r3,[r4,#0xd]          ;491
000192  7b24              LDRB     r4,[r4,#0xc]          ;491
000194  041b              LSLS     r3,r3,#16             ;491
000196  eb032304          ADD      r3,r3,r4,LSL #8       ;491
00019a  e004              B        |L2.422|
                  |L2.412|
00019c  e176              B        |L2.1164|
                  |L2.414|
00019e  e1c6              B        |L2.1326|
                  |L2.416|
0001a0  e1e0              B        |L2.1380|
                  |L2.418|
0001a2  e1f3              B        |L2.1420|
                  |L2.420|
0001a4  e2ac              B        |L2.1792|
                  |L2.422|
0001a6  4419              ADD      r1,r1,r3              ;491
0001a8  4bd4              LDR      r3,|L2.1276|
0001aa  685c              LDR      r4,[r3,#4]            ;497  ; iapCB
0001ac  4294              CMP      r4,r2                 ;497
0001ae  d105              BNE      |L2.444|
0001b0  689a              LDR      r2,[r3,#8]            ;497  ; iapCB
0001b2  4282              CMP      r2,r0                 ;497
0001b4  d102              BNE      |L2.444|
0001b6  68d8              LDR      r0,[r3,#0xc]          ;497  ; iapCB
0001b8  4288              CMP      r0,r1                 ;497
0001ba  d0be              BEQ      |L2.314|
                  |L2.444|
0001bc  48d0              LDR      r0,|L2.1280|
0001be  49d1              LDR      r1,|L2.1284|
0001c0  f8d02760          LDR      r2,[r0,#0x760]        ;505  ; iapCtrlUartCB
0001c4  428a              CMP      r2,r1                 ;505
0001c6  d0b8              BEQ      |L2.314|
0001c8  f8c01760          STR      r1,[r0,#0x760]        ;508  ; iapCtrlUartCB
0001cc  4658              MOV      r0,r11                ;510
0001ce  f7fffffe          BL       SPI_FLASH_WriteWord
                  |L2.466|
0001d2  e3ad              B        |L2.2352|
                  |L2.468|
0001d4  e2da              B        |L2.1932|
                  |L2.470|
0001d6  e2a0              B        |L2.1818|
                  |L2.472|
0001d8  e2b1              B        |L2.1854|
                  |L2.474|
0001da  e2c2              B        |L2.1890|
                  |L2.476|
0001dc  e2e4              B        |L2.1960|
                  |L2.478|
0001de  e326              B        |L2.2094|
0001e0  2000              MOVS     r0,#0                 ;519
0001e2  f7fffffe          BL       TIMER_KillTask
0001e6  2002              MOVS     r0,#2                 ;520
0001e8  f7fffffe          BL       TIMER_KillTask
0001ec  2101              MOVS     r1,#1                 ;523
0001ee  2003              MOVS     r0,#3                 ;523
0001f0  f7fffffe          BL       IAP_CTRL_UART_SendCmdWithResult
0001f4  e39c              B        |L2.2352|
                  |L2.502|
0001f6  78e0              LDRB     r0,[r4,#3]            ;536
0001f8  2800              CMP      r0,#0                 ;536
0001fa  d19e              BNE      |L2.314|
0001fc  7920              LDRB     r0,[r4,#4]            ;539
0001fe  0201              LSLS     r1,r0,#8              ;540
000200  7960              LDRB     r0,[r4,#5]            ;541
000202  4308              ORRS     r0,r0,r1              ;541
000204  f8a80174          STRH     r0,[r8,#0x174]        ;542
000208  79a0              LDRB     r0,[r4,#6]            ;544
00020a  0201              LSLS     r1,r0,#8              ;545
00020c  79e0              LDRB     r0,[r4,#7]            ;546
00020e  4308              ORRS     r0,r0,r1              ;546
000210  f8a80176          STRH     r0,[r8,#0x176]        ;547
000214  7a20              LDRB     r0,[r4,#8]            ;550
000216  f8880178          STRB     r0,[r8,#0x178]        ;550
00021a  7a60              LDRB     r0,[r4,#9]            ;553
00021c  f8880179          STRB     r0,[r8,#0x179]        ;553
000220  7aa0              LDRB     r0,[r4,#0xa]          ;556
000222  f888017a          STRB     r0,[r8,#0x17a]        ;556
000226  7ae0              LDRB     r0,[r4,#0xb]          ;559
000228  f888017b          STRB     r0,[r8,#0x17b]        ;559
00022c  7b20              LDRB     r0,[r4,#0xc]          ;562
00022e  f888017c          STRB     r0,[r8,#0x17c]        ;562
000232  7b60              LDRB     r0,[r4,#0xd]          ;565
000234  f888017d          STRB     r0,[r8,#0x17d]        ;565
000238  7ba0              LDRB     r0,[r4,#0xe]          ;568
00023a  f888017e          STRB     r0,[r8,#0x17e]        ;568
00023e  7be0              LDRB     r0,[r4,#0xf]          ;571
000240  f888017f          STRB     r0,[r8,#0x17f]        ;571
000244  7c20              LDRB     r0,[r4,#0x10]         ;574
000246  f8880180          STRB     r0,[r8,#0x180]        ;574
00024a  7c60              LDRB     r0,[r4,#0x11]         ;577
00024c  f8880181          STRB     r0,[r8,#0x181]        ;577
000250  7ca0              LDRB     r0,[r4,#0x12]         ;580
000252  f8880182          STRB     r0,[r8,#0x182]        ;580
000256  7ce0              LDRB     r0,[r4,#0x13]         ;583
000258  f8880183          STRB     r0,[r8,#0x183]        ;583
00025c  2001              MOVS     r0,#1                 ;586
00025e  f7fffffe          BL       FACTORY_NVM_SetDirtyFlag
000262  2155              MOVS     r1,#0x55              ;589
000264  48a6              LDR      r0,|L2.1280|
000266  f7fffffe          BL       IAP_CTRL_UART_TxAddData
00026a  2110              MOVS     r1,#0x10              ;590
00026c  48a4              LDR      r0,|L2.1280|
00026e  f7fffffe          BL       IAP_CTRL_UART_TxAddData
000272  2102              MOVS     r1,#2                 ;591
000274  48a2              LDR      r0,|L2.1280|
000276  f7fffffe          BL       IAP_CTRL_UART_TxAddData
00027a  2100              MOVS     r1,#0                 ;592
00027c  48a0              LDR      r0,|L2.1280|
00027e  f7fffffe          BL       IAP_CTRL_UART_TxAddData
000282  2101              MOVS     r1,#1                 ;593
000284  489e              LDR      r0,|L2.1280|
000286  f7fffffe          BL       IAP_CTRL_UART_TxAddData
00028a  489d              LDR      r0,|L2.1280|
00028c  f7fffffe          BL       IAP_CTRL_UART_TxAddFrame
000290  e34e              B        |L2.2352|
                  |L2.658|
000292  78e0              LDRB     r0,[r4,#3]            ;603
000294  2800              CMP      r0,#0                 ;603
000296  d19c              BNE      |L2.466|
000298  4c9b              LDR      r4,|L2.1288|
00029a  2210              MOVS     r2,#0x10              ;607
00029c  4621              MOV      r1,r4                 ;607
00029e  489b              LDR      r0,|L2.1292|
0002a0  f7fffffe          BL       SPI_FLASH_ReadArray
0002a4  4899              LDR      r0,|L2.1292|
0002a6  2210              MOVS     r2,#0x10              ;608
0002a8  4621              MOV      r1,r4                 ;608
0002aa  3010              ADDS     r0,r0,#0x10           ;608
0002ac  f7fffffe          BL       SPI_FLASH_ReadArray
0002b0  2155              MOVS     r1,#0x55              ;610
0002b2  4893              LDR      r0,|L2.1280|
0002b4  f7fffffe          BL       IAP_CTRL_UART_TxAddData
0002b8  2111              MOVS     r1,#0x11              ;611
0002ba  e008              B        |L2.718|
0002bc  e1ec              B        |L2.1688|
0002be  e1e7              B        |L2.1680|
0002c0  e1d1              B        |L2.1638|
0002c2  e1c7              B        |L2.1620|
0002c4  e1c2              B        |L2.1612|
0002c6  e1ac              B        |L2.1570|
0002c8  e1a2              B        |L2.1552|
0002ca  e19d              B        |L2.1544|
0002cc  e188              B        |L2.1504|
                  |L2.718|
0002ce  488c              LDR      r0,|L2.1280|
0002d0  f7fffffe          BL       IAP_CTRL_UART_TxAddData
0002d4  2101              MOVS     r1,#1                 ;612
0002d6  488a              LDR      r0,|L2.1280|
0002d8  f7fffffe          BL       IAP_CTRL_UART_TxAddData
0002dc  2100              MOVS     r1,#0                 ;613
0002de  4888              LDR      r0,|L2.1280|
0002e0  f7fffffe          BL       IAP_CTRL_UART_TxAddData
0002e4  f8b80174          LDRH     r0,[r8,#0x174]        ;615  ; paramCB
0002e8  0a01              LSRS     r1,r0,#8              ;615
0002ea  4885              LDR      r0,|L2.1280|
0002ec  f7fffffe          BL       IAP_CTRL_UART_TxAddData
0002f0  f8981174          LDRB     r1,[r8,#0x174]        ;616  ; paramCB
0002f4  4882              LDR      r0,|L2.1280|
0002f6  f7fffffe          BL       IAP_CTRL_UART_TxAddData
0002fa  f8b80176          LDRH     r0,[r8,#0x176]        ;618  ; paramCB
0002fe  0a01              LSRS     r1,r0,#8              ;618
000300  487f              LDR      r0,|L2.1280|
000302  f7fffffe          BL       IAP_CTRL_UART_TxAddData
000306  f8981176          LDRB     r1,[r8,#0x176]        ;619  ; paramCB
00030a  487d              LDR      r0,|L2.1280|
00030c  f7fffffe          BL       IAP_CTRL_UART_TxAddData
000310  f8981178          LDRB     r1,[r8,#0x178]        ;621  ; paramCB
000314  487a              LDR      r0,|L2.1280|
000316  f7fffffe          BL       IAP_CTRL_UART_TxAddData
00031a  f8981179          LDRB     r1,[r8,#0x179]        ;623  ; paramCB
00031e  4878              LDR      r0,|L2.1280|
000320  f7fffffe          BL       IAP_CTRL_UART_TxAddData
000324  f898117a          LDRB     r1,[r8,#0x17a]        ;625  ; paramCB
000328  4875              LDR      r0,|L2.1280|
00032a  f7fffffe          BL       IAP_CTRL_UART_TxAddData
00032e  f898117b          LDRB     r1,[r8,#0x17b]        ;627  ; paramCB
000332  4873              LDR      r0,|L2.1280|
000334  f7fffffe          BL       IAP_CTRL_UART_TxAddData
000338  f898117c          LDRB     r1,[r8,#0x17c]        ;629  ; paramCB
00033c  4870              LDR      r0,|L2.1280|
00033e  f7fffffe          BL       IAP_CTRL_UART_TxAddData
000342  f898117d          LDRB     r1,[r8,#0x17d]        ;631  ; paramCB
000346  486e              LDR      r0,|L2.1280|
000348  f7fffffe          BL       IAP_CTRL_UART_TxAddData
00034c  f898117e          LDRB     r1,[r8,#0x17e]        ;633  ; paramCB
000350  486b              LDR      r0,|L2.1280|
000352  f7fffffe          BL       IAP_CTRL_UART_TxAddData
000356  f898117f          LDRB     r1,[r8,#0x17f]        ;635  ; paramCB
00035a  4869              LDR      r0,|L2.1280|
00035c  f7fffffe          BL       IAP_CTRL_UART_TxAddData
000360  f8981180          LDRB     r1,[r8,#0x180]        ;637  ; paramCB
000364  4866              LDR      r0,|L2.1280|
000366  f7fffffe          BL       IAP_CTRL_UART_TxAddData
00036a  f8981181          LDRB     r1,[r8,#0x181]        ;639  ; paramCB
00036e  4864              LDR      r0,|L2.1280|
000370  f7fffffe          BL       IAP_CTRL_UART_TxAddData
000374  f8981182          LDRB     r1,[r8,#0x182]        ;641  ; paramCB
000378  4861              LDR      r0,|L2.1280|
00037a  f7fffffe          BL       IAP_CTRL_UART_TxAddData
00037e  f8981183          LDRB     r1,[r8,#0x183]        ;643  ; paramCB
000382  485f              LDR      r0,|L2.1280|
000384  f7fffffe          BL       IAP_CTRL_UART_TxAddData
000388  485d              LDR      r0,|L2.1280|
00038a  f7fffffe          BL       IAP_CTRL_UART_TxAddFrame
00038e  e2cf              B        |L2.2352|
                  |L2.912|
000390  4639              MOV      r1,r7                 ;667
000392  2000              MOVS     r0,#0                 ;667
000394  f7fffffe          BL       SPI_FLASH_EraseRoom
000398  2101              MOVS     r1,#1                 ;671
00039a  2013              MOVS     r0,#0x13              ;671
00039c  f7fffffe          BL       IAP_CTRL_UART_SendCmdWithResult
0003a0  e2c6              B        |L2.2352|
                  |L2.930|
0003a2  4e5b              LDR      r6,|L2.1296|
0003a4  4630              MOV      r0,r6                 ;677
0003a6  f7fffffe          BL       spi_disable
0003aa  2100              MOVS     r1,#0                 ;678
0003ac  4608              MOV      r0,r1                 ;678
0003ae  f7fffffe          BL       SPIx_ConfigureWorkMode
0003b2  4630              MOV      r0,r6                 ;679
0003b4  f7fffffe          BL       spi_enable
0003b8  78e0              LDRB     r0,[r4,#3]            ;680
0003ba  0200              LSLS     r0,r0,#8              ;681
0003bc  7921              LDRB     r1,[r4,#4]            ;682
0003be  4408              ADD      r0,r0,r1              ;682
0003c0  0200              LSLS     r0,r0,#8              ;683
0003c2  7961              LDRB     r1,[r4,#5]            ;684
0003c4  4408              ADD      r0,r0,r1              ;684
0003c6  0200              LSLS     r0,r0,#8              ;685
0003c8  79a1              LDRB     r1,[r4,#6]            ;686
0003ca  4401              ADD      r1,r1,r0              ;686
0003cc  78a0              LDRB     r0,[r4,#2]            ;688
0003ce  1f00              SUBS     r0,r0,#4              ;688
0003d0  b282              UXTH     r2,r0                 ;688
0003d2  1de0              ADDS     r0,r4,#7              ;691
0003d4  f7fffffe          BL       SPI_FLASH_WriteWithCheck
0003d8  4601              MOV      r1,r0                 ;691
0003da  2015              MOVS     r0,#0x15              ;694
0003dc  f7fffffe          BL       IAP_CTRL_UART_SendCmdWithResult
0003e0  e2a6              B        |L2.2352|
                  |L2.994|
0003e2  f7fffffe          BL       IAP_EraseAPP1Area
0003e6  f7fffffe          BL       IAP_CheckApp1FlashIsBlank
0003ea  4601              MOV      r1,r0                 ;705
0003ec  2025              MOVS     r0,#0x25              ;708
0003ee  f7fffffe          BL       IAP_CTRL_UART_SendCmdWithResult
0003f2  e29d              B        |L2.2352|
                  |L2.1012|
0003f4  78e0              LDRB     r0,[r4,#3]            ;719
0003f6  7921              LDRB     r1,[r4,#4]            ;720
0003f8  b140              CBZ      r0,|L2.1036|
0003fa  2801              CMP      r0,#1                 ;722
0003fc  d019              BEQ      |L2.1074|
0003fe  2802              CMP      r0,#2                 ;722
000400  d03b              BEQ      |L2.1146|
000402  2100              MOVS     r1,#0                 ;764
                  |L2.1028|
000404  2027              MOVS     r0,#0x27              ;769
000406  f7fffffe          BL       IAP_CTRL_UART_SendCmdWithResult
00040a  e291              B        |L2.2352|
                  |L2.1036|
00040c  7960              LDRB     r0,[r4,#5]            ;725
00040e  0200              LSLS     r0,r0,#8              ;726
000410  79a1              LDRB     r1,[r4,#6]            ;727
000412  4408              ADD      r0,r0,r1              ;727
000414  0200              LSLS     r0,r0,#8              ;728
000416  79e1              LDRB     r1,[r4,#7]            ;729
000418  4408              ADD      r0,r0,r1              ;729
00041a  0200              LSLS     r0,r0,#8              ;730
00041c  7a21              LDRB     r1,[r4,#8]            ;731
00041e  4408              ADD      r0,r0,r1              ;731
000420  78a1              LDRB     r1,[r4,#2]            ;733
000422  1f89              SUBS     r1,r1,#6              ;733
000424  b28a              UXTH     r2,r1                 ;733
000426  f1040109          ADD      r1,r4,#9              ;736
00042a  f7fffffe          BL       IAP_WriteAppBin
00042e  4601              MOV      r1,r0                 ;736
000430  e7e8              B        |L2.1028|
                  |L2.1074|
000432  7960              LDRB     r0,[r4,#5]            ;740
000434  4048              EORS     r0,r0,r1              ;740
000436  0200              LSLS     r0,r0,#8              ;741
000438  79a2              LDRB     r2,[r4,#6]            ;742
00043a  404a              EORS     r2,r2,r1              ;742
00043c  4410              ADD      r0,r0,r2              ;742
00043e  0200              LSLS     r0,r0,#8              ;743
000440  79e2              LDRB     r2,[r4,#7]            ;744
000442  404a              EORS     r2,r2,r1              ;744
000444  4410              ADD      r0,r0,r2              ;744
000446  0200              LSLS     r0,r0,#8              ;745
000448  7a22              LDRB     r2,[r4,#8]            ;746
00044a  404a              EORS     r2,r2,r1              ;746
00044c  1817              ADDS     r7,r2,r0              ;746
00044e  78a0              LDRB     r0,[r4,#2]            ;748
000450  1f80              SUBS     r0,r0,#6              ;748
000452  b282              UXTH     r2,r0                 ;748
000454  2000              MOVS     r0,#0                 ;750
000456  4e2a              LDR      r6,|L2.1280|
000458  3ea0              SUBS     r6,r6,#0xa0           ;752
00045a  e005              B        |L2.1128|
                  |L2.1116|
00045c  1823              ADDS     r3,r4,r0              ;752
00045e  7a5b              LDRB     r3,[r3,#9]            ;752
000460  404b              EORS     r3,r3,r1              ;752
000462  5433              STRB     r3,[r6,r0]            ;752
000464  1c40              ADDS     r0,r0,#1              ;750
000466  b280              UXTH     r0,r0                 ;750
                  |L2.1128|
000468  4290              CMP      r0,r2                 ;750
00046a  d3f7              BCC      |L2.1116|
00046c  4924              LDR      r1,|L2.1280|
00046e  4638              MOV      r0,r7                 ;756
000470  39a0              SUBS     r1,r1,#0xa0           ;756
000472  f7fffffe          BL       IAP_WriteAppBin
000476  4601              MOV      r1,r0                 ;756
000478  e7c4              B        |L2.1028|
                  |L2.1146|
00047a  2100              MOVS     r1,#0                 ;760
00047c  e7c2              B        |L2.1028|
                  |L2.1150|
00047e  f7fffffe          BL       IAP_CheckApp2FlashIsBlank
000482  4601              MOV      r1,r0                 ;776
000484  2029              MOVS     r0,#0x29              ;779
000486  f7fffffe          BL       IAP_CTRL_UART_SendCmdWithResult
00048a  e251              B        |L2.2352|
                  |L2.1164|
00048c  4815              LDR      r0,|L2.1252|
00048e  21ff              MOVS     r1,#0xff              ;786
000490  3080              ADDS     r0,r0,#0x80           ;786
000492  f7fffffe          BL       SPI_FLASH_WriteByte
000496  202b              MOVS     r0,#0x2b              ;792
000498  f7fffffe          BL       IAP_CTRL_UART_SendCmdNoResult
00049c  e248              B        |L2.2352|
                  |L2.1182|
00049e  f8886168          STRB     r6,[r8,#0x168]        ;799
0004a2  f04f30ff          MOV      r0,#0xffffffff        ;802
0004a6  e9cd0600          STRD     r0,r6,[sp,#0]         ;802
0004aa  2301              MOVS     r3,#1                 ;802
0004ac  4a19              LDR      r2,|L2.1300|
0004ae  21c8              MOVS     r1,#0xc8              ;802
0004b0  2003              MOVS     r0,#3                 ;802
0004b2  f7fffffe          BL       TIMER_AddTask
0004b6  4818              LDR      r0,|L2.1304|
0004b8  f880604a          STRB     r6,[r0,#0x4a]         ;810
0004bc  2001              MOVS     r0,#1                 ;823
0004be  f7fffffe          BL       GSM_UART_GsmPowerOnOff
0004c2  e235              B        |L2.2352|
                  |L2.1220|
0004c4  4e15              LDR      r6,|L2.1308|
0004c6  2241              MOVS     r2,#0x41              ;831
0004c8  4631              MOV      r1,r6                 ;831
0004ca  1ca0              ADDS     r0,r4,#2              ;831
0004cc  f7fffffe          BL       SPI_FLASH_WriteWithErase
0004d0  2241              MOVS     r2,#0x41              ;834
0004d2  4631              MOV      r1,r6                 ;834
0004d4  a802              ADD      r0,sp,#8              ;834
0004d6  f7fffffe          BL       SPI_FLASH_ReadArray
0004da  2241              MOVS     r2,#0x41              ;837
0004dc  a902              ADD      r1,sp,#8              ;837
0004de  1ca0              ADDS     r0,r4,#2              ;837
0004e0  e01e              B        |L2.1312|
0004e2  0000              DCW      0x0000
                  |L2.1252|
                          DCD      0x003ff000
                  |L2.1256|
                          DCD      0x08010000
                  |L2.1260|
                          DCD      paramCB
                  |L2.1264|
                          DCD      PARAM_MCU_VERSION_ADDRESS
                  |L2.1268|
                          DCD      IAP_JumpToAppFun
                  |L2.1272|
                          DCD      UART_PROTOCOL_SendMcuUid
                  |L2.1276|
                          DCD      iapCB
                  |L2.1280|
                          DCD      ||.bss||+0xa0
                  |L2.1284|
                          DCD      0x55aa55bb
                  |L2.1288|
                          DCD      0x003fb000
                  |L2.1292|
                          DCD      paramCB+0x174
                  |L2.1296|
                          DCD      0x40003c00
                  |L2.1300|
                          DCD      BLE_UART_CALLBALL_GetBleMacAddrRequest
                  |L2.1304|
                          DCD      gsmUartCB
                  |L2.1308|
                          DCD      0x003fe100
                  |L2.1312|
000520  f7fffffe          BL       PARAM_CmpareN
000524  4601              MOV      r1,r0                 ;837
000526  2043              MOVS     r0,#0x43              ;840
000528  f7fffffe          BL       IAP_CTRL_UART_SendCmdWithResult
00052c  e200              B        |L2.2352|
                  |L2.1326|
00052e  2100              MOVS     r1,#0                 ;849
                  |L2.1328|
000530  0202              LSLS     r2,r0,#8              ;851
000532  1860              ADDS     r0,r4,r1              ;852
000534  78c0              LDRB     r0,[r0,#3]            ;852
000536  4310              ORRS     r0,r0,r2              ;852
000538  1c49              ADDS     r1,r1,#1              ;849
00053a  b289              UXTH     r1,r1                 ;849
00053c  2904              CMP      r1,#4                 ;849
00053e  d3f7              BCC      |L2.1328|
000540  2200              MOVS     r2,#0                 ;855
000542  2100              MOVS     r1,#0                 ;856
                  |L2.1348|
000544  0213              LSLS     r3,r2,#8              ;858
000546  1862              ADDS     r2,r4,r1              ;859
000548  79d2              LDRB     r2,[r2,#7]            ;859
00054a  431a              ORRS     r2,r2,r3              ;859
00054c  1c49              ADDS     r1,r1,#1              ;856
00054e  b289              UXTH     r1,r1                 ;856
000550  2904              CMP      r1,#4                 ;856
000552  d3f7              BCC      |L2.1348|
000554  4611              MOV      r1,r2                 ;863
000556  f7fffffe          BL       SPI_FLASH_EraseRoom
00055a  2101              MOVS     r1,#1                 ;865
00055c  2060              MOVS     r0,#0x60              ;865
00055e  f7fffffe          BL       IAP_CTRL_UART_SendCmdWithResult
000562  e1e5              B        |L2.2352|
                  |L2.1380|
000564  2100              MOVS     r1,#0                 ;872
                  |L2.1382|
000566  0202              LSLS     r2,r0,#8              ;874
000568  1860              ADDS     r0,r4,r1              ;875
00056a  78c0              LDRB     r0,[r0,#3]            ;875
00056c  4310              ORRS     r0,r0,r2              ;875
00056e  1c49              ADDS     r1,r1,#1              ;872
000570  b289              UXTH     r1,r1                 ;872
000572  2904              CMP      r1,#4                 ;872
000574  d3f7              BCC      |L2.1382|
000576  79e2              LDRB     r2,[r4,#7]            ;880
000578  4601              MOV      r1,r0                 ;883
00057a  f1040008          ADD      r0,r4,#8              ;883
00057e  f7fffffe          BL       SPI_FLASH_WriteWithCheck
000582  4601              MOV      r1,r0                 ;883
000584  2061              MOVS     r0,#0x61              ;885
000586  f7fffffe          BL       IAP_CTRL_UART_SendCmdWithResult
00058a  e1d1              B        |L2.2352|
                  |L2.1420|
00058c  2100              MOVS     r1,#0                 ;892
                  |L2.1422|
00058e  0202              LSLS     r2,r0,#8              ;894
000590  1860              ADDS     r0,r4,r1              ;895
000592  78c0              LDRB     r0,[r0,#3]            ;895
000594  4310              ORRS     r0,r0,r2              ;895
000596  1c49              ADDS     r1,r1,#1              ;892
000598  b289              UXTH     r1,r1                 ;892
00059a  2904              CMP      r1,#4                 ;892
00059c  d3f7              BCC      |L2.1422|
00059e  79e1              LDRB     r1,[r4,#7]            ;900
0005a0  f7fffffe          BL       IAP_CTRL_UART_SendSpiFlashData
0005a4  e1c4              B        |L2.2352|
                  |L2.1446|
0005a6  2100              MOVS     r1,#0                 ;910
                  |L2.1448|
0005a8  0202              LSLS     r2,r0,#8              ;912
0005aa  1860              ADDS     r0,r4,r1              ;913
0005ac  78c0              LDRB     r0,[r0,#3]            ;913
0005ae  4310              ORRS     r0,r0,r2              ;913
0005b0  1c49              ADDS     r1,r1,#1              ;910
0005b2  b289              UXTH     r1,r1                 ;910
0005b4  2904              CMP      r1,#4                 ;910
0005b6  d3f7              BCC      |L2.1448|
0005b8  79e2              LDRB     r2,[r4,#7]            ;918
0005ba  4601              MOV      r1,r0                 ;921
0005bc  f1040008          ADD      r0,r4,#8              ;921
0005c0  f7fffffe          BL       SPI_FLASH_WriteWithErase
0005c4  2101              MOVS     r1,#1                 ;923
0005c6  2063              MOVS     r0,#0x63              ;923
0005c8  f7fffffe          BL       IAP_CTRL_UART_SendCmdWithResult
                  |L2.1484|
0005cc  e1b0              B        |L2.2352|
                  |L2.1486|
0005ce  4639              MOV      r1,r7                 ;929
0005d0  2000              MOVS     r0,#0                 ;929
0005d2  f7fffffe          BL       SPI_FLASH_EraseRoom
0005d6  2101              MOVS     r1,#1                 ;931
0005d8  2070              MOVS     r0,#0x70              ;931
0005da  f7fffffe          BL       IAP_CTRL_UART_SendCmdWithResult
0005de  e1a7              B        |L2.2352|
                  |L2.1504|
0005e0  2100              MOVS     r1,#0                 ;938
                  |L2.1506|
0005e2  0202              LSLS     r2,r0,#8              ;940
0005e4  1860              ADDS     r0,r4,r1              ;941
0005e6  78c0              LDRB     r0,[r0,#3]            ;941
0005e8  4310              ORRS     r0,r0,r2              ;941
0005ea  1c49              ADDS     r1,r1,#1              ;938
0005ec  b289              UXTH     r1,r1                 ;938
0005ee  2904              CMP      r1,#4                 ;938
0005f0  d3f7              BCC      |L2.1506|
0005f2  79e2              LDRB     r2,[r4,#7]            ;944
0005f4  4601              MOV      r1,r0                 ;947
0005f6  f1040008          ADD      r0,r4,#8              ;947
0005fa  f7fffffe          BL       SPI_FLASH_WriteWithCheck
0005fe  4601              MOV      r1,r0                 ;947
000600  2071              MOVS     r0,#0x71              ;949
000602  f7fffffe          BL       IAP_CTRL_UART_SendCmdWithResult
000606  e193              B        |L2.2352|
                  |L2.1544|
000608  2072              MOVS     r0,#0x72              ;954
00060a  f7fffffe          BL       IAP_CTRL_UART_SendCmdNoResult
00060e  e18f              B        |L2.2352|
                  |L2.1552|
000610  4611              MOV      r1,r2                 ;960
000612  4638              MOV      r0,r7                 ;960
000614  f7fffffe          BL       SPI_FLASH_EraseRoom
000618  2101              MOVS     r1,#1                 ;962
00061a  2073              MOVS     r0,#0x73              ;962
00061c  f7fffffe          BL       IAP_CTRL_UART_SendCmdWithResult
000620  e186              B        |L2.2352|
                  |L2.1570|
000622  2100              MOVS     r1,#0                 ;969
                  |L2.1572|
000624  0202              LSLS     r2,r0,#8              ;971
000626  1860              ADDS     r0,r4,r1              ;972
000628  78c0              LDRB     r0,[r0,#3]            ;972
00062a  4310              ORRS     r0,r0,r2              ;972
00062c  1c49              ADDS     r1,r1,#1              ;969
00062e  b289              UXTH     r1,r1                 ;969
000630  2904              CMP      r1,#4                 ;969
000632  d3f7              BCC      |L2.1572|
000634  79e2              LDRB     r2,[r4,#7]            ;975
000636  f5001140          ADD      r1,r0,#0x300000       ;978
00063a  f1040008          ADD      r0,r4,#8              ;978
00063e  f7fffffe          BL       SPI_FLASH_WriteWithCheck
000642  4601              MOV      r1,r0                 ;978
000644  2074              MOVS     r0,#0x74              ;980
000646  f7fffffe          BL       IAP_CTRL_UART_SendCmdWithResult
00064a  e171              B        |L2.2352|
                  |L2.1612|
00064c  2075              MOVS     r0,#0x75              ;985
00064e  f7fffffe          BL       IAP_CTRL_UART_SendCmdNoResult
000652  e16d              B        |L2.2352|
                  |L2.1620|
000654  4611              MOV      r1,r2                 ;991
000656  4640              MOV      r0,r8                 ;991
000658  f7fffffe          BL       SPI_FLASH_EraseRoom
00065c  2101              MOVS     r1,#1                 ;993
00065e  2076              MOVS     r0,#0x76              ;993
000660  f7fffffe          BL       IAP_CTRL_UART_SendCmdWithResult
000664  e164              B        |L2.2352|
                  |L2.1638|
000666  2100              MOVS     r1,#0                 ;1000
                  |L2.1640|
000668  0202              LSLS     r2,r0,#8              ;1002
00066a  1860              ADDS     r0,r4,r1              ;1003
00066c  78c0              LDRB     r0,[r0,#3]            ;1003
00066e  4310              ORRS     r0,r0,r2              ;1003
000670  1c49              ADDS     r1,r1,#1              ;1000
000672  b289              UXTH     r1,r1                 ;1000
000674  2904              CMP      r1,#4                 ;1000
000676  d3f7              BCC      |L2.1640|
000678  79e2              LDRB     r2,[r4,#7]            ;1006
00067a  f5001150          ADD      r1,r0,#0x340000       ;1009
00067e  f1040008          ADD      r0,r4,#8              ;1009
000682  f7fffffe          BL       SPI_FLASH_WriteWithCheck
000686  4601              MOV      r1,r0                 ;1009
000688  2077              MOVS     r0,#0x77              ;1011
00068a  f7fffffe          BL       IAP_CTRL_UART_SendCmdWithResult
00068e  e14f              B        |L2.2352|
                  |L2.1680|
000690  2078              MOVS     r0,#0x78              ;1016
000692  f7fffffe          BL       IAP_CTRL_UART_SendCmdNoResult
000696  e14b              B        |L2.2352|
                  |L2.1688|
000698  f7fffffe          BL       IAP_EraseAPP2Area
00069c  2080              MOVS     r0,#0x80              ;1025
00069e  f7fffffe          BL       malloc
0006a2  4683              MOV      r11,r0                ;1025
0006a4  ea5f000b          MOVS     r0,r11                ;1026
0006a8  f43faccc          BEQ      |L2.68|
0006ac  78e0              LDRB     r0,[r4,#3]            ;1031
0006ae  2801              CMP      r0,#1                 ;1031
0006b0  d002              BEQ      |L2.1720|
0006b2  2802              CMP      r0,#2                 ;1035
0006b4  d18a              BNE      |L2.1484|
0006b6  4647              MOV      r7,r8                 ;1037
                  |L2.1720|
0006b8  2400              MOVS     r4,#0                 ;1045
0006ba  f44f6800          MOV      r8,#0x800             ;1045
                  |L2.1726|
0006be  eb0711c4          ADD      r1,r7,r4,LSL #7       ;1047
0006c2  2280              MOVS     r2,#0x80              ;1047
0006c4  4658              MOV      r0,r11                ;1047
0006c6  f7fffffe          BL       SPI_FLASH_ReadArray
0006ca  eb0910c4          ADD      r0,r9,r4,LSL #7       ;1048
0006ce  2280              MOVS     r2,#0x80              ;1048
0006d0  4659              MOV      r1,r11                ;1048
0006d2  f7fffffe          BL       IAP_WriteAppBin
0006d6  1c64              ADDS     r4,r4,#1              ;1045
0006d8  b2a4              UXTH     r4,r4                 ;1045
0006da  4544              CMP      r4,r8                 ;1045
0006dc  d3ef              BCC      |L2.1726|
0006de  4658              MOV      r0,r11                ;1053
0006e0  f7fffffe          BL       free
0006e4  9600              STR      r6,[sp,#0]            ;1056
0006e6  f44f3380          MOV      r3,#0x10000           ;1056
0006ea  4a9a              LDR      r2,|L2.2388|
0006ec  21c8              MOVS     r1,#0xc8              ;1056
0006ee  2006              MOVS     r0,#6                 ;1056
0006f0  9601              STR      r6,[sp,#4]            ;1056
0006f2  f7fffffe          BL       TIMER_AddTask
0006f6  2101              MOVS     r1,#1                 ;1063
0006f8  2079              MOVS     r0,#0x79              ;1063
0006fa  f7fffffe          BL       IAP_CTRL_UART_SendCmdWithResult
0006fe  e117              B        |L2.2352|
                  |L2.1792|
000700  4603              MOV      r3,r0                 ;1067
000702  9600              STR      r6,[sp,#0]            ;1067
000704  4a94              LDR      r2,|L2.2392|
000706  21c8              MOVS     r1,#0xc8              ;1067
000708  2006              MOVS     r0,#6                 ;1067
00070a  9601              STR      r6,[sp,#4]            ;1067
00070c  f7fffffe          BL       TIMER_AddTask
000710  2101              MOVS     r1,#1                 ;1074
000712  2080              MOVS     r0,#0x80              ;1074
000714  f7fffffe          BL       IAP_CTRL_UART_SendCmdWithResult
000718  e10a              B        |L2.2352|
                  |L2.1818|
00071a  f44f4400          MOV      r4,#0x8000            ;1080
00071e  9600              STR      r6,[sp,#0]            ;1082
000720  4623              MOV      r3,r4                 ;1082
000722  4a8c              LDR      r2,|L2.2388|
000724  21c8              MOVS     r1,#0xc8              ;1082
000726  2006              MOVS     r0,#6                 ;1082
000728  9601              STR      r6,[sp,#4]            ;1082
00072a  f7fffffe          BL       TIMER_AddTask
00072e  4620              MOV      r0,r4                 ;1089
000730  f7fffffe          BL       IAP_CheckAppRightful
000734  4601              MOV      r1,r0                 ;1089
000736  2081              MOVS     r0,#0x81              ;1089
000738  f7fffffe          BL       IAP_CTRL_UART_SendCmdWithResult
00073c  e0f8              B        |L2.2352|
                  |L2.1854|
00073e  f44f3480          MOV      r4,#0x10000           ;1094
000742  9600              STR      r6,[sp,#0]            ;1096
000744  4623              MOV      r3,r4                 ;1096
000746  4a83              LDR      r2,|L2.2388|
000748  21c8              MOVS     r1,#0xc8              ;1096
00074a  2006              MOVS     r0,#6                 ;1096
00074c  9601              STR      r6,[sp,#4]            ;1096
00074e  f7fffffe          BL       TIMER_AddTask
000752  4620              MOV      r0,r4                 ;1103
000754  f7fffffe          BL       IAP_CheckAppRightful
000758  4601              MOV      r1,r0                 ;1103
00075a  2082              MOVS     r0,#0x82              ;1103
00075c  f7fffffe          BL       IAP_CTRL_UART_SendCmdWithResult
000760  e0e6              B        |L2.2352|
                  |L2.1890|
000762  78e0              LDRB     r0,[r4,#3]            ;1108
000764  b110              CBZ      r0,|L2.1900|
000766  f7fffffe          BL       IAP_CTRL_UART_SendVersionCheck
00076a  e0e1              B        |L2.2352|
                  |L2.1900|
00076c  487b              LDR      r0,|L2.2396|
00076e  7007              STRB     r7,[r0,#0]            ;1110
000770  2008              MOVS     r0,#8                 ;1112
000772  e9cd0600          STRD     r0,r6,[sp,#0]         ;1112
000776  2300              MOVS     r3,#0                 ;1112
000778  4a79              LDR      r2,|L2.2400|
00077a  21c8              MOVS     r1,#0xc8              ;1112
00077c  2006              MOVS     r0,#6                 ;1112
00077e  f7fffffe          BL       TIMER_AddTask
000782  e0d5              B        |L2.2352|
                  |L2.1924|
000784  2001              MOVS     r0,#1                 ;1126
000786  f7fffffe          BL       IAP_CTRL_UART_SendFlagCheck
00078a  e0d1              B        |L2.2352|
                  |L2.1932|
00078c  78e0              LDRB     r0,[r4,#3]            ;1132
00078e  2204              MOVS     r2,#4                 ;1135
000790  eb0b0180          ADD      r1,r11,r0,LSL #2      ;1135
000794  1d20              ADDS     r0,r4,#4              ;1135
000796  f7fffffe          BL       SPI_FLASH_WriteWithErase
00079a  f7fffffe          BL       PARAM_Init
00079e  2101              MOVS     r1,#1                 ;1140
0007a0  2092              MOVS     r0,#0x92              ;1140
0007a2  f7fffffe          BL       IAP_CTRL_UART_SendCmdWithResult
0007a6  e0c3              B        |L2.2352|
                  |L2.1960|
0007a8  f8948003          LDRB     r8,[r4,#3]            ;1145
0007ac  f8949004          LDRB     r9,[r4,#4]            ;1148
0007b0  2080              MOVS     r0,#0x80              ;1150
0007b2  f7fffffe          BL       malloc
0007b6  4603              MOV      r3,r0                 ;1150
0007b8  0018              MOVS     r0,r3                 ;1151
0007ba  d037              BEQ      |L2.2092|
0007bc  2000              MOVS     r0,#0                 ;1157
                  |L2.1982|
0007be  541f              STRB     r7,[r3,r0]            ;1159
0007c0  1c40              ADDS     r0,r0,#1              ;1157
0007c2  b280              UXTH     r0,r0                 ;1157
0007c4  2880              CMP      r0,#0x80              ;1157
0007c6  d3fa              BCC      |L2.1982|
0007c8  2000              MOVS     r0,#0                 ;1162
0007ca  f1090901          ADD      r9,r9,#1              ;1162
0007ce  e004              B        |L2.2010|
                  |L2.2000|
0007d0  1821              ADDS     r1,r4,r0              ;1164
0007d2  7909              LDRB     r1,[r1,#4]            ;1164
0007d4  5419              STRB     r1,[r3,r0]            ;1164
0007d6  1c40              ADDS     r0,r0,#1              ;1162
0007d8  b280              UXTH     r0,r0                 ;1162
                  |L2.2010|
0007da  4548              CMP      r0,r9                 ;1162
0007dc  d3f8              BCC      |L2.2000|
0007de  f1b80f10          CMP      r8,#0x10              ;1168
0007e2  d80a              BHI      |L2.2042|
0007e4  fa1ff289          UXTH     r2,r9                 ;1170
0007e8  f8561028          LDR      r1,[r6,r8,LSL #2]     ;1170
0007ec  4618              MOV      r0,r3                 ;1170
0007ee  f7fffffe          BL       SPI_FLASH_WriteWithErase
0007f2  f7fffffe          BL       PARAM_Init
0007f6  2401              MOVS     r4,#1                 ;1173
0007f8  e000              B        |L2.2044|
                  |L2.2042|
0007fa  2400              MOVS     r4,#0                 ;1177
                  |L2.2044|
0007fc  2155              MOVS     r1,#0x55              ;1180
0007fe  4859              LDR      r0,|L2.2404|
000800  f7fffffe          BL       IAP_CTRL_UART_TxAddData
000804  2193              MOVS     r1,#0x93              ;1181
000806  4857              LDR      r0,|L2.2404|
000808  f7fffffe          BL       IAP_CTRL_UART_TxAddData
00080c  2101              MOVS     r1,#1                 ;1182
00080e  4855              LDR      r0,|L2.2404|
000810  f7fffffe          BL       IAP_CTRL_UART_TxAddData
000814  f00801ff          AND      r1,r8,#0xff           ;1183
000818  4852              LDR      r0,|L2.2404|
00081a  f7fffffe          BL       IAP_CTRL_UART_TxAddData
00081e  4621              MOV      r1,r4                 ;1184
000820  4850              LDR      r0,|L2.2404|
000822  f7fffffe          BL       IAP_CTRL_UART_TxAddData
000826  484f              LDR      r0,|L2.2404|
000828  f7fffffe          BL       IAP_CTRL_UART_TxAddFrame
                  |L2.2092|
00082c  e080              B        |L2.2352|
                  |L2.2094|
00082e  f8948003          LDRB     r8,[r4,#3]            ;1189
000832  2080              MOVS     r0,#0x80              ;1191
000834  f7fffffe          BL       malloc
000838  4604              MOV      r4,r0                 ;1191
00083a  0020              MOVS     r0,r4                 ;1192
00083c  d078              BEQ      |L2.2352|
00083e  2000              MOVS     r0,#0                 ;1197
                  |L2.2112|
000840  5427              STRB     r7,[r4,r0]            ;1199
000842  1c40              ADDS     r0,r0,#1              ;1197
000844  b280              UXTH     r0,r0                 ;1197
000846  2880              CMP      r0,#0x80              ;1197
000848  d3fa              BCC      |L2.2112|
00084a  f8561028          LDR      r1,[r6,r8,LSL #2]     ;1203
00084e  2241              MOVS     r2,#0x41              ;1203
000850  4620              MOV      r0,r4                 ;1203
000852  f7fffffe          BL       SPI_FLASH_ReadArray
000856  2155              MOVS     r1,#0x55              ;1205
000858  4842              LDR      r0,|L2.2404|
00085a  f7fffffe          BL       IAP_CTRL_UART_TxAddData
00085e  2194              MOVS     r1,#0x94              ;1206
000860  4840              LDR      r0,|L2.2404|
000862  f7fffffe          BL       IAP_CTRL_UART_TxAddData
000866  2101              MOVS     r1,#1                 ;1207
000868  483e              LDR      r0,|L2.2404|
00086a  f7fffffe          BL       IAP_CTRL_UART_TxAddData
00086e  f00801ff          AND      r1,r8,#0xff           ;1208
000872  483c              LDR      r0,|L2.2404|
000874  f7fffffe          BL       IAP_CTRL_UART_TxAddData
000878  f1b80f09          CMP      r8,#9                 ;1211
00087c  d244              BCS      |L2.2312|
00087e  e8dff008          TBB      [pc,r8]               ;1211
000882  0505              DCB      0x05,0x05
000884  0505051e          DCB      0x05,0x05,0x05,0x1e
000888  1e330500          DCB      0x1e,0x33,0x05,0x00
00088c  7821              LDRB     r1,[r4,#0]            ;1219
00088e  1e48              SUBS     r0,r1,#1              ;1219
000890  283f              CMP      r0,#0x3f              ;1219
000892  d80f              BHI      |L2.2228|
000894  4833              LDR      r0,|L2.2404|
000896  f7fffffe          BL       IAP_CTRL_UART_TxAddData
00089a  2600              MOVS     r6,#0                 ;1225
00089c  e006              B        |L2.2220|
                  |L2.2206|
00089e  19a0              ADDS     r0,r4,r6              ;1227
0008a0  7841              LDRB     r1,[r0,#1]            ;1227
0008a2  4830              LDR      r0,|L2.2404|
0008a4  f7fffffe          BL       IAP_CTRL_UART_TxAddData
0008a8  1c76              ADDS     r6,r6,#1              ;1225
0008aa  b2b6              UXTH     r6,r6                 ;1225
                  |L2.2220|
0008ac  7820              LDRB     r0,[r4,#0]            ;1225
0008ae  42b0              CMP      r0,r6                 ;1225
0008b0  d8f5              BHI      |L2.2206|
0008b2  e02d              B        |L2.2320|
                  |L2.2228|
0008b4  2100              MOVS     r1,#0                 ;1233
0008b6  482b              LDR      r0,|L2.2404|
0008b8  f7fffffe          BL       IAP_CTRL_UART_TxAddData
0008bc  e028              B        |L2.2320|
0008be  2104              MOVS     r1,#4                 ;1240
0008c0  4828              LDR      r0,|L2.2404|
0008c2  f7fffffe          BL       IAP_CTRL_UART_TxAddData
0008c6  7861              LDRB     r1,[r4,#1]            ;1243
0008c8  4826              LDR      r0,|L2.2404|
0008ca  f7fffffe          BL       IAP_CTRL_UART_TxAddData
0008ce  78a1              LDRB     r1,[r4,#2]            ;1244
0008d0  4824              LDR      r0,|L2.2404|
0008d2  f7fffffe          BL       IAP_CTRL_UART_TxAddData
0008d6  78e1              LDRB     r1,[r4,#3]            ;1245
0008d8  4822              LDR      r0,|L2.2404|
0008da  f7fffffe          BL       IAP_CTRL_UART_TxAddData
0008de  7921              LDRB     r1,[r4,#4]            ;1246
0008e0  4820              LDR      r0,|L2.2404|
0008e2  f7fffffe          BL       IAP_CTRL_UART_TxAddData
0008e6  e013              B        |L2.2320|
0008e8  2120              MOVS     r1,#0x20              ;1251
0008ea  481e              LDR      r0,|L2.2404|
0008ec  f7fffffe          BL       IAP_CTRL_UART_TxAddData
0008f0  2600              MOVS     r6,#0                 ;1254
                  |L2.2290|
0008f2  19a0              ADDS     r0,r4,r6              ;1256
0008f4  7841              LDRB     r1,[r0,#1]            ;1256
0008f6  481b              LDR      r0,|L2.2404|
0008f8  f7fffffe          BL       IAP_CTRL_UART_TxAddData
0008fc  1c76              ADDS     r6,r6,#1              ;1254
0008fe  b2b6              UXTH     r6,r6                 ;1254
000900  2e20              CMP      r6,#0x20              ;1254
000902  d3f6              BCC      |L2.2290|
000904  e004              B        |L2.2320|
                  |L2.2310|
000906  e00a              B        |L2.2334|
                  |L2.2312|
000908  2100              MOVS     r1,#0                 ;1261
00090a  4816              LDR      r0,|L2.2404|
00090c  f7fffffe          BL       IAP_CTRL_UART_TxAddData
                  |L2.2320|
000910  4814              LDR      r0,|L2.2404|
000912  f7fffffe          BL       IAP_CTRL_UART_TxAddFrame
000916  4620              MOV      r0,r4                 ;1266
000918  f7fffffe          BL       free
00091c  e008              B        |L2.2352|
                  |L2.2334|
00091e  78a0              LDRB     r0,[r4,#2]            ;1277
000920  2801              CMP      r0,#1                 ;1277
000922  d012              BEQ      |L2.2378|
000924  2000              MOVS     r0,#0                 ;1283
000926  f7fffffe          BL       IAP_CTRL_UART_LcdControl
                  |L2.2346|
00092a  2096              MOVS     r0,#0x96              ;1285
00092c  f7fffffe          BL       IAP_CTRL_UART_SendCmdNoResult
                  |L2.2352|
000930  f8b5042a          LDRH     r0,[r5,#0x42a]        ;1293
000934  1c40              ADDS     r0,r0,#1              ;1293
000936  b280              UXTH     r0,r0                 ;1293
000938  fbb0f1fa          UDIV     r1,r0,r10             ;1294
00093c  fb0a0011          MLS      r0,r10,r1,r0          ;1294
000940  f8a5042a          STRH     r0,[r5,#0x42a]        ;1294
000944  b00f              ADD      sp,sp,#0x3c           ;441
000946  e8bd8ff0          POP      {r4-r11,pc}
                  |L2.2378|
00094a  78e0              LDRB     r0,[r4,#3]            ;1279
00094c  f7fffffe          BL       IAP_CTRL_UART_LcdControl
000950  e7eb              B        |L2.2346|
;;;1296   
                          ENDP

000952  0000              DCW      0x0000
                  |L2.2388|
                          DCD      IAP_JumpToAppFun
                  |L2.2392|
                          DCD      SYSTEM_Rst
                  |L2.2396|
                          DCD      ||.data||
                  |L2.2400|
                          DCD      checkVersion
                  |L2.2404|
                          DCD      ||.bss||+0xa0

                          AREA ||i.IAP_CTRL_UART_ConfirmTempCmdFrameBuff||, CODE, READONLY, ALIGN=1

                  IAP_CTRL_UART_ConfirmTempCmdFrameBuff PROC
;;;178    // 将临时缓冲区添加到命令帧缓冲区中，其本质操作是承认临时缓冲区数据有效
;;;179    BOOL IAP_CTRL_UART_ConfirmTempCmdFrameBuff(IAP_CTRL_UART_CB* pCB)
000000  2800              CMP      r0,#0
;;;180    {
000002  d01e              BEQ      |L3.66|
;;;181    	IAP_CTRL_CMD_FRAME* pCmdFrame = NULL;
;;;182    	
;;;183    	// 参数合法性检验
;;;184    	if(NULL == pCB)
;;;185    	{
;;;186    		return FALSE;
;;;187    	}
;;;188    
;;;189    	// 临时缓冲区为空，不予添加
;;;190    	pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.end];
000004  f8b0142c          LDRH     r1,[r0,#0x42c]
000008  eb011201          ADD      r2,r1,r1,LSL #4
00000c  eb021281          ADD      r2,r2,r1,LSL #6
000010  eb000242          ADD      r2,r0,r2,LSL #1
;;;191    	if(0 == pCmdFrame->length)
000014  f8b221a0          LDRH     r2,[r2,#0x1a0]
000018  b1aa              CBZ      r2,|L3.70|
;;;192    	{
;;;193    		return FALSE;
;;;194    	}
;;;195    
;;;196    	// 添加
;;;197    	pCB->rx.end ++;
00001a  1c49              ADDS     r1,r1,#1
00001c  b289              UXTH     r1,r1
;;;198    	pCB->rx.end %= IAP_CTRL_UART_RX_QUEUE_SIZE;
00001e  2205              MOVS     r2,#5
000020  fbb1f3f2          UDIV     r3,r1,r2
000024  fb021113          MLS      r1,r2,r3,r1
000028  f8a0142c          STRH     r1,[r0,#0x42c]
;;;199    	pCB->rx.cmdQueue[pCB->rx.end].length = 0;	// 该行的作用是将新的添加位置有效数据个数清零，以便将这个位置当做临时帧缓冲区
00002c  eb011301          ADD      r3,r1,r1,LSL #4
000030  eb031181          ADD      r1,r3,r1,LSL #6
000034  eb000041          ADD      r0,r0,r1,LSL #1
000038  2200              MOVS     r2,#0
00003a  f8a021a0          STRH     r2,[r0,#0x1a0]
;;;200    	
;;;201    	return TRUE;
00003e  2001              MOVS     r0,#1
;;;202    }
000040  4770              BX       lr
                  |L3.66|
000042  2000              MOVS     r0,#0                 ;186
000044  4770              BX       lr
                  |L3.70|
000046  2000              MOVS     r0,#0                 ;193
000048  4770              BX       lr
;;;203    
                          ENDP


                          AREA ||i.IAP_CTRL_UART_DataStructureInit||, CODE, READONLY, ALIGN=1

                  IAP_CTRL_UART_DataStructureInit PROC
;;;111    // 数据结构初始化
;;;112    void IAP_CTRL_UART_DataStructureInit(IAP_CTRL_UART_CB* pCB)
000000  2800              CMP      r0,#0
;;;113    {
000002  d02b              BEQ      |L4.92|
;;;114    	uint8 i;
;;;115    	
;;;116    	// 参数合法性检验
;;;117    	if(NULL == pCB)
;;;118    	{
;;;119    		return;
;;;120    	}
;;;121    
;;;122    	pCB->tx.txBusy = FALSE;
000004  2200              MOVS     r2,#0
000006  f880275e          STRB     r2,[r0,#0x75e]
;;;123    	pCB->tx.index = 0;
00000a  f8a0275c          STRH     r2,[r0,#0x75c]
;;;124    	pCB->tx.head = 0;
00000e  f8a02758          STRH     r2,[r0,#0x758]
;;;125    	pCB->tx.end = 0;
000012  f8a0275a          STRH     r2,[r0,#0x75a]
;;;126    	for(i=0; i<IAP_CTRL_UART_TX_QUEUE_SIZE; i++)
000016  2100              MOVS     r1,#0
                  |L4.24|
;;;127    	{
;;;128    		pCB->tx.cmdQueue[i].length = 0;
000018  eb011301          ADD      r3,r1,r1,LSL #4
00001c  eb031381          ADD      r3,r3,r1,LSL #6
000020  eb000343          ADD      r3,r0,r3,LSL #1
000024  f8a324ce          STRH     r2,[r3,#0x4ce]
000028  1c49              ADDS     r1,r1,#1              ;126
00002a  b2c9              UXTB     r1,r1                 ;126
00002c  2905              CMP      r1,#5                 ;126
00002e  d3f3              BCC      |L4.24|
;;;129    	}
;;;130    	
;;;131    	pCB->rxFIFO.head = 0;
000030  f8202ffa          STRH     r2,[r0,#0xfa]!
;;;132    	pCB->rxFIFO.currentProcessIndex = 0;
000034  8082              STRH     r2,[r0,#4]
;;;133    	pCB->rxFIFO.end  = 0;
000036  8042              STRH     r2,[r0,#2]
;;;134    
;;;135    	pCB->rx.head = 0;
000038  f8a02330          STRH     r2,[r0,#0x330]
;;;136    	pCB->rx.end  = 0;
00003c  f8a02332          STRH     r2,[r0,#0x332]
000040  38fa              SUBS     r0,r0,#0xfa
;;;137    	for(i=0; i<IAP_CTRL_UART_RX_QUEUE_SIZE; i++)
000042  2100              MOVS     r1,#0
                  |L4.68|
;;;138    	{
;;;139    		pCB->rx.cmdQueue[i].length = 0;
000044  eb011301          ADD      r3,r1,r1,LSL #4
000048  eb031381          ADD      r3,r3,r1,LSL #6
00004c  eb000343          ADD      r3,r0,r3,LSL #1
000050  f8a321a0          STRH     r2,[r3,#0x1a0]
000054  1c49              ADDS     r1,r1,#1              ;137
000056  b2c9              UXTB     r1,r1                 ;137
000058  2905              CMP      r1,#5                 ;137
00005a  d3f3              BCC      |L4.68|
                  |L4.92|
;;;140    	}
;;;141    }
00005c  4770              BX       lr
;;;142    
                          ENDP


                          AREA ||i.IAP_CTRL_UART_HwInit||, CODE, READONLY, ALIGN=2

                  IAP_CTRL_UART_HwInit PROC
;;;143    // UART初始化
;;;144    void IAP_CTRL_UART_HwInit(uint32 baud)
000000  b570              PUSH     {r4-r6,lr}
;;;145    {
000002  4605              MOV      r5,r0
;;;146    	// GD32
;;;147    	// 时钟配置
;;;148    	rcu_periph_clock_enable(RCU_GPIOA);
000004  f2406002          MOV      r0,#0x602
000008  f7fffffe          BL       rcu_periph_clock_enable
;;;149    	
;;;150    	// GPIO配置
;;;151    	gpio_init(GPIOA, GPIO_MODE_AF_PP, GPIO_OSPEED_10MHZ, GPIO_PIN_2);   //复用推挽
00000c  4c21              LDR      r4,|L5.148|
00000e  2304              MOVS     r3,#4
000010  2201              MOVS     r2,#1
000012  2118              MOVS     r1,#0x18
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       gpio_init
;;;152    
;;;153    	gpio_init(GPIOA, GPIO_MODE_IPU, GPIO_OSPEED_10MHZ, GPIO_PIN_3); 	// 上拉输入
00001a  2308              MOVS     r3,#8
00001c  2201              MOVS     r2,#1
00001e  2148              MOVS     r1,#0x48
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       gpio_init
;;;154    	
;;;155    	// UART时钟配置
;;;156    	rcu_periph_clock_enable(RCU_USART1);								// 时能USART时钟
000026  f2407011          MOV      r0,#0x711
00002a  f7fffffe          BL       rcu_periph_clock_enable
;;;157    	usart_deinit(IAP_CTRL_UART_TYPE_DEF);									// 复位串口
00002e  4c1a              LDR      r4,|L5.152|
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       usart_deinit
;;;158    
;;;159    	// 串口配置
;;;160    	usart_baudrate_set(IAP_CTRL_UART_TYPE_DEF, baud);						// 波特率
000036  4629              MOV      r1,r5
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       usart_baudrate_set
;;;161    	usart_word_length_set(IAP_CTRL_UART_TYPE_DEF, USART_WL_8BIT);			// 8位数据位
00003e  2100              MOVS     r1,#0
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       usart_word_length_set
;;;162    	usart_stop_bit_set(IAP_CTRL_UART_TYPE_DEF, USART_STB_1BIT);			// 一个停止位
000046  2100              MOVS     r1,#0
000048  4620              MOV      r0,r4
00004a  f7fffffe          BL       usart_stop_bit_set
;;;163    	usart_parity_config(IAP_CTRL_UART_TYPE_DEF, USART_PM_NONE);			// 无奇偶校验
00004e  2100              MOVS     r1,#0
000050  4620              MOV      r0,r4
000052  f7fffffe          BL       usart_parity_config
;;;164    	usart_hardware_flow_rts_config(IAP_CTRL_UART_TYPE_DEF, USART_RTS_DISABLE); // 无硬件数据流控制
000056  2100              MOVS     r1,#0
000058  4620              MOV      r0,r4
00005a  f7fffffe          BL       usart_hardware_flow_rts_config
;;;165    	usart_hardware_flow_cts_config(IAP_CTRL_UART_TYPE_DEF, USART_CTS_DISABLE);
00005e  2100              MOVS     r1,#0
000060  4620              MOV      r0,r4
000062  f7fffffe          BL       usart_hardware_flow_cts_config
;;;166    	usart_transmit_config(IAP_CTRL_UART_TYPE_DEF, USART_TRANSMIT_ENABLE);	// 使能发射
000066  2108              MOVS     r1,#8
000068  4620              MOV      r0,r4
00006a  f7fffffe          BL       usart_transmit_config
;;;167    	usart_receive_config(IAP_CTRL_UART_TYPE_DEF, USART_RECEIVE_ENABLE);		// 使能接收
00006e  2104              MOVS     r1,#4
000070  4620              MOV      r0,r4
000072  f7fffffe          BL       usart_receive_config
;;;168    
;;;169    	// 中断配置
;;;170    	nvic_irq_enable(IAP_CTRL_UART_IRQn_DEF, 2, 1);
000076  2201              MOVS     r2,#1
000078  2102              MOVS     r1,#2
00007a  2026              MOVS     r0,#0x26
00007c  f7fffffe          BL       nvic_irq_enable
;;;171    
;;;172    	usart_interrupt_enable(IAP_CTRL_UART_TYPE_DEF, USART_INT_RBNE);			// 开启中断
000080  f2403105          MOV      r1,#0x305
000084  4620              MOV      r0,r4
000086  f7fffffe          BL       usart_interrupt_enable
;;;173    
;;;174    	usart_enable(IAP_CTRL_UART_TYPE_DEF);									// 使能串口 
00008a  4620              MOV      r0,r4
00008c  e8bd4070          POP      {r4-r6,lr}
000090  f7ffbffe          B.W      usart_enable
;;;175    
;;;176    }
;;;177    
                          ENDP

                  |L5.148|
                          DCD      0x40010800
                  |L5.152|
                          DCD      0x40004400

                          AREA ||i.IAP_CTRL_UART_IR_StartSendData||, CODE, READONLY, ALIGN=2

                  IAP_CTRL_UART_IR_StartSendData PROC
;;;1523   // 启动中断字节发送
;;;1524   void IAP_CTRL_UART_IR_StartSendData(uint8 data)
000000  b570              PUSH     {r4-r6,lr}
;;;1525   {
000002  4605              MOV      r5,r0
;;;1526   	// 先读SR，再填充DR会把TC标志清掉
;;;1527   	usart_flag_get(IAP_CTRL_UART_TYPE_DEF, USART_FLAG_TC);
000004  4c07              LDR      r4,|L6.36|
000006  2106              MOVS     r1,#6
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       usart_flag_get
;;;1528   
;;;1529   	// 发送一个字节
;;;1530   	usart_data_transmit(IAP_CTRL_UART_TYPE_DEF, data);
00000e  4629              MOV      r1,r5
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       usart_data_transmit
;;;1531   
;;;1532   	// 打开发送完成中断
;;;1533   	usart_interrupt_enable(IAP_CTRL_UART_TYPE_DEF, USART_INT_TC);	
000016  4620              MOV      r0,r4
000018  e8bd4070          POP      {r4-r6,lr}
00001c  f2403106          MOV      r1,#0x306
000020  f7ffbffe          B.W      usart_interrupt_enable
;;;1534   }
;;;1535   
                          ENDP

                  |L6.36|
                          DCD      0x40004400

                          AREA ||i.IAP_CTRL_UART_Init||, CODE, READONLY, ALIGN=2

                  IAP_CTRL_UART_Init PROC
;;;101    // UART初始化
;;;102    void IAP_CTRL_UART_Init(void)
000000  b510              PUSH     {r4,lr}
;;;103    {	
;;;104    	// 硬件UART配置
;;;105    	IAP_CTRL_UART_HwInit(IAP_CTRL_UART_BAUD_RATE);
000002  f44f30e1          MOV      r0,#0x1c200
000006  f7fffffe          BL       IAP_CTRL_UART_HwInit
;;;106    
;;;107    	// UART数据结构初始化
;;;108    	IAP_CTRL_UART_DataStructureInit(&iapCtrlUartCB);
00000a  e8bd4010          POP      {r4,lr}
00000e  4801              LDR      r0,|L7.20|
000010  f7ffbffe          B.W      IAP_CTRL_UART_DataStructureInit
;;;109    }
;;;110    
                          ENDP

                  |L7.20|
                          DCD      ||.bss||+0xa0

                          AREA ||i.IAP_CTRL_UART_LcdControl||, CODE, READONLY, ALIGN=2

                  IAP_CTRL_UART_LcdControl PROC
;;;1300   // 串口显示控制
;;;1301   uint8 IAP_CTRL_UART_LcdControl(uint8 lcdCmd)
000000  b510              PUSH     {r4,lr}
;;;1302   {
000002  4602              MOV      r2,r0
;;;1303   	switch (lcdCmd)
;;;1304   	{
;;;1305   		case 0:
;;;1306   			gpio_bit_set(GPIOA, GPIO_PIN_8);
000004  480a              LDR      r0,|L8.48|
000006  f44f7180          MOV      r1,#0x100
00000a  2a08              CMP      r2,#8                 ;1303
00000c  d20d              BCS      |L8.42|
00000e  e8dff002          TBB      [pc,r2]               ;1303
000012  0407              DCB      0x04,0x07
000014  07070707          DCB      0x07,0x07,0x07,0x07
000018  070a              DCB      0x07,0x0a
00001a  f7fffffe          BL       gpio_bit_set
;;;1307   			//LCD_FillColor(LCD_COLOR_RED);
;;;1308   			
;;;1309   			break;
00001e  e004              B        |L8.42|
;;;1310   
;;;1311   		case 1:
;;;1312   		case 2:
;;;1313   		case 3:
;;;1314   		case 4:
;;;1315   		case 5:
;;;1316   		case 6:
;;;1317   			gpio_bit_set(GPIOA, GPIO_PIN_8);
000020  f7fffffe          BL       gpio_bit_set
;;;1318   		
;;;1319   			break;
000024  e001              B        |L8.42|
;;;1320   
;;;1321   		case 7:
;;;1322   			gpio_bit_reset(GPIOA, GPIO_PIN_8);
000026  f7fffffe          BL       gpio_bit_reset
                  |L8.42|
;;;1323   			break;
;;;1324   
;;;1325   		default:		
;;;1326   			break;
;;;1327   	}
;;;1328   	return 0;
00002a  2000              MOVS     r0,#0
;;;1329   }
00002c  bd10              POP      {r4,pc}
;;;1330   			
                          ENDP

00002e  0000              DCW      0x0000
                  |L8.48|
                          DCD      0x40010800

                          AREA ||i.IAP_CTRL_UART_Process||, CODE, READONLY, ALIGN=2

                  IAP_CTRL_UART_Process PROC
;;;1412   // UART模块处理入口
;;;1413   void IAP_CTRL_UART_Process(void)
000000  b510              PUSH     {r4,lr}
;;;1414   {
;;;1415   	// 内部通讯接口的一级接收缓冲区处理
;;;1416   	IAP_CTRL_UART_RxFIFOProcess(&iapCtrlUartCB);
000002  4805              LDR      r0,|L9.24|
000004  f7fffffe          BL       IAP_CTRL_UART_RxFIFOProcess
;;;1417   
;;;1418   	// 内部通讯接口的命令帧缓冲区处理
;;;1419   	IAP_CTRL_UART_CmdFrameProcess(&iapCtrlUartCB);
000008  4803              LDR      r0,|L9.24|
00000a  f7fffffe          BL       IAP_CTRL_UART_CmdFrameProcess
;;;1420   	
;;;1421   	//中断发送方式
;;;1422   #if (IAP_CTRL_UART_TX_MODE == IAP_CTRL_INTERRUPT_TX_MODE)
;;;1423   	// 内部通讯接口的发送处理
;;;1424   	IAP_CTRL_UART_TxProcess(&iapCtrlUartCB);
00000e  e8bd4010          POP      {r4,lr}
000012  4801              LDR      r0,|L9.24|
000014  f7ffbffe          B.W      IAP_CTRL_UART_TxProcess
;;;1425   #endif
;;;1426   
;;;1427   }
;;;1428   
                          ENDP

                  |L9.24|
                          DCD      ||.bss||+0xa0

                          AREA ||i.IAP_CTRL_UART_RxFIFOProcess||, CODE, READONLY, ALIGN=1

                  IAP_CTRL_UART_RxFIFOProcess PROC
;;;204    // 一级接收缓冲区处理，从一级接收缓冲区中取出一个字节添加到命令帧缓冲区中
;;;205    void IAP_CTRL_UART_RxFIFOProcess(IAP_CTRL_UART_CB* pCB)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;206    {
000004  4604              MOV      r4,r0
;;;207    	uint16 end = pCB->rxFIFO.end;
000006  f8b410fc          LDRH     r1,[r4,#0xfc]
;;;208    	uint16 head = pCB->rxFIFO.head;
00000a  f8b400fa          LDRH     r0,[r4,#0xfa]
;;;209    	IAP_CTRL_CMD_FRAME* pCmdFrame = NULL;
;;;210    	uint16 length = 0;
;;;211    	uint8 currentData = 0;
;;;212    	
;;;213    	// 参数合法性检验
;;;214    	if(NULL == pCB)
00000e  2c00              CMP      r4,#0
000010  d024              BEQ      |L10.92|
;;;215    	{
;;;216    		return;
;;;217    	}
;;;218    	
;;;219    	// 一级缓冲区为空，退出
;;;220    	if(head == end)
000012  4288              CMP      r0,r1
000014  d022              BEQ      |L10.92|
;;;221    	{
;;;222    		return;
;;;223    	}
;;;224    
;;;225    	// 获取临时缓冲区指针
;;;226    	pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.end];
000016  f8b4042c          LDRH     r0,[r4,#0x42c]
00001a  eb001200          ADD      r2,r0,r0,LSL #4
00001e  eb021280          ADD      r2,r2,r0,LSL #6
000022  eb040542          ADD      r5,r4,r2,LSL #1
000026  f5057580          ADD      r5,r5,#0x100
;;;227    	// 取出当前要处理的字节
;;;228    	currentData = pCB->rxFIFO.buff[pCB->rxFIFO.currentProcessIndex];
00002a  f8b420fe          LDRH     r2,[r4,#0xfe]
00002e  5ca2              LDRB     r2,[r4,r2]
;;;229    	
;;;230    	// 临时缓冲区长度为0时，搜索首字节
;;;231    	if(0 == pCmdFrame->length)
000030  f8b530a0          LDRH     r3,[r5,#0xa0]
;;;232    	{
;;;233    		// 命令头错误，删除当前字节并退出
;;;234    		if(IAP_CTRL_UART_CMD_HEAD != currentData)
;;;235    		{
;;;236    			pCB->rxFIFO.head ++;
;;;237    			pCB->rxFIFO.head %= IAP_CTRL_UART_RX_FIFO_SIZE;
000034  27fa              MOVS     r7,#0xfa
000036  b19b              CBZ      r3,|L10.96|
;;;238    			pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;239    
;;;240    			return;
;;;241    		}
;;;242    		
;;;243    		// 命令头正确，但无临时缓冲区可用，退出
;;;244    		if((pCB->rx.end + 1)%IAP_CTRL_UART_RX_QUEUE_SIZE == pCB->rx.head)
;;;245    		{
;;;246    			return;
;;;247    		}
;;;248    
;;;249    		// 添加UART通讯超时时间设置-2016.1.5增加
;;;250    		#if IAP_CTRL_UART_RX_TIME_OUT_CHECK_ENABLE
;;;251    		TIMER_AddTask(TIMER_ID_UART_RX_TIME_OUT_CONTROL, IAP_CTRL_UART_BUS_UNIDIRECTIONAL_TIME_OUT, IAP_CTRL_UART_CALLBACK_RxTimeOut, 0, 1, ACTION_MODE_ADD_TO_QUEUE);
;;;252    		#endif
;;;253    		
;;;254    		// 命令头正确，有临时缓冲区可用，则将其添加到命令帧临时缓冲区中
;;;255    		pCmdFrame->buff[pCmdFrame->length++]= currentData;
;;;256    		pCB->rxFIFO.currentProcessIndex ++;
;;;257    		pCB->rxFIFO.currentProcessIndex %= IAP_CTRL_UART_RX_FIFO_SIZE;
;;;258    	}
;;;259    	// 非首字节，将数据添加到命令帧临时缓冲区中，但暂不删除当前数据
;;;260    	else
;;;261    	{
;;;262    		// 临时缓冲区溢出，说明当前正在接收的命令帧是错误的，正确的命令帧不会出现长度溢出的情况
;;;263    		if(pCmdFrame->length >= IAP_CTRL_UART_CMD_LENGTH_MAX)
000038  f04f0800          MOV      r8,#0
00003c  2ba0              CMP      r3,#0xa0
00003e  d37d              BCC      |L10.316|
;;;264    		{
;;;265    			#if IAP_CTRL_UART_RX_TIME_OUT_CHECK_ENABLE
;;;266    			// 停止RX通讯超时检测
;;;267    			IAP_CTRL_UART_StopRxTimeOutCheck();
;;;268    			#endif
;;;269    
;;;270    			// 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;271    			pCmdFrame->length = 0;	// 2016.1.5增加
000040  f8a580a0          STRH     r8,[r5,#0xa0]
;;;272    			// 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;273    			pCB->rxFIFO.head ++;
000044  f8340ffa          LDRH     r0,[r4,#0xfa]!
000048  1c40              ADDS     r0,r0,#1
00004a  8020              STRH     r0,[r4,#0]
;;;274    			pCB->rxFIFO.head %= IAP_CTRL_UART_RX_FIFO_SIZE;
00004c  8820              LDRH     r0,[r4,#0]
00004e  fbb0f1f7          UDIV     r1,r0,r7
000052  fb070011          MLS      r0,r7,r1,r0
000056  8020              STRH     r0,[r4,#0]
;;;275    			pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
000058  8820              LDRH     r0,[r4,#0]
00005a  80a0              STRH     r0,[r4,#4]
                  |L10.92|
;;;276    
;;;277    			return;
;;;278    		}
;;;279    
;;;280    		// 一直取到末尾
;;;281    		while(end != pCB->rxFIFO.currentProcessIndex)
;;;282    		{
;;;283    			// 取出当前要处理的字节
;;;284    			currentData = pCB->rxFIFO.buff[pCB->rxFIFO.currentProcessIndex];
;;;285    			// 缓冲区未溢出，正常接收，将数据添加到临时缓冲区中
;;;286    			pCmdFrame->buff[pCmdFrame->length++]= currentData;
;;;287    			pCB->rxFIFO.currentProcessIndex ++;
;;;288    			pCB->rxFIFO.currentProcessIndex %= IAP_CTRL_UART_RX_FIFO_SIZE;
;;;289    
;;;290    			// ■■接下来，需要检查命令帧是否完整，如果完整，则将命令帧临时缓冲区扶正■■
;;;291    			
;;;292    			// 首先判断命令帧最小长度，一个完整的命令字至少包括4个字节: 命令头 + 命令字 + 数据长度 + 校验码，因此不足4个字节的必定不完整
;;;293    			if(pCmdFrame->length < IAP_CTRL_UART_CMD_FRAME_LENGTH_MIN)
;;;294    			{
;;;295    				// 继续接收
;;;296    				continue;
;;;297    			}
;;;298    
;;;299    			// 命令帧长度数值越界，说明当前命令帧错误，停止接收
;;;300    			if(pCmdFrame->buff[IAP_CTRL_UART_CMD_LENGTH_INDEX] > IAP_CTRL_UART_CMD_LENGTH_MAX-IAP_CTRL_UART_CMD_FRAME_LENGTH_MIN)
;;;301    			{
;;;302    				#if IAP_CTRL_UART_RX_TIME_OUT_CHECK_ENABLE
;;;303    				// 停止RX通讯超时检测
;;;304    				IAP_CTRL_UART_StopRxTimeOutCheck();
;;;305    				#endif
;;;306    			
;;;307    				// 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;308    				pCmdFrame->length = 0;
;;;309    				// 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;310    				pCB->rxFIFO.head ++;
;;;311    				pCB->rxFIFO.head %= IAP_CTRL_UART_RX_FIFO_SIZE;
;;;312    				pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;313    
;;;314    				return;
;;;315    			}
;;;316    
;;;317    			// 命令帧长度校验，在命令长度描述字的数值上，增加命令头、命令字、数据长度、校验码，即为命令帧实际长度
;;;318    			length = pCmdFrame->length;
;;;319    			if(length < pCmdFrame->buff[IAP_CTRL_UART_CMD_LENGTH_INDEX] + IAP_CTRL_UART_CMD_FRAME_LENGTH_MIN)
;;;320    			{
;;;321    				// 长度要求不一致，说明未接收完毕，退出继续
;;;322    				continue;
;;;323    			}
;;;324    
;;;325    			// 命令帧长度OK，则进行校验，失败时删除命令头
;;;326    			if(!IAP_CTRL_UART_CheckSUM(pCmdFrame))
;;;327    			{
;;;328    				#if IAP_CTRL_UART_RX_TIME_OUT_CHECK_ENABLE
;;;329    				// 停止RX通讯超时检测
;;;330    				IAP_CTRL_UART_StopRxTimeOutCheck();
;;;331    				#endif
;;;332    				
;;;333    				// 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;334    				pCmdFrame->length = 0;
;;;335    				// 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;336    				pCB->rxFIFO.head ++;
;;;337    				pCB->rxFIFO.head %= IAP_CTRL_UART_RX_FIFO_SIZE;
;;;338    				pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;339    				
;;;340    				return;
;;;341    			}
;;;342    
;;;343    			#if IAP_CTRL_UART_RX_TIME_OUT_CHECK_ENABLE
;;;344    			// 停止RX通讯超时检测
;;;345    			IAP_CTRL_UART_StopRxTimeOutCheck();
;;;346    			#endif
;;;347    			
;;;348    			// 执行到这里，即说明接收到了一个完整并且正确的命令帧，此时需将处理过的数据从一级缓冲区中删除，并将该命令帧扶正
;;;349    			pCB->rxFIFO.head += length;		// head必须要用16位，否则这一行有时会溢出
;;;350    			pCB->rxFIFO.head %= IAP_CTRL_UART_RX_FIFO_SIZE;
;;;351    			pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;352    			IAP_CTRL_UART_ConfirmTempCmdFrameBuff(pCB);
;;;353    
;;;354    			return;
;;;355    		}
;;;356    	}
;;;357    }
00005c  e8bd81f0          POP      {r4-r8,pc}
                  |L10.96|
000060  2a55              CMP      r2,#0x55              ;234
000062  d00c              BEQ      |L10.126|
000064  f8340ffa          LDRH     r0,[r4,#0xfa]!        ;236
000068  1c40              ADDS     r0,r0,#1              ;236
00006a  8020              STRH     r0,[r4,#0]            ;236
00006c  8820              LDRH     r0,[r4,#0]            ;237
00006e  fbb0f1f7          UDIV     r1,r0,r7              ;237
000072  fb070011          MLS      r0,r7,r1,r0           ;237
000076  8020              STRH     r0,[r4,#0]            ;237
000078  8820              LDRH     r0,[r4,#0]            ;238
00007a  80a0              STRH     r0,[r4,#4]            ;238
00007c  e7ee              B        |L10.92|
                  |L10.126|
00007e  1c40              ADDS     r0,r0,#1              ;244
000080  2105              MOVS     r1,#5                 ;244
000082  fbb0f3f1          UDIV     r3,r0,r1              ;244
000086  fb010013          MLS      r0,r1,r3,r0           ;244
00008a  f8b4142a          LDRH     r1,[r4,#0x42a]        ;244
00008e  4288              CMP      r0,r1                 ;244
000090  d0e4              BEQ      |L10.92|
000092  2001              MOVS     r0,#1                 ;255
000094  f8a500a0          STRH     r0,[r5,#0xa0]         ;255
000098  702a              STRB     r2,[r5,#0]            ;255
00009a  f8340ffe          LDRH     r0,[r4,#0xfe]!        ;256
00009e  1c40              ADDS     r0,r0,#1              ;256
0000a0  b280              UXTH     r0,r0                 ;256
0000a2  fbb0f1f7          UDIV     r1,r0,r7              ;257
0000a6  fb070011          MLS      r0,r7,r1,r0           ;257
0000aa  8020              STRH     r0,[r4,#0]            ;257
0000ac  e7d6              B        |L10.92|
                  |L10.174|
0000ae  5c22              LDRB     r2,[r4,r0]            ;284
0000b0  f8b500a0          LDRH     r0,[r5,#0xa0]         ;286
0000b4  1c43              ADDS     r3,r0,#1              ;286
0000b6  f8a530a0          STRH     r3,[r5,#0xa0]         ;286
0000ba  542a              STRB     r2,[r5,r0]            ;286
0000bc  f8b400fe          LDRH     r0,[r4,#0xfe]         ;287
0000c0  1c40              ADDS     r0,r0,#1              ;287
0000c2  b280              UXTH     r0,r0                 ;287
0000c4  fbb0f2f7          UDIV     r2,r0,r7              ;288
0000c8  fb070012          MLS      r0,r7,r2,r0           ;288
0000cc  f8a400fe          STRH     r0,[r4,#0xfe]         ;288
0000d0  f8b560a0          LDRH     r6,[r5,#0xa0]         ;293
0000d4  2e04              CMP      r6,#4                 ;293
0000d6  d33b              BCC      |L10.336|
0000d8  78a8              LDRB     r0,[r5,#2]            ;300
0000da  289c              CMP      r0,#0x9c              ;300
0000dc  d90e              BLS      |L10.252|
0000de  f8a580a0          STRH     r8,[r5,#0xa0]         ;308
0000e2  f8340ffa          LDRH     r0,[r4,#0xfa]!        ;310
0000e6  1c40              ADDS     r0,r0,#1              ;310
0000e8  8020              STRH     r0,[r4,#0]            ;310
0000ea  8820              LDRH     r0,[r4,#0]            ;311
0000ec  fbb0f1f7          UDIV     r1,r0,r7              ;311
0000f0  fb070011          MLS      r0,r7,r1,r0           ;311
0000f4  8020              STRH     r0,[r4,#0]            ;311
0000f6  8820              LDRH     r0,[r4,#0]            ;312
0000f8  80a0              STRH     r0,[r4,#4]            ;312
0000fa  e7af              B        |L10.92|
                  |L10.252|
0000fc  1d00              ADDS     r0,r0,#4              ;319
0000fe  42b0              CMP      r0,r6                 ;319
000100  d826              BHI      |L10.336|
000102  4628              MOV      r0,r5                 ;326
000104  f7fffffe          BL       IAP_CTRL_UART_CheckSUM
000108  b188              CBZ      r0,|L10.302|
00010a  f8340ffa          LDRH     r0,[r4,#0xfa]!        ;349
00010e  4430              ADD      r0,r0,r6              ;349
000110  8020              STRH     r0,[r4,#0]            ;349
000112  8820              LDRH     r0,[r4,#0]            ;350
000114  fbb0f1f7          UDIV     r1,r0,r7              ;350
000118  fb070011          MLS      r0,r7,r1,r0           ;350
00011c  8020              STRH     r0,[r4,#0]            ;350
00011e  8820              LDRH     r0,[r4,#0]            ;351
000120  80a0              STRH     r0,[r4,#4]            ;351
000122  3cfa              SUBS     r4,r4,#0xfa           ;351
000124  4620              MOV      r0,r4                 ;352
000126  e8bd41f0          POP      {r4-r8,lr}            ;352
00012a  f7ffbffe          B.W      IAP_CTRL_UART_ConfirmTempCmdFrameBuff
                  |L10.302|
00012e  f8a580a0          STRH     r8,[r5,#0xa0]         ;334
000132  f8340ffa          LDRH     r0,[r4,#0xfa]!        ;336
000136  1c40              ADDS     r0,r0,#1              ;336
000138  8020              STRH     r0,[r4,#0]            ;336
00013a  e000              B        |L10.318|
                  |L10.316|
00013c  e008              B        |L10.336|
                  |L10.318|
00013e  8820              LDRH     r0,[r4,#0]            ;337
000140  fbb0f1f7          UDIV     r1,r0,r7              ;337
000144  fb070011          MLS      r0,r7,r1,r0           ;337
000148  8020              STRH     r0,[r4,#0]            ;337
00014a  8820              LDRH     r0,[r4,#0]            ;338
00014c  80a0              STRH     r0,[r4,#4]            ;338
00014e  e785              B        |L10.92|
                  |L10.336|
000150  f8b400fe          LDRH     r0,[r4,#0xfe]         ;281
000154  4288              CMP      r0,r1                 ;281
000156  d1aa              BNE      |L10.174|
000158  e780              B        |L10.92|
;;;358    
                          ENDP


                          AREA ||i.IAP_CTRL_UART_SendCmdCheckFlashBlankResult||, CODE, READONLY, ALIGN=2

                  IAP_CTRL_UART_SendCmdCheckFlashBlankResult PROC
;;;1677   // 查空结果上报
;;;1678   void IAP_CTRL_UART_SendCmdCheckFlashBlankResult(uint8 param)
000000  b510              PUSH     {r4,lr}
;;;1679   {
000002  4604              MOV      r4,r0
;;;1680   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_HEAD);
000004  2155              MOVS     r1,#0x55
000006  480a              LDR      r0,|L11.48|
000008  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1681   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_UP_CHECK_FLASH_BLANK_RESULT);
00000c  2129              MOVS     r1,#0x29
00000e  4808              LDR      r0,|L11.48|
000010  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1682   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, 1);		// 数据长度
000014  2101              MOVS     r1,#1
000016  4806              LDR      r0,|L11.48|
000018  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1683   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, param);
00001c  4621              MOV      r1,r4
00001e  4804              LDR      r0,|L11.48|
000020  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1684   	IAP_CTRL_UART_TxAddFrame(&iapCtrlUartCB);
000024  e8bd4010          POP      {r4,lr}
000028  4801              LDR      r0,|L11.48|
00002a  f7ffbffe          B.W      IAP_CTRL_UART_TxAddFrame
;;;1685   }
;;;1686   
                          ENDP

00002e  0000              DCW      0x0000
                  |L11.48|
                          DCD      ||.bss||+0xa0

                          AREA ||i.IAP_CTRL_UART_SendCmdEraseFlashResult||, CODE, READONLY, ALIGN=2

                  IAP_CTRL_UART_SendCmdEraseFlashResult PROC
;;;1657   // 擦除FLASH结果上报
;;;1658   void IAP_CTRL_UART_SendCmdEraseFlashResult(uint8 param)
000000  b510              PUSH     {r4,lr}
;;;1659   {
000002  4604              MOV      r4,r0
;;;1660   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_HEAD);
000004  2155              MOVS     r1,#0x55
000006  480a              LDR      r0,|L12.48|
000008  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1661   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_UP_IAP_ERASE_FLASH_RESULT);
00000c  2125              MOVS     r1,#0x25
00000e  4808              LDR      r0,|L12.48|
000010  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1662   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, 1);		// 数据长度
000014  2101              MOVS     r1,#1
000016  4806              LDR      r0,|L12.48|
000018  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1663   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, param);
00001c  4621              MOV      r1,r4
00001e  4804              LDR      r0,|L12.48|
000020  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1664   	IAP_CTRL_UART_TxAddFrame(&iapCtrlUartCB);
000024  e8bd4010          POP      {r4,lr}
000028  4801              LDR      r0,|L12.48|
00002a  f7ffbffe          B.W      IAP_CTRL_UART_TxAddFrame
;;;1665   }
;;;1666   
                          ENDP

00002e  0000              DCW      0x0000
                  |L12.48|
                          DCD      ||.bss||+0xa0

                          AREA ||i.IAP_CTRL_UART_SendCmdNoResult||, CODE, READONLY, ALIGN=2

                  IAP_CTRL_UART_SendCmdNoResult PROC
;;;1847   // 发送命令无结果
;;;1848   void IAP_CTRL_UART_SendCmdNoResult(uint8 cmdWord)
000000  b510              PUSH     {r4,lr}
;;;1849   {
000002  4604              MOV      r4,r0
;;;1850   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_HEAD);
000004  2155              MOVS     r1,#0x55
000006  4808              LDR      r0,|L13.40|
000008  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1851   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, cmdWord);
00000c  4621              MOV      r1,r4
00000e  4806              LDR      r0,|L13.40|
000010  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1852   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, 0);		// 数据长度
000014  2100              MOVS     r1,#0
000016  4804              LDR      r0,|L13.40|
000018  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1853   	IAP_CTRL_UART_TxAddFrame(&iapCtrlUartCB);
00001c  e8bd4010          POP      {r4,lr}
000020  4801              LDR      r0,|L13.40|
000022  f7ffbffe          B.W      IAP_CTRL_UART_TxAddFrame
;;;1854   }
;;;1855   
                          ENDP

000026  0000              DCW      0x0000
                  |L13.40|
                          DCD      ||.bss||+0xa0

                          AREA ||i.IAP_CTRL_UART_SendCmdProjectApply||, CODE, READONLY, ALIGN=2

                  IAP_CTRL_UART_SendCmdProjectApply PROC
;;;1628   // 工程模式启用
;;;1629   void IAP_CTRL_UART_SendCmdProjectApply(uint32 para)
000000  b570              PUSH     {r4-r6,lr}
;;;1630   {
000002  b088              SUB      sp,sp,#0x20
;;;1631   	uint8 param[] = IAP_VERSION;
000004  221c              MOVS     r2,#0x1c
000006  a112              ADR      r1,|L14.80|
000008  a801              ADD      r0,sp,#4
00000a  f7fffffe          BL       __aeabi_memcpy4
;;;1632   	uint8 len = strlen((char*)param);
00000e  a801              ADD      r0,sp,#4
000010  f7fffffe          BL       strlen
000014  b2c6              UXTB     r6,r0
;;;1633   	uint8 i;
;;;1634   	
;;;1635   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_HEAD);
000016  2155              MOVS     r1,#0x55
000018  4814              LDR      r0,|L14.108|
00001a  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1636   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_UP_PROJECT_APPLY);
00001e  2101              MOVS     r1,#1
000020  4812              LDR      r0,|L14.108|
000022  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1637   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, len);		// 数据长度
000026  4631              MOV      r1,r6
000028  4810              LDR      r0,|L14.108|
00002a  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1638   
;;;1639   	for (i = 0; i < len; i++)
00002e  2400              MOVS     r4,#0
000030  ad01              ADD      r5,sp,#4              ;1631
000032  e005              B        |L14.64|
                  |L14.52|
;;;1640   	{
;;;1641   		IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, param[i]);
000034  5d29              LDRB     r1,[r5,r4]
000036  480d              LDR      r0,|L14.108|
000038  f7fffffe          BL       IAP_CTRL_UART_TxAddData
00003c  1c64              ADDS     r4,r4,#1              ;1639
00003e  b2e4              UXTB     r4,r4                 ;1639
                  |L14.64|
000040  42b4              CMP      r4,r6                 ;1639
000042  d3f7              BCC      |L14.52|
;;;1642   	}
;;;1643   	
;;;1644   	IAP_CTRL_UART_TxAddFrame(&iapCtrlUartCB);
000044  4809              LDR      r0,|L14.108|
000046  f7fffffe          BL       IAP_CTRL_UART_TxAddFrame
;;;1645   }
00004a  b008              ADD      sp,sp,#0x20
00004c  bd70              POP      {r4-r6,pc}
;;;1646   
                          ENDP

00004e  0000              DCW      0x0000
                  |L14.80|
000050  425f434d          DCB      "B_CM_FW_BL_DT_BC201_V0.0.0",0
000054  5f46575f
000058  424c5f44
00005c  545f4243
000060  3230315f
000064  56302e30
000068  2e3000  
00006b  00                DCB      0
                  |L14.108|
                          DCD      ||.bss||+0xa0

                          AREA ||i.IAP_CTRL_UART_SendCmdProjectReady||, CODE, READONLY, ALIGN=2

                  IAP_CTRL_UART_SendCmdProjectReady PROC
;;;1647   // 工程模式准备就绪报告
;;;1648   void IAP_CTRL_UART_SendCmdProjectReady(uint8 param)
000000  b510              PUSH     {r4,lr}
;;;1649   {
000002  4604              MOV      r4,r0
;;;1650   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_HEAD);
000004  2155              MOVS     r1,#0x55
000006  480a              LDR      r0,|L15.48|
000008  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1651   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_UP_PROJECT_READY);
00000c  2103              MOVS     r1,#3
00000e  4808              LDR      r0,|L15.48|
000010  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1652   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, 1);		// 数据长度
000014  2101              MOVS     r1,#1
000016  4806              LDR      r0,|L15.48|
000018  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1653   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, param);
00001c  4621              MOV      r1,r4
00001e  4804              LDR      r0,|L15.48|
000020  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1654   	IAP_CTRL_UART_TxAddFrame(&iapCtrlUartCB);
000024  e8bd4010          POP      {r4,lr}
000028  4801              LDR      r0,|L15.48|
00002a  f7ffbffe          B.W      IAP_CTRL_UART_TxAddFrame
;;;1655   }
;;;1656   
                          ENDP

00002e  0000              DCW      0x0000
                  |L15.48|
                          DCD      ||.bss||+0xa0

                          AREA ||i.IAP_CTRL_UART_SendCmdQrRegParam||, CODE, READONLY, ALIGN=2

                  IAP_CTRL_UART_SendCmdQrRegParam PROC
;;;1716   // 二维码注册参数上报
;;;1717   void IAP_CTRL_UART_SendCmdQrRegParam(uint8 *param)
000000  b570              PUSH     {r4-r6,lr}
;;;1718   {
000002  4605              MOV      r5,r0
;;;1719   	uint8 len = strlen((char*)param);
000004  4628              MOV      r0,r5
000006  f7fffffe          BL       strlen
00000a  b2c6              UXTB     r6,r0
;;;1720   	uint8 i;
;;;1721   	
;;;1722   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_HEAD);
00000c  2155              MOVS     r1,#0x55
00000e  480d              LDR      r0,|L16.68|
000010  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1723   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_UP_QR_PARAM_REPORT);
000014  2141              MOVS     r1,#0x41
000016  480b              LDR      r0,|L16.68|
000018  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1724   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, len);		// 数据长度
00001c  4631              MOV      r1,r6
00001e  4809              LDR      r0,|L16.68|
000020  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1725   
;;;1726   	for (i = 0; i < len; i++)
000024  2400              MOVS     r4,#0
000026  e005              B        |L16.52|
                  |L16.40|
;;;1727   	{
;;;1728   		IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, param[i]);
000028  5d29              LDRB     r1,[r5,r4]
00002a  4806              LDR      r0,|L16.68|
00002c  f7fffffe          BL       IAP_CTRL_UART_TxAddData
000030  1c64              ADDS     r4,r4,#1              ;1726
000032  b2e4              UXTB     r4,r4                 ;1726
                  |L16.52|
000034  42b4              CMP      r4,r6                 ;1726
000036  d3f7              BCC      |L16.40|
;;;1729   	}
;;;1730   	
;;;1731   	IAP_CTRL_UART_TxAddFrame(&iapCtrlUartCB);
000038  e8bd4070          POP      {r4-r6,lr}
00003c  4801              LDR      r0,|L16.68|
00003e  f7ffbffe          B.W      IAP_CTRL_UART_TxAddFrame
;;;1732   }
;;;1733   
                          ENDP

000042  0000              DCW      0x0000
                  |L16.68|
                          DCD      ||.bss||+0xa0

                          AREA ||i.IAP_CTRL_UART_SendCmdQrWriteResultReport||, CODE, READONLY, ALIGN=2

                  IAP_CTRL_UART_SendCmdQrWriteResultReport PROC
;;;1734   // 发送写入二维码数据结果
;;;1735   void IAP_CTRL_UART_SendCmdQrWriteResultReport(uint8 param)
000000  b510              PUSH     {r4,lr}
;;;1736   {
000002  4604              MOV      r4,r0
;;;1737   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_HEAD);
000004  2155              MOVS     r1,#0x55
000006  480a              LDR      r0,|L17.48|
000008  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1738   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_UP_QR_DATA_WRITE_RESULT);
00000c  2143              MOVS     r1,#0x43
00000e  4808              LDR      r0,|L17.48|
000010  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1739   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, 1);		// 数据长度
000014  2101              MOVS     r1,#1
000016  4806              LDR      r0,|L17.48|
000018  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1740   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, param);
00001c  4621              MOV      r1,r4
00001e  4804              LDR      r0,|L17.48|
000020  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1741   	IAP_CTRL_UART_TxAddFrame(&iapCtrlUartCB);
000024  e8bd4010          POP      {r4,lr}
000028  4801              LDR      r0,|L17.48|
00002a  f7ffbffe          B.W      IAP_CTRL_UART_TxAddFrame
;;;1742   }
;;;1743   
                          ENDP

00002e  0000              DCW      0x0000
                  |L17.48|
                          DCD      ||.bss||+0xa0

                          AREA ||i.IAP_CTRL_UART_SendCmdUIEraseResultReport||, CODE, READONLY, ALIGN=2

                  IAP_CTRL_UART_SendCmdUIEraseResultReport PROC
;;;1696   // 发送UI数据擦除结果
;;;1697   void IAP_CTRL_UART_SendCmdUIEraseResultReport(uint8 param)
000000  b510              PUSH     {r4,lr}
;;;1698   {
000002  4604              MOV      r4,r0
;;;1699   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_HEAD);
000004  2155              MOVS     r1,#0x55
000006  480a              LDR      r0,|L18.48|
000008  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1700   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_UP_UI_DATA_ERASE_ACK);
00000c  2113              MOVS     r1,#0x13
00000e  4808              LDR      r0,|L18.48|
000010  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1701   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, 1);		// 数据长度
000014  2101              MOVS     r1,#1
000016  4806              LDR      r0,|L18.48|
000018  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1702   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, param);
00001c  4621              MOV      r1,r4
00001e  4804              LDR      r0,|L18.48|
000020  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1703   	IAP_CTRL_UART_TxAddFrame(&iapCtrlUartCB);
000024  e8bd4010          POP      {r4,lr}
000028  4801              LDR      r0,|L18.48|
00002a  f7ffbffe          B.W      IAP_CTRL_UART_TxAddFrame
;;;1704   }
;;;1705   
                          ENDP

00002e  0000              DCW      0x0000
                  |L18.48|
                          DCD      ||.bss||+0xa0

                          AREA ||i.IAP_CTRL_UART_SendCmdUIWriteDataResultReport||, CODE, READONLY, ALIGN=2

                  IAP_CTRL_UART_SendCmdUIWriteDataResultReport PROC
;;;1706   // 发送UI数据写入结果
;;;1707   void IAP_CTRL_UART_SendCmdUIWriteDataResultReport(uint8 param)
000000  b510              PUSH     {r4,lr}
;;;1708   {
000002  4604              MOV      r4,r0
;;;1709   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_HEAD);
000004  2155              MOVS     r1,#0x55
000006  480a              LDR      r0,|L19.48|
000008  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1710   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_UP_UI_DATA_WRITE_RESULT);
00000c  2115              MOVS     r1,#0x15
00000e  4808              LDR      r0,|L19.48|
000010  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1711   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, 1);		// 数据长度
000014  2101              MOVS     r1,#1
000016  4806              LDR      r0,|L19.48|
000018  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1712   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, param);
00001c  4621              MOV      r1,r4
00001e  4804              LDR      r0,|L19.48|
000020  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1713   	IAP_CTRL_UART_TxAddFrame(&iapCtrlUartCB);
000024  e8bd4010          POP      {r4,lr}
000028  4801              LDR      r0,|L19.48|
00002a  f7ffbffe          B.W      IAP_CTRL_UART_TxAddFrame
;;;1714   }
;;;1715   
                          ENDP

00002e  0000              DCW      0x0000
                  |L19.48|
                          DCD      ||.bss||+0xa0

                          AREA ||i.IAP_CTRL_UART_SendCmdUpdataFinishResult||, CODE, READONLY, ALIGN=2

                  IAP_CTRL_UART_SendCmdUpdataFinishResult PROC
;;;1687   // 系统升级结束确认
;;;1688   void IAP_CTRL_UART_SendCmdUpdataFinishResult(uint8 param)
000000  b500              PUSH     {lr}
;;;1689   {
;;;1690   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_HEAD);
000002  2155              MOVS     r1,#0x55
000004  4807              LDR      r0,|L20.36|
000006  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1691   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_UP_UPDATA_FINISH_RESULT);
00000a  212b              MOVS     r1,#0x2b
00000c  4805              LDR      r0,|L20.36|
00000e  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1692   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, 0);		// 数据长度
000012  2100              MOVS     r1,#0
000014  4803              LDR      r0,|L20.36|
000016  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1693   	IAP_CTRL_UART_TxAddFrame(&iapCtrlUartCB);
00001a  4802              LDR      r0,|L20.36|
00001c  f85deb04          POP      {lr}
000020  f7ffbffe          B.W      IAP_CTRL_UART_TxAddFrame
;;;1694   }
;;;1695   
                          ENDP

                  |L20.36|
                          DCD      ||.bss||+0xa0

                          AREA ||i.IAP_CTRL_UART_SendCmdWithResult||, CODE, READONLY, ALIGN=2

                  IAP_CTRL_UART_SendCmdWithResult PROC
;;;1837   // 发送命令带结果
;;;1838   void IAP_CTRL_UART_SendCmdWithResult(uint8 cmdWord, uint8 result)
000000  b530              PUSH     {r4,r5,lr}
;;;1839   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1840   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_HEAD);
000006  2155              MOVS     r1,#0x55
000008  4809              LDR      r0,|L21.48|
00000a  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1841   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, cmdWord);
00000e  4629              MOV      r1,r5
000010  4807              LDR      r0,|L21.48|
000012  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1842   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, 1);		// 数据长度
000016  2101              MOVS     r1,#1
000018  4805              LDR      r0,|L21.48|
00001a  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1843   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, result);
00001e  4621              MOV      r1,r4
000020  4803              LDR      r0,|L21.48|
000022  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1844   	IAP_CTRL_UART_TxAddFrame(&iapCtrlUartCB);
000026  e8bd4030          POP      {r4,r5,lr}
00002a  4801              LDR      r0,|L21.48|
00002c  f7ffbffe          B.W      IAP_CTRL_UART_TxAddFrame
;;;1845   }
;;;1846   
                          ENDP

                  |L21.48|
                          DCD      ||.bss||+0xa0

                          AREA ||i.IAP_CTRL_UART_SendCmdWriteFlashResult||, CODE, READONLY, ALIGN=2

                  IAP_CTRL_UART_SendCmdWriteFlashResult PROC
;;;1667   // IAP数据写入结果上报
;;;1668   void IAP_CTRL_UART_SendCmdWriteFlashResult(uint8 param)
000000  b510              PUSH     {r4,lr}
;;;1669   {
000002  4604              MOV      r4,r0
;;;1670   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_HEAD);
000004  2155              MOVS     r1,#0x55
000006  480a              LDR      r0,|L22.48|
000008  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1671   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_UP_IAP_WRITE_FLASH_RESULT);
00000c  2127              MOVS     r1,#0x27
00000e  4808              LDR      r0,|L22.48|
000010  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1672   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, 1);		// 数据长度
000014  2101              MOVS     r1,#1
000016  4806              LDR      r0,|L22.48|
000018  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1673   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, param);
00001c  4621              MOV      r1,r4
00001e  4804              LDR      r0,|L22.48|
000020  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1674   	IAP_CTRL_UART_TxAddFrame(&iapCtrlUartCB);
000024  e8bd4010          POP      {r4,lr}
000028  4801              LDR      r0,|L22.48|
00002a  f7ffbffe          B.W      IAP_CTRL_UART_TxAddFrame
;;;1675   }
;;;1676   
                          ENDP

00002e  0000              DCW      0x0000
                  |L22.48|
                          DCD      ||.bss||+0xa0

                          AREA ||i.IAP_CTRL_UART_SendFlagCheck||, CODE, READONLY, ALIGN=2

                  IAP_CTRL_UART_SendFlagCheck PROC
;;;1816   
;;;1817   void IAP_CTRL_UART_SendFlagCheck(uint32 checkNum)
000000  b530              PUSH     {r4,r5,lr}
;;;1818   {
;;;1819   	uint8 *buff;
;;;1820   	uint8 i;
;;;1821   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_HEAD);
000002  2155              MOVS     r1,#0x55
000004  480e              LDR      r0,|L23.64|
000006  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1822   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_FLAG_ARRAY_READ);
00000a  2191              MOVS     r1,#0x91
00000c  480c              LDR      r0,|L23.64|
00000e  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1823   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, 0);				// 数据长度
000012  2100              MOVS     r1,#0
000014  480a              LDR      r0,|L23.64|
000016  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1824   
;;;1825   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, 64);			// 标志区长度
00001a  2140              MOVS     r1,#0x40
00001c  4808              LDR      r0,|L23.64|
00001e  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1826   
;;;1827   	buff = paramCB.runtime.flagArr;
000022  4d08              LDR      r5,|L23.68|
;;;1828   	for (i = 0; i < 64; i++)
000024  2400              MOVS     r4,#0
                  |L23.38|
;;;1829   	{
;;;1830   		IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, buff[i]);		// 版本字符内容
000026  4806              LDR      r0,|L23.64|
000028  5d29              LDRB     r1,[r5,r4]
00002a  f7fffffe          BL       IAP_CTRL_UART_TxAddData
00002e  1c64              ADDS     r4,r4,#1              ;1828
000030  b2e4              UXTB     r4,r4                 ;1828
000032  2c40              CMP      r4,#0x40              ;1828
000034  d3f7              BCC      |L23.38|
;;;1831   	}
;;;1832   	
;;;1833   	IAP_CTRL_UART_TxAddFrame(&iapCtrlUartCB);
000036  e8bd4030          POP      {r4,r5,lr}
00003a  4801              LDR      r0,|L23.64|
00003c  f7ffbffe          B.W      IAP_CTRL_UART_TxAddFrame
;;;1834   }
;;;1835   
                          ENDP

                  |L23.64|
                          DCD      ||.bss||+0xa0
                  |L23.68|
                          DCD      paramCB

                          AREA ||i.IAP_CTRL_UART_SendSpiFlashData||, CODE, READONLY, ALIGN=2

                  IAP_CTRL_UART_SendSpiFlashData PROC
;;;1856   // 读取数据上报
;;;1857   void IAP_CTRL_UART_SendSpiFlashData(uint32 ReadAddr, uint8 NumByteToRead)
000000  b570              PUSH     {r4-r6,lr}
;;;1858   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;1859   	uint16 i;
;;;1860   	uint8* pFlashBuff = NULL;				// 保存读取扇区的数据
;;;1861   
;;;1862   	pFlashBuff = (uint8 *)malloc(NumByteToRead);
000006  4630              MOV      r0,r6
000008  f7fffffe          BL       malloc
00000c  4605              MOV      r5,r0
;;;1863   	if (NULL == pFlashBuff)
00000e  0028              MOVS     r0,r5
000010  d038              BEQ      |L24.132|
;;;1864   	{
;;;1865   		return;
;;;1866   	}
;;;1867   	
;;;1868   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_HEAD);
000012  2155              MOVS     r1,#0x55
000014  481c              LDR      r0,|L24.136|
000016  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1869   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_SPI_FLASH_ABSOLUTE_READ);
00001a  2162              MOVS     r1,#0x62
00001c  481a              LDR      r0,|L24.136|
00001e  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1870   	
;;;1871   	// 发送数据长度，随意填写即可
;;;1872   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, (128+4));
000022  2184              MOVS     r1,#0x84
000024  4818              LDR      r0,|L24.136|
000026  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1873   
;;;1874   	// 发送读取的地址
;;;1875   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, ((ReadAddr & 0xFF000000) >> 24));
00002a  0e21              LSRS     r1,r4,#24
00002c  4816              LDR      r0,|L24.136|
00002e  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1876   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, ((ReadAddr & 0x00FF0000) >> 16));
000032  f3c44107          UBFX     r1,r4,#16,#8
000036  4814              LDR      r0,|L24.136|
000038  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1877   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, ((ReadAddr & 0x0000FF00) >> 8));
00003c  f3c42107          UBFX     r1,r4,#8,#8
000040  4811              LDR      r0,|L24.136|
000042  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1878   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, ((ReadAddr & 0x000000FF) >> 0));
000046  b2e1              UXTB     r1,r4
000048  480f              LDR      r0,|L24.136|
00004a  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1879   
;;;1880   	// 发送读取数据字节数
;;;1881   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, (NumByteToRead & 0xFF));
00004e  4631              MOV      r1,r6
000050  480d              LDR      r0,|L24.136|
000052  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1882   
;;;1883   	// 从外部spiflash读取数据
;;;1884   	SPI_FLASH_ReadArray(pFlashBuff, ReadAddr, NumByteToRead);
000056  4632              MOV      r2,r6
000058  4621              MOV      r1,r4
00005a  4628              MOV      r0,r5
00005c  f7fffffe          BL       SPI_FLASH_ReadArray
;;;1885   	// 填充数据到命令帧数据中
;;;1886   	for (i = 0; i < NumByteToRead; i++)
000060  2400              MOVS     r4,#0
000062  e005              B        |L24.112|
                  |L24.100|
;;;1887   	{
;;;1888   		IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, pFlashBuff[i]);
000064  5d29              LDRB     r1,[r5,r4]
000066  4808              LDR      r0,|L24.136|
000068  f7fffffe          BL       IAP_CTRL_UART_TxAddData
00006c  1c64              ADDS     r4,r4,#1              ;1886
00006e  b2a4              UXTH     r4,r4                 ;1886
                  |L24.112|
000070  42b4              CMP      r4,r6                 ;1886
000072  d3f7              BCC      |L24.100|
;;;1889   	}
;;;1890   	
;;;1891   	IAP_CTRL_UART_TxAddFrame(&iapCtrlUartCB);
000074  4804              LDR      r0,|L24.136|
000076  f7fffffe          BL       IAP_CTRL_UART_TxAddFrame
;;;1892   
;;;1893   	free(pFlashBuff);
00007a  4628              MOV      r0,r5
00007c  e8bd4070          POP      {r4-r6,lr}
000080  f7ffbffe          B.W      free
                  |L24.132|
;;;1894   }
000084  bd70              POP      {r4-r6,pc}
;;;1895   
                          ENDP

000086  0000              DCW      0x0000
                  |L24.136|
                          DCD      ||.bss||+0xa0

                          AREA ||i.IAP_CTRL_UART_SendVersionCheck||, CODE, READONLY, ALIGN=2

                  IAP_CTRL_UART_SendVersionCheck PROC
;;;1745   // 发送指定核对的版本
;;;1746   void IAP_CTRL_UART_SendVersionCheck(uint32 checkNum)
000000  b530              PUSH     {r4,r5,lr}
;;;1747   {
000002  4605              MOV      r5,r0
;;;1748   	uint8 *buff;
;;;1749   	uint8 i;
;;;1750   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_HEAD);
000004  2155              MOVS     r1,#0x55
000006  4824              LDR      r0,|L25.152|
000008  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1751   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_CHECK_VERSION);
00000c  2190              MOVS     r1,#0x90
00000e  4822              LDR      r0,|L25.152|
000010  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1752   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, 0);				// 数据长度
000014  2100              MOVS     r1,#0
000016  4820              LDR      r0,|L25.152|
000018  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1753   
;;;1754   	// 根据版本号，选择发送的版本
;;;1755   	switch ((IAP_CTRL_UART_CHECK_VERSION_E)checkNum)
00001c  b2e8              UXTB     r0,r5
00001e  2808              CMP      r0,#8
000020  d219              BCS      |L25.86|
000022  e8dff000          TBB      [pc,r0]
000026  1804              DCB      0x18,0x04
000028  06090c0f          DCB      0x06,0x09,0x0c,0x0f
00002c  1215              DCB      0x12,0x15
;;;1756   	{
;;;1757   		// APP
;;;1758   		case IAP_CTRL_UART_CHECK_VERSION_APP:
;;;1759   			buff = paramCB.runtime.appVersion;
00002e  4c1b              LDR      r4,|L25.156|
;;;1760   			break;
000030  e012              B        |L25.88|
;;;1761   
;;;1762   		// BOOT
;;;1763   		case IAP_CTRL_UART_CHECK_VERSION_BOOT:
;;;1764   			buff = paramCB.runtime.bootVersion;
000032  4c1a              LDR      r4,|L25.156|
000034  3420              ADDS     r4,r4,#0x20
;;;1765   			break;
000036  e00f              B        |L25.88|
;;;1766   
;;;1767   		// UI
;;;1768   		case IAP_CTRL_UART_CHECK_VERSION_UI:
;;;1769   			buff = paramCB.runtime.uiVersion;
000038  4c18              LDR      r4,|L25.156|
00003a  3440              ADDS     r4,r4,#0x40
;;;1770   			break;
00003c  e00c              B        |L25.88|
;;;1771   			
;;;1772   		// 硬件版本
;;;1773   		case IAP_CTRL_UART_CHECK_VERSION_HW:
;;;1774   			buff = paramCB.runtime.hardVersion;
00003e  4c17              LDR      r4,|L25.156|
000040  34a0              ADDS     r4,r4,#0xa0
;;;1775   			break;
000042  e009              B        |L25.88|
;;;1776   			
;;;1777   		// SN版本
;;;1778   		case IAP_CTRL_UART_CHECK_VERSION_SN_NUM:
;;;1779   			buff = paramCB.runtime.snCode;
000044  4c15              LDR      r4,|L25.156|
000046  34c0              ADDS     r4,r4,#0xc0
;;;1780   			break;
000048  e006              B        |L25.88|
;;;1781   			
;;;1782   		// 蓝牙MAC
;;;1783   		case IAP_CTRL_UART_CHECK_VERSION_BLE_MAC:
;;;1784   			buff = paramCB.runtime.bluMac;
00004a  4c14              LDR      r4,|L25.156|
00004c  34e0              ADDS     r4,r4,#0xe0
;;;1785   			break;
00004e  e003              B        |L25.88|
;;;1786   			
;;;1787   		// 二维码字符
;;;1788   		case IAP_CTRL_UART_CHECK_VERSION_QR_CODE:
;;;1789   			buff = paramCB.runtime.qrCodeStr;
000050  4c12              LDR      r4,|L25.156|
000052  3460              ADDS     r4,r4,#0x60
;;;1790   			break;
000054  e000              B        |L25.88|
                  |L25.86|
;;;1791   
;;;1792   		default:
;;;1793   			buff = NULL;
000056  2400              MOVS     r4,#0
                  |L25.88|
;;;1794   			break;
;;;1795   	
;;;1796   	}
;;;1797   
;;;1798   	// 判断指针是否合法
;;;1799   	if (NULL == buff)
000058  b14c              CBZ      r4,|L25.110|
;;;1800   	{
;;;1801   		IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, checkNum & 0xFF);		// 比对号
;;;1802   	}
;;;1803   	else
;;;1804   	{		
;;;1805   		IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, checkNum & 0xFF);		// 比对号
00005a  b2e9              UXTB     r1,r5
00005c  480e              LDR      r0,|L25.152|
00005e  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1806   		IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, buff[0]);		// 版本长度
000062  7821              LDRB     r1,[r4,#0]
000064  480c              LDR      r0,|L25.152|
000066  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1807   
;;;1808   		for (i = 0; i < buff[0]; i++)
00006a  2500              MOVS     r5,#0
00006c  e00b              B        |L25.134|
                  |L25.110|
00006e  b2e9              UXTB     r1,r5                 ;1801
000070  4809              LDR      r0,|L25.152|
000072  f7fffffe          BL       IAP_CTRL_UART_TxAddData
000076  e009              B        |L25.140|
                  |L25.120|
;;;1809   		{
;;;1810   			IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, buff[1 + i]);		// 版本字符内容
000078  1960              ADDS     r0,r4,r5
00007a  7841              LDRB     r1,[r0,#1]
00007c  4806              LDR      r0,|L25.152|
00007e  f7fffffe          BL       IAP_CTRL_UART_TxAddData
000082  1c6d              ADDS     r5,r5,#1              ;1808
000084  b2ed              UXTB     r5,r5                 ;1808
                  |L25.134|
000086  7820              LDRB     r0,[r4,#0]            ;1808
000088  42a8              CMP      r0,r5                 ;1808
00008a  d8f5              BHI      |L25.120|
                  |L25.140|
;;;1811   		}
;;;1812   	}
;;;1813   	
;;;1814   	IAP_CTRL_UART_TxAddFrame(&iapCtrlUartCB);
00008c  e8bd4030          POP      {r4,r5,lr}
000090  4801              LDR      r0,|L25.152|
000092  f7ffbffe          B.W      IAP_CTRL_UART_TxAddFrame
;;;1815   }
;;;1816   
                          ENDP

000096  0000              DCW      0x0000
                  |L25.152|
                          DCD      ||.bss||+0xa0
                  |L25.156|
                          DCD      paramCB+0x40

                          AREA ||i.IAP_CTRL_UART_TxAddData||, CODE, READONLY, ALIGN=1

                  IAP_CTRL_UART_TxAddData PROC
;;;1332   // 向发送命令帧队列中添加数据
;;;1333   void IAP_CTRL_UART_TxAddData(IAP_CTRL_UART_CB* pCB, uint8 data)
000000  b530              PUSH     {r4,r5,lr}
;;;1334   {
;;;1335   	IAP_CTRL_CMD_FRAME* pCmdFrame = &pCB->tx.cmdQueue[pCB->tx.end];
000002  f8b0275a          LDRH     r2,[r0,#0x75a]
000006  eb021302          ADD      r3,r2,r2,LSL #4
00000a  eb031282          ADD      r2,r3,r2,LSL #6
00000e  eb000242          ADD      r2,r0,r2,LSL #1
000012  f202422e          ADD      r2,r2,#0x42e
;;;1336   	uint16 head = pCB->tx.head;
000016  f8b04758          LDRH     r4,[r0,#0x758]
;;;1337   	uint16 end =  pCB->tx.end;	// 2015.12.29
00001a  f8b0375a          LDRH     r3,[r0,#0x75a]
;;;1338   
;;;1339   	// 参数合法性检验
;;;1340   	if(NULL == pCB)
00001e  2800              CMP      r0,#0
000020  d010              BEQ      |L26.68|
;;;1341   	{
;;;1342   		return;
;;;1343   	}
;;;1344   
;;;1345   	// 发送缓冲区已满，不予接收
;;;1346   	if((end + 1) % IAP_CTRL_UART_TX_QUEUE_SIZE == head)
000022  1c5b              ADDS     r3,r3,#1
000024  2005              MOVS     r0,#5
000026  fbb3f5f0          UDIV     r5,r3,r0
00002a  fb003015          MLS      r0,r0,r5,r3
00002e  42a0              CMP      r0,r4
000030  d008              BEQ      |L26.68|
;;;1347   	{
;;;1348   		return;
;;;1349   	}
;;;1350   	
;;;1351   	// 队尾命令帧已满，退出
;;;1352   	if(pCmdFrame->length >= IAP_CTRL_UART_CMD_LENGTH_MAX)
000032  f8b200a0          LDRH     r0,[r2,#0xa0]
000036  28a0              CMP      r0,#0xa0
000038  d204              BCS      |L26.68|
;;;1353   	{
;;;1354   		return;
;;;1355   	}
;;;1356   
;;;1357   	// 数据添加到帧末尾，并更新帧长度
;;;1358   	pCmdFrame->buff[pCmdFrame->length] = data;
00003a  5411              STRB     r1,[r2,r0]
;;;1359   	pCmdFrame->length ++;
00003c  f8320fa0          LDRH     r0,[r2,#0xa0]!
000040  1c40              ADDS     r0,r0,#1
000042  8010              STRH     r0,[r2,#0]
                  |L26.68|
;;;1360   }
000044  bd30              POP      {r4,r5,pc}
;;;1361   
                          ENDP


                          AREA ||i.IAP_CTRL_UART_TxAddFrame||, CODE, READONLY, ALIGN=1

                  IAP_CTRL_UART_TxAddFrame PROC
;;;1362   // 确认添加命令帧，即承认之前填充的数据为命令帧，将其添加到发送队列中，由main进行调度发送，本函数内会自动校正命令长度，并添加校验码
;;;1363   void IAP_CTRL_UART_TxAddFrame(IAP_CTRL_UART_CB* pCB)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1364   {
;;;1365   	uint8 cc = 0;
000002  2400              MOVS     r4,#0
;;;1366   	uint16 i = 0;
000004  2200              MOVS     r2,#0
;;;1367   	IAP_CTRL_CMD_FRAME* pCmdFrame = &pCB->tx.cmdQueue[pCB->tx.end];
000006  f8b0175a          LDRH     r1,[r0,#0x75a]
00000a  eb011301          ADD      r3,r1,r1,LSL #4
00000e  eb031181          ADD      r1,r3,r1,LSL #6
000012  eb000141          ADD      r1,r0,r1,LSL #1
000016  f201412e          ADD      r1,r1,#0x42e
;;;1368   	uint16 length = pCmdFrame->length;
00001a  f8b130a0          LDRH     r3,[r1,#0xa0]
;;;1369   	uint16 head = pCB->tx.head;
00001e  f8b07758          LDRH     r7,[r0,#0x758]
;;;1370   	uint16 end =  pCB->tx.end;	// 2015.12.29
000022  f8b0575a          LDRH     r5,[r0,#0x75a]
;;;1371   
;;;1372   	// 参数合法性检验
;;;1373   	if(NULL == pCB)
000026  2800              CMP      r0,#0
000028  d00c              BEQ      |L27.68|
;;;1374   	{
;;;1375   		return;
;;;1376   	}
;;;1377   
;;;1378   	// 发送缓冲区已满，不予接收
;;;1379   	if((end + 1) % IAP_CTRL_UART_TX_QUEUE_SIZE == head)
00002a  1c6d              ADDS     r5,r5,#1
00002c  2605              MOVS     r6,#5
00002e  fbb5fcf6          UDIV     r12,r5,r6
000032  fb06551c          MLS      r5,r6,r12,r5
000036  42bd              CMP      r5,r7
000038  d004              BEQ      |L27.68|
;;;1380   	{
;;;1381   		return;
;;;1382   	}
;;;1383   	
;;;1384   	// 命令帧长度不足，清除已填充的数据，退出
;;;1385   	if(IAP_CTRL_UART_CMD_FRAME_LENGTH_MIN-1 > length)//2016.1.5修改减1
00003a  2b03              CMP      r3,#3
00003c  d203              BCS      |L27.70|
;;;1386   	{
;;;1387   		pCmdFrame->length = 0;
00003e  2000              MOVS     r0,#0
000040  f8a100a0          STRH     r0,[r1,#0xa0]
                  |L27.68|
;;;1388   		
;;;1389   		return;
;;;1390   	}
;;;1391   
;;;1392   	// 重新设置数据长度，系统在准备数据时，填充的"数据长度"可以为任意值，并且不需要添加校验码，在这里重新设置为正确的值
;;;1393   	pCmdFrame->buff[IAP_CTRL_UART_CMD_LENGTH_INDEX] = length - 3;	// 重设数据长度
;;;1394   	for(i=0; i<length; i++)
;;;1395   	{
;;;1396   		cc ^= pCmdFrame->buff[i];
;;;1397   	}
;;;1398   	pCmdFrame->buff[length] = ~cc;
;;;1399   	pCmdFrame->length ++;
;;;1400   
;;;1401   	pCB->tx.end ++;
;;;1402   	pCB->tx.end %= IAP_CTRL_UART_TX_QUEUE_SIZE;
;;;1403   	//pCB->tx.cmdQueue[pCB->tx.end].length = 0;   //2015.12.2修改
;;;1404   
;;;1405   	// 阻塞方式时启动发送
;;;1406   #if (IAP_CTRL_UART_TX_MODE == IAP_CTRL_BLOCKING_TX_MODE)
;;;1407   	IAP_CTRL_UART_BC_StartTx(pCB);
;;;1408   #endif
;;;1409   
;;;1410   }
000044  bdf0              POP      {r4-r7,pc}
                  |L27.70|
000046  1edd              SUBS     r5,r3,#3              ;1393
000048  708d              STRB     r5,[r1,#2]            ;1393
00004a  e003              B        |L27.84|
                  |L27.76|
00004c  5c8d              LDRB     r5,[r1,r2]            ;1396
00004e  406c              EORS     r4,r4,r5              ;1396
000050  1c52              ADDS     r2,r2,#1              ;1394
000052  b292              UXTH     r2,r2                 ;1394
                  |L27.84|
000054  429a              CMP      r2,r3                 ;1394
000056  d3f9              BCC      |L27.76|
000058  43e2              MVNS     r2,r4                 ;1398
00005a  54ca              STRB     r2,[r1,r3]            ;1398
00005c  f8312fa0          LDRH     r2,[r1,#0xa0]!        ;1399
000060  1c52              ADDS     r2,r2,#1              ;1399
000062  800a              STRH     r2,[r1,#0]            ;1399
000064  f200705a          ADD      r0,r0,#0x75a          ;1401
000068  8801              LDRH     r1,[r0,#0]            ;1401
00006a  1c49              ADDS     r1,r1,#1              ;1401
00006c  8001              STRH     r1,[r0,#0]            ;1401
00006e  8801              LDRH     r1,[r0,#0]            ;1402
000070  fbb1f2f6          UDIV     r2,r1,r6              ;1402
000074  fb061112          MLS      r1,r6,r2,r1           ;1402
000078  8001              STRH     r1,[r0,#0]            ;1402
00007a  bdf0              POP      {r4-r7,pc}
;;;1411   
                          ENDP


                          AREA ||i.IAP_CTRL_UART_TxProcess||, CODE, READONLY, ALIGN=1

                  IAP_CTRL_UART_TxProcess PROC
;;;1579   // 发送处理,发现发送缓冲区非空时,启动中断发送
;;;1580   void IAP_CTRL_UART_TxProcess(IAP_CTRL_UART_CB* pCB)
000000  b510              PUSH     {r4,lr}
;;;1581   {
000002  4604              MOV      r4,r0
;;;1582   	uint16 index = pCB->tx.index;							// 当前发送数据的索引号
000004  f8b4175c          LDRH     r1,[r4,#0x75c]
;;;1583   	uint16 length = pCB->tx.cmdQueue[pCB->tx.head].length;	// 当前发送的命令帧的长度
000008  f8b40758          LDRH     r0,[r4,#0x758]
00000c  eb001200          ADD      r2,r0,r0,LSL #4
000010  eb021080          ADD      r0,r2,r0,LSL #6
000014  eb040040          ADD      r0,r4,r0,LSL #1
000018  f8b024ce          LDRH     r2,[r0,#0x4ce]
;;;1584   	uint16 head = pCB->tx.head;								// 发送命令帧队列头索引号
00001c  f8b40758          LDRH     r0,[r4,#0x758]
;;;1585   	uint16 end = pCB->tx.end;								// 发送命令帧队列尾索引号
000020  f8b4375a          LDRH     r3,[r4,#0x75a]
;;;1586   
;;;1587   	// 参数合法性检验
;;;1588   	if(NULL == pCB)
000024  2c00              CMP      r4,#0
000026  d01a              BEQ      |L28.94|
;;;1589   	{
;;;1590   		return;
;;;1591   	}
;;;1592   	
;;;1593   	// 队列为空，不处理
;;;1594   	if(head == end)
000028  4298              CMP      r0,r3
00002a  d018              BEQ      |L28.94|
;;;1595   	{
;;;1596   		return;
;;;1597   	}
;;;1598   
;;;1599   	// ■■执行到这里，说明队列非空■■
;;;1600   	
;;;1601   	// 当前命令帧未发送完时，取出一个字节放到发送寄存器中
;;;1602   	if(index < length)
00002c  4291              CMP      r1,r2
00002e  d216              BCS      |L28.94|
;;;1603   	{
;;;1604   		// 发送忙，退出
;;;1605   		if(pCB->tx.txBusy)
000030  f894175e          LDRB     r1,[r4,#0x75e]
000034  2900              CMP      r1,#0
000036  d112              BNE      |L28.94|
;;;1606   		{
;;;1607   			return;
;;;1608   		}
;;;1609   		
;;;1610   		IAP_CTRL_UART_IR_StartSendData(pCB->tx.cmdQueue[head].buff[pCB->tx.index++]);
000038  f8b4175c          LDRH     r1,[r4,#0x75c]
00003c  1c4a              ADDS     r2,r1,#1
00003e  f8a4275c          STRH     r2,[r4,#0x75c]
000042  eb001200          ADD      r2,r0,r0,LSL #4
000046  eb021080          ADD      r0,r2,r0,LSL #6
00004a  eb040040          ADD      r0,r4,r0,LSL #1
00004e  4408              ADD      r0,r0,r1
000050  f890042e          LDRB     r0,[r0,#0x42e]
000054  f7fffffe          BL       IAP_CTRL_UART_IR_StartSendData
;;;1611   		
;;;1612   		// 设置发送忙状态
;;;1613   		pCB->tx.txBusy = TRUE;
000058  2001              MOVS     r0,#1
00005a  f884075e          STRB     r0,[r4,#0x75e]
                  |L28.94|
;;;1614   
;;;1615   	}
;;;1616   	// 当前命令帧发送完时，删除之
;;;1617   	else
;;;1618   	{
;;;1619   	//	pCB->tx.head ++;
;;;1620   	//	pCB->tx.head %= IAP_CTRL_UART_TX_QUEUE_SIZE;
;;;1621   	//	pCB->tx.index = 0;
;;;1622   	}
;;;1623   }
00005e  bd10              POP      {r4,pc}
;;;1624   
                          ENDP


                          AREA ||i.UART_PROTOCOL_SendMcuUid||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL_SendMcuUid PROC
;;;1934   // 发送自身MCU的唯一序列号，防止误入老化
;;;1935   void UART_PROTOCOL_SendMcuUid(uint32 param)
000000  b53e              PUSH     {r1-r5,lr}
;;;1936   {
;;;1937   	uint8 buff[UART_PROTOCOL_MCU_UID_BUFF_LENGTH];
;;;1938   	uint8 i;
;;;1939   
;;;1940   	// 按位发送sn0
;;;1941   	buff[0] = iapCB.mcuUID.sn0 & 0xff;
000002  4824              LDR      r0,|L29.148|
000004  6841              LDR      r1,[r0,#4]  ; iapCB
000006  f88d1000          STRB     r1,[sp,#0]
;;;1942   	buff[1] = (iapCB.mcuUID.sn0 >> 8)  & 0xff;
00000a  6841              LDR      r1,[r0,#4]  ; iapCB
00000c  0a09              LSRS     r1,r1,#8
00000e  f88d1001          STRB     r1,[sp,#1]
;;;1943   	buff[2] = (iapCB.mcuUID.sn0 >> 16) & 0xff;
000012  6841              LDR      r1,[r0,#4]  ; iapCB
000014  0c09              LSRS     r1,r1,#16
000016  f88d1002          STRB     r1,[sp,#2]
;;;1944   	buff[3] = (iapCB.mcuUID.sn0 >> 24) & 0xff;
00001a  6841              LDR      r1,[r0,#4]  ; iapCB
00001c  0e09              LSRS     r1,r1,#24
00001e  f88d1003          STRB     r1,[sp,#3]
;;;1945   
;;;1946   	// 按位发送sn1
;;;1947   	buff[4] = iapCB.mcuUID.sn1 & 0xff;
000022  6881              LDR      r1,[r0,#8]  ; iapCB
000024  f88d1004          STRB     r1,[sp,#4]
;;;1948   	buff[5] = (iapCB.mcuUID.sn1 >> 8)  & 0xff;
000028  6881              LDR      r1,[r0,#8]  ; iapCB
00002a  0a09              LSRS     r1,r1,#8
00002c  f88d1005          STRB     r1,[sp,#5]
;;;1949   	buff[6] = (iapCB.mcuUID.sn1 >> 16) & 0xff;
000030  6881              LDR      r1,[r0,#8]  ; iapCB
000032  0c09              LSRS     r1,r1,#16
000034  f88d1006          STRB     r1,[sp,#6]
;;;1950   	buff[7] = (iapCB.mcuUID.sn1 >> 24) & 0xff;
000038  6881              LDR      r1,[r0,#8]  ; iapCB
00003a  0e09              LSRS     r1,r1,#24
00003c  f88d1007          STRB     r1,[sp,#7]
;;;1951   
;;;1952   	// 按位发送sn2
;;;1953   	buff[8]  = iapCB.mcuUID.sn2 & 0xff;
000040  68c1              LDR      r1,[r0,#0xc]  ; iapCB
000042  f88d1008          STRB     r1,[sp,#8]
;;;1954   	buff[9]  = (iapCB.mcuUID.sn2 >> 8)  & 0xff;
000046  68c1              LDR      r1,[r0,#0xc]  ; iapCB
000048  0a09              LSRS     r1,r1,#8
00004a  f88d1009          STRB     r1,[sp,#9]
;;;1955   	buff[10] = (iapCB.mcuUID.sn2 >> 16) & 0xff;
00004e  68c1              LDR      r1,[r0,#0xc]  ; iapCB
000050  0c09              LSRS     r1,r1,#16
000052  f88d100a          STRB     r1,[sp,#0xa]
;;;1956   	buff[11] = (iapCB.mcuUID.sn2 >> 24) & 0xff;
000056  68c0              LDR      r0,[r0,#0xc]  ; iapCB
000058  0e00              LSRS     r0,r0,#24
00005a  f88d000b          STRB     r0,[sp,#0xb]
;;;1957   
;;;1958   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_HEAD);
00005e  2155              MOVS     r1,#0x55
000060  480d              LDR      r0,|L29.152|
000062  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1959   	
;;;1960   	// MCU_UID
;;;1961   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, UART_ECO_CMD_ECO_MCU_UID);	
000066  2108              MOVS     r1,#8
000068  480b              LDR      r0,|L29.152|
00006a  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1962   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, 0x00);	
00006e  2100              MOVS     r1,#0
000070  4809              LDR      r0,|L29.152|
000072  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1963   	
;;;1964   	for (i = 0; i < UART_PROTOCOL_MCU_UID_BUFF_LENGTH; i++)
000076  2400              MOVS     r4,#0
000078  466d              MOV      r5,sp                 ;1937
                  |L29.122|
;;;1965   	{
;;;1966   		IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, buff[i]);
00007a  4807              LDR      r0,|L29.152|
00007c  5d29              LDRB     r1,[r5,r4]
00007e  f7fffffe          BL       IAP_CTRL_UART_TxAddData
000082  1c64              ADDS     r4,r4,#1              ;1964
000084  b2e4              UXTB     r4,r4                 ;1964
000086  2c0c              CMP      r4,#0xc               ;1964
000088  d3f7              BCC      |L29.122|
;;;1967   	}
;;;1968   	
;;;1969   	IAP_CTRL_UART_TxAddFrame(&iapCtrlUartCB);
00008a  e8bd403e          POP      {r1-r5,lr}
00008e  4802              LDR      r0,|L29.152|
000090  f7ffbffe          B.W      IAP_CTRL_UART_TxAddFrame
;;;1970   }
;;;1971   
                          ENDP

                  |L29.148|
                          DCD      iapCB
                  |L29.152|
                          DCD      ||.bss||+0xa0

                          AREA ||i.USART1_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART1_IRQHandler PROC
;;;1435   *************************************************************/
;;;1436   void USART1_IRQHandler(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1437   {
;;;1438   	// 判断DR是否有数据，中断接收
;;;1439   	if(usart_interrupt_flag_get(IAP_CTRL_UART_TYPE_DEF, USART_INT_FLAG_RBNE) != RESET) 	 
000004  4e43              LDR      r6,|L30.276|
000006  4942              LDR      r1,|L30.272|
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       usart_interrupt_flag_get
;;;1440   	{
;;;1441   		uint16 end = iapCtrlUartCB.rxFIFO.end;
00000e  4c42              LDR      r4,|L30.280|
000010  b1d8              CBZ      r0,|L30.74|
000012  f8b450fc          LDRH     r5,[r4,#0xfc]  ; iapCtrlUartCB
;;;1442   		uint16 head = iapCtrlUartCB.rxFIFO.head;
000016  f8b470fa          LDRH     r7,[r4,#0xfa]  ; iapCtrlUartCB
;;;1443   		uint8 rxdata = 0x00;
;;;1444   		
;;;1445   		// 接收数据
;;;1446   		rxdata = (uint8)usart_data_receive(IAP_CTRL_UART_TYPE_DEF);
00001a  4630              MOV      r0,r6
00001c  f7fffffe          BL       usart_data_receive
000020  b2c0              UXTB     r0,r0
;;;1447   
;;;1448   		// 一级缓冲区已满，不予接收
;;;1449   		if((end + 1)%IAP_CTRL_UART_RX_FIFO_SIZE == head)
000022  1c69              ADDS     r1,r5,#1
000024  22fa              MOVS     r2,#0xfa
000026  fbb1f3f2          UDIV     r3,r1,r2
00002a  fb021113          MLS      r1,r2,r3,r1
00002e  42b9              CMP      r1,r7
000030  d06b              BEQ      |L30.266|
;;;1450   		{
;;;1451   			return;
;;;1452   		}
;;;1453   		// 一级缓冲区未满，接收 
;;;1454   		else
;;;1455   		{
;;;1456   			// 将接收到的数据放到临时缓冲区中
;;;1457   			iapCtrlUartCB.rxFIFO.buff[end] = rxdata;
000032  5560              STRB     r0,[r4,r5]
;;;1458   			iapCtrlUartCB.rxFIFO.end ++;
000034  f8340ffc          LDRH     r0,[r4,#0xfc]!  ; iapCtrlUartCB
000038  1c40              ADDS     r0,r0,#1
00003a  8020              STRH     r0,[r4,#0]
;;;1459   			iapCtrlUartCB.rxFIFO.end %= IAP_CTRL_UART_RX_FIFO_SIZE;
00003c  8821              LDRH     r1,[r4,#0]  ; iapCtrlUartCB
00003e  fbb1f0f2          UDIV     r0,r1,r2
000042  fb021010          MLS      r0,r2,r0,r1
000046  f82409fc          STRH     r0,[r4],#-0xfc
                  |L30.74|
;;;1460   		}	
;;;1461   
;;;1462   	}
;;;1463   
;;;1464   // 中断模式发送
;;;1465   #if (IAP_CTRL_UART_TX_MODE == IAP_CTRL_INTERRUPT_TX_MODE)
;;;1466   	// 判断DR是否有数据，中断发送
;;;1467   	if(usart_interrupt_flag_get(IAP_CTRL_UART_TYPE_DEF, USART_INT_FLAG_TC) != RESET)
00004a  4635              MOV      r5,r6
00004c  4933              LDR      r1,|L30.284|
00004e  4628              MOV      r0,r5
000050  f7fffffe          BL       usart_interrupt_flag_get
000054  b3f0              CBZ      r0,|L30.212|
;;;1468   	{
;;;1469   		uint16 head = iapCtrlUartCB.tx.head;
000056  f8b41758          LDRH     r1,[r4,#0x758]  ; iapCtrlUartCB
;;;1470   		uint16 end;
;;;1471   		uint16 index = iapCtrlUartCB.tx.index;
00005a  f8b4075c          LDRH     r0,[r4,#0x75c]  ; iapCtrlUartCB
;;;1472   		uint8 txdata = 0x00;
;;;1473   
;;;1474   		// 执行到这里，说明上一个数据已经发送完毕，当前命令帧未发送完时，取出一个字节放到发送寄存器中
;;;1475   		if(index < iapCtrlUartCB.tx.cmdQueue[head].length)
00005e  eb011201          ADD      r2,r1,r1,LSL #4
000062  eb021181          ADD      r1,r2,r1,LSL #6
000066  eb040241          ADD      r2,r4,r1,LSL #1
00006a  f8b214ce          LDRH     r1,[r2,#0x4ce]
00006e  4281              CMP      r1,r0
000070  d90b              BLS      |L30.138|
;;;1476   		{
;;;1477   			txdata = iapCtrlUartCB.tx.cmdQueue[head].buff[iapCtrlUartCB.tx.index++];
000072  f8b4175c          LDRH     r1,[r4,#0x75c]  ; iapCtrlUartCB
000076  1c48              ADDS     r0,r1,#1
000078  f8a4075c          STRH     r0,[r4,#0x75c]
00007c  1888              ADDS     r0,r1,r2
00007e  f890142e          LDRB     r1,[r0,#0x42e]
;;;1478   			
;;;1479   			// 填充数据
;;;1480   			usart_data_transmit(IAP_CTRL_UART_TYPE_DEF, txdata);
000082  4628              MOV      r0,r5
000084  f7fffffe          BL       usart_data_transmit
000088  e030              B        |L30.236|
                  |L30.138|
;;;1481   		}
;;;1482   		// 当前命令帧发送完时，删除之
;;;1483   		else
;;;1484   		{
;;;1485   			iapCtrlUartCB.tx.cmdQueue[head].length = 0;
00008a  2600              MOVS     r6,#0
00008c  f8a264ce          STRH     r6,[r2,#0x4ce]
;;;1486   			iapCtrlUartCB.tx.head ++;
000090  f50464eb          ADD      r4,r4,#0x758
000094  8820              LDRH     r0,[r4,#0]  ; iapCtrlUartCB
000096  1c40              ADDS     r0,r0,#1
000098  8020              STRH     r0,[r4,#0]
;;;1487   			iapCtrlUartCB.tx.head %= IAP_CTRL_UART_TX_QUEUE_SIZE;
00009a  8820              LDRH     r0,[r4,#0]  ; iapCtrlUartCB
00009c  2105              MOVS     r1,#5
00009e  fbb0f2f1          UDIV     r2,r0,r1
0000a2  fb010012          MLS      r0,r1,r2,r0
0000a6  8020              STRH     r0,[r4,#0]
;;;1488   			iapCtrlUartCB.tx.index = 0;
0000a8  80a6              STRH     r6,[r4,#4]
;;;1489   
;;;1490   			head = iapCtrlUartCB.tx.head;
0000aa  8821              LDRH     r1,[r4,#0]  ; iapCtrlUartCB
;;;1491   			end = iapCtrlUartCB.tx.end;
0000ac  8860              LDRH     r0,[r4,#2]  ; iapCtrlUartCB
0000ae  f5a464eb          SUB      r4,r4,#0x758
;;;1492   			
;;;1493   			// 命令帧队列非空，继续发送下一个命令帧
;;;1494   			if(head != end)
0000b2  4281              CMP      r1,r0
0000b4  d013              BEQ      |L30.222|
;;;1495   			{
;;;1496   				txdata = iapCtrlUartCB.tx.cmdQueue[head].buff[iapCtrlUartCB.tx.index++];
0000b6  f8b4275c          LDRH     r2,[r4,#0x75c]  ; iapCtrlUartCB
0000ba  1c50              ADDS     r0,r2,#1
0000bc  f8a4075c          STRH     r0,[r4,#0x75c]
0000c0  eb011001          ADD      r0,r1,r1,LSL #4
0000c4  eb001081          ADD      r0,r0,r1,LSL #6
0000c8  eb040040          ADD      r0,r4,r0,LSL #1
0000cc  4410              ADD      r0,r0,r2
0000ce  f890142e          LDRB     r1,[r0,#0x42e]
;;;1497   
;;;1498   				// 填充数据
;;;1499   				usart_data_transmit(IAP_CTRL_UART_TYPE_DEF, txdata);
0000d2  e000              B        |L30.214|
                  |L30.212|
0000d4  e00a              B        |L30.236|
                  |L30.214|
0000d6  4628              MOV      r0,r5
0000d8  f7fffffe          BL       usart_data_transmit
0000dc  e006              B        |L30.236|
                  |L30.222|
;;;1500   			}
;;;1501   			// 命令帧队列为空停止发送，设置空闲
;;;1502   			else
;;;1503   			{
;;;1504   				// 关闭发送空中断
;;;1505   				usart_interrupt_disable(IAP_CTRL_UART_TYPE_DEF, USART_INT_TC);
0000de  f2403106          MOV      r1,#0x306
0000e2  4628              MOV      r0,r5
0000e4  f7fffffe          BL       usart_interrupt_disable
;;;1506   				
;;;1507   				iapCtrlUartCB.tx.txBusy = FALSE;				
0000e8  f884675e          STRB     r6,[r4,#0x75e]
                  |L30.236|
;;;1508   			}
;;;1509   		}		
;;;1510   	}
;;;1511   #endif
;;;1512   
;;;1513   	// Other USARTx interrupts handler can go here ...				 
;;;1514   	if(usart_interrupt_flag_get(IAP_CTRL_UART_TYPE_DEF, USART_INT_FLAG_ERR_ORERR) != RESET) //----------------------- 接收溢出中断 	
0000ec  490c              LDR      r1,|L30.288|
0000ee  4628              MOV      r0,r5
0000f0  f7fffffe          BL       usart_interrupt_flag_get
0000f4  2800              CMP      r0,#0
0000f6  d008              BEQ      |L30.266|
;;;1515   	{
;;;1516   		// 用户手册 434  --- 软件先读USART_STAT0，再读USART_DATA可清除该位
;;;1517   		usart_flag_get(IAP_CTRL_UART_TYPE_DEF, USART_FLAG_ORERR);		
0000f8  2103              MOVS     r1,#3
0000fa  4628              MOV      r0,r5
0000fc  f7fffffe          BL       usart_flag_get
;;;1518   		usart_data_receive(IAP_CTRL_UART_TYPE_DEF);						  //----------------------- 清空寄存器
000100  4628              MOV      r0,r5
000102  e8bd41f0          POP      {r4-r8,lr}
000106  f7ffbffe          B.W      usart_data_receive
                  |L30.266|
;;;1519   	}
;;;1520   }
00010a  e8bd81f0          POP      {r4-r8,pc}
;;;1521   
                          ENDP

00010e  0000              DCW      0x0000
                  |L30.272|
                          DCD      0x00050305
                  |L30.276|
                          DCD      0x40004400
                  |L30.280|
                          DCD      ||.bss||+0xa0
                  |L30.284|
                          DCD      0x00060306
                  |L30.288|
                          DCD      0x00030500

                          AREA ||i.checkVersion||, CODE, READONLY, ALIGN=2

                  checkVersion PROC
;;;388    
;;;389    void checkVersion(uint32 param)
000000  b510              PUSH     {r4,lr}
;;;390    {
;;;391    	IAP_CTRL_UART_SendVersionCheck(checkFlag);
000002  4c04              LDR      r4,|L31.20|
000004  7820              LDRB     r0,[r4,#0]  ; checkFlag
000006  f7fffffe          BL       IAP_CTRL_UART_SendVersionCheck
;;;392    	checkFlag++;
00000a  7820              LDRB     r0,[r4,#0]  ; checkFlag
00000c  1c40              ADDS     r0,r0,#1
00000e  7020              STRB     r0,[r4,#0]
;;;393    }
000010  bd10              POP      {r4,pc}
;;;394    
                          ENDP

000012  0000              DCW      0x0000
                  |L31.20|
                          DCD      ||.data||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  arrbuf
                          %        160
                  iapCtrlUartCB
                          %        1892

                          AREA ||.data||, DATA, ALIGN=0

                  checkFlag
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "User\\iapCtrlUart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_iapCtrlUart_c_5e3d4376____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___13_iapCtrlUart_c_5e3d4376____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_iapCtrlUart_c_5e3d4376____REVSH|
#line 128
|__asm___13_iapCtrlUart_c_5e3d4376____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
