; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\gsmuart.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\gsmuart.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.3\Device\Include -D__MICROLIB -D__UVISION_VERSION=539 -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\gsmuart.crf User\GsmUart.c]
                          THUMB

                          AREA ||i.GSM_UART_BC_SendData||, CODE, READONLY, ALIGN=2

                  GSM_UART_BC_SendData PROC
;;;80     // 阻塞发送一个字节数据
;;;81     void GSM_UART_BC_SendData(uint8 data)
000000  b570              PUSH     {r4-r6,lr}
;;;82     {	
000002  4605              MOV      r5,r0
;;;83     	// 防止丢失第一个字节(清除空标志位,务必加) 
;;;84     	usart_flag_get(GSM_UART_TYPE_DEF, USART_FLAG_TC);		
000004  4c07              LDR      r4,|L1.36|
000006  2106              MOVS     r1,#6
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       usart_flag_get
;;;85     
;;;86     	// 填充数据
;;;87     	usart_data_transmit(GSM_UART_TYPE_DEF, data);
00000e  4629              MOV      r1,r5
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       usart_data_transmit
                  |L1.22|
;;;88     
;;;89     	// 未发送完，持续等待
;;;90     	while(usart_flag_get(GSM_UART_TYPE_DEF, USART_FLAG_TC) != SET); 		
000016  2106              MOVS     r1,#6
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       usart_flag_get
00001e  2801              CMP      r0,#1
000020  d1f9              BNE      |L1.22|
;;;91     }
000022  bd70              POP      {r4-r6,pc}
;;;92     
                          ENDP

                  |L1.36|
                          DCD      0x40004c00

                          AREA ||i.GSM_UART_CALLBALL_GetSimIccidRequest||, CODE, READONLY, ALIGN=2

                  GSM_UART_CALLBALL_GetSimIccidRequest PROC
;;;180    // 定时器回调发送获取sim卡ICCID命令
;;;181    void GSM_UART_CALLBALL_GetSimIccidRequest(uint32 param)
000000  b570              PUSH     {r4-r6,lr}
;;;182    {
;;;183    	uint8 i;
;;;184    	
;;;185    	// 是否已经开机
;;;186    	if (!gsmUartCB.power.state)
000002  4c13              LDR      r4,|L2.80|
000004  f8940048          LDRB     r0,[r4,#0x48]  ; gsmUartCB
000008  2800              CMP      r0,#0
00000a  d020              BEQ      |L2.78|
;;;187    	{
;;;188    		return;
;;;189    	}
;;;190    	
;;;191    	// 发送获取sim的ICCID
;;;192    	GSM_UART_SendCmdGetICCID(TRUE);
00000c  2001              MOVS     r0,#1
00000e  f7fffffe          BL       GSM_UART_SendCmdGetICCID
;;;193    
;;;194    	// 由实验得知5秒内可以获取GSM模块的ICCID，超出此时间判断失败
;;;195    	if (++gsmUartCB.rcvIccidTimeCnt > (5500/GSM_UART_TX_QUERY_ICCID_TIME))
000012  f894004b          LDRB     r0,[r4,#0x4b]  ; gsmUartCB
000016  1c40              ADDS     r0,r0,#1
000018  b2c0              UXTB     r0,r0
00001a  f884004b          STRB     r0,[r4,#0x4b]
00001e  281b              CMP      r0,#0x1b
000020  d915              BLS      |L2.78|
;;;196    	{
;;;197    		gsmUartCB.rcvIccidTimeCnt = 0;
000022  2500              MOVS     r5,#0
000024  3449              ADDS     r4,r4,#0x49
000026  70a5              STRB     r5,[r4,#2]
;;;198    		gsmUartCB.rcvIccidTimeOut = TRUE;
000028  2001              MOVS     r0,#1
00002a  7060              STRB     r0,[r4,#1]
;;;199    
;;;200    		// ICCID接收失败
;;;201    		gsmUartCB.rcvIccidOK = FALSE;
00002c  f8045949          STRB     r5,[r4],#-0x49
;;;202    
;;;203    		// 关闭定时器
;;;204    		TIMER_KillTask(TIMER_ID_GSM_CONTROL);
000030  2004              MOVS     r0,#4
000032  f7fffffe          BL       TIMER_KillTask
;;;205    
;;;206    		for (i = 0; i < 20; i++)
000036  2000              MOVS     r0,#0
;;;207    		{
;;;208    			gsmUartCB.rx.iccidBuff[i] = '0';
000038  2130              MOVS     r1,#0x30
                  |L2.58|
00003a  1822              ADDS     r2,r4,r0
00003c  f8821032          STRB     r1,[r2,#0x32]
000040  1c40              ADDS     r0,r0,#1              ;206
000042  b2c0              UXTB     r0,r0                 ;206
000044  2814              CMP      r0,#0x14              ;206
000046  d3f8              BCC      |L2.58|
;;;209    		}
;;;210    		gsmUartCB.rx.iccidBuff[i] = '\0';
000048  4420              ADD      r0,r0,r4
00004a  f8805032          STRB     r5,[r0,#0x32]
                  |L2.78|
;;;211    	}
;;;212    }
00004e  bd70              POP      {r4-r6,pc}
;;;213    
                          ENDP

                  |L2.80|
                          DCD      ||.bss||

                          AREA ||i.GSM_UART_GpioOnOffControl||, CODE, READONLY, ALIGN=2

                  GSM_UART_GpioOnOffControl PROC
;;;228    
;;;229    void GSM_UART_GpioOnOffControl(uint32 param)
000000  b510              PUSH     {r4,lr}
;;;230    {
000002  4604              MOV      r4,r0
;;;231    	// 拉高释放引脚
;;;232    	GSM_ONOFF_HIGH();
000004  2200              MOVS     r2,#0
000006  f44f7100          MOV      r1,#0x200
00000a  4803              LDR      r0,|L3.24|
00000c  f7fffffe          BL       gpio_bit_write
;;;233    
;;;234    	// 上电完成
;;;235    	gsmUartCB.power.state = (BOOL)param;
000010  4802              LDR      r0,|L3.28|
000012  f8804048          STRB     r4,[r0,#0x48]
;;;236    }
000016  bd10              POP      {r4,pc}
;;;237    
                          ENDP

                  |L3.24|
                          DCD      0x40010c00
                  |L3.28|
                          DCD      ||.bss||

                          AREA ||i.GSM_UART_GsmPowerOnOff||, CODE, READONLY, ALIGN=2

                  GSM_UART_GsmPowerOnOff PROC
;;;214    // gsm模块开关机控制
;;;215    void GSM_UART_GsmPowerOnOff(uint32 param)
000000  b51c              PUSH     {r2-r4,lr}
;;;216    {
000002  4604              MOV      r4,r0
;;;217    	// 模块ON/OFF管脚一个持续时间1S以上的低电平模块即可开关机
;;;218    	GSM_ONOFF_LOW();
000004  2201              MOVS     r2,#1
000006  0251              LSLS     r1,r2,#9
000008  4806              LDR      r0,|L4.36|
00000a  f7fffffe          BL       gpio_bit_write
;;;219    
;;;220    	// 开启定时器，定时1秒即可
;;;221    	TIMER_AddTask(TIMER_ID_GSM_POWER_CONTROL,
00000e  2101              MOVS     r1,#1
000010  9100              STR      r1,[sp,#0]
000012  9101              STR      r1,[sp,#4]
000014  4623              MOV      r3,r4
000016  4a04              LDR      r2,|L4.40|
000018  f44f717a          MOV      r1,#0x3e8
00001c  2005              MOVS     r0,#5
00001e  f7fffffe          BL       TIMER_AddTask
;;;222    					1000,
;;;223    					GSM_UART_GpioOnOffControl,
;;;224    					param,
;;;225    					1,
;;;226    					ACTION_MODE_ADD_TO_QUEUE);
;;;227    }
000022  bd1c              POP      {r2-r4,pc}
;;;228    
                          ENDP

                  |L4.36|
                          DCD      0x40010c00
                  |L4.40|
                          DCD      GSM_UART_GpioOnOffControl

                          AREA ||i.GSM_UART_HwInit||, CODE, READONLY, ALIGN=2

                  GSM_UART_HwInit PROC
;;;34     // UART初始化
;;;35     void GSM_UART_HwInit(uint32 baud)
000000  b570              PUSH     {r4-r6,lr}
;;;36     {
000002  4605              MOV      r5,r0
;;;37     	// 打开时钟
;;;38     	rcu_periph_clock_enable(RCU_GPIOC);
000004  f2406004          MOV      r0,#0x604
000008  f7fffffe          BL       rcu_periph_clock_enable
;;;39     	gpio_init(GPIOC, GPIO_MODE_AF_PP, GPIO_OSPEED_2MHZ, GPIO_PIN_10);
00000c  4c30              LDR      r4,|L5.208|
00000e  f44f6380          MOV      r3,#0x400
000012  2202              MOVS     r2,#2
000014  2118              MOVS     r1,#0x18
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       gpio_init
;;;40     	
;;;41     	gpio_init(GPIOC, GPIO_MODE_IPU, GPIO_OSPEED_2MHZ, GPIO_PIN_11);
00001c  14e3              ASRS     r3,r4,#19
00001e  2202              MOVS     r2,#2
000020  2148              MOVS     r1,#0x48
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       gpio_init
;;;42     
;;;43     	// UART时钟配置
;;;44     	rcu_periph_clock_enable(RCU_UART3);
000028  f2407013          MOV      r0,#0x713
00002c  f7fffffe          BL       rcu_periph_clock_enable
;;;45     	usart_deinit(GSM_UART_TYPE_DEF);									// 复位串口
000030  4c28              LDR      r4,|L5.212|
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       usart_deinit
;;;46     		
;;;47     	// 串口配置
;;;48     	usart_baudrate_set(GSM_UART_TYPE_DEF, baud);						// 波特率
000038  4629              MOV      r1,r5
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       usart_baudrate_set
;;;49     	usart_word_length_set(GSM_UART_TYPE_DEF, USART_WL_8BIT);			// 8位数据位
000040  2100              MOVS     r1,#0
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       usart_word_length_set
;;;50     	usart_stop_bit_set(GSM_UART_TYPE_DEF, USART_STB_1BIT); 				// 一个停止位
000048  2100              MOVS     r1,#0
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       usart_stop_bit_set
;;;51     	usart_parity_config(GSM_UART_TYPE_DEF, USART_PM_NONE); 				// 无奇偶校验
000050  2100              MOVS     r1,#0
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       usart_parity_config
;;;52     	usart_hardware_flow_rts_config(GSM_UART_TYPE_DEF, USART_RTS_DISABLE); // 无硬件数据流控制
000058  2100              MOVS     r1,#0
00005a  4620              MOV      r0,r4
00005c  f7fffffe          BL       usart_hardware_flow_rts_config
;;;53     	usart_hardware_flow_cts_config(GSM_UART_TYPE_DEF, USART_CTS_DISABLE);
000060  2100              MOVS     r1,#0
000062  4620              MOV      r0,r4
000064  f7fffffe          BL       usart_hardware_flow_cts_config
;;;54     	usart_transmit_config(GSM_UART_TYPE_DEF, USART_TRANSMIT_ENABLE);	// 使能发射
000068  2108              MOVS     r1,#8
00006a  4620              MOV      r0,r4
00006c  f7fffffe          BL       usart_transmit_config
;;;55     	usart_receive_config(GSM_UART_TYPE_DEF, USART_RECEIVE_ENABLE); 		// 使能接收
000070  2104              MOVS     r1,#4
000072  4620              MOV      r0,r4
000074  f7fffffe          BL       usart_receive_config
;;;56     
;;;57     	// 中断配置
;;;58     	nvic_irq_enable(GSM_UART_IRQn_DEF, 2, 1);
000078  2201              MOVS     r2,#1
00007a  2102              MOVS     r1,#2
00007c  2034              MOVS     r0,#0x34
00007e  f7fffffe          BL       nvic_irq_enable
;;;59     
;;;60     	usart_interrupt_enable(GSM_UART_TYPE_DEF, USART_INT_RBNE); 			// 开启中断
000082  f2403105          MOV      r1,#0x305
000086  4620              MOV      r0,r4
000088  f7fffffe          BL       usart_interrupt_enable
;;;61     
;;;62     	usart_enable(GSM_UART_TYPE_DEF);									// 使能串口 
00008c  4620              MOV      r0,r4
00008e  f7fffffe          BL       usart_enable
;;;63     
;;;64     
;;;65     //====================================================================================================================
;;;66     	// 打开时钟
;;;67     	rcu_periph_clock_enable(RCU_GPIOB);
000092  f2406003          MOV      r0,#0x603
000096  f7fffffe          BL       rcu_periph_clock_enable
;;;68     	gpio_init(GPIOB, GPIO_MODE_OUT_PP, GPIO_OSPEED_2MHZ, GPIO_PIN_8);
00009a  4e0f              LDR      r6,|L5.216|
00009c  15a4              ASRS     r4,r4,#22
00009e  4623              MOV      r3,r4
0000a0  2202              MOVS     r2,#2
0000a2  2110              MOVS     r1,#0x10
0000a4  4630              MOV      r0,r6
0000a6  f7fffffe          BL       gpio_init
;;;69     	
;;;70     	gpio_init(GPIOB, GPIO_MODE_OUT_PP, GPIO_OSPEED_2MHZ, GPIO_PIN_9);
0000aa  0065              LSLS     r5,r4,#1
0000ac  462b              MOV      r3,r5
0000ae  2202              MOVS     r2,#2
0000b0  2110              MOVS     r1,#0x10
0000b2  4630              MOV      r0,r6
0000b4  f7fffffe          BL       gpio_init
;;;71     
;;;72     	// DTR唤醒
;;;73     	GSM_DTR_LOW();
0000b8  2200              MOVS     r2,#0
0000ba  4621              MOV      r1,r4
0000bc  4630              MOV      r0,r6
0000be  f7fffffe          BL       gpio_bit_write
;;;74     
;;;75     	// gsm模块上电默认关机
;;;76     	GSM_ONOFF_HIGH();
0000c2  4629              MOV      r1,r5
0000c4  4630              MOV      r0,r6
0000c6  e8bd4070          POP      {r4-r6,lr}
0000ca  2200              MOVS     r2,#0
0000cc  f7ffbffe          B.W      gpio_bit_write
;;;77     
;;;78     }
;;;79     
                          ENDP

                  |L5.208|
                          DCD      0x40011000
                  |L5.212|
                          DCD      0x40004c00
                  |L5.216|
                          DCD      0x40010c00

                          AREA ||i.GSM_UART_Init||, CODE, READONLY, ALIGN=1

                  GSM_UART_Init PROC
;;;28     // UART初始化
;;;29     void GSM_UART_Init(void)
000000  f44f30e1          MOV      r0,#0x1c200
;;;30     {
;;;31     	GSM_UART_HwInit(GSM_UART_BAUD_RATE_CONTROL);
000004  f7ffbffe          B.W      GSM_UART_HwInit
;;;32     }
;;;33     
                          ENDP


                          AREA ||i.GSM_UART_RcvSimICCID||, CODE, READONLY, ALIGN=2

                  GSM_UART_RcvSimICCID PROC
;;;136    // 接收ICCID处理
;;;137    void GSM_UART_RcvSimICCID(uint8 data)
000000  b570              PUSH     {r4-r6,lr}
;;;138    {
;;;139    	uint8 i;
;;;140    	
;;;141    	// 连续接收数据
;;;142    	gsmUartCB.rx.fifoBuff[gsmUartCB.rx.index++] = data;
000002  4c18              LDR      r4,|L7.100|
000004  f8941047          LDRB     r1,[r4,#0x47]  ; gsmUartCB
000008  1c4a              ADDS     r2,r1,#1
00000a  f8842047          STRB     r2,[r4,#0x47]
00000e  5460              STRB     r0,[r4,r1]
;;;143    
;;;144    	// 越界判断
;;;145    	if (gsmUartCB.rx.index >= sizeof(gsmUartCB.rx.fifoBuff))
000010  f8941047          LDRB     r1,[r4,#0x47]  ; gsmUartCB
000014  2500              MOVS     r5,#0
000016  2932              CMP      r1,#0x32
000018  d302              BCC      |L7.32|
;;;146    	{
;;;147    		gsmUartCB.rx.index = 0;
00001a  f8845047          STRB     r5,[r4,#0x47]
                  |L7.30|
;;;148    
;;;149    		return;
;;;150    	}
;;;151    	
;;;152    	if (data == '\n')			// 收到结束标志
;;;153    	{
;;;154    		gsmUartCB.rx.index = 0;
;;;155    		
;;;156    		// 将读到的ICCID提取出来
;;;157    		if (strstr((const char*)gsmUartCB.rx.fifoBuff, (const char*)"+ICCID: ") != NULL)
;;;158    		{
;;;159    			for (i = 0; i < 20; i++)
;;;160    			{
;;;161    				gsmUartCB.rx.iccidBuff[i] = gsmUartCB.rx.fifoBuff[i+8];
;;;162    			}
;;;163    			gsmUartCB.rx.iccidBuff[i] = '\0';
;;;164    
;;;165    			// 关闭定时器
;;;166    			TIMER_KillTask(TIMER_ID_GSM_CONTROL);
;;;167    			
;;;168    			// gsm模块开关机控制
;;;169    			GSM_UART_GsmPowerOnOff(FALSE);
;;;170    
;;;171    			// ICCID接收完成
;;;172    			gsmUartCB.rcvIccidOK = TRUE;
;;;173    
;;;174    			// 非超时所致
;;;175    			gsmUartCB.rcvIccidTimeOut = FALSE;
;;;176    		}		
;;;177    	}
;;;178    }
00001e  bd70              POP      {r4-r6,pc}
                  |L7.32|
000020  280a              CMP      r0,#0xa               ;152
000022  d1fc              BNE      |L7.30|
000024  f8845047          STRB     r5,[r4,#0x47]         ;154
000028  a10f              ADR      r1,|L7.104|
00002a  480e              LDR      r0,|L7.100|
00002c  f7fffffe          BL       strstr
000030  2800              CMP      r0,#0                 ;157
000032  d0f4              BEQ      |L7.30|
000034  2000              MOVS     r0,#0                 ;159
                  |L7.54|
000036  1821              ADDS     r1,r4,r0              ;161
000038  7a0a              LDRB     r2,[r1,#8]            ;161
00003a  f8812032          STRB     r2,[r1,#0x32]         ;161
00003e  1c40              ADDS     r0,r0,#1              ;159
000040  b2c0              UXTB     r0,r0                 ;159
000042  2814              CMP      r0,#0x14              ;159
000044  d3f7              BCC      |L7.54|
000046  4420              ADD      r0,r0,r4              ;163
000048  f8805032          STRB     r5,[r0,#0x32]         ;163
00004c  2004              MOVS     r0,#4                 ;166
00004e  f7fffffe          BL       TIMER_KillTask
000052  2000              MOVS     r0,#0                 ;169
000054  f7fffffe          BL       GSM_UART_GsmPowerOnOff
000058  2001              MOVS     r0,#1                 ;172
00005a  f8040f49          STRB     r0,[r4,#0x49]!        ;172
00005e  7065              STRB     r5,[r4,#1]            ;175
000060  bd70              POP      {r4-r6,pc}
;;;179    
                          ENDP

000062  0000              DCW      0x0000
                  |L7.100|
                          DCD      ||.bss||
                  |L7.104|
000068  2b494343          DCB      "+ICCID: ",0
00006c  49443a20
000070  00      
000071  00                DCB      0
000072  00                DCB      0
000073  00                DCB      0

                          AREA ||i.GSM_UART_SendCmdGetICCID||, CODE, READONLY, ALIGN=2

                  GSM_UART_SendCmdGetICCID PROC
;;;122    // 发送获取sim的ICCID
;;;123    void GSM_UART_SendCmdGetICCID(uint32 param)
000000  b53e              PUSH     {r1-r5,lr}
;;;124    {
;;;125    	uint8 i;
;;;126    	uint8 iccidStr[] = {'A','T','+','I','C','C','I','D','\r','\n','\0'};
000002  a00a              ADR      r0,|L8.44|
000004  e9d01200          LDRD     r1,r2,[r0,#0]
000008  6880              LDR      r0,[r0,#8]
00000a  e9cd1200          STRD     r1,r2,[sp,#0]
00000e  9002              STR      r0,[sp,#8]
;;;127    
;;;128    	// 启动阻塞式发送命令
;;;129    	for (i = 0; iccidStr[i] != '\0';)
000010  2400              MOVS     r4,#0
000012  466d              MOV      r5,sp                 ;126
000014  e005              B        |L8.34|
                  |L8.22|
;;;130    	{
;;;131    		// 填充数据，启动发送
;;;132    		GSM_UART_BC_SendData(iccidStr[i++]);
000016  4620              MOV      r0,r4
000018  1c64              ADDS     r4,r4,#1
00001a  b2e4              UXTB     r4,r4
00001c  5c28              LDRB     r0,[r5,r0]
00001e  f7fffffe          BL       GSM_UART_BC_SendData
                  |L8.34|
000022  5d28              LDRB     r0,[r5,r4]            ;129
000024  2800              CMP      r0,#0                 ;129
000026  d1f6              BNE      |L8.22|
;;;133    	}
;;;134    }
000028  bd3e              POP      {r1-r5,pc}
;;;135    
                          ENDP

00002a  0000              DCW      0x0000
                  |L8.44|
00002c  41542b49          DCB      "AT+ICCID\r\n",0
000030  43434944
000034  0d0a00  
000037  00                DCB      0

                          AREA ||i.UART3_IRQHandler||, CODE, READONLY, ALIGN=2

                  UART3_IRQHandler PROC
;;;99     *************************************************************/
;;;100    void UART3_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;101    {
;;;102    	// 判断DR是否有数据，中断接收
;;;103    	if(usart_interrupt_flag_get(GSM_UART_TYPE_DEF, USART_INT_FLAG_RBNE) != RESET) 
000002  4c0f              LDR      r4,|L9.64|
000004  490d              LDR      r1,|L9.60|
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       usart_interrupt_flag_get
00000c  b128              CBZ      r0,|L9.26|
;;;104    	{
;;;105    		uint8 rxData;
;;;106    		
;;;107    		// 接收数据
;;;108    		rxData = (uint8)usart_data_receive(GSM_UART_TYPE_DEF);
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       usart_data_receive
000014  b2c0              UXTB     r0,r0
;;;109    
;;;110    		GSM_UART_RcvSimICCID(rxData);
000016  f7fffffe          BL       GSM_UART_RcvSimICCID
                  |L9.26|
;;;111    	}
;;;112    
;;;113    	// Other USART1 interrupts handler can go here ...				 
;;;114    	if (usart_interrupt_flag_get(GSM_UART_TYPE_DEF, USART_INT_FLAG_ERR_ORERR) != RESET) //----------------------- 接收溢出中断 
00001a  490a              LDR      r1,|L9.68|
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       usart_interrupt_flag_get
000022  2800              CMP      r0,#0
000024  d008              BEQ      |L9.56|
;;;115    	{
;;;116    		usart_flag_get(GSM_UART_TYPE_DEF, USART_FLAG_ORERR); 		 //----------------------- 清除接收溢出中断标志位 
000026  2103              MOVS     r1,#3
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       usart_flag_get
;;;117    		usart_data_receive(GSM_UART_TYPE_DEF);										 //----------------------- 清空寄存器
00002e  4620              MOV      r0,r4
000030  e8bd4010          POP      {r4,lr}
000034  f7ffbffe          B.W      usart_data_receive
                  |L9.56|
;;;118    	}
;;;119    	
;;;120    }
000038  bd10              POP      {r4,pc}
;;;121    
                          ENDP

00003a  0000              DCW      0x0000
                  |L9.60|
                          DCD      0x00050305
                  |L9.64|
                          DCD      0x40004c00
                  |L9.68|
                          DCD      0x00030500

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  gsmUartCB
                          %        76

;*** Start embedded assembler ***

#line 1 "User\\GsmUart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_GsmUart_c_d24a68d9____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___9_GsmUart_c_d24a68d9____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_GsmUart_c_d24a68d9____REVSH|
#line 128
|__asm___9_GsmUart_c_d24a68d9____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
