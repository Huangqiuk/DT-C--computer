; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\spiflash.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\spiflash.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.3\Device\Include -D__MICROLIB -D__UVISION_VERSION=539 -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\spiflash.crf User\spiflash.c]
                          THUMB

                          AREA ||i.DMA0_Channel1_IRQHandler||, CODE, READONLY, ALIGN=2

                  DMA0_Channel1_IRQHandler PROC
;;;860    // DMA接收中断RX
;;;861    void DMA0_Channel1_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;862    {
;;;863        if (dma_interrupt_flag_get(DMA0, DMA_CH1, DMA_INT_FLAG_FTF))
000002  4c10              LDR      r4,|L1.68|
000004  2202              MOVS     r2,#2
000006  2101              MOVS     r1,#1
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       dma_interrupt_flag_get
00000e  2800              CMP      r0,#0
000010  d017              BEQ      |L1.66|
;;;864        {
;;;865    #if STM32_DMA_SPI_DIRECTION
;;;866            dma_interrupt_flag_clear(DMA0, DMA_CH1, DMA_INT_FLAG_G);
;;;867            dma_interrupt_flag_clear(DMA0, DMA_CH2, DMA_INT_FLAG_G);
;;;868    
;;;869            while (spi_i2s_flag_get(STM32_SPIx_NUM_DEF, I2S_FLAG_TRANS) != RESET);
;;;870    
;;;871            // 禁止SPI
;;;872            spi_disable(STM32_SPIx_NUM_DEF);
;;;873            // 关闭发送，接收DMA
;;;874            spi_dma_disable(SPI0, SPI_DMA_TRANSMIT);
;;;875            spi_dma_disable(SPI0, SPI_DMA_RECEIVE);
;;;876    
;;;877            // 禁止接收TC中断
;;;878            dma_interrupt_disable(DMA0, DMA_CH1, DMA_INT_FTF);
;;;879    
;;;880            SPI_FLASH_CS_H();  // 结束片选
;;;881    
;;;882            // 设置DMA完成标识
;;;883            spiCB.dmaFinished = TRUE;
;;;884    #else
;;;885    
;;;886            dma_interrupt_flag_clear(DMA0, DMA_CH1, DMA_INT_FLAG_FTF);
000012  2202              MOVS     r2,#2
000014  2101              MOVS     r1,#1
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       dma_interrupt_flag_clear
;;;887            // 注意:当设置模式为双线只接收或单线接收模式下，不能在此加入忙BSY的判断死等，此时该标志已失效
;;;888            // 传输的完成就已经是彻底的接收完成，无需别的动作
;;;889    
;;;890            // 禁止SPI
;;;891            spi_disable(STM32_SPIx_NUM_DEF);
00001c  480a              LDR      r0,|L1.72|
00001e  f7fffffe          BL       spi_disable
;;;892            // 关闭接收DMA
;;;893            dma_channel_disable(DMA0, DMA_CH1);
000022  2101              MOVS     r1,#1
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       dma_channel_disable
;;;894            // 禁止接收TC中断
;;;895            dma_interrupt_disable(DMA0, DMA_CH1, DMA_INT_FTF);
00002a  2202              MOVS     r2,#2
00002c  2101              MOVS     r1,#1
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       dma_interrupt_disable
;;;896    
;;;897            SPI_FLASH_CS_H();  // 结束片选
000034  2102              MOVS     r1,#2
000036  4805              LDR      r0,|L1.76|
000038  f7fffffe          BL       gpio_bit_set
;;;898    
;;;899            // 设置DMA完成标识
;;;900            spiCB.dmaFinished = TRUE;
00003c  4904              LDR      r1,|L1.80|
00003e  2001              MOVS     r0,#1
000040  7008              STRB     r0,[r1,#0]
                  |L1.66|
;;;901    #endif
;;;902        }
;;;903    }
000042  bd10              POP      {r4,pc}
;;;904    
                          ENDP

                  |L1.68|
                          DCD      0x40020000
                  |L1.72|
                          DCD      0x40003c00
                  |L1.76|
                          DCD      0x40011800
                  |L1.80|
                          DCD      ||.data||

                          AREA ||i.DMA0_Channel2_IRQHandler||, CODE, READONLY, ALIGN=2

                  DMA0_Channel2_IRQHandler PROC
;;;905    // DMA发送中断TX
;;;906    void DMA0_Channel2_IRQHandler(void)
000000  b570              PUSH     {r4-r6,lr}
;;;907    {
;;;908        if (dma_interrupt_flag_get(DMA0, DMA_CH2, DMA_INT_FLAG_FTF))
000002  4c12              LDR      r4,|L2.76|
000004  2202              MOVS     r2,#2
000006  4611              MOV      r1,r2
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       dma_interrupt_flag_get
00000e  2800              CMP      r0,#0
000010  d01a              BEQ      |L2.72|
;;;909        {
;;;910            dma_interrupt_flag_clear(DMA0, DMA_CH2, DMA_INT_FLAG_FTF);
000012  2202              MOVS     r2,#2
000014  4611              MOV      r1,r2
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       dma_interrupt_flag_clear
;;;911    
;;;912            // 注意:上面为止DMA已经将所有的数据搬运到SPI_DR，但是，但是，但是实际上SPI数据还没全发送出去
;;;913            // 因此，软件等待忙标志，确保所有数据都发送出去才能将其关闭
;;;914            while (spi_i2s_flag_get(STM32_SPIx_NUM_DEF, I2S_FLAG_TRANS) != RESET);
00001c  4d0c              LDR      r5,|L2.80|
                  |L2.30|
00001e  2180              MOVS     r1,#0x80
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       spi_i2s_flag_get
000026  2800              CMP      r0,#0
000028  d1f9              BNE      |L2.30|
;;;915    
;;;916            // 关闭发送DMA
;;;917            spi_dma_disable(SPI0, SPI_DMA_TRANSMIT);
00002a  2100              MOVS     r1,#0
00002c  4809              LDR      r0,|L2.84|
00002e  f7fffffe          BL       spi_dma_disable
;;;918            // 关闭发送TC中断
;;;919            dma_interrupt_disable(DMA0, DMA_CH2, DMA_INT_FTF);
000032  2202              MOVS     r2,#2
000034  4611              MOV      r1,r2
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       dma_interrupt_disable
;;;920    
;;;921            SPI_FLASH_CS_H();  // 结束片选
00003c  e8bd4070          POP      {r4-r6,lr}
000040  2102              MOVS     r1,#2
000042  4805              LDR      r0,|L2.88|
000044  f7ffbffe          B.W      gpio_bit_set
                  |L2.72|
;;;922        }
;;;923    }
000048  bd70              POP      {r4-r6,pc}
;;;924    
                          ENDP

00004a  0000              DCW      0x0000
                  |L2.76|
                          DCD      0x40020000
                  |L2.80|
                          DCD      0x40003c00
                  |L2.84|
                          DCD      0x40013000
                  |L2.88|
                          DCD      0x40011800

                          AREA ||i.DMAy_SPIx_Configuration||, CODE, READONLY, ALIGN=2

                  DMAy_SPIx_Configuration PROC
;;;795    // DMA硬件初始化
;;;796    void DMAy_SPIx_Configuration(void)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;797    {
;;;798        static uint16 txByte = 0xFF;    // 初始一个虚拟地址
;;;799        static uint16 rxByte = 0xFF;    // 初始一个虚拟地址
;;;800    
;;;801        // 使能时钟DMAy
;;;802        rcu_periph_clock_enable(RCU_DMA0);
000004  f44f60a0          MOV      r0,#0x500
000008  f7fffffe          BL       rcu_periph_clock_enable
;;;803    
;;;804        //SPIx Rx DMA
;;;805        dma_deinit(DMA0, DMA_CH1);
00000c  f8df90e0          LDR      r9,|L3.240|
000010  2101              MOVS     r1,#1
000012  4648              MOV      r0,r9
000014  f7fffffe          BL       dma_deinit
;;;806        dma_rx_init_struct.periph_addr  = STM32_SPIx_DR_Addr;           // 设置SPI发送外设地址(源地址)
000018  4c37              LDR      r4,|L3.248|
00001a  f8df80d8          LDR      r8,|L3.244|
00001e  f8c48000          STR      r8,[r4,#0]  ; dma_rx_init_struct
;;;807        dma_rx_init_struct.memory_addr  = (uint32)(&rxByte);            // 设置SRAM存储地址(目的地址)
000022  4836              LDR      r0,|L3.252|
000024  60a0              STR      r0,[r4,#8]  ; dma_rx_init_struct
;;;808        dma_rx_init_struct.direction    = DMA_PERIPHERAL_TO_MEMORY;     // 传输方向外设-内存
000026  2500              MOVS     r5,#0
000028  76a5              STRB     r5,[r4,#0x1a]
;;;809        dma_rx_init_struct.number       = 0;                            // 设置SPI发送长度
00002a  6125              STR      r5,[r4,#0x10]  ; dma_rx_init_struct
;;;810        dma_rx_init_struct.periph_inc   = DMA_PERIPH_INCREASE_DISABLE;  // 外设地址不增加
00002c  7625              STRB     r5,[r4,#0x18]
;;;811        dma_rx_init_struct.memory_inc   = DMA_MEMORY_INCREASE_DISABLE;  // 内存地址不增加
00002e  7665              STRB     r5,[r4,#0x19]
;;;812        dma_rx_init_struct.periph_width = DMA_PERIPHERAL_WIDTH_16BIT;   // 外设的传输数据宽度16位
000030  f44f7780          MOV      r7,#0x100
000034  6067              STR      r7,[r4,#4]  ; dma_rx_init_struct
;;;813        dma_rx_init_struct.memory_width = DMA_MEMORY_WIDTH_16BIT;       // 存储器的传输数据宽度16位
000036  00be              LSLS     r6,r7,#2
000038  60e6              STR      r6,[r4,#0xc]  ; dma_rx_init_struct
;;;814        dma_circulation_disable(DMA0, DMA_CH1);                         // 不循环
00003a  2101              MOVS     r1,#1
00003c  4648              MOV      r0,r9
00003e  f7fffffe          BL       dma_circulation_disable
;;;815        dma_rx_init_struct.priority     = DMA_PRIORITY_ULTRA_HIGH;      // 通道优先级为高
000042  f44f5040          MOV      r0,#0x3000
000046  6160              STR      r0,[r4,#0x14]  ; dma_rx_init_struct
;;;816        dma_memory_to_memory_disable(DMA0, DMA_CH1);                    // 失能内存到内存模式
000048  2101              MOVS     r1,#1
00004a  4648              MOV      r0,r9
00004c  f7fffffe          BL       dma_memory_to_memory_disable
;;;817        dma_init(DMA0, DMA_CH1, &dma_rx_init_struct);                   // 初始化DMA0
000050  4622              MOV      r2,r4
000052  2101              MOVS     r1,#1
000054  4648              MOV      r0,r9
000056  f7fffffe          BL       dma_init
;;;818    
;;;819        //SPIx Tx DMA
;;;820        dma_deinit(DMA0, DMA_CH2);
00005a  2102              MOVS     r1,#2
00005c  4648              MOV      r0,r9
00005e  f7fffffe          BL       dma_deinit
;;;821        dma_tx_init_struct.periph_addr  = STM32_SPIx_DR_Addr;           // 设置SPI发送外设地址(源地址)
000062  3c1c              SUBS     r4,r4,#0x1c
000064  f8c48000          STR      r8,[r4,#0]  ; dma_tx_init_struct
;;;822        dma_tx_init_struct.memory_addr  = (uint32)(&txByte);            // 设置SRAM存储地址(目的地址)
000068  4824              LDR      r0,|L3.252|
00006a  1e80              SUBS     r0,r0,#2
00006c  60a0              STR      r0,[r4,#8]  ; dma_tx_init_struct
;;;823        dma_tx_init_struct.direction    = DMA_MEMORY_TO_PERIPHERAL;     // 传输方向内存-外设
00006e  2001              MOVS     r0,#1
000070  76a0              STRB     r0,[r4,#0x1a]
;;;824        dma_tx_init_struct.number       = 0;                            // 设置SPI发送长度
000072  6125              STR      r5,[r4,#0x10]  ; dma_tx_init_struct
;;;825        dma_tx_init_struct.periph_inc   = DMA_PERIPH_INCREASE_DISABLE;  // 外设地址不增加
000074  7625              STRB     r5,[r4,#0x18]
;;;826        dma_tx_init_struct.memory_inc   = DMA_MEMORY_INCREASE_DISABLE;  // 内存地址不增加
000076  7665              STRB     r5,[r4,#0x19]
;;;827        dma_tx_init_struct.memory_width = DMA_MEMORY_WIDTH_16BIT;       // 存储器的传输数据宽度16位
000078  60e6              STR      r6,[r4,#0xc]  ; dma_tx_init_struct
;;;828        dma_tx_init_struct.periph_width = DMA_PERIPHERAL_WIDTH_16BIT;   // 外设的传输数据宽度16位
00007a  6067              STR      r7,[r4,#4]  ; dma_tx_init_struct
;;;829        dma_circulation_disable(DMA0, DMA_CH2);                         // 不循环
00007c  2102              MOVS     r1,#2
00007e  4648              MOV      r0,r9
000080  f7fffffe          BL       dma_circulation_disable
;;;830        dma_tx_init_struct.priority     = DMA_PRIORITY_MEDIUM;          // 中断方式
000084  00b0              LSLS     r0,r6,#2
000086  6160              STR      r0,[r4,#0x14]  ; dma_tx_init_struct
;;;831        dma_memory_to_memory_disable(DMA0, DMA_CH2);                    // 失能内存到内存模式
000088  2102              MOVS     r1,#2
00008a  4648              MOV      r0,r9
00008c  f7fffffe          BL       dma_memory_to_memory_disable
;;;832        dma_init(DMA0, DMA_CH2, &dma_tx_init_struct);                   // 初始化DMA0
000090  4622              MOV      r2,r4
000092  2102              MOVS     r1,#2
000094  4648              MOV      r0,r9
000096  f7fffffe          BL       dma_init
;;;833    
;;;834    
;;;835        // 关闭DMA发送/接收中断，清DMA标记，禁止DMA1_TX，RX的传输完成中断
;;;836        spi_dma_disable(STM32_SPIx_NUM_DEF, SPI_DMA_TRANSMIT);
00009a  4c16              LDR      r4,|L3.244|
00009c  2100              MOVS     r1,#0
00009e  3c0c              SUBS     r4,r4,#0xc
0000a0  4620              MOV      r0,r4
0000a2  f7fffffe          BL       spi_dma_disable
;;;837        spi_dma_disable(STM32_SPIx_NUM_DEF, SPI_DMA_RECEIVE);
0000a6  2101              MOVS     r1,#1
0000a8  4620              MOV      r0,r4
0000aa  f7fffffe          BL       spi_dma_disable
;;;838        dma_flag_clear(DMA0, DMA_CH1, DMA_FLAG_G);
0000ae  2201              MOVS     r2,#1
0000b0  4611              MOV      r1,r2
0000b2  4648              MOV      r0,r9
0000b4  f7fffffe          BL       dma_flag_clear
;;;839        dma_flag_clear(DMA0, DMA_CH2, DMA_FLAG_G);
0000b8  2201              MOVS     r2,#1
0000ba  2102              MOVS     r1,#2
0000bc  4648              MOV      r0,r9
0000be  f7fffffe          BL       dma_flag_clear
;;;840        dma_interrupt_disable(DMA0, DMA_CH1, DMA_INT_FTF);
0000c2  2202              MOVS     r2,#2
0000c4  2101              MOVS     r1,#1
0000c6  4648              MOV      r0,r9
0000c8  f7fffffe          BL       dma_interrupt_disable
;;;841        dma_interrupt_disable(DMA0, DMA_CH2, DMA_INT_FTF);
0000cc  2202              MOVS     r2,#2
0000ce  4611              MOV      r1,r2
0000d0  4648              MOV      r0,r9
0000d2  f7fffffe          BL       dma_interrupt_disable
;;;842    
;;;843        // 使能SPIx的DMA发送，接收请求
;;;844        spi_dma_enable(STM32_SPIx_NUM_DEF, SPI_DMA_TRANSMIT);
0000d6  2100              MOVS     r1,#0
0000d8  4620              MOV      r0,r4
0000da  f7fffffe          BL       spi_dma_enable
;;;845        spi_dma_enable(STM32_SPIx_NUM_DEF, SPI_DMA_RECEIVE);
0000de  2101              MOVS     r1,#1
0000e0  4620              MOV      r0,r4
0000e2  f7fffffe          BL       spi_dma_enable
;;;846    
;;;847        // 使能NVIC中断
;;;848        NVIC_DMAy_Configuration();
0000e6  e8bd47f0          POP      {r4-r10,lr}
0000ea  f7ffbffe          B.W      NVIC_DMAy_Configuration
;;;849    
;;;850    
;;;851    }
;;;852    
                          ENDP

0000ee  0000              DCW      0x0000
                  |L3.240|
                          DCD      0x40020000
                  |L3.244|
                          DCD      0x40003c0c
                  |L3.248|
                          DCD      ||.bss||+0x38
                  |L3.252|
                          DCD      ||.data||+0x4

                          AREA ||i.NVIC_DMAy_Configuration||, CODE, READONLY, ALIGN=1

                  NVIC_DMAy_Configuration PROC
;;;853    // 配置DMA通道中断
;;;854    static void NVIC_DMAy_Configuration(void)
000000  b510              PUSH     {r4,lr}
;;;855    {
;;;856        nvic_irq_enable(DMA0_Channel1_IRQn, 2, 0);                      // 设置中断优先级
000002  2200              MOVS     r2,#0
000004  2102              MOVS     r1,#2
000006  200c              MOVS     r0,#0xc
000008  f7fffffe          BL       nvic_irq_enable
;;;857        nvic_irq_enable(DMA0_Channel2_IRQn, 2, 0);                      // 设置中断优先级
00000c  2200              MOVS     r2,#0
00000e  2102              MOVS     r1,#2
000010  e8bd4010          POP      {r4,lr}
000014  200d              MOVS     r0,#0xd
000016  f7ffbffe          B.W      nvic_irq_enable
;;;858    }
;;;859    
                          ENDP


                          AREA ||i.SPI_FLASH_EraseBlock||, CODE, READONLY, ALIGN=2

                  SPI_FLASH_EraseBlock PROC
;;;167    // 擦除块
;;;168    void SPI_FLASH_EraseBlock(uint32 BlockAddr)
000000  b570              PUSH     {r4-r6,lr}
;;;169    {
000002  4604              MOV      r4,r0
;;;170        // 使能写入操作
;;;171        SPI_FLASH_WriteEnable();
000004  f7fffffe          BL       SPI_FLASH_WriteEnable
;;;172    
;;;173        // 片选
;;;174        SPI_FLASH_CS_L();
000008  4d0d              LDR      r5,|L5.64|
00000a  2102              MOVS     r1,#2
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       gpio_bit_reset
;;;175    
;;;176        // 发送64K擦除命令
;;;177        SPI_FLASH_SendByte(CMD_BLOCK_ERASE_64K);
000012  20d8              MOVS     r0,#0xd8
000014  f7fffffe          BL       SPI_FLASH_SendByte
;;;178    
;;;179        // 发送24位地址
;;;180        SPI_FLASH_SendByte((BlockAddr & 0xFF0000) >> 16);
000018  f3c44007          UBFX     r0,r4,#16,#8
00001c  f7fffffe          BL       SPI_FLASH_SendByte
;;;181        SPI_FLASH_SendByte((BlockAddr & 0xFF00) >> 8);
000020  f3c42007          UBFX     r0,r4,#8,#8
000024  f7fffffe          BL       SPI_FLASH_SendByte
;;;182        SPI_FLASH_SendByte(BlockAddr & 0xFF);
000028  b2e0              UXTB     r0,r4
00002a  f7fffffe          BL       SPI_FLASH_SendByte
;;;183    
;;;184        // 释放
;;;185        SPI_FLASH_CS_H();
00002e  2102              MOVS     r1,#2
000030  4628              MOV      r0,r5
000032  f7fffffe          BL       gpio_bit_set
;;;186    
;;;187        // 等待写入完成
;;;188        SPI_FLASH_WaitForWriteEnd();
000036  e8bd4070          POP      {r4-r6,lr}
00003a  f7ffbffe          B.W      SPI_FLASH_WaitForWriteEnd
;;;189    }
;;;190    
                          ENDP

00003e  0000              DCW      0x0000
                  |L5.64|
                          DCD      0x40011800

                          AREA ||i.SPI_FLASH_EraseChip||, CODE, READONLY, ALIGN=2

                  SPI_FLASH_EraseChip PROC
;;;192    // 擦除整个Flash
;;;193    void SPI_FLASH_EraseChip(void)
000000  b510              PUSH     {r4,lr}
;;;194    {
;;;195        // 使能写入操作
;;;196        SPI_FLASH_WriteEnable();
000002  f7fffffe          BL       SPI_FLASH_WriteEnable
;;;197    
;;;198        // 片选
;;;199        SPI_FLASH_CS_L();
000006  4c08              LDR      r4,|L6.40|
000008  2102              MOVS     r1,#2
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       gpio_bit_reset
;;;200    
;;;201        // 发送片擦除命令
;;;202        SPI_FLASH_SendByte(CMD_CHIP_ERASE);
000010  20c7              MOVS     r0,#0xc7
000012  f7fffffe          BL       SPI_FLASH_SendByte
;;;203    
;;;204        // 释放
;;;205        SPI_FLASH_CS_H();
000016  2102              MOVS     r1,#2
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       gpio_bit_set
;;;206    
;;;207        // 等待写入完成
;;;208        SPI_FLASH_WaitForWriteEnd();
00001e  e8bd4010          POP      {r4,lr}
000022  f7ffbffe          B.W      SPI_FLASH_WaitForWriteEnd
;;;209    }
;;;210    
                          ENDP

000026  0000              DCW      0x0000
                  |L6.40|
                          DCD      0x40011800

                          AREA ||i.SPI_FLASH_EraseRoom||, CODE, READONLY, ALIGN=1

                  SPI_FLASH_EraseRoom PROC
;;;528    // 擦除指定空间 先擦扇区再擦块再擦扇区
;;;529    void SPI_FLASH_EraseRoom(uint32 Addr, uint32 size)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;530    {
000004  4605              MOV      r5,r0
000006  4688              MOV      r8,r1
;;;531    
;;;532        uint16 blockStartNum = 0;       // 块号
;;;533        uint16 blockCount = 0;          // 需要擦除块的数量
;;;534        uint16 blockSectorOffset = 0;   // 块内扇区偏移量
;;;535        uint16 i;
;;;536    
;;;537        blockSectorOffset = Addr / SPI_FLASH_SECTOR_SIZE % SPI_FLASH_BLOCK_PER_16SECTORS;
000008  f3c53003          UBFX     r0,r5,#12,#4
;;;538    
;;;539        if (blockSectorOffset)          // 擦除扇区在块内存在偏移量
00000c  2800              CMP      r0,#0
00000e  d004              BEQ      |L7.26|
;;;540        {
;;;541            blockStartNum = Addr / SPI_FLASH_BLOCK_SIZE + 1;
000010  2101              MOVS     r1,#1
000012  eb014115          ADD      r1,r1,r5,LSR #16
000016  b28e              UXTH     r6,r1
000018  e000              B        |L7.28|
                  |L7.26|
;;;542        }
;;;543        else                            // 擦除开始地址等于块的起始地址，不存在偏移
;;;544        {
;;;545            blockStartNum = Addr / SPI_FLASH_BLOCK_SIZE;
00001a  0c2e              LSRS     r6,r5,#16
                  |L7.28|
;;;546        }
;;;547    
;;;548        // 擦除起始块内扇区偏移
;;;549        for (i = 0; i < SPI_FLASH_BLOCK_PER_16SECTORS - blockSectorOffset; i++)
00001c  2400              MOVS     r4,#0
00001e  f1c00710          RSB      r7,r0,#0x10
000022  e008              B        |L7.54|
                  |L7.36|
;;;550        {
;;;551            SPI_FLASH_EraseSector((Addr / SPI_FLASH_SECTOR_SIZE + i) * SPI_FLASH_SECTOR_SIZE);
000024  eb043015          ADD      r0,r4,r5,LSR #12
000028  0300              LSLS     r0,r0,#12
00002a  f7fffffe          BL       SPI_FLASH_EraseSector
;;;552    
;;;553            WDT_Clear();
00002e  f7fffffe          BL       WDT_Clear
000032  1c64              ADDS     r4,r4,#1              ;549
000034  b2a4              UXTH     r4,r4                 ;549
                  |L7.54|
000036  42a7              CMP      r7,r4                 ;549
000038  dcf4              BGT      |L7.36|
;;;554        }
;;;555    
;;;556        // 计算出需要擦除的块的数量
;;;557        blockCount = ((size / SPI_FLASH_SECTOR_SIZE) - (SPI_FLASH_BLOCK_PER_16SECTORS - blockSectorOffset)) / SPI_FLASH_BLOCK_PER_16SECTORS;
00003a  ebc73718          RSB      r7,r7,r8,LSR #12
00003e  f3c7150f          UBFX     r5,r7,#4,#16
;;;558    
;;;559        // 擦除块
;;;560        for (i = 0; i < blockCount; i++)
000042  2400              MOVS     r4,#0
000044  e007              B        |L7.86|
                  |L7.70|
;;;561        {
;;;562            SPI_FLASH_EraseBlock((blockStartNum + i) * SPI_FLASH_BLOCK_SIZE);
000046  1930              ADDS     r0,r6,r4
000048  0400              LSLS     r0,r0,#16
00004a  f7fffffe          BL       SPI_FLASH_EraseBlock
;;;563    
;;;564            WDT_Clear();
00004e  f7fffffe          BL       WDT_Clear
000052  1c64              ADDS     r4,r4,#1              ;560
000054  b2a4              UXTH     r4,r4                 ;560
                  |L7.86|
000056  42ac              CMP      r4,r5                 ;560
000058  d3f5              BCC      |L7.70|
;;;565        }
;;;566    
;;;567        // 擦除剩余扇区,剩余的扇区不满一个块
;;;568        for (i = 0; i < ((size / SPI_FLASH_SECTOR_SIZE) - (SPI_FLASH_BLOCK_PER_16SECTORS - blockSectorOffset)) % SPI_FLASH_BLOCK_PER_16SECTORS; i++)
00005a  2400              MOVS     r4,#0
;;;569        {
;;;570            SPI_FLASH_EraseSector((blockStartNum + blockCount) * SPI_FLASH_BLOCK_SIZE + i * SPI_FLASH_SECTOR_SIZE);
00005c  1970              ADDS     r0,r6,r5
00005e  0405              LSLS     r5,r0,#16
000060  f007060f          AND      r6,r7,#0xf            ;568
000064  e007              B        |L7.118|
                  |L7.102|
000066  eb053004          ADD      r0,r5,r4,LSL #12
00006a  f7fffffe          BL       SPI_FLASH_EraseSector
;;;571    
;;;572            WDT_Clear();
00006e  f7fffffe          BL       WDT_Clear
000072  1c64              ADDS     r4,r4,#1              ;568
000074  b2a4              UXTH     r4,r4                 ;568
                  |L7.118|
000076  42a6              CMP      r6,r4                 ;568
000078  d8f5              BHI      |L7.102|
;;;573        }
;;;574    }
00007a  e8bd81f0          POP      {r4-r8,pc}
;;;575    
                          ENDP


                          AREA ||i.SPI_FLASH_EraseSector||, CODE, READONLY, ALIGN=2

                  SPI_FLASH_EraseSector PROC
;;;143    // 擦除扇区
;;;144    void SPI_FLASH_EraseSector(uint32 SectorAddr)
000000  b570              PUSH     {r4-r6,lr}
;;;145    {
000002  4604              MOV      r4,r0
;;;146        // 使能写入操作
;;;147        SPI_FLASH_WriteEnable();
000004  f7fffffe          BL       SPI_FLASH_WriteEnable
;;;148    
;;;149        // 片选
;;;150        SPI_FLASH_CS_L();
000008  4d0d              LDR      r5,|L8.64|
00000a  2102              MOVS     r1,#2
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       gpio_bit_reset
;;;151    
;;;152        // 发送扇区擦除命令
;;;153        SPI_FLASH_SendByte(CMD_SECTOR_ERASE_4K);
000012  2020              MOVS     r0,#0x20
000014  f7fffffe          BL       SPI_FLASH_SendByte
;;;154    
;;;155        // 发送24位地址
;;;156        SPI_FLASH_SendByte((SectorAddr & 0xFF0000) >> 16);
000018  f3c44007          UBFX     r0,r4,#16,#8
00001c  f7fffffe          BL       SPI_FLASH_SendByte
;;;157        SPI_FLASH_SendByte((SectorAddr & 0xFF00) >> 8);
000020  f3c42007          UBFX     r0,r4,#8,#8
000024  f7fffffe          BL       SPI_FLASH_SendByte
;;;158        SPI_FLASH_SendByte(SectorAddr & 0xFF);
000028  b2e0              UXTB     r0,r4
00002a  f7fffffe          BL       SPI_FLASH_SendByte
;;;159    
;;;160        // 释放
;;;161        SPI_FLASH_CS_H();
00002e  2102              MOVS     r1,#2
000030  4628              MOV      r0,r5
000032  f7fffffe          BL       gpio_bit_set
;;;162    
;;;163        // 等待写入完成
;;;164        SPI_FLASH_WaitForWriteEnd();
000036  e8bd4070          POP      {r4-r6,lr}
00003a  f7ffbffe          B.W      SPI_FLASH_WaitForWriteEnd
;;;165    }
;;;166    
                          ENDP

00003e  0000              DCW      0x0000
                  |L8.64|
                          DCD      0x40011800

                          AREA ||i.SPI_FLASH_ReadArray||, CODE, READONLY, ALIGN=2

                  SPI_FLASH_ReadArray PROC
;;;374    // 读取数据至指定缓冲区，数据个数最大可以为整片容量
;;;375    void SPI_FLASH_ReadArray(uint8 *pBuffer, uint32 ReadAddr, uint16 NumByteToRead)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;376    {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
;;;377        // 指针非空判断
;;;378        if (NULL == pBuffer)
00000a  2c00              CMP      r4,#0
00000c  d023              BEQ      |L9.86|
;;;379        {
;;;380            return;
;;;381        }
;;;382    
;;;383        // 要读取的数据量为0，退出
;;;384        if (0 == NumByteToRead)
00000e  2d00              CMP      r5,#0
000010  d021              BEQ      |L9.86|
;;;385        {
;;;386            return;
;;;387        }
;;;388    
;;;389        // 片选
;;;390        SPI_FLASH_CS_L();
000012  4e12              LDR      r6,|L9.92|
000014  2102              MOVS     r1,#2
000016  4630              MOV      r0,r6
000018  f7fffffe          BL       gpio_bit_reset
;;;391    
;;;392        // 发送读取命令
;;;393        SPI_FLASH_SendByte(CMD_READ_BYTE);
00001c  2003              MOVS     r0,#3
00001e  f7fffffe          BL       SPI_FLASH_SendByte
;;;394    
;;;395        // 发送24位起始地址
;;;396        SPI_FLASH_SendByte((ReadAddr & 0xFF0000) >> 16);
000022  f3c74007          UBFX     r0,r7,#16,#8
000026  f7fffffe          BL       SPI_FLASH_SendByte
;;;397        SPI_FLASH_SendByte((ReadAddr & 0xFF00) >> 8);
00002a  f3c72007          UBFX     r0,r7,#8,#8
00002e  f7fffffe          BL       SPI_FLASH_SendByte
;;;398        SPI_FLASH_SendByte(ReadAddr & 0xFF);
000032  b2f8              UXTB     r0,r7
000034  f7fffffe          BL       SPI_FLASH_SendByte
;;;399    
;;;400        // 一直读取完指定的数量为止
;;;401        while (NumByteToRead--)
000038  e004              B        |L9.68|
                  |L9.58|
;;;402        {
;;;403            // 读取一个字节
;;;404            *(pBuffer++) = SPI_FLASH_SendByte(0);
00003a  2000              MOVS     r0,#0
00003c  f7fffffe          BL       SPI_FLASH_SendByte
000040  f8040b01          STRB     r0,[r4],#1
                  |L9.68|
000044  1e6d              SUBS     r5,r5,#1              ;401
000046  b2ad              UXTH     r5,r5                 ;401
000048  d2f7              BCS      |L9.58|
;;;405        }
;;;406    
;;;407        // 释放
;;;408        SPI_FLASH_CS_H();
00004a  4630              MOV      r0,r6
00004c  e8bd41f0          POP      {r4-r8,lr}
000050  2102              MOVS     r1,#2
000052  f7ffbffe          B.W      gpio_bit_set
                  |L9.86|
;;;409    }
000056  e8bd81f0          POP      {r4-r8,pc}
;;;410    
                          ENDP

00005a  0000              DCW      0x0000
                  |L9.92|
                          DCD      0x40011800

                          AREA ||i.SPI_FLASH_ReadByte||, CODE, READONLY, ALIGN=1

                  SPI_FLASH_ReadByte PROC
;;;346    
;;;347    uint8 SPI_FLASH_ReadByte(uint32 ReadAddr)
000000  b508              PUSH     {r3,lr}
;;;348    {
;;;349        uint8 buff[4];
;;;350    
;;;351        SPI_FLASH_ReadArray(buff, ReadAddr, 4);
000002  4601              MOV      r1,r0
000004  2204              MOVS     r2,#4
000006  4668              MOV      r0,sp
000008  f7fffffe          BL       SPI_FLASH_ReadArray
;;;352    
;;;353        return buff[0];
00000c  f89d0000          LDRB     r0,[sp,#0]
;;;354    }
000010  bd08              POP      {r3,pc}
;;;355    
                          ENDP


                          AREA ||i.SPI_FLASH_ReadChipID||, CODE, READONLY, ALIGN=2

                  SPI_FLASH_ReadChipID PROC
;;;411    // 读取芯片ID
;;;412    uint16 SPI_FLASH_ReadChipID(void)
000000  b570              PUSH     {r4-r6,lr}
;;;413    {
;;;414        uint16 W25xXX_ID = 0;
;;;415    
;;;416        // 使能写入操作
;;;417        SPI_FLASH_WriteEnable();
000002  f7fffffe          BL       SPI_FLASH_WriteEnable
;;;418    
;;;419        SPI_FLASH_CS_L();
000006  4d11              LDR      r5,|L11.76|
000008  2102              MOVS     r1,#2
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       gpio_bit_reset
;;;420    
;;;421        // 发送读取ID命令
;;;422        SPI_FLASH_SendByte(CMD_MANUFACT_DEVICE_ID);
000010  2090              MOVS     r0,#0x90
000012  f7fffffe          BL       SPI_FLASH_SendByte
;;;423    
;;;424        // 发送24位的地址
;;;425        SPI_FLASH_SendByte(0x00);   // dummy
000016  2000              MOVS     r0,#0
000018  f7fffffe          BL       SPI_FLASH_SendByte
;;;426        SPI_FLASH_SendByte(0x00);   // dummy
00001c  2000              MOVS     r0,#0
00001e  f7fffffe          BL       SPI_FLASH_SendByte
;;;427        SPI_FLASH_SendByte(0x00);   // 0x00
000022  2000              MOVS     r0,#0
000024  f7fffffe          BL       SPI_FLASH_SendByte
;;;428    
;;;429        // 读取返回的16位值
;;;430        W25xXX_ID = SPI_FLASH_SendByte(0xFF);   // 高8位数据
000028  20ff              MOVS     r0,#0xff
00002a  f7fffffe          BL       SPI_FLASH_SendByte
;;;431        W25xXX_ID <<= 8;
00002e  f64f71ff          MOV      r1,#0xffff
000032  ea012400          AND      r4,r1,r0,LSL #8
;;;432        W25xXX_ID += SPI_FLASH_SendByte(0xFF);  // 底8位数据
000036  20ff              MOVS     r0,#0xff
000038  f7fffffe          BL       SPI_FLASH_SendByte
00003c  4420              ADD      r0,r0,r4
00003e  b284              UXTH     r4,r0
;;;433    
;;;434        SPI_FLASH_CS_H();
000040  2102              MOVS     r1,#2
000042  4628              MOV      r0,r5
000044  f7fffffe          BL       gpio_bit_set
;;;435    
;;;436        return W25xXX_ID;
000048  4620              MOV      r0,r4
;;;437    }
00004a  bd70              POP      {r4-r6,pc}
;;;438    
                          ENDP

                  |L11.76|
                          DCD      0x40011800

                          AREA ||i.SPI_FLASH_ReadHalfWord||, CODE, READONLY, ALIGN=1

                  SPI_FLASH_ReadHalfWord PROC
;;;355    
;;;356    uint16 SPI_FLASH_ReadHalfWord(uint32 ReadAddr)
000000  b508              PUSH     {r3,lr}
;;;357    {
;;;358        uint8 buff[4];
;;;359    
;;;360        SPI_FLASH_ReadArray(buff, ReadAddr, 4);
000002  4601              MOV      r1,r0
000004  2204              MOVS     r2,#4
000006  4668              MOV      r0,sp
000008  f7fffffe          BL       SPI_FLASH_ReadArray
;;;361    
;;;362        return ((uint16)buff[0] << 8) + buff[1];
00000c  f89d0001          LDRB     r0,[sp,#1]
000010  f89d1000          LDRB     r1,[sp,#0]
000014  eb002001          ADD      r0,r0,r1,LSL #8
000018  b280              UXTH     r0,r0
;;;363    }
00001a  bd08              POP      {r3,pc}
;;;364    
                          ENDP


                          AREA ||i.SPI_FLASH_ReadWord||, CODE, READONLY, ALIGN=1

                  SPI_FLASH_ReadWord PROC
;;;364    
;;;365    uint32 SPI_FLASH_ReadWord(uint32 ReadAddr)
000000  b508              PUSH     {r3,lr}
;;;366    {
;;;367        uint8 buff[4];
;;;368    
;;;369        SPI_FLASH_ReadArray(buff, ReadAddr, 4);
000002  4601              MOV      r1,r0
000004  2204              MOVS     r2,#4
000006  4668              MOV      r0,sp
000008  f7fffffe          BL       SPI_FLASH_ReadArray
;;;370    
;;;371        return ((uint32)buff[0] << 24) + ((uint32)buff[1] << 16) + ((uint32)buff[2] << 8) + buff[3];
00000c  f89d0003          LDRB     r0,[sp,#3]
000010  f89d1000          LDRB     r1,[sp,#0]
000014  f89d2002          LDRB     r2,[sp,#2]
000018  eb006001          ADD      r0,r0,r1,LSL #24
00001c  f89d1001          LDRB     r1,[sp,#1]
000020  0409              LSLS     r1,r1,#16
000022  eb012102          ADD      r1,r1,r2,LSL #8
000026  4408              ADD      r0,r0,r1
;;;372    }
000028  bd08              POP      {r3,pc}
;;;373    
                          ENDP


                          AREA ||i.SPI_FLASH_SendByte||, CODE, READONLY, ALIGN=2

                  SPI_FLASH_SendByte PROC
;;;439    // 发送一个字节
;;;440    uint8 SPI_FLASH_SendByte(uint8 byte)
000000  b570              PUSH     {r4-r6,lr}
;;;441    {
000002  4605              MOV      r5,r0
;;;442        // 发送寄存器不为空，等待
;;;443        uint16 spiRetryTime = 0;
000004  2400              MOVS     r4,#0
;;;444    
;;;445        while (spi_i2s_flag_get(STM32_SPIx_NUM_DEF, SPI_STAT_TBE) == RESET)
000006  4e14              LDR      r6,|L14.88|
000008  e006              B        |L14.24|
                  |L14.10|
;;;446        {
;;;447            if (spiRetryTime++ > SPI_FLASH_RETRY_READ_TIME)
00000a  4620              MOV      r0,r4
00000c  1c64              ADDS     r4,r4,#1
00000e  b2a4              UXTH     r4,r4
000010  28c8              CMP      r0,#0xc8
000012  d901              BLS      |L14.24|
;;;448            {
;;;449                return 0x00;
000014  2000              MOVS     r0,#0
;;;450            }
;;;451        }
;;;452        // 发送
;;;453        spi_i2s_data_transmit(STM32_SPIx_NUM_DEF, byte);
;;;454    
;;;455        // 接收寄存器为空，等待
;;;456        spiRetryTime = 0;
;;;457        while (spi_i2s_flag_get(STM32_SPIx_NUM_DEF, SPI_STAT_RBNE) == RESET)
;;;458        {
;;;459            if (spiRetryTime++ > SPI_FLASH_RETRY_READ_TIME)
;;;460            {
;;;461                return 0x00;
;;;462            }
;;;463        }
;;;464    
;;;465        // 返回接收到的值
;;;466        return spi_i2s_data_receive(STM32_SPIx_NUM_DEF);
;;;467    }
000016  bd70              POP      {r4-r6,pc}
                  |L14.24|
000018  2102              MOVS     r1,#2                 ;445
00001a  4630              MOV      r0,r6                 ;445
00001c  f7fffffe          BL       spi_i2s_flag_get
000020  2800              CMP      r0,#0                 ;445
000022  d0f2              BEQ      |L14.10|
000024  4629              MOV      r1,r5                 ;453
000026  4635              MOV      r5,r6                 ;453
000028  4628              MOV      r0,r5                 ;453
00002a  f7fffffe          BL       spi_i2s_data_transmit
00002e  2400              MOVS     r4,#0                 ;456
000030  e006              B        |L14.64|
                  |L14.50|
000032  4620              MOV      r0,r4                 ;459
000034  1c64              ADDS     r4,r4,#1              ;459
000036  b2a4              UXTH     r4,r4                 ;459
000038  28c8              CMP      r0,#0xc8              ;459
00003a  d901              BLS      |L14.64|
00003c  2000              MOVS     r0,#0                 ;461
00003e  bd70              POP      {r4-r6,pc}
                  |L14.64|
000040  2101              MOVS     r1,#1                 ;457
000042  4628              MOV      r0,r5                 ;457
000044  f7fffffe          BL       spi_i2s_flag_get
000048  2800              CMP      r0,#0                 ;457
00004a  d0f2              BEQ      |L14.50|
00004c  4628              MOV      r0,r5                 ;466
00004e  f7fffffe          BL       spi_i2s_data_receive
000052  b2c0              UXTB     r0,r0                 ;466
000054  bd70              POP      {r4-r6,pc}
;;;468    
                          ENDP

000056  0000              DCW      0x0000
                  |L14.88|
                          DCD      0x40003c00

                          AREA ||i.SPI_FLASH_WaitForWriteEnd||, CODE, READONLY, ALIGN=2

                  SPI_FLASH_WaitForWriteEnd PROC
;;;505    // 等待写入操作完成
;;;506    void SPI_FLASH_WaitForWriteEnd(void)
000000  b510              PUSH     {r4,lr}
;;;507    {
;;;508        uint8 flashstatus = 0;
;;;509    
;;;510        // 片选
;;;511        SPI_FLASH_CS_L();
000002  4c09              LDR      r4,|L15.40|
000004  2102              MOVS     r1,#2
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       gpio_bit_reset
;;;512    
;;;513        // 发送读取状态寄存器1的命令
;;;514        SPI_FLASH_SendByte(CMD_READ_STATUS_REGISTER1);
00000c  2005              MOVS     r0,#5
00000e  f7fffffe          BL       SPI_FLASH_SendByte
                  |L15.18|
;;;515    
;;;516        // 写入中，持续等待
;;;517        do
;;;518        {
;;;519            // 发送一个假数据，即可产生SPI时钟
;;;520            flashstatus = SPI_FLASH_SendByte(0);
000012  2000              MOVS     r0,#0
000014  f7fffffe          BL       SPI_FLASH_SendByte
;;;521        }
;;;522        while ((flashstatus & BUSY_FLAG) == BUSY_FLAG);
000018  07c0              LSLS     r0,r0,#31
00001a  d1fa              BNE      |L15.18|
;;;523    
;;;524        // 释放
;;;525        SPI_FLASH_CS_H();
00001c  4620              MOV      r0,r4
00001e  e8bd4010          POP      {r4,lr}
000022  2102              MOVS     r1,#2
000024  f7ffbffe          B.W      gpio_bit_set
;;;526    }
;;;527    
                          ENDP

                  |L15.40|
                          DCD      0x40011800

                          AREA ||i.SPI_FLASH_WriteArray||, CODE, READONLY, ALIGN=1

                  SPI_FLASH_WriteArray PROC
;;;250    // 将指定缓冲区的数据写入指定开始地址的区域
;;;251    void SPI_FLASH_WriteArray(uint8 *pBuffer, uint32 WriteAddr, uint16 NumByteToWrite)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;252    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4690              MOV      r8,r2
;;;253        uint8 NumOfPage = 0, NumOfRestByte = 0, StartAddrOffset = 0, RestSpace = 0, temp = 0;
;;;254    
;;;255        // 指针非空判断
;;;256        if (NULL == pBuffer)
00000a  2d00              CMP      r5,#0
00000c  d065              BEQ      |L16.218|
;;;257        {
;;;258            return;
;;;259        }
;;;260    
;;;261        // 写入数据量为0，退出
;;;262        if (0 == NumByteToWrite)
00000e  f1b80f00          CMP      r8,#0
000012  d062              BEQ      |L16.218|
;;;263        {
;;;264            return ;
;;;265        }
;;;266    
;;;267        StartAddrOffset = WriteAddr % SPI_FLASH_PAGE_SIZE;
000014  b2f0              UXTB     r0,r6
;;;268        RestSpace = SPI_FLASH_PAGE_SIZE - StartAddrOffset;
000016  4241              RSBS     r1,r0,#0
000018  b2cf              UXTB     r7,r1
;;;269        NumOfPage =  NumByteToWrite / SPI_FLASH_PAGE_SIZE;
00001a  ea4f2418          LSR      r4,r8,#8
;;;270        NumOfRestByte = NumByteToWrite % SPI_FLASH_PAGE_SIZE;
00001e  f0080aff          AND      r10,r8,#0xff
;;;271    
;;;272        // 起始地址刚好位于当前页的起点
;;;273        if (StartAddrOffset == 0)
;;;274        {
;;;275            // 数据量不足一页，直接写入
;;;276            if (NumOfPage == 0)
;;;277            {
;;;278                SPI_FLASH_WritePage(pBuffer, WriteAddr, NumByteToWrite);
;;;279            }
;;;280            // 数据量超出一页
;;;281            else
;;;282            {
;;;283                // 整页的部分，直接写入整页
;;;284                while (NumOfPage--)
;;;285                {
;;;286                    // 在当前页写满
;;;287                    SPI_FLASH_WritePage(pBuffer, WriteAddr, SPI_FLASH_PAGE_SIZE);
000022  f44f7980          MOV      r9,#0x100
000026  b190              CBZ      r0,|L16.78|
000028  b2f0              UXTB     r0,r6                 ;267
00002a  4240              RSBS     r0,r0,#0              ;268
00002c  b2c0              UXTB     r0,r0                 ;268
;;;288    
;;;289                    WriteAddr += SPI_FLASH_PAGE_SIZE;
;;;290                    pBuffer += SPI_FLASH_PAGE_SIZE;
;;;291                }
;;;292    
;;;293                // 写入不足一页的部分
;;;294                SPI_FLASH_WritePage(pBuffer, WriteAddr, NumOfRestByte);
;;;295            }
;;;296        }
;;;297        // 起始地址不是当前页的起点，即从中间插入写入
;;;298        else
;;;299        {
;;;300            // 数据量不足一页，直接写入
;;;301            if (NumOfPage == 0)
;;;302            {
;;;303                // 要写入的数据量超过了当前页剩余空间，则分开两次写入
;;;304                if (NumOfRestByte > RestSpace)
;;;305                {
;;;306                    // 先将当前页填满
;;;307                    temp = NumOfRestByte - RestSpace;
;;;308    
;;;309                    SPI_FLASH_WritePage(pBuffer, WriteAddr, RestSpace);
;;;310                    WriteAddr +=  RestSpace;
00002e  eb060b00          ADD      r11,r6,r0
000032  b33c              CBZ      r4,|L16.132|
;;;311                    pBuffer += RestSpace;
;;;312    
;;;313                    // 再将剩余的数据写入下一页
;;;314                    SPI_FLASH_WritePage(pBuffer, WriteAddr, temp);
;;;315                }
;;;316                // 要写入的数据量不超过当前页的剩余空间，则直接写入
;;;317                else
;;;318                {
;;;319                    SPI_FLASH_WritePage(pBuffer, WriteAddr, NumByteToWrite);
;;;320                }
;;;321            }
;;;322            // 数据量超过一页
;;;323            else
;;;324            {
;;;325                // 先将当前页填满
;;;326                SPI_FLASH_WritePage(pBuffer, WriteAddr, RestSpace);
000034  463a              MOV      r2,r7
000036  4631              MOV      r1,r6
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       SPI_FLASH_WritePage
;;;327                WriteAddr +=  RestSpace;
00003e  465e              MOV      r6,r11
;;;328                pBuffer += RestSpace;
000040  443d              ADD      r5,r5,r7
;;;329    
;;;330                // 剩余的数据，写入起点就是下一页的起点了，和上面第一种情况相同的处理
;;;331                NumByteToWrite -= RestSpace;
000042  eba80007          SUB      r0,r8,r7
000046  b280              UXTH     r0,r0
;;;332                NumOfPage =  NumByteToWrite / SPI_FLASH_PAGE_SIZE;
000048  0a04              LSRS     r4,r0,#8
;;;333                NumOfRestByte = NumByteToWrite % SPI_FLASH_PAGE_SIZE;
00004a  b2c7              UXTB     r7,r0
;;;334    
;;;335                while (NumOfPage--)
00004c  e03b              B        |L16.198|
                  |L16.78|
00004e  b97c              CBNZ     r4,|L16.112|
000050  4642              MOV      r2,r8                 ;278
000052  4631              MOV      r1,r6                 ;278
000054  4628              MOV      r0,r5                 ;278
000056  e8bd5ff0          POP      {r4-r12,lr}           ;278
00005a  f7ffbffe          B.W      SPI_FLASH_WritePage
                  |L16.94|
00005e  464a              MOV      r2,r9                 ;287
000060  4631              MOV      r1,r6                 ;287
000062  4628              MOV      r0,r5                 ;287
000064  f7fffffe          BL       SPI_FLASH_WritePage
000068  f5067680          ADD      r6,r6,#0x100          ;289
00006c  f5057580          ADD      r5,r5,#0x100          ;290
                  |L16.112|
000070  1e64              SUBS     r4,r4,#1              ;284
000072  b2e4              UXTB     r4,r4                 ;284
000074  d2f3              BCS      |L16.94|
000076  4652              MOV      r2,r10                ;294
000078  4631              MOV      r1,r6                 ;294
00007a  4628              MOV      r0,r5                 ;294
00007c  e8bd5ff0          POP      {r4-r12,lr}           ;294
000080  f7ffbffe          B.W      SPI_FLASH_WritePage
                  |L16.132|
000084  45ba              CMP      r10,r7                ;304
000086  d90e              BLS      |L16.166|
000088  ebaa0007          SUB      r0,r10,r7             ;307
00008c  b2c4              UXTB     r4,r0                 ;307
00008e  463a              MOV      r2,r7                 ;309
000090  4631              MOV      r1,r6                 ;309
000092  4628              MOV      r0,r5                 ;309
000094  f7fffffe          BL       SPI_FLASH_WritePage
000098  4659              MOV      r1,r11                ;310
00009a  19e8              ADDS     r0,r5,r7              ;311
00009c  4622              MOV      r2,r4                 ;314
00009e  e8bd5ff0          POP      {r4-r12,lr}           ;314
0000a2  f7ffbffe          B.W      SPI_FLASH_WritePage
                  |L16.166|
0000a6  4642              MOV      r2,r8                 ;319
0000a8  4631              MOV      r1,r6                 ;319
0000aa  4628              MOV      r0,r5                 ;319
0000ac  e8bd5ff0          POP      {r4-r12,lr}           ;319
0000b0  f7ffbffe          B.W      SPI_FLASH_WritePage
                  |L16.180|
;;;336                {
;;;337                    SPI_FLASH_WritePage(pBuffer, WriteAddr, SPI_FLASH_PAGE_SIZE);
0000b4  464a              MOV      r2,r9
0000b6  4631              MOV      r1,r6
0000b8  4628              MOV      r0,r5
0000ba  f7fffffe          BL       SPI_FLASH_WritePage
;;;338                    WriteAddr += SPI_FLASH_PAGE_SIZE;
0000be  f5067680          ADD      r6,r6,#0x100
;;;339                    pBuffer += SPI_FLASH_PAGE_SIZE;
0000c2  f5057580          ADD      r5,r5,#0x100
                  |L16.198|
0000c6  1e64              SUBS     r4,r4,#1              ;335
0000c8  b2e4              UXTB     r4,r4                 ;335
0000ca  d2f3              BCS      |L16.180|
;;;340                }
;;;341    
;;;342                SPI_FLASH_WritePage(pBuffer, WriteAddr, NumOfRestByte);
0000cc  463a              MOV      r2,r7
0000ce  4631              MOV      r1,r6
0000d0  4628              MOV      r0,r5
0000d2  e8bd5ff0          POP      {r4-r12,lr}
0000d6  f7ffbffe          B.W      SPI_FLASH_WritePage
                  |L16.218|
;;;343            }
;;;344        }
;;;345    }
0000da  e8bd9ff0          POP      {r4-r12,pc}
;;;346    
                          ENDP


                          AREA ||i.SPI_FLASH_WriteByte||, CODE, READONLY, ALIGN=1

                  SPI_FLASH_WriteByte PROC
;;;659    
;;;660    void SPI_FLASH_WriteByte(uint32 WriteAddr, uint8 data)
000000  b508              PUSH     {r3,lr}
;;;661    {
;;;662        uint8 buff[4];
;;;663    
;;;664        buff[0] = (data) & 0xFF;
000002  f88d1000          STRB     r1,[sp,#0]
;;;665    
;;;666        SPI_FLASH_WriteWithErase(buff, WriteAddr, 1);
000006  4601              MOV      r1,r0
000008  2201              MOVS     r2,#1
00000a  4668              MOV      r0,sp
00000c  f7fffffe          BL       SPI_FLASH_WriteWithErase
;;;667    }
000010  bd08              POP      {r3,pc}
;;;668    
                          ENDP


                          AREA ||i.SPI_FLASH_WriteEnable||, CODE, READONLY, ALIGN=2

                  SPI_FLASH_WriteEnable PROC
;;;469    // 发送写入使能指令
;;;470    void SPI_FLASH_WriteEnable(void)
000000  b510              PUSH     {r4,lr}
;;;471    {
;;;472        // 片选
;;;473        SPI_FLASH_CS_L();
000002  4c07              LDR      r4,|L18.32|
000004  2102              MOVS     r1,#2
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       gpio_bit_reset
;;;474    
;;;475        // 发送写入使能指令
;;;476        SPI_FLASH_SendByte(CMD_WRITE_ENABLE);
00000c  2006              MOVS     r0,#6
00000e  f7fffffe          BL       SPI_FLASH_SendByte
;;;477    
;;;478        // 释放
;;;479        SPI_FLASH_CS_H();
000012  4620              MOV      r0,r4
000014  e8bd4010          POP      {r4,lr}
000018  2102              MOVS     r1,#2
00001a  f7ffbffe          B.W      gpio_bit_set
;;;480    }
;;;481    
                          ENDP

00001e  0000              DCW      0x0000
                  |L18.32|
                          DCD      0x40011800

                          AREA ||i.SPI_FLASH_WriteHalfWord||, CODE, READONLY, ALIGN=1

                  SPI_FLASH_WriteHalfWord PROC
;;;668    
;;;669    void SPI_FLASH_WriteHalfWord(uint32 WriteAddr, uint16 data)
000000  b508              PUSH     {r3,lr}
;;;670    {
;;;671        uint8 buff[4];
;;;672    
;;;673        buff[0] = (data >> 8) & 0xFF;
000002  0a0a              LSRS     r2,r1,#8
000004  f88d2000          STRB     r2,[sp,#0]
;;;674        buff[1] = (data) & 0xFF;
000008  f88d1001          STRB     r1,[sp,#1]
;;;675    
;;;676        SPI_FLASH_WriteWithErase(buff, WriteAddr, 2);
00000c  4601              MOV      r1,r0
00000e  2202              MOVS     r2,#2
000010  4668              MOV      r0,sp
000012  f7fffffe          BL       SPI_FLASH_WriteWithErase
;;;677    }
000016  bd08              POP      {r3,pc}
;;;678    
                          ENDP


                          AREA ||i.SPI_FLASH_WritePage||, CODE, READONLY, ALIGN=2

                  SPI_FLASH_WritePage PROC
;;;211    // 页写入
;;;212    void SPI_FLASH_WritePage(uint8 *pBuffer, uint32 WriteAddr, uint16 NumByteToWrite)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;213    {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
;;;214        // 写入数据量为0，退出
;;;215        if (0 == NumByteToWrite)
00000a  2c00              CMP      r4,#0
00000c  d024              BEQ      |L20.88|
;;;216        {
;;;217            return ;
;;;218        }
;;;219    
;;;220        // 使能写入操作
;;;221        SPI_FLASH_WriteEnable();
00000e  f7fffffe          BL       SPI_FLASH_WriteEnable
;;;222    
;;;223        // 片选
;;;224        SPI_FLASH_CS_L();
000012  4e12              LDR      r6,|L20.92|
000014  2102              MOVS     r1,#2
000016  4630              MOV      r0,r6
000018  f7fffffe          BL       gpio_bit_reset
;;;225    
;;;226        // 发送页写入命令
;;;227        SPI_FLASH_SendByte(CMD_PAGE_WRITE);
00001c  2002              MOVS     r0,#2
00001e  f7fffffe          BL       SPI_FLASH_SendByte
;;;228    
;;;229        // 写入24位起始地址
;;;230        SPI_FLASH_SendByte((WriteAddr >> 16) & 0xFF);
000022  f3c74007          UBFX     r0,r7,#16,#8
000026  f7fffffe          BL       SPI_FLASH_SendByte
;;;231        SPI_FLASH_SendByte((WriteAddr >> 8) & 0xFF);
00002a  f3c72007          UBFX     r0,r7,#8,#8
00002e  f7fffffe          BL       SPI_FLASH_SendByte
;;;232        SPI_FLASH_SendByte(WriteAddr & 0xFF);
000032  b2f8              UXTB     r0,r7
000034  f7fffffe          BL       SPI_FLASH_SendByte
;;;233    
;;;234        // 连续写入指定数量的数据
;;;235        while (NumByteToWrite--)
000038  e003              B        |L20.66|
                  |L20.58|
;;;236        {
;;;237            /// 写入一个字节
;;;238            SPI_FLASH_SendByte(*pBuffer);
00003a  7828              LDRB     r0,[r5,#0]
00003c  f7fffffe          BL       SPI_FLASH_SendByte
;;;239    
;;;240            pBuffer++;
000040  1c6d              ADDS     r5,r5,#1
                  |L20.66|
000042  1e64              SUBS     r4,r4,#1              ;235
000044  b2a4              UXTH     r4,r4                 ;235
000046  d2f8              BCS      |L20.58|
;;;241        }
;;;242    
;;;243        // 释放
;;;244        SPI_FLASH_CS_H();
000048  2102              MOVS     r1,#2
00004a  4630              MOV      r0,r6
00004c  f7fffffe          BL       gpio_bit_set
;;;245    
;;;246        // 等待写入完成
;;;247        SPI_FLASH_WaitForWriteEnd();
000050  e8bd41f0          POP      {r4-r8,lr}
000054  f7ffbffe          B.W      SPI_FLASH_WaitForWriteEnd
                  |L20.88|
;;;248    }
000058  e8bd81f0          POP      {r4-r8,pc}
;;;249    
                          ENDP

                  |L20.92|
                          DCD      0x40011800

                          AREA ||i.SPI_FLASH_WriteStatus||, CODE, READONLY, ALIGN=2

                  SPI_FLASH_WriteStatus PROC
;;;482    // 写状态寄存器
;;;483    void SPI_FLASH_WriteStatus(uint8 data)
000000  b570              PUSH     {r4-r6,lr}
;;;484    {
000002  4605              MOV      r5,r0
;;;485        // 片选
;;;486        SPI_FLASH_CS_L();
000004  4c0d              LDR      r4,|L21.60|
000006  2102              MOVS     r1,#2
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       gpio_bit_reset
;;;487    
;;;488        // 允许写状态寄存器
;;;489        SPI_FLASH_SendByte(CMD_WRITE_REGISTER_ENABLE);
00000e  2050              MOVS     r0,#0x50
000010  f7fffffe          BL       SPI_FLASH_SendByte
;;;490    
;;;491        // 释放
;;;492        SPI_FLASH_CS_H();
000014  2102              MOVS     r1,#2
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       gpio_bit_set
;;;493    
;;;494        // 片选
;;;495        SPI_FLASH_CS_L();
00001c  2102              MOVS     r1,#2
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       gpio_bit_reset
;;;496    
;;;497        // 允许写状态寄存器
;;;498        SPI_FLASH_SendByte(CMD_WRITE_STATUS_REGISTER);
000024  2001              MOVS     r0,#1
000026  f7fffffe          BL       SPI_FLASH_SendByte
;;;499        SPI_FLASH_SendByte(data);
00002a  4628              MOV      r0,r5
00002c  f7fffffe          BL       SPI_FLASH_SendByte
;;;500    
;;;501        // 释放
;;;502        SPI_FLASH_CS_H();
000030  4620              MOV      r0,r4
000032  e8bd4070          POP      {r4-r6,lr}
000036  2102              MOVS     r1,#2
000038  f7ffbffe          B.W      gpio_bit_set
;;;503    }
;;;504    
                          ENDP

                  |L21.60|
                          DCD      0x40011800

                          AREA ||i.SPI_FLASH_WriteWithCheck||, CODE, READONLY, ALIGN=1

                  SPI_FLASH_WriteWithCheck PROC
;;;577    // 数据写入接口，返回写入结果
;;;578    BOOL SPI_FLASH_WriteWithCheck(uint8 *pBuffer, uint32 WriteAddr, uint16 NumByteToWrite)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;579    {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4617              MOV      r7,r2
;;;580        uint16 NumOfInt = 0;
;;;581        uint16 NumOfRestByte = 0;
;;;582        uint16 i;
;;;583        uint8 *pFlashBuff = NULL;               // 保存读取扇区的数据
;;;584    
;;;585        if ((NULL == pBuffer) || (0 == NumByteToWrite))
00000a  2c00              CMP      r4,#0
00000c  d00e              BEQ      |L22.44|
00000e  b16f              CBZ      r7,|L22.44|
;;;586        {
;;;587            return FALSE;
;;;588        }
;;;589    
;;;590        // 申请4096Byte空间保存扇区数据
;;;591        pFlashBuff = (uint8 *)malloc(SPI_FLASH_SECTOR_SIZE);
000010  f44f5980          MOV      r9,#0x1000
000014  4648              MOV      r0,r9
000016  f7fffffe          BL       malloc
00001a  4605              MOV      r5,r0
;;;592    
;;;593        // 指针非空判断
;;;594        if (NULL == pFlashBuff)
00001c  0028              MOVS     r0,r5
00001e  d008              BEQ      |L22.50|
;;;595        {
;;;596            return FALSE;
;;;597        }
;;;598    
;;;599        if (NumByteToWrite > SPI_FLASH_SECTOR_SIZE)
000020  454f              CMP      r7,r9
000022  d941              BLS      |L22.168|
;;;600        {
;;;601            NumOfInt = NumByteToWrite / SPI_FLASH_SECTOR_SIZE;
000024  0b3e              LSRS     r6,r7,#12
;;;602            NumOfRestByte = NumByteToWrite % SPI_FLASH_SECTOR_SIZE;
000026  f3c7070b          UBFX     r7,r7,#0,#12
;;;603    
;;;604            while (NumOfInt--)
00002a  e020              B        |L22.110|
                  |L22.44|
00002c  2000              MOVS     r0,#0                 ;587
                  |L22.46|
;;;605            {
;;;606                // 执行写入
;;;607                SPI_FLASH_WriteArray(pBuffer, WriteAddr, SPI_FLASH_SECTOR_SIZE);
;;;608                // 执行读取
;;;609                SPI_FLASH_ReadArray(pFlashBuff, WriteAddr, SPI_FLASH_SECTOR_SIZE);
;;;610    
;;;611                for (i = 0; i < SPI_FLASH_SECTOR_SIZE; i++)
;;;612                {
;;;613                    if (pBuffer[i] != pFlashBuff[i])
;;;614                    {
;;;615                        free(pFlashBuff);
;;;616                        return FALSE;
;;;617                    }
;;;618                }
;;;619    
;;;620                WriteAddr += SPI_FLASH_SECTOR_SIZE;
;;;621                pBuffer += SPI_FLASH_SECTOR_SIZE;
;;;622            }
;;;623    
;;;624            // 执行写入
;;;625            SPI_FLASH_WriteArray(pBuffer, WriteAddr, NumOfRestByte);
;;;626            // 执行读取
;;;627            SPI_FLASH_ReadArray(pFlashBuff, WriteAddr, NumOfRestByte);
;;;628    
;;;629            for (i = 0; i < NumOfRestByte; i++)
;;;630            {
;;;631                if (pBuffer[i] != pFlashBuff[i])
;;;632                {
;;;633                    free(pFlashBuff);
;;;634                    return FALSE;
;;;635                }
;;;636            }
;;;637        }
;;;638        else
;;;639        {
;;;640            // 执行写入
;;;641            SPI_FLASH_WriteArray(pBuffer, WriteAddr, NumByteToWrite);
;;;642            // 执行读取
;;;643            SPI_FLASH_ReadArray(pFlashBuff, WriteAddr, NumByteToWrite);
;;;644    
;;;645            for (i = 0; i < NumByteToWrite; i++)
;;;646            {
;;;647                if (pBuffer[i] != pFlashBuff[i])
;;;648                {
;;;649                    free(pFlashBuff);
;;;650                    return FALSE;
;;;651                }
;;;652            }
;;;653        }
;;;654    
;;;655        free(pFlashBuff);
;;;656    
;;;657        return TRUE;
;;;658    }
00002e  e8bd87f0          POP      {r4-r10,pc}
                  |L22.50|
000032  2000              MOVS     r0,#0                 ;596
000034  e7fb              B        |L22.46|
                  |L22.54|
000036  464a              MOV      r2,r9                 ;607
000038  4641              MOV      r1,r8                 ;607
00003a  4620              MOV      r0,r4                 ;607
00003c  f7fffffe          BL       SPI_FLASH_WriteArray
000040  464a              MOV      r2,r9                 ;609
000042  4641              MOV      r1,r8                 ;609
000044  4628              MOV      r0,r5                 ;609
000046  f7fffffe          BL       SPI_FLASH_ReadArray
00004a  2000              MOVS     r0,#0                 ;611
                  |L22.76|
00004c  5c21              LDRB     r1,[r4,r0]            ;613
00004e  5c2a              LDRB     r2,[r5,r0]            ;613
000050  4291              CMP      r1,r2                 ;613
000052  d004              BEQ      |L22.94|
000054  4628              MOV      r0,r5                 ;615
000056  f7fffffe          BL       free
00005a  2000              MOVS     r0,#0                 ;616
00005c  e7e7              B        |L22.46|
                  |L22.94|
00005e  1c40              ADDS     r0,r0,#1              ;611
000060  b280              UXTH     r0,r0                 ;611
000062  4548              CMP      r0,r9                 ;611
000064  d3f2              BCC      |L22.76|
000066  f5085880          ADD      r8,r8,#0x1000         ;620
00006a  f5045480          ADD      r4,r4,#0x1000         ;621
                  |L22.110|
00006e  1e76              SUBS     r6,r6,#1              ;604
000070  b2b6              UXTH     r6,r6                 ;604
000072  d2e0              BCS      |L22.54|
000074  463a              MOV      r2,r7                 ;625
000076  4641              MOV      r1,r8                 ;625
000078  4620              MOV      r0,r4                 ;625
00007a  f7fffffe          BL       SPI_FLASH_WriteArray
00007e  463a              MOV      r2,r7                 ;627
000080  4641              MOV      r1,r8                 ;627
000082  4628              MOV      r0,r5                 ;627
000084  f7fffffe          BL       SPI_FLASH_ReadArray
000088  2000              MOVS     r0,#0                 ;629
00008a  e00a              B        |L22.162|
                  |L22.140|
00008c  5c21              LDRB     r1,[r4,r0]            ;631
00008e  5c2a              LDRB     r2,[r5,r0]            ;631
000090  4291              CMP      r1,r2                 ;631
000092  d004              BEQ      |L22.158|
000094  4628              MOV      r0,r5                 ;633
000096  f7fffffe          BL       free
00009a  2000              MOVS     r0,#0                 ;634
00009c  e7c7              B        |L22.46|
                  |L22.158|
00009e  1c40              ADDS     r0,r0,#1              ;629
0000a0  b280              UXTH     r0,r0                 ;629
                  |L22.162|
0000a2  42b8              CMP      r0,r7                 ;629
0000a4  d3f2              BCC      |L22.140|
0000a6  e018              B        |L22.218|
                  |L22.168|
0000a8  463a              MOV      r2,r7                 ;641
0000aa  4641              MOV      r1,r8                 ;641
0000ac  4620              MOV      r0,r4                 ;641
0000ae  f7fffffe          BL       SPI_FLASH_WriteArray
0000b2  463a              MOV      r2,r7                 ;643
0000b4  4641              MOV      r1,r8                 ;643
0000b6  4628              MOV      r0,r5                 ;643
0000b8  f7fffffe          BL       SPI_FLASH_ReadArray
0000bc  2000              MOVS     r0,#0                 ;645
0000be  e00a              B        |L22.214|
                  |L22.192|
0000c0  5c21              LDRB     r1,[r4,r0]            ;647
0000c2  5c2a              LDRB     r2,[r5,r0]            ;647
0000c4  4291              CMP      r1,r2                 ;647
0000c6  d004              BEQ      |L22.210|
0000c8  4628              MOV      r0,r5                 ;649
0000ca  f7fffffe          BL       free
0000ce  2000              MOVS     r0,#0                 ;650
0000d0  e7ad              B        |L22.46|
                  |L22.210|
0000d2  1c40              ADDS     r0,r0,#1              ;645
0000d4  b280              UXTH     r0,r0                 ;645
                  |L22.214|
0000d6  42b8              CMP      r0,r7                 ;645
0000d8  d3f2              BCC      |L22.192|
                  |L22.218|
0000da  4628              MOV      r0,r5                 ;655
0000dc  f7fffffe          BL       free
0000e0  2001              MOVS     r0,#1                 ;657
0000e2  e7a4              B        |L22.46|
;;;659    
                          ENDP


                          AREA ||i.SPI_FLASH_WriteWithErase||, CODE, READONLY, ALIGN=1

                  SPI_FLASH_WriteWithErase PROC
;;;704    **********************************************************************/
;;;705    void SPI_FLASH_WriteWithErase(uint8 *pBuffer, uint32 WriteAddr, uint16 NumByteToWrite)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;706    {
000004  4607              MOV      r7,r0
000006  468b              MOV      r11,r1
000008  4615              MOV      r5,r2
;;;707        uint32 sectPos = 0;
;;;708        uint16 sectOff = 0;
;;;709        uint16 sectRemain = 0;
;;;710        uint16 i = 0;
;;;711        uint8 *pFlashBuff = NULL;               // 保存读取扇区的数据
;;;712    
;;;713        if ((NULL == pBuffer) || (0 == NumByteToWrite))
00000a  2f00              CMP      r7,#0
00000c  d054              BEQ      |L23.184|
00000e  2d00              CMP      r5,#0
000010  d052              BEQ      |L23.184|
;;;714        {
;;;715            return;
;;;716        }
;;;717    
;;;718        // 申请4096Byte空间保存扇区数据
;;;719        pFlashBuff = (uint8 *)malloc(SPI_FLASH_SECTOR_SIZE);
000012  f44f5080          MOV      r0,#0x1000
000016  f7fffffe          BL       malloc
00001a  4680              MOV      r8,r0
;;;720    
;;;721        if (NULL == pFlashBuff)
00001c  ea5f0008          MOVS     r0,r8
000020  d04a              BEQ      |L23.184|
;;;722        {
;;;723            return;
;;;724        }
;;;725    
;;;726        sectPos = WriteAddr / SPI_FLASH_SECTOR_SIZE; // 扇区地址
000022  ea4f391b          LSR      r9,r11,#12
;;;727        sectOff = WriteAddr % SPI_FLASH_SECTOR_SIZE; // 在扇区内的偏移
000026  f3cb060b          UBFX     r6,r11,#0,#12
;;;728        sectRemain = SPI_FLASH_SECTOR_SIZE - sectOff; // 扇区剩余空间大小
00002a  f5c65480          RSB      r4,r6,#0x1000
;;;729    
;;;730        if (NumByteToWrite <= sectRemain)
00002e  42a5              CMP      r5,r4
000030  d838              BHI      |L23.164|
;;;731        {
;;;732            sectRemain = NumByteToWrite;            // 不大于4096个字节
000032  462c              MOV      r4,r5
000034  e036              B        |L23.164|
                  |L23.54|
;;;733        }
;;;734    
;;;735        while (1)
;;;736        {
;;;737            // 读出整个扇区的内容
;;;738            SPI_FLASH_ReadArray(pFlashBuff, sectPos * SPI_FLASH_SECTOR_SIZE, SPI_FLASH_SECTOR_SIZE);
;;;739    
;;;740            for (i = 0; i < sectRemain; i++)    // 校验数据
;;;741            {
;;;742                if (pFlashBuff[sectOff + i] != 0xFF)
000036  1831              ADDS     r1,r6,r0
000038  f8181001          LDRB     r1,[r8,r1]
00003c  29ff              CMP      r1,#0xff
00003e  d103              BNE      |L23.72|
000040  1c40              ADDS     r0,r0,#1              ;740
000042  b280              UXTH     r0,r0                 ;740
                  |L23.68|
000044  42a0              CMP      r0,r4                 ;740
000046  d3f6              BCC      |L23.54|
                  |L23.72|
;;;743                {
;;;744                    break;                      // 需要擦除
;;;745                }
;;;746            }
;;;747    
;;;748            if (i < sectRemain)                 // 需要擦除
000048  42a0              CMP      r0,r4
00004a  d213              BCS      |L23.116|
;;;749            {
;;;750                SPI_FLASH_EraseSector(sectPos * SPI_FLASH_SECTOR_SIZE);// 擦除这个扇区
00004c  4650              MOV      r0,r10
00004e  f7fffffe          BL       SPI_FLASH_EraseSector
;;;751    
;;;752                // 复制
;;;753                for (i = 0; i < sectRemain; i++)
000052  2000              MOVS     r0,#0
000054  e005              B        |L23.98|
                  |L23.86|
;;;754                {
;;;755                    pFlashBuff[i + sectOff] = pBuffer[i];
000056  1982              ADDS     r2,r0,r6
000058  5c39              LDRB     r1,[r7,r0]
00005a  f8081002          STRB     r1,[r8,r2]
00005e  1c40              ADDS     r0,r0,#1              ;753
000060  b280              UXTH     r0,r0                 ;753
                  |L23.98|
000062  42a0              CMP      r0,r4                 ;753
000064  d3f7              BCC      |L23.86|
;;;756                }
;;;757    
;;;758                // 写入整个扇区
;;;759                SPI_FLASH_WriteArray(pFlashBuff, sectPos * SPI_FLASH_SECTOR_SIZE, SPI_FLASH_SECTOR_SIZE);
000066  4651              MOV      r1,r10
000068  f44f5280          MOV      r2,#0x1000
00006c  4640              MOV      r0,r8
00006e  f7fffffe          BL       SPI_FLASH_WriteArray
000072  e004              B        |L23.126|
                  |L23.116|
;;;760            }
;;;761            else
;;;762            {
;;;763                // 写已经擦除了的,直接写入扇区剩余区间.
;;;764                SPI_FLASH_WriteArray(pBuffer, WriteAddr, sectRemain);
000074  4622              MOV      r2,r4
000076  4659              MOV      r1,r11
000078  4638              MOV      r0,r7
00007a  f7fffffe          BL       SPI_FLASH_WriteArray
                  |L23.126|
;;;765            }
;;;766    
;;;767            if (NumByteToWrite == sectRemain)
00007e  42a5              CMP      r5,r4
000080  d104              BNE      |L23.140|
;;;768            {
;;;769                break;                                  // 写入结束了
;;;770            }
;;;771            else                                        // 写入未结束
;;;772            {
;;;773                sectPos++;                              // 扇区地址增1
;;;774                sectOff = 0;                            // 偏移位置为0
;;;775    
;;;776                pBuffer += sectRemain;                  // 指针偏移
;;;777                WriteAddr += sectRemain;                // 写地址偏移
;;;778                NumByteToWrite -= sectRemain;           // 字节数递减
;;;779    
;;;780                if (NumByteToWrite > SPI_FLASH_SECTOR_SIZE)
;;;781                {
;;;782                    sectRemain = SPI_FLASH_SECTOR_SIZE; // 下一个扇区还是写不完
;;;783                }
;;;784                else
;;;785                {
;;;786                    sectRemain = NumByteToWrite;        // 下一个扇区可以写完了
;;;787                }
;;;788            }
;;;789        }
;;;790    
;;;791        // 释放数据缓存区
;;;792        free(pFlashBuff);
000082  4640              MOV      r0,r8
000084  e8bd5ff0          POP      {r4-r12,lr}
000088  f7ffbffe          B.W      free
                  |L23.140|
00008c  f1090901          ADD      r9,r9,#1              ;773
000090  2600              MOVS     r6,#0                 ;774
000092  4427              ADD      r7,r7,r4              ;776
000094  44a3              ADD      r11,r11,r4            ;777
000096  1b28              SUBS     r0,r5,r4              ;778
000098  b285              UXTH     r5,r0                 ;778
00009a  f44f5480          MOV      r4,#0x1000            ;780
00009e  42a5              CMP      r5,r4                 ;780
0000a0  d800              BHI      |L23.164|
0000a2  462c              MOV      r4,r5                 ;786
                  |L23.164|
0000a4  ea4f3a09          LSL      r10,r9,#12            ;738
0000a8  f44f5280          MOV      r2,#0x1000            ;738
0000ac  4651              MOV      r1,r10                ;738
0000ae  4640              MOV      r0,r8                 ;738
0000b0  f7fffffe          BL       SPI_FLASH_ReadArray
0000b4  2000              MOVS     r0,#0                 ;740
0000b6  e7c5              B        |L23.68|
                  |L23.184|
;;;793    }
0000b8  e8bd9ff0          POP      {r4-r12,pc}
;;;794    
                          ENDP


                          AREA ||i.SPI_FLASH_WriteWord||, CODE, READONLY, ALIGN=1

                  SPI_FLASH_WriteWord PROC
;;;678    
;;;679    void SPI_FLASH_WriteWord(uint32 WriteAddr, uint32 data)
000000  b508              PUSH     {r3,lr}
;;;680    {
;;;681        uint8 buff[4];
;;;682    
;;;683        buff[0] = (data >> 24) & 0xFF;
000002  0e0a              LSRS     r2,r1,#24
000004  f88d2000          STRB     r2,[sp,#0]
;;;684        buff[1] = (data >> 16) & 0xFF;
000008  0c0a              LSRS     r2,r1,#16
00000a  f88d2001          STRB     r2,[sp,#1]
;;;685        buff[2] = (data >> 8) & 0xFF;
00000e  0a0a              LSRS     r2,r1,#8
000010  f88d2002          STRB     r2,[sp,#2]
;;;686        buff[3] = (data) & 0xFF;
000014  f88d1003          STRB     r1,[sp,#3]
;;;687    
;;;688        SPI_FLASH_WriteWithErase(buff, WriteAddr, 4);
000018  4601              MOV      r1,r0
00001a  2204              MOVS     r2,#4
00001c  4668              MOV      r0,sp
00001e  f7fffffe          BL       SPI_FLASH_WriteWithErase
;;;689    }
000022  bd08              POP      {r3,pc}
;;;690    
                          ENDP


                          AREA ||i.SPIx_ConfigureWorkMode||, CODE, READONLY, ALIGN=2

                  SPIx_ConfigureWorkMode PROC
;;;1143   // 配置SPI工作模式
;;;1144   void SPIx_ConfigureWorkMode(uint16 SpiDirection, uint16 SpiDataSize)
000000  b510              PUSH     {r4,lr}
;;;1145   {
;;;1146       spi_init_struct.trans_mode = SpiDirection;
000002  4a08              LDR      r2,|L25.36|
000004  6050              STR      r0,[r2,#4]  ; spi_init_struct
;;;1147       spi_init_struct.frame_size = SpiDataSize;
000006  6091              STR      r1,[r2,#8]  ; spi_init_struct
;;;1148   
;;;1149       spi_init(STM32_SPIx_NUM_DEF, &spi_init_struct);
000008  4c07              LDR      r4,|L25.40|
00000a  4611              MOV      r1,r2
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       spi_init
;;;1150       spi_enable(STM32_SPIx_NUM_DEF);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       spi_enable
;;;1151   
;;;1152       spi_i2s_data_receive(STM32_SPIx_NUM_DEF);
000018  4620              MOV      r0,r4
00001a  e8bd4010          POP      {r4,lr}
00001e  f7ffbffe          B.W      spi_i2s_data_receive
;;;1153   }
;;;1154   
                          ENDP

000022  0000              DCW      0x0000
                  |L25.36|
                          DCD      ||.bss||
                  |L25.40|
                          DCD      0x40003c00

                          AREA ||i.SPIx_DMAy_Read||, CODE, READONLY, ALIGN=2

                  SPIx_DMAy_Read PROC
;;;997    // 启动DMA方式读取
;;;998    void SPIx_DMAy_Read(uint32 srcAddr, uint32 dstAddr, uint16 count)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;999    {
000004  4605              MOV      r5,r0
000006  468b              MOV      r11,r1
000008  4690              MOV      r8,r2
;;;1000   #if STM32_DMA_SPI_DIRECTION
;;;1001   
;;;1002       static uint16 txByte = 0xFF; // dummy
;;;1003   
;;;1004       // 入参检查
;;;1005       if (0 == count)
;;;1006       {
;;;1007           return;
;;;1008       }
;;;1009   
;;;1010       // 设置DMA完成标识
;;;1011       spiCB.dmaFinished = FALSE;
;;;1012       // 先禁止SPI以修改配置
;;;1013       spi_disable(STM32_SPIx_NUM_DEF);
;;;1014   
;;;1015       // 关闭DMA
;;;1016       dma_channel_disable(DMA0, DMA_CH1);
;;;1017       dma_channel_disable(DMA1, DMA_CH2);
;;;1018   
;;;1019       // 先配置全双工模式，以在DMA之前写命令和地址
;;;1020       spi_init_struct.trans_mode = SPI_TRANSMODE_FULLDUPLEX;
;;;1021       spi_init_struct.frame_size = SPI_FRAMESIZE_8BIT;
;;;1022       spi_init(STM32_SPIx_NUM_DEF, &spi_init_struct);
;;;1023   
;;;1024       // 重新配置接收地址以及接收数量
;;;1025       dma_rx_init_struct.memory_inc = DMA_MEMORY_INCREASE_ENABLE; // 内存地址增量变化
;;;1026       dma_rx_init_struct.memory_addr = (uint32)dstAddr;
;;;1027       dma_rx_init_struct.number = count;
;;;1028       dma_init(DMA0, DMA_CH1, &dma_rx_init_struct);
;;;1029   
;;;1030       // 发送为dummy
;;;1031       dma_tx_init_struct.memory_inc = DMA_MEMORY_INCREASE_DISABLE;// 内存地址增量不变化
;;;1032       dma_tx_init_struct.memory_addr = (uint32)(&txByte);
;;;1033       dma_tx_init_struct.number = count;
;;;1034       dma_init(DMA0, DMA_CH2, &dma_tx_init_struct);
;;;1035   
;;;1036       // 使能SPI，使用双工模式发送命令和地址
;;;1037       spi_enable(STM32_SPIx_NUM_DEF);
;;;1038   
;;;1039       // 片选
;;;1040       SPI_FLASH_CS_L();
;;;1041       // 发送读取命令
;;;1042       SPI_FLASH_SendByte(CMD_READ_BYTE);
;;;1043       // 发送24位起始地址
;;;1044       SPI_FLASH_SendByte((srcAddr & 0xFF0000) >> 16);
;;;1045       SPI_FLASH_SendByte((srcAddr & 0xFF00) >> 8);
;;;1046       SPI_FLASH_SendByte(srcAddr & 0xFF);
;;;1047       // 接收前读一次数据DR，保证接收缓冲区为空
;;;1048       spi_i2s_data_receive(STM32_SPIx_NUM_DEF);
;;;1049       // 再次禁止SPI以修改配置全双工模式
;;;1050       spi_disable(STM32_SPIx_NUM_DEF);
;;;1051   
;;;1052       // 配置为全双工16位模式
;;;1053       spi_init_struct.trans_mode = SPI_TRANSMODE_FULLDUPLEX;
;;;1054       spi_init_struct.frame_size = SPI_FRAMESIZE_16BIT;
;;;1055       spi_init(STM32_SPIx_NUM_DEF, &spi_init_struct);
;;;1056   
;;;1057       // 清DMA标记
;;;1058       dma_flag_clear(DMA0, DMA_CH1, DMA_FLAG_G);
;;;1059       dma_flag_clear(DMA0, DMA_CH2, DMA_FLAG_G);
;;;1060   
;;;1061       // 使能RX的TC中断
;;;1062       dma_interrupt_enable(DMA0, DMA_CH1, DMA_INT_FTF);
;;;1063   
;;;1064       // 重新使能SPI，SCK时钟立刻开始输出，开始发送接收数据
;;;1065       spi_enable(STM32_SPIx_NUM_DEF);
;;;1066       spi_i2s_data_receive(STM32_SPIx_NUM_DEF);
;;;1067   
;;;1068       // 开启DMA通道DMA1_Channel2，DMA1_Channel3
;;;1069       dma_channel_enable(DMA0, DMA_CH1);
;;;1070       dma_channel_enable(DMA1, DMA_CH2);
;;;1071   
;;;1072       while (!spiCB.dmaFinished);
;;;1073   
;;;1074       // DMA读完后，模式重新复位
;;;1075       SPIx_ConfigureWorkMode(SPI_TRANSMODE_FULLDUPLEX, SPI_FRAMESIZE_8BIT);
;;;1076   
;;;1077   #else
;;;1078   
;;;1079       // 入参检查
;;;1080       if (0 == count)
00000a  f1b80f00          CMP      r8,#0
00000e  d061              BEQ      |L26.212|
;;;1081       {
;;;1082           return ;
;;;1083       }
;;;1084   
;;;1085       // 设置DMA完成标识
;;;1086       spiCB.dmaFinished = FALSE;
000010  4c31              LDR      r4,|L26.216|
000012  2700              MOVS     r7,#0
000014  7027              STRB     r7,[r4,#0]
;;;1087   
;;;1088       // 先禁止SPI以修改配置
;;;1089       spi_disable(STM32_SPIx_NUM_DEF);
000016  f8df90c4          LDR      r9,|L26.220|
00001a  4648              MOV      r0,r9
00001c  f7fffffe          BL       spi_disable
;;;1090   
;;;1091       // 关闭DMA
;;;1092       dma_channel_disable(DMA0, DMA_CH1);
000020  f8dfa0bc          LDR      r10,|L26.224|
000024  2101              MOVS     r1,#1
000026  4650              MOV      r0,r10
000028  f7fffffe          BL       dma_channel_disable
;;;1093   
;;;1094       // 先配置全双工模式，以在DMA之前写命令和地址
;;;1095       spi_init_struct.trans_mode = SPI_TRANSMODE_FULLDUPLEX;
00002c  4e2d              LDR      r6,|L26.228|
00002e  6077              STR      r7,[r6,#4]  ; spi_init_struct
;;;1096       spi_init_struct.frame_size = SPI_FRAMESIZE_8BIT;
000030  60b7              STR      r7,[r6,#8]  ; spi_init_struct
;;;1097       spi_init(STM32_SPIx_NUM_DEF, &spi_init_struct);
000032  4631              MOV      r1,r6
000034  4648              MOV      r0,r9
000036  f7fffffe          BL       spi_init
;;;1098   
;;;1099       // 重新配置接收地址以及接收数量
;;;1100       dma_rx_init_struct.memory_inc = DMA_MEMORY_INCREASE_ENABLE; // 内存地址增量变化
00003a  f1060038          ADD      r0,r6,#0x38
00003e  2101              MOVS     r1,#1
000040  7641              STRB     r1,[r0,#0x19]
;;;1101       dma_rx_init_struct.memory_addr = (uint32)dstAddr;
000042  f8c0b008          STR      r11,[r0,#8]  ; dma_rx_init_struct
;;;1102       dma_rx_init_struct.number = count;
000046  f8c08010          STR      r8,[r0,#0x10]  ; dma_rx_init_struct
;;;1103       dma_init(DMA0, DMA_CH1, &dma_rx_init_struct);
00004a  4602              MOV      r2,r0
00004c  4650              MOV      r0,r10
00004e  f7fffffe          BL       dma_init
;;;1104   
;;;1105       // 使能SPI，使用双工模式发送命令和地址
;;;1106       spi_enable(STM32_SPIx_NUM_DEF);
000052  4648              MOV      r0,r9
000054  f7fffffe          BL       spi_enable
;;;1107       // 片选
;;;1108       SPI_FLASH_CS_L();
000058  2102              MOVS     r1,#2
00005a  4823              LDR      r0,|L26.232|
00005c  f7fffffe          BL       gpio_bit_reset
;;;1109       // 发送读取命令
;;;1110       SPI_FLASH_SendByte(CMD_READ_BYTE);
000060  2003              MOVS     r0,#3
000062  f7fffffe          BL       SPI_FLASH_SendByte
;;;1111       // 发送24位起始地址
;;;1112       SPI_FLASH_SendByte((srcAddr & 0xFF0000) >> 16);
000066  f3c54007          UBFX     r0,r5,#16,#8
00006a  f7fffffe          BL       SPI_FLASH_SendByte
;;;1113       SPI_FLASH_SendByte((srcAddr & 0xFF00) >> 8);
00006e  f3c52007          UBFX     r0,r5,#8,#8
000072  f7fffffe          BL       SPI_FLASH_SendByte
;;;1114       SPI_FLASH_SendByte(srcAddr & 0xFF);
000076  b2e8              UXTB     r0,r5
000078  f7fffffe          BL       SPI_FLASH_SendByte
;;;1115       // 接收前读一次数据DR，保证接收缓冲区为空
;;;1116       spi_i2s_data_receive(STM32_SPIx_NUM_DEF);
00007c  4648              MOV      r0,r9
00007e  f7fffffe          BL       spi_i2s_data_receive
;;;1117       // 再次禁止SPI以修改配置为只接收模式
;;;1118       spi_disable(STM32_SPIx_NUM_DEF);
000082  4648              MOV      r0,r9
000084  f7fffffe          BL       spi_disable
;;;1119       // 配置为只接收16位模式
;;;1120       spi_init_struct.trans_mode = SPI_TRANSMODE_RECEIVEONLY;
000088  f44f6080          MOV      r0,#0x400
00008c  6070              STR      r0,[r6,#4]  ; spi_init_struct
;;;1121       spi_init_struct.frame_size = SPI_FRAMESIZE_16BIT;
00008e  0040              LSLS     r0,r0,#1
000090  60b0              STR      r0,[r6,#8]  ; spi_init_struct
;;;1122       spi_init(STM32_SPIx_NUM_DEF, &spi_init_struct);
000092  4631              MOV      r1,r6
000094  4648              MOV      r0,r9
000096  f7fffffe          BL       spi_init
;;;1123   
;;;1124       // 清DMA标记
;;;1125       dma_flag_clear(DMA0, DMA_CH1, DMA_FLAG_G);// 清RX全局中断标志
00009a  2201              MOVS     r2,#1
00009c  4611              MOV      r1,r2
00009e  4650              MOV      r0,r10
0000a0  f7fffffe          BL       dma_flag_clear
;;;1126       // 使能RX的TC中断
;;;1127       dma_interrupt_enable(DMA0, DMA_CH1, DMA_INT_FTF);
0000a4  2202              MOVS     r2,#2
0000a6  2101              MOVS     r1,#1
0000a8  4650              MOV      r0,r10
0000aa  f7fffffe          BL       dma_interrupt_enable
;;;1128   
;;;1129       // 重新使能SPI，SCK时钟立刻开始输出，开始接收数据
;;;1130       spi_enable(STM32_SPIx_NUM_DEF);
0000ae  4648              MOV      r0,r9
0000b0  f7fffffe          BL       spi_enable
;;;1131       spi_i2s_data_receive(STM32_SPIx_NUM_DEF);
0000b4  4648              MOV      r0,r9
0000b6  f7fffffe          BL       spi_i2s_data_receive
;;;1132   
;;;1133       // 开启DMA通道DMA0_Channel1
;;;1134       dma_channel_enable(DMA0, DMA_CH1);
0000ba  2101              MOVS     r1,#1
0000bc  4650              MOV      r0,r10
0000be  f7fffffe          BL       dma_channel_enable
                  |L26.194|
;;;1135   
;;;1136       while (!spiCB.dmaFinished);
0000c2  7820              LDRB     r0,[r4,#0]  ; spiCB
0000c4  2800              CMP      r0,#0
0000c6  d0fc              BEQ      |L26.194|
;;;1137   
;;;1138       // DMA读完后，模式重新复位
;;;1139       SPIx_ConfigureWorkMode(SPI_TRANSMODE_FULLDUPLEX, SPI_FRAMESIZE_8BIT);
0000c8  e8bd5ff0          POP      {r4-r12,lr}
0000cc  2100              MOVS     r1,#0
0000ce  4608              MOV      r0,r1
0000d0  f7ffbffe          B.W      SPIx_ConfigureWorkMode
                  |L26.212|
;;;1140   #endif
;;;1141   }
0000d4  e8bd9ff0          POP      {r4-r12,pc}
;;;1142   
                          ENDP

                  |L26.216|
                          DCD      ||.data||
                  |L26.220|
                          DCD      0x40003c00
                  |L26.224|
                          DCD      0x40020000
                  |L26.228|
                          DCD      ||.bss||
                  |L26.232|
                          DCD      0x40011800

                          AREA ||i.SPIx_DMAy_SendBuffer||, CODE, READONLY, ALIGN=2

                  SPIx_DMAy_SendBuffer PROC
;;;925    // DMA发送(只支持也写256Byte)
;;;926    void SPIx_DMAy_SendBuffer(uint8 *sendBuffer, uint32 WriteAddr, uint16 ndtr)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;927    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
;;;928    #if STM32_DMA_SPI_DIRECTION
;;;929        // 关闭DMA
;;;930        spi_dma_disable(SPI0, SPI_DMA_TRANSMIT);
;;;931    
;;;932        dma_tx_init_struct.memory_inc = DMA_MEMORY_INCREASE_ENABLE;
;;;933        dma_tx_init_struct.memory_addr = (uint32)sendBuffer;
;;;934        dma_tx_init_struct.number = ndtr;
;;;935        dma_init(DMA0, DMA_CH2, &dma_tx_init_struct);
;;;936    
;;;937        // 片选
;;;938        SPI_FLASH_CS_L();
;;;939        // 发送页写入命令
;;;940        SPI_FLASH_SendByte(CMD_PAGE_WRITE);
;;;941        // 写入24位起始地址
;;;942        SPI_FLASH_SendByte((WriteAddr >> 16) & 0xFF);
;;;943        SPI_FLASH_SendByte((WriteAddr >> 8) & 0xFF);
;;;944        SPI_FLASH_SendByte(WriteAddr & 0xFF);
;;;945    
;;;946        // 清DMA标记
;;;947        dma_flag_clear(DMA0, DMA_CH2, DMA_FLAG_G);
;;;948    
;;;949        // 使能TX的TC中断
;;;950        dma_interrupt_enable(DMA0, DMA_CH2, DMA_INT_FTF);
;;;951    
;;;952        // 开启DMA通道DMA0_Channel2
;;;953        spi_dma_enable(SPI0, SPI_DMA_TRANSMIT);
;;;954    
;;;955    #else
;;;956    
;;;957        // 先禁止SPI以修改配置
;;;958        spi_disable(STM32_SPIx_NUM_DEF);
00000a  f8df8080          LDR      r8,|L27.140|
00000e  4640              MOV      r0,r8
000010  f7fffffe          BL       spi_disable
;;;959    
;;;960        // 关闭DMA
;;;961        spi_dma_disable(SPI0, SPI_DMA_TRANSMIT);
000014  4f1e              LDR      r7,|L27.144|
000016  2100              MOVS     r1,#0
000018  4638              MOV      r0,r7
00001a  f7fffffe          BL       spi_dma_disable
;;;962    
;;;963        // 全双工发送接收模式，此时不用理会接收的数据
;;;964        // 数据的开始以填数据进SPI_DR为启动时刻
;;;965        spi_init_struct.trans_mode = SPI_TRANSMODE_FULLDUPLEX;
00001e  491d              LDR      r1,|L27.148|
000020  2000              MOVS     r0,#0
000022  6048              STR      r0,[r1,#4]  ; spi_init_struct
;;;966        spi_init(STM32_SPIx_NUM_DEF, &spi_init_struct);
000024  4640              MOV      r0,r8
000026  f7fffffe          BL       spi_init
;;;967    
;;;968        dma_tx_init_struct.memory_inc = DMA_MEMORY_INCREASE_ENABLE;
00002a  491a              LDR      r1,|L27.148|
00002c  2001              MOVS     r0,#1
00002e  311c              ADDS     r1,r1,#0x1c
000030  7648              STRB     r0,[r1,#0x19]
;;;969        dma_tx_init_struct.memory_addr = (uint32)sendBuffer;
000032  608d              STR      r5,[r1,#8]  ; dma_tx_init_struct
;;;970        dma_tx_init_struct.number = ndtr;
000034  610e              STR      r6,[r1,#0x10]  ; dma_tx_init_struct
;;;971        dma_init(DMA0, DMA_CH2, &dma_tx_init_struct);
000036  4d18              LDR      r5,|L27.152|
000038  460a              MOV      r2,r1
00003a  2102              MOVS     r1,#2
00003c  4628              MOV      r0,r5
00003e  f7fffffe          BL       dma_init
;;;972    
;;;973        // 使能SPI，使用双工模式发送命令和地址
;;;974        spi_enable(STM32_SPIx_NUM_DEF);
000042  4640              MOV      r0,r8
000044  f7fffffe          BL       spi_enable
;;;975    
;;;976        // 片选
;;;977        SPI_FLASH_CS_L();
000048  2102              MOVS     r1,#2
00004a  4814              LDR      r0,|L27.156|
00004c  f7fffffe          BL       gpio_bit_reset
;;;978        // 发送页写入命令
;;;979        SPI_FLASH_SendByte(CMD_PAGE_WRITE);
000050  2002              MOVS     r0,#2
000052  f7fffffe          BL       SPI_FLASH_SendByte
;;;980        // 写入24位起始地址
;;;981        SPI_FLASH_SendByte((WriteAddr >> 16) & 0xFF);
000056  f3c44007          UBFX     r0,r4,#16,#8
00005a  f7fffffe          BL       SPI_FLASH_SendByte
;;;982        SPI_FLASH_SendByte((WriteAddr >> 8) & 0xFF);
00005e  f3c42007          UBFX     r0,r4,#8,#8
000062  f7fffffe          BL       SPI_FLASH_SendByte
;;;983        SPI_FLASH_SendByte(WriteAddr & 0xFF);
000066  b2e0              UXTB     r0,r4
000068  f7fffffe          BL       SPI_FLASH_SendByte
;;;984    
;;;985        // 清DMA标记
;;;986        dma_flag_clear(DMA0, DMA_CH2, DMA_FLAG_G);
00006c  2201              MOVS     r2,#1
00006e  2102              MOVS     r1,#2
000070  4628              MOV      r0,r5
000072  f7fffffe          BL       dma_flag_clear
;;;987    
;;;988        // 使能TX的TC中断
;;;989        dma_interrupt_enable(DMA0, DMA_CH2, DMA_INT_FTF);
000076  2202              MOVS     r2,#2
000078  4611              MOV      r1,r2
00007a  4628              MOV      r0,r5
00007c  f7fffffe          BL       dma_interrupt_enable
;;;990    
;;;991        // 开启DMA通道DMA0_Channel2
;;;992        spi_dma_enable(SPI0, SPI_DMA_TRANSMIT);
000080  4638              MOV      r0,r7
000082  e8bd41f0          POP      {r4-r8,lr}
000086  2100              MOVS     r1,#0
000088  f7ffbffe          B.W      spi_dma_enable
;;;993    
;;;994    #endif
;;;995    }
;;;996    
                          ENDP

                  |L27.140|
                          DCD      0x40003c00
                  |L27.144|
                          DCD      0x40013000
                  |L27.148|
                          DCD      ||.bss||
                  |L27.152|
                          DCD      0x40020000
                  |L27.156|
                          DCD      0x40011800

                          AREA ||i.SPIx_FLASH_Init||, CODE, READONLY, ALIGN=2

                  SPIx_FLASH_Init PROC
;;;53     // 初始化SPI Flash驱动端口
;;;54     void SPIx_FLASH_Init(void)
000000  b570              PUSH     {r4-r6,lr}
;;;55     {
;;;56     //  // GD32 - SPI
;;;57     //  if(STM32_SPIx_NUM_DEF == SPI0)
;;;58     //  {
;;;59     //      /*
;;;60     //      * PA5 --> SPI1 SCK          Mode: GPIO_Mode_AF_PP
;;;61     //      * PA7 --> SPI1 MOSI Write   Mode: GPIO_Mode_AF_PP
;;;62     //      * PA6 --> SPI1 MISO Read    Mode: GPIO_Mode_IPU
;;;63     //      * PA4 --> SPI1 CS           Mode: GPIO_Mode_Out_PP
;;;64     //      */
;;;65     //
;;;66     //      // 使能GPIO时钟
;;;67     //      rcu_periph_clock_enable(RCU_GPIOB);
;;;68     //
;;;69     //      // SPI0 GPIO config: SCK/PA5-> PB3, MOSI/PA7 - > PB5
;;;70     //      gpio_init(GPIOB, GPIO_MODE_AF_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_3 | GPIO_PIN_5);
;;;71     
;;;72     //      // SPI0 GPIO config: MISO/PA6 ->PB4
;;;73     //      gpio_init(GPIOB, GPIO_MODE_IPU, GPIO_OSPEED_50MHZ, GPIO_PIN_4);
;;;74     
;;;75     //      // SPI0 GPIO config: NSS/PA4 -> PE1
;;;76     //      gpio_init(GPIOE, GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_1);
;;;77     //
;;;78     //      // SPIx配置选项
;;;79     //      rcu_periph_clock_enable(RCU_SPI0);
;;;80     //
;;;81     //  }
;;;82     //  else
;;;83     //  {
;;;84     //      // 使能GPIO时钟
;;;85     //      rcu_periph_clock_enable(RCU_GPIOB);
;;;86     //
;;;87     //      // SPI1 GPIO config: SCK/PB13, MOSI/PB15
;;;88     //      gpio_init(GPIOB, GPIO_MODE_AF_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_13 |GPIO_PIN_15);
;;;89     
;;;90     //      // SPI1 GPIO config: MISO/PB14
;;;91     //      gpio_init(GPIOB, GPIO_MODE_AF_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_14);
;;;92     
;;;93     //      // SPI1 GPIO config: NSS/PB12
;;;94     //      gpio_init(GPIOB, GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_12);
;;;95     
;;;96     //      // SPIx配置选项
;;;97     //      rcu_periph_clock_enable(RCU_SPI1);
;;;98     //  }
;;;99         rcu_periph_clock_enable(RCU_GPIOB);
000002  f2406003          MOV      r0,#0x603
000006  f7fffffe          BL       rcu_periph_clock_enable
;;;100        rcu_periph_clock_enable(RCU_GPIOE);
00000a  f2406006          MOV      r0,#0x606
00000e  f7fffffe          BL       rcu_periph_clock_enable
;;;101        rcu_periph_clock_enable(RCU_SPI2);
000012  f240700f          MOV      r0,#0x70f
000016  f7fffffe          BL       rcu_periph_clock_enable
;;;102        rcu_periph_clock_enable(RCU_AF);
00001a  f44f60c0          MOV      r0,#0x600
00001e  f7fffffe          BL       rcu_periph_clock_enable
;;;103    
;;;104        //禁用JTAG引脚功能，操作的是AF寄存器，所以要先使能AF时钟
;;;105        gpio_pin_remap_config(GPIO_SWJ_SWDPENABLE_REMAP, ENABLE);
000022  2101              MOVS     r1,#1
000024  4818              LDR      r0,|L28.136|
000026  f7fffffe          BL       gpio_pin_remap_config
;;;106    
;;;107        // SPI0 GPIO config: SCK/PB3, MOSI/PB5
;;;108        gpio_init(GPIOB, GPIO_MODE_AF_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_3 | GPIO_PIN_5);
00002a  4c18              LDR      r4,|L28.140|
00002c  2328              MOVS     r3,#0x28
00002e  2203              MOVS     r2,#3
000030  2118              MOVS     r1,#0x18
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       gpio_init
;;;109    
;;;110        // SPI0 GPIO config: MISO/PB4
;;;111        gpio_init(GPIOB, GPIO_MODE_IPU, GPIO_OSPEED_50MHZ, GPIO_PIN_4);
000038  2310              MOVS     r3,#0x10
00003a  2203              MOVS     r2,#3
00003c  2148              MOVS     r1,#0x48
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       gpio_init
;;;112    
;;;113        // SPI0 GPIO config: NSS/PE1
;;;114        gpio_init(GPIOE, GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_1);
000044  2302              MOVS     r3,#2
000046  2203              MOVS     r2,#3
000048  2110              MOVS     r1,#0x10
00004a  4811              LDR      r0,|L28.144|
00004c  f7fffffe          BL       gpio_init
;;;115    
;;;116        spi_i2s_deinit(STM32_SPIx_NUM_DEF);
000050  4d10              LDR      r5,|L28.148|
000052  4628              MOV      r0,r5
000054  f7fffffe          BL       spi_i2s_deinit
;;;117    
;;;118        spi_init_struct.trans_mode           = SPI_TRANSMODE_FULLDUPLEX;
000058  490f              LDR      r1,|L28.152|
00005a  2400              MOVS     r4,#0
00005c  604c              STR      r4,[r1,#4]  ; spi_init_struct
;;;119        spi_init_struct.device_mode          = SPI_MASTER;
00005e  f44f7082          MOV      r0,#0x104
000062  6008              STR      r0,[r1,#0]  ; spi_init_struct
;;;120        spi_init_struct.frame_size           = SPI_FRAMESIZE_8BIT;
000064  608c              STR      r4,[r1,#8]  ; spi_init_struct
;;;121        spi_init_struct.clock_polarity_phase = SPI_CK_PL_LOW_PH_1EDGE;              // 空闲时CLK拉底，在第一个时钟跳变沿采集第一个数据
000066  614c              STR      r4,[r1,#0x14]  ; spi_init_struct
;;;122        spi_init_struct.nss                  = SPI_NSS_SOFT;                        // 片选软件控制
000068  1568              ASRS     r0,r5,#21
00006a  60c8              STR      r0,[r1,#0xc]  ; spi_init_struct
;;;123    
;;;124        // APB2 - SPI0 - 72M
;;;125        // APB1 - SPI1/SPI2 - 36M
;;;126        spi_init_struct.prescale             = SPI_PSC_4;                           // 72/4=18M
00006c  2008              MOVS     r0,#8
00006e  6188              STR      r0,[r1,#0x18]  ; spi_init_struct
;;;127        spi_init_struct.endian               = SPI_ENDIAN_MSB;                      // 先发送高位
000070  610c              STR      r4,[r1,#0x10]  ; spi_init_struct
;;;128        spi_init(STM32_SPIx_NUM_DEF, &spi_init_struct);
000072  4628              MOV      r0,r5
000074  f7fffffe          BL       spi_init
;;;129    
;;;130        // 使能SPIx
;;;131        spi_enable(STM32_SPIx_NUM_DEF);
000078  4628              MOV      r0,r5
00007a  f7fffffe          BL       spi_enable
;;;132    
;;;133        // 使能DMA功能
;;;134        DMAy_SPIx_Configuration();
00007e  f7fffffe          BL       DMAy_SPIx_Configuration
;;;135    
;;;136        spiCB.dmaFinished = FALSE;
000082  4806              LDR      r0,|L28.156|
000084  7004              STRB     r4,[r0,#0]
;;;137    
;;;138    #if SPI_FLASH_UNIT_TEST
;;;139        SPI_FLASH_UnitTest();
;;;140    #endif
;;;141    }
000086  bd70              POP      {r4-r6,pc}
;;;142    
                          ENDP

                  |L28.136|
                          DCD      0x00300200
                  |L28.140|
                          DCD      0x40010c00
                  |L28.144|
                          DCD      0x40011800
                  |L28.148|
                          DCD      0x40003c00
                  |L28.152|
                          DCD      ||.bss||
                  |L28.156|
                          DCD      ||.data||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  spi_init_struct
                          %        28
                  dma_tx_init_struct
                          %        28
                  dma_rx_init_struct
                          %        28

                          AREA ||.data||, DATA, ALIGN=1

                  spiCB
000000  0000              DCB      0x00,0x00
                  txByte
000002  00ff              DCW      0x00ff
                  rxByte
000004  00ff              DCW      0x00ff

;*** Start embedded assembler ***

#line 1 "User\\spiflash.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_spiflash_c_de66f17a____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___10_spiflash_c_de66f17a____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_spiflash_c_de66f17a____REVSH|
#line 128
|__asm___10_spiflash_c_de66f17a____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
