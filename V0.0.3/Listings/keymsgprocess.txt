; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\keymsgprocess.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\keymsgprocess.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.1\Device\Include -D__MICROLIB -D__UVISION_VERSION=534 -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\keymsgprocess.crf User\keyMsgProcess.c]
                          THUMB

                          AREA ||i.KEYMSG_CALLBACK_Scan||, CODE, READONLY, ALIGN=2

                  KEYMSG_CALLBACK_Scan PROC
;;;212    // 【接口功能】按键处理回调函数，在定时器控制下，被周期调用，实现按键扫描
;;;213    void KEYMSG_CALLBACK_Scan(uint32 param)
000000  4901              LDR      r1,|L1.8|
;;;214    {
;;;215    	keyMsgCB.scanRequest = TRUE;
000002  2001              MOVS     r0,#1
000004  7008              STRB     r0,[r1,#0]
;;;216    }
000006  4770              BX       lr
;;;217    
                          ENDP

                  |L1.8|
                          DCD      ||.bss||

                          AREA ||i.KEYMSG_ClearGlobalMaskRequest||, CODE, READONLY, ALIGN=2

                  KEYMSG_ClearGlobalMaskRequest PROC
;;;549    // 清除全局屏蔽请求
;;;550    void KEYMSG_ClearGlobalMaskRequest(void)
000000  4902              LDR      r1,|L2.12|
;;;551    {
;;;552    	keyMsgCB.globalMaskRequest = FALSE;
000002  2000              MOVS     r0,#0
000004  f8810128          STRB     r0,[r1,#0x128]
;;;553    }
000008  4770              BX       lr
;;;554    
                          ENDP

00000a  0000              DCW      0x0000
                  |L2.12|
                          DCD      ||.bss||

                          AREA ||i.KEYMSG_ClearMaskRequest||, CODE, READONLY, ALIGN=2

                  KEYMSG_ClearMaskRequest PROC
;;;537    // 清除指定按键的指定消息的屏蔽请求
;;;538    void KEYMSG_ClearMaskRequest(KEY_NAME_E keyName, KEY_MSG_E keyMsg)
000000  4b03              LDR      r3,|L3.16|
;;;539    {
;;;540    	keyMsgCB.msgMaskRequest[keyName][keyMsg] = FALSE;
000002  2200              MOVS     r2,#0
000004  eb030080          ADD      r0,r3,r0,LSL #2
000008  4408              ADD      r0,r0,r1
00000a  f8802110          STRB     r2,[r0,#0x110]
;;;541    }
00000e  4770              BX       lr
;;;542    
                          ENDP

                  |L3.16|
                          DCD      ||.bss||

                          AREA ||i.KEYMSG_GetAddDecKeyUpRecoveryRequest||, CODE, READONLY, ALIGN=2

                  KEYMSG_GetAddDecKeyUpRecoveryRequest PROC
;;;561    // 获取+-键弹起恢复请求
;;;562    BOOL KEYMSG_GetAddDecKeyUpRecoveryRequest(void)
000000  4801              LDR      r0,|L4.8|
;;;563    {
;;;564    	return keyMsgCB.addDecKeyUpRercoveryRequest;
000002  f8900129          LDRB     r0,[r0,#0x129]  ; keyMsgCB
;;;565    }
000006  4770              BX       lr
;;;566    
                          ENDP

                  |L4.8|
                          DCD      ||.bss||

                          AREA ||i.KEYMSG_Init||, CODE, READONLY, ALIGN=2

                  KEYMSG_Init PROC
;;;84     // 【使用方法】在 main 中大循环之前调用，注意，在调用本接口之前，必须完成定时器模块初始化
;;;85     void KEYMSG_Init(void)
000000  b57c              PUSH     {r2-r6,lr}
;;;86     {
;;;87     	uint8 i,j;
;;;88     
;;;89     	// 数据结构初始化
;;;90     	for(i=0; i<KEY_NAME_MAX; i++)
000002  2100              MOVS     r1,#0
;;;91     	{
;;;92     		keyMsgCB.keyMsgInfo[i].end = 0;
000004  4d23              LDR      r5,|L5.148|
;;;93     		for(j=0; j<KEY_INFO_SIZE; j++)
;;;94     		{
;;;95     			keyMsgCB.keyMsgInfo[i].stateCount[j] = KEY_STATE_MASK;
000006  f44f4200          MOV      r2,#0x8000
00000a  2400              MOVS     r4,#0
                  |L5.12|
00000c  eb010081          ADD      r0,r1,r1,LSL #2       ;92
000010  eb0503c0          ADD      r3,r5,r0,LSL #3       ;92
000014  711c              STRB     r4,[r3,#4]            ;92
000016  2000              MOVS     r0,#0                 ;93
                  |L5.24|
000018  eb030640          ADD      r6,r3,r0,LSL #1
00001c  80f2              STRH     r2,[r6,#6]
00001e  1c40              ADDS     r0,r0,#1              ;93
000020  b2c0              UXTB     r0,r0                 ;93
000022  2802              CMP      r0,#2                 ;93
000024  d3f8              BCC      |L5.24|
;;;96     		}
;;;97     
;;;98     		// 清除所有消息的屏蔽请求
;;;99     		for(j=0; j<KEY_MSG_MAX; j++)
000026  2000              MOVS     r0,#0
;;;100    		{
;;;101    			keyMsgCB.msgMaskRequest[i][j] = FALSE;
000028  eb050381          ADD      r3,r5,r1,LSL #2
                  |L5.44|
00002c  181e              ADDS     r6,r3,r0
00002e  f8864110          STRB     r4,[r6,#0x110]
000032  1c40              ADDS     r0,r0,#1              ;99
000034  b2c0              UXTB     r0,r0                 ;99
000036  2804              CMP      r0,#4                 ;99
000038  d3f8              BCC      |L5.44|
00003a  1c49              ADDS     r1,r1,#1              ;90
00003c  b2c9              UXTB     r1,r1                 ;90
00003e  2906              CMP      r1,#6                 ;90
000040  d3e4              BCC      |L5.12|
;;;102    		}
;;;103    	}
;;;104    	for(i=0; i<sizeof(keyMsgCB.keyValue); i++)
000042  2000              MOVS     r0,#0
;;;105    	{
;;;106    		keyMsgCB.keyValue[i] = 0xFF;
000044  21ff              MOVS     r1,#0xff
                  |L5.70|
000046  182a              ADDS     r2,r5,r0
000048  7051              STRB     r1,[r2,#1]
00004a  1c40              ADDS     r0,r0,#1              ;104
00004c  b2c0              UXTB     r0,r0                 ;104
00004e  2800              CMP      r0,#0                 ;104
000050  d0f9              BEQ      |L5.70|
;;;107    		#if 0==KEY_MSG_THROW_KEY_UP_AFTER_REPEAT
;;;108    		keyMsgCB.keyUpMsgMaskBit[i] = 0x00;
;;;109    		#endif
;;;110    	}
;;;111    	
;;;112    	// 消息环形队列初始化
;;;113    	keyMsgCB.msgQueue.head = 0;
000052  f88540f4          STRB     r4,[r5,#0xf4]
;;;114    	keyMsgCB.msgQueue.end  = 0;
000056  f88540f5          STRB     r4,[r5,#0xf5]
;;;115    	for(i=0; i<KEY_MSG_QUEUE_SIZE; i++)
00005a  2000              MOVS     r0,#0
;;;116    	{
;;;117    		keyMsgCB.msgQueue.node[i].keyName = KEY_NAME_NULL;
00005c  2207              MOVS     r2,#7
;;;118    		keyMsgCB.msgQueue.node[i].keyMsg = KEY_MSG_NULL;
00005e  2305              MOVS     r3,#5
                  |L5.96|
000060  eb050140          ADD      r1,r5,r0,LSL #1       ;117
000064  f8012ff6          STRB     r2,[r1,#0xf6]!        ;117
000068  704b              STRB     r3,[r1,#1]
00006a  1c40              ADDS     r0,r0,#1              ;115
00006c  b2c0              UXTB     r0,r0                 ;115
00006e  280a              CMP      r0,#0xa               ;115
000070  d3f6              BCC      |L5.96|
;;;119    	}
;;;120    	
;;;121    	keyMsgCB.scanRequest = FALSE;
000072  702c              STRB     r4,[r5,#0]
;;;122     
;;;123    	// 按键消息服务初始化
;;;124    	KEYMSG_StopAllService();
000074  f7fffffe          BL       KEYMSG_StopAllService
;;;125    	
;;;126    	// 按键刷新函数接口初始化
;;;127    	keyMsgCB.KeyUpdate = NULL;
000078  f8c5410c          STR      r4,[r5,#0x10c]  ; keyMsgCB
;;;128    	
;;;129    	// 启动按键扫描
;;;130    	TIMER_AddTask(TIMER_ID_KEY_SCAN,
00007c  f04f30ff          MOV      r0,#0xffffffff
000080  e9cd0400          STRD     r0,r4,[sp,#0]
000084  2300              MOVS     r3,#0
000086  4a04              LDR      r2,|L5.152|
000088  2132              MOVS     r1,#0x32
00008a  2001              MOVS     r0,#1
00008c  f7fffffe          BL       TIMER_AddTask
;;;131    					KEY_SCAN_TIME,
;;;132    					KEYMSG_CALLBACK_Scan,
;;;133    					0,
;;;134    					TIMER_LOOP_FOREVER,
;;;135    					ACTION_MODE_DO_AT_ONCE);
;;;136    }
000090  bd7c              POP      {r2-r6,pc}
;;;137    
                          ENDP

000092  0000              DCW      0x0000
                  |L5.148|
                          DCD      ||.bss||
                  |L5.152|
                          DCD      KEYMSG_CALLBACK_Scan

                          AREA ||i.KEYMSG_MsgProcess||, CODE, READONLY, ALIGN=2

                  KEYMSG_MsgProcess PROC
;;;295    // 【接口功能】按键消息处理
;;;296    void KEYMSG_MsgProcess(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;297    {
;;;298    	uint8 i;
;;;299    	KEYMSG_INFO_CB* pKeyInfo = NULL;
;;;300    	uint16 currentCount = 0;	// 当前按键状态计数值
;;;301    	uint16 currentState = 0;	// 当前按键状态
;;;302    	uint16* pStateCount = NULL;	// 当前操作中的状态计数值
;;;303    	
;;;304    	// 遍历当前的状态，根据需要抛出按键消息，添加到按键环形队列中
;;;305    	for(i=0; i<KEY_NAME_MAX; i++)
000002  2500              MOVS     r5,#0
;;;306    	{
;;;307    		// 获取当前按键信息结构体指针
;;;308    		pKeyInfo = &keyMsgCB.keyMsgInfo[i];
000004  4f2b              LDR      r7,|L6.180|
;;;309    		
;;;310    		// 获取当前操作中的按键状态计数值指针
;;;311    		pStateCount = &(pKeyInfo->stateCount[pKeyInfo->end]);
;;;312    		
;;;313    		// 获取当前按键状态
;;;314    		currentState = (*pStateCount) & KEY_STATE_MASK;
;;;315    		
;;;316    		// 获取当前按键状态计数值
;;;317    		currentCount = (*pStateCount) & (~KEY_STATE_MASK);
;;;318    		
;;;319    		// 最高位为0，说明当前状态为按键按下
;;;320    		if(0 == currentState)
;;;321    		{
;;;322    			// 当前状态计数值为1，说明当前状态为第一次出现，需要抛出按下消息
;;;323    			if(1 == currentCount)
;;;324    			{
;;;325    			#if 1==KEY_MSG_SWITCH_DOWN
;;;326    				// 抛出按键按下消息
;;;327    				KEYMSG_ThrowMsg((KEY_NAME_E)i, KEY_MSG_DOWN);
;;;328    			#endif
;;;329    			#if 0==KEY_MSG_THROW_KEY_UP_AFTER_REPEAT	// KEY_UP 屏蔽位置位时，不抛出 KEY_UP 消息
;;;330    				keyMsgCB.keyUpMsgMaskBit[i/8] &= (0x01<<(i%8));	// 按键按下时解除 KEY_UP 限制
;;;331    			#endif
;;;332    				// 计数值清零，即代表已抛出消息
;;;333    				(*pStateCount) &= KEY_STATE_MASK;
;;;334    			}
;;;335    			// 当前状态计数值大于1，则判断是否达到长按门限
;;;336    			else if(currentCount > 1)
;;;337    			{
;;;338    				// 达到长按门限，抛出长按消息，注意这里的判断条件，不能用>，否则将不断抛出长按消息
;;;339    			#if 0==KEY_MSG_USE_SAME_HOLD_THRESHOLD
;;;340    				if(currentCount*KEY_SCAN_TIME == keyHoldThreshHold[i])	// 每个按键使用单独的长按门限
000006  4e2c              LDR      r6,|L6.184|
                  |L6.8|
000008  eb050085          ADD      r0,r5,r5,LSL #2       ;308
00000c  eb0700c0          ADD      r0,r7,r0,LSL #3       ;308
000010  1d00              ADDS     r0,r0,#4              ;308
000012  7801              LDRB     r1,[r0,#0]            ;311
000014  eb000441          ADD      r4,r0,r1,LSL #1       ;311
000018  1ca4              ADDS     r4,r4,#2              ;311
00001a  8820              LDRH     r0,[r4,#0]            ;314
00001c  f4004100          AND      r1,r0,#0x8000         ;314
000020  f4204000          BIC      r0,r0,#0x8000         ;317
000024  b111              CBZ      r1,|L6.44|
;;;341    			#else
;;;342    				if(currentCount*KEY_SCAN_TIME == KEY_HOLD_TIME) // 所有按键使用统一的长按门限
;;;343    			#endif
;;;344    				{
;;;345    				#if 1==KEY_MSG_SWITCH_HOLD
;;;346    					// 抛出按键长按消息
;;;347    					KEYMSG_ThrowMsg((KEY_NAME_E)i, KEY_MSG_HOLD);
;;;348    				#endif
;;;349    				#if 0==KEY_MSG_THROW_KEY_UP_AFTER_REPEAT	// KEY_UP 屏蔽位置位时，不抛出 KEY_UP 消息
;;;350    					keyMsgCB.keyUpMsgMaskBit[i/8] |= (0x01<<(i%8));	// 按键长按时设置 KEY_UP 限制
;;;351    				#endif
;;;352    					// 计数值增加1，防止下一次重复抛出长按消息
;;;353    					(*pStateCount)++;
;;;354    				}
;;;355    				// 超出长按门限，判断是否达到重复抛出门限
;;;356    			#if 0==KEY_MSG_USE_SAME_HOLD_THRESHOLD
;;;357    				else if(currentCount*KEY_SCAN_TIME >= keyHoldThreshHold[i] + keyRepeatTime[i])	// 每个按键使用单独的长按门限
;;;358    			#else
;;;359    				else if(currentCount*KEY_SCAN_TIME >= KEY_HOLD_TIME + KEY_RETHROW_TIME) // 所有按键使用统一的长按门限
;;;360    			#endif
;;;361    				{
;;;362    				#if 1==KEY_MSG_SWITCH_REPEAT
;;;363    					// 抛出按键重复消息
;;;364    					KEYMSG_ThrowMsg((KEY_NAME_E)i, KEY_MSG_REPEAT);
;;;365    				#endif
;;;366    					
;;;367    					// 将计数值设置为长按门限+1，为下次抛出重复消息做准备
;;;368    					(*pStateCount) &= KEY_STATE_MASK;
;;;369    				#if 0==KEY_MSG_USE_SAME_HOLD_THRESHOLD
;;;370    					(*pStateCount) += (keyHoldThreshHold[i]/KEY_SCAN_TIME) + 1; // 每个按键使用单独的长按门限
;;;371    				#else
;;;372    					(*pStateCount) += (KEY_HOLD_TIME/KEY_SCAN_TIME) + 1;	// 所有按键使用统一的长按门限
;;;373    				#endif
;;;374    				}
;;;375    				// 未达到长按门限，不予处理
;;;376    				else
;;;377    				{}
;;;378    			}
;;;379    			// 当前状态计数值为0，说明已抛出边沿消息，不再予以处理
;;;380    			else
;;;381    			{}
;;;382    		}
;;;383    		// 最高位为1，说明当前状态为按键释放
;;;384    		else
;;;385    		{
;;;386    			// 当前状态计数值为1，说明当前状态为第一次出现，需要抛出释放消息
;;;387    			if(1 == currentCount)
000026  2801              CMP      r0,#1
000028  d036              BEQ      |L6.152|
00002a  e03d              B        |L6.168|
                  |L6.44|
00002c  2801              CMP      r0,#1                 ;323
00002e  d011              BEQ      |L6.84|
000030  d93a              BLS      |L6.168|
000032  f8361015          LDRH     r1,[r6,r5,LSL #1]     ;340
000036  eb0002c0          ADD      r2,r0,r0,LSL #3       ;340
00003a  eb021000          ADD      r0,r2,r0,LSL #4       ;340
00003e  ebb10f40          CMP      r1,r0,LSL #1          ;340
000042  d110              BNE      |L6.102|
000044  2102              MOVS     r1,#2                 ;347
000046  4628              MOV      r0,r5                 ;347
000048  f7fffffe          BL       KEYMSG_ThrowMsg
00004c  8820              LDRH     r0,[r4,#0]            ;353
00004e  1c40              ADDS     r0,r0,#1              ;353
000050  8020              STRH     r0,[r4,#0]            ;353
000052  e029              B        |L6.168|
                  |L6.84|
000054  2100              MOVS     r1,#0                 ;327
000056  4628              MOV      r0,r5                 ;327
000058  f7fffffe          BL       KEYMSG_ThrowMsg
00005c  8820              LDRH     r0,[r4,#0]            ;333
00005e  f4004000          AND      r0,r0,#0x8000         ;333
000062  8020              STRH     r0,[r4,#0]            ;333
000064  e020              B        |L6.168|
                  |L6.102|
000066  4a14              LDR      r2,|L6.184|
000068  320c              ADDS     r2,r2,#0xc            ;357
00006a  f8322015          LDRH     r2,[r2,r5,LSL #1]     ;357
00006e  4411              ADD      r1,r1,r2              ;357
000070  ebb10f40          CMP      r1,r0,LSL #1          ;357
000074  d818              BHI      |L6.168|
000076  2103              MOVS     r1,#3                 ;364
000078  4628              MOV      r0,r5                 ;364
00007a  f7fffffe          BL       KEYMSG_ThrowMsg
00007e  8820              LDRH     r0,[r4,#0]            ;368
000080  f4004000          AND      r0,r0,#0x8000         ;368
000084  8020              STRH     r0,[r4,#0]            ;368
000086  f8361015          LDRH     r1,[r6,r5,LSL #1]     ;370
00008a  2232              MOVS     r2,#0x32              ;370
00008c  fbb1f1f2          UDIV     r1,r1,r2              ;370
000090  1c49              ADDS     r1,r1,#1              ;370
000092  4408              ADD      r0,r0,r1              ;370
000094  8020              STRH     r0,[r4,#0]            ;370
000096  e007              B        |L6.168|
                  |L6.152|
;;;388    			{
;;;389    			#if 1==KEY_MSG_SWITCH_UP
;;;390    				// 抛出按键释放消息
;;;391    				KEYMSG_ThrowMsg((KEY_NAME_E)i, KEY_MSG_UP);
000098  2101              MOVS     r1,#1
00009a  4628              MOV      r0,r5
00009c  f7fffffe          BL       KEYMSG_ThrowMsg
;;;392    			#endif
;;;393    				
;;;394    				// 计数值清零，即代表已抛出消息
;;;395    				(*pStateCount) &= KEY_STATE_MASK;
0000a0  8820              LDRH     r0,[r4,#0]
0000a2  f4004000          AND      r0,r0,#0x8000
0000a6  8020              STRH     r0,[r4,#0]
                  |L6.168|
0000a8  1c6d              ADDS     r5,r5,#1              ;305
0000aa  b2ed              UXTB     r5,r5                 ;305
0000ac  2d06              CMP      r5,#6                 ;305
0000ae  d3ab              BCC      |L6.8|
;;;396    			}
;;;397    			// 计数值为0时，说明已抛出边沿消息，不再予以处理
;;;398    			// 计数值>1时，为按键释放状态下计数，不予处理
;;;399    			else
;;;400    			{}
;;;401    		}
;;;402    	}
;;;403    }
0000b0  bdf0              POP      {r4-r7,pc}
;;;404    
                          ENDP

0000b2  0000              DCW      0x0000
                  |L6.180|
                          DCD      ||.bss||
                  |L6.184|
                          DCD      ||.constdata||

                          AREA ||i.KEYMSG_Process||, CODE, READONLY, ALIGN=1

                  KEYMSG_Process PROC
;;;443    // 【使用方法】在 main 中大循环内调用
;;;444    void KEYMSG_Process(void)
000000  b510              PUSH     {r4,lr}
;;;445    {
;;;446    	// 按键扫描处理
;;;447    	KEYMSG_ScanProcess();
000002  f7fffffe          BL       KEYMSG_ScanProcess
;;;448    	
;;;449    	// 按键消息处理
;;;450    	KEYMSG_MsgProcess();
000006  f7fffffe          BL       KEYMSG_MsgProcess
;;;451    	
;;;452    	// 按键服务处理
;;;453    	KEYMSG_ServiceProcess();
00000a  e8bd4010          POP      {r4,lr}
00000e  f7ffbffe          B.W      KEYMSG_ServiceProcess
;;;454    }
;;;455    
                          ENDP


                          AREA ||i.KEYMSG_RegisterKeyScanCallback||, CODE, READONLY, ALIGN=2

                  KEYMSG_RegisterKeyScanCallback PROC
;;;142    //             并通过此接口向本模块注册，需要注意的是：按键按下为0，按键释放为1
;;;143    void KEYMSG_RegisterKeyScanCallback(void(*fun)(uint8* p8bitKeyValueArray))
000000  4901              LDR      r1,|L8.8|
;;;144    {
;;;145    	keyMsgCB.KeyUpdate = fun;
000002  f8c1010c          STR      r0,[r1,#0x10c]  ; keyMsgCB
;;;146    }
000006  4770              BX       lr
;;;147    
                          ENDP

                  |L8.8|
                          DCD      ||.bss||

                          AREA ||i.KEYMSG_RegisterMsgService||, CODE, READONLY, ALIGN=2

                  KEYMSG_RegisterMsgService PROC
;;;151    // 【使用方法】用于注册按键消息服务，执行之前无须先注销，可直接调用本接口改变消息服务，注册的服务函数的形式必须与本接口中形参一致
;;;152    void KEYMSG_RegisterMsgService(KEY_NAME_E keyName, KEY_MSG_E keyMsg, void(*service)(uint32 param), uint32 param)
000000  b510              PUSH     {r4,lr}
;;;153    {
;;;154    	// 参数合法性检验
;;;155    	if(keyName >= KEY_NAME_MAX)
000002  2806              CMP      r0,#6
000004  d20c              BCS      |L9.32|
;;;156    	{
;;;157    		return ;
;;;158    	}
;;;159    	if(keyMsg >= KEY_MSG_MAX)
000006  2904              CMP      r1,#4
000008  d20a              BCS      |L9.32|
;;;160    	{
;;;161    		return ;
;;;162    	}
;;;163    	if(!service)
00000a  2a00              CMP      r2,#0
00000c  d008              BEQ      |L9.32|
;;;164    	{
;;;165    		return ;
;;;166    	}
;;;167    	
;;;168    	// 配置按键服务
;;;169    	keyMsgCB.keyMsgInfo[keyName].service[keyMsg] = service;
00000e  eb000480          ADD      r4,r0,r0,LSL #2
000012  4804              LDR      r0,|L9.36|
000014  eb0000c4          ADD      r0,r0,r4,LSL #3
000018  eb000081          ADD      r0,r0,r1,LSL #2
00001c  60c2              STR      r2,[r0,#0xc]
;;;170    	keyMsgCB.keyMsgInfo[keyName].param[keyMsg] = param;
00001e  61c3              STR      r3,[r0,#0x1c]
                  |L9.32|
;;;171    }
000020  bd10              POP      {r4,pc}
;;;172    
                          ENDP

000022  0000              DCW      0x0000
                  |L9.36|
                          DCD      ||.bss||

                          AREA ||i.KEYMSG_ScanProcess||, CODE, READONLY, ALIGN=2

                  KEYMSG_ScanProcess PROC
;;;219    // 【接口功能】按键扫描处理
;;;220    void KEYMSG_ScanProcess(void)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;221    {
;;;222    	uint8 i;
;;;223    	KEYMSG_INFO_CB* pKeyInfo = NULL;
;;;224    	uint16 currentKeyBit = 0;	// 当前按键状态，无论哪个按键，都需要把按键值移动到最高位，以便与状态队列中的数值进行比较
;;;225    	
;;;226    	uint16 currentCount = 0;	// 当前按键状态计数值
;;;227    	uint16 currentState = 0;	// 当前按键状态
;;;228    	uint16* pStateCount = NULL;	// 当前操作中的状态计数值
;;;229    
;;;230    	if(!keyMsgCB.scanRequest)
000004  4f22              LDR      r7,|L10.144|
000006  7838              LDRB     r0,[r7,#0]  ; keyMsgCB
000008  2800              CMP      r0,#0
00000a  d03f              BEQ      |L10.140|
;;;231    	{
;;;232    		return ;
;;;233    	}
;;;234    	
;;;235    	keyMsgCB.scanRequest = FALSE;
00000c  2000              MOVS     r0,#0
00000e  7038              STRB     r0,[r7,#0]
;;;236    	
;;;237    	// 调用回调函数读取按键值，未注册回调函数时退出
;;;238    	if(NULL == keyMsgCB.KeyUpdate)
000010  f8d7110c          LDR      r1,[r7,#0x10c]  ; keyMsgCB
000014  2900              CMP      r1,#0
000016  d039              BEQ      |L10.140|
;;;239    	{
;;;240    		return ;
;;;241    	}
;;;242    	(*keyMsgCB.KeyUpdate)(keyMsgCB.keyValue);
000018  1c78              ADDS     r0,r7,#1
00001a  4788              BLX      r1
;;;243    	
;;;244    	// 对每个按键当前的状态进行处理，将按键状态放入各自的按键信息节点中
;;;245    	for(i=0; i<KEY_NAME_MAX; i++)
00001c  2100              MOVS     r1,#0
;;;246    	{
;;;247    		// 获取当前按键信息结构体指针
;;;248    		pKeyInfo = &keyMsgCB.keyMsgInfo[i];
;;;249    		
;;;250    		// 获取当前操作中的按键状态计数值指针
;;;251    		pStateCount = &(pKeyInfo->stateCount[pKeyInfo->end]);
;;;252    		
;;;253    		// 获取当前按键状态
;;;254    		currentState = (*pStateCount) & KEY_STATE_MASK;
;;;255    		
;;;256    		// 获取当前按键状态计数值
;;;257    		currentCount = (*pStateCount) & (~KEY_STATE_MASK);
;;;258    		
;;;259    		// 获取当前读取到的按键状态，并移位
;;;260    		currentKeyBit = keyMsgCB.keyValue[i/8]&(0x01<<(i%8));	// 屏蔽其它按键值，只保留当前按键值
00001e  f04f0801          MOV      r8,#1
                  |L10.34|
000022  eb010081          ADD      r0,r1,r1,LSL #2       ;248
000026  eb0702c0          ADD      r2,r7,r0,LSL #3       ;248
00002a  f812cf04          LDRB     r12,[r2,#4]!          ;251
00002e  eb02034c          ADD      r3,r2,r12,LSL #1      ;251
000032  1c9b              ADDS     r3,r3,#2              ;251
000034  881c              LDRH     r4,[r3,#0]            ;254
000036  f4044900          AND      r9,r4,#0x8000         ;254
00003a  f4244600          BIC      r6,r4,#0x8000         ;257
00003e  eb0700d1          ADD      r0,r7,r1,LSR #3
000042  7845              LDRB     r5,[r0,#1]
000044  f0010007          AND      r0,r1,#7
000048  fa08fa00          LSL      r10,r8,r0
00004c  ea05050a          AND      r5,r5,r10
;;;261    		currentKeyBit <<= 7 + 8 - (i%8);					// 将按键值移位到16bit的最高位
000050  f1c0000f          RSB      r0,r0,#0xf
000054  4085              LSLS     r5,r5,r0
000056  b2ad              UXTH     r5,r5
;;;262    
;;;263    		// 如果当前按键状态与上一次状态相同，则最后一个状态计数值递增
;;;264    		if(currentKeyBit == currentState)
000058  454d              CMP      r5,r9
00005a  d10a              BNE      |L10.114|
;;;265    		{
;;;266    			// 次数未溢出时，可以递增，否则不变
;;;267    			if(currentCount < (KEY_STATE_MASK-1))
00005c  f64770ff          MOV      r0,#0x7fff
000060  4286              CMP      r6,r0
000062  d20f              BCS      |L10.132|
;;;268    			{
;;;269    				// 【计数值处理方法说明】
;;;270    				// 计数值为0，说明当前计数值为1，并且已抛出边沿消息；
;;;271    				// 计数值为1，说明当前计数值为1，但未抛出边沿消息；
;;;272    				// 计数值 >1，代表实际的计数值
;;;273    				// 因此遇到计数值为0时，说明前面已经抛出了边沿消息，计数值需要增加2，以避免重复抛出边沿消息
;;;274    				if(0 == currentCount)
000064  b116              CBZ      r6,|L10.108|
;;;275    				{
;;;276    					(*pStateCount) += 2;
;;;277    				}
;;;278    				else
;;;279    				{
;;;280    					(*pStateCount) ++;
000066  1c64              ADDS     r4,r4,#1
000068  801c              STRH     r4,[r3,#0]
00006a  e00b              B        |L10.132|
                  |L10.108|
00006c  1ca4              ADDS     r4,r4,#2              ;276
00006e  801c              STRH     r4,[r3,#0]            ;276
000070  e008              B        |L10.132|
                  |L10.114|
;;;281    				}
;;;282    			}
;;;283    		}
;;;284    		// 当前按键状态与上一次状态不同，则新增状态，同时触发对应消息
;;;285    		else
;;;286    		{
;;;287    			pKeyInfo->end ++;
000072  f10c0c01          ADD      r12,r12,#1
;;;288    			pKeyInfo->end %= KEY_INFO_SIZE;
000076  f00c0001          AND      r0,r12,#1
00007a  7010              STRB     r0,[r2,#0]
;;;289    			pKeyInfo->stateCount[pKeyInfo->end] = currentKeyBit + 1;	// 当前状态添加到队列末尾，并且计数值赋1
00007c  eb020040          ADD      r0,r2,r0,LSL #1
000080  1c6d              ADDS     r5,r5,#1
000082  8045              STRH     r5,[r0,#2]
                  |L10.132|
000084  1c49              ADDS     r1,r1,#1              ;245
000086  b2c9              UXTB     r1,r1                 ;245
000088  2906              CMP      r1,#6                 ;245
00008a  d3ca              BCC      |L10.34|
                  |L10.140|
;;;290    		}
;;;291    	}
;;;292    }
00008c  e8bd87f0          POP      {r4-r10,pc}
;;;293    
                          ENDP

                  |L10.144|
                          DCD      ||.bss||

                          AREA ||i.KEYMSG_ServiceDoNothing||, CODE, READONLY, ALIGN=1

                  KEYMSG_ServiceDoNothing PROC
;;;75     // 【使用方法】空函数，什么也不做
;;;76     void KEYMSG_ServiceDoNothing(uint32 param)
000000  4770              BX       lr
;;;77     {
;;;78     	return ;
;;;79     }
;;;80     
                          ENDP


                          AREA ||i.KEYMSG_ServiceProcess||, CODE, READONLY, ALIGN=2

                  KEYMSG_ServiceProcess PROC
;;;406    // 【接口功能】按键服务处理
;;;407    void KEYMSG_ServiceProcess(void)
000000  b510              PUSH     {r4,lr}
;;;408    {
;;;409    	KEY_NAME_E keyName;
;;;410    	KEY_MSG_E keyMsg;
;;;411    	void (*service)(uint32 param) = 0;
;;;412    	
;;;413    	// 消息队列为空，退出
;;;414    	if(keyMsgCB.msgQueue.head == keyMsgCB.msgQueue.end)
000002  4c12              LDR      r4,|L12.76|
000004  f89400f4          LDRB     r0,[r4,#0xf4]  ; keyMsgCB
000008  f89410f5          LDRB     r1,[r4,#0xf5]  ; keyMsgCB
00000c  4288              CMP      r0,r1
00000e  d01b              BEQ      |L12.72|
;;;415    	{
;;;416    		return ;
;;;417    	}
;;;418    	
;;;419    	// 取出最早的消息执行
;;;420    	keyName  = keyMsgCB.msgQueue.node[keyMsgCB.msgQueue.head].keyName;
000010  eb040140          ADD      r1,r4,r0,LSL #1
000014  f8110ff6          LDRB     r0,[r1,#0xf6]!
;;;421    	keyMsg = keyMsgCB.msgQueue.node[keyMsgCB.msgQueue.head].keyMsg;
000018  7849              LDRB     r1,[r1,#1]
;;;422    	
;;;423    	if(keyName >= KEY_NAME_MAX)
00001a  2806              CMP      r0,#6
00001c  d214              BCS      |L12.72|
;;;424    	{
;;;425    		return ;
;;;426    	}
;;;427    	if(keyMsg >= KEY_MSG_MAX)
00001e  2904              CMP      r1,#4
000020  d212              BCS      |L12.72|
;;;428    	{
;;;429    		return ;
;;;430    	}
;;;431    	
;;;432    	// 执行已注册的按键消息服务
;;;433    	service = keyMsgCB.keyMsgInfo[keyName].service[keyMsg];
000022  eb000080          ADD      r0,r0,r0,LSL #2
000026  eb0400c0          ADD      r0,r4,r0,LSL #3
00002a  eb000081          ADD      r0,r0,r1,LSL #2
00002e  68c1              LDR      r1,[r0,#0xc]
;;;434    	(*service)(keyMsgCB.keyMsgInfo[keyName].param[keyMsg]);
000030  69c0              LDR      r0,[r0,#0x1c]
000032  4788              BLX      r1
;;;435    	
;;;436    	keyMsgCB.msgQueue.head ++;
000034  f8140ff4          LDRB     r0,[r4,#0xf4]!  ; keyMsgCB
000038  1c40              ADDS     r0,r0,#1
00003a  b2c0              UXTB     r0,r0
;;;437    	keyMsgCB.msgQueue.head %= KEY_MSG_QUEUE_SIZE;
00003c  210a              MOVS     r1,#0xa
00003e  fbb0f2f1          UDIV     r2,r0,r1
000042  fb010012          MLS      r0,r1,r2,r0
000046  7020              STRB     r0,[r4,#0]
                  |L12.72|
;;;438    }
000048  bd10              POP      {r4,pc}
;;;439    
                          ENDP

00004a  0000              DCW      0x0000
                  |L12.76|
                          DCD      ||.bss||

                          AREA ||i.KEYMSG_SetAddDecKeyUpRecoveryRequest||, CODE, READONLY, ALIGN=2

                  KEYMSG_SetAddDecKeyUpRecoveryRequest PROC
;;;555    // 设置+-键弹起恢复请求
;;;556    void KEYMSG_SetAddDecKeyUpRecoveryRequest(BOOL state)
000000  4901              LDR      r1,|L13.8|
;;;557    {
;;;558    	keyMsgCB.addDecKeyUpRercoveryRequest = state;
000002  f8810129          STRB     r0,[r1,#0x129]
;;;559    }
000006  4770              BX       lr
;;;560    
                          ENDP

                  |L13.8|
                          DCD      ||.bss||

                          AREA ||i.KEYMSG_SetGlobalMaskRequest||, CODE, READONLY, ALIGN=2

                  KEYMSG_SetGlobalMaskRequest PROC
;;;543    // 设置全局屏蔽请求
;;;544    void KEYMSG_SetGlobalMaskRequest(void)
000000  4902              LDR      r1,|L14.12|
;;;545    {
;;;546    	keyMsgCB.globalMaskRequest = TRUE;
000002  2001              MOVS     r0,#1
000004  f8810128          STRB     r0,[r1,#0x128]
;;;547    }
000008  4770              BX       lr
;;;548    
                          ENDP

00000a  0000              DCW      0x0000
                  |L14.12|
                          DCD      ||.bss||

                          AREA ||i.KEYMSG_SetMaskRequest||, CODE, READONLY, ALIGN=2

                  KEYMSG_SetMaskRequest PROC
;;;531    // 设置指定按键的指定消息的屏蔽请求
;;;532    void KEYMSG_SetMaskRequest(KEY_NAME_E keyName, KEY_MSG_E keyMsg)
000000  4b03              LDR      r3,|L15.16|
;;;533    {
;;;534    	keyMsgCB.msgMaskRequest[keyName][keyMsg] = TRUE;
000002  2201              MOVS     r2,#1
000004  eb030080          ADD      r0,r3,r0,LSL #2
000008  4408              ADD      r0,r0,r1
00000a  f8802110          STRB     r2,[r0,#0x110]
;;;535    }
00000e  4770              BX       lr
;;;536    
                          ENDP

                  |L15.16|
                          DCD      ||.bss||

                          AREA ||i.KEYMSG_StopAllService||, CODE, READONLY, ALIGN=2

                  KEYMSG_StopAllService PROC
;;;196    // 【使用方法】停止所有按键所有消息的响应
;;;197    void KEYMSG_StopAllService(void)
000000  b530              PUSH     {r4,r5,lr}
;;;198    {
;;;199    	uint8 i,j;
;;;200    	
;;;201    	// 按键消息服务初始化
;;;202    	for(i=0; i<KEY_NAME_MAX; i++)
000002  2100              MOVS     r1,#0
;;;203    	{
;;;204    		for(j=0; j<KEY_MSG_MAX; j++)
;;;205    		{
;;;206    			keyMsgCB.keyMsgInfo[i].service[j] = KEYMSG_ServiceDoNothing;
000004  4a09              LDR      r2,|L16.44|
000006  4d0a              LDR      r5,|L16.48|
                  |L16.8|
000008  2000              MOVS     r0,#0                 ;204
00000a  eb010381          ADD      r3,r1,r1,LSL #2
00000e  eb0503c3          ADD      r3,r5,r3,LSL #3
                  |L16.18|
000012  eb030480          ADD      r4,r3,r0,LSL #2
000016  60e2              STR      r2,[r4,#0xc]
000018  1c40              ADDS     r0,r0,#1              ;204
00001a  b2c0              UXTB     r0,r0                 ;204
00001c  2804              CMP      r0,#4                 ;204
00001e  d3f8              BCC      |L16.18|
000020  1c49              ADDS     r1,r1,#1              ;202
000022  b2c9              UXTB     r1,r1                 ;202
000024  2906              CMP      r1,#6                 ;202
000026  d3ef              BCC      |L16.8|
;;;207    		}
;;;208    	}
;;;209    }
000028  bd30              POP      {r4,r5,pc}
;;;210    
                          ENDP

00002a  0000              DCW      0x0000
                  |L16.44|
                          DCD      KEYMSG_ServiceDoNothing
                  |L16.48|
                          DCD      ||.bss||

                          AREA ||i.KEYMSG_StopService||, CODE, READONLY, ALIGN=2

                  KEYMSG_StopService PROC
;;;176    // 【使用方法】需要停止按键消息响应时，通过本接口停止对指定按键的指定消息的响应
;;;177    void KEYMSG_StopService(KEY_NAME_E keyName, KEY_MSG_E keyMsg)
000000  2806              CMP      r0,#6
;;;178    {
000002  d20a              BCS      |L17.26|
;;;179    	// 参数合法性检验
;;;180    	if(keyName >= KEY_NAME_MAX)
;;;181    	{
;;;182    		return ;
;;;183    	}
;;;184    	if(keyMsg >= KEY_MSG_MAX)
000004  2904              CMP      r1,#4
000006  d208              BCS      |L17.26|
;;;185    	{
;;;186    		return ;
;;;187    	}
;;;188    	
;;;189    	// 将对应按键的对应服务设置为空
;;;190    	keyMsgCB.keyMsgInfo[keyName].service[keyMsg] = KEYMSG_ServiceDoNothing;
000008  4b05              LDR      r3,|L17.32|
00000a  eb000080          ADD      r0,r0,r0,LSL #2
00000e  eb0300c0          ADD      r0,r3,r0,LSL #3
000012  eb000081          ADD      r0,r0,r1,LSL #2
000016  4a01              LDR      r2,|L17.28|
000018  60c2              STR      r2,[r0,#0xc]
                  |L17.26|
;;;191    }
00001a  4770              BX       lr
;;;192    
                          ENDP

                  |L17.28|
                          DCD      KEYMSG_ServiceDoNothing
                  |L17.32|
                          DCD      ||.bss||

                          AREA ||i.KEYMSG_ThrowMsg||, CODE, READONLY, ALIGN=2

                  KEYMSG_ThrowMsg PROC
;;;457    // 【接口功能】抛出按键消息，保存在消息环形队列中
;;;458    uint8 KEYMSG_ThrowMsg(KEY_NAME_E keyName, KEY_MSG_E keyMsg)
000000  b570              PUSH     {r4-r6,lr}
;;;459    {
;;;460    	// 当前按键的当前消息有屏蔽请求，则不添加，并清除屏蔽请求
;;;461    	if(keyMsgCB.msgMaskRequest[keyName][keyMsg])
000002  4a1d              LDR      r2,|L18.120|
000004  eb020380          ADD      r3,r2,r0,LSL #2
000008  440b              ADD      r3,r3,r1
00000a  f8934110          LDRB     r4,[r3,#0x110]
00000e  2c00              CMP      r4,#0
000010  d003              BEQ      |L18.26|
;;;462    	{
;;;463    		keyMsgCB.msgMaskRequest[keyName][keyMsg] = FALSE;
000012  2000              MOVS     r0,#0
000014  f8830110          STRB     r0,[r3,#0x110]
;;;464    
;;;465    		return 0;
;;;466    	}
;;;467    
;;;468    	// 有全局屏蔽请求，则退出
;;;469    	if(keyMsgCB.globalMaskRequest)
;;;470    	{
;;;471    		return 0;
;;;472    	}
;;;473    	
;;;474    	// 消息队列满，禁止添加
;;;475    	if(((keyMsgCB.msgQueue.end+1)%KEY_MSG_QUEUE_SIZE) == keyMsgCB.msgQueue.head)
;;;476    	{
;;;477    #if 0==KEY_MSG_PRIORITY	// 旧消息优先时，队列满禁止添加
;;;478    	  
;;;479    		return 0;
;;;480    		
;;;481    #else	// 新消息优先时，队列满，删除最早的消息
;;;482    		
;;;483    		keyMsgCB.msgQueue.head ++;
;;;484    		keyMsgCB.msgQueue.head %= KEY_MSG_QUEUE_SIZE;
;;;485    #endif
;;;486    	}
;;;487    	
;;;488    #if 0==KEY_MSG_THROW_KEY_UP_AFTER_REPEAT	// KEY_REPEAT 消息后禁止抛出 KEY_UP 消息
;;;489    	// KEY_UP 屏蔽位置位时，不抛出 KEY_UP 消息，并且清除屏蔽位
;;;490    	if((KEY_MSG_UP == keyMsg) && (keyMsgCB.keyUpMsgMaskBit[keyName/8] & (0x01<<(keyName%8))))
;;;491    	{
;;;492    		keyMsgCB.keyUpMsgMaskBit[keyName/8] &= (0x01<<(keyName%8));
;;;493    	}
;;;494    	else
;;;495    	{
;;;496    		// 添加到队列中
;;;497    		keyMsgCB.msgQueue.node[keyMsgCB.msgQueue.end].keyName  = keyName;
;;;498    		keyMsgCB.msgQueue.node[keyMsgCB.msgQueue.end].keyMsg = keyMsg;
;;;499    		// 队尾后移
;;;500    		keyMsgCB.msgQueue.end ++;
;;;501    		keyMsgCB.msgQueue.end %= KEY_MSG_QUEUE_SIZE;
;;;502    	}
;;;503    #else	// 无论何种情况，按键释放时均抛出 KEY_UP 消息
;;;504    	// 添加到队列中
;;;505    	keyMsgCB.msgQueue.node[keyMsgCB.msgQueue.end].keyName  = keyName;
;;;506    	keyMsgCB.msgQueue.node[keyMsgCB.msgQueue.end].keyMsg = keyMsg;
;;;507    	
;;;508    	// 队尾后移
;;;509    	keyMsgCB.msgQueue.end ++;
;;;510    	keyMsgCB.msgQueue.end %= KEY_MSG_QUEUE_SIZE;
;;;511    #endif
;;;512    
;;;513    	return 1;
;;;514    }
000018  bd70              POP      {r4-r6,pc}
                  |L18.26|
00001a  f8923128          LDRB     r3,[r2,#0x128]        ;469  ; keyMsgCB
00001e  b10b              CBZ      r3,|L18.36|
000020  2000              MOVS     r0,#0                 ;471
000022  bd70              POP      {r4-r6,pc}
                  |L18.36|
000024  f89240f5          LDRB     r4,[r2,#0xf5]         ;475  ; keyMsgCB
000028  230a              MOVS     r3,#0xa               ;475
00002a  4625              MOV      r5,r4                 ;475
00002c  1c64              ADDS     r4,r4,#1              ;475
00002e  fbb4f6f3          UDIV     r6,r4,r3              ;475
000032  fb034616          MLS      r6,r3,r6,r4           ;475
000036  f89240f4          LDRB     r4,[r2,#0xf4]         ;475  ; keyMsgCB
00003a  42a6              CMP      r6,r4                 ;475
00003c  d107              BNE      |L18.78|
00003e  1c64              ADDS     r4,r4,#1              ;483
000040  b2e4              UXTB     r4,r4                 ;483
000042  fbb4f6f3          UDIV     r6,r4,r3              ;484
000046  fb034416          MLS      r4,r3,r6,r4           ;484
00004a  f88240f4          STRB     r4,[r2,#0xf4]         ;484
                  |L18.78|
00004e  eb020445          ADD      r4,r2,r5,LSL #1       ;505
000052  f88400f6          STRB     r0,[r4,#0xf6]         ;505
000056  f89200f5          LDRB     r0,[r2,#0xf5]         ;506  ; keyMsgCB
00005a  eb020040          ADD      r0,r2,r0,LSL #1       ;506
00005e  f88010f7          STRB     r1,[r0,#0xf7]         ;506
000062  f8120ff5          LDRB     r0,[r2,#0xf5]!        ;509  ; keyMsgCB
000066  1c40              ADDS     r0,r0,#1              ;509
000068  b2c0              UXTB     r0,r0                 ;509
00006a  fbb0f1f3          UDIV     r1,r0,r3              ;510
00006e  fb030011          MLS      r0,r3,r1,r0           ;510
000072  7010              STRB     r0,[r2,#0]            ;510
000074  2001              MOVS     r0,#1                 ;513
000076  bd70              POP      {r4-r6,pc}
;;;515    
                          ENDP

                  |L18.120|
                          DCD      ||.bss||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  keyMsgCB
                          %        300

                          AREA ||.constdata||, DATA, READONLY, ALIGN=1

                  keyHoldThreshHold
000000  07d005dc          DCW      0x07d0,0x05dc
000004  07d003e8          DCW      0x07d0,0x03e8
000008  03e81770          DCW      0x03e8,0x1770
                  keyRepeatTime
00000c  012c012c          DCW      0x012c,0x012c
000010  012c012c          DCW      0x012c,0x012c
000014  012c012c          DCW      0x012c,0x012c

;*** Start embedded assembler ***

#line 1 "User\\keyMsgProcess.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_keyMsgProcess_c_7077c383____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___15_keyMsgProcess_c_7077c383____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_keyMsgProcess_c_7077c383____REVSH|
#line 128
|__asm___15_keyMsgProcess_c_7077c383____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
