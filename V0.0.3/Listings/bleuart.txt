; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\bleuart.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\bleuart.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.3\Device\Include -D__MICROLIB -D__UVISION_VERSION=539 -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\bleuart.crf User\BleUart.c]
                          THUMB

                          AREA ||i.BLE_MODULE_Reset||, CODE, READONLY, ALIGN=2

                  BLE_MODULE_Reset PROC
;;;515    // BLE模块复位
;;;516    void BLE_MODULE_Reset(uint32 param)
000000  b570              PUSH     {r4-r6,lr}
;;;517    {
;;;518    	// 蓝牙复位
;;;519    	BLE_RST_RESET();
000002  4d0a              LDR      r5,|L1.44|
000004  f44f5480          MOV      r4,#0x1000
000008  4621              MOV      r1,r4
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       gpio_bit_reset
;;;520    	Delayms(10);
000010  200a              MOVS     r0,#0xa
000012  f7fffffe          BL       Delayms
;;;521    	
;;;522    	// 释放复位
;;;523    	BLE_RST_RELEASE();
000016  4621              MOV      r1,r4
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       gpio_bit_set
;;;524    
;;;525    	// 允许开始广播
;;;526    	BLE_EN_ENABLE();
00001e  1061              ASRS     r1,r4,#1
000020  4628              MOV      r0,r5
000022  e8bd4070          POP      {r4-r6,lr}
000026  f7ffbffe          B.W      gpio_bit_reset
;;;527    }
;;;528    
                          ENDP

00002a  0000              DCW      0x0000
                  |L1.44|
                          DCD      0x40010800

                          AREA ||i.BLE_UART_AddTxArray||, CODE, READONLY, ALIGN=2

                  BLE_UART_AddTxArray PROC
;;;481    // 向发送缓冲区中添加一条待发送序列
;;;482    BOOL BLE_UART_AddTxArray(uint16 id, uint8 *pArray, uint16 length)
000000  b5f0              PUSH     {r4-r7,lr}
;;;483    {
;;;484    	uint16 i;
;;;485    	uint16 head = bleUartCB.tx.head;
000002  4d1e              LDR      r5,|L2.124|
000004  f8b571d2          LDRH     r7,[r5,#0x1d2]  ; bleUartCB
;;;486    	uint16 end = bleUartCB.tx.end;
000008  f8b531d4          LDRH     r3,[r5,#0x1d4]  ; bleUartCB
;;;487    	
;;;488    	// 参数检验
;;;489    	if ((NULL == pArray) || (0 == length))
00000c  2900              CMP      r1,#0
00000e  d00a              BEQ      |L2.38|
000010  b14a              CBZ      r2,|L2.38|
;;;490    	{
;;;491    		return FALSE;
;;;492    	}
;;;493    
;;;494    	// 发送缓冲区已满，不予接收
;;;495    	if((end + 1) % BLE_UART_DRIVE_TX_QUEUE_SIZE == head)
000012  1c5e              ADDS     r6,r3,#1
000014  2403              MOVS     r4,#3
000016  fbb6fcf4          UDIV     r12,r6,r4
00001a  fb04661c          MLS      r6,r4,r12,r6
00001e  42be              CMP      r6,r7
000020  d103              BNE      |L2.42|
;;;496    	{
;;;497    		return FALSE;
000022  2000              MOVS     r0,#0
;;;498    	}
;;;499    
;;;500    	bleUartCB.tx.cmdQueue[end].deviceID = id;
;;;501    	for (i = 0; i < length; i++)
;;;502    	{
;;;503    		bleUartCB.tx.cmdQueue[end].buff[i] = *pArray++;
;;;504    	}
;;;505    	bleUartCB.tx.cmdQueue[end].length = length;
;;;506    	
;;;507    	// 发送环形队列更新位置
;;;508    	bleUartCB.tx.end ++;
;;;509    	bleUartCB.tx.end %= BLE_UART_DRIVE_TX_QUEUE_SIZE;
;;;510    	bleUartCB.tx.cmdQueue[bleUartCB.tx.end].length = 0;
;;;511    
;;;512    	return TRUE;
;;;513    }
000024  bdf0              POP      {r4-r7,pc}
                  |L2.38|
000026  2000              MOVS     r0,#0                 ;491
000028  bdf0              POP      {r4-r7,pc}
                  |L2.42|
00002a  264d              MOVS     r6,#0x4d              ;500
00002c  4373              MULS     r3,r6,r3              ;500
00002e  eb050343          ADD      r3,r5,r3,LSL #1       ;500
000032  8098              STRH     r0,[r3,#4]            ;500
000034  2000              MOVS     r0,#0                 ;501
000036  e005              B        |L2.68|
                  |L2.56|
000038  181f              ADDS     r7,r3,r0              ;503
00003a  f8116b01          LDRB     r6,[r1],#1            ;503
00003e  71be              STRB     r6,[r7,#6]            ;503
000040  1c40              ADDS     r0,r0,#1              ;501
000042  b280              UXTH     r0,r0                 ;501
                  |L2.68|
000044  4290              CMP      r0,r2                 ;501
000046  d3f7              BCC      |L2.56|
000048  f8a3209c          STRH     r2,[r3,#0x9c]         ;505
00004c  f50575ea          ADD      r5,r5,#0x1d4          ;508
000050  8828              LDRH     r0,[r5,#0]            ;508  ; bleUartCB
000052  1c40              ADDS     r0,r0,#1              ;508
000054  8028              STRH     r0,[r5,#0]            ;508
000056  8828              LDRH     r0,[r5,#0]            ;509  ; bleUartCB
000058  fbb0f1f4          UDIV     r1,r0,r4              ;509
00005c  fb040011          MLS      r0,r4,r1,r0           ;509
000060  8028              STRH     r0,[r5,#0]            ;509
000062  8828              LDRH     r0,[r5,#0]            ;510  ; bleUartCB
000064  2100              MOVS     r1,#0                 ;510
000066  224d              MOVS     r2,#0x4d              ;510
000068  f5a575ea          SUB      r5,r5,#0x1d4          ;510
00006c  4350              MULS     r0,r2,r0              ;510
00006e  eb050040          ADD      r0,r5,r0,LSL #1       ;510
000072  f8a0109c          STRH     r1,[r0,#0x9c]         ;510
000076  2001              MOVS     r0,#1                 ;512
000078  bdf0              POP      {r4-r7,pc}
;;;514    
                          ENDP

00007a  0000              DCW      0x0000
                  |L2.124|
                          DCD      ||.bss||+0x14

                          AREA ||i.BLE_UART_BC_SendData||, CODE, READONLY, ALIGN=2

                  BLE_UART_BC_SendData PROC
;;;103    // 阻塞发送一个字节数据
;;;104    void BLE_UART_BC_SendData(uint8 data)
000000  b570              PUSH     {r4-r6,lr}
;;;105    {	
000002  4605              MOV      r5,r0
;;;106    	// 防止丢失第一个字节(清除空标志位,务必加) 
;;;107    	usart_flag_get(BLE_UART_TYPE_DEF, USART_FLAG_TC);		
000004  4c07              LDR      r4,|L3.36|
000006  2106              MOVS     r1,#6
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       usart_flag_get
;;;108    
;;;109    	// 填充数据
;;;110    	usart_data_transmit(BLE_UART_TYPE_DEF, data);
00000e  4629              MOV      r1,r5
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       usart_data_transmit
                  |L3.22|
;;;111    
;;;112    	// 未发送完，持续等待
;;;113    	while(usart_flag_get(BLE_UART_TYPE_DEF, USART_FLAG_TC) != SET);		
000016  2106              MOVS     r1,#6
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       usart_flag_get
00001e  2801              CMP      r0,#1
000020  d1f9              BNE      |L3.22|
;;;114    }
000022  bd70              POP      {r4-r6,pc}
;;;115    
                          ENDP

                  |L3.36|
                          DCD      0x40013800

                          AREA ||i.BLE_UART_BleConnectState||, CODE, READONLY, ALIGN=2

                  BLE_UART_BleConnectState PROC
;;;137    uint8 bleIndex = 0;
;;;138    void BLE_UART_BleConnectState(uint32 param)
000000  4903              LDR      r1,|L4.16|
;;;139    {	
;;;140    	bleIndex = 0;
000002  2000              MOVS     r0,#0
000004  7008              STRB     r0,[r1,#0]
;;;141    
;;;142    	if (-1 != STRING_Find(bleRxBuff, "TTM:CONNECTED"))
000006  a103              ADR      r1,|L4.20|
000008  4806              LDR      r0,|L4.36|
00000a  f7ffbffe          B.W      STRING_Find
;;;143    	{
;;;144    		// 开启鉴权定时器，10s钟内如果没有鉴权成功则退出蓝牙连接
;;;145    //		TIMER_AddTask(TIMER_ID_BLE_CONNECT_VERIFICATE,
;;;146    //					60000,
;;;147    //					BLE_MODULE_Reset,
;;;148    //					0,
;;;149    //					1,
;;;150    //					ACTION_MODE_ADD_TO_QUEUE);
;;;151    	}
;;;152    }
;;;153    
                          ENDP

00000e  0000              DCW      0x0000
                  |L4.16|
                          DCD      ||.data||
                  |L4.20|
000014  54544d3a          DCB      "TTM:CONNECTED",0
000018  434f4e4e
00001c  45435445
000020  4400    
000022  00                DCB      0
000023  00                DCB      0
                  |L4.36|
                          DCD      ||.bss||

                          AREA ||i.BLE_UART_CALLBALL_GetBleMacAddrRequest||, CODE, READONLY, ALIGN=1

                  BLE_UART_CALLBALL_GetBleMacAddrRequest PROC
;;;365    // 定时器回调发送获取蓝牙地址命令
;;;366    void BLE_UART_CALLBALL_GetBleMacAddrRequest(uint32 param)
000000  2001              MOVS     r0,#1
;;;367    {
;;;368    	// 发送获取MAC地址
;;;369    	BLE_UART_SendCmdGetBleMacAddr(TRUE);
000002  f7ffbffe          B.W      BLE_UART_SendCmdGetBleMacAddr
;;;370    }
;;;371    
                          ENDP


                          AREA ||i.BLE_UART_DataStructureInit||, CODE, READONLY, ALIGN=1

                  BLE_UART_DataStructureInit PROC
;;;372    // 数据结构初始化
;;;373    void BLE_UART_DataStructureInit(BLE_UART_CB* pCB)
000000  2800              CMP      r0,#0
;;;374    {
000002  d013              BEQ      |L6.44|
;;;375    	uint16 i;
;;;376    	
;;;377    	// 参数合法性检验
;;;378    	if (NULL == pCB)
;;;379    	{
;;;380    		return;
;;;381    	}
;;;382    
;;;383    	pCB->tx.txBusy = FALSE;
000004  2200              MOVS     r2,#0
000006  f88021d8          STRB     r2,[r0,#0x1d8]
;;;384    	pCB->tx.index = 0;
00000a  f8a021d6          STRH     r2,[r0,#0x1d6]
;;;385    	pCB->tx.head = 0;
00000e  f8a021d2          STRH     r2,[r0,#0x1d2]
;;;386    	pCB->tx.end = 0;
000012  f8a021d4          STRH     r2,[r0,#0x1d4]
;;;387    	for(i = 0; i < BLE_UART_DRIVE_TX_QUEUE_SIZE; i++)
000016  2100              MOVS     r1,#0
                  |L6.24|
;;;388    	{
;;;389    		pCB->tx.cmdQueue[i].length = 0;
000018  234d              MOVS     r3,#0x4d
00001a  434b              MULS     r3,r1,r3
00001c  eb000343          ADD      r3,r0,r3,LSL #1
000020  f8a3209c          STRH     r2,[r3,#0x9c]
000024  1c49              ADDS     r1,r1,#1              ;387
000026  b289              UXTH     r1,r1                 ;387
000028  2903              CMP      r1,#3                 ;387
00002a  d3f5              BCC      |L6.24|
                  |L6.44|
;;;390    	}
;;;391    }
00002c  4770              BX       lr
;;;392    
                          ENDP


                          AREA ||i.BLE_UART_HwInit||, CODE, READONLY, ALIGN=2

                  BLE_UART_HwInit PROC
;;;55     // UART初始化
;;;56     void BLE_UART_HwInit(uint32 baud)
000000  b570              PUSH     {r4-r6,lr}
;;;57     {
000002  4605              MOV      r5,r0
;;;58     	// 打开时钟
;;;59     	rcu_periph_clock_enable(RCU_GPIOA);
000004  f2406002          MOV      r0,#0x602
000008  f7fffffe          BL       rcu_periph_clock_enable
;;;60     	gpio_init(GPIOA, GPIO_MODE_AF_PP, GPIO_OSPEED_2MHZ, GPIO_PIN_9);
00000c  4e34              LDR      r6,|L7.224|
00000e  f44f7300          MOV      r3,#0x200
000012  2202              MOVS     r2,#2
000014  2118              MOVS     r1,#0x18
000016  4630              MOV      r0,r6
000018  f7fffffe          BL       gpio_init
;;;61     	
;;;62     	gpio_init(GPIOA, GPIO_MODE_IPU, GPIO_OSPEED_2MHZ, GPIO_PIN_10);
00001c  1533              ASRS     r3,r6,#20
00001e  2202              MOVS     r2,#2
000020  2148              MOVS     r1,#0x48
000022  4630              MOV      r0,r6
000024  f7fffffe          BL       gpio_init
;;;63     
;;;64     	// UART时钟配置
;;;65     	rcu_periph_clock_enable(RCU_USART0);
000028  f240600e          MOV      r0,#0x60e
00002c  f7fffffe          BL       rcu_periph_clock_enable
;;;66     	usart_deinit(BLE_UART_TYPE_DEF);									// 复位串口
000030  4c2c              LDR      r4,|L7.228|
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       usart_deinit
;;;67     		
;;;68     	// 串口配置
;;;69     	usart_baudrate_set(BLE_UART_TYPE_DEF, baud);						// 波特率
000038  4629              MOV      r1,r5
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       usart_baudrate_set
;;;70     	usart_word_length_set(BLE_UART_TYPE_DEF, USART_WL_8BIT);			// 8位数据位
000040  2100              MOVS     r1,#0
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       usart_word_length_set
;;;71     	usart_stop_bit_set(BLE_UART_TYPE_DEF, USART_STB_1BIT); 				// 一个停止位
000048  2100              MOVS     r1,#0
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       usart_stop_bit_set
;;;72     	usart_parity_config(BLE_UART_TYPE_DEF, USART_PM_NONE); 				// 无奇偶校验
000050  2100              MOVS     r1,#0
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       usart_parity_config
;;;73     	usart_hardware_flow_rts_config(BLE_UART_TYPE_DEF, USART_RTS_DISABLE); // 无硬件数据流控制
000058  2100              MOVS     r1,#0
00005a  4620              MOV      r0,r4
00005c  f7fffffe          BL       usart_hardware_flow_rts_config
;;;74     	usart_hardware_flow_cts_config(BLE_UART_TYPE_DEF, USART_CTS_DISABLE);
000060  2100              MOVS     r1,#0
000062  4620              MOV      r0,r4
000064  f7fffffe          BL       usart_hardware_flow_cts_config
;;;75     	usart_transmit_config(BLE_UART_TYPE_DEF, USART_TRANSMIT_ENABLE);	// 使能发射
000068  2108              MOVS     r1,#8
00006a  4620              MOV      r0,r4
00006c  f7fffffe          BL       usart_transmit_config
;;;76     	usart_receive_config(BLE_UART_TYPE_DEF, USART_RECEIVE_ENABLE); 		// 使能接收
000070  2104              MOVS     r1,#4
000072  4620              MOV      r0,r4
000074  f7fffffe          BL       usart_receive_config
;;;77     
;;;78     	// 中断配置
;;;79     	nvic_irq_enable(BLE_UART_IRQn_DEF, 2, 1);
000078  2201              MOVS     r2,#1
00007a  2102              MOVS     r1,#2
00007c  2025              MOVS     r0,#0x25
00007e  f7fffffe          BL       nvic_irq_enable
;;;80     
;;;81     	usart_interrupt_enable(BLE_UART_TYPE_DEF, USART_INT_RBNE); 			// 开启中断
000082  f2403105          MOV      r1,#0x305
000086  4620              MOV      r0,r4
000088  f7fffffe          BL       usart_interrupt_enable
;;;82     
;;;83     	usart_enable(BLE_UART_TYPE_DEF);									// 使能串口 
00008c  4620              MOV      r0,r4
00008e  f7fffffe          BL       usart_enable
;;;84     
;;;85     //====================================================================================================================
;;;86     
;;;87     	rcu_periph_clock_enable(RCU_GPIOC);
000092  f2406004          MOV      r0,#0x604
000096  f7fffffe          BL       rcu_periph_clock_enable
;;;88     
;;;89     	gpio_init(GPIOA, GPIO_MODE_OUT_PP, GPIO_OSPEED_2MHZ, GPIO_PIN_11);
00009a  14e4              ASRS     r4,r4,#19
00009c  4623              MOV      r3,r4
00009e  2202              MOVS     r2,#2
0000a0  2110              MOVS     r1,#0x10
0000a2  4630              MOV      r0,r6
0000a4  f7fffffe          BL       gpio_init
;;;90     	gpio_init(GPIOA, GPIO_MODE_OUT_PP, GPIO_OSPEED_2MHZ, GPIO_PIN_12);
0000a8  0065              LSLS     r5,r4,#1
0000aa  462b              MOV      r3,r5
0000ac  2202              MOVS     r2,#2
0000ae  2110              MOVS     r1,#0x10
0000b0  4630              MOV      r0,r6
0000b2  f7fffffe          BL       gpio_init
;;;91     
;;;92     	// 释放复位
;;;93     	BLE_RST_RELEASE();
0000b6  4629              MOV      r1,r5
0000b8  4630              MOV      r0,r6
0000ba  f7fffffe          BL       gpio_bit_set
;;;94     	// 允许开始广播
;;;95     	BLE_EN_ENABLE();
0000be  4621              MOV      r1,r4
0000c0  4630              MOV      r0,r6
0000c2  f7fffffe          BL       gpio_bit_reset
;;;96     
;;;97     	gpio_init(GPIOC, GPIO_MODE_OUT_PP, GPIO_OSPEED_2MHZ, GPIO_PIN_12);
0000c6  4c08              LDR      r4,|L7.232|
0000c8  462b              MOV      r3,r5
0000ca  2202              MOVS     r2,#2
0000cc  2110              MOVS     r1,#0x10
0000ce  4620              MOV      r0,r4
0000d0  f7fffffe          BL       gpio_init
;;;98     
;;;99     	// 上电后一直处于发送准备状态
;;;100    	gpio_bit_reset(GPIOC, GPIO_PIN_12);
0000d4  4629              MOV      r1,r5
0000d6  4620              MOV      r0,r4
0000d8  e8bd4070          POP      {r4-r6,lr}
0000dc  f7ffbffe          B.W      gpio_bit_reset
;;;101    }
;;;102    
                          ENDP

                  |L7.224|
                          DCD      0x40010800
                  |L7.228|
                          DCD      0x40013800
                  |L7.232|
                          DCD      0x40011000

                          AREA ||i.BLE_UART_IR_StartSendData||, CODE, READONLY, ALIGN=2

                  BLE_UART_IR_StartSendData PROC
;;;116    // 启动中断字节发送
;;;117    void BLE_UART_IR_StartSendData(uint8 data)
000000  b570              PUSH     {r4-r6,lr}
;;;118    {
000002  4605              MOV      r5,r0
;;;119    	// 先读SR，再填充DR会把TC标志清掉
;;;120    	usart_flag_get(BLE_UART_TYPE_DEF, USART_FLAG_TC);
000004  4c07              LDR      r4,|L8.36|
000006  2106              MOVS     r1,#6
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       usart_flag_get
;;;121    
;;;122    	// 发送一个字节
;;;123    	usart_data_transmit(BLE_UART_TYPE_DEF, data);
00000e  4629              MOV      r1,r5
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       usart_data_transmit
;;;124    
;;;125    	// 打开发送完成中断
;;;126    	usart_interrupt_enable(BLE_UART_TYPE_DEF, USART_INT_TC);	
000016  4620              MOV      r0,r4
000018  e8bd4070          POP      {r4-r6,lr}
00001c  f2403106          MOV      r1,#0x306
000020  f7ffbffe          B.W      usart_interrupt_enable
;;;127    }
;;;128    
                          ENDP

                  |L8.36|
                          DCD      0x40013800

                          AREA ||i.BLE_UART_Init||, CODE, READONLY, ALIGN=2

                  BLE_UART_Init PROC
;;;37     // UART初始化
;;;38     void BLE_UART_Init(void)
000000  b510              PUSH     {r4,lr}
;;;39     {
;;;40     	// 由安卓端点击蓝牙升级时，应用层跳转boot需要屏蔽掉蓝牙模块初始化，防止蓝牙断开连接
;;;41     	if(0xAA == SPI_FLASH_ReadByte(SPI_FLASH_BLE_UPDATA_FLAG_ADDEESS + 1))
000002  4c0a              LDR      r4,|L9.44|
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       SPI_FLASH_ReadByte
00000a  28aa              CMP      r0,#0xaa
00000c  d008              BEQ      |L9.32|
;;;42     	{
;;;43     		// 清除蓝牙升级时，跳转boot屏蔽初始化标志位，重启之后需要重新初始化蓝牙，防止升级失败
;;;44     		SPI_FLASH_WriteByte(SPI_FLASH_BLE_UPDATA_FLAG_ADDEESS + 1, 0xFF);
;;;45     	}
;;;46     	else
;;;47     	{
;;;48     		BLE_UART_HwInit(BLE_UART_BAUD_RATE);
00000e  f44f5016          MOV      r0,#0x2580
000012  f7fffffe          BL       BLE_UART_HwInit
                  |L9.22|
;;;49     	}
;;;50     	
;;;51     	// UART数据结构初始化
;;;52     	BLE_UART_DataStructureInit(&bleUartCB);	
000016  e8bd4010          POP      {r4,lr}
00001a  4805              LDR      r0,|L9.48|
00001c  f7ffbffe          B.W      BLE_UART_DataStructureInit
                  |L9.32|
000020  21ff              MOVS     r1,#0xff              ;44
000022  4620              MOV      r0,r4                 ;44
000024  f7fffffe          BL       SPI_FLASH_WriteByte
000028  e7f5              B        |L9.22|
;;;53     }
;;;54     
                          ENDP

00002a  0000              DCW      0x0000
                  |L9.44|
                          DCD      0x003ff081
                  |L9.48|
                          DCD      ||.bss||+0x14

                          AREA ||i.BLE_UART_Process||, CODE, READONLY, ALIGN=2

                  BLE_UART_Process PROC
;;;468    // UART模块处理入口
;;;469    void BLE_UART_Process(void)
000000  4801              LDR      r0,|L10.8|
;;;470    {
;;;471    	// 发送处理
;;;472    	BLE_UART_TxProcess(&bleUartCB);
000002  f7ffbffe          B.W      BLE_UART_TxProcess
;;;473    }
;;;474    
                          ENDP

000006  0000              DCW      0x0000
                  |L10.8|
                          DCD      ||.bss||+0x14

                          AREA ||i.BLE_UART_RcvBleMacAddr||, CODE, READONLY, ALIGN=2

                  BLE_UART_RcvBleMacAddr PROC
;;;272    // 接收蓝牙mac地址
;;;273    void BLE_UART_RcvBleMacAddr(uint8 data)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;274    {
;;;275    	uint8 i;
;;;276    	
;;;277    	if (!bleUartCB.rx.startFlag)
000004  4c40              LDR      r4,|L11.264|
;;;278    	{
;;;279    		if (data == 'T')				// 起始标志
;;;280    		{
;;;281    			bleUartCB.rx.startFlag = TRUE;
000006  2601              MOVS     r6,#1
000008  2500              MOVS     r5,#0
00000a  f89411da          LDRB     r1,[r4,#0x1da]        ;277  ; bleUartCB
00000e  2900              CMP      r1,#0                 ;277
000010  d011              BEQ      |L11.54|
;;;282    
;;;283    			bleUartCB.rx.index = 0;
;;;284    
;;;285    			bleUartCB.rx.fifoBuff[bleUartCB.rx.index++] = data;		
;;;286    			
;;;287    			return;
;;;288    		}
;;;289    	}
;;;290    	else
;;;291    	{
;;;292    		// 连续接收数据
;;;293    		bleUartCB.rx.fifoBuff[bleUartCB.rx.index++] = data;
000012  f8941221          LDRB     r1,[r4,#0x221]  ; bleUartCB
000016  1c4a              ADDS     r2,r1,#1
000018  4421              ADD      r1,r1,r4
00001a  f8842221          STRB     r2,[r4,#0x221]
00001e  f88101db          STRB     r0,[r1,#0x1db]
;;;294    
;;;295    		// 越界判断
;;;296    		if (bleUartCB.rx.index >= sizeof(bleUartCB.rx.fifoBuff))
000022  f8941221          LDRB     r1,[r4,#0x221]  ; bleUartCB
000026  2932              CMP      r1,#0x32
000028  d30e              BCC      |L11.72|
;;;297    		{
;;;298    			bleUartCB.rx.startFlag = TRUE;
00002a  f88461da          STRB     r6,[r4,#0x1da]
;;;299    			bleUartCB.rx.index = 0;
00002e  f8845221          STRB     r5,[r4,#0x221]
                  |L11.50|
;;;300    
;;;301    			return;
;;;302    		}
;;;303    		
;;;304    		if (data == '\n')			// 收到结束标志
;;;305    		{
;;;306    			bleUartCB.rx.startFlag = FALSE;
;;;307    			bleUartCB.rx.index = 0;
;;;308    
;;;309    			bleUartCB.rx.macBuff[2] = ':';
;;;310    			bleUartCB.rx.macBuff[5] = ':';
;;;311    			bleUartCB.rx.macBuff[8] = ':';
;;;312    			bleUartCB.rx.macBuff[11] = ':';
;;;313    			bleUartCB.rx.macBuff[14] = ':';
;;;314    			bleUartCB.rx.macBuff[17] = '\0';
;;;315    
;;;316    			// 过滤回显指令
;;;317    			if ((strstr((const char*)bleUartCB.rx.fifoBuff, (const char*)"TTM:MAC-?") != NULL))
;;;318    			{
;;;319    				return ;
;;;320    			}
;;;321    
;;;322    			// 将读到的蓝牙mac地址提取出来
;;;323    			if ((strstr((const char*)bleUartCB.rx.fifoBuff, (const char*)"TTM:MAC-") != NULL) 
;;;324    			&& (bleUartCB.rx.fifoBuff[0] == 'T') && (bleUartCB.rx.fifoBuff[1] == 'T') && (bleUartCB.rx.fifoBuff[2] == 'M'))
;;;325    			{
;;;326    				bleUartCB.rx.macBuff[0] = bleUartCB.rx.fifoBuff[8];
;;;327    				bleUartCB.rx.macBuff[1] = bleUartCB.rx.fifoBuff[9];
;;;328    
;;;329    				bleUartCB.rx.macBuff[3] = bleUartCB.rx.fifoBuff[10];
;;;330    				bleUartCB.rx.macBuff[4] = bleUartCB.rx.fifoBuff[11];
;;;331    
;;;332    				bleUartCB.rx.macBuff[6] = bleUartCB.rx.fifoBuff[12];
;;;333    				bleUartCB.rx.macBuff[7] = bleUartCB.rx.fifoBuff[13];
;;;334    
;;;335    				bleUartCB.rx.macBuff[9] = bleUartCB.rx.fifoBuff[14];
;;;336    				bleUartCB.rx.macBuff[10] = bleUartCB.rx.fifoBuff[15];
;;;337    
;;;338    				bleUartCB.rx.macBuff[12] = bleUartCB.rx.fifoBuff[16];
;;;339    				bleUartCB.rx.macBuff[13] = bleUartCB.rx.fifoBuff[17];
;;;340    
;;;341    				bleUartCB.rx.macBuff[15] = bleUartCB.rx.fifoBuff[18];
;;;342    				bleUartCB.rx.macBuff[16] = bleUartCB.rx.fifoBuff[19];
;;;343    
;;;344    				//for (i = 0; i < 12; i++)
;;;345    				//{
;;;346    				//	bleUartCB.rx.macBuff[i] = bleUartCB.rx.fifoBuff[i+10];
;;;347    				//}
;;;348    				//bleUartCB.rx.macBuff[i] = '\0';
;;;349    				
;;;350    				for (i = 0; i < sizeof(bleUartCB.rx.fifoBuff); i++)
;;;351    				{
;;;352    					bleUartCB.rx.fifoBuff[i] = 0;
;;;353    				}				
;;;354    
;;;355    				// 注销该定时器
;;;356    				TIMER_KillTask(TIMER_ID_BLE_CONTROL);
;;;357    
;;;358    				// 蓝牙地址接收完成
;;;359    				bleUartCB.rcvBleMacOK = TRUE;
;;;360    			}	
;;;361    		}
;;;362    	}
;;;363    }
000032  e8bd81f0          POP      {r4-r8,pc}
                  |L11.54|
000036  2854              CMP      r0,#0x54              ;279
000038  d1fb              BNE      |L11.50|
00003a  f88461da          STRB     r6,[r4,#0x1da]        ;281
00003e  f8846221          STRB     r6,[r4,#0x221]        ;285
000042  f88401db          STRB     r0,[r4,#0x1db]        ;285
000046  e7f4              B        |L11.50|
                  |L11.72|
000048  280a              CMP      r0,#0xa               ;304
00004a  d1f2              BNE      |L11.50|
00004c  f2042402          ADD      r4,r4,#0x202          ;306
000050  f8045c28          STRB     r5,[r4,#-0x28]        ;306
000054  77e5              STRB     r5,[r4,#0x1f]         ;307
000056  203a              MOVS     r0,#0x3a              ;309
000058  7360              STRB     r0,[r4,#0xd]          ;309
00005a  7420              STRB     r0,[r4,#0x10]         ;310
00005c  74e0              STRB     r0,[r4,#0x13]         ;311
00005e  75a0              STRB     r0,[r4,#0x16]         ;312
000060  7660              STRB     r0,[r4,#0x19]         ;313
000062  7725              STRB     r5,[r4,#0x1c]         ;314
000064  f2a42402          SUB      r4,r4,#0x202          ;314
000068  482b              LDR      r0,|L11.280|
00006a  a128              ADR      r1,|L11.268|
00006c  4607              MOV      r7,r0                 ;317
00006e  f7fffffe          BL       strstr
000072  2800              CMP      r0,#0                 ;317
000074  d1dd              BNE      |L11.50|
000076  a129              ADR      r1,|L11.284|
000078  4638              MOV      r0,r7                 ;323
00007a  f7fffffe          BL       strstr
00007e  2800              CMP      r0,#0                 ;323
000080  d0d7              BEQ      |L11.50|
000082  f89401db          LDRB     r0,[r4,#0x1db]        ;324  ; bleUartCB
000086  2854              CMP      r0,#0x54              ;324
000088  d1d3              BNE      |L11.50|
00008a  f89401dc          LDRB     r0,[r4,#0x1dc]        ;324  ; bleUartCB
00008e  2854              CMP      r0,#0x54              ;324
000090  d1cf              BNE      |L11.50|
000092  f89401dd          LDRB     r0,[r4,#0x1dd]        ;324  ; bleUartCB
000096  284d              CMP      r0,#0x4d              ;324
000098  d1cb              BNE      |L11.50|
00009a  f20414e3          ADD      r4,r4,#0x1e3          ;326
00009e  7820              LDRB     r0,[r4,#0]            ;326  ; bleUartCB
0000a0  f884002a          STRB     r0,[r4,#0x2a]         ;326
0000a4  7860              LDRB     r0,[r4,#1]            ;327  ; bleUartCB
0000a6  f884002b          STRB     r0,[r4,#0x2b]         ;327
0000aa  78a0              LDRB     r0,[r4,#2]            ;329  ; bleUartCB
0000ac  f884002d          STRB     r0,[r4,#0x2d]         ;329
0000b0  78e0              LDRB     r0,[r4,#3]            ;330  ; bleUartCB
0000b2  f884002e          STRB     r0,[r4,#0x2e]         ;330
0000b6  7920              LDRB     r0,[r4,#4]            ;332  ; bleUartCB
0000b8  f8840030          STRB     r0,[r4,#0x30]         ;332
0000bc  7960              LDRB     r0,[r4,#5]            ;333  ; bleUartCB
0000be  f8840031          STRB     r0,[r4,#0x31]         ;333
0000c2  79a0              LDRB     r0,[r4,#6]            ;335  ; bleUartCB
0000c4  f8840033          STRB     r0,[r4,#0x33]         ;335
0000c8  79e0              LDRB     r0,[r4,#7]            ;336  ; bleUartCB
0000ca  f8840034          STRB     r0,[r4,#0x34]         ;336
0000ce  7a20              LDRB     r0,[r4,#8]            ;338  ; bleUartCB
0000d0  f8840036          STRB     r0,[r4,#0x36]         ;338
0000d4  7a60              LDRB     r0,[r4,#9]            ;339  ; bleUartCB
0000d6  f8840037          STRB     r0,[r4,#0x37]         ;339
0000da  7aa0              LDRB     r0,[r4,#0xa]          ;341  ; bleUartCB
0000dc  f8840039          STRB     r0,[r4,#0x39]         ;341
0000e0  7ae0              LDRB     r0,[r4,#0xb]          ;342  ; bleUartCB
0000e2  f884003a          STRB     r0,[r4,#0x3a]         ;342
0000e6  f2a414e3          SUB      r4,r4,#0x1e3          ;342
0000ea  2000              MOVS     r0,#0                 ;350
                  |L11.236|
0000ec  1821              ADDS     r1,r4,r0              ;352
0000ee  f88151db          STRB     r5,[r1,#0x1db]        ;352
0000f2  1c40              ADDS     r0,r0,#1              ;350
0000f4  b2c0              UXTB     r0,r0                 ;350
0000f6  2832              CMP      r0,#0x32              ;350
0000f8  d3f8              BCC      |L11.236|
0000fa  2003              MOVS     r0,#3                 ;356
0000fc  f7fffffe          BL       TIMER_KillTask
000100  f8846222          STRB     r6,[r4,#0x222]        ;359
000104  e795              B        |L11.50|
;;;364    
                          ENDP

000106  0000              DCW      0x0000
                  |L11.264|
                          DCD      ||.bss||+0x14
                  |L11.268|
00010c  54544d3a          DCB      "TTM:MAC-?",0
000110  4d41432d
000114  3f00    
000116  00                DCB      0
000117  00                DCB      0
                  |L11.280|
                          DCD      ||.bss||+0x1ef
                  |L11.284|
00011c  54544d3a          DCB      "TTM:MAC-",0
000120  4d41432d
000124  00      
000125  00                DCB      0
000126  00                DCB      0
000127  00                DCB      0

                          AREA ||i.BLE_UART_RegisterDataSendService||, CODE, READONLY, ALIGN=2

                  BLE_UART_RegisterDataSendService PROC
;;;475    // 注册数据抛出接口服务
;;;476    void BLE_UART_RegisterDataSendService(void (*service)(uint16 id, uint8 *pData, uint16 length))
000000  4901              LDR      r1,|L12.8|
;;;477    {
;;;478    	bleUartCB.receiveDataThrowService = service;
000002  6008              STR      r0,[r1,#0]  ; bleUartCB
;;;479    }
000004  4770              BX       lr
;;;480    
                          ENDP

000006  0000              DCW      0x0000
                  |L12.8|
                          DCD      ||.bss||+0x14

                          AREA ||i.BLE_UART_SendCmdGetBleMacAddr||, CODE, READONLY, ALIGN=2

                  BLE_UART_SendCmdGetBleMacAddr PROC
;;;255    // 发送获取MAC地址
;;;256    void BLE_UART_SendCmdGetBleMacAddr(uint32 param)
000000  b53e              PUSH     {r1-r5,lr}
;;;257    {
;;;258    	uint8 i;
;;;259    	uint8 bleMacStr[] = "TTM:MAC-?";
000002  a009              ADR      r0,|L13.40|
000004  e9d01200          LDRD     r1,r2,[r0,#0]
000008  6880              LDR      r0,[r0,#8]
00000a  e9cd1200          STRD     r1,r2,[sp,#0]
00000e  9002              STR      r0,[sp,#8]
;;;260    	
;;;261    	// 使能BLE发送
;;;262    	BLE_BRTS_TX_REQUEST();
;;;263    
;;;264    	// 查询蓝牙mac指令,启动阻塞式发送
;;;265    	for (i = 0; bleMacStr[i] != '\0'; i++)
000010  2400              MOVS     r4,#0
000012  466d              MOV      r5,sp                 ;259
000014  e003              B        |L13.30|
                  |L13.22|
;;;266    	{
;;;267    		// 填充数据，启动发送
;;;268    		BLE_UART_BC_SendData(bleMacStr[i]);
000016  f7fffffe          BL       BLE_UART_BC_SendData
00001a  1c64              ADDS     r4,r4,#1              ;265
00001c  b2e4              UXTB     r4,r4                 ;265
                  |L13.30|
00001e  5d28              LDRB     r0,[r5,r4]            ;265
000020  2800              CMP      r0,#0                 ;265
000022  d1f8              BNE      |L13.22|
;;;269    	}	
;;;270    }
000024  bd3e              POP      {r1-r5,pc}
;;;271    
                          ENDP

000026  0000              DCW      0x0000
                  |L13.40|
000028  54544d3a          DCB      "TTM:MAC-?",0
00002c  4d41432d
000030  3f00    
000032  00                DCB      0
000033  00                DCB      0

                          AREA ||i.BLE_UART_TxProcess||, CODE, READONLY, ALIGN=1

                  BLE_UART_TxProcess PROC
;;;393    // 发送处理
;;;394    void BLE_UART_TxProcess(BLE_UART_CB* pCB)
000000  b510              PUSH     {r4,lr}
;;;395    {
000002  4604              MOV      r4,r0
;;;396    // 中断方式
;;;397    #if (BLE_UART_TX_MODE == BLE_UART_INTERRUPT_TX_MODE)
;;;398    	uint16 index = pCB->tx.index;							// 当前发送数据的索引号
000004  f8b401d6          LDRH     r0,[r4,#0x1d6]
;;;399    	uint16 length = pCB->tx.cmdQueue[pCB->tx.head].length;	// 当前发送的命令帧的长度
000008  f8b411d2          LDRH     r1,[r4,#0x1d2]
00000c  224d              MOVS     r2,#0x4d
00000e  4351              MULS     r1,r2,r1
000010  eb040141          ADD      r1,r4,r1,LSL #1
000014  f8b1209c          LDRH     r2,[r1,#0x9c]
;;;400    	uint16 head = pCB->tx.head;								// 发送命令帧队列头索引号
000018  f8b411d2          LDRH     r1,[r4,#0x1d2]
;;;401    	uint16 end = pCB->tx.end;								// 发送命令帧队列尾索引号
00001c  f8b431d4          LDRH     r3,[r4,#0x1d4]
;;;402    
;;;403    	// 参数合法性检验
;;;404    	if (NULL == pCB)
000020  2c00              CMP      r4,#0
000022  d017              BEQ      |L14.84|
;;;405    	{
;;;406    		return;
;;;407    	}
;;;408    	
;;;409    	// 队列为空，不处理
;;;410    	if (head == end)
000024  4299              CMP      r1,r3
000026  d015              BEQ      |L14.84|
;;;411    	{
;;;412    		return;
;;;413    	}
;;;414    
;;;415    	// 发送忙，退出
;;;416    	if (pCB->tx.txBusy)
000028  f89431d8          LDRB     r3,[r4,#0x1d8]
00002c  2b00              CMP      r3,#0
00002e  d111              BNE      |L14.84|
;;;417    	{
;;;418    		return;
;;;419    	}
;;;420    
;;;421    	// ■■执行到这里，说明队列非空■■
;;;422    	
;;;423    	// 当前命令帧未发送完时，取出一个字节放到发送寄存器中
;;;424    	if (index < length)
000030  4290              CMP      r0,r2
000032  d20f              BCS      |L14.84|
;;;425    	{		
;;;426    		BLE_UART_IR_StartSendData(pCB->tx.cmdQueue[head].buff[pCB->tx.index++]);
000034  f8b401d6          LDRH     r0,[r4,#0x1d6]
000038  1c42              ADDS     r2,r0,#1
00003a  f8a421d6          STRH     r2,[r4,#0x1d6]
00003e  224d              MOVS     r2,#0x4d
000040  4351              MULS     r1,r2,r1
000042  eb040141          ADD      r1,r4,r1,LSL #1
000046  4408              ADD      r0,r0,r1
000048  7980              LDRB     r0,[r0,#6]
00004a  f7fffffe          BL       BLE_UART_IR_StartSendData
;;;427    		
;;;428    		// 设置发送忙状态
;;;429    		pCB->tx.txBusy = TRUE;
00004e  2001              MOVS     r0,#1
000050  f88401d8          STRB     r0,[r4,#0x1d8]
                  |L14.84|
;;;430    	}
;;;431    
;;;432    
;;;433    // 阻塞方式时启动发送
;;;434    #else
;;;435    	uint16 index = pCB->tx.index;
;;;436    	uint16 head = pCB->tx.head;
;;;437    	uint16 end = pCB->tx.end;
;;;438    
;;;439    	// 参数合法性检验
;;;440    	if(NULL == pCB)
;;;441    	{
;;;442    		return;
;;;443    	}
;;;444    
;;;445    	// 队列为空，不处理
;;;446    	if(head == end)
;;;447    	{
;;;448    		return;
;;;449    	}
;;;450    	
;;;451    	// 当前命令帧未发送完时，持续发送
;;;452    	while(index < pCB->tx.cmdQueue[head].length)
;;;453    	{
;;;454    		// 一直填充发送
;;;455    		BLE_UART_BC_SendData(pCB->tx.cmdQueue[head].buff[pCB->tx.index++]);
;;;456    		
;;;457    		index = pCB->tx.index;
;;;458    	}
;;;459    	
;;;460    	// 当前命令帧发送完时，删除之
;;;461    	pCB->tx.cmdQueue[head].length = 0;
;;;462    	pCB->tx.head ++;
;;;463    	pCB->tx.head %= BLE_UART_DRIVE_TX_QUEUE_SIZE;
;;;464    	pCB->tx.index = 0;
;;;465    #endif
;;;466    }
000054  bd10              POP      {r4,pc}
;;;467    
                          ENDP


                          AREA ||i.USART0_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART0_IRQHandler PROC
;;;160    *************************************************************/
;;;161    void USART0_IRQHandler(void)
000000  b5fe              PUSH     {r1-r7,lr}
;;;162    {
;;;163    	// 判断DR是否有数据，中断接收
;;;164    	if (usart_interrupt_flag_get(BLE_UART_TYPE_DEF, USART_INT_FLAG_RBNE) != RESET) 
000002  4e46              LDR      r6,|L15.284|
000004  4944              LDR      r1,|L15.280|
000006  4630              MOV      r0,r6
000008  f7fffffe          BL       usart_interrupt_flag_get
;;;165    	{
;;;166    		uint8 rxData = 0x00;
;;;167    		
;;;168    		// 接收数据
;;;169    		rxData = (uint8)usart_data_receive(BLE_UART_TYPE_DEF);
;;;170    
;;;171    		// 手机app数据交互通道
;;;172    		if (NULL != bleUartCB.receiveDataThrowService)
00000c  4c44              LDR      r4,|L15.288|
00000e  2500              MOVS     r5,#0                 ;164
000010  b350              CBZ      r0,|L15.104|
000012  9502              STR      r5,[sp,#8]            ;166
000014  4630              MOV      r0,r6                 ;169
000016  f7fffffe          BL       usart_data_receive
00001a  9002              STR      r0,[sp,#8]            ;169
00001c  6823              LDR      r3,[r4,#0]  ; bleUartCB
00001e  b123              CBZ      r3,|L15.42|
;;;173    		{			
;;;174    			(*bleUartCB.receiveDataThrowService)(0xFFF, &rxData, 1);
000020  2201              MOVS     r2,#1
000022  a902              ADD      r1,sp,#8
000024  f64070ff          MOV      r0,#0xfff
000028  4798              BLX      r3
                  |L15.42|
;;;175    		}
;;;176    
;;;177    		// 只有在注册的时候才允许解析AT指令
;;;178    		if (paramCB.runtime.qrRegEnable)
00002a  483e              LDR      r0,|L15.292|
00002c  f8900168          LDRB     r0,[r0,#0x168]  ; paramCB
000030  b118              CBZ      r0,|L15.58|
;;;179    		{
;;;180    			BLE_UART_RcvBleMacAddr(rxData);
000032  f89d0008          LDRB     r0,[sp,#8]
000036  f7fffffe          BL       BLE_UART_RcvBleMacAddr
                  |L15.58|
;;;181    		}
;;;182    		
;;;183    //=================================================================
;;;184    		// 蓝牙连接判断
;;;185    		if ((bleIndex + 1)< sizeof(bleRxBuff)/sizeof(bleRxBuff[0]))
00003a  4a3b              LDR      r2,|L15.296|
00003c  7811              LDRB     r1,[r2,#0]  ; bleIndex
00003e  4608              MOV      r0,r1
000040  1c49              ADDS     r1,r1,#1
000042  2914              CMP      r1,#0x14
000044  d207              BCS      |L15.86|
;;;186    		{
;;;187    			bleRxBuff[bleIndex++] = rxData;
000046  f89d3008          LDRB     r3,[sp,#8]
00004a  b2c9              UXTB     r1,r1
00004c  7011              STRB     r1,[r2,#0]
00004e  4a34              LDR      r2,|L15.288|
000050  3a14              SUBS     r2,r2,#0x14
000052  5413              STRB     r3,[r2,r0]
;;;188    			bleRxBuff[bleIndex] = '\0';
000054  5455              STRB     r5,[r2,r1]
                  |L15.86|
;;;189    		}
;;;190    
;;;191    		TIMER_AddTask(TIMER_ID_BLE_CONNECT_STATE,
000056  2001              MOVS     r0,#1
000058  9000              STR      r0,[sp,#0]
00005a  9001              STR      r0,[sp,#4]
00005c  2300              MOVS     r3,#0
00005e  4a33              LDR      r2,|L15.300|
000060  2164              MOVS     r1,#0x64
000062  200a              MOVS     r0,#0xa
000064  f7fffffe          BL       TIMER_AddTask
                  |L15.104|
;;;192    					100,
;;;193    					BLE_UART_BleConnectState,
;;;194    					0,
;;;195    					1,
;;;196    					ACTION_MODE_ADD_TO_QUEUE);
;;;197    	}
;;;198    
;;;199    // 中断模式发送
;;;200    #if (BLE_UART_TX_MODE == BLE_UART_INTERRUPT_TX_MODE)
;;;201    	// 判断DR是否有数据，中断发送
;;;202    	if (usart_interrupt_flag_get(BLE_UART_TYPE_DEF, USART_INT_FLAG_TC) != RESET)
000068  4931              LDR      r1,|L15.304|
00006a  4630              MOV      r0,r6
00006c  f7fffffe          BL       usart_interrupt_flag_get
000070  b3c8              CBZ      r0,|L15.230|
;;;203    	{
;;;204    		uint16 head = bleUartCB.tx.head;
000072  f8b401d2          LDRH     r0,[r4,#0x1d2]  ; bleUartCB
;;;205    		uint16 end;
;;;206    		uint16 index = bleUartCB.tx.index;
000076  f8b411d6          LDRH     r1,[r4,#0x1d6]  ; bleUartCB
;;;207    		uint8 txdata = 0x00;
;;;208    
;;;209    		// 执行到这里，说明上一个数据已经发送完毕，当前命令帧未发送完时，取出一个字节放到发送寄存器中
;;;210    		if (index < bleUartCB.tx.cmdQueue[head].length)
00007a  224d              MOVS     r2,#0x4d
00007c  4350              MULS     r0,r2,r0
00007e  eb040240          ADD      r2,r4,r0,LSL #1
000082  f8b2009c          LDRH     r0,[r2,#0x9c]
000086  4288              CMP      r0,r1
000088  d90a              BLS      |L15.160|
;;;211    		{
;;;212    			txdata = bleUartCB.tx.cmdQueue[head].buff[bleUartCB.tx.index++];
00008a  f8b411d6          LDRH     r1,[r4,#0x1d6]  ; bleUartCB
00008e  1c48              ADDS     r0,r1,#1
000090  f8a401d6          STRH     r0,[r4,#0x1d6]
000094  1888              ADDS     r0,r1,r2
000096  7981              LDRB     r1,[r0,#6]
;;;213    			
;;;214    			// 填充数据
;;;215    			usart_data_transmit(BLE_UART_TYPE_DEF, txdata);
000098  4630              MOV      r0,r6
00009a  f7fffffe          BL       usart_data_transmit
00009e  e02a              B        |L15.246|
                  |L15.160|
;;;216    		}
;;;217    		// 当前命令帧发送完时，删除之
;;;218    		else
;;;219    		{
;;;220    			bleUartCB.tx.cmdQueue[head].length = 0;
0000a0  f8a2509c          STRH     r5,[r2,#0x9c]
;;;221    			bleUartCB.tx.head ++;
0000a4  f50474e9          ADD      r4,r4,#0x1d2
0000a8  8820              LDRH     r0,[r4,#0]  ; bleUartCB
0000aa  1c40              ADDS     r0,r0,#1
0000ac  8020              STRH     r0,[r4,#0]
;;;222    			bleUartCB.tx.head %= BLE_UART_DRIVE_TX_QUEUE_SIZE;
0000ae  8820              LDRH     r0,[r4,#0]  ; bleUartCB
0000b0  2103              MOVS     r1,#3
0000b2  fbb0f2f1          UDIV     r2,r0,r1
0000b6  fb010012          MLS      r0,r1,r2,r0
0000ba  8020              STRH     r0,[r4,#0]
;;;223    			bleUartCB.tx.index = 0;
0000bc  80a5              STRH     r5,[r4,#4]
;;;224    
;;;225    			head = bleUartCB.tx.head;
0000be  8822              LDRH     r2,[r4,#0]  ; bleUartCB
;;;226    			end = bleUartCB.tx.end;
0000c0  8860              LDRH     r0,[r4,#2]  ; bleUartCB
0000c2  f5a474e9          SUB      r4,r4,#0x1d2
;;;227    			
;;;228    			// 命令帧队列非空，继续发送下一个命令帧
;;;229    			if (head != end)
0000c6  4282              CMP      r2,r0
0000c8  d00e              BEQ      |L15.232|
;;;230    			{
;;;231    				txdata = bleUartCB.tx.cmdQueue[head].buff[bleUartCB.tx.index++];
0000ca  f8b411d6          LDRH     r1,[r4,#0x1d6]  ; bleUartCB
0000ce  1c48              ADDS     r0,r1,#1
0000d0  f8a401d6          STRH     r0,[r4,#0x1d6]
0000d4  204d              MOVS     r0,#0x4d
0000d6  4342              MULS     r2,r0,r2
0000d8  eb040042          ADD      r0,r4,r2,LSL #1
0000dc  4408              ADD      r0,r0,r1
0000de  7981              LDRB     r1,[r0,#6]
;;;232    
;;;233    				// 填充数据
;;;234    				usart_data_transmit(BLE_UART_TYPE_DEF, txdata);
0000e0  4630              MOV      r0,r6
0000e2  f7fffffe          BL       usart_data_transmit
                  |L15.230|
0000e6  e006              B        |L15.246|
                  |L15.232|
;;;235    			}
;;;236    			// 命令帧队列为空停止发送，设置空闲
;;;237    			else
;;;238    			{
;;;239    				// 关闭发送完成中断
;;;240    				usart_interrupt_disable(BLE_UART_TYPE_DEF, USART_INT_TC);
0000e8  f2403106          MOV      r1,#0x306
0000ec  4630              MOV      r0,r6
0000ee  f7fffffe          BL       usart_interrupt_disable
;;;241    				bleUartCB.tx.txBusy = FALSE;				
0000f2  f88451d8          STRB     r5,[r4,#0x1d8]
                  |L15.246|
;;;242    			}
;;;243    		}		
;;;244    	}
;;;245    #endif
;;;246    	
;;;247    	// Other USARTx interrupts handler can go here ...				 
;;;248    	if (usart_interrupt_flag_get(BLE_UART_TYPE_DEF, USART_INT_FLAG_ERR_ORERR) != RESET)	//----------------------- 接收溢出中断 
0000f6  490f              LDR      r1,|L15.308|
0000f8  4630              MOV      r0,r6
0000fa  f7fffffe          BL       usart_interrupt_flag_get
0000fe  2800              CMP      r0,#0
000100  d008              BEQ      |L15.276|
;;;249    	{
;;;250    		usart_flag_get(BLE_UART_TYPE_DEF, USART_FLAG_ORERR); 			//----------------------- 清除接收溢出中断标志位 
000102  2103              MOVS     r1,#3
000104  4630              MOV      r0,r6
000106  f7fffffe          BL       usart_flag_get
;;;251    		usart_data_receive(BLE_UART_TYPE_DEF);									//----------------------- 清空寄存器
00010a  4630              MOV      r0,r6
00010c  e8bd40fe          POP      {r1-r7,lr}
000110  f7ffbffe          B.W      usart_data_receive
                  |L15.276|
;;;252    	}
;;;253    }
000114  bdfe              POP      {r1-r7,pc}
;;;254    
                          ENDP

000116  0000              DCW      0x0000
                  |L15.280|
                          DCD      0x00050305
                  |L15.284|
                          DCD      0x40013800
                  |L15.288|
                          DCD      ||.bss||+0x14
                  |L15.292|
                          DCD      paramCB
                  |L15.296|
                          DCD      ||.data||
                  |L15.300|
                          DCD      BLE_UART_BleConnectState
                  |L15.304|
                          DCD      0x00060306
                  |L15.308|
                          DCD      0x00030500

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  bleRxBuff
                          %        20
                  bleUartCB
                          %        548

                          AREA ||.data||, DATA, ALIGN=0

                  bleIndex
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "User\\BleUart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_BleUart_c_0b2a4802____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___9_BleUart_c_0b2a4802____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_BleUart_c_0b2a4802____REVSH|
#line 128
|__asm___9_BleUart_c_0b2a4802____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
