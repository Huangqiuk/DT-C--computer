; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\gd32f10x_rcu.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\gd32f10x_rcu.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -IC:\Users\Administrator\AppData\Local\Arm\Packs\GigaDevice\GD32F10x_DFP\2.0.1\Device\Include -D__MICROLIB -D__UVISION_VERSION=534 -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\gd32f10x_rcu.crf Libraries\src\gd32f10x_rcu.c]
                          THUMB

                          AREA ||i.rcu_adc_clock_config||, CODE, READONLY, ALIGN=2

                  rcu_adc_clock_config PROC
;;;527    */
;;;528    void rcu_adc_clock_config(uint32_t adc_psc)
000000  4a0b              LDR      r2,|L1.48|
;;;529    {
;;;530        uint32_t reg0;
;;;531    
;;;532        /* reset the ADCPSC bits */
;;;533        reg0 = RCU_CFG0;
000002  6851              LDR      r1,[r2,#4]
;;;534        reg0 &= ~(RCU_CFG0_ADCPSC_2 | RCU_CFG0_ADCPSC);
000004  4b0b              LDR      r3,|L1.52|
000006  4019              ANDS     r1,r1,r3
;;;535    
;;;536        /* set the ADC prescaler factor */
;;;537        switch(adc_psc){
000008  2808              CMP      r0,#8
00000a  d20e              BCS      |L1.42|
00000c  e8dff000          TBB      [pc,r0]
000010  04040404          DCB      0x04,0x04,0x04,0x04
000014  0d070d07          DCB      0x0d,0x07,0x0d,0x07
;;;538            case RCU_CKADC_CKAPB2_DIV2:
;;;539            case RCU_CKADC_CKAPB2_DIV4:
;;;540            case RCU_CKADC_CKAPB2_DIV6:
;;;541            case RCU_CKADC_CKAPB2_DIV8:
;;;542                reg0 |= (adc_psc << 14);
000018  ea413180          ORR      r1,r1,r0,LSL #14
;;;543                break;
00001c  e005              B        |L1.42|
;;;544    
;;;545            case RCU_CKADC_CKAPB2_DIV12:
;;;546            case RCU_CKADC_CKAPB2_DIV16:
;;;547                adc_psc &= ~BIT(2);
00001e  f0200004          BIC      r0,r0,#4
;;;548                reg0 |= (adc_psc << 14 | RCU_CFG0_ADCPSC_2);
000022  ea413080          ORR      r0,r1,r0,LSL #14
000026  f0405180          ORR      r1,r0,#0x10000000
                  |L1.42|
;;;549                break;
;;;550    
;;;551            default:
;;;552                break;
;;;553        }
;;;554    
;;;555        /* set the register */
;;;556        RCU_CFG0 = reg0;
00002a  6051              STR      r1,[r2,#4]
;;;557    }
00002c  4770              BX       lr
;;;558    
                          ENDP

00002e  0000              DCW      0x0000
                  |L1.48|
                          DCD      0x40021000
                  |L1.52|
                          DCD      0xefff3fff

                          AREA ||i.rcu_ahb_clock_config||, CODE, READONLY, ALIGN=2

                  rcu_ahb_clock_config PROC
;;;306    */
;;;307    void rcu_ahb_clock_config(uint32_t ck_ahb)
000000  4a03              LDR      r2,|L2.16|
;;;308    {
;;;309        uint32_t reg;
;;;310        
;;;311        reg = RCU_CFG0;
000002  6851              LDR      r1,[r2,#4]
;;;312    
;;;313        /* reset the AHBPSC bits and set according to ck_ahb */
;;;314        reg &= ~RCU_CFG0_AHBPSC;
000004  f02101f0          BIC      r1,r1,#0xf0
;;;315        RCU_CFG0 = (reg | ck_ahb);
000008  4301              ORRS     r1,r1,r0
00000a  6051              STR      r1,[r2,#4]
;;;316    }
00000c  4770              BX       lr
;;;317    
                          ENDP

00000e  0000              DCW      0x0000
                  |L2.16|
                          DCD      0x40021000

                          AREA ||i.rcu_all_reset_flag_clear||, CODE, READONLY, ALIGN=2

                  rcu_all_reset_flag_clear PROC
;;;682    */
;;;683    void rcu_all_reset_flag_clear(void)
000000  4802              LDR      r0,|L3.12|
;;;684    {
;;;685        RCU_RSTSCK |= RCU_RSTSCK_RSTFC;
000002  6a41              LDR      r1,[r0,#0x24]
000004  f0417180          ORR      r1,r1,#0x1000000
000008  6241              STR      r1,[r0,#0x24]
;;;686    }
00000a  4770              BX       lr
;;;687    
                          ENDP

                  |L3.12|
                          DCD      0x40021000

                          AREA ||i.rcu_apb1_clock_config||, CODE, READONLY, ALIGN=2

                  rcu_apb1_clock_config PROC
;;;329    */
;;;330    void rcu_apb1_clock_config(uint32_t ck_apb1)
000000  4a03              LDR      r2,|L4.16|
;;;331    {
;;;332        uint32_t reg;
;;;333        
;;;334        reg = RCU_CFG0;
000002  6851              LDR      r1,[r2,#4]
;;;335    
;;;336        /* reset the APB1PSC and set according to ck_apb1 */
;;;337        reg &= ~RCU_CFG0_APB1PSC;
000004  f42161e0          BIC      r1,r1,#0x700
;;;338        RCU_CFG0 = (reg | ck_apb1);
000008  4301              ORRS     r1,r1,r0
00000a  6051              STR      r1,[r2,#4]
;;;339    }
00000c  4770              BX       lr
;;;340    
                          ENDP

00000e  0000              DCW      0x0000
                  |L4.16|
                          DCD      0x40021000

                          AREA ||i.rcu_apb2_clock_config||, CODE, READONLY, ALIGN=2

                  rcu_apb2_clock_config PROC
;;;352    */
;;;353    void rcu_apb2_clock_config(uint32_t ck_apb2)
000000  4a03              LDR      r2,|L5.16|
;;;354    {
;;;355        uint32_t reg;
;;;356        
;;;357        reg = RCU_CFG0;
000002  6851              LDR      r1,[r2,#4]
;;;358    
;;;359        /* reset the APB2PSC and set according to ck_apb2 */
;;;360        reg &= ~RCU_CFG0_APB2PSC;
000004  f4215160          BIC      r1,r1,#0x3800
;;;361        RCU_CFG0 = (reg | ck_apb2);
000008  4301              ORRS     r1,r1,r0
00000a  6051              STR      r1,[r2,#4]
;;;362    }
00000c  4770              BX       lr
;;;363    
                          ENDP

00000e  0000              DCW      0x0000
                  |L5.16|
                          DCD      0x40021000

                          AREA ||i.rcu_bkp_reset_disable||, CODE, READONLY, ALIGN=2

                  rcu_bkp_reset_disable PROC
;;;259    */
;;;260    void rcu_bkp_reset_disable(void)
000000  4802              LDR      r0,|L6.12|
;;;261    {
;;;262        RCU_BDCTL &= ~RCU_BDCTL_BKPRST;
000002  6a01              LDR      r1,[r0,#0x20]
000004  f4213180          BIC      r1,r1,#0x10000
000008  6201              STR      r1,[r0,#0x20]
;;;263    }
00000a  4770              BX       lr
;;;264    
                          ENDP

                  |L6.12|
                          DCD      0x40021000

                          AREA ||i.rcu_bkp_reset_enable||, CODE, READONLY, ALIGN=2

                  rcu_bkp_reset_enable PROC
;;;248    */
;;;249    void rcu_bkp_reset_enable(void)
000000  4802              LDR      r0,|L7.12|
;;;250    {
;;;251        RCU_BDCTL |= RCU_BDCTL_BKPRST;
000002  6a01              LDR      r1,[r0,#0x20]
000004  f4413180          ORR      r1,r1,#0x10000
000008  6201              STR      r1,[r0,#0x20]
;;;252    }
00000a  4770              BX       lr
;;;253    
                          ENDP

                  |L7.12|
                          DCD      0x40021000

                          AREA ||i.rcu_ckout0_config||, CODE, READONLY, ALIGN=2

                  rcu_ckout0_config PROC
;;;379    */
;;;380    void rcu_ckout0_config(uint32_t ckout0_src)
000000  4a03              LDR      r2,|L8.16|
;;;381    {
;;;382        uint32_t reg;
;;;383        
;;;384        reg = RCU_CFG0;
000002  6851              LDR      r1,[r2,#4]
;;;385    
;;;386        /* reset the CKOUT0SRC, set according to ckout0_src */
;;;387        reg &= ~RCU_CFG0_CKOUT0SEL;
000004  f02161e0          BIC      r1,r1,#0x7000000
;;;388        RCU_CFG0 = (reg | ckout0_src);
000008  4301              ORRS     r1,r1,r0
00000a  6051              STR      r1,[r2,#4]
;;;389    }
00000c  4770              BX       lr
;;;390    
                          ENDP

00000e  0000              DCW      0x0000
                  |L8.16|
                          DCD      0x40021000

                          AREA ||i.rcu_clock_freq_get||, CODE, READONLY, ALIGN=2

                  rcu_clock_freq_get PROC
;;;1074   */
;;;1075   uint32_t rcu_clock_freq_get(rcu_clock_freq_enum clock)
000000  b570              PUSH     {r4-r6,lr}
;;;1076   {
000002  b088              SUB      sp,sp,#0x20
000004  4602              MOV      r2,r0
;;;1077       uint32_t sws, ck_freq = 0U;
000006  2000              MOVS     r0,#0
;;;1078       uint32_t cksys_freq, ahb_freq, apb1_freq, apb2_freq;
;;;1079       uint32_t pllsel, predv0sel, pllmf,ck_src, idx, clk_exp;
;;;1080   #ifdef GD32F10X_CL
;;;1081       uint32_t predv0, predv1, pll1mf;
;;;1082   #endif /* GD32F10X_CL */
;;;1083   
;;;1084       /* exponent of AHB, APB1 and APB2 clock divider */
;;;1085       uint8_t ahb_exp[16] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 6, 7, 8, 9};
000008  a131              ADR      r1,|L9.208|
00000a  ae04              ADD      r6,sp,#0x10
00000c  e8910038          LDM      r1,{r3-r5}
000010  68c9              LDR      r1,[r1,#0xc]
000012  c638              STM      r6!,{r3-r5}
000014  9107              STR      r1,[sp,#0x1c]
;;;1086       uint8_t apb1_exp[8] = {0, 0, 0, 0, 1, 2, 3, 4};
000016  a12f              ADR      r1,|L9.212|
000018  c90a              LDM      r1,{r1,r3}
00001a  e9cd1302          STRD     r1,r3,[sp,#8]
;;;1087       uint8_t apb2_exp[8] = {0, 0, 0, 0, 1, 2, 3, 4};
00001e  a12d              ADR      r1,|L9.212|
000020  c90a              LDM      r1,{r1,r3}
000022  e9cd1300          STRD     r1,r3,[sp,#0]
;;;1088   
;;;1089       sws = GET_BITS(RCU_CFG0, 2, 3);
000026  4c2e              LDR      r4,|L9.224|
000028  6861              LDR      r1,[r4,#4]
00002a  f3c10181          UBFX     r1,r1,#2,#2
;;;1090       switch(sws){
;;;1091       /* IRC8M is selected as CK_SYS */
;;;1092       case SEL_IRC8M:
;;;1093           cksys_freq = IRC8M_VALUE;
00002e  4b2d              LDR      r3,|L9.228|
000030  2900              CMP      r1,#0                 ;1090
000032  d023              BEQ      |L9.124|
000034  2901              CMP      r1,#1                 ;1090
000036  d023              BEQ      |L9.128|
000038  2902              CMP      r1,#2                 ;1090
00003a  d023              BEQ      |L9.132|
;;;1094           break;
;;;1095       /* HXTAL is selected as CK_SYS */
;;;1096       case SEL_HXTAL:
;;;1097           cksys_freq = HXTAL_VALUE;
;;;1098           break;
;;;1099       /* PLL is selected as CK_SYS */
;;;1100       case SEL_PLL:
;;;1101           /* PLL clock source selection, HXTAL or IRC8M/2 */
;;;1102           pllsel = (RCU_CFG0 & RCU_CFG0_PLLSEL);
;;;1103   
;;;1104           if(RCU_PLLSRC_HXTAL == pllsel) {
;;;1105               /* PLL clock source is HXTAL */
;;;1106               ck_src = HXTAL_VALUE;
;;;1107   
;;;1108   #if (defined(GD32F10X_MD) || defined(GD32F10X_HD) || defined(GD32F10X_XD))
;;;1109               predv0sel = (RCU_CFG0 & RCU_CFG0_PREDV0);
;;;1110               /* PREDV0 input source clock divided by 2 */
;;;1111               if(RCU_CFG0_PREDV0 == predv0sel){
;;;1112                   ck_src = HXTAL_VALUE/2U;
;;;1113               }
;;;1114   #elif defined(GD32F10X_CL)
;;;1115               predv0sel = (RCU_CFG1 & RCU_CFG1_PREDV0SEL);
;;;1116               /* source clock use PLL1 */
;;;1117               if(RCU_PREDV0SRC_CKPLL1 == predv0sel){
;;;1118                   predv1 = (uint32_t)((RCU_CFG1 & RCU_CFG1_PREDV1) >> 4) + 1U;
;;;1119                   pll1mf = (uint32_t)((RCU_CFG1 & RCU_CFG1_PLL1MF) >> 8) + 2U;
;;;1120                   if(17U == pll1mf){
;;;1121                       pll1mf = 20U;
;;;1122                   }
;;;1123                   ck_src = (ck_src / predv1) * pll1mf;
;;;1124               }
;;;1125               predv0 = (RCU_CFG1 & RCU_CFG1_PREDV0) + 1U;
;;;1126               ck_src /= predv0;
;;;1127   #endif /* GD32F10X_HD and GD32F10X_XD */
;;;1128           }else{
;;;1129               /* PLL clock source is IRC8M/2 */
;;;1130               ck_src = IRC8M_VALUE/2U;
;;;1131           }
;;;1132   
;;;1133           /* PLL multiplication factor */
;;;1134           pllmf = GET_BITS(RCU_CFG0, 18, 21);
;;;1135           if((RCU_CFG0 & RCU_CFG0_PLLMF_4)){
;;;1136               pllmf |= 0x10U;
;;;1137           }
;;;1138           if(pllmf < 15U){
;;;1139               pllmf += 2U;
;;;1140           }else{
;;;1141               pllmf += 1U;
;;;1142           }
;;;1143   
;;;1144           cksys_freq = ck_src * pllmf;
;;;1145   
;;;1146       #ifdef GD32F10X_CL
;;;1147           if(15U == pllmf){
;;;1148               /* PLL source clock multiply by 6.5 */
;;;1149               cksys_freq = ck_src * 6U + ck_src / 2U;
;;;1150           }
;;;1151       #endif /* GD32F10X_CL */
;;;1152   
;;;1153           break;
;;;1154       /* IRC8M is selected as CK_SYS */
;;;1155       default:
;;;1156           cksys_freq = IRC8M_VALUE;
00003c  4619              MOV      r1,r3
                  |L9.62|
;;;1157           break;
;;;1158       }
;;;1159   
;;;1160       /* calculate AHB clock frequency */
;;;1161       idx = GET_BITS(RCU_CFG0, 4, 7);
00003e  6863              LDR      r3,[r4,#4]
000040  f3c31303          UBFX     r3,r3,#4,#4
;;;1162       clk_exp = ahb_exp[idx];
000044  ad04              ADD      r5,sp,#0x10
000046  5ceb              LDRB     r3,[r5,r3]
;;;1163       ahb_freq = cksys_freq >> clk_exp;
000048  fa21f303          LSR      r3,r1,r3
;;;1164       
;;;1165       /* calculate APB1 clock frequency */
;;;1166       idx = GET_BITS(RCU_CFG0, 8, 10);
00004c  6865              LDR      r5,[r4,#4]
00004e  f3c52502          UBFX     r5,r5,#8,#3
;;;1167       clk_exp = apb1_exp[idx];
000052  ae02              ADD      r6,sp,#8
000054  5d75              LDRB     r5,[r6,r5]
;;;1168       apb1_freq = ahb_freq >> clk_exp;
000056  fa23f505          LSR      r5,r3,r5
;;;1169       
;;;1170       /* calculate APB2 clock frequency */
;;;1171       idx = GET_BITS(RCU_CFG0, 11, 13);
00005a  6864              LDR      r4,[r4,#4]
00005c  f3c424c2          UBFX     r4,r4,#11,#3
;;;1172       clk_exp = apb2_exp[idx];
000060  f81d4004          LDRB     r4,[sp,r4]
;;;1173       apb2_freq = ahb_freq >> clk_exp;
000064  fa23f404          LSR      r4,r3,r4
000068  b35a              CBZ      r2,|L9.194|
;;;1174       
;;;1175       /* return the clocks frequency */
;;;1176       switch(clock){
00006a  2a01              CMP      r2,#1
00006c  d02b              BEQ      |L9.198|
00006e  2a02              CMP      r2,#2
000070  d02b              BEQ      |L9.202|
000072  2a03              CMP      r2,#3
000074  d100              BNE      |L9.120|
;;;1177       case CK_SYS:
;;;1178           ck_freq = cksys_freq;
;;;1179           break;
;;;1180       case CK_AHB:
;;;1181           ck_freq = ahb_freq;
;;;1182           break;
;;;1183       case CK_APB1:
;;;1184           ck_freq = apb1_freq;
;;;1185           break;
;;;1186       case CK_APB2:
;;;1187           ck_freq = apb2_freq;
000076  4620              MOV      r0,r4
                  |L9.120|
;;;1188           break;
;;;1189       default:
;;;1190           break;
;;;1191       }
;;;1192       return ck_freq;
;;;1193   }
000078  b008              ADD      sp,sp,#0x20
00007a  bd70              POP      {r4-r6,pc}
                  |L9.124|
00007c  4619              MOV      r1,r3                 ;1093
00007e  e7de              B        |L9.62|
                  |L9.128|
000080  4619              MOV      r1,r3                 ;1097
000082  e7dc              B        |L9.62|
                  |L9.132|
000084  6861              LDR      r1,[r4,#4]            ;1102
000086  f4013180          AND      r1,r1,#0x10000        ;1102
00008a  4d17              LDR      r5,|L9.232|
00008c  f5b13f80          CMP      r1,#0x10000           ;1104
000090  d00c              BEQ      |L9.172|
000092  462b              MOV      r3,r5                 ;1130
                  |L9.148|
000094  6861              LDR      r1,[r4,#4]            ;1134
000096  f3c14183          UBFX     r1,r1,#18,#4          ;1134
00009a  6865              LDR      r5,[r4,#4]            ;1135
00009c  012d              LSLS     r5,r5,#4              ;1135
00009e  d501              BPL      |L9.164|
0000a0  f0410110          ORR      r1,r1,#0x10           ;1136
                  |L9.164|
0000a4  290f              CMP      r1,#0xf               ;1138
0000a6  d209              BCS      |L9.188|
0000a8  1c89              ADDS     r1,r1,#2              ;1139
0000aa  e008              B        |L9.190|
                  |L9.172|
0000ac  6861              LDR      r1,[r4,#4]            ;1109
0000ae  f4013100          AND      r1,r1,#0x20000        ;1109
0000b2  f5b13f00          CMP      r1,#0x20000           ;1111
0000b6  d1ed              BNE      |L9.148|
0000b8  462b              MOV      r3,r5                 ;1112
0000ba  e7eb              B        |L9.148|
                  |L9.188|
0000bc  1c49              ADDS     r1,r1,#1              ;1141
                  |L9.190|
0000be  4359              MULS     r1,r3,r1              ;1144
0000c0  e7bd              B        |L9.62|
                  |L9.194|
0000c2  4608              MOV      r0,r1                 ;1178
0000c4  e7d8              B        |L9.120|
                  |L9.198|
0000c6  4618              MOV      r0,r3                 ;1181
0000c8  e7d6              B        |L9.120|
                  |L9.202|
0000ca  4628              MOV      r0,r5                 ;1184
0000cc  e7d4              B        |L9.120|
                          ENDP

0000ce  0000              DCW      0x0000
                  |L9.208|
0000d0  00                DCB      0
0000d1  00                DCB      0
0000d2  00                DCB      0
0000d3  00                DCB      0
                  |L9.212|
0000d4  00                DCB      0
0000d5  00                DCB      0
0000d6  00                DCB      0
0000d7  00                DCB      0
0000d8  01020304          DCB      1,2,3,4,6,"\a\b\t"
0000dc  06070809
                  |L9.224|
                          DCD      0x40021000
                  |L9.228|
                          DCD      0x007a1200
                  |L9.232|
                          DCD      0x003d0900

                          AREA ||i.rcu_deepsleep_voltage_set||, CODE, READONLY, ALIGN=2

                  rcu_deepsleep_voltage_set PROC
;;;1057   */
;;;1058   void rcu_deepsleep_voltage_set(uint32_t dsvol)
000000  f0000007          AND      r0,r0,#7
;;;1059   {    
;;;1060       dsvol &= RCU_DSV_DSLPVS;
;;;1061       RCU_DSV = dsvol;
000004  4901              LDR      r1,|L10.12|
000006  6348              STR      r0,[r1,#0x34]
;;;1062   }
000008  4770              BX       lr
;;;1063   
                          ENDP

00000a  0000              DCW      0x0000
                  |L10.12|
                          DCD      0x40021000

                          AREA ||i.rcu_deinit||, CODE, READONLY, ALIGN=2

                  rcu_deinit PROC
;;;55     */
;;;56     void rcu_deinit(void)
000000  b510              PUSH     {r4,lr}
;;;57     {
;;;58         /* enable IRC8M */
;;;59         RCU_CTL |= RCU_CTL_IRC8MEN;
000002  4c0c              LDR      r4,|L11.52|
000004  6820              LDR      r0,[r4,#0]
000006  f0400001          ORR      r0,r0,#1
00000a  6020              STR      r0,[r4,#0]
;;;60         rcu_osci_stab_wait(RCU_IRC8M);
00000c  2000              MOVS     r0,#0
00000e  f7fffffe          BL       rcu_osci_stab_wait
;;;61     
;;;62         /* reset CFG0 register */
;;;63     #if (defined(GD32F10X_MD) || defined(GD32F10X_HD) || defined(GD32F10X_XD))
;;;64         RCU_CFG0 &= ~(RCU_CFG0_SCS | RCU_CFG0_AHBPSC | RCU_CFG0_APB1PSC | RCU_CFG0_APB2PSC |
000012  6860              LDR      r0,[r4,#4]
000014  4908              LDR      r1,|L11.56|
000016  4008              ANDS     r0,r0,r1
000018  6060              STR      r0,[r4,#4]
;;;65                       RCU_CFG0_ADCPSC | RCU_CFG0_PLLSEL | RCU_CFG0_PREDV0 | RCU_CFG0_PLLMF |
;;;66                       RCU_CFG0_USBDPSC | RCU_CFG0_CKOUT0SEL | RCU_CFG0_PLLMF_4 | RCU_CFG0_ADCPSC_2);
;;;67     #elif defined(GD32F10X_CL)
;;;68         RCU_CFG0 &= ~(RCU_CFG0_SCS | RCU_CFG0_AHBPSC | RCU_CFG0_APB1PSC | RCU_CFG0_APB2PSC |
;;;69                       RCU_CFG0_ADCPSC | RCU_CFG0_PLLSEL | RCU_CFG0_PREDV0_LSB | RCU_CFG0_PLLMF |
;;;70                       RCU_CFG0_USBFSPSC | RCU_CFG0_CKOUT0SEL | RCU_CFG0_ADCPSC_2 | RCU_CFG0_PLLMF_4);
;;;71     #endif /* GD32F10X_MD and GD32F10X_HD and GD32F10X_XD */
;;;72         /* reset CTL register */
;;;73         RCU_CTL &= ~(RCU_CTL_HXTALEN | RCU_CTL_CKMEN | RCU_CTL_PLLEN);
00001a  6820              LDR      r0,[r4,#0]
00001c  4907              LDR      r1,|L11.60|
00001e  4008              ANDS     r0,r0,r1
000020  6020              STR      r0,[r4,#0]
;;;74         RCU_CTL &= ~RCU_CTL_HXTALBPS;
000022  6820              LDR      r0,[r4,#0]
000024  f4202080          BIC      r0,r0,#0x40000
000028  6020              STR      r0,[r4,#0]
;;;75     #ifdef GD32F10X_CL
;;;76         RCU_CTL &= ~(RCU_CTL_PLL1EN | RCU_CTL_PLL2EN);
;;;77     #endif /* GD32F10X_CL */
;;;78     
;;;79         /* reset INT and CFG1 register */
;;;80     #if (defined(GD32F10X_MD) || defined(GD32F10X_HD) || defined(GD32F10X_XD))
;;;81         RCU_INT = 0x009f0000U;
00002a  f44f001f          MOV      r0,#0x9f0000
00002e  60a0              STR      r0,[r4,#8]
;;;82     #elif defined(GD32F10X_CL)
;;;83         RCU_INT = 0x00ff0000U;
;;;84         RCU_CFG1 &= ~(RCU_CFG1_PREDV0 | RCU_CFG1_PREDV1 | RCU_CFG1_PLL1MF | RCU_CFG1_PLL2MF |
;;;85                       RCU_CFG1_PREDV0SEL | RCU_CFG1_I2S1SEL | RCU_CFG1_I2S2SEL);
;;;86     #endif /* GD32F10X_MD and GD32F10X_HD and GD32F10X_XD */
;;;87     }
000030  bd10              POP      {r4,pc}
;;;88     
                          ENDP

000032  0000              DCW      0x0000
                  |L11.52|
                          DCD      0x40021000
                  |L11.56|
                          DCD      0xe000000c
                  |L11.60|
                          DCD      0xfef6ffff

                          AREA ||i.rcu_flag_get||, CODE, READONLY, ALIGN=2

                  rcu_flag_get PROC
;;;666    */
;;;667    FlagStatus rcu_flag_get(rcu_flag_enum flag)
000000  4a06              LDR      r2,|L12.28|
;;;668    {
;;;669        /* get the rcu flag */
;;;670        if(RESET != (RCU_REG_VAL(flag) & BIT(RCU_BIT_POS(flag)))){
000002  eb021190          ADD      r1,r2,r0,LSR #6
000006  6809              LDR      r1,[r1,#0]
000008  f000021f          AND      r2,r0,#0x1f
00000c  2001              MOVS     r0,#1
00000e  4090              LSLS     r0,r0,r2
000010  4201              TST      r1,r0
000012  d001              BEQ      |L12.24|
;;;671            return SET;
000014  2001              MOVS     r0,#1
;;;672        }else{
;;;673            return RESET;
;;;674        }
;;;675    }
000016  4770              BX       lr
                  |L12.24|
000018  2000              MOVS     r0,#0                 ;673
00001a  4770              BX       lr
;;;676    
                          ENDP

                  |L12.28|
                          DCD      0x40021000

                          AREA ||i.rcu_hxtal_clock_monitor_disable||, CODE, READONLY, ALIGN=2

                  rcu_hxtal_clock_monitor_disable PROC
;;;1025   */
;;;1026   void rcu_hxtal_clock_monitor_disable(void)
000000  4802              LDR      r0,|L13.12|
;;;1027   {
;;;1028       RCU_CTL &= ~RCU_CTL_CKMEN;
000002  6801              LDR      r1,[r0,#0]
000004  f4212100          BIC      r1,r1,#0x80000
000008  6001              STR      r1,[r0,#0]
;;;1029   }
00000a  4770              BX       lr
;;;1030   
                          ENDP

                  |L13.12|
                          DCD      0x40021000

                          AREA ||i.rcu_hxtal_clock_monitor_enable||, CODE, READONLY, ALIGN=2

                  rcu_hxtal_clock_monitor_enable PROC
;;;1014   
;;;1015   void rcu_hxtal_clock_monitor_enable(void)
000000  4802              LDR      r0,|L14.12|
;;;1016   {
;;;1017       RCU_CTL |= RCU_CTL_CKMEN;
000002  6801              LDR      r1,[r0,#0]
000004  f4412100          ORR      r1,r1,#0x80000
000008  6001              STR      r1,[r0,#0]
;;;1018   }
00000a  4770              BX       lr
;;;1019   
                          ENDP

                  |L14.12|
                          DCD      0x40021000

                          AREA ||i.rcu_interrupt_disable||, CODE, READONLY, ALIGN=2

                  rcu_interrupt_disable PROC
;;;765    */
;;;766    void rcu_interrupt_disable(rcu_int_enum stab_int)
000000  4905              LDR      r1,|L15.24|
;;;767    {
;;;768        RCU_REG_VAL(stab_int) &= ~BIT(RCU_BIT_POS(stab_int));
000002  eb011190          ADD      r1,r1,r0,LSR #6
000006  680a              LDR      r2,[r1,#0]
000008  f000031f          AND      r3,r0,#0x1f
00000c  2001              MOVS     r0,#1
00000e  4098              LSLS     r0,r0,r3
000010  4382              BICS     r2,r2,r0
000012  600a              STR      r2,[r1,#0]
;;;769    }
000014  4770              BX       lr
;;;770    
                          ENDP

000016  0000              DCW      0x0000
                  |L15.24|
                          DCD      0x40021000

                          AREA ||i.rcu_interrupt_enable||, CODE, READONLY, ALIGN=2

                  rcu_interrupt_enable PROC
;;;746    */
;;;747    void rcu_interrupt_enable(rcu_int_enum stab_int)
000000  4905              LDR      r1,|L16.24|
;;;748    {
;;;749        RCU_REG_VAL(stab_int) |= BIT(RCU_BIT_POS(stab_int));
000002  eb011190          ADD      r1,r1,r0,LSR #6
000006  680a              LDR      r2,[r1,#0]
000008  f000031f          AND      r3,r0,#0x1f
00000c  2001              MOVS     r0,#1
00000e  4098              LSLS     r0,r0,r3
000010  4302              ORRS     r2,r2,r0
000012  600a              STR      r2,[r1,#0]
;;;750    }
000014  4770              BX       lr
;;;751    
                          ENDP

000016  0000              DCW      0x0000
                  |L16.24|
                          DCD      0x40021000

                          AREA ||i.rcu_interrupt_flag_clear||, CODE, READONLY, ALIGN=2

                  rcu_interrupt_flag_clear PROC
;;;727    */
;;;728    void rcu_interrupt_flag_clear(rcu_int_flag_clear_enum int_flag_clear)
000000  4905              LDR      r1,|L17.24|
;;;729    {
;;;730        RCU_REG_VAL(int_flag_clear) |= BIT(RCU_BIT_POS(int_flag_clear));
000002  eb011190          ADD      r1,r1,r0,LSR #6
000006  680a              LDR      r2,[r1,#0]
000008  f000031f          AND      r3,r0,#0x1f
00000c  2001              MOVS     r0,#1
00000e  4098              LSLS     r0,r0,r3
000010  4302              ORRS     r2,r2,r0
000012  600a              STR      r2,[r1,#0]
;;;731    }
000014  4770              BX       lr
;;;732    
                          ENDP

000016  0000              DCW      0x0000
                  |L17.24|
                          DCD      0x40021000

                          AREA ||i.rcu_interrupt_flag_get||, CODE, READONLY, ALIGN=2

                  rcu_interrupt_flag_get PROC
;;;702    */
;;;703    FlagStatus rcu_interrupt_flag_get(rcu_int_flag_enum int_flag)
000000  4a06              LDR      r2,|L18.28|
;;;704    {
;;;705        /* get the rcu interrupt flag */
;;;706        if(RESET != (RCU_REG_VAL(int_flag) & BIT(RCU_BIT_POS(int_flag)))){
000002  eb021190          ADD      r1,r2,r0,LSR #6
000006  6809              LDR      r1,[r1,#0]
000008  f000021f          AND      r2,r0,#0x1f
00000c  2001              MOVS     r0,#1
00000e  4090              LSLS     r0,r0,r2
000010  4201              TST      r1,r0
000012  d001              BEQ      |L18.24|
;;;707            return SET;
000014  2001              MOVS     r0,#1
;;;708        }else{
;;;709            return RESET;
;;;710        }
;;;711    }
000016  4770              BX       lr
                  |L18.24|
000018  2000              MOVS     r0,#0                 ;709
00001a  4770              BX       lr
;;;712    
                          ENDP

                  |L18.28|
                          DCD      0x40021000

                          AREA ||i.rcu_irc8m_adjust_value_set||, CODE, READONLY, ALIGN=2

                  rcu_irc8m_adjust_value_set PROC
;;;1036   */
;;;1037   void rcu_irc8m_adjust_value_set(uint8_t irc8m_adjval)
000000  4a04              LDR      r2,|L19.20|
;;;1038   {
;;;1039       uint32_t reg;
;;;1040       
;;;1041       reg = RCU_CTL;
000002  6811              LDR      r1,[r2,#0]
;;;1042       /* reset the IRC8MADJ bits and set according to irc8m_adjval */
;;;1043       reg &= ~RCU_CTL_IRC8MADJ;
000004  f02101f8          BIC      r1,r1,#0xf8
;;;1044       RCU_CTL = (reg | ((irc8m_adjval & 0x1FU) << 3));
000008  f000001f          AND      r0,r0,#0x1f
00000c  ea4100c0          ORR      r0,r1,r0,LSL #3
000010  6010              STR      r0,[r2,#0]
;;;1045   }
000012  4770              BX       lr
;;;1046   
                          ENDP

                  |L19.20|
                          DCD      0x40021000

                          AREA ||i.rcu_osci_bypass_mode_disable||, CODE, READONLY, ALIGN=2

                  rcu_osci_bypass_mode_disable PROC
;;;977    */
;;;978    void rcu_osci_bypass_mode_disable(rcu_osci_type_enum osci)
000000  490e              LDR      r1,|L20.60|
;;;979    {
;;;980        uint32_t reg;
;;;981        
;;;982        switch(osci){
000002  2818              CMP      r0,#0x18
000004  d00c              BEQ      |L20.32|
000006  dc0c              BGT      |L20.34|
000008  2800              CMP      r0,#0
00000a  d009              BEQ      |L20.32|
00000c  2810              CMP      r0,#0x10
00000e  d107              BNE      |L20.32|
;;;983        /* disable HXTAL to bypass mode */
;;;984        case RCU_HXTAL:
;;;985            reg = RCU_CTL;
000010  6808              LDR      r0,[r1,#0]
;;;986            RCU_CTL &= ~RCU_CTL_HXTALEN;
000012  680a              LDR      r2,[r1,#0]
000014  f4223280          BIC      r2,r2,#0x10000
000018  600a              STR      r2,[r1,#0]
;;;987            RCU_CTL = (reg & ~RCU_CTL_HXTALBPS);
00001a  f4202080          BIC      r0,r0,#0x40000
00001e  6008              STR      r0,[r1,#0]
                  |L20.32|
;;;988            break;
;;;989        /* disable LXTAL to bypass mode */
;;;990        case RCU_LXTAL:
;;;991            reg = RCU_BDCTL;
;;;992            RCU_BDCTL &= ~RCU_BDCTL_LXTALEN;
;;;993            RCU_BDCTL = (reg & ~RCU_BDCTL_LXTALBPS);
;;;994            break;
;;;995        case RCU_IRC8M:
;;;996        case RCU_IRC40K:
;;;997        case RCU_PLL_CK:
;;;998    #ifdef GD32F10X_CL
;;;999        case RCU_PLL1_CK:
;;;1000       case RCU_PLL2_CK:
;;;1001   #endif /* GD32F10X_CL */
;;;1002           break;
;;;1003       default:
;;;1004           break;
;;;1005       }
;;;1006   }
000020  4770              BX       lr
                  |L20.34|
000022  f5b06f00          CMP      r0,#0x800             ;982
000026  d1fb              BNE      |L20.32|
000028  6a08              LDR      r0,[r1,#0x20]         ;991
00002a  6a0a              LDR      r2,[r1,#0x20]         ;992
00002c  f0220201          BIC      r2,r2,#1              ;992
000030  620a              STR      r2,[r1,#0x20]         ;992
000032  f0200004          BIC      r0,r0,#4              ;993
000036  6208              STR      r0,[r1,#0x20]         ;993
000038  4770              BX       lr
;;;1007   
                          ENDP

00003a  0000              DCW      0x0000
                  |L20.60|
                          DCD      0x40021000

                          AREA ||i.rcu_osci_bypass_mode_enable||, CODE, READONLY, ALIGN=2

                  rcu_osci_bypass_mode_enable PROC
;;;938    */
;;;939    void rcu_osci_bypass_mode_enable(rcu_osci_type_enum osci)
000000  490e              LDR      r1,|L21.60|
;;;940    {
;;;941        uint32_t reg;
;;;942    
;;;943        switch(osci){
000002  2818              CMP      r0,#0x18
000004  d00c              BEQ      |L21.32|
000006  dc0c              BGT      |L21.34|
000008  2800              CMP      r0,#0
00000a  d009              BEQ      |L21.32|
00000c  2810              CMP      r0,#0x10
00000e  d107              BNE      |L21.32|
;;;944        /* enable HXTAL to bypass mode */
;;;945        case RCU_HXTAL:
;;;946            reg = RCU_CTL;
000010  6808              LDR      r0,[r1,#0]
;;;947            RCU_CTL &= ~RCU_CTL_HXTALEN;
000012  680a              LDR      r2,[r1,#0]
000014  f4223280          BIC      r2,r2,#0x10000
000018  600a              STR      r2,[r1,#0]
;;;948            RCU_CTL = (reg | RCU_CTL_HXTALBPS);
00001a  f4402080          ORR      r0,r0,#0x40000
00001e  6008              STR      r0,[r1,#0]
                  |L21.32|
;;;949            break;
;;;950        /* enable LXTAL to bypass mode */
;;;951        case RCU_LXTAL:
;;;952            reg = RCU_BDCTL;
;;;953            RCU_BDCTL &= ~RCU_BDCTL_LXTALEN;
;;;954            RCU_BDCTL = (reg | RCU_BDCTL_LXTALBPS);
;;;955            break;
;;;956        case RCU_IRC8M:
;;;957        case RCU_IRC40K:
;;;958        case RCU_PLL_CK:
;;;959    #ifdef GD32F10X_CL
;;;960        case RCU_PLL1_CK:
;;;961        case RCU_PLL2_CK:
;;;962    #endif /* GD32F10X_CL */
;;;963            break;
;;;964        default:
;;;965            break;
;;;966        }
;;;967    }
000020  4770              BX       lr
                  |L21.34|
000022  f5b06f00          CMP      r0,#0x800             ;943
000026  d1fb              BNE      |L21.32|
000028  6a08              LDR      r0,[r1,#0x20]         ;952
00002a  6a0a              LDR      r2,[r1,#0x20]         ;953
00002c  f0220201          BIC      r2,r2,#1              ;953
000030  620a              STR      r2,[r1,#0x20]         ;953
000032  f0400004          ORR      r0,r0,#4              ;954
000036  6208              STR      r0,[r1,#0x20]         ;954
000038  4770              BX       lr
;;;968    
                          ENDP

00003a  0000              DCW      0x0000
                  |L21.60|
                          DCD      0x40021000

                          AREA ||i.rcu_osci_off||, CODE, READONLY, ALIGN=2

                  rcu_osci_off PROC
;;;924    */
;;;925    void rcu_osci_off(rcu_osci_type_enum osci)
000000  4905              LDR      r1,|L22.24|
;;;926    {
;;;927        RCU_REG_VAL(osci) &= ~BIT(RCU_BIT_POS(osci));
000002  eb011190          ADD      r1,r1,r0,LSR #6
000006  680a              LDR      r2,[r1,#0]
000008  f000031f          AND      r3,r0,#0x1f
00000c  2001              MOVS     r0,#1
00000e  4098              LSLS     r0,r0,r3
000010  4382              BICS     r2,r2,r0
000012  600a              STR      r2,[r1,#0]
;;;928    }
000014  4770              BX       lr
;;;929    
                          ENDP

000016  0000              DCW      0x0000
                  |L22.24|
                          DCD      0x40021000

                          AREA ||i.rcu_osci_on||, CODE, READONLY, ALIGN=2

                  rcu_osci_on PROC
;;;905    */
;;;906    void rcu_osci_on(rcu_osci_type_enum osci)
000000  4905              LDR      r1,|L23.24|
;;;907    {
;;;908        RCU_REG_VAL(osci) |= BIT(RCU_BIT_POS(osci));
000002  eb011190          ADD      r1,r1,r0,LSR #6
000006  680a              LDR      r2,[r1,#0]
000008  f000031f          AND      r3,r0,#0x1f
00000c  2001              MOVS     r0,#1
00000e  4098              LSLS     r0,r0,r3
000010  4302              ORRS     r2,r2,r0
000012  600a              STR      r2,[r1,#0]
;;;909    }
000014  4770              BX       lr
;;;910    
                          ENDP

000016  0000              DCW      0x0000
                  |L23.24|
                          DCD      0x40021000

                          AREA ||i.rcu_osci_stab_wait||, CODE, READONLY, ALIGN=2

                  rcu_osci_stab_wait PROC
;;;784    */
;;;785    ErrStatus rcu_osci_stab_wait(rcu_osci_type_enum osci)
000000  b570              PUSH     {r4-r6,lr}
;;;786    {
000002  4601              MOV      r1,r0
;;;787        uint32_t stb_cnt = 0U;
000004  2300              MOVS     r3,#0
;;;788        ErrStatus reval = ERROR;
000006  2400              MOVS     r4,#0
;;;789        FlagStatus osci_stat = RESET;
000008  2000              MOVS     r0,#0
;;;790        
;;;791        switch(osci){
;;;792        /* wait HXTAL stable */
;;;793        case RCU_HXTAL:
;;;794            while((RESET == osci_stat) && (HXTAL_STARTUP_TIMEOUT != stb_cnt)){
;;;795                osci_stat = rcu_flag_get(RCU_FLAG_HXTALSTB);
;;;796                stb_cnt++;
;;;797            }
;;;798    
;;;799            /* check whether flag is set or not */
;;;800            if(RESET != rcu_flag_get(RCU_FLAG_HXTALSTB)){
;;;801                reval = SUCCESS;
;;;802            }
;;;803            break;
;;;804    
;;;805        /* wait LXTAL stable */
;;;806        case RCU_LXTAL:
;;;807            while((RESET == osci_stat) && (LXTAL_STARTUP_TIMEOUT != stb_cnt)){
;;;808                osci_stat = rcu_flag_get(RCU_FLAG_LXTALSTB);
;;;809                stb_cnt++;
;;;810            }
;;;811    
;;;812            /* check whether flag is set or not */
;;;813            if(RESET != rcu_flag_get(RCU_FLAG_LXTALSTB)){
;;;814                reval = SUCCESS;
;;;815            }
;;;816            break;
;;;817    
;;;818        /* wait IRC8M stable */
;;;819        case RCU_IRC8M:
;;;820            while((RESET == osci_stat) && (IRC8M_STARTUP_TIMEOUT != stb_cnt)){
;;;821                osci_stat = rcu_flag_get(RCU_FLAG_IRC8MSTB);
;;;822                stb_cnt++;
;;;823            }
;;;824    
;;;825            /* check whether flag is set or not */
;;;826            if(RESET != rcu_flag_get(RCU_FLAG_IRC8MSTB)){
;;;827                reval = SUCCESS;
;;;828            }
;;;829            break;
;;;830    
;;;831        /* wait IRC40K stable */
;;;832        case RCU_IRC40K:
;;;833            while((RESET == osci_stat) && (OSC_STARTUP_TIMEOUT != stb_cnt)){
00000a  4d2f              LDR      r5,|L24.200|
00000c  2918              CMP      r1,#0x18              ;791
00000e  d051              BEQ      |L24.180|
000010  dc03              BGT      |L24.26|
000012  b359              CBZ      r1,|L24.108|
000014  2910              CMP      r1,#0x10              ;791
000016  d155              BNE      |L24.196|
000018  e006              B        |L24.40|
                  |L24.26|
00001a  f5b16f00          CMP      r1,#0x800             ;791
00001e  d013              BEQ      |L24.72|
000020  f5b16f10          CMP      r1,#0x900             ;791
000024  d14e              BNE      |L24.196|
000026  e031              B        |L24.140|
                  |L24.40|
000028  f64f75ff          MOV      r5,#0xffff            ;794
00002c  e003              B        |L24.54|
                  |L24.46|
00002e  2011              MOVS     r0,#0x11              ;795
000030  f7fffffe          BL       rcu_flag_get
000034  1c5b              ADDS     r3,r3,#1              ;796
                  |L24.54|
000036  b908              CBNZ     r0,|L24.60|
000038  42ab              CMP      r3,r5                 ;794
00003a  d1f8              BNE      |L24.46|
                  |L24.60|
00003c  2011              MOVS     r0,#0x11              ;800
00003e  f7fffffe          BL       rcu_flag_get
000042  b310              CBZ      r0,|L24.138|
000044  2401              MOVS     r4,#1                 ;801
000046  e03d              B        |L24.196|
                  |L24.72|
000048  f6400601          MOV      r6,#0x801             ;808
00004c  f06f457c          MVN      r5,#0xfc000000        ;807
000050  e003              B        |L24.90|
                  |L24.82|
000052  4630              MOV      r0,r6                 ;808
000054  f7fffffe          BL       rcu_flag_get
000058  1c5b              ADDS     r3,r3,#1              ;809
                  |L24.90|
00005a  b908              CBNZ     r0,|L24.96|
00005c  42ab              CMP      r3,r5                 ;807
00005e  d1f8              BNE      |L24.82|
                  |L24.96|
000060  4630              MOV      r0,r6                 ;813
000062  f7fffffe          BL       rcu_flag_get
000066  b180              CBZ      r0,|L24.138|
000068  2401              MOVS     r4,#1                 ;814
00006a  e02b              B        |L24.196|
                  |L24.108|
00006c  f44f65a0          MOV      r5,#0x500             ;820
000070  e003              B        |L24.122|
                  |L24.114|
000072  2001              MOVS     r0,#1                 ;821
000074  f7fffffe          BL       rcu_flag_get
000078  1c5b              ADDS     r3,r3,#1              ;822
                  |L24.122|
00007a  b908              CBNZ     r0,|L24.128|
00007c  42ab              CMP      r3,r5                 ;820
00007e  d1f8              BNE      |L24.114|
                  |L24.128|
000080  2001              MOVS     r0,#1                 ;826
000082  f7fffffe          BL       rcu_flag_get
000086  b100              CBZ      r0,|L24.138|
000088  2401              MOVS     r4,#1                 ;827
                  |L24.138|
00008a  e01b              B        |L24.196|
                  |L24.140|
;;;834                osci_stat = rcu_flag_get(RCU_FLAG_IRC40KSTB);
00008c  f6401601          MOV      r6,#0x901
000090  e003              B        |L24.154|
                  |L24.146|
000092  4630              MOV      r0,r6
000094  f7fffffe          BL       rcu_flag_get
;;;835                stb_cnt++;
000098  1c5b              ADDS     r3,r3,#1
                  |L24.154|
00009a  b908              CBNZ     r0,|L24.160|
00009c  42ab              CMP      r3,r5                 ;833
00009e  d1f8              BNE      |L24.146|
                  |L24.160|
;;;836            }
;;;837    
;;;838            /* check whether flag is set or not */
;;;839            if(RESET != rcu_flag_get(RCU_FLAG_IRC40KSTB)){
0000a0  4630              MOV      r0,r6
0000a2  f7fffffe          BL       rcu_flag_get
0000a6  b168              CBZ      r0,|L24.196|
;;;840                reval = SUCCESS;
0000a8  2401              MOVS     r4,#1
0000aa  e00b              B        |L24.196|
                  |L24.172|
;;;841            }
;;;842            break;
;;;843    
;;;844        /* wait PLL stable */
;;;845        case RCU_PLL_CK:
;;;846            while((RESET == osci_stat) && (OSC_STARTUP_TIMEOUT != stb_cnt)){
;;;847                osci_stat = rcu_flag_get(RCU_FLAG_PLLSTB);
0000ac  2019              MOVS     r0,#0x19
0000ae  f7fffffe          BL       rcu_flag_get
;;;848                stb_cnt++;
0000b2  1c5b              ADDS     r3,r3,#1
                  |L24.180|
0000b4  b908              CBNZ     r0,|L24.186|
0000b6  42ab              CMP      r3,r5                 ;846
0000b8  d1f8              BNE      |L24.172|
                  |L24.186|
;;;849            }
;;;850    
;;;851            /* check whether flag is set or not */
;;;852            if(RESET != rcu_flag_get(RCU_FLAG_PLLSTB)){
0000ba  2019              MOVS     r0,#0x19
0000bc  f7fffffe          BL       rcu_flag_get
0000c0  b100              CBZ      r0,|L24.196|
;;;853                reval = SUCCESS;
0000c2  2401              MOVS     r4,#1
                  |L24.196|
;;;854            }
;;;855            break;
;;;856    
;;;857    #ifdef GD32F10X_CL
;;;858        /* wait PLL1 stable */
;;;859        case RCU_PLL1_CK:
;;;860            while((RESET == osci_stat) && (OSC_STARTUP_TIMEOUT != stb_cnt)){
;;;861                osci_stat = rcu_flag_get(RCU_FLAG_PLL1STB);
;;;862                stb_cnt++;
;;;863            }
;;;864    
;;;865            /* check whether flag is set or not */
;;;866            if(RESET != rcu_flag_get(RCU_FLAG_PLL1STB)){
;;;867                reval = SUCCESS;
;;;868            }
;;;869            break;
;;;870        /* wait PLL2 stable */
;;;871        case RCU_PLL2_CK:
;;;872            while((RESET == osci_stat) && (OSC_STARTUP_TIMEOUT != stb_cnt)){
;;;873                osci_stat = rcu_flag_get(RCU_FLAG_PLL2STB);
;;;874                stb_cnt++;
;;;875            }
;;;876    
;;;877            /* check whether flag is set or not */
;;;878            if(RESET != rcu_flag_get(RCU_FLAG_PLL2STB)){
;;;879                reval = SUCCESS;
;;;880            }
;;;881            break;
;;;882    #endif /* GD32F10X_CL */
;;;883    
;;;884        default:
;;;885            break;
;;;886        }
;;;887    
;;;888        /* return value */
;;;889        return reval;
0000c4  4620              MOV      r0,r4
;;;890    }
0000c6  bd70              POP      {r4-r6,pc}
;;;891    
                          ENDP

                  |L24.200|
                          DCD      0x000fffff

                          AREA ||i.rcu_periph_clock_disable||, CODE, READONLY, ALIGN=2

                  rcu_periph_clock_disable PROC
;;;153    */
;;;154    void rcu_periph_clock_disable(rcu_periph_enum periph)
000000  4905              LDR      r1,|L25.24|
;;;155    {
;;;156        RCU_REG_VAL(periph) &= ~BIT(RCU_BIT_POS(periph));
000002  eb011190          ADD      r1,r1,r0,LSR #6
000006  680a              LDR      r2,[r1,#0]
000008  f000031f          AND      r3,r0,#0x1f
00000c  2001              MOVS     r0,#1
00000e  4098              LSLS     r0,r0,r3
000010  4382              BICS     r2,r2,r0
000012  600a              STR      r2,[r1,#0]
;;;157    }
000014  4770              BX       lr
;;;158    
                          ENDP

000016  0000              DCW      0x0000
                  |L25.24|
                          DCD      0x40021000

                          AREA ||i.rcu_periph_clock_enable||, CODE, READONLY, ALIGN=2

                  rcu_periph_clock_enable PROC
;;;118    */
;;;119    void rcu_periph_clock_enable(rcu_periph_enum periph)
000000  4905              LDR      r1,|L26.24|
;;;120    {
;;;121        RCU_REG_VAL(periph) |= BIT(RCU_BIT_POS(periph));
000002  eb011190          ADD      r1,r1,r0,LSR #6
000006  680a              LDR      r2,[r1,#0]
000008  f000031f          AND      r3,r0,#0x1f
00000c  2001              MOVS     r0,#1
00000e  4098              LSLS     r0,r0,r3
000010  4302              ORRS     r2,r2,r0
000012  600a              STR      r2,[r1,#0]
;;;122    }
000014  4770              BX       lr
;;;123    
                          ENDP

000016  0000              DCW      0x0000
                  |L26.24|
                          DCD      0x40021000

                          AREA ||i.rcu_periph_clock_sleep_disable||, CODE, READONLY, ALIGN=2

                  rcu_periph_clock_sleep_disable PROC
;;;181    */
;;;182    void rcu_periph_clock_sleep_disable(rcu_periph_sleep_enum periph)
000000  4905              LDR      r1,|L27.24|
;;;183    {
;;;184        RCU_REG_VAL(periph) &= ~BIT(RCU_BIT_POS(periph));
000002  eb011190          ADD      r1,r1,r0,LSR #6
000006  680a              LDR      r2,[r1,#0]
000008  f000031f          AND      r3,r0,#0x1f
00000c  2001              MOVS     r0,#1
00000e  4098              LSLS     r0,r0,r3
000010  4382              BICS     r2,r2,r0
000012  600a              STR      r2,[r1,#0]
;;;185    }
000014  4770              BX       lr
;;;186    
                          ENDP

000016  0000              DCW      0x0000
                  |L27.24|
                          DCD      0x40021000

                          AREA ||i.rcu_periph_clock_sleep_enable||, CODE, READONLY, ALIGN=2

                  rcu_periph_clock_sleep_enable PROC
;;;167    */
;;;168    void rcu_periph_clock_sleep_enable(rcu_periph_sleep_enum periph)
000000  4905              LDR      r1,|L28.24|
;;;169    {
;;;170        RCU_REG_VAL(periph) |= BIT(RCU_BIT_POS(periph));
000002  eb011190          ADD      r1,r1,r0,LSR #6
000006  680a              LDR      r2,[r1,#0]
000008  f000031f          AND      r3,r0,#0x1f
00000c  2001              MOVS     r0,#1
00000e  4098              LSLS     r0,r0,r3
000010  4302              ORRS     r2,r2,r0
000012  600a              STR      r2,[r1,#0]
;;;171    }
000014  4770              BX       lr
;;;172    
                          ENDP

000016  0000              DCW      0x0000
                  |L28.24|
                          DCD      0x40021000

                          AREA ||i.rcu_periph_reset_disable||, CODE, READONLY, ALIGN=2

                  rcu_periph_reset_disable PROC
;;;237    */
;;;238    void rcu_periph_reset_disable(rcu_periph_reset_enum periph_reset)
000000  4905              LDR      r1,|L29.24|
;;;239    {
;;;240        RCU_REG_VAL(periph_reset) &= ~BIT(RCU_BIT_POS(periph_reset));
000002  eb011190          ADD      r1,r1,r0,LSR #6
000006  680a              LDR      r2,[r1,#0]
000008  f000031f          AND      r3,r0,#0x1f
00000c  2001              MOVS     r0,#1
00000e  4098              LSLS     r0,r0,r3
000010  4382              BICS     r2,r2,r0
000012  600a              STR      r2,[r1,#0]
;;;241    }
000014  4770              BX       lr
;;;242    
                          ENDP

000016  0000              DCW      0x0000
                  |L29.24|
                          DCD      0x40021000

                          AREA ||i.rcu_periph_reset_enable||, CODE, READONLY, ALIGN=2

                  rcu_periph_reset_enable PROC
;;;209    */
;;;210    void rcu_periph_reset_enable(rcu_periph_reset_enum periph_reset)
000000  4905              LDR      r1,|L30.24|
;;;211    {
;;;212        RCU_REG_VAL(periph_reset) |= BIT(RCU_BIT_POS(periph_reset));
000002  eb011190          ADD      r1,r1,r0,LSR #6
000006  680a              LDR      r2,[r1,#0]
000008  f000031f          AND      r3,r0,#0x1f
00000c  2001              MOVS     r0,#1
00000e  4098              LSLS     r0,r0,r3
000010  4302              ORRS     r2,r2,r0
000012  600a              STR      r2,[r1,#0]
;;;213    }
000014  4770              BX       lr
;;;214    
                          ENDP

000016  0000              DCW      0x0000
                  |L30.24|
                          DCD      0x40021000

                          AREA ||i.rcu_pll_config||, CODE, READONLY, ALIGN=2

                  rcu_pll_config PROC
;;;402    */
;;;403    void rcu_pll_config(uint32_t pll_src, uint32_t pll_mul)
000000  b510              PUSH     {r4,lr}
;;;404    {
;;;405        uint32_t reg = 0U;
;;;406    
;;;407        reg = RCU_CFG0;
000002  4b04              LDR      r3,|L31.20|
000004  685a              LDR      r2,[r3,#4]
;;;408    
;;;409        /* PLL clock source and multiplication factor configuration */
;;;410        reg &= ~(RCU_CFG0_PLLSEL | RCU_CFG0_PLLMF | RCU_CFG0_PLLMF_4);
000006  4c04              LDR      r4,|L31.24|
000008  4022              ANDS     r2,r2,r4
;;;411        reg |= (pll_src | pll_mul);
00000a  4308              ORRS     r0,r0,r1
00000c  4310              ORRS     r0,r0,r2
;;;412    
;;;413        RCU_CFG0 = reg;
00000e  6058              STR      r0,[r3,#4]
;;;414    }
000010  bd10              POP      {r4,pc}
;;;415    
                          ENDP

000012  0000              DCW      0x0000
                  |L31.20|
                          DCD      0x40021000
                  |L31.24|
                          DCD      0xf7c2ffff

                          AREA ||i.rcu_predv0_config||, CODE, READONLY, ALIGN=2

                  rcu_predv0_config PROC
;;;424    */
;;;425    void rcu_predv0_config(uint32_t predv0_div)
000000  4a04              LDR      r2,|L32.20|
;;;426    {
;;;427        uint32_t reg = 0U;
;;;428    
;;;429        reg = RCU_CFG0;
000002  6851              LDR      r1,[r2,#4]
;;;430        /* reset PREDV0 bit */
;;;431        reg &= ~RCU_CFG0_PREDV0;
000004  f4213100          BIC      r1,r1,#0x20000
;;;432        if(RCU_PREDV0_DIV2 == predv0_div){
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L32.16|
;;;433            /* set the PREDV0 bit */
;;;434            reg |= RCU_CFG0_PREDV0;
00000c  f4413100          ORR      r1,r1,#0x20000
                  |L32.16|
;;;435        }
;;;436    
;;;437        RCU_CFG0 = reg;
000010  6051              STR      r1,[r2,#4]
;;;438    }
000012  4770              BX       lr
;;;439    #elif defined(GD32F10X_CL)
                          ENDP

                  |L32.20|
                          DCD      0x40021000

                          AREA ||i.rcu_rtc_clock_config||, CODE, READONLY, ALIGN=2

                  rcu_rtc_clock_config PROC
;;;596    */
;;;597    void rcu_rtc_clock_config(uint32_t rtc_clock_source)
000000  4a03              LDR      r2,|L33.16|
;;;598    {
;;;599        uint32_t reg;
;;;600        
;;;601        reg = RCU_BDCTL; 
000002  6a11              LDR      r1,[r2,#0x20]
;;;602        /* reset the RTCSRC bits and set according to rtc_clock_source */
;;;603        reg &= ~RCU_BDCTL_RTCSRC;
000004  f4217140          BIC      r1,r1,#0x300
;;;604        RCU_BDCTL = (reg | rtc_clock_source);
000008  4301              ORRS     r1,r1,r0
00000a  6211              STR      r1,[r2,#0x20]
;;;605    }
00000c  4770              BX       lr
;;;606    
                          ENDP

00000e  0000              DCW      0x0000
                  |L33.16|
                          DCD      0x40021000

                          AREA ||i.rcu_system_clock_source_config||, CODE, READONLY, ALIGN=2

                  rcu_system_clock_source_config PROC
;;;274    */
;;;275    void rcu_system_clock_source_config(uint32_t ck_sys)
000000  4a03              LDR      r2,|L34.16|
;;;276    {
;;;277        uint32_t reg;
;;;278        
;;;279        reg = RCU_CFG0;
000002  6851              LDR      r1,[r2,#4]
;;;280        /* reset the SCS bits and set according to ck_sys */
;;;281        reg &= ~RCU_CFG0_SCS;
000004  f0210103          BIC      r1,r1,#3
;;;282        RCU_CFG0 = (reg | ck_sys);
000008  4301              ORRS     r1,r1,r0
00000a  6051              STR      r1,[r2,#4]
;;;283    }
00000c  4770              BX       lr
;;;284    
                          ENDP

00000e  0000              DCW      0x0000
                  |L34.16|
                          DCD      0x40021000

                          AREA ||i.rcu_system_clock_source_get||, CODE, READONLY, ALIGN=2

                  rcu_system_clock_source_get PROC
;;;293    */
;;;294    uint32_t rcu_system_clock_source_get(void)
000000  4802              LDR      r0,|L35.12|
;;;295    {
;;;296        return (RCU_CFG0 & RCU_CFG0_SCSS);
000002  6840              LDR      r0,[r0,#4]
000004  f000000c          AND      r0,r0,#0xc
;;;297    }
000008  4770              BX       lr
;;;298    
                          ENDP

00000a  0000              DCW      0x0000
                  |L35.12|
                          DCD      0x40021000

                          AREA ||i.rcu_usb_clock_config||, CODE, READONLY, ALIGN=2

                  rcu_usb_clock_config PROC
;;;569    */
;;;570    void rcu_usb_clock_config(uint32_t usb_psc)
000000  4a03              LDR      r2,|L36.16|
;;;571    {
;;;572        uint32_t reg;
;;;573        
;;;574        reg = RCU_CFG0;
000002  6851              LDR      r1,[r2,#4]
;;;575    
;;;576        /* configure the USBD/USBFS prescaler factor */
;;;577    #if (defined(GD32F10X_MD) || defined(GD32F10X_HD) || defined(GD32F10X_XD))
;;;578        reg &= ~RCU_CFG0_USBDPSC;
000004  f4210140          BIC      r1,r1,#0xc00000
;;;579    #elif defined(GD32F10X_CL)
;;;580        reg &= ~RCU_CFG0_USBFSPSC;
;;;581    #endif /* GD32F10X_MD and GD32F10X_HD and GD32F10X_XD */
;;;582    
;;;583        RCU_CFG0 = (reg | usb_psc);
000008  4301              ORRS     r1,r1,r0
00000a  6051              STR      r1,[r2,#4]
;;;584    }
00000c  4770              BX       lr
;;;585    
                          ENDP

00000e  0000              DCW      0x0000
                  |L36.16|
                          DCD      0x40021000

;*** Start embedded assembler ***

#line 1 "Libraries\\src\\gd32f10x_rcu.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_gd32f10x_rcu_c_60720801____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___14_gd32f10x_rcu_c_60720801____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_gd32f10x_rcu_c_60720801____REVSH|
#line 128
|__asm___14_gd32f10x_rcu_c_60720801____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
