; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\gsmuart.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\gsmuart.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -IC:\Users\Administrator\AppData\Local\Arm\Packs\GigaDevice\GD32F10x_DFP\2.0.1\Device\Include -D__MICROLIB -D__UVISION_VERSION=534 -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\gsmuart.crf User\GsmUart.c]
                          THUMB

                          AREA ||i.GSM_UART_BC_SendData||, CODE, READONLY, ALIGN=2

                  GSM_UART_BC_SendData PROC
;;;78     // 阻塞发送一个字节数据
;;;79     void GSM_UART_BC_SendData(uint8 data)
000000  b570              PUSH     {r4-r6,lr}
;;;80     {	
000002  4605              MOV      r5,r0
;;;81     	// 防止丢失第一个字节(清除空标志位,务必加) 
;;;82     	usart_flag_get(GSM_UART_TYPE_DEF, USART_FLAG_TC);		
000004  4c07              LDR      r4,|L1.36|
000006  2106              MOVS     r1,#6
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       usart_flag_get
;;;83     
;;;84     	// 填充数据
;;;85     	usart_data_transmit(GSM_UART_TYPE_DEF, data);
00000e  4629              MOV      r1,r5
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       usart_data_transmit
                  |L1.22|
;;;86     
;;;87     	// 未发送完，持续等待
;;;88     	while(usart_flag_get(GSM_UART_TYPE_DEF, USART_FLAG_TC) != SET); 		
000016  2106              MOVS     r1,#6
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       usart_flag_get
00001e  2801              CMP      r0,#1
000020  d1f9              BNE      |L1.22|
;;;89     }
000022  bd70              POP      {r4-r6,pc}
;;;90     
                          ENDP

                  |L1.36|
                          DCD      0x40004c00

                          AREA ||i.GSM_UART_CALLBALL_GetSimIccidRequest||, CODE, READONLY, ALIGN=2

                  GSM_UART_CALLBALL_GetSimIccidRequest PROC
;;;179    // 定时器回调发送获取sim卡ICCID命令
;;;180    void GSM_UART_CALLBALL_GetSimIccidRequest(uint32 param)
000000  b570              PUSH     {r4-r6,lr}
;;;181    {
;;;182    	uint8 i;
;;;183    	
;;;184    	// 是否已经开机
;;;185    	if (!gsmUartCB.power.state)
000002  4c13              LDR      r4,|L2.80|
000004  f8940048          LDRB     r0,[r4,#0x48]  ; gsmUartCB
000008  2800              CMP      r0,#0
00000a  d020              BEQ      |L2.78|
;;;186    	{
;;;187    		return;
;;;188    	}
;;;189    	
;;;190    	// 发送获取sim的ICCID
;;;191    	GSM_UART_SendCmdGetICCID(TRUE);
00000c  2001              MOVS     r0,#1
00000e  f7fffffe          BL       GSM_UART_SendCmdGetICCID
;;;192    
;;;193    	// 由实验得知5秒内可以获取GSM模块的ICCID，超出此时间判断失败
;;;194    	if (++gsmUartCB.rcvIccidTimeCnt > (5500/GSM_UART_TX_QUERY_ICCID_TIME))
000012  f894004b          LDRB     r0,[r4,#0x4b]  ; gsmUartCB
000016  1c40              ADDS     r0,r0,#1
000018  b2c0              UXTB     r0,r0
00001a  f884004b          STRB     r0,[r4,#0x4b]
00001e  281b              CMP      r0,#0x1b
000020  d915              BLS      |L2.78|
;;;195    	{
;;;196    		gsmUartCB.rcvIccidTimeCnt = 0;
000022  2500              MOVS     r5,#0
000024  3449              ADDS     r4,r4,#0x49
000026  70a5              STRB     r5,[r4,#2]
;;;197    		gsmUartCB.rcvIccidTimeOut = TRUE;
000028  2001              MOVS     r0,#1
00002a  7060              STRB     r0,[r4,#1]
;;;198    
;;;199    		// ICCID接收失败
;;;200    		gsmUartCB.rcvIccidOK = FALSE;
00002c  f8045949          STRB     r5,[r4],#-0x49
;;;201    
;;;202    		// 关闭定时器
;;;203    		TIMER_KillTask(TIMER_ID_GSM_CONTROL);
000030  2004              MOVS     r0,#4
000032  f7fffffe          BL       TIMER_KillTask
;;;204    
;;;205    		for (i = 0; i < 20; i++)
000036  2000              MOVS     r0,#0
;;;206    		{
;;;207    			gsmUartCB.rx.iccidBuff[i] = '0';
000038  2130              MOVS     r1,#0x30
                  |L2.58|
00003a  1822              ADDS     r2,r4,r0
00003c  f8821032          STRB     r1,[r2,#0x32]
000040  1c40              ADDS     r0,r0,#1              ;205
000042  b2c0              UXTB     r0,r0                 ;205
000044  2814              CMP      r0,#0x14              ;205
000046  d3f8              BCC      |L2.58|
;;;208    		}
;;;209    		gsmUartCB.rx.iccidBuff[i] = '\0';
000048  4420              ADD      r0,r0,r4
00004a  f8805032          STRB     r5,[r0,#0x32]
                  |L2.78|
;;;210    	}
;;;211    }
00004e  bd70              POP      {r4-r6,pc}
;;;212    
                          ENDP

                  |L2.80|
                          DCD      ||.bss||

                          AREA ||i.GSM_UART_GpioOnOffControl||, CODE, READONLY, ALIGN=2

                  GSM_UART_GpioOnOffControl PROC
;;;227    
;;;228    void GSM_UART_GpioOnOffControl(uint32 param)
000000  b510              PUSH     {r4,lr}
;;;229    {
000002  4604              MOV      r4,r0
;;;230    	// 拉高释放引脚
;;;231    	GSM_ONOFF_HIGH();
000004  2200              MOVS     r2,#0
000006  f44f7100          MOV      r1,#0x200
00000a  4803              LDR      r0,|L3.24|
00000c  f7fffffe          BL       gpio_bit_write
;;;232    
;;;233    	// 上电完成
;;;234    	gsmUartCB.power.state = (BOOL)param;
000010  4802              LDR      r0,|L3.28|
000012  f8804048          STRB     r4,[r0,#0x48]
;;;235    }
000016  bd10              POP      {r4,pc}
;;;236    
                          ENDP

                  |L3.24|
                          DCD      0x40010c00
                  |L3.28|
                          DCD      ||.bss||

                          AREA ||i.GSM_UART_GsmPowerOnOff||, CODE, READONLY, ALIGN=2

                  GSM_UART_GsmPowerOnOff PROC
;;;213    // gsm模块开关机控制
;;;214    void GSM_UART_GsmPowerOnOff(uint32 param)
000000  b51c              PUSH     {r2-r4,lr}
;;;215    {
000002  4604              MOV      r4,r0
;;;216    	// 模块ON/OFF管脚一个持续时间1S以上的低电平模块即可开关机
;;;217    	GSM_ONOFF_LOW();
000004  2201              MOVS     r2,#1
000006  0251              LSLS     r1,r2,#9
000008  4806              LDR      r0,|L4.36|
00000a  f7fffffe          BL       gpio_bit_write
;;;218    
;;;219    	// 开启定时器，定时1秒即可
;;;220    	TIMER_AddTask(TIMER_ID_GSM_POWER_CONTROL,
00000e  2101              MOVS     r1,#1
000010  9100              STR      r1,[sp,#0]
000012  9101              STR      r1,[sp,#4]
000014  4623              MOV      r3,r4
000016  4a04              LDR      r2,|L4.40|
000018  f44f717a          MOV      r1,#0x3e8
00001c  2005              MOVS     r0,#5
00001e  f7fffffe          BL       TIMER_AddTask
;;;221    					1000,
;;;222    					GSM_UART_GpioOnOffControl,
;;;223    					param,
;;;224    					1,
;;;225    					ACTION_MODE_ADD_TO_QUEUE);
;;;226    }
000022  bd1c              POP      {r2-r4,pc}
;;;227    
                          ENDP

                  |L4.36|
                          DCD      0x40010c00
                  |L4.40|
                          DCD      GSM_UART_GpioOnOffControl

                          AREA ||i.GSM_UART_HwInit||, CODE, READONLY, ALIGN=2

                  GSM_UART_HwInit PROC
;;;34     // UART初始化
;;;35     void GSM_UART_HwInit(uint32 baud)
000000  b570              PUSH     {r4-r6,lr}
;;;36     {
000002  4605              MOV      r5,r0
;;;37     	// 打开时钟
;;;38     	rcu_periph_clock_enable(RCU_GPIOC);
000004  f2406004          MOV      r0,#0x604
000008  f7fffffe          BL       rcu_periph_clock_enable
;;;39     	gpio_init(GPIOC, GPIO_MODE_AF_PP, GPIO_OSPEED_2MHZ, GPIO_PIN_10);
00000c  4c30              LDR      r4,|L5.208|
00000e  f44f6380          MOV      r3,#0x400
000012  2202              MOVS     r2,#2
000014  2118              MOVS     r1,#0x18
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       gpio_init
;;;40     	
;;;41     	gpio_init(GPIOC, GPIO_MODE_IPU, GPIO_OSPEED_2MHZ, GPIO_PIN_11);
00001c  14e3              ASRS     r3,r4,#19
00001e  2202              MOVS     r2,#2
000020  2148              MOVS     r1,#0x48
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       gpio_init
;;;42     
;;;43     	// UART时钟配置
;;;44     	rcu_periph_clock_enable(RCU_UART3);
000028  f2407013          MOV      r0,#0x713
00002c  f7fffffe          BL       rcu_periph_clock_enable
;;;45     	usart_deinit(GSM_UART_TYPE_DEF);									// 复位串口
000030  4c28              LDR      r4,|L5.212|
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       usart_deinit
;;;46     		
;;;47     	// 串口配置
;;;48     	usart_baudrate_set(GSM_UART_TYPE_DEF, baud);						// 波特率
000038  4629              MOV      r1,r5
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       usart_baudrate_set
;;;49     	usart_word_length_set(GSM_UART_TYPE_DEF, USART_WL_8BIT);			// 8位数据位
000040  2100              MOVS     r1,#0
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       usart_word_length_set
;;;50     	usart_stop_bit_set(GSM_UART_TYPE_DEF, USART_STB_1BIT); 				// 一个停止位
000048  2100              MOVS     r1,#0
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       usart_stop_bit_set
;;;51     	usart_parity_config(GSM_UART_TYPE_DEF, USART_PM_NONE); 				// 无奇偶校验
000050  2100              MOVS     r1,#0
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       usart_parity_config
;;;52     	usart_hardware_flow_rts_config(GSM_UART_TYPE_DEF, USART_RTS_DISABLE); // 无硬件数据流控制
000058  2100              MOVS     r1,#0
00005a  4620              MOV      r0,r4
00005c  f7fffffe          BL       usart_hardware_flow_rts_config
;;;53     	usart_hardware_flow_cts_config(GSM_UART_TYPE_DEF, USART_CTS_DISABLE);
000060  2100              MOVS     r1,#0
000062  4620              MOV      r0,r4
000064  f7fffffe          BL       usart_hardware_flow_cts_config
;;;54     	usart_transmit_config(GSM_UART_TYPE_DEF, USART_TRANSMIT_ENABLE);	// 使能发射
000068  2108              MOVS     r1,#8
00006a  4620              MOV      r0,r4
00006c  f7fffffe          BL       usart_transmit_config
;;;55     	usart_receive_config(GSM_UART_TYPE_DEF, USART_RECEIVE_ENABLE); 		// 使能接收
000070  2104              MOVS     r1,#4
000072  4620              MOV      r0,r4
000074  f7fffffe          BL       usart_receive_config
;;;56     
;;;57     	// 中断配置
;;;58     	nvic_irq_enable(GSM_UART_IRQn_DEF, 2, 1);
000078  2201              MOVS     r2,#1
00007a  2102              MOVS     r1,#2
00007c  2034              MOVS     r0,#0x34
00007e  f7fffffe          BL       nvic_irq_enable
;;;59     
;;;60     	usart_interrupt_enable(GSM_UART_TYPE_DEF, USART_INT_RBNE); 			// 开启中断
000082  f2403105          MOV      r1,#0x305
000086  4620              MOV      r0,r4
000088  f7fffffe          BL       usart_interrupt_enable
;;;61     
;;;62     	usart_enable(GSM_UART_TYPE_DEF);									// 使能串口 
00008c  4620              MOV      r0,r4
00008e  f7fffffe          BL       usart_enable
;;;63     
;;;64     //====================================================================================================================
;;;65     	// 打开时钟
;;;66     	rcu_periph_clock_enable(RCU_GPIOB);
000092  f2406003          MOV      r0,#0x603
000096  f7fffffe          BL       rcu_periph_clock_enable
;;;67     	gpio_init(GPIOB, GPIO_MODE_OUT_PP, GPIO_OSPEED_2MHZ, GPIO_PIN_8);
00009a  4e0f              LDR      r6,|L5.216|
00009c  15a4              ASRS     r4,r4,#22
00009e  4623              MOV      r3,r4
0000a0  2202              MOVS     r2,#2
0000a2  2110              MOVS     r1,#0x10
0000a4  4630              MOV      r0,r6
0000a6  f7fffffe          BL       gpio_init
;;;68     	
;;;69     	gpio_init(GPIOB, GPIO_MODE_OUT_PP, GPIO_OSPEED_2MHZ, GPIO_PIN_9);
0000aa  0065              LSLS     r5,r4,#1
0000ac  462b              MOV      r3,r5
0000ae  2202              MOVS     r2,#2
0000b0  2110              MOVS     r1,#0x10
0000b2  4630              MOV      r0,r6
0000b4  f7fffffe          BL       gpio_init
;;;70     
;;;71     	// DTR唤醒
;;;72     	GSM_DTR_LOW();
0000b8  2200              MOVS     r2,#0
0000ba  4621              MOV      r1,r4
0000bc  4630              MOV      r0,r6
0000be  f7fffffe          BL       gpio_bit_write
;;;73     
;;;74     	// gsm模块上电默认关机
;;;75     	GSM_ONOFF_HIGH();
0000c2  4629              MOV      r1,r5
0000c4  4630              MOV      r0,r6
0000c6  e8bd4070          POP      {r4-r6,lr}
0000ca  2200              MOVS     r2,#0
0000cc  f7ffbffe          B.W      gpio_bit_write
;;;76     }
;;;77     
                          ENDP

                  |L5.208|
                          DCD      0x40011000
                  |L5.212|
                          DCD      0x40004c00
                  |L5.216|
                          DCD      0x40010c00

                          AREA ||i.GSM_UART_Init||, CODE, READONLY, ALIGN=1

                  GSM_UART_Init PROC
;;;28     // UART初始化
;;;29     void GSM_UART_Init(void)
000000  f44f30e1          MOV      r0,#0x1c200
;;;30     {
;;;31     	GSM_UART_HwInit(GSM_UART_BAUD_RATE_CONTROL);
000004  f7ffbffe          B.W      GSM_UART_HwInit
;;;32     }
;;;33     
                          ENDP


                          AREA ||i.GSM_UART_RcvSimICCID||, CODE, READONLY, ALIGN=2

                  GSM_UART_RcvSimICCID PROC
;;;135    // 接收ICCID处理
;;;136    void GSM_UART_RcvSimICCID(uint8 data)
000000  b570              PUSH     {r4-r6,lr}
;;;137    {
;;;138    	uint8 i;
;;;139    	
;;;140    	// 连续接收数据
;;;141    	gsmUartCB.rx.fifoBuff[gsmUartCB.rx.index++] = data;
000002  4c18              LDR      r4,|L7.100|
000004  f8941047          LDRB     r1,[r4,#0x47]  ; gsmUartCB
000008  1c4a              ADDS     r2,r1,#1
00000a  f8842047          STRB     r2,[r4,#0x47]
00000e  5460              STRB     r0,[r4,r1]
;;;142    
;;;143    	// 越界判断
;;;144    	if (gsmUartCB.rx.index >= sizeof(gsmUartCB.rx.fifoBuff))
000010  f8941047          LDRB     r1,[r4,#0x47]  ; gsmUartCB
000014  2500              MOVS     r5,#0
000016  2932              CMP      r1,#0x32
000018  d302              BCC      |L7.32|
;;;145    	{
;;;146    		gsmUartCB.rx.index = 0;
00001a  f8845047          STRB     r5,[r4,#0x47]
                  |L7.30|
;;;147    
;;;148    		return;
;;;149    	}
;;;150    	
;;;151    	if (data == '\n')			// 收到结束标志
;;;152    	{
;;;153    		gsmUartCB.rx.index = 0;
;;;154    		
;;;155    		// 将读到的ICCID提取出来
;;;156    		if (strstr((const char*)gsmUartCB.rx.fifoBuff, (const char*)"+ICCID: ") != NULL)
;;;157    		{
;;;158    			for (i = 0; i < 20; i++)
;;;159    			{
;;;160    				gsmUartCB.rx.iccidBuff[i] = gsmUartCB.rx.fifoBuff[i+8];
;;;161    			}
;;;162    			gsmUartCB.rx.iccidBuff[i] = '\0';
;;;163    
;;;164    			// 关闭定时器
;;;165    			TIMER_KillTask(TIMER_ID_GSM_CONTROL);
;;;166    			
;;;167    			// gsm模块开关机控制
;;;168    			GSM_UART_GsmPowerOnOff(FALSE);
;;;169    
;;;170    			// ICCID接收完成
;;;171    			gsmUartCB.rcvIccidOK = TRUE;
;;;172    
;;;173    			// 非超时所致
;;;174    			gsmUartCB.rcvIccidTimeOut = FALSE;
;;;175    		}		
;;;176    	}
;;;177    }
00001e  bd70              POP      {r4-r6,pc}
                  |L7.32|
000020  280a              CMP      r0,#0xa               ;151
000022  d1fc              BNE      |L7.30|
000024  f8845047          STRB     r5,[r4,#0x47]         ;153
000028  a10f              ADR      r1,|L7.104|
00002a  480e              LDR      r0,|L7.100|
00002c  f7fffffe          BL       strstr
000030  2800              CMP      r0,#0                 ;156
000032  d0f4              BEQ      |L7.30|
000034  2000              MOVS     r0,#0                 ;158
                  |L7.54|
000036  1821              ADDS     r1,r4,r0              ;160
000038  7a0a              LDRB     r2,[r1,#8]            ;160
00003a  f8812032          STRB     r2,[r1,#0x32]         ;160
00003e  1c40              ADDS     r0,r0,#1              ;158
000040  b2c0              UXTB     r0,r0                 ;158
000042  2814              CMP      r0,#0x14              ;158
000044  d3f7              BCC      |L7.54|
000046  4420              ADD      r0,r0,r4              ;162
000048  f8805032          STRB     r5,[r0,#0x32]         ;162
00004c  2004              MOVS     r0,#4                 ;165
00004e  f7fffffe          BL       TIMER_KillTask
000052  2000              MOVS     r0,#0                 ;168
000054  f7fffffe          BL       GSM_UART_GsmPowerOnOff
000058  2001              MOVS     r0,#1                 ;171
00005a  f8040f49          STRB     r0,[r4,#0x49]!        ;171
00005e  7065              STRB     r5,[r4,#1]            ;174
000060  bd70              POP      {r4-r6,pc}
;;;178    
                          ENDP

000062  0000              DCW      0x0000
                  |L7.100|
                          DCD      ||.bss||
                  |L7.104|
000068  2b494343          DCB      "+ICCID: ",0
00006c  49443a20
000070  00      
000071  00                DCB      0
000072  00                DCB      0
000073  00                DCB      0

                          AREA ||i.GSM_UART_SendCmdGetICCID||, CODE, READONLY, ALIGN=2

                  GSM_UART_SendCmdGetICCID PROC
;;;121    // 发送获取sim的ICCID
;;;122    void GSM_UART_SendCmdGetICCID(uint32 param)
000000  b53e              PUSH     {r1-r5,lr}
;;;123    {
;;;124    	uint8 i;
;;;125    	uint8 iccidStr[] = {'A','T','+','I','C','C','I','D','\r','\n','\0'};
000002  a00a              ADR      r0,|L8.44|
000004  e9d01200          LDRD     r1,r2,[r0,#0]
000008  6880              LDR      r0,[r0,#8]
00000a  e9cd1200          STRD     r1,r2,[sp,#0]
00000e  9002              STR      r0,[sp,#8]
;;;126    
;;;127    	// 启动阻塞式发送命令
;;;128    	for (i = 0; iccidStr[i] != '\0';)
000010  2400              MOVS     r4,#0
000012  466d              MOV      r5,sp                 ;125
000014  e005              B        |L8.34|
                  |L8.22|
;;;129    	{
;;;130    		// 填充数据，启动发送
;;;131    		GSM_UART_BC_SendData(iccidStr[i++]);
000016  4620              MOV      r0,r4
000018  1c64              ADDS     r4,r4,#1
00001a  b2e4              UXTB     r4,r4
00001c  5c28              LDRB     r0,[r5,r0]
00001e  f7fffffe          BL       GSM_UART_BC_SendData
                  |L8.34|
000022  5d28              LDRB     r0,[r5,r4]            ;128
000024  2800              CMP      r0,#0                 ;128
000026  d1f6              BNE      |L8.22|
;;;132    	}
;;;133    }
000028  bd3e              POP      {r1-r5,pc}
;;;134    
                          ENDP

00002a  0000              DCW      0x0000
                  |L8.44|
00002c  41542b49          DCB      "AT+ICCID\r\n",0
000030  43434944
000034  0d0a00  
000037  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  gsmUartCB
                          %        76

;*** Start embedded assembler ***

#line 1 "User\\GsmUart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_GsmUart_c_d24a68d9____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___9_GsmUart_c_d24a68d9____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_GsmUart_c_d24a68d9____REVSH|
#line 128
|__asm___9_GsmUart_c_d24a68d9____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
