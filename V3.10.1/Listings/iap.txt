; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\iap.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\iap.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -IC:\Users\Administrator\AppData\Local\Arm\Packs\GigaDevice\GD32F10x_DFP\2.0.1\Device\Include -D__MICROLIB -D__UVISION_VERSION=534 -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\iap.crf User\iap.c]
                          THUMB

                          AREA ||i.IAP_BleWriteAppBin||, CODE, READONLY, ALIGN=2

                  IAP_BleWriteAppBin PROC
;;;205    *******************************************************************************/
;;;206    BOOL IAP_BleWriteAppBin(uint32 appAddr, uint8 *appBuf, uint32 appSize)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;207    {
000004  460c              MOV      r4,r1
000006  4690              MOV      r8,r2
;;;208    	uint16 i = 0;
000008  2500              MOVS     r5,#0
;;;209    	uint16 j = 0;
00000a  2600              MOVS     r6,#0
;;;210    	uint32 curAppAddr = appAddr; 	// 当前写入的地址
00000c  4681              MOV      r9,r0
;;;211    	uint32 *iapBuf = NULL;
;;;212    	BOOL writeStatus;
;;;213    	
;;;214    	// 参数判断
;;;215    	if (NULL == appBuf)
00000e  2c00              CMP      r4,#0
000010  d009              BEQ      |L1.38|
;;;216    	{
;;;217    		return FALSE;
;;;218    	}
;;;219    
;;;220    	// 参数检验是否非法，地址不能是IAP本身代码地址，绝对不能自己把自己擦掉
;;;221    	if ((appAddr < IAP_FLASH_APP1_ADDR) || ((appAddr + appSize) > (IAP_GD32_FLASH_BASE+IAP_GD32_FLASH_SIZE)))
000012  491a              LDR      r1,|L1.124|
000014  4288              CMP      r0,r1
000016  d303              BCC      |L1.32|
000018  4919              LDR      r1,|L1.128|
00001a  4440              ADD      r0,r0,r8
00001c  4288              CMP      r0,r1
00001e  d904              BLS      |L1.42|
                  |L1.32|
;;;222    	{
;;;223    		return FALSE;		// 非法地址
000020  2000              MOVS     r0,#0
                  |L1.34|
;;;224    	}
;;;225    
;;;226    	// 开辟临时内存
;;;227    	iapBuf = (uint32 *)malloc(1024);
;;;228    	if (NULL == iapBuf)
;;;229    	{
;;;230    		return FALSE;
;;;231    	}
;;;232    	
;;;233    	// 循环写入
;;;234    	for (i = 0, j = 0; j < appSize; j += 4)
;;;235    	{
;;;236    		// 字节整合
;;;237    		iapBuf[i++] = (uint32)(*appBuf) + ((uint32)(*(appBuf+1)) << 8) + ((uint32)(*(appBuf+2)) << 16) + ((uint32)(*(appBuf+3)) << 24);
;;;238    		// 偏移4个字节
;;;239    		appBuf += 4;
;;;240    	}      
;;;241    	
;;;242    	// 直接写入FLASH
;;;243    	writeStatus = IAP_FlashWriteWordArray(curAppAddr, iapBuf, appSize/4);	
;;;244    	
;;;245    	// 释放内存
;;;246    	free(iapBuf);
;;;247    	
;;;248    	return writeStatus;
;;;249    }
000022  e8bd87f0          POP      {r4-r10,pc}
                  |L1.38|
000026  2000              MOVS     r0,#0                 ;217
000028  e7fb              B        |L1.34|
                  |L1.42|
00002a  f44f6080          MOV      r0,#0x400             ;227
00002e  f7fffffe          BL       malloc
000032  4607              MOV      r7,r0                 ;227
000034  0038              MOVS     r0,r7                 ;228
000036  d112              BNE      |L1.94|
000038  e7f3              B        |L1.34|
                  |L1.58|
00003a  7820              LDRB     r0,[r4,#0]            ;237
00003c  7861              LDRB     r1,[r4,#1]            ;237
00003e  78e2              LDRB     r2,[r4,#3]            ;237
000040  eb002001          ADD      r0,r0,r1,LSL #8       ;237
000044  78a1              LDRB     r1,[r4,#2]            ;237
000046  0409              LSLS     r1,r1,#16             ;237
000048  eb016102          ADD      r1,r1,r2,LSL #24      ;237
00004c  4401              ADD      r1,r1,r0              ;237
00004e  4628              MOV      r0,r5                 ;237
000050  1c6d              ADDS     r5,r5,#1              ;237
000052  b2ad              UXTH     r5,r5                 ;237
000054  f8471020          STR      r1,[r7,r0,LSL #2]     ;237
000058  1d24              ADDS     r4,r4,#4              ;239
00005a  1d36              ADDS     r6,r6,#4              ;234
00005c  b2b6              UXTH     r6,r6                 ;234
                  |L1.94|
00005e  4546              CMP      r6,r8                 ;234
000060  d3eb              BCC      |L1.58|
000062  f3c8028f          UBFX     r2,r8,#2,#16          ;243
000066  4639              MOV      r1,r7                 ;243
000068  4648              MOV      r0,r9                 ;243
00006a  f7fffffe          BL       IAP_FlashWriteWordArray
00006e  4604              MOV      r4,r0                 ;243
000070  4638              MOV      r0,r7                 ;246
000072  f7fffffe          BL       free
000076  4620              MOV      r0,r4                 ;248
000078  e7d3              B        |L1.34|
;;;250    
                          ENDP

00007a  0000              DCW      0x0000
                  |L1.124|
                          DCD      0x08008000
                  |L1.128|
                          DCD      0x08040000

                          AREA ||i.IAP_CheckApp1FlashIsBlank||, CODE, READONLY, ALIGN=1

                  IAP_CheckApp1FlashIsBlank PROC
;;;286    // 查询Flash是否为空
;;;287    BOOL IAP_CheckApp1FlashIsBlank(void)
000000  b570              PUSH     {r4-r6,lr}
;;;288    {
;;;289    	uint16 i;
;;;290    	uint16 j;
;;;291    	uint16 readHalfWord;
;;;292    	uint32 readAddr;
;;;293    	
;;;294    	for (i = (IAP_FLASH_ADRESS_APP1_OFFSET/IAP_STM32_PAGE_SIZE); i < ((IAP_FLASH_ADRESS_APP1_OFFSET + IAP_GD32_APP1_SIZE)/IAP_STM32_PAGE_SIZE); i++)
000002  2210              MOVS     r2,#0x10
;;;295    	{
;;;296    		// 页地址
;;;297    		readAddr = i*IAP_STM32_PAGE_SIZE + IAP_GD32_FLASH_BASE;
000004  05d6              LSLS     r6,r2,#23
;;;298    
;;;299    		for (j = 0; j < IAP_STM32_PAGE_SIZE; j += 2)
;;;300    		{
;;;301    			readHalfWord = IAP_FlashReadHalfWord(readAddr);	// 读
;;;302    		  	readAddr += 2;
;;;303    
;;;304    			// 全为0xFFFF说明为空
;;;305    			if (readHalfWord == 0xFFFF)
000006  f64f74ff          MOV      r4,#0xffff
00000a  01d5              LSLS     r5,r2,#7              ;299
                  |L2.12|
00000c  eb0623c2          ADD      r3,r6,r2,LSL #11      ;297
000010  2100              MOVS     r1,#0                 ;299
                  |L2.18|
000012  4618              MOV      r0,r3                 ;301
000014  f7fffffe          BL       IAP_FlashReadHalfWord
000018  1c9b              ADDS     r3,r3,#2              ;302
00001a  42a0              CMP      r0,r4
00001c  d109              BNE      |L2.50|
00001e  1c89              ADDS     r1,r1,#2              ;299
000020  b289              UXTH     r1,r1                 ;299
000022  42a9              CMP      r1,r5                 ;299
;;;306    			{
;;;307    				continue;
000024  d3f5              BCC      |L2.18|
000026  1c52              ADDS     r2,r2,#1              ;294
000028  b292              UXTH     r2,r2                 ;294
00002a  2a80              CMP      r2,#0x80              ;294
00002c  d3ee              BCC      |L2.12|
;;;308    			}
;;;309    			else
;;;310    			{
;;;311    				return FALSE;
;;;312    			}
;;;313    		}  
;;;314    		
;;;315    	}
;;;316    
;;;317    	return TRUE;
00002e  2001              MOVS     r0,#1
;;;318    }
000030  bd70              POP      {r4-r6,pc}
                  |L2.50|
000032  2000              MOVS     r0,#0                 ;311
000034  bd70              POP      {r4-r6,pc}
;;;319    
                          ENDP


                          AREA ||i.IAP_CheckApp2FlashIsBlank||, CODE, READONLY, ALIGN=1

                  IAP_CheckApp2FlashIsBlank PROC
;;;320    // 查询Flash是否为空
;;;321    BOOL IAP_CheckApp2FlashIsBlank(void)
000000  b570              PUSH     {r4-r6,lr}
;;;322    {
;;;323    	uint16 i;
;;;324    	uint16 j;
;;;325    	uint16 readHalfWord;
;;;326    	uint32 readAddr;
;;;327    	
;;;328    	for (i = (IAP_FLASH_ADRESS_APP2_OFFSET/IAP_STM32_PAGE_SIZE); i < ((IAP_FLASH_ADRESS_APP2_OFFSET + IAP_GD32_APP2_SIZE)/IAP_STM32_PAGE_SIZE); i++)
000002  2220              MOVS     r2,#0x20
;;;329    	{
;;;330    		// 页地址
;;;331    		readAddr = i*IAP_STM32_PAGE_SIZE + IAP_GD32_FLASH_BASE;
000004  0596              LSLS     r6,r2,#22
;;;332    
;;;333    		for (j = 0; j < IAP_STM32_PAGE_SIZE; j += 2)
;;;334    		{
;;;335    			readHalfWord = IAP_FlashReadHalfWord(readAddr);	// 读
;;;336    		  	readAddr += 2;
;;;337    
;;;338    			// 全为0xFFFF说明为空
;;;339    			if (readHalfWord == 0xFFFF)
000006  f64f74ff          MOV      r4,#0xffff
00000a  0195              LSLS     r5,r2,#6              ;333
                  |L3.12|
00000c  eb0623c2          ADD      r3,r6,r2,LSL #11      ;331
000010  2100              MOVS     r1,#0                 ;333
                  |L3.18|
000012  4618              MOV      r0,r3                 ;335
000014  f7fffffe          BL       IAP_FlashReadHalfWord
000018  1c9b              ADDS     r3,r3,#2              ;336
00001a  42a0              CMP      r0,r4
00001c  d109              BNE      |L3.50|
00001e  1c89              ADDS     r1,r1,#2              ;333
000020  b289              UXTH     r1,r1                 ;333
000022  42a9              CMP      r1,r5                 ;333
;;;340    			{
;;;341    				continue;
000024  d3f5              BCC      |L3.18|
000026  1c52              ADDS     r2,r2,#1              ;328
000028  b292              UXTH     r2,r2                 ;328
00002a  2a80              CMP      r2,#0x80              ;328
00002c  d3ee              BCC      |L3.12|
;;;342    			}
;;;343    			else
;;;344    			{
;;;345    				return FALSE;
;;;346    			}
;;;347    		}
;;;348    		
;;;349    	}
;;;350    
;;;351    	return TRUE;
00002e  2001              MOVS     r0,#1
;;;352    }
000030  bd70              POP      {r4-r6,pc}
                  |L3.50|
000032  2000              MOVS     r0,#0                 ;345
000034  bd70              POP      {r4-r6,pc}
;;;353    
                          ENDP


                          AREA ||i.IAP_CheckAppRightful||, CODE, READONLY, ALIGN=2

                  IAP_CheckAppRightful PROC
;;;115    // 判断指定地址APP是否合法
;;;116    uint8 IAP_CheckAppRightful(uint32 addr)
000000  4a08              LDR      r2,|L4.36|
;;;117    {
;;;118    	// 检查栈顶地址是否合法.
;;;119    	if(((*(uint32*)addr) & 0x2FFE0000) != 0x20000000)	
000002  6801              LDR      r1,[r0,#0]
000004  4011              ANDS     r1,r1,r2
000006  f1b15f00          CMP      r1,#0x20000000
00000a  d001              BEQ      |L4.16|
;;;120    	{
;;;121    		return 0;
00000c  2000              MOVS     r0,#0
;;;122    	}
;;;123    
;;;124    	// APP无效
;;;125    	if (((*(uint32*)(addr+4)) & 0xFFF80000) != 0x08000000)
;;;126    	{
;;;127    		return 0;
;;;128    	}
;;;129    
;;;130    	return 1;
;;;131    }
00000e  4770              BX       lr
                  |L4.16|
000010  6840              LDR      r0,[r0,#4]            ;125
000012  f44f7180          MOV      r1,#0x100             ;125
000016  ebb14fd0          CMP      r1,r0,LSR #19         ;125
00001a  d001              BEQ      |L4.32|
00001c  2000              MOVS     r0,#0                 ;127
00001e  4770              BX       lr
                  |L4.32|
000020  2001              MOVS     r0,#1                 ;130
000022  4770              BX       lr
;;;132    
                          ENDP

                  |L4.36|
                          DCD      0x2ffe0000

                          AREA ||i.IAP_CheckFlashIsBlank||, CODE, READONLY, ALIGN=1

                  IAP_CheckFlashIsBlank PROC
;;;252    // 查询Flash是否为空
;;;253    BOOL IAP_CheckFlashIsBlank(void)
000000  b570              PUSH     {r4-r6,lr}
;;;254    {
;;;255    	uint16 i;
;;;256    	uint16 j;
;;;257    	uint16 readHalfWord;
;;;258    	uint32 readAddr;
;;;259    	
;;;260    	for (i = (IAP_FLASH_ADRESS_APP1_OFFSET/IAP_STM32_PAGE_SIZE); i < (IAP_GD32_FLASH_SIZE/IAP_STM32_PAGE_SIZE); i++)
000002  2210              MOVS     r2,#0x10
;;;261    	{
;;;262    		// 页地址
;;;263    		readAddr = i*IAP_STM32_PAGE_SIZE + IAP_GD32_FLASH_BASE;
000004  05d6              LSLS     r6,r2,#23
;;;264    
;;;265    		for (j = 0; j < IAP_STM32_PAGE_SIZE; j += 2)
;;;266    		{
;;;267    			readHalfWord = IAP_FlashReadHalfWord(readAddr);	// 读
;;;268    		  	readAddr += 2;
;;;269    
;;;270    			// 全为0xFFFF说明为空
;;;271    			if (readHalfWord == 0xFFFF)
000006  f64f74ff          MOV      r4,#0xffff
00000a  01d5              LSLS     r5,r2,#7              ;265
                  |L5.12|
00000c  eb0623c2          ADD      r3,r6,r2,LSL #11      ;263
000010  2100              MOVS     r1,#0                 ;265
                  |L5.18|
000012  4618              MOV      r0,r3                 ;267
000014  f7fffffe          BL       IAP_FlashReadHalfWord
000018  1c9b              ADDS     r3,r3,#2              ;268
00001a  42a0              CMP      r0,r4
00001c  d109              BNE      |L5.50|
00001e  1c89              ADDS     r1,r1,#2              ;265
000020  b289              UXTH     r1,r1                 ;265
000022  42a9              CMP      r1,r5                 ;265
;;;272    			{
;;;273    				continue;
000024  d3f5              BCC      |L5.18|
000026  1c52              ADDS     r2,r2,#1              ;260
000028  b292              UXTH     r2,r2                 ;260
00002a  2a80              CMP      r2,#0x80              ;260
00002c  d3ee              BCC      |L5.12|
;;;274    			}
;;;275    			else
;;;276    			{
;;;277    				return FALSE;
;;;278    			}
;;;279    		}  
;;;280    		
;;;281    	}
;;;282    
;;;283    	return TRUE;
00002e  2001              MOVS     r0,#1
;;;284    }
000030  bd70              POP      {r4-r6,pc}
                  |L5.50|
000032  2000              MOVS     r0,#0                 ;277
000034  bd70              POP      {r4-r6,pc}
;;;285    
                          ENDP


                          AREA ||i.IAP_EraseAPP1Area||, CODE, READONLY, ALIGN=1

                  IAP_EraseAPP1Area PROC
;;;396    // 擦除APP1所有页
;;;397    BOOL IAP_EraseAPP1Area(void)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;398    {
;;;399    	uint16 i;
;;;400    	fmc_state_enum status = FMC_READY;
;;;401    	BOOL eraseStatus = TRUE;
000004  2501              MOVS     r5,#1
;;;402    
;;;403    	DI();				// 关闭总中断
000006  b672              CPSID    i
;;;404    	fmc_unlock();		// 解锁
000008  f7fffffe          BL       fmc_unlock
;;;405    
;;;406    	// 清除所有挂起标志位
;;;407        fmc_flag_clear(FMC_FLAG_BANK0_END);
00000c  f2403705          MOV      r7,#0x305
000010  4638              MOV      r0,r7
000012  f7fffffe          BL       fmc_flag_clear
;;;408        fmc_flag_clear(FMC_FLAG_BANK0_WPERR);
000016  f44f7841          MOV      r8,#0x304
00001a  4640              MOV      r0,r8
00001c  f7fffffe          BL       fmc_flag_clear
;;;409        fmc_flag_clear(FMC_FLAG_BANK0_PGERR);
000020  f2403902          MOV      r9,#0x302
000024  4648              MOV      r0,r9
000026  f7fffffe          BL       fmc_flag_clear
;;;410    	
;;;411    	// 擦除APP所有页
;;;412    	for (i = (IAP_FLASH_ADRESS_APP1_OFFSET/IAP_STM32_PAGE_SIZE); i < ((IAP_FLASH_ADRESS_APP1_OFFSET + IAP_GD32_APP1_SIZE)/IAP_STM32_PAGE_SIZE); i++)
00002a  2410              MOVS     r4,#0x10
;;;413    	{
;;;414    		status = fmc_page_erase(i*IAP_STM32_PAGE_SIZE + IAP_GD32_FLASH_BASE);
00002c  05e6              LSLS     r6,r4,#23
                  |L6.46|
00002e  eb0620c4          ADD      r0,r6,r4,LSL #11
000032  f7fffffe          BL       fmc_page_erase
000036  4682              MOV      r10,r0
;;;415    
;;;416    		fmc_flag_clear(FMC_FLAG_BANK0_END);
000038  4638              MOV      r0,r7
00003a  f7fffffe          BL       fmc_flag_clear
;;;417            fmc_flag_clear(FMC_FLAG_BANK0_WPERR);
00003e  4640              MOV      r0,r8
000040  f7fffffe          BL       fmc_flag_clear
;;;418            fmc_flag_clear(FMC_FLAG_BANK0_PGERR);
000044  4648              MOV      r0,r9
000046  f7fffffe          BL       fmc_flag_clear
;;;419    		
;;;420    		if (FMC_READY != status)
00004a  f1ba0f00          CMP      r10,#0
00004e  d001              BEQ      |L6.84|
;;;421    		{
;;;422    			eraseStatus = FALSE;
000050  2500              MOVS     r5,#0
;;;423    
;;;424    			break;
000052  e005              B        |L6.96|
                  |L6.84|
;;;425    		}
;;;426    
;;;427    		// 清看门狗
;;;428    		WDT_Clear();
000054  f7fffffe          BL       WDT_Clear
000058  1c64              ADDS     r4,r4,#1              ;412
00005a  b2a4              UXTH     r4,r4                 ;412
00005c  2c80              CMP      r4,#0x80              ;412
00005e  d3e6              BCC      |L6.46|
                  |L6.96|
;;;429    	}
;;;430    
;;;431    	fmc_lock();			// 上锁
000060  f7fffffe          BL       fmc_lock
;;;432    	EI(); 				// 开启总中断
000064  b662              CPSIE    i
;;;433    
;;;434    	return eraseStatus;
000066  4628              MOV      r0,r5
;;;435    }
000068  e8bd87f0          POP      {r4-r10,pc}
;;;436    
                          ENDP


                          AREA ||i.IAP_EraseAPP2Area||, CODE, READONLY, ALIGN=1

                  IAP_EraseAPP2Area PROC
;;;437    // 擦除APP2所有页
;;;438    BOOL IAP_EraseAPP2Area(void)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;439    {
;;;440    	uint16 i;
;;;441    	fmc_state_enum status = FMC_READY;
;;;442    	BOOL eraseStatus = TRUE;
000004  2501              MOVS     r5,#1
;;;443    
;;;444    	DI();				// 关闭总中断
000006  b672              CPSID    i
;;;445    	fmc_unlock();		// 解锁
000008  f7fffffe          BL       fmc_unlock
;;;446    
;;;447    	// 清除所有挂起标志位
;;;448        fmc_flag_clear(FMC_FLAG_BANK0_END);
00000c  f2403705          MOV      r7,#0x305
000010  4638              MOV      r0,r7
000012  f7fffffe          BL       fmc_flag_clear
;;;449        fmc_flag_clear(FMC_FLAG_BANK0_WPERR);
000016  f44f7841          MOV      r8,#0x304
00001a  4640              MOV      r0,r8
00001c  f7fffffe          BL       fmc_flag_clear
;;;450        fmc_flag_clear(FMC_FLAG_BANK0_PGERR);
000020  f2403902          MOV      r9,#0x302
000024  4648              MOV      r0,r9
000026  f7fffffe          BL       fmc_flag_clear
;;;451    	
;;;452    	// 擦除APP所有页
;;;453    	for (i = (IAP_FLASH_ADRESS_APP2_OFFSET/IAP_STM32_PAGE_SIZE); i < ((IAP_FLASH_ADRESS_APP2_OFFSET + IAP_GD32_APP2_SIZE)/IAP_STM32_PAGE_SIZE); i++)
00002a  2420              MOVS     r4,#0x20
;;;454    	{
;;;455    		status = fmc_page_erase(i*IAP_STM32_PAGE_SIZE + IAP_GD32_FLASH_BASE);
00002c  05a6              LSLS     r6,r4,#22
                  |L7.46|
00002e  eb0620c4          ADD      r0,r6,r4,LSL #11
000032  f7fffffe          BL       fmc_page_erase
000036  4682              MOV      r10,r0
;;;456    
;;;457    		fmc_flag_clear(FMC_FLAG_BANK0_END);
000038  4638              MOV      r0,r7
00003a  f7fffffe          BL       fmc_flag_clear
;;;458            fmc_flag_clear(FMC_FLAG_BANK0_WPERR);
00003e  4640              MOV      r0,r8
000040  f7fffffe          BL       fmc_flag_clear
;;;459            fmc_flag_clear(FMC_FLAG_BANK0_PGERR);
000044  4648              MOV      r0,r9
000046  f7fffffe          BL       fmc_flag_clear
;;;460    
;;;461    		if (FMC_READY != status)
00004a  f1ba0f00          CMP      r10,#0
00004e  d001              BEQ      |L7.84|
;;;462    		{
;;;463    			eraseStatus = FALSE;
000050  2500              MOVS     r5,#0
;;;464    
;;;465    			break;
000052  e005              B        |L7.96|
                  |L7.84|
;;;466    		}
;;;467    		
;;;468    		// 清看门狗
;;;469    		WDT_Clear();
000054  f7fffffe          BL       WDT_Clear
000058  1c64              ADDS     r4,r4,#1              ;453
00005a  b2a4              UXTH     r4,r4                 ;453
00005c  2c80              CMP      r4,#0x80              ;453
00005e  d3e6              BCC      |L7.46|
                  |L7.96|
;;;470    	}
;;;471    
;;;472    	fmc_lock();			// 上锁
000060  f7fffffe          BL       fmc_lock
;;;473    	EI(); 				// 开启总中断
000064  b662              CPSIE    i
;;;474    
;;;475    	return eraseStatus;
000066  4628              MOV      r0,r5
;;;476    }
000068  e8bd87f0          POP      {r4-r10,pc}
;;;477    
                          ENDP


                          AREA ||i.IAP_EraseAPPArea||, CODE, READONLY, ALIGN=1

                  IAP_EraseAPPArea PROC
;;;355    // 擦除APP所有页
;;;356    BOOL IAP_EraseAPPArea(void)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;357    {
;;;358    	uint16 i;
;;;359    	fmc_state_enum status = FMC_READY;
;;;360    	BOOL eraseStatus = TRUE;
000004  2501              MOVS     r5,#1
;;;361    
;;;362    	DI();				// 关闭总中断
000006  b672              CPSID    i
;;;363    	fmc_unlock();		// 解锁
000008  f7fffffe          BL       fmc_unlock
;;;364    
;;;365    	// 清除所有挂起标志位
;;;366        fmc_flag_clear(FMC_FLAG_BANK0_END);
00000c  f2403705          MOV      r7,#0x305
000010  4638              MOV      r0,r7
000012  f7fffffe          BL       fmc_flag_clear
;;;367        fmc_flag_clear(FMC_FLAG_BANK0_WPERR);
000016  f44f7841          MOV      r8,#0x304
00001a  4640              MOV      r0,r8
00001c  f7fffffe          BL       fmc_flag_clear
;;;368        fmc_flag_clear(FMC_FLAG_BANK0_PGERR);
000020  f2403902          MOV      r9,#0x302
000024  4648              MOV      r0,r9
000026  f7fffffe          BL       fmc_flag_clear
;;;369    	
;;;370    	// 擦除APP所有页
;;;371    	for (i = (IAP_FLASH_ADRESS_APP1_OFFSET/IAP_STM32_PAGE_SIZE); i < (IAP_GD32_FLASH_SIZE/IAP_STM32_PAGE_SIZE); i++)
00002a  2410              MOVS     r4,#0x10
;;;372    	{
;;;373    		status = fmc_page_erase(i*IAP_STM32_PAGE_SIZE + IAP_GD32_FLASH_BASE);
00002c  05e6              LSLS     r6,r4,#23
                  |L8.46|
00002e  eb0620c4          ADD      r0,r6,r4,LSL #11
000032  f7fffffe          BL       fmc_page_erase
000036  4682              MOV      r10,r0
;;;374    
;;;375    		fmc_flag_clear(FMC_FLAG_BANK0_END);
000038  4638              MOV      r0,r7
00003a  f7fffffe          BL       fmc_flag_clear
;;;376            fmc_flag_clear(FMC_FLAG_BANK0_WPERR);
00003e  4640              MOV      r0,r8
000040  f7fffffe          BL       fmc_flag_clear
;;;377            fmc_flag_clear(FMC_FLAG_BANK0_PGERR);
000044  4648              MOV      r0,r9
000046  f7fffffe          BL       fmc_flag_clear
;;;378    		
;;;379    		if (FMC_READY != status)
00004a  f1ba0f00          CMP      r10,#0
00004e  d001              BEQ      |L8.84|
;;;380    		{
;;;381    			eraseStatus = FALSE;
000050  2500              MOVS     r5,#0
;;;382    
;;;383    			break;
000052  e005              B        |L8.96|
                  |L8.84|
;;;384    		}
;;;385    
;;;386    		// 清看门狗
;;;387    		WDT_Clear();
000054  f7fffffe          BL       WDT_Clear
000058  1c64              ADDS     r4,r4,#1              ;371
00005a  b2a4              UXTH     r4,r4                 ;371
00005c  2c80              CMP      r4,#0x80              ;371
00005e  d3e6              BCC      |L8.46|
                  |L8.96|
;;;388    	}
;;;389    
;;;390    	fmc_lock();		// 上锁
000060  f7fffffe          BL       fmc_lock
;;;391    	EI(); 				// 开启总中断
000064  b662              CPSIE    i
;;;392    
;;;393    	return eraseStatus;
000066  4628              MOV      r0,r5
;;;394    }
000068  e8bd87f0          POP      {r4-r10,pc}
;;;395    
                          ENDP


                          AREA ||i.IAP_FlashReadForCrc8||, CODE, READONLY, ALIGN=2

                  IAP_FlashReadForCrc8 PROC
;;;1001   *******************************************************************************/
;;;1002   uint8 IAP_FlashReadForCrc8(uint32 datalen)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1003   {
000002  4601              MOV      r1,r0
;;;1004   	uint8 crc = 0;
000004  2000              MOVS     r0,#0
;;;1005   	uint8 i,j;
;;;1006   	uint8 buf[4] = {0};
000006  2200              MOVS     r2,#0
000008  9200              STR      r2,[sp,#0]
;;;1007   	uint32 addrIndex = 0;
00000a  2300              MOVS     r3,#0
;;;1008   	uint32 dataTemp;
;;;1009   	uint32 len = datalen/4;
00000c  088c              LSRS     r4,r1,#2
00000e  e021              B        |L9.84|
                  |L9.16|
;;;1010   
;;;1011   	while (len--)
;;;1012   	{
;;;1013   		dataTemp = *(volatile uint32*)(addrIndex + IAP_FLASH_APP2_ADDR);
000010  4912              LDR      r1,|L9.92|
000012  5859              LDR      r1,[r3,r1]
;;;1014   		addrIndex += 4;
000014  1d1b              ADDS     r3,r3,#4
;;;1015   		// 小端模式
;;;1016   		buf[3] = (uint8)(dataTemp >> 24);
000016  0e0a              LSRS     r2,r1,#24
000018  f88d2003          STRB     r2,[sp,#3]
;;;1017   		buf[2] = (uint8)(dataTemp >> 16);
00001c  0c0a              LSRS     r2,r1,#16
00001e  f88d2002          STRB     r2,[sp,#2]
;;;1018   		buf[1] = (uint8)(dataTemp >> 8);
000022  0a0a              LSRS     r2,r1,#8
000024  f88d2001          STRB     r2,[sp,#1]
;;;1019   		buf[0] = (uint8)dataTemp;
000028  f88d1000          STRB     r1,[sp,#0]
;;;1020   		
;;;1021   		for(j = 0; j < 4; j++)
00002c  2200              MOVS     r2,#0
00002e  466e              MOV      r6,sp                 ;1006
;;;1022   		{
;;;1023   			crc ^= buf[j];
;;;1024   			
;;;1025   			for (i = 0; i < 8; i++)
;;;1026   			{
;;;1027   				if (crc & 0x01)
;;;1028   				{
;;;1029   					crc = (crc >> 1) ^ 0x8C;
000030  258c              MOVS     r5,#0x8c
                  |L9.50|
000032  5cb1              LDRB     r1,[r6,r2]            ;1023
000034  4048              EORS     r0,r0,r1              ;1023
000036  2100              MOVS     r1,#0                 ;1025
                  |L9.56|
000038  07c7              LSLS     r7,r0,#31             ;1027
00003a  d002              BEQ      |L9.66|
00003c  ea850050          EOR      r0,r5,r0,LSR #1
000040  e000              B        |L9.68|
                  |L9.66|
;;;1030   				}
;;;1031   				else
;;;1032   				{
;;;1033   					crc >>= 1;
000042  0840              LSRS     r0,r0,#1
                  |L9.68|
000044  1c49              ADDS     r1,r1,#1              ;1025
000046  b2c9              UXTB     r1,r1                 ;1025
000048  2908              CMP      r1,#8                 ;1025
00004a  d3f5              BCC      |L9.56|
00004c  1c52              ADDS     r2,r2,#1              ;1021
00004e  b2d2              UXTB     r2,r2                 ;1021
000050  2a04              CMP      r2,#4                 ;1021
000052  d3ee              BCC      |L9.50|
                  |L9.84|
000054  1e64              SUBS     r4,r4,#1              ;1011
000056  1c61              ADDS     r1,r4,#1              ;1011
000058  d1da              BNE      |L9.16|
;;;1034   				}
;;;1035   			}
;;;1036   		}
;;;1037   	}
;;;1038   	return crc;
;;;1039   }
00005a  bdf8              POP      {r3-r7,pc}
;;;1040   
                          ENDP

                  |L9.92|
                          DCD      0x08010000

                          AREA ||i.IAP_FlashReadHalfWord||, CODE, READONLY, ALIGN=1

                  IAP_FlashReadHalfWord PROC
;;;483    *******************************************************************************/
;;;484    uint16 IAP_FlashReadHalfWord(uint32 flashAddr)
000000  8800              LDRH     r0,[r0,#0]
;;;485    {
;;;486    	return *(volatile uint16*)flashAddr; 
;;;487    }
000002  4770              BX       lr
;;;488    
                          ENDP


                          AREA ||i.IAP_FlashReadHalfWordArray||, CODE, READONLY, ALIGN=1

                  IAP_FlashReadHalfWordArray PROC
;;;701    *******************************************************************************/
;;;702    void IAP_FlashReadHalfWordArray(uint32 readAddr, uint16 *pBuffer, uint16 numToRead)   	
000000  b510              PUSH     {r4,lr}
;;;703    {
000002  4604              MOV      r4,r0
;;;704    	uint16 i;
;;;705    
;;;706    	// 参数判断
;;;707    	if (NULL == pBuffer)
000004  2900              CMP      r1,#0
000006  d010              BEQ      |L11.42|
;;;708    	{
;;;709    		return;
;;;710    	}
;;;711    
;;;712    	// 参数检验是否非法
;;;713    	if ((readAddr < IAP_GD32_FLASH_BASE) || (readAddr >= (IAP_GD32_FLASH_BASE+IAP_GD32_FLASH_SIZE)))
000008  f1a46000          SUB      r0,r4,#0x8000000
00000c  f5b02f80          CMP      r0,#0x40000
000010  d20b              BCS      |L11.42|
;;;714    	{
;;;715    		return;	// 非法地址
;;;716    	}
;;;717    	
;;;718    	for (i = 0; i < numToRead; i++)
000012  2300              MOVS     r3,#0
000014  e007              B        |L11.38|
                  |L11.22|
;;;719    	{
;;;720    		pBuffer[i] = IAP_FlashReadHalfWord(readAddr);	// 读取2个字节.
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       IAP_FlashReadHalfWord
00001c  f8210013          STRH     r0,[r1,r3,LSL #1]
;;;721    		readAddr += 2; 									// 偏移2个字节.	
000020  1ca4              ADDS     r4,r4,#2
000022  1c5b              ADDS     r3,r3,#1              ;718
000024  b29b              UXTH     r3,r3                 ;718
                  |L11.38|
000026  4293              CMP      r3,r2                 ;718
000028  d3f5              BCC      |L11.22|
                  |L11.42|
;;;722    	}
;;;723    }
00002a  bd10              POP      {r4,pc}
;;;724    
                          ENDP


                          AREA ||i.IAP_FlashReadWord||, CODE, READONLY, ALIGN=1

                  IAP_FlashReadWord PROC
;;;850    *******************************************************************************/
;;;851    uint32 IAP_FlashReadWord(uint32 flashAddr)
000000  6800              LDR      r0,[r0,#0]
;;;852    {
;;;853    	return *(volatile uint32*)flashAddr; 
;;;854    }
000002  4770              BX       lr
;;;855    
                          ENDP


                          AREA ||i.IAP_FlashReadWordArray||, CODE, READONLY, ALIGN=2

                  IAP_FlashReadWordArray PROC
;;;821    *******************************************************************************/
;;;822    void IAP_FlashReadWordArray(uint32 readAddr, uint32 *pBuffer, uint16 numToRead)   	
000000  b510              PUSH     {r4,lr}
;;;823    {
000002  4604              MOV      r4,r0
;;;824    	uint16 i;
;;;825    
;;;826    	// 参数判断
;;;827    	if (NULL == pBuffer)
000004  2900              CMP      r1,#0
000006  d012              BEQ      |L13.46|
;;;828    	{
;;;829    		return;
;;;830    	}
;;;831    
;;;832    	// 参数检验是否非法
;;;833    	if ((readAddr < IAP_GD32_FLASH_BASE) || ((readAddr + numToRead) > (IAP_GD32_FLASH_BASE+IAP_GD32_FLASH_SIZE+1024UL)))
000008  f1b46f00          CMP      r4,#0x8000000
00000c  d30f              BCC      |L13.46|
00000e  4b08              LDR      r3,|L13.48|
000010  18a0              ADDS     r0,r4,r2
000012  4298              CMP      r0,r3
000014  d80b              BHI      |L13.46|
;;;834    	{
;;;835    		return;	// 非法地址
;;;836    	}
;;;837    	
;;;838    	for (i = 0; i < numToRead; i++)
000016  2300              MOVS     r3,#0
000018  e007              B        |L13.42|
                  |L13.26|
;;;839    	{
;;;840    		pBuffer[i] = IAP_FlashReadWord(readAddr);	// 读取4个字节.
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       IAP_FlashReadWord
000020  f8410023          STR      r0,[r1,r3,LSL #2]
;;;841    		readAddr += 4;								// 偏移4个字节.	
000024  1d24              ADDS     r4,r4,#4
000026  1c5b              ADDS     r3,r3,#1              ;838
000028  b29b              UXTH     r3,r3                 ;838
                  |L13.42|
00002a  4293              CMP      r3,r2                 ;838
00002c  d3f5              BCC      |L13.26|
                  |L13.46|
;;;842    	}
;;;843    }
00002e  bd10              POP      {r4,pc}
;;;844    
                          ENDP

                  |L13.48|
                          DCD      0x08040400

                          AREA ||i.IAP_FlashWriteHalfWordArray||, CODE, READONLY, ALIGN=1

                  IAP_FlashWriteHalfWordArray PROC
;;;541    *******************************************************************************/
;;;542    BOOL IAP_FlashWriteHalfWordArray(uint32 writeAddr, uint16 *pBuffer, uint16 numToWrite)	
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;543    {
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
;;;544    #if 0
;;;545    
;;;546    	uint32 secpos;	    // 扇区地址
;;;547    	uint16 secoff;	    // 扇区内偏移地址(16位字计算)
;;;548    	uint16 secremain;  	// 扇区内剩余地址(16位字计算)	   
;;;549     	uint16 i;    
;;;550    	uint32 offaddr;    	// 去掉0X08000000后的地址
;;;551    	BOOL writeStatus = FALSE;
;;;552    	FLASH_Status status = FLASH_COMPLETE;
;;;553    	static uint16 iapFlashBuf[IAP_STM32_PAGE_SIZE/2];	// 最多是2K字节
;;;554    
;;;555    	// 参数检验是否非法
;;;556    	if ((writeAddr < IAP_GD32_FLASH_BASE) || (writeAddr >= (IAP_GD32_FLASH_BASE+IAP_GD32_FLASH_SIZE)))
;;;557    	{
;;;558    		return FALSE;	// 非法地址
;;;559    	}
;;;560    	
;;;561    	DI();			// 关闭总中断
;;;562    	FLASH_Unlock();	// 解锁
;;;563    
;;;564    	// 清除所有挂起标志位
;;;565    	FLASH_ClearFlag(FLASH_FLAG_EOP | FLASH_FLAG_PGERR | FLASH_FLAG_WRPRTERR);
;;;566    	
;;;567    	offaddr = writeAddr-IAP_GD32_FLASH_BASE;			// 实际偏移地址.
;;;568    	secpos = offaddr/IAP_STM32_PAGE_SIZE;				// 扇区地址  0~127 for STM32F103RBT6
;;;569    	secoff = (offaddr%IAP_STM32_PAGE_SIZE)/2;			// 在扇区内的偏移(2个字节为基本单位.)
;;;570    	secremain = IAP_STM32_PAGE_SIZE/2 - secoff;			// 扇区剩余空间大小 
;;;571    
;;;572    	// 不大于该扇区范围
;;;573    	if (numToWrite <= secremain) 
;;;574    	{
;;;575    		secremain = numToWrite;
;;;576    	}
;;;577    	
;;;578    	while (1)
;;;579    	{
;;;580    		// 读出整个扇区的内容
;;;581    		IAP_FlashReadHalfWordArray((secpos*IAP_STM32_PAGE_SIZE+IAP_GD32_FLASH_BASE),
;;;582    									iapFlashBuf,
;;;583    									IAP_STM32_PAGE_SIZE/2);
;;;584    
;;;585    		// 校验数据
;;;586    		for (i = 0; i < secremain; i++)
;;;587    		{
;;;588    			if (iapFlashBuf[secoff + i] != 0xFFFF)
;;;589    			{
;;;590    				// 里面的数据不全是0xFFFF，说明需要擦除
;;;591    				break;
;;;592    			}
;;;593    		}
;;;594    
;;;595    		// 需要擦除
;;;596    		if (i < secremain)
;;;597    		{
;;;598    			// 擦除这个扇区
;;;599    			status = FLASH_ErasePage(secpos*IAP_STM32_PAGE_SIZE+IAP_STM32_FLASH_BASE);
;;;600    
;;;601    			if (FLASH_COMPLETE != status)
;;;602    			{
;;;603    				return FALSE;
;;;604    			}
;;;605    			
;;;606    			for (i = 0; i < secremain; i++) // 复制
;;;607    			{
;;;608    				iapFlashBuf[i + secoff] = pBuffer[i];	  
;;;609    			}
;;;610    
;;;611    			// 写入整个扇区
;;;612    			writeStatus = IAP_FlashWriteHalfWordArrayAndCheck((secpos*IAP_STM32_PAGE_SIZE+IAP_GD32_FLASH_BASE), 
;;;613    																iapFlashBuf, 
;;;614    																IAP_STM32_PAGE_SIZE/2);
;;;615    		}
;;;616    		// 不需要擦除
;;;617    		else
;;;618    		{
;;;619    			writeStatus = IAP_FlashWriteHalfWordArrayAndCheck(writeAddr,pBuffer,secremain); //写已经擦除了的,直接写入扇区剩余区间. 
;;;620    		}
;;;621    		
;;;622    		if (!writeStatus)
;;;623    		{
;;;624    			break;
;;;625    		}
;;;626    		
;;;627    		// 写入结束了
;;;628    		if (numToWrite == secremain)
;;;629    		{
;;;630    			break;
;;;631    		}
;;;632    		// 写入未结束
;;;633    		else 
;;;634    		{
;;;635    			secpos++;							// 扇区地址增1
;;;636    			secoff = 0;							// 偏移位置为0 	 
;;;637    		 	pBuffer += secremain;  	     		// 指针偏移
;;;638    			writeAddr += secremain;				// 写地址偏移	   
;;;639    		  	numToWrite -= secremain;			// 字节(16位)数递减
;;;640    
;;;641    		  	// 下一个扇区还是写不完
;;;642    			if (numToWrite > (IAP_STM32_PAGE_SIZE/2))
;;;643    			{
;;;644    				secremain = IAP_STM32_PAGE_SIZE/2;	
;;;645    			}
;;;646    			// 下一个扇区可以写完了
;;;647    			else 
;;;648    			{
;;;649    				secremain = numToWrite;
;;;650    			}
;;;651    		}	 
;;;652    	}
;;;653    	
;;;654    	FLASH_Lock();		// 上锁
;;;655    	EI(); 				// 开启总中断
;;;656    	
;;;657    	return writeStatus;
;;;658    
;;;659    #else
;;;660    	BOOL writeStatus = TRUE;
00000a  2401              MOVS     r4,#1
;;;661    	
;;;662    	// 参数判断
;;;663    	if (NULL == pBuffer)
00000c  2d00              CMP      r5,#0
00000e  d007              BEQ      |L14.32|
;;;664    	{
;;;665    		return FALSE;
;;;666    	}
;;;667    
;;;668    	// 参数检验是否非法
;;;669    	if ((writeAddr < IAP_GD32_FLASH_BASE) || (writeAddr >= (IAP_GD32_FLASH_BASE+IAP_GD32_FLASH_SIZE)))
000010  f1a66000          SUB      r0,r6,#0x8000000
000014  f5b02f80          CMP      r0,#0x40000
000018  d304              BCC      |L14.36|
;;;670    	{
;;;671    		return FALSE;	// 非法地址
00001a  2000              MOVS     r0,#0
                  |L14.28|
;;;672    	}
;;;673    	
;;;674    	DI();				// 关闭总中断
;;;675    	fmc_unlock();		// 解锁
;;;676    
;;;677    	// 清除所有挂起标志位
;;;678    	fmc_flag_clear(FMC_FLAG_BANK0_END);
;;;679        fmc_flag_clear(FMC_FLAG_BANK0_WPERR);
;;;680        fmc_flag_clear(FMC_FLAG_BANK0_PGERR);
;;;681    	
;;;682    	// 写入页
;;;683    	if (!IAP_FlashWriteHalfWordArrayAndCheck(writeAddr, pBuffer, numToWrite))	
;;;684    	{
;;;685    		writeStatus = FALSE;
;;;686    	}
;;;687    
;;;688    	fmc_lock();		// 上锁
;;;689    	EI(); 			// 开启总中断
;;;690    	
;;;691    	return writeStatus;
;;;692    
;;;693    #endif
;;;694    }
00001c  e8bd81f0          POP      {r4-r8,pc}
                  |L14.32|
000020  2000              MOVS     r0,#0                 ;665
000022  e7fb              B        |L14.28|
                  |L14.36|
000024  b672              CPSID    i                     ;674
000026  f7fffffe          BL       fmc_unlock
00002a  f2403005          MOV      r0,#0x305             ;678
00002e  f7fffffe          BL       fmc_flag_clear
000032  f44f7041          MOV      r0,#0x304             ;679
000036  f7fffffe          BL       fmc_flag_clear
00003a  f2403002          MOV      r0,#0x302             ;680
00003e  f7fffffe          BL       fmc_flag_clear
000042  463a              MOV      r2,r7                 ;683
000044  4629              MOV      r1,r5                 ;683
000046  4630              MOV      r0,r6                 ;683
000048  f7fffffe          BL       IAP_FlashWriteHalfWordArrayAndCheck
00004c  b900              CBNZ     r0,|L14.80|
00004e  2400              MOVS     r4,#0                 ;685
                  |L14.80|
000050  f7fffffe          BL       fmc_lock
000054  b662              CPSIE    i                     ;689
000056  4620              MOV      r0,r4                 ;691
000058  e7e0              B        |L14.28|
;;;695    
                          ENDP


                          AREA ||i.IAP_FlashWriteHalfWordArrayAndCheck||, CODE, READONLY, ALIGN=1

                  IAP_FlashWriteHalfWordArrayAndCheck PROC
;;;495    *******************************************************************************/
;;;496    BOOL IAP_FlashWriteHalfWordArrayAndCheck(uint32 writeAddr, uint16 *pBuffer, uint16 numToWrite)   
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;497    { 			 		 
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;498    	uint16 i;
;;;499    	uint16 readHalfWord;
;;;500    
;;;501    	// 参数判断
;;;502    	if (NULL == pBuffer)
00000a  2e00              CMP      r6,#0
00000c  d007              BEQ      |L15.30|
;;;503    	{
;;;504    		return FALSE;
;;;505    	}
;;;506    
;;;507    	// 参数检验是否非法
;;;508    	if ((writeAddr < IAP_GD32_FLASH_BASE) || (writeAddr >= (IAP_GD32_FLASH_BASE+IAP_GD32_FLASH_SIZE)))
00000e  f1a56000          SUB      r0,r5,#0x8000000
000012  f5b02f80          CMP      r0,#0x40000
000016  d304              BCC      |L15.34|
;;;509    	{
;;;510    		return FALSE;	// 非法地址
000018  2000              MOVS     r0,#0
                  |L15.26|
;;;511    	}
;;;512    	
;;;513    	for (i = 0; i < numToWrite; i++)
;;;514    	{
;;;515    		fmc_halfword_program(writeAddr, pBuffer[i]);		// 写
;;;516    		readHalfWord = IAP_FlashReadHalfWord(writeAddr);	// 读
;;;517    	  	writeAddr += 2;
;;;518    
;;;519    		fmc_flag_clear(FMC_FLAG_BANK0_END);
;;;520            fmc_flag_clear(FMC_FLAG_BANK0_WPERR);
;;;521            fmc_flag_clear(FMC_FLAG_BANK0_PGERR); 
;;;522    		
;;;523    	  	// 写入FLASH中的缓冲区数据与读取的数据是否匹配
;;;524    		if (readHalfWord == pBuffer[i])
;;;525    		{
;;;526    			continue;
;;;527    		}
;;;528    		else
;;;529    		{
;;;530    			return FALSE;
;;;531    		}
;;;532    	}  
;;;533    	return TRUE;
;;;534    } 
00001a  e8bd9ff0          POP      {r4-r12,pc}
                  |L15.30|
00001e  2000              MOVS     r0,#0                 ;504
000020  e7fb              B        |L15.26|
                  |L15.34|
000022  2400              MOVS     r4,#0                 ;513
000024  f2403805          MOV      r8,#0x305             ;519
000028  f44f7941          MOV      r9,#0x304             ;520
00002c  f2403a02          MOV      r10,#0x302            ;521
000030  e018              B        |L15.100|
                  |L15.50|
000032  f8361014          LDRH     r1,[r6,r4,LSL #1]     ;515
000036  4628              MOV      r0,r5                 ;515
000038  f7fffffe          BL       fmc_halfword_program
00003c  4628              MOV      r0,r5                 ;516
00003e  f7fffffe          BL       IAP_FlashReadHalfWord
000042  4683              MOV      r11,r0                ;516
000044  1cad              ADDS     r5,r5,#2              ;517
000046  4640              MOV      r0,r8                 ;519
000048  f7fffffe          BL       fmc_flag_clear
00004c  4648              MOV      r0,r9                 ;520
00004e  f7fffffe          BL       fmc_flag_clear
000052  4650              MOV      r0,r10                ;521
000054  f7fffffe          BL       fmc_flag_clear
000058  f8360014          LDRH     r0,[r6,r4,LSL #1]     ;524
00005c  4558              CMP      r0,r11                ;524
00005e  d105              BNE      |L15.108|
000060  1c64              ADDS     r4,r4,#1              ;513
000062  b2a4              UXTH     r4,r4                 ;513
                  |L15.100|
000064  42bc              CMP      r4,r7                 ;513
000066  d3e4              BCC      |L15.50|
000068  2001              MOVS     r0,#1                 ;533
00006a  e7d6              B        |L15.26|
                  |L15.108|
00006c  2000              MOVS     r0,#0                 ;530
00006e  e7d4              B        |L15.26|
;;;535    
                          ENDP


                          AREA ||i.IAP_FlashWriteWordArray||, CODE, READONLY, ALIGN=2

                  IAP_FlashWriteWordArray PROC
;;;731    *******************************************************************************/
;;;732    BOOL IAP_FlashWriteWordArray(uint32 writeAddr, uint32 *pBuffer, uint16 numToWrite)	
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;733    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;734    	BOOL writeStatus = TRUE;
00000a  2501              MOVS     r5,#1
;;;735    	
;;;736    	// 参数判断
;;;737    	if (NULL == pBuffer)
00000c  2e00              CMP      r6,#0
00000e  d009              BEQ      |L16.36|
;;;738    	{
;;;739    		return FALSE;
;;;740    	}
;;;741    
;;;742    	// 参数检验是否非法
;;;743    	if ((writeAddr < IAP_GD32_FLASH_BASE) || ((writeAddr + numToWrite) > (IAP_GD32_FLASH_BASE+IAP_GD32_FLASH_SIZE)))
000010  f1b46f00          CMP      r4,#0x8000000
000014  d303              BCC      |L16.30|
000016  4912              LDR      r1,|L16.96|
000018  19e0              ADDS     r0,r4,r7
00001a  4288              CMP      r0,r1
00001c  d904              BLS      |L16.40|
                  |L16.30|
;;;744    	{
;;;745    		return FALSE;	// 非法地址
00001e  2000              MOVS     r0,#0
                  |L16.32|
;;;746    	}
;;;747    	
;;;748    	DI();				// 关闭总中断
;;;749    	fmc_unlock();		// 解锁
;;;750    
;;;751    	// 清除所有挂起标志位
;;;752    	fmc_flag_clear(FMC_FLAG_BANK0_END);
;;;753        fmc_flag_clear(FMC_FLAG_BANK0_WPERR);
;;;754        fmc_flag_clear(FMC_FLAG_BANK0_PGERR);
;;;755    
;;;756    
;;;757    	// 写入页
;;;758    	if (!IAP_FlashWriteWordArrayAndCheck(writeAddr, pBuffer, numToWrite))	
;;;759    	{
;;;760    		writeStatus = FALSE;
;;;761    	}
;;;762    
;;;763    	fmc_lock();			// 上锁
;;;764    	EI(); 				// 开启总中断
;;;765    	
;;;766    	return writeStatus;
;;;767    }
000020  e8bd81f0          POP      {r4-r8,pc}
                  |L16.36|
000024  2000              MOVS     r0,#0                 ;739
000026  e7fb              B        |L16.32|
                  |L16.40|
000028  b672              CPSID    i                     ;748
00002a  f7fffffe          BL       fmc_unlock
00002e  f2403005          MOV      r0,#0x305             ;752
000032  f7fffffe          BL       fmc_flag_clear
000036  f44f7041          MOV      r0,#0x304             ;753
00003a  f7fffffe          BL       fmc_flag_clear
00003e  f2403002          MOV      r0,#0x302             ;754
000042  f7fffffe          BL       fmc_flag_clear
000046  463a              MOV      r2,r7                 ;758
000048  4631              MOV      r1,r6                 ;758
00004a  4620              MOV      r0,r4                 ;758
00004c  f7fffffe          BL       IAP_FlashWriteWordArrayAndCheck
000050  b900              CBNZ     r0,|L16.84|
000052  2500              MOVS     r5,#0                 ;760
                  |L16.84|
000054  f7fffffe          BL       fmc_lock
000058  b662              CPSIE    i                     ;764
00005a  4628              MOV      r0,r5                 ;766
00005c  e7e0              B        |L16.32|
;;;768    
                          ENDP

00005e  0000              DCW      0x0000
                  |L16.96|
                          DCD      0x08040000

                          AREA ||i.IAP_FlashWriteWordArrayAndCheck||, CODE, READONLY, ALIGN=2

                  IAP_FlashWriteWordArrayAndCheck PROC
;;;775    *******************************************************************************/
;;;776    BOOL IAP_FlashWriteWordArrayAndCheck(uint32 writeAddr, uint32 *pBuffer, uint16 numToWrite)   
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;777    { 			 		 
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;778    	uint16 i;
;;;779    	uint32 readWord;
;;;780    
;;;781    	// 参数判断
;;;782    	if (NULL == pBuffer)
00000a  2e00              CMP      r6,#0
00000c  d009              BEQ      |L17.34|
;;;783    	{
;;;784    		return FALSE;
;;;785    	}
;;;786    
;;;787    	// 参数检验是否非法
;;;788    	if ((writeAddr < IAP_GD32_FLASH_BASE) || ((writeAddr + numToWrite) > (IAP_GD32_FLASH_BASE+IAP_GD32_FLASH_SIZE+1024UL)))
00000e  f1b56f00          CMP      r5,#0x8000000
000012  d303              BCC      |L17.28|
000014  4917              LDR      r1,|L17.116|
000016  19e8              ADDS     r0,r5,r7
000018  4288              CMP      r0,r1
00001a  d904              BLS      |L17.38|
                  |L17.28|
;;;789    	{
;;;790    		return FALSE;	// 非法地址
00001c  2000              MOVS     r0,#0
                  |L17.30|
;;;791    	}
;;;792    	
;;;793    	for (i = 0; i < numToWrite; i++)
;;;794    	{
;;;795    		fmc_word_program(writeAddr, pBuffer[i]);		// 写
;;;796    		readWord = IAP_FlashReadWord(writeAddr);		// 读
;;;797    	  	writeAddr += 4;
;;;798    
;;;799    		fmc_flag_clear(FMC_FLAG_BANK0_END);
;;;800            fmc_flag_clear(FMC_FLAG_BANK0_WPERR);
;;;801            fmc_flag_clear(FMC_FLAG_BANK0_PGERR); 
;;;802    
;;;803    	  	// 写入FLASH中的缓冲区数据与读取的数据是否匹配
;;;804    		if (readWord == pBuffer[i])
;;;805    		{
;;;806    			continue;
;;;807    		}
;;;808    		else
;;;809    		{
;;;810    			return FALSE;
;;;811    		}
;;;812    	}  
;;;813    	return TRUE;
;;;814    } 
00001e  e8bd9ff0          POP      {r4-r12,pc}
                  |L17.34|
000022  2000              MOVS     r0,#0                 ;784
000024  e7fb              B        |L17.30|
                  |L17.38|
000026  2400              MOVS     r4,#0                 ;793
000028  f2403805          MOV      r8,#0x305             ;799
00002c  f44f7941          MOV      r9,#0x304             ;800
000030  f2403a02          MOV      r10,#0x302            ;801
000034  e018              B        |L17.104|
                  |L17.54|
000036  f8561024          LDR      r1,[r6,r4,LSL #2]     ;795
00003a  4628              MOV      r0,r5                 ;795
00003c  f7fffffe          BL       fmc_word_program
000040  4628              MOV      r0,r5                 ;796
000042  f7fffffe          BL       IAP_FlashReadWord
000046  4683              MOV      r11,r0                ;796
000048  1d2d              ADDS     r5,r5,#4              ;797
00004a  4640              MOV      r0,r8                 ;799
00004c  f7fffffe          BL       fmc_flag_clear
000050  4648              MOV      r0,r9                 ;800
000052  f7fffffe          BL       fmc_flag_clear
000056  4650              MOV      r0,r10                ;801
000058  f7fffffe          BL       fmc_flag_clear
00005c  f8560024          LDR      r0,[r6,r4,LSL #2]     ;804
000060  4558              CMP      r0,r11                ;804
000062  d105              BNE      |L17.112|
000064  1c64              ADDS     r4,r4,#1              ;793
000066  b2a4              UXTH     r4,r4                 ;793
                  |L17.104|
000068  42bc              CMP      r4,r7                 ;793
00006a  d3e4              BCC      |L17.54|
00006c  2001              MOVS     r0,#1                 ;813
00006e  e7d6              B        |L17.30|
                  |L17.112|
000070  2000              MOVS     r0,#0                 ;810
000072  e7d4              B        |L17.30|
;;;815    
                          ENDP

                  |L17.116|
                          DCD      0x08040400

                          AREA ||i.IAP_FlashWriteWordArrayWithErase||, CODE, READONLY, ALIGN=2

                  IAP_FlashWriteWordArrayWithErase PROC
;;;861    *******************************************************************************/
;;;862    BOOL IAP_FlashWriteWordArrayWithErase(uint32 writeAddr, uint32 *pBuffer, uint16 NumWordToWrite)	
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;863    {
000004  4682              MOV      r10,r0
000006  4689              MOV      r9,r1
;;;864    	BOOL writeStatus = TRUE;
000008  2001              MOVS     r0,#1
00000a  9000              STR      r0,[sp,#0]
;;;865    	uint32 pagePos = 0;						// 扇区地址
;;;866    	uint16 pageOffsent = 0;					// 在扇区内的偏移
;;;867    	uint16 pageRemain = 0;  				// 扇区剩余空间大小 
;;;868    	uint32 offaddr;    						// 去掉0X08000000后的地址
;;;869     	uint16 i = 0;
;;;870     	uint32 * pFlashBuff = NULL;				// 保存读取扇区的数据
;;;871     	uint16 numByteToWrite = NumWordToWrite * 4;
00000c  f64f70ff          MOV      r0,#0xffff
000010  ea000582          AND      r5,r0,r2,LSL #2
;;;872    	
;;;873    	// 参数判断
;;;874    	if (NULL == pBuffer|| (NULL == numByteToWrite))
000014  f1b90f00          CMP      r9,#0
000018  d00b              BEQ      |L18.50|
00001a  b155              CBZ      r5,|L18.50|
;;;875    	{
;;;876    		return FALSE;
;;;877    	}
;;;878    
;;;879    	// 参数检验是否非法
;;;880    	if ((writeAddr < IAP_GD32_FLASH_BASE) || ((writeAddr + numByteToWrite) > (IAP_GD32_FLASH_BASE+IAP_GD32_FLASH_SIZE + 1024UL)))
00001c  f1ba6f00          CMP      r10,#0x8000000
000020  d304              BCC      |L18.44|
000022  4947              LDR      r1,|L18.320|
000024  eb0a0005          ADD      r0,r10,r5
000028  4288              CMP      r0,r1
00002a  d904              BLS      |L18.54|
                  |L18.44|
;;;881    	{
;;;882    		return FALSE;	// 非法地址
00002c  2000              MOVS     r0,#0
                  |L18.46|
;;;883    	}
;;;884    
;;;885    	// 申请1024Byte空间保存页数据
;;;886    	pFlashBuff = (uint32 *)malloc(IAP_STM32_PAGE_SIZE);
;;;887    	if (NULL == pFlashBuff)
;;;888    	{
;;;889    		return FALSE;
;;;890    	}
;;;891    
;;;892    	offaddr = writeAddr - IAP_GD32_FLASH_BASE;		// 实际偏移地址
;;;893    	pagePos = offaddr / IAP_STM32_PAGE_SIZE;		// 页地址
;;;894    	pageOffsent = offaddr % IAP_STM32_PAGE_SIZE;	// 在页内偏移
;;;895    	pageRemain = IAP_STM32_PAGE_SIZE - pageOffsent;	// 页剩余空间大小
;;;896    
;;;897    	if (numByteToWrite <= pageRemain)
;;;898    	{
;;;899    		pageRemain = numByteToWrite;				// 不大于该页范围
;;;900    	}
;;;901    	
;;;902    	DI();				// 关闭总中断
;;;903    	fmc_unlock();		// 解锁
;;;904    
;;;905    	// 清除所有挂起标志位
;;;906    	fmc_flag_clear(FMC_FLAG_BANK0_END);
;;;907        fmc_flag_clear(FMC_FLAG_BANK0_WPERR);
;;;908        fmc_flag_clear(FMC_FLAG_BANK0_PGERR);
;;;909    
;;;910    	
;;;911    	while(1)
;;;912    	{
;;;913    		// 读出整个页的内容
;;;914    		IAP_FlashReadWordArray(pagePos*IAP_STM32_PAGE_SIZE+IAP_STM32_PAGE_SIZE, pFlashBuff, IAP_STM32_PAGE_SIZE/4);
;;;915    
;;;916    		for (i = 0; i < pageRemain/4; i++)	// 校验数据
;;;917    		{
;;;918    			if (pFlashBuff[pageOffsent/4 + i] != 0xFFFFFFFF)
;;;919    			{
;;;920    				// 里面的数据不全是0xFFFFFFFF，说明需要擦除
;;;921    				break;
;;;922    			}
;;;923    		}
;;;924    
;;;925    		if (i < pageRemain/4)					// 需要擦除
;;;926    		{
;;;927    			// 擦除这个页
;;;928    			//IAP_PageErase(pagePos * IAP_STM32_PAGE_SIZE + IAP_GD32_FLASH_BASE);
;;;929    			fmc_page_erase(pagePos * IAP_STM32_PAGE_SIZE + IAP_GD32_FLASH_BASE);
;;;930    
;;;931    			// 复制
;;;932    			for (i = 0; i < pageRemain/4; i++)
;;;933    			{
;;;934    				pFlashBuff[i + pageOffsent/4] = pBuffer[i]; 
;;;935    			}
;;;936    
;;;937    			// 写入整页
;;;938    			if (!IAP_FlashWriteWordArrayAndCheck(pagePos * IAP_STM32_PAGE_SIZE + IAP_GD32_FLASH_BASE, pFlashBuff, IAP_STM32_PAGE_SIZE/4))	
;;;939    			{
;;;940    				// 释放数据缓存区
;;;941    				free(pFlashBuff);
;;;942    
;;;943    				fmc_lock();			// 上锁
;;;944    				EI();				// 开启总中断
;;;945    				writeStatus = FALSE;
;;;946    				return writeStatus;
;;;947    			}
;;;948    		}
;;;949    		else 
;;;950    		{
;;;951    			// 写已经擦除了的,直接写入扇区剩余区间.
;;;952    			if (!IAP_FlashWriteWordArrayAndCheck(writeAddr, pBuffer, pageRemain/4))	
;;;953    			{
;;;954    				// 释放数据缓存区
;;;955    				free(pFlashBuff);
;;;956    
;;;957    				fmc_lock();			// 上锁
;;;958    				EI(); 				// 开启总中断
;;;959    				writeStatus = FALSE;
;;;960    				return writeStatus;
;;;961    			}
;;;962    		}
;;;963    		
;;;964    		if (numByteToWrite == pageRemain)
;;;965    		{
;;;966    			break;									// 写入结束了
;;;967    		}
;;;968    		else										// 写入未结束
;;;969    		{
;;;970    			pagePos++;								// 扇区地址增1
;;;971    			pageOffsent = 0;						// 偏移位置为0 	 
;;;972    
;;;973    		   	pBuffer += (pageRemain/4);  			// 指针偏移
;;;974    			writeAddr += pageRemain;				// 写地址偏移	   
;;;975    		   	numByteToWrite -= pageRemain;			// 字节数递减
;;;976    		   	
;;;977    			if (numByteToWrite > IAP_STM32_PAGE_SIZE)
;;;978    			{
;;;979    				pageRemain = IAP_STM32_PAGE_SIZE;	// 下一个扇区还是写不完
;;;980    			}
;;;981    			else
;;;982    			{
;;;983    				pageRemain = numByteToWrite;		// 下一个扇区可以写完了	
;;;984    			}
;;;985    		}	
;;;986    		
;;;987    	}
;;;988    
;;;989    	// 释放数据缓存区
;;;990    	free(pFlashBuff);	
;;;991    	fmc_lock();			// 上锁
;;;992    	EI(); 				// 开启总中断
;;;993    	return writeStatus;
;;;994    }
00002e  e8bd8ff8          POP      {r3-r11,pc}
                  |L18.50|
000032  2000              MOVS     r0,#0                 ;876
000034  e7fb              B        |L18.46|
                  |L18.54|
000036  f44f6000          MOV      r0,#0x800             ;886
00003a  f7fffffe          BL       malloc
00003e  4680              MOV      r8,r0                 ;886
000040  ea5f0008          MOVS     r0,r8                 ;887
000044  d023              BEQ      |L18.142|
000046  f1aa6000          SUB      r0,r10,#0x8000000     ;892
00004a  0ac7              LSRS     r7,r0,#11             ;893
00004c  f3c0060a          UBFX     r6,r0,#0,#11          ;894
000050  f5c66400          RSB      r4,r6,#0x800          ;895
000054  42a5              CMP      r5,r4                 ;897
000056  d800              BHI      |L18.90|
000058  462c              MOV      r4,r5                 ;899
                  |L18.90|
00005a  b672              CPSID    i                     ;902
00005c  f7fffffe          BL       fmc_unlock
000060  f2403005          MOV      r0,#0x305             ;906
000064  f7fffffe          BL       fmc_flag_clear
000068  f44f7041          MOV      r0,#0x304             ;907
00006c  f7fffffe          BL       fmc_flag_clear
000070  f2403002          MOV      r0,#0x302             ;908
000074  f7fffffe          BL       fmc_flag_clear
                  |L18.120|
000078  f44f6000          MOV      r0,#0x800             ;914
00007c  eb0020c7          ADD      r0,r0,r7,LSL #11      ;914
000080  f44f7200          MOV      r2,#0x200             ;914
000084  4641              MOV      r1,r8                 ;914
000086  f7fffffe          BL       IAP_FlashReadWordArray
00008a  2000              MOVS     r0,#0                 ;916
00008c  e009              B        |L18.162|
                  |L18.142|
00008e  2000              MOVS     r0,#0                 ;889
000090  e7cd              B        |L18.46|
                  |L18.146|
000092  eb000196          ADD      r1,r0,r6,LSR #2       ;918
000096  f8581021          LDR      r1,[r8,r1,LSL #2]     ;918
00009a  1c49              ADDS     r1,r1,#1              ;918
00009c  d104              BNE      |L18.168|
00009e  1c40              ADDS     r0,r0,#1              ;916
0000a0  b280              UXTH     r0,r0                 ;916
                  |L18.162|
0000a2  ebb00f94          CMP      r0,r4,LSR #2          ;916
0000a6  d3f4              BCC      |L18.146|
                  |L18.168|
0000a8  ebb00f94          CMP      r0,r4,LSR #2          ;925
0000ac  d222              BCS      |L18.244|
0000ae  f04f6000          MOV      r0,#0x8000000         ;929
0000b2  eb002bc7          ADD      r11,r0,r7,LSL #11     ;929
0000b6  4658              MOV      r0,r11                ;929
0000b8  f7fffffe          BL       fmc_page_erase
0000bc  2000              MOVS     r0,#0                 ;932
0000be  e007              B        |L18.208|
                  |L18.192|
0000c0  eb000296          ADD      r2,r0,r6,LSR #2       ;934
0000c4  f8591020          LDR      r1,[r9,r0,LSL #2]     ;934
0000c8  f8481022          STR      r1,[r8,r2,LSL #2]     ;934
0000cc  1c40              ADDS     r0,r0,#1              ;932
0000ce  b280              UXTH     r0,r0                 ;932
                  |L18.208|
0000d0  ebb00f94          CMP      r0,r4,LSR #2          ;932
0000d4  d3f4              BCC      |L18.192|
0000d6  4658              MOV      r0,r11                ;938
0000d8  f44f7200          MOV      r2,#0x200             ;938
0000dc  4641              MOV      r1,r8                 ;938
0000de  f7fffffe          BL       IAP_FlashWriteWordArrayAndCheck
0000e2  b968              CBNZ     r0,|L18.256|
0000e4  4640              MOV      r0,r8                 ;941
0000e6  f7fffffe          BL       free
0000ea  f7fffffe          BL       fmc_lock
0000ee  b662              CPSIE    i                     ;944
0000f0  2000              MOVS     r0,#0                 ;945
0000f2  e79c              B        |L18.46|
                  |L18.244|
0000f4  08a2              LSRS     r2,r4,#2              ;952
0000f6  4649              MOV      r1,r9                 ;952
0000f8  4650              MOV      r0,r10                ;952
0000fa  f7fffffe          BL       IAP_FlashWriteWordArrayAndCheck
0000fe  b148              CBZ      r0,|L18.276|
                  |L18.256|
000100  42a5              CMP      r5,r4                 ;964
000102  d10f              BNE      |L18.292|
000104  4640              MOV      r0,r8                 ;990
000106  f7fffffe          BL       free
00010a  f7fffffe          BL       fmc_lock
00010e  b662              CPSIE    i                     ;992
000110  9800              LDR      r0,[sp,#0]            ;966
000112  e78c              B        |L18.46|
                  |L18.276|
000114  4640              MOV      r0,r8                 ;955
000116  f7fffffe          BL       free
00011a  f7fffffe          BL       fmc_lock
00011e  b662              CPSIE    i                     ;958
000120  2000              MOVS     r0,#0                 ;959
000122  e784              B        |L18.46|
                  |L18.292|
000124  1c7f              ADDS     r7,r7,#1              ;970
000126  2600              MOVS     r6,#0                 ;971
000128  f0240003          BIC      r0,r4,#3              ;973
00012c  4481              ADD      r9,r9,r0              ;973
00012e  44a2              ADD      r10,r10,r4            ;974
000130  1b28              SUBS     r0,r5,r4              ;975
000132  b285              UXTH     r5,r0                 ;975
000134  f44f6400          MOV      r4,#0x800             ;977
000138  42a5              CMP      r5,r4                 ;977
00013a  d89d              BHI      |L18.120|
00013c  462c              MOV      r4,r5                 ;983
00013e  e79b              B        |L18.120|
;;;995    
                          ENDP

                  |L18.320|
                          DCD      0x08040400

                          AREA ||i.IAP_Init||, CODE, READONLY, ALIGN=2

                  IAP_Init PROC
;;;139    *******************************************************************************/
;;;140    void IAP_Init(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;141    {		
;;;142    	iapCB.mcuUID.sn0 = *(uint32*)(0x1FFFF7E8); 
000002  480e              LDR      r0,|L19.60|
000004  6801              LDR      r1,[r0,#0]
000006  480e              LDR      r0,|L19.64|
000008  6041              STR      r1,[r0,#4]  ; iapCB
;;;143    	iapCB.mcuUID.sn1 = *(uint32*)(0x1FFFF7EC); 
00000a  490c              LDR      r1,|L19.60|
00000c  1d09              ADDS     r1,r1,#4
00000e  6809              LDR      r1,[r1,#0]
000010  6081              STR      r1,[r0,#8]  ; iapCB
;;;144    	iapCB.mcuUID.sn2 = *(uint32*)(0x1FFFF7F0);
000012  490a              LDR      r1,|L19.60|
000014  3108              ADDS     r1,r1,#8
000016  6809              LDR      r1,[r1,#0]
000018  60c1              STR      r1,[r0,#0xc]  ; iapCB
;;;145    	
;;;146    	// 设置中断向量起始位置
;;;147    	nvic_vector_table_set(NVIC_VECTTAB_FLASH,0x0000);
00001a  2100              MOVS     r1,#0
00001c  f04f6000          MOV      r0,#0x8000000
000020  f7fffffe          BL       nvic_vector_table_set
;;;148    	
;;;149    	TIMER_AddTask(TIMER_ID_IAP_ECO_REQUEST,
000024  2001              MOVS     r0,#1
000026  2103              MOVS     r1,#3
000028  e9cd1000          STRD     r1,r0,[sp,#0]
00002c  4603              MOV      r3,r0
00002e  4a05              LDR      r2,|L19.68|
000030  2132              MOVS     r1,#0x32
000032  2002              MOVS     r0,#2
000034  f7fffffe          BL       TIMER_AddTask
;;;150    					50,
;;;151    					IAP_CTRL_UART_SendCmdProjectApply,
;;;152    					IAP_CTRL_UART_CMD_UP_PROJECT_APPLY,
;;;153    					3,
;;;154    					ACTION_MODE_ADD_TO_QUEUE);
;;;155    		
;;;156    }
000038  bd1c              POP      {r2-r4,pc}
;;;157    
                          ENDP

00003a  0000              DCW      0x0000
                  |L19.60|
                          DCD      0x1ffff7e8
                  |L19.64|
                          DCD      ||.bss||
                  |L19.68|
                          DCD      IAP_CTRL_UART_SendCmdProjectApply

                          AREA ||i.IAP_JumpToAppFun||, CODE, READONLY, ALIGN=2

                  IAP_JumpToAppFun PROC
;;;96     // 窗口时间到跳转到APP代码区运行
;;;97     void IAP_JumpToAppFun(uint32 param)
000000  4a07              LDR      r2,|L20.32|
;;;98     {
;;;99     	// 检查栈顶地址是否合法.
;;;100    	if(((*(uint32*)param) & 0x2FFE0000) != 0x20000000)	
000002  6801              LDR      r1,[r0,#0]
000004  4011              ANDS     r1,r1,r2
000006  f1b15f00          CMP      r1,#0x20000000
00000a  d107              BNE      |L20.28|
;;;101    	{
;;;102    		return;
;;;103    	}
;;;104    
;;;105    	// APP无效
;;;106    	if (((*(uint32*)(param+4)) & 0xFFF80000) != 0x08000000)
00000c  6841              LDR      r1,[r0,#4]
00000e  f44f7280          MOV      r2,#0x100
000012  ebb24fd1          CMP      r2,r1,LSR #19
000016  d101              BNE      |L20.28|
;;;107    	{
;;;108    		return;
;;;109    	}
;;;110    	
;;;111    	// 执行APP程序
;;;112    	IAP_RunAPP(param);
000018  f7ffbffe          B.W      IAP_RunAPP
                  |L20.28|
;;;113    }
00001c  4770              BX       lr
;;;114    
                          ENDP

00001e  0000              DCW      0x0000
                  |L20.32|
                          DCD      0x2ffe0000

                          AREA ||i.IAP_RunAPP||, CODE, READONLY, ALIGN=2

                  IAP_RunAPP PROC
;;;65     *******************************************************************************/
;;;66     void IAP_RunAPP(uint32 appAddr)
000000  b430              PUSH     {r4,r5}
;;;67     {
;;;68         // appAddr存放的是用户程序Flash的首地址，(*(vu32*)appAddr的意思是取用户程序首地址里面的数据，该数据是用户程序的堆栈地址
;;;69         // 堆栈地址指向RAM,而RAM的起始地址是0x20000000,因此上面的判断语句执行:判断用户代码的堆栈地址是否落在:0x20000000~0x2001ffff区间中，
;;;70         // 这个区间的大小较多落在<128K RAM的区间，因此需要进行下面的判断
;;;71     
;;;72     	//定义一个函数类型的参数	
;;;73     	typedef void (*IAP_Func)(void);
;;;74     	IAP_Func jumpToApp;
;;;75     
;;;76     	if(((*(uint32*)appAddr) & 0x2FFE0000) == 0x20000000)	// 检查栈顶地址是否合法.
000002  4a10              LDR      r2,|L21.68|
000004  6801              LDR      r1,[r0,#0]
000006  4011              ANDS     r1,r1,r2
000008  f1b15f00          CMP      r1,#0x20000000
00000c  d118              BNE      |L21.64|
;;;77     	{ 
;;;78     		if (((*(uint32*)(appAddr+4)) & 0xFFF80000) != 0x08000000)   // APP无效
00000e  6841              LDR      r1,[r0,#4]
000010  f44f7280          MOV      r2,#0x100
000014  ebb24fd1          CMP      r2,r1,LSR #19
000018  d112              BNE      |L21.64|
;;;79     		{
;;;80     			return;
;;;81     		}
;;;82     
;;;83     		// 跳转之前关总中断，复位外设为默认值
;;;84     		DI();
00001a  b672              CPSID    i
;;;85     		RCU_APB2RST |= 0xFFFFFFFF;
00001c  490a              LDR      r1,|L21.72|
00001e  68ca              LDR      r2,[r1,#0xc]
000020  f04f32ff          MOV      r2,#0xffffffff
000024  60ca              STR      r2,[r1,#0xc]
;;;86     		RCU_APB2RST &= ~0xFFFFFFFF;
000026  68cb              LDR      r3,[r1,#0xc]
000028  2300              MOVS     r3,#0
00002a  60cb              STR      r3,[r1,#0xc]
;;;87     		RCU_APB1RST |= 0xFFFFFFFF;
00002c  690c              LDR      r4,[r1,#0x10]
00002e  610a              STR      r2,[r1,#0x10]
;;;88     		RCU_APB1RST &= ~0xFFFFFFFF;
000030  690a              LDR      r2,[r1,#0x10]
000032  610b              STR      r3,[r1,#0x10]
;;;89     		
;;;90     		jumpToApp = (IAP_Func)*(uint32*)(appAddr+4);		// 用户代码区第二个字为程序开始地址(复位地址)		
000034  6841              LDR      r1,[r0,#4]
;;;91     	  	__set_MSP(*(uint32*)appAddr);						// 初始化用户程序的堆栈指针
000036  6800              LDR      r0,[r0,#0]
000038  f3808808          MSR      MSP,r0
;;;92     		jumpToApp();										// 跳转到用户程序APP
00003c  bc30              POP      {r4,r5}
00003e  4708              BX       r1
                  |L21.64|
;;;93     	}
;;;94     }
000040  bc30              POP      {r4,r5}
000042  4770              BX       lr
;;;95     
                          ENDP

                  |L21.68|
                          DCD      0x2ffe0000
                  |L21.72|
                          DCD      0x40021000

                          AREA ||i.IAP_WriteAppBin||, CODE, READONLY, ALIGN=2

                  IAP_WriteAppBin PROC
;;;163    *******************************************************************************/
;;;164    BOOL IAP_WriteAppBin(uint32 appAddr, uint8 *appBuf, uint32 appSize)
000000  b5f0              PUSH     {r4-r7,lr}
;;;165    {
000002  f6ad0d04          SUB      sp,sp,#0x804
;;;166    	uint16 i = 0;
000006  2400              MOVS     r4,#0
;;;167    	uint16 j = 0;
000008  2300              MOVS     r3,#0
;;;168    	uint32 curAppAddr = appAddr; 	// 当前写入的地址
;;;169    	uint16 iapBuf[SPI_FLASH_APP_READ_UPDATA_SIZE];			// 此16位数据需要和串口通讯协议一帧最长字节有关126*2=252个字节
;;;170    	BOOL writeStatus;
;;;171    	
;;;172    	// 参数判断
;;;173    	if (NULL == appBuf)
00000a  2900              CMP      r1,#0
00000c  d008              BEQ      |L22.32|
;;;174    	{
;;;175    		return FALSE;
;;;176    	}
;;;177    
;;;178    	// 参数检验是否非法，地址不能是IAP本身代码地址，绝对不能自己把自己擦掉
;;;179    	if ((appAddr < IAP_FLASH_APP1_ADDR) || (appAddr >= (IAP_GD32_FLASH_BASE+IAP_GD32_FLASH_SIZE)))
00000e  4e10              LDR      r6,|L22.80|
000010  1985              ADDS     r5,r0,r6
000012  f5b53f60          CMP      r5,#0x38000
000016  d305              BCC      |L22.36|
;;;180    	{
;;;181    		return FALSE;	// 非法地址
000018  2000              MOVS     r0,#0
                  |L22.26|
;;;182    	}
;;;183    	
;;;184    	// 循环写入
;;;185    	for (j = 0; j < appSize; j += 2)
;;;186    	{
;;;187    		// 字节整合
;;;188    		iapBuf[i++] = (uint16)(*appBuf) + ((uint16)(*(appBuf+1)) << 8);
;;;189    		// 偏移2个字节
;;;190    		appBuf += 2;
;;;191    	}
;;;192    
;;;193    	// 直接写入FLASH
;;;194    	writeStatus = IAP_FlashWriteHalfWordArray(curAppAddr, iapBuf, appSize/2);	
;;;195    
;;;196    	return writeStatus;
;;;197    }
00001a  f60d0d04          ADD      sp,sp,#0x804
00001e  bdf0              POP      {r4-r7,pc}
                  |L22.32|
000020  2000              MOVS     r0,#0                 ;175
000022  e7fa              B        |L22.26|
                  |L22.36|
000024  af01              ADD      r7,sp,#4              ;169
000026  e00b              B        |L22.64|
                  |L22.40|
000028  780d              LDRB     r5,[r1,#0]            ;188
00002a  784e              LDRB     r6,[r1,#1]            ;188
00002c  eb052506          ADD      r5,r5,r6,LSL #8       ;188
000030  4626              MOV      r6,r4                 ;188
000032  1c64              ADDS     r4,r4,#1              ;188
000034  b2a4              UXTH     r4,r4                 ;188
000036  f8275016          STRH     r5,[r7,r6,LSL #1]     ;188
00003a  1c89              ADDS     r1,r1,#2              ;190
00003c  1c9b              ADDS     r3,r3,#2              ;185
00003e  b29b              UXTH     r3,r3                 ;185
                  |L22.64|
000040  4293              CMP      r3,r2                 ;185
000042  d3f1              BCC      |L22.40|
000044  f3c2024f          UBFX     r2,r2,#1,#16          ;194
000048  a901              ADD      r1,sp,#4              ;194
00004a  f7fffffe          BL       IAP_FlashWriteHalfWordArray
00004e  e7e4              B        |L22.26|
;;;198    
                          ENDP

                  |L22.80|
                          DCD      0xf7ff8000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  iapCB
                          %        16

;*** Start embedded assembler ***

#line 1 "User\\iap.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_iap_c_c37294e4____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___5_iap_c_c37294e4____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_iap_c_c37294e4____REVSH|
#line 128
|__asm___5_iap_c_c37294e4____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
