; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\e2prom.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\e2prom.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -IC:\Users\Administrator\AppData\Local\Arm\Packs\GigaDevice\GD32F10x_DFP\2.0.1\Device\Include -D__MICROLIB -D__UVISION_VERSION=534 -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\e2prom.crf User\e2prom.c]
                          THUMB

                          AREA ||i.E2PROM_Delayms||, CODE, READONLY, ALIGN=1

                  E2PROM_Delayms PROC
;;;115    // 简单延时
;;;116    void E2PROM_Delayms(volatile uint8 i)
000000  b531              PUSH     {r0,r4,r5,lr}
;;;117    {
000002  b082              SUB      sp,sp,#8
;;;118    	volatile uint16 x;
;;;119    	volatile uint8 y;
;;;120    
;;;121    	while (i--)
;;;122    	{
;;;123    		x = 700; 
000004  f44f752f          MOV      r5,#0x2bc
;;;124    		while (x--)
;;;125    		{
;;;126    			y = 10;
000008  240a              MOVS     r4,#0xa
00000a  e010              B        |L1.46|
                  |L1.12|
00000c  9501              STR      r5,[sp,#4]            ;123
00000e  e007              B        |L1.32|
                  |L1.16|
000010  9400              STR      r4,[sp,#0]
;;;127    			while (y--)
000012  e000              B        |L1.22|
                  |L1.20|
;;;128    			{
;;;129    				NOP(); 
000014  bf00              NOP      
                  |L1.22|
000016  f89d0000          LDRB     r0,[sp,#0]            ;127
00001a  1e41              SUBS     r1,r0,#1              ;127
00001c  9100              STR      r1,[sp,#0]            ;127
00001e  d2f9              BCS      |L1.20|
                  |L1.32|
000020  f8bd0004          LDRH     r0,[sp,#4]            ;124
000024  1e41              SUBS     r1,r0,#1              ;124
000026  9101              STR      r1,[sp,#4]            ;124
000028  d2f2              BCS      |L1.16|
;;;130    			} 
;;;131    		}
;;;132    
;;;133    		// 看门狗处理
;;;134    		WDT_Clear();
00002a  f7fffffe          BL       WDT_Clear
                  |L1.46|
00002e  f89d0008          LDRB     r0,[sp,#8]            ;121
000032  1e41              SUBS     r1,r0,#1              ;121
000034  9102              STR      r1,[sp,#8]            ;121
000036  d2e9              BCS      |L1.12|
;;;135    	}
;;;136    }
000038  bd3e              POP      {r1-r5,pc}
;;;137    
                          ENDP


                          AREA ||i.E2PROM_Delayus||, CODE, READONLY, ALIGN=1

                  E2PROM_Delayus PROC
;;;70     // 简单延时
;;;71     void E2PROM_Delayus(volatile uint8 i)
000000  b501              PUSH     {r0,lr}
;;;72     {	 
;;;73     	// 内核72MHz，1us
;;;74     	while (i--) 
;;;75     	{
;;;76     		NOP();
;;;77     		NOP();
;;;78     		NOP();
;;;79     		NOP();
;;;80     		NOP();
;;;81     		NOP();
;;;82     		NOP();
;;;83     		NOP();
;;;84     		NOP();
;;;85     		NOP();	// 10
;;;86     		NOP();
;;;87     		NOP();
;;;88     		NOP();
;;;89     		NOP();
;;;90     		NOP();
;;;91     		NOP();
;;;92     		NOP();
;;;93     		NOP();
;;;94     		NOP();
;;;95     		NOP();	// 10
;;;96     		NOP();
;;;97     		NOP();
;;;98     		NOP();
;;;99     		NOP();
;;;100    		NOP();
;;;101    		NOP();
;;;102    		NOP();
;;;103    		NOP();
;;;104    		NOP();
;;;105    		NOP();	// 10
;;;106    		NOP();
;;;107    		NOP();
;;;108    		NOP();
;;;109    		NOP();
;;;110    		NOP();
;;;111    		NOP();	// 6
000002  e023              B        |L2.76|
                  |L2.4|
000004  bf00              NOP                            ;76
000006  bf00              NOP                            ;77
000008  bf00              NOP                            ;78
00000a  bf00              NOP                            ;79
00000c  bf00              NOP                            ;80
00000e  bf00              NOP                            ;81
000010  bf00              NOP                            ;82
000012  bf00              NOP                            ;83
000014  bf00              NOP                            ;84
000016  bf00              NOP                            ;85
000018  bf00              NOP                            ;86
00001a  bf00              NOP                            ;87
00001c  bf00              NOP                            ;88
00001e  bf00              NOP                            ;89
000020  bf00              NOP                            ;90
000022  bf00              NOP                            ;91
000024  bf00              NOP                            ;92
000026  bf00              NOP                            ;93
000028  bf00              NOP                            ;94
00002a  bf00              NOP                            ;95
00002c  bf00              NOP                            ;96
00002e  bf00              NOP                            ;97
000030  bf00              NOP                            ;98
000032  bf00              NOP                            ;99
000034  bf00              NOP                            ;100
000036  bf00              NOP                            ;101
000038  bf00              NOP                            ;102
00003a  bf00              NOP                            ;103
00003c  bf00              NOP                            ;104
00003e  bf00              NOP                            ;105
000040  bf00              NOP                            ;106
000042  bf00              NOP                            ;107
000044  bf00              NOP                            ;108
000046  bf00              NOP                            ;109
000048  bf00              NOP                            ;110
00004a  bf00              NOP      
                  |L2.76|
00004c  f89d0000          LDRB     r0,[sp,#0]            ;74
000050  1e41              SUBS     r1,r0,#1              ;74
000052  9100              STR      r1,[sp,#0]            ;74
000054  d2d6              BCS      |L2.4|
;;;112    	}
;;;113    }
000056  bd08              POP      {r3,pc}
;;;114    
                          ENDP


                          AREA ||i.E2PROM_I2C_Init||, CODE, READONLY, ALIGN=2

                  E2PROM_I2C_Init PROC
;;;140    // I2C初始化
;;;141    void E2PROM_I2C_Init(void)
000000  b510              PUSH     {r4,lr}
;;;142    {
;;;143    	// 打开时钟
;;;144    	rcu_periph_clock_enable(RCU_GPIOC);
000002  f2406004          MOV      r0,#0x604
000006  f7fffffe          BL       rcu_periph_clock_enable
;;;145    	gpio_init(GPIOC, GPIO_MODE_OUT_OD, GPIO_OSPEED_2MHZ, GPIO_PIN_5);
00000a  4c0c              LDR      r4,|L3.60|
00000c  2320              MOVS     r3,#0x20
00000e  2202              MOVS     r2,#2
000010  2114              MOVS     r1,#0x14
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       gpio_init
;;;146    	gpio_init(GPIOC, GPIO_MODE_OUT_OD, GPIO_OSPEED_2MHZ, GPIO_PIN_6);
000018  2340              MOVS     r3,#0x40
00001a  2202              MOVS     r2,#2
00001c  2114              MOVS     r1,#0x14
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       gpio_init
;;;147    	
;;;148    	E2PROM_SCL_HIGH();
000024  2201              MOVS     r2,#1
000026  2120              MOVS     r1,#0x20
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       gpio_bit_write
;;;149    	E2PROM_SDA_HIGH();
00002e  4620              MOV      r0,r4
000030  2201              MOVS     r2,#1
000032  e8bd4010          POP      {r4,lr}
000036  2140              MOVS     r1,#0x40
000038  f7ffbffe          B.W      gpio_bit_write
;;;150    	E2PROM_SCL_DIR_OUT();
;;;151    	E2PROM_SDA_DIR_OUT();
;;;152    }
;;;153    
                          ENDP

                  |L3.60|
                          DCD      0x40011000

                          AREA ||i.E2PROM_I2C_ReadByte||, CODE, READONLY, ALIGN=2

                  E2PROM_I2C_ReadByte PROC
;;;219    // I2C读取一个字节
;;;220    uint8 E2PROM_I2C_ReadByte(uint8 AckOrNot)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;221    {
000004  4607              MOV      r7,r0
;;;222    	uint8 i;
;;;223    	uint8 RetValue = 0;
000006  2400              MOVS     r4,#0
;;;224    	
;;;225    	E2PROM_SDA_DIR_IN();					// 端口设为输入方式以读取数据 
000008  4e1f              LDR      r6,|L4.136|
00000a  2201              MOVS     r2,#1
00000c  2140              MOVS     r1,#0x40
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       gpio_bit_write
;;;226    	 
;;;227    	for (i=0; i<8; i++)
000014  2500              MOVS     r5,#0
                  |L4.22|
;;;228    	{
;;;229    		E2PROM_SCL_HIGH();					// 时钟为高,读取位
000016  2201              MOVS     r2,#1
000018  2120              MOVS     r1,#0x20
00001a  4630              MOV      r0,r6
00001c  f7fffffe          BL       gpio_bit_write
;;;230    		E2PROM_DELAY();
000020  2005              MOVS     r0,#5
000022  f7fffffe          BL       E2PROM_Delayus
;;;231    		
;;;232    		RetValue <<= 1;
000026  0660              LSLS     r0,r4,#25
000028  0e04              LSRS     r4,r0,#24
;;;233    		if (E2PROM_SDA_GET())
00002a  2140              MOVS     r1,#0x40
00002c  4630              MOV      r0,r6
00002e  f7fffffe          BL       gpio_input_bit_get
000032  b108              CBZ      r0,|L4.56|
;;;234    		{
;;;235    			RetValue |= 0x01;
000034  f0440401          ORR      r4,r4,#1
                  |L4.56|
;;;236    		}
;;;237    		
;;;238    		E2PROM_SCL_LOW();					// 时钟为低,24C02改变位数据
000038  2200              MOVS     r2,#0
00003a  2120              MOVS     r1,#0x20
00003c  4630              MOV      r0,r6
00003e  f7fffffe          BL       gpio_bit_write
;;;239    		E2PROM_DELAY();    
000042  2005              MOVS     r0,#5
000044  f7fffffe          BL       E2PROM_Delayus
000048  1c6d              ADDS     r5,r5,#1              ;227
00004a  b2ed              UXTB     r5,r5                 ;227
00004c  2d08              CMP      r5,#8                 ;227
00004e  d3e2              BCC      |L4.22|
;;;240    	}
;;;241    	
;;;242    	E2PROM_SDA_DIR_OUT();
;;;243    	E2PROM_SDA_SET(AckOrNot);				// 应答与否
000050  463a              MOV      r2,r7
000052  2140              MOVS     r1,#0x40
000054  4630              MOV      r0,r6
000056  f7fffffe          BL       gpio_bit_write
;;;244    	E2PROM_DELAY();
00005a  2005              MOVS     r0,#5
00005c  f7fffffe          BL       E2PROM_Delayus
;;;245    	
;;;246    	E2PROM_SCL_HIGH();
000060  2201              MOVS     r2,#1
000062  2120              MOVS     r1,#0x20
000064  4630              MOV      r0,r6
000066  f7fffffe          BL       gpio_bit_write
;;;247    	E2PROM_DELAY();
00006a  2005              MOVS     r0,#5
00006c  f7fffffe          BL       E2PROM_Delayus
;;;248    	
;;;249    	E2PROM_SCL_LOW();
000070  2200              MOVS     r2,#0
000072  2120              MOVS     r1,#0x20
000074  4630              MOV      r0,r6
000076  f7fffffe          BL       gpio_bit_write
;;;250    	E2PROM_DELAY();  
00007a  2005              MOVS     r0,#5
00007c  f7fffffe          BL       E2PROM_Delayus
;;;251    	
;;;252    	return RetValue;
000080  4620              MOV      r0,r4
;;;253    }
000082  e8bd81f0          POP      {r4-r8,pc}
;;;254    
                          ENDP

000086  0000              DCW      0x0000
                  |L4.136|
                          DCD      0x40011000

                          AREA ||i.E2PROM_I2C_Start||, CODE, READONLY, ALIGN=2

                  E2PROM_I2C_Start PROC
;;;154    // I2C起始信号
;;;155    void E2PROM_I2C_Start(void)
000000  b510              PUSH     {r4,lr}
;;;156    {
;;;157    	E2PROM_SDA_HIGH();
000002  4c10              LDR      r4,|L5.68|
000004  2201              MOVS     r2,#1
000006  2140              MOVS     r1,#0x40
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       gpio_bit_write
;;;158    	E2PROM_SCL_HIGH();
00000e  2201              MOVS     r2,#1
000010  2120              MOVS     r1,#0x20
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       gpio_bit_write
;;;159    	E2PROM_DELAY();
000018  2005              MOVS     r0,#5
00001a  f7fffffe          BL       E2PROM_Delayus
;;;160    	
;;;161    	E2PROM_SDA_LOW();
00001e  2200              MOVS     r2,#0
000020  2140              MOVS     r1,#0x40
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       gpio_bit_write
;;;162    	E2PROM_DELAY();
000028  2005              MOVS     r0,#5
00002a  f7fffffe          BL       E2PROM_Delayus
;;;163    	
;;;164    	E2PROM_SCL_LOW();
00002e  2200              MOVS     r2,#0
000030  2120              MOVS     r1,#0x20
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       gpio_bit_write
;;;165    	E2PROM_DELAY();
000038  e8bd4010          POP      {r4,lr}
00003c  2005              MOVS     r0,#5
00003e  f7ffbffe          B.W      E2PROM_Delayus
;;;166    }
;;;167    
                          ENDP

000042  0000              DCW      0x0000
                  |L5.68|
                          DCD      0x40011000

                          AREA ||i.E2PROM_I2C_Stop||, CODE, READONLY, ALIGN=2

                  E2PROM_I2C_Stop PROC
;;;168    // I2C停止信号
;;;169    void E2PROM_I2C_Stop(void)
000000  b510              PUSH     {r4,lr}
;;;170    {
;;;171    	E2PROM_SCL_LOW();
000002  4c10              LDR      r4,|L6.68|
000004  2200              MOVS     r2,#0
000006  2120              MOVS     r1,#0x20
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       gpio_bit_write
;;;172    	E2PROM_SDA_LOW();
00000e  2200              MOVS     r2,#0
000010  2140              MOVS     r1,#0x40
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       gpio_bit_write
;;;173    	E2PROM_DELAY();
000018  2005              MOVS     r0,#5
00001a  f7fffffe          BL       E2PROM_Delayus
;;;174    	
;;;175    	E2PROM_SCL_HIGH();
00001e  2201              MOVS     r2,#1
000020  2120              MOVS     r1,#0x20
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       gpio_bit_write
;;;176    	E2PROM_DELAY();
000028  2005              MOVS     r0,#5
00002a  f7fffffe          BL       E2PROM_Delayus
;;;177    	
;;;178    	E2PROM_SDA_HIGH();
00002e  2201              MOVS     r2,#1
000030  2140              MOVS     r1,#0x40
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       gpio_bit_write
;;;179    	E2PROM_DELAY();
000038  e8bd4010          POP      {r4,lr}
00003c  2005              MOVS     r0,#5
00003e  f7ffbffe          B.W      E2PROM_Delayus
;;;180    }
;;;181    
                          ENDP

000042  0000              DCW      0x0000
                  |L6.68|
                          DCD      0x40011000

                          AREA ||i.E2PROM_I2C_WriteByte||, CODE, READONLY, ALIGN=2

                  E2PROM_I2C_WriteByte PROC
;;;182    // I2C写一个字节
;;;183    void E2PROM_I2C_WriteByte(uint8 Value)
000000  b570              PUSH     {r4-r6,lr}
;;;184    {
000002  4605              MOV      r5,r0
;;;185    	uint8 i;
;;;186    	
;;;187    	for (i=0; i<8; i++)
000004  2400              MOVS     r4,#0
;;;188    	{
;;;189    		if(0x80 == (Value & 0x80))
;;;190    		{
;;;191    			E2PROM_SDA_HIGH();
000006  4e1f              LDR      r6,|L7.132|
                  |L7.8|
000008  0628              LSLS     r0,r5,#24             ;189
00000a  d505              BPL      |L7.24|
00000c  2201              MOVS     r2,#1
00000e  2140              MOVS     r1,#0x40
000010  4630              MOV      r0,r6
000012  f7fffffe          BL       gpio_bit_write
000016  e004              B        |L7.34|
                  |L7.24|
;;;192    		}
;;;193    		else
;;;194    		{
;;;195    			E2PROM_SDA_LOW();
000018  2200              MOVS     r2,#0
00001a  2140              MOVS     r1,#0x40
00001c  4630              MOV      r0,r6
00001e  f7fffffe          BL       gpio_bit_write
                  |L7.34|
;;;196    		}
;;;197    		E2PROM_DELAY();
000022  2005              MOVS     r0,#5
000024  f7fffffe          BL       E2PROM_Delayus
;;;198    		
;;;199    		E2PROM_SCL_HIGH();
000028  2201              MOVS     r2,#1
00002a  2120              MOVS     r1,#0x20
00002c  4630              MOV      r0,r6
00002e  f7fffffe          BL       gpio_bit_write
;;;200    		E2PROM_DELAY();
000032  2005              MOVS     r0,#5
000034  f7fffffe          BL       E2PROM_Delayus
;;;201    		
;;;202    		E2PROM_SCL_LOW();
000038  2200              MOVS     r2,#0
00003a  2120              MOVS     r1,#0x20
00003c  4630              MOV      r0,r6
00003e  f7fffffe          BL       gpio_bit_write
;;;203    		E2PROM_DELAY(); 
000042  2005              MOVS     r0,#5
000044  f7fffffe          BL       E2PROM_Delayus
;;;204    	 
;;;205    		Value <<= 1;
000048  0668              LSLS     r0,r5,#25
00004a  0e05              LSRS     r5,r0,#24
00004c  1c64              ADDS     r4,r4,#1              ;187
00004e  b2e4              UXTB     r4,r4                 ;187
000050  2c08              CMP      r4,#8                 ;187
000052  d3d9              BCC      |L7.8|
;;;206    	}
;;;207    	
;;;208    	E2PROM_SDA_DIR_IN();				  // 准备接收ACK
000054  2201              MOVS     r2,#1
000056  2140              MOVS     r1,#0x40
000058  4630              MOV      r0,r6
00005a  f7fffffe          BL       gpio_bit_write
;;;209    	
;;;210    	E2PROM_SCL_HIGH();	 
00005e  2201              MOVS     r2,#1
000060  2120              MOVS     r1,#0x20
000062  4630              MOV      r0,r6
000064  f7fffffe          BL       gpio_bit_write
;;;211    	E2PROM_DELAY();  
000068  2005              MOVS     r0,#5
00006a  f7fffffe          BL       E2PROM_Delayus
;;;212    	
;;;213    	E2PROM_SCL_LOW();		  
00006e  2200              MOVS     r2,#0
000070  2120              MOVS     r1,#0x20
000072  4630              MOV      r0,r6
000074  f7fffffe          BL       gpio_bit_write
;;;214    	E2PROM_DELAY();
000078  e8bd4070          POP      {r4-r6,lr}
00007c  2005              MOVS     r0,#5
00007e  f7ffbffe          B.W      E2PROM_Delayus
;;;215    	
;;;216    	E2PROM_SDA_DIR_OUT();				  
;;;217    }									 
;;;218    
                          ENDP

000082  0000              DCW      0x0000
                  |L7.132|
                          DCD      0x40011000

                          AREA ||i.E2PROM_Init||, CODE, READONLY, ALIGN=1

                  E2PROM_Init PROC
;;;298    // E2PROM初始化
;;;299    void E2PROM_Init(void)
000000  f7ffbffe          B.W      E2PROM_I2C_Init
;;;300    {
;;;301    	// 硬件初始化
;;;302    	E2PROM_I2C_Init();
;;;303    
;;;304    #if E2PROM_UNIT_TEST
;;;305    	E2PROM_UnitTest();
;;;306    #endif
;;;307    
;;;308    	//E2PROM_ServiceInit();
;;;309    }
;;;310    
                          ENDP


                          AREA ||i.E2PROM_ReadByte||, CODE, READONLY, ALIGN=1

                  E2PROM_ReadByte PROC
;;;442    // 读取一个字节
;;;443    uint8 E2PROM_ReadByte(uint16 ReadAddr)
000000  b570              PUSH     {r4-r6,lr}
;;;444    {
;;;445    	uint8 data;
;;;446    	uint8 addrH = (uint8)(ReadAddr >> 8);	// 取高8位地址
000002  0a04              LSRS     r4,r0,#8
;;;447    	uint8 addrL = (uint8)ReadAddr;			// 取低8位地址
000004  b2c5              UXTB     r5,r0
;;;448    
;;;449    	// 判断存储地址是否超过8位
;;;450    #if EEPROM_TYPE <= EEPROM_24C16
;;;451    
;;;452    	E2PROM_I2C_Start();
;;;453    	E2PROM_I2C_WriteByte(((addrH<<1)&0x0F) | EEPROM_WRCOMMAND);    // 设备地址也是字节地址的高8位，写指令
;;;454    	E2PROM_I2C_WriteByte(addrL);
;;;455    
;;;456    	E2PROM_I2C_Start();
;;;457    	E2PROM_I2C_WriteByte(EEPROM_RDCOMMAND);	// 读指令
;;;458    
;;;459    	data = E2PROM_I2C_ReadByte(E2PROM_I2C_NACK);
;;;460    
;;;461    	E2PROM_I2C_Stop();
;;;462    
;;;463    	return data;
;;;464    	
;;;465    #else
;;;466    
;;;467    	E2PROM_I2C_Start();
000006  f7fffffe          BL       E2PROM_I2C_Start
;;;468    	E2PROM_I2C_WriteByte(EEPROM_WRCOMMAND); // 写指令
00000a  20a0              MOVS     r0,#0xa0
00000c  f7fffffe          BL       E2PROM_I2C_WriteByte
;;;469    	E2PROM_I2C_WriteByte(addrH);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       E2PROM_I2C_WriteByte
;;;470    	E2PROM_I2C_WriteByte(addrL);
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       E2PROM_I2C_WriteByte
;;;471    
;;;472    	E2PROM_I2C_Start();
00001c  f7fffffe          BL       E2PROM_I2C_Start
;;;473    	E2PROM_I2C_WriteByte(EEPROM_RDCOMMAND);	// 读指令
000020  20a1              MOVS     r0,#0xa1
000022  f7fffffe          BL       E2PROM_I2C_WriteByte
;;;474    
;;;475    	data = E2PROM_I2C_ReadByte(E2PROM_I2C_NACK);
000026  2001              MOVS     r0,#1
000028  f7fffffe          BL       E2PROM_I2C_ReadByte
00002c  4604              MOV      r4,r0
;;;476    
;;;477    	E2PROM_I2C_Stop();
00002e  f7fffffe          BL       E2PROM_I2C_Stop
;;;478    
;;;479    	return data;
000032  4620              MOV      r0,r4
;;;480    
;;;481    #endif
;;;482    }
000034  bd70              POP      {r4-r6,pc}
;;;483    
                          ENDP


                          AREA ||i.E2PROM_ReadByteArray||, CODE, READONLY, ALIGN=1

                  E2PROM_ReadByteArray PROC
;;;311    // 读数据，整个地址内，无需考虑页问题
;;;312    BOOL E2PROM_ReadByteArray(uint16 ReadAddr, uint8* pBuf, uint16 readNum)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;313    {
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;314    	uint16 i = 0;
000008  2400              MOVS     r4,#0
;;;315    	uint8 addrH = (uint8)(ReadAddr >> 8);	// 取高8位地址
00000a  0a07              LSRS     r7,r0,#8
;;;316    	uint8 addrL = (uint8)ReadAddr;			// 取低8位地址
00000c  f00008ff          AND      r8,r0,#0xff
;;;317    
;;;318    	// 地址不能超出总空间大小
;;;319    	if (ReadAddr > EE_TOTAL_SIZE)
000010  f44f5100          MOV      r1,#0x2000
000014  4288              CMP      r0,r1
000016  d302              BCC      |L10.30|
;;;320    	{
;;;321    		return FALSE;
000018  2000              MOVS     r0,#0
                  |L10.26|
;;;322    	}
;;;323    
;;;324    	// 读的数量超出总空间大小
;;;325    	if ((ReadAddr + readNum) > EE_TOTAL_SIZE) 
;;;326    	{
;;;327    		return FALSE;
;;;328    	}
;;;329    
;;;330    	// 空指针
;;;331    	if (NULL == pBuf)
;;;332    	{
;;;333    		return FALSE;
;;;334    	}
;;;335    
;;;336    	// 判断存储地址是否超过8位
;;;337    #if EEPROM_TYPE <= EEPROM_24C16
;;;338    
;;;339    	E2PROM_I2C_Start();
;;;340    	E2PROM_I2C_WriteByte(((addrH<<1)&0x0F) | EEPROM_WRCOMMAND);    // 设备地址也是字节地址的高8位，写指令
;;;341    	E2PROM_I2C_WriteByte(addrL);
;;;342    
;;;343    	E2PROM_I2C_Start();
;;;344    	E2PROM_I2C_WriteByte(EEPROM_RDCOMMAND);	// 读指令
;;;345    	while(i < (readNum-1))
;;;346    	{
;;;347    		pBuf[i++] = E2PROM_I2C_ReadByte(E2PROM_I2C_ACK);
;;;348    	}
;;;349    	pBuf[i] = E2PROM_I2C_ReadByte(E2PROM_I2C_NACK);
;;;350    
;;;351    	E2PROM_I2C_Stop();
;;;352    	
;;;353    #else
;;;354    
;;;355    	E2PROM_I2C_Start();
;;;356    	E2PROM_I2C_WriteByte(EEPROM_WRCOMMAND); // 写指令
;;;357    	E2PROM_I2C_WriteByte(addrH);
;;;358    	E2PROM_I2C_WriteByte(addrL);
;;;359    
;;;360    	E2PROM_I2C_Start();
;;;361    	E2PROM_I2C_WriteByte(EEPROM_RDCOMMAND);	// 读指令
;;;362    	while(i < (readNum-1))
;;;363    	{
;;;364    		pBuf[i++] = E2PROM_I2C_ReadByte(E2PROM_I2C_ACK);
;;;365    	}
;;;366    	pBuf[i] = E2PROM_I2C_ReadByte(E2PROM_I2C_NACK);
;;;367    
;;;368    	E2PROM_I2C_Stop();
;;;369    
;;;370    #endif
;;;371    	return TRUE;
;;;372    }
00001a  e8bd81f0          POP      {r4-r8,pc}
                  |L10.30|
00001e  4430              ADD      r0,r0,r6              ;325
000020  4288              CMP      r0,r1                 ;325
000022  d301              BCC      |L10.40|
000024  2000              MOVS     r0,#0                 ;327
000026  e7f8              B        |L10.26|
                  |L10.40|
000028  b18d              CBZ      r5,|L10.78|
00002a  f7fffffe          BL       E2PROM_I2C_Start
00002e  20a0              MOVS     r0,#0xa0              ;356
000030  f7fffffe          BL       E2PROM_I2C_WriteByte
000034  4638              MOV      r0,r7                 ;357
000036  f7fffffe          BL       E2PROM_I2C_WriteByte
00003a  4640              MOV      r0,r8                 ;358
00003c  f7fffffe          BL       E2PROM_I2C_WriteByte
000040  f7fffffe          BL       E2PROM_I2C_Start
000044  20a1              MOVS     r0,#0xa1              ;361
000046  f7fffffe          BL       E2PROM_I2C_WriteByte
00004a  1e76              SUBS     r6,r6,#1              ;362
00004c  e008              B        |L10.96|
                  |L10.78|
00004e  2000              MOVS     r0,#0                 ;333
000050  e7e3              B        |L10.26|
                  |L10.82|
000052  2000              MOVS     r0,#0                 ;364
000054  f7fffffe          BL       E2PROM_I2C_ReadByte
000058  4621              MOV      r1,r4                 ;364
00005a  1c64              ADDS     r4,r4,#1              ;364
00005c  b2a4              UXTH     r4,r4                 ;364
00005e  5468              STRB     r0,[r5,r1]            ;364
                  |L10.96|
000060  42b4              CMP      r4,r6                 ;362
000062  dbf6              BLT      |L10.82|
000064  2001              MOVS     r0,#1                 ;366
000066  f7fffffe          BL       E2PROM_I2C_ReadByte
00006a  5528              STRB     r0,[r5,r4]            ;366
00006c  f7fffffe          BL       E2PROM_I2C_Stop
000070  2001              MOVS     r0,#1                 ;371
000072  e7d2              B        |L10.26|
;;;373    
                          ENDP


                          AREA ||i.E2PROM_ReadInt||, CODE, READONLY, ALIGN=1

                  E2PROM_ReadInt PROC
;;;484    // 读取一个双字节数值
;;;485    uint16 E2PROM_ReadInt(uint16 ReadAddr)
000000  b570              PUSH     {r4-r6,lr}
;;;486    {
;;;487    	uint16 data = 0;
;;;488    	uint8 addrH = (uint8)(ReadAddr >> 8);	// 取高8位地址
000002  0a04              LSRS     r4,r0,#8
;;;489    	uint8 addrL = (uint8)ReadAddr;			// 取低8位地址
000004  b2c5              UXTB     r5,r0
;;;490    
;;;491    	// 判断存储地址是否超过8位
;;;492    #if EEPROM_TYPE <= EEPROM_24C16
;;;493    
;;;494    	E2PROM_I2C_Start();
;;;495    	E2PROM_I2C_WriteByte(((addrH<<1)&0x0F) | EEPROM_WRCOMMAND);    // 设备地址也是字节地址的高8位，写指令
;;;496    	E2PROM_I2C_WriteByte(addrL);
;;;497    
;;;498    	E2PROM_I2C_Start();
;;;499    	E2PROM_I2C_WriteByte(EEPROM_RDCOMMAND);	// 读指令
;;;500    
;;;501    	data = E2PROM_I2C_ReadByte(E2PROM_I2C_ACK);
;;;502    	data <<= 8;
;;;503    	data |= E2PROM_I2C_ReadByte(E2PROM_I2C_NACK);
;;;504    
;;;505    	E2PROM_I2C_Stop();
;;;506    
;;;507    	return data;
;;;508    	
;;;509    #else
;;;510    
;;;511    	E2PROM_I2C_Start();
000006  f7fffffe          BL       E2PROM_I2C_Start
;;;512    	E2PROM_I2C_WriteByte(EEPROM_WRCOMMAND); // 写指令
00000a  20a0              MOVS     r0,#0xa0
00000c  f7fffffe          BL       E2PROM_I2C_WriteByte
;;;513    	E2PROM_I2C_WriteByte(addrH);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       E2PROM_I2C_WriteByte
;;;514    	E2PROM_I2C_WriteByte(addrL);
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       E2PROM_I2C_WriteByte
;;;515    
;;;516    	E2PROM_I2C_Start();
00001c  f7fffffe          BL       E2PROM_I2C_Start
;;;517    	E2PROM_I2C_WriteByte(EEPROM_RDCOMMAND);	// 读指令
000020  20a1              MOVS     r0,#0xa1
000022  f7fffffe          BL       E2PROM_I2C_WriteByte
;;;518    
;;;519    	data = E2PROM_I2C_ReadByte(E2PROM_I2C_ACK);
000026  2000              MOVS     r0,#0
000028  f7fffffe          BL       E2PROM_I2C_ReadByte
;;;520    	data <<= 8;
00002c  f64f71ff          MOV      r1,#0xffff
000030  ea012500          AND      r5,r1,r0,LSL #8
;;;521    	data |= E2PROM_I2C_ReadByte(E2PROM_I2C_NACK);
000034  2001              MOVS     r0,#1
000036  f7fffffe          BL       E2PROM_I2C_ReadByte
00003a  ea400405          ORR      r4,r0,r5
;;;522    
;;;523    	E2PROM_I2C_Stop();
00003e  f7fffffe          BL       E2PROM_I2C_Stop
;;;524    
;;;525    	return data;
000042  4620              MOV      r0,r4
;;;526    
;;;527    #endif
;;;528    }
000044  bd70              POP      {r4-r6,pc}
;;;529    
                          ENDP


                          AREA ||i.E2PROM_ReadWord||, CODE, READONLY, ALIGN=1

                  E2PROM_ReadWord PROC
;;;530    // 读取一个四字节数值
;;;531    uint32 E2PROM_ReadWord(uint16 ReadAddr)
000000  b570              PUSH     {r4-r6,lr}
;;;532    {
;;;533    	uint32 data = 0;
;;;534    	uint8 addrH = (uint8)(ReadAddr >> 8);	// 取高8位地址
000002  0a04              LSRS     r4,r0,#8
;;;535    	uint8 addrL = (uint8)ReadAddr;			// 取低8位地址
000004  b2c5              UXTB     r5,r0
;;;536    
;;;537    	// 判断存储地址是否超过8位
;;;538    #if EEPROM_TYPE <= EEPROM_24C16
;;;539    
;;;540    	E2PROM_I2C_Start();
;;;541    	E2PROM_I2C_WriteByte(((addrH<<1)&0x0F) | EEPROM_WRCOMMAND);    // 设备地址也是字节地址的高8位，写指令
;;;542    	E2PROM_I2C_WriteByte(addrL);
;;;543    
;;;544    	E2PROM_I2C_Start();
;;;545    	E2PROM_I2C_WriteByte(EEPROM_RDCOMMAND);	// 读指令
;;;546    
;;;547    	data = E2PROM_I2C_ReadByte(E2PROM_I2C_ACK);
;;;548    	data <<= 8;
;;;549    	data |= E2PROM_I2C_ReadByte(E2PROM_I2C_ACK);
;;;550    	data <<= 8;
;;;551    	data |= E2PROM_I2C_ReadByte(E2PROM_I2C_ACK);
;;;552    	data <<= 8;
;;;553    	data |= E2PROM_I2C_ReadByte(E2PROM_I2C_NACK);
;;;554    
;;;555    	E2PROM_I2C_Stop();
;;;556    
;;;557    	return data;
;;;558    	
;;;559    #else
;;;560    
;;;561    	E2PROM_I2C_Start();
000006  f7fffffe          BL       E2PROM_I2C_Start
;;;562    	E2PROM_I2C_WriteByte(EEPROM_WRCOMMAND); // 写指令
00000a  20a0              MOVS     r0,#0xa0
00000c  f7fffffe          BL       E2PROM_I2C_WriteByte
;;;563    	E2PROM_I2C_WriteByte(addrH);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       E2PROM_I2C_WriteByte
;;;564    	E2PROM_I2C_WriteByte(addrL);
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       E2PROM_I2C_WriteByte
;;;565    
;;;566    	E2PROM_I2C_Start();
00001c  f7fffffe          BL       E2PROM_I2C_Start
;;;567    	E2PROM_I2C_WriteByte(EEPROM_RDCOMMAND);	// 读指令
000020  20a1              MOVS     r0,#0xa1
000022  f7fffffe          BL       E2PROM_I2C_WriteByte
;;;568    
;;;569    	data = E2PROM_I2C_ReadByte(E2PROM_I2C_ACK);
000026  2000              MOVS     r0,#0
000028  f7fffffe          BL       E2PROM_I2C_ReadByte
;;;570    	data <<= 8;
00002c  0204              LSLS     r4,r0,#8
;;;571    	data |= E2PROM_I2C_ReadByte(E2PROM_I2C_ACK);
00002e  2000              MOVS     r0,#0
000030  f7fffffe          BL       E2PROM_I2C_ReadByte
000034  4320              ORRS     r0,r0,r4
;;;572    	data <<= 8;
000036  0204              LSLS     r4,r0,#8
;;;573    	data |= E2PROM_I2C_ReadByte(E2PROM_I2C_ACK);
000038  2000              MOVS     r0,#0
00003a  f7fffffe          BL       E2PROM_I2C_ReadByte
00003e  4320              ORRS     r0,r0,r4
;;;574    	data <<= 8;
000040  0205              LSLS     r5,r0,#8
;;;575    	data |= E2PROM_I2C_ReadByte(E2PROM_I2C_NACK);
000042  2001              MOVS     r0,#1
000044  f7fffffe          BL       E2PROM_I2C_ReadByte
000048  ea400405          ORR      r4,r0,r5
;;;576    
;;;577    	E2PROM_I2C_Stop();
00004c  f7fffffe          BL       E2PROM_I2C_Stop
;;;578    
;;;579    	return data;
000050  4620              MOV      r0,r4
;;;580    
;;;581    #endif
;;;582    }
000052  bd70              POP      {r4-r6,pc}
;;;583    
                          ENDP


                          AREA ||i.E2PROM_ServiceGetIDAddr||, CODE, READONLY, ALIGN=2

                  E2PROM_ServiceGetIDAddr PROC
;;;825    // 业务层获取相应ID存取的地址
;;;826    uint16 E2PROM_ServiceGetIDAddr(E2PROM_ID id)
000000  4902              LDR      r1,|L13.12|
;;;827    {	
;;;828    	return e2promCB.record[id].addr;
000002  eb011000          ADD      r0,r1,r0,LSL #4
000006  8800              LDRH     r0,[r0,#0]
;;;829    }
000008  4770              BX       lr
;;;830    
                          ENDP

00000a  0000              DCW      0x0000
                  |L13.12|
                          DCD      ||.bss||

                          AREA ||i.E2PROM_ServiceGetRomSize||, CODE, READONLY, ALIGN=2

                  E2PROM_ServiceGetRomSize PROC
;;;831    // 业务层获取使用的总空间大小
;;;832    uint32 E2PROM_ServiceGetRomSize(void)
000000  4801              LDR      r0,|L14.8|
;;;833    {
;;;834    	return e2promCB.size;
000002  6e00              LDR      r0,[r0,#0x60]  ; e2promCB
;;;835    }
000004  4770              BX       lr
;;;836    
                          ENDP

000006  0000              DCW      0x0000
                  |L14.8|
                          DCD      ||.bss||

                          AREA ||i.E2PROM_ServiceInit||, CODE, READONLY, ALIGN=2

                  E2PROM_ServiceInit PROC
;;;801    // 服务数据初始化
;;;802    void E2PROM_ServiceInit(void)
000000  b510              PUSH     {r4,lr}
;;;803    {
;;;804    	uint8 i;
;;;805    
;;;806    	for (i = 0; i < E2PROM_ID_MAX; i++)
000002  2000              MOVS     r0,#0
;;;807    	{
;;;808    		e2promCB.record[i].addr = 0;
000004  4b13              LDR      r3,|L15.84|
000006  2200              MOVS     r2,#0                 ;806
                  |L15.8|
000008  eb031100          ADD      r1,r3,r0,LSL #4
00000c  800a              STRH     r2,[r1,#0]
;;;809    		e2promCB.record[i].length = 0;
00000e  804a              STRH     r2,[r1,#2]
;;;810    		e2promCB.record[i].writeMode = E2PROM_ACCESS_MODE_NOT_OFTEN;
000010  730a              STRB     r2,[r1,#0xc]
;;;811    
;;;812    		e2promCB.record[i].isExist = FALSE;
000012  734a              STRB     r2,[r1,#0xd]
000014  1c40              ADDS     r0,r0,#1              ;806
000016  b2c0              UXTB     r0,r0                 ;806
000018  2806              CMP      r0,#6                 ;806
00001a  d3f5              BCC      |L15.8|
;;;813    	}
;;;814    	e2promCB.size = 0;
00001c  661a              STR      r2,[r3,#0x60]  ; e2promCB
;;;815    
;;;816    	// 注册系统参数
;;;817    	E2PROM_ServiceRegister32bit(E2PROM_ID_WHELL_SIZE1, E2PROM_ACCESS_MODE_NOT_OFTEN);
00001e  2100              MOVS     r1,#0
000020  4608              MOV      r0,r1
000022  f7fffffe          BL       E2PROM_ServiceRegister32bit
;;;818    	E2PROM_ServiceRegister32bit(E2PROM_ID_WHELL_SIZE2, E2PROM_ACCESS_MODE_NOT_OFTEN);
000026  2100              MOVS     r1,#0
000028  2001              MOVS     r0,#1
00002a  f7fffffe          BL       E2PROM_ServiceRegister32bit
;;;819    	E2PROM_ServiceRegister32bit(E2PROM_ID_WHELL_SIZE3, E2PROM_ACCESS_MODE_NOT_OFTEN);
00002e  2100              MOVS     r1,#0
000030  2002              MOVS     r0,#2
000032  f7fffffe          BL       E2PROM_ServiceRegister32bit
;;;820    	E2PROM_ServiceRegister32bit(E2PROM_ID_WHELL_SIZE4, E2PROM_ACCESS_MODE_NOT_OFTEN);
000036  2100              MOVS     r1,#0
000038  2003              MOVS     r0,#3
00003a  f7fffffe          BL       E2PROM_ServiceRegister32bit
;;;821    	E2PROM_ServiceRegister32bit(E2PROM_ID_WHELL_SIZE5, E2PROM_ACCESS_MODE_NOT_OFTEN);
00003e  2100              MOVS     r1,#0
000040  2004              MOVS     r0,#4
000042  f7fffffe          BL       E2PROM_ServiceRegister32bit
;;;822    	E2PROM_ServiceRegister32bit(E2PROM_ID_WHELL_SIZE6, E2PROM_ACCESS_MODE_NOT_OFTEN);
000046  2100              MOVS     r1,#0
000048  e8bd4010          POP      {r4,lr}
00004c  2005              MOVS     r0,#5
00004e  f7ffbffe          B.W      E2PROM_ServiceRegister32bit
;;;823    }
;;;824    
                          ENDP

000052  0000              DCW      0x0000
                  |L15.84|
                          DCD      ||.bss||

                          AREA ||i.E2PROM_ServiceRead16bit||, CODE, READONLY, ALIGN=1

                  E2PROM_ServiceRead16bit PROC
;;;1171   // 业务层读一个双字节
;;;1172   uint16 E2PROM_ServiceRead16bit(E2PROM_ID id)
000000  b508              PUSH     {r3,lr}
;;;1173   { 
;;;1174   	uint8 dataBuf[2];
;;;1175   	uint16 data;
;;;1176   
;;;1177   	E2PROM_ServiceReadArray(id, dataBuf);
000002  4669              MOV      r1,sp
000004  f7fffffe          BL       E2PROM_ServiceReadArray
;;;1178   
;;;1179   	data = dataBuf[0];
000008  f89d0000          LDRB     r0,[sp,#0]
;;;1180   	data <<= 8;
00000c  f64f71ff          MOV      r1,#0xffff
000010  ea012100          AND      r1,r1,r0,LSL #8
;;;1181   	data |= dataBuf[1];
000014  f89d0001          LDRB     r0,[sp,#1]
000018  4308              ORRS     r0,r0,r1
;;;1182   
;;;1183   	return data;
;;;1184   }
00001a  bd08              POP      {r3,pc}
;;;1185   
                          ENDP


                          AREA ||i.E2PROM_ServiceRead32bit||, CODE, READONLY, ALIGN=1

                  E2PROM_ServiceRead32bit PROC
;;;1186   // 业务层读一个四字节
;;;1187   uint32 E2PROM_ServiceRead32bit(E2PROM_ID id)
000000  b508              PUSH     {r3,lr}
;;;1188   { 
;;;1189   	uint8 dataBuf[4];
;;;1190   	uint32 data;
;;;1191   
;;;1192   	E2PROM_ServiceReadArray(id, dataBuf);
000002  4669              MOV      r1,sp
000004  f7fffffe          BL       E2PROM_ServiceReadArray
;;;1193   
;;;1194   	data = dataBuf[0];
000008  f89d0000          LDRB     r0,[sp,#0]
;;;1195   	data <<= 8;
00000c  0201              LSLS     r1,r0,#8
;;;1196   	data |= dataBuf[1];
00000e  f89d0001          LDRB     r0,[sp,#1]
000012  4308              ORRS     r0,r0,r1
;;;1197   	data <<= 8;
000014  0201              LSLS     r1,r0,#8
;;;1198   	data |= dataBuf[2];
000016  f89d0002          LDRB     r0,[sp,#2]
00001a  4308              ORRS     r0,r0,r1
;;;1199   	data <<= 8;
00001c  0201              LSLS     r1,r0,#8
;;;1200   	data |= dataBuf[3];
00001e  f89d0003          LDRB     r0,[sp,#3]
000022  4308              ORRS     r0,r0,r1
;;;1201   
;;;1202   	return data;
;;;1203   }
000024  bd08              POP      {r3,pc}
;;;1204   
                          ENDP


                          AREA ||i.E2PROM_ServiceRead8bit||, CODE, READONLY, ALIGN=1

                  E2PROM_ServiceRead8bit PROC
;;;1161   // 业务层读一个字节
;;;1162   uint8 E2PROM_ServiceRead8bit(E2PROM_ID id)
000000  b508              PUSH     {r3,lr}
;;;1163   { 
;;;1164   	uint8 data;
;;;1165   
;;;1166   	E2PROM_ServiceReadArray(id, &data);
000002  4669              MOV      r1,sp
000004  f7fffffe          BL       E2PROM_ServiceReadArray
;;;1167   
;;;1168   	return data;
000008  f89d0000          LDRB     r0,[sp,#0]
;;;1169   }
00000c  bd08              POP      {r3,pc}
;;;1170   
                          ENDP


                          AREA ||i.E2PROM_ServiceReadArray||, CODE, READONLY, ALIGN=2

                  E2PROM_ServiceReadArray PROC
;;;1124   // 业务层读
;;;1125   void E2PROM_ServiceReadArray(E2PROM_ID id, uint8* pBuf)
000000  b570              PUSH     {r4-r6,lr}
;;;1126   { 
000002  460d              MOV      r5,r1
;;;1127   	uint16 addrBuf;
;;;1128   
;;;1129   	// 参数合法性检验
;;;1130   	if ((id >= E2PROM_ID_MAX) || (NULL == pBuf))
000004  2806              CMP      r0,#6
000006  da23              BGE      |L19.80|
000008  2d00              CMP      r5,#0
00000a  d021              BEQ      |L19.80|
;;;1131   	{
;;;1132   		return;
;;;1133   	}
;;;1134   
;;;1135   	// 此ID注册不成功
;;;1136   	if (!e2promCB.record[id].isExist)
00000c  4911              LDR      r1,|L19.84|
00000e  eb011400          ADD      r4,r1,r0,LSL #4
000012  7b60              LDRB     r0,[r4,#0xd]
000014  2800              CMP      r0,#0
000016  d01b              BEQ      |L19.80|
;;;1137   	{
;;;1138   		return;
;;;1139   	}
;;;1140   
;;;1141   	// 读取频繁擦写的字节
;;;1142   	if(E2PROM_ACCESS_MODE_QUITE_OFTEN == e2promCB.record[id].writeMode)
000018  7b20              LDRB     r0,[r4,#0xc]
00001a  2801              CMP      r0,#1
00001c  d006              BEQ      |L19.44|
;;;1143   	{
;;;1144   		// 读取索引值
;;;1145   		E2PROM_ReadByteArray(e2promCB.record[id].addr, &e2promCB.record[id].index, 1);
;;;1146   		
;;;1147   		// 读取数据值
;;;1148   		// 先计算次数值的地址
;;;1149   		addrBuf = (e2promCB.record[id].addr+2) + (e2promCB.record[id].index * ((sizeof(e2promCB.record[id].count)+1) + e2promCB.record[id].length));
;;;1150   		// 真正数据的地址为次数值地址加上其所占的字节数
;;;1151   		addrBuf = addrBuf + (sizeof(e2promCB.record[id].count)+1);
;;;1152   		E2PROM_ReadByteArray(addrBuf, pBuf, e2promCB.record[id].length);
;;;1153   	}
;;;1154   	// 常规读取
;;;1155   	else
;;;1156   	{
;;;1157   		E2PROM_ReadByteArray(e2promCB.record[id].addr, pBuf, e2promCB.record[id].length);
00001e  8862              LDRH     r2,[r4,#2]
000020  8820              LDRH     r0,[r4,#0]
000022  4629              MOV      r1,r5
000024  e8bd4070          POP      {r4-r6,lr}
000028  f7ffbffe          B.W      E2PROM_ReadByteArray
                  |L19.44|
00002c  1d21              ADDS     r1,r4,#4              ;1145
00002e  8820              LDRH     r0,[r4,#0]            ;1145
000030  2201              MOVS     r2,#1                 ;1145
000032  f7fffffe          BL       E2PROM_ReadByteArray
000036  8862              LDRH     r2,[r4,#2]            ;1149
000038  8821              LDRH     r1,[r4,#0]            ;1149
00003a  7923              LDRB     r3,[r4,#4]            ;1149
00003c  1d50              ADDS     r0,r2,#5              ;1149
00003e  fb031000          MLA      r0,r3,r0,r1           ;1149
000042  1dc0              ADDS     r0,r0,#7              ;1151
000044  b280              UXTH     r0,r0                 ;1151
000046  4629              MOV      r1,r5                 ;1152
000048  e8bd4070          POP      {r4-r6,lr}            ;1152
00004c  f7ffbffe          B.W      E2PROM_ReadByteArray
                  |L19.80|
;;;1158   	}
;;;1159   }
000050  bd70              POP      {r4-r6,pc}
;;;1160   
                          ENDP

000052  0000              DCW      0x0000
                  |L19.84|
                          DCD      ||.bss||

                          AREA ||i.E2PROM_ServiceReadByID||, CODE, READONLY, ALIGN=2

                  E2PROM_ServiceReadByID PROC
;;;1205   // 根据ID读取数值
;;;1206   uint32 E2PROM_ServiceReadByID(E2PROM_ID id)
000000  4908              LDR      r1,|L20.36|
;;;1207   {
;;;1208   	if(1 == e2promCB.record[id].length)
000002  eb011100          ADD      r1,r1,r0,LSL #4
000006  8849              LDRH     r1,[r1,#2]
000008  2901              CMP      r1,#1
00000a  d005              BEQ      |L20.24|
;;;1209   	{
;;;1210   		return E2PROM_ServiceRead8bit(id);
;;;1211   	}
;;;1212   	else if(2 == e2promCB.record[id].length)
00000c  2902              CMP      r1,#2
00000e  d005              BEQ      |L20.28|
;;;1213   	{
;;;1214   		return E2PROM_ServiceRead16bit(id);
;;;1215   	}
;;;1216   	else if(4 == e2promCB.record[id].length)
000010  2904              CMP      r1,#4
000012  d005              BEQ      |L20.32|
;;;1217   	{
;;;1218   		return E2PROM_ServiceRead32bit(id);
;;;1219   	}
;;;1220   	else
;;;1221   	{
;;;1222   		return 0;
000014  2000              MOVS     r0,#0
;;;1223   	}
;;;1224   }
000016  4770              BX       lr
                  |L20.24|
000018  f7ffbffe          B.W      E2PROM_ServiceRead8bit
                  |L20.28|
00001c  f7ffbffe          B.W      E2PROM_ServiceRead16bit
                  |L20.32|
000020  f7ffbffe          B.W      E2PROM_ServiceRead32bit
;;;1225   
                          ENDP

                  |L20.36|
                          DCD      ||.bss||

                          AREA ||i.E2PROM_ServiceRegister||, CODE, READONLY, ALIGN=2

                  E2PROM_ServiceRegister PROC
;;;837    // 注册相应ID的长度以及是否需要频繁擦写模式
;;;838    void E2PROM_ServiceRegister(E2PROM_ID id, uint16 length, E2PROM_ACCESS_MODE_E mode)
000000  b5fe              PUSH     {r1-r7,lr}
;;;839    {
;;;840    	uint8 i;
;;;841    	uint8 indexBuf[2];
;;;842    	uint16 addrBuf;
;;;843    	uint8 dataBuf[sizeof(e2promCB.record[id].count)+1];
;;;844    	uint8 sumCheck;
;;;845    
;;;846    	// 参数合法性检验
;;;847    	if ((id >= E2PROM_ID_MAX) || (length > E2PROM_DISPOSABIE_DATA_LENGTH_MAX))
000002  2806              CMP      r0,#6
000004  da1c              BGE      |L21.64|
000006  f44f5c00          MOV      r12,#0x2000
00000a  4561              CMP      r1,r12
00000c  d218              BCS      |L21.64|
;;;848    	{
;;;849    		return;
;;;850    	}
;;;851    
;;;852    	// 超出E2PROM空间大小
;;;853    	if ((E2PROM_SYSTEM_PARAM_ADDR_OFFSET + e2promCB.size) > EE_TOTAL_SIZE)
00000e  4f42              LDR      r7,|L21.280|
000010  6e3b              LDR      r3,[r7,#0x60]  ; e2promCB
000012  330a              ADDS     r3,r3,#0xa
000014  4563              CMP      r3,r12
000016  d213              BCS      |L21.64|
;;;854    	{
;;;855    		return;
;;;856    	} 
;;;857    	
;;;858    	// 需要写入数据的一个记录条首地址
;;;859    	e2promCB.record[id].addr = E2PROM_SYSTEM_PARAM_ADDR_OFFSET + e2promCB.size;
000018  eb071400          ADD      r4,r7,r0,LSL #4
00001c  8023              STRH     r3,[r4,#0]
;;;860    
;;;861    	// 是否需要频繁写入
;;;862    	e2promCB.record[id].writeMode = mode;
00001e  7322              STRB     r2,[r4,#0xc]
;;;863    
;;;864    	// 需要频繁写入
;;;865    	if (mode)
;;;866    	{
;;;867    		// 需要频繁写入的数据将要增加一个索引以及记录写入数据次数所分配的总空间
;;;868    		e2promCB.size += (sizeof(e2promCB.record[id].index) + (sizeof(e2promCB.record[id].count) + length) * E2PROM_MALLOC_SAVE_SPACE_COUNT);
000020  2601              MOVS     r6,#1
000022  2500              MOVS     r5,#0
000024  2a00              CMP      r2,#0                 ;865
000026  d06a              BEQ      |L21.254|
000028  1d08              ADDS     r0,r1,#4
00002a  eb000080          ADD      r0,r0,r0,LSL #2
00002e  6e3a              LDR      r2,[r7,#0x60]  ; e2promCB
000030  eb060040          ADD      r0,r6,r0,LSL #1
000034  4410              ADD      r0,r0,r2
000036  6638              STR      r0,[r7,#0x60]  ; e2promCB
;;;869    
;;;870    		// 超出E2PROM空间大小
;;;871    		if ((E2PROM_SYSTEM_PARAM_ADDR_OFFSET + e2promCB.size) > EE_TOTAL_SIZE)
000038  300a              ADDS     r0,r0,#0xa
00003a  4560              CMP      r0,r12
00003c  d301              BCC      |L21.66|
;;;872    		{
;;;873    			e2promCB.record[id].isExist = FALSE;
00003e  7365              STRB     r5,[r4,#0xd]
                  |L21.64|
;;;874    			return;
;;;875    		}		  
;;;876    
;;;877    		// 更新当前ID对应的数据长度
;;;878    		e2promCB.record[id].length = length; 
;;;879    
;;;880    		// 索引值
;;;881    		E2PROM_ReadByteArray(e2promCB.record[id].addr, indexBuf, 2);
;;;882    		
;;;883    		// 判断是否需要给其配置初始值
;;;884    		if (~(indexBuf[0] + E2PROM_LOCKED_KEY) == indexBuf[1])
;;;885    		{
;;;886    			e2promCB.record[id].index = indexBuf[0];
;;;887    		}
;;;888    		else
;;;889    		{
;;;890    			// 第一次上电赋默认值
;;;891    			e2promCB.record[id].index = 0;
;;;892    			indexBuf[0] = e2promCB.record[id].index;
;;;893    			indexBuf[1] = ~(e2promCB.record[id].index + E2PROM_LOCKED_KEY);
;;;894    			E2PROM_WriteByteArray(e2promCB.record[id].addr, indexBuf, 2);  // 更新索引值，包含了索引的校验值
;;;895    		}
;;;896    
;;;897    		// 读取擦写次数值
;;;898    		addrBuf = (e2promCB.record[id].addr+2) + (e2promCB.record[id].index * ((sizeof(e2promCB.record[id].count)+1) + e2promCB.record[id].length));
;;;899    		E2PROM_ReadByteArray(addrBuf, dataBuf, sizeof(e2promCB.record[id].count)+1);
;;;900    
;;;901    		// 校验值
;;;902    		sumCheck = 0;
;;;903    		for (i = 0; i < sizeof(e2promCB.record[id].count); i++)
;;;904    		{
;;;905    			sumCheck += dataBuf[i];
;;;906    		}
;;;907    		sumCheck = ~(sumCheck + E2PROM_LOCKED_KEY);
;;;908    		
;;;909    		// 判断是否需要给其配置初始值
;;;910    		if (sumCheck == dataBuf[i])
;;;911    		{
;;;912    			for (i = 0, e2promCB.record[id].count = 0; i < sizeof(e2promCB.record[id].count); i++)
;;;913    			{
;;;914    				e2promCB.record[id].count <<= 8;
;;;915    				e2promCB.record[id].count |= dataBuf[i];
;;;916    			}
;;;917    		}
;;;918    		else
;;;919    		{
;;;920    			// 第一次上电赋默认值
;;;921    			e2promCB.record[id].count = 0;
;;;922    			
;;;923    			// 计算检验值
;;;924    			sumCheck = 0;
;;;925    			for (i = 0; i < sizeof(e2promCB.record[id].count); i++)
;;;926    			{
;;;927    				dataBuf[i] = 0;
;;;928    				sumCheck += dataBuf[i];
;;;929    			}
;;;930    			dataBuf[i] = ~(sumCheck + E2PROM_LOCKED_KEY);
;;;931    			
;;;932    			// 当前索引对应的擦写次数相对于索引的偏移地址
;;;933    			addrBuf = (e2promCB.record[id].addr+2) + (e2promCB.record[id].index * ((sizeof(e2promCB.record[id].count)+1) + e2promCB.record[id].length));
;;;934    			E2PROM_WriteByteArray(addrBuf, dataBuf, sizeof(e2promCB.record[id].count)+1);  // 更新当前索引对应的次数值，包含了次数值的校验值
;;;935    		}
;;;936    	}
;;;937    	// 常规写入，间隔时间比较长的情况
;;;938    	else
;;;939    	{
;;;940    		e2promCB.size += length;
;;;941    
;;;942    		// 超出E2PROM空间大小
;;;943    		if ((E2PROM_SYSTEM_PARAM_ADDR_OFFSET + e2promCB.size) > EE_TOTAL_SIZE)
;;;944    		{
;;;945    			e2promCB.record[id].isExist = FALSE;
;;;946    			return;
;;;947    		}
;;;948    		
;;;949    		e2promCB.record[id].length = length;
;;;950    
;;;951    		e2promCB.record[id].index = 0;
;;;952    
;;;953    		e2promCB.record[id].count = 0;
;;;954    	}
;;;955    
;;;956    	// 执行到此，说明没有超出E2PROM空间大小
;;;957    	e2promCB.record[id].isExist = TRUE;
;;;958    
;;;959    }
000040  bdfe              POP      {r1-r7,pc}
                  |L21.66|
000042  8061              STRH     r1,[r4,#2]            ;878
000044  8820              LDRH     r0,[r4,#0]            ;881
000046  2202              MOVS     r2,#2                 ;881
000048  a902              ADD      r1,sp,#8              ;881
00004a  f7fffffe          BL       E2PROM_ReadByteArray
00004e  f89d0008          LDRB     r0,[sp,#8]            ;884
000052  f89d2009          LDRB     r2,[sp,#9]            ;884
000056  f10001a8          ADD      r1,r0,#0xa8           ;884
00005a  43c9              MVNS     r1,r1                 ;884
00005c  4291              CMP      r1,r2                 ;884
00005e  d101              BNE      |L21.100|
000060  7120              STRB     r0,[r4,#4]            ;886
000062  e00a              B        |L21.122|
                  |L21.100|
000064  7125              STRB     r5,[r4,#4]            ;891
000066  f88d5008          STRB     r5,[sp,#8]            ;892
00006a  2057              MOVS     r0,#0x57              ;893
00006c  f88d0009          STRB     r0,[sp,#9]            ;893
000070  8820              LDRH     r0,[r4,#0]            ;894
000072  2202              MOVS     r2,#2                 ;894
000074  a902              ADD      r1,sp,#8              ;894
000076  f7fffffe          BL       E2PROM_WriteByteArray
                  |L21.122|
00007a  8860              LDRH     r0,[r4,#2]            ;898
00007c  8821              LDRH     r1,[r4,#0]            ;898
00007e  7922              LDRB     r2,[r4,#4]            ;898
000080  1d40              ADDS     r0,r0,#5              ;898
000082  fb021000          MLA      r0,r2,r0,r1           ;898
000086  1c80              ADDS     r0,r0,#2              ;898
000088  b280              UXTH     r0,r0                 ;898
00008a  2205              MOVS     r2,#5                 ;899
00008c  4669              MOV      r1,sp                 ;899
00008e  f7fffffe          BL       E2PROM_ReadByteArray
000092  2100              MOVS     r1,#0                 ;902
000094  2000              MOVS     r0,#0                 ;903
000096  466a              MOV      r2,sp                 ;843
                  |L21.152|
000098  5c13              LDRB     r3,[r2,r0]            ;905
00009a  4419              ADD      r1,r1,r3              ;905
00009c  b2c9              UXTB     r1,r1                 ;905
00009e  1c40              ADDS     r0,r0,#1              ;903
0000a0  b2c0              UXTB     r0,r0                 ;903
0000a2  2804              CMP      r0,#4                 ;903
0000a4  d3f8              BCC      |L21.152|
0000a6  31a8              ADDS     r1,r1,#0xa8           ;907
0000a8  43c9              MVNS     r1,r1                 ;907
0000aa  b2c9              UXTB     r1,r1                 ;907
0000ac  5c10              LDRB     r0,[r2,r0]            ;910
0000ae  4288              CMP      r0,r1                 ;910
0000b0  d10c              BNE      |L21.204|
0000b2  2000              MOVS     r0,#0                 ;912
0000b4  60a5              STR      r5,[r4,#8]            ;912
0000b6  e006              B        |L21.198|
                  |L21.184|
0000b8  68a1              LDR      r1,[r4,#8]            ;914
0000ba  0209              LSLS     r1,r1,#8              ;914
0000bc  5c13              LDRB     r3,[r2,r0]            ;915
0000be  4319              ORRS     r1,r1,r3              ;915
0000c0  60a1              STR      r1,[r4,#8]            ;915
0000c2  1c40              ADDS     r0,r0,#1              ;912
0000c4  b2c0              UXTB     r0,r0                 ;912
                  |L21.198|
0000c6  2804              CMP      r0,#4                 ;912
0000c8  d3f6              BCC      |L21.184|
0000ca  e023              B        |L21.276|
                  |L21.204|
0000cc  60a5              STR      r5,[r4,#8]            ;921
0000ce  2100              MOVS     r1,#0                 ;924
0000d0  2000              MOVS     r0,#0                 ;925
                  |L21.210|
0000d2  5415              STRB     r5,[r2,r0]            ;927
0000d4  b2c9              UXTB     r1,r1                 ;928
0000d6  1c40              ADDS     r0,r0,#1              ;925
0000d8  b2c0              UXTB     r0,r0                 ;925
0000da  2804              CMP      r0,#4                 ;925
0000dc  d3f9              BCC      |L21.210|
0000de  31a8              ADDS     r1,r1,#0xa8           ;930
0000e0  43c9              MVNS     r1,r1                 ;930
0000e2  5411              STRB     r1,[r2,r0]            ;930
0000e4  8860              LDRH     r0,[r4,#2]            ;933
0000e6  8821              LDRH     r1,[r4,#0]            ;933
0000e8  7922              LDRB     r2,[r4,#4]            ;933
0000ea  1d40              ADDS     r0,r0,#5              ;933
0000ec  fb021000          MLA      r0,r2,r0,r1           ;933
0000f0  1c80              ADDS     r0,r0,#2              ;933
0000f2  b280              UXTH     r0,r0                 ;933
0000f4  2205              MOVS     r2,#5                 ;934
0000f6  4669              MOV      r1,sp                 ;934
0000f8  f7fffffe          BL       E2PROM_WriteByteArray
0000fc  e00a              B        |L21.276|
                  |L21.254|
0000fe  6e38              LDR      r0,[r7,#0x60]         ;940  ; e2promCB
000100  4408              ADD      r0,r0,r1              ;940
000102  6638              STR      r0,[r7,#0x60]         ;940  ; e2promCB
000104  300a              ADDS     r0,r0,#0xa            ;943
000106  4560              CMP      r0,r12                ;943
000108  d301              BCC      |L21.270|
00010a  7365              STRB     r5,[r4,#0xd]          ;945
00010c  bdfe              POP      {r1-r7,pc}
                  |L21.270|
00010e  8061              STRH     r1,[r4,#2]            ;949
000110  7125              STRB     r5,[r4,#4]            ;951
000112  60a5              STR      r5,[r4,#8]            ;953
                  |L21.276|
000114  7366              STRB     r6,[r4,#0xd]          ;957
000116  bdfe              POP      {r1-r7,pc}
;;;960    
                          ENDP

                  |L21.280|
                          DCD      ||.bss||

                          AREA ||i.E2PROM_ServiceRegister16bit||, CODE, READONLY, ALIGN=1

                  E2PROM_ServiceRegister16bit PROC
;;;967    // 注册长度为2个字节的参数，指定ID和访问模式
;;;968    void E2PROM_ServiceRegister16bit(E2PROM_ID id, E2PROM_ACCESS_MODE_E mode)
000000  460a              MOV      r2,r1
;;;969    {
;;;970    	E2PROM_ServiceRegister(id, 2, mode);
000002  2102              MOVS     r1,#2
000004  f7ffbffe          B.W      E2PROM_ServiceRegister
;;;971    }
;;;972    
                          ENDP


                          AREA ||i.E2PROM_ServiceRegister32bit||, CODE, READONLY, ALIGN=1

                  E2PROM_ServiceRegister32bit PROC
;;;973    // 注册长度为4个字节的参数，指定ID和访问模式
;;;974    void E2PROM_ServiceRegister32bit(E2PROM_ID id, E2PROM_ACCESS_MODE_E mode)
000000  460a              MOV      r2,r1
;;;975    {
;;;976    	E2PROM_ServiceRegister(id, 4, mode);
000002  2104              MOVS     r1,#4
000004  f7ffbffe          B.W      E2PROM_ServiceRegister
;;;977    }
;;;978    
                          ENDP


                          AREA ||i.E2PROM_ServiceRegister8bit||, CODE, READONLY, ALIGN=1

                  E2PROM_ServiceRegister8bit PROC
;;;961    // 注册长度为1个字节的参数，指定ID和访问模式
;;;962    void E2PROM_ServiceRegister8bit(E2PROM_ID id, E2PROM_ACCESS_MODE_E mode)
000000  460a              MOV      r2,r1
;;;963    {
;;;964    	E2PROM_ServiceRegister(id, 1, mode);
000002  2101              MOVS     r1,#1
000004  f7ffbffe          B.W      E2PROM_ServiceRegister
;;;965    }
;;;966    
                          ENDP


                          AREA ||i.E2PROM_ServiceWrite16bit||, CODE, READONLY, ALIGN=1

                  E2PROM_ServiceWrite16bit PROC
;;;1100   // 业务层写一个双字节
;;;1101   void E2PROM_ServiceWrite16bit(E2PROM_ID id, uint16 data)
000000  b508              PUSH     {r3,lr}
;;;1102   {
;;;1103   	uint8 dataBuf[2];
;;;1104   
;;;1105   	dataBuf[0] = data>>8;
000002  0a0a              LSRS     r2,r1,#8
000004  f88d2000          STRB     r2,[sp,#0]
;;;1106   	dataBuf[1] = data&0x00FF;
000008  f88d1001          STRB     r1,[sp,#1]
;;;1107   	
;;;1108   	E2PROM_ServiceWriteArray(id, dataBuf);
00000c  4669              MOV      r1,sp
00000e  f7fffffe          BL       E2PROM_ServiceWriteArray
;;;1109   }
000012  bd08              POP      {r3,pc}
;;;1110   
                          ENDP


                          AREA ||i.E2PROM_ServiceWrite32bit||, CODE, READONLY, ALIGN=1

                  E2PROM_ServiceWrite32bit PROC
;;;1111   // 业务层写一个四字节
;;;1112   void E2PROM_ServiceWrite32bit(E2PROM_ID id, uint32 data)
000000  b508              PUSH     {r3,lr}
;;;1113   {
;;;1114   	uint8 dataBuf[4];
;;;1115   
;;;1116   	dataBuf[0] = data>>24;
000002  0e0a              LSRS     r2,r1,#24
000004  f88d2000          STRB     r2,[sp,#0]
;;;1117   	dataBuf[1] = (data>>16)&0x00FF;
000008  0c0a              LSRS     r2,r1,#16
00000a  f88d2001          STRB     r2,[sp,#1]
;;;1118   	dataBuf[2] = (data>>8)&0x00FF;
00000e  0a0a              LSRS     r2,r1,#8
000010  f88d2002          STRB     r2,[sp,#2]
;;;1119   	dataBuf[3] = data&0x00FF;
000014  f88d1003          STRB     r1,[sp,#3]
;;;1120   	
;;;1121   	E2PROM_ServiceWriteArray(id, dataBuf);
000018  4669              MOV      r1,sp
00001a  f7fffffe          BL       E2PROM_ServiceWriteArray
;;;1122   }
00001e  bd08              POP      {r3,pc}
;;;1123   
                          ENDP


                          AREA ||i.E2PROM_ServiceWrite8bit||, CODE, READONLY, ALIGN=1

                  E2PROM_ServiceWrite8bit PROC
;;;1090   // 业务层写一个字节
;;;1091   void E2PROM_ServiceWrite8bit(E2PROM_ID id, uint8 data)
000000  b508              PUSH     {r3,lr}
;;;1092   {
;;;1093   	uint8 dataBuf[1];
;;;1094   
;;;1095   	dataBuf[0] = data;
000002  9100              STR      r1,[sp,#0]
;;;1096   	
;;;1097   	E2PROM_ServiceWriteArray(id, dataBuf);
000004  4669              MOV      r1,sp
000006  f7fffffe          BL       E2PROM_ServiceWriteArray
;;;1098   }
00000a  bd08              POP      {r3,pc}
;;;1099   
                          ENDP


                          AREA ||i.E2PROM_ServiceWriteArray||, CODE, READONLY, ALIGN=2

                  E2PROM_ServiceWriteArray PROC
;;;979    // 业务层写
;;;980    void E2PROM_ServiceWriteArray(E2PROM_ID id, uint8* pBuf)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;981    {
000004  460e              MOV      r6,r1
;;;982    	uint8 i;   
;;;983    	uint16 addrBuf;
;;;984    	uint8 dataBuf[sizeof(e2promCB.record[id].index)+1+sizeof(e2promCB.record[id].count)+1];
;;;985    	uint8 sumCheck;
;;;986    
;;;987    	// 参数合法性检验
;;;988    	if ((id >= E2PROM_ID_MAX) || (NULL == pBuf))
000006  2806              CMP      r0,#6
000008  da0f              BGE      |L28.42|
00000a  2e00              CMP      r6,#0
00000c  d00d              BEQ      |L28.42|
;;;989    	{
;;;990    		return;
;;;991    	}
;;;992    
;;;993    	// 此ID注册不成功
;;;994    	if (!e2promCB.record[id].isExist)
00000e  4950              LDR      r1,|L28.336|
000010  eb011400          ADD      r4,r1,r0,LSL #4
000014  7b60              LDRB     r0,[r4,#0xd]
000016  2800              CMP      r0,#0
000018  d007              BEQ      |L28.42|
;;;995    	{
;;;996    		return;
;;;997    	}
;;;998    
;;;999    	// 需要频繁写入
;;;1000   	if(E2PROM_ACCESS_MODE_QUITE_OFTEN == e2promCB.record[id].writeMode)
00001a  7b20              LDRB     r0,[r4,#0xc]
00001c  2801              CMP      r0,#1
00001e  d006              BEQ      |L28.46|
;;;1001   	{
;;;1002   		// 读取次数值
;;;1003   		addrBuf = (e2promCB.record[id].addr+2) + (e2promCB.record[id].index * ((sizeof(e2promCB.record[id].count)+1) + e2promCB.record[id].length));
;;;1004   		E2PROM_ReadByteArray(addrBuf, dataBuf, sizeof(e2promCB.record[id].count));
;;;1005   		for (i = 0, e2promCB.record[id].count = 0; i < sizeof(e2promCB.record[id].count); i++)
;;;1006   		{
;;;1007   			e2promCB.record[id].count <<= 8;
;;;1008   			e2promCB.record[id].count |= dataBuf[i];
;;;1009   		}
;;;1010   
;;;1011   		// 每写一次数据需要记录一次次数
;;;1012   		e2promCB.record[id].count++;	 
;;;1013   		
;;;1014   		if (e2promCB.record[id].count > E2PROM_ERASE_TIMES) // 擦写次数超过限制
;;;1015   		{
;;;1016   			// 将当前索引对应的擦写次数重新归零并写入EEPROM
;;;1017   			e2promCB.record[id].count = 0;
;;;1018   			
;;;1019   			// 计算检验值
;;;1020   			sumCheck = 0;
;;;1021   			for (i = 0; i < sizeof(e2promCB.record[id].count); i++)
;;;1022   			{
;;;1023   				dataBuf[i] = 0;
;;;1024   				sumCheck += dataBuf[i];
;;;1025   			}
;;;1026   			dataBuf[i] = ~(sumCheck + E2PROM_LOCKED_KEY);
;;;1027   			
;;;1028   			// 当前索引对应的擦写次数相对于索引的偏移地址
;;;1029   			addrBuf = (e2promCB.record[id].addr+2) + (e2promCB.record[id].index * ((sizeof(e2promCB.record[id].count)+1) + e2promCB.record[id].length));
;;;1030   			E2PROM_WriteByteArray(addrBuf, dataBuf, sizeof(e2promCB.record[id].count)+1);  // 更新当前索引对应的次数值，包含了次数值的校验值
;;;1031   			
;;;1032   			// 换下一个擦写空间
;;;1033   			e2promCB.record[id].index++;
;;;1034   			e2promCB.record[id].index %= E2PROM_MALLOC_SAVE_SPACE_COUNT;		// 超过指定分配的空间数
;;;1035   			
;;;1036   			// 计算校验值
;;;1037   			dataBuf[0] = e2promCB.record[id].index;
;;;1038   			dataBuf[1] = ~(e2promCB.record[id].index + E2PROM_LOCKED_KEY);
;;;1039   			E2PROM_WriteByteArray(e2promCB.record[id].addr, dataBuf, 2);  // 更新索引值，包含了索引的校验值
;;;1040   
;;;1041   			// 将新索引对应的次数值也清零
;;;1042   			sumCheck = 0;
;;;1043   			for (i = 0; i < sizeof(e2promCB.record[id].count); i++)
;;;1044   			{
;;;1045   				dataBuf[i] = 0;
;;;1046   				sumCheck += dataBuf[i];
;;;1047   			}
;;;1048   			dataBuf[i] = ~(sumCheck + E2PROM_LOCKED_KEY);
;;;1049   			
;;;1050   			// 校正次数相对于索引的偏移地址
;;;1051   			addrBuf = (e2promCB.record[id].addr+2) + (e2promCB.record[id].index * ((sizeof(e2promCB.record[id].count)+1) + e2promCB.record[id].length));
;;;1052   			E2PROM_WriteByteArray(addrBuf, dataBuf, sizeof(e2promCB.record[id].count)+1);  // 更新下一个索引对应的次数值，包含了次数值的校验值
;;;1053   
;;;1054   			// 写真正的数据
;;;1055   			// 校正真正数据相对于索引的偏移地址
;;;1056   			addrBuf = addrBuf + sizeof(e2promCB.record[id].count);
;;;1057   			E2PROM_WriteByteArray(addrBuf, pBuf, e2promCB.record[id].length);
;;;1058   		}
;;;1059   		else
;;;1060   		{
;;;1061   			// 此处的索引值保持不变
;;;1062   			
;;;1063   			// 写次数
;;;1064   			// 次数的地址需要根据索引来寻址
;;;1065   			sumCheck = 0;
;;;1066   			for (i = 0; i < sizeof(e2promCB.record[id].count); i++)
;;;1067   			{
;;;1068   				dataBuf[i] = (uint8)(e2promCB.record[id].count >> ((sizeof(e2promCB.record[id].count) - (i + 1)) * 8));
;;;1069   				sumCheck += dataBuf[i];
;;;1070   			}
;;;1071   			dataBuf[i] = ~(sumCheck + E2PROM_LOCKED_KEY);
;;;1072   			
;;;1073   			// 校正次数相对于索引的偏移地址
;;;1074   			addrBuf = (e2promCB.record[id].addr+2) + (e2promCB.record[id].index * ((sizeof(e2promCB.record[id].count)+1) + e2promCB.record[id].length));
;;;1075   			E2PROM_WriteByteArray(addrBuf, dataBuf, sizeof(e2promCB.record[id].count)+1);
;;;1076   
;;;1077   			// 写真正的数据
;;;1078   			// 校正真正数据相对于索引的偏移地址
;;;1079   			addrBuf = addrBuf + (sizeof(e2promCB.record[id].count)+1);
;;;1080   			E2PROM_WriteByteArray(addrBuf, pBuf, e2promCB.record[id].length);
;;;1081   		}
;;;1082   	}
;;;1083   	// 常规写入，间隔时间比较长的情况
;;;1084   	else
;;;1085   	{
;;;1086   		E2PROM_WriteByteArray(e2promCB.record[id].addr, pBuf, e2promCB.record[id].length);
000020  8862              LDRH     r2,[r4,#2]
000022  8820              LDRH     r0,[r4,#0]
000024  4631              MOV      r1,r6
000026  f7fffffe          BL       E2PROM_WriteByteArray
                  |L28.42|
;;;1087   	}
;;;1088   }
00002a  e8bd81fc          POP      {r2-r8,pc}
                  |L28.46|
00002e  8860              LDRH     r0,[r4,#2]            ;1003
000030  8821              LDRH     r1,[r4,#0]            ;1003
000032  7922              LDRB     r2,[r4,#4]            ;1003
000034  1d40              ADDS     r0,r0,#5              ;1003
000036  fb021000          MLA      r0,r2,r0,r1           ;1003
00003a  1c80              ADDS     r0,r0,#2              ;1003
00003c  b280              UXTH     r0,r0                 ;1003
00003e  2204              MOVS     r2,#4                 ;1004
000040  4669              MOV      r1,sp                 ;1004
000042  f7fffffe          BL       E2PROM_ReadByteArray
000046  2000              MOVS     r0,#0                 ;1005
000048  2700              MOVS     r7,#0                 ;1005
00004a  60a7              STR      r7,[r4,#8]            ;1005
00004c  466d              MOV      r5,sp                 ;984
00004e  e006              B        |L28.94|
                  |L28.80|
000050  68a1              LDR      r1,[r4,#8]            ;1007
000052  0209              LSLS     r1,r1,#8              ;1007
000054  5c2a              LDRB     r2,[r5,r0]            ;1008
000056  4311              ORRS     r1,r1,r2              ;1008
000058  60a1              STR      r1,[r4,#8]            ;1008
00005a  1c40              ADDS     r0,r0,#1              ;1005
00005c  b2c0              UXTB     r0,r0                 ;1005
                  |L28.94|
00005e  2804              CMP      r0,#4                 ;1005
000060  d3f6              BCC      |L28.80|
000062  68a3              LDR      r3,[r4,#8]            ;1012
000064  1c5b              ADDS     r3,r3,#1              ;1012
000066  60a3              STR      r3,[r4,#8]            ;1012
000068  483a              LDR      r0,|L28.340|
00006a  4283              CMP      r3,r0                 ;1014
00006c  d94a              BLS      |L28.260|
00006e  60a7              STR      r7,[r4,#8]            ;1017
000070  2200              MOVS     r2,#0                 ;1020
000072  2000              MOVS     r0,#0                 ;1021
                  |L28.116|
000074  542f              STRB     r7,[r5,r0]            ;1023
000076  b2d2              UXTB     r2,r2                 ;1024
000078  1c40              ADDS     r0,r0,#1              ;1021
00007a  b2c0              UXTB     r0,r0                 ;1021
00007c  2804              CMP      r0,#4                 ;1021
00007e  d3f9              BCC      |L28.116|
000080  32a8              ADDS     r2,r2,#0xa8           ;1026
000082  43d1              MVNS     r1,r2                 ;1026
000084  5429              STRB     r1,[r5,r0]            ;1026
000086  8860              LDRH     r0,[r4,#2]            ;1029
000088  8821              LDRH     r1,[r4,#0]            ;1029
00008a  7922              LDRB     r2,[r4,#4]            ;1029
00008c  1d40              ADDS     r0,r0,#5              ;1029
00008e  fb021000          MLA      r0,r2,r0,r1           ;1029
000092  1c80              ADDS     r0,r0,#2              ;1029
000094  b280              UXTH     r0,r0                 ;1029
000096  2205              MOVS     r2,#5                 ;1030
000098  4669              MOV      r1,sp                 ;1030
00009a  f7fffffe          BL       E2PROM_WriteByteArray
00009e  7920              LDRB     r0,[r4,#4]            ;1033
0000a0  1c40              ADDS     r0,r0,#1              ;1033
0000a2  b2c0              UXTB     r0,r0                 ;1033
0000a4  210a              MOVS     r1,#0xa               ;1034
0000a6  fbb0f2f1          UDIV     r2,r0,r1              ;1034
0000aa  fb010012          MLS      r0,r1,r2,r0           ;1034
0000ae  7120              STRB     r0,[r4,#4]            ;1034
0000b0  f88d0000          STRB     r0,[sp,#0]            ;1037
0000b4  30a8              ADDS     r0,r0,#0xa8           ;1038
0000b6  43c0              MVNS     r0,r0                 ;1038
0000b8  f88d0001          STRB     r0,[sp,#1]            ;1038
0000bc  8820              LDRH     r0,[r4,#0]            ;1039
0000be  2202              MOVS     r2,#2                 ;1039
0000c0  4669              MOV      r1,sp                 ;1039
0000c2  f7fffffe          BL       E2PROM_WriteByteArray
0000c6  2100              MOVS     r1,#0                 ;1042
0000c8  2000              MOVS     r0,#0                 ;1043
                  |L28.202|
0000ca  542f              STRB     r7,[r5,r0]            ;1045
0000cc  b2c9              UXTB     r1,r1                 ;1046
0000ce  1c40              ADDS     r0,r0,#1              ;1043
0000d0  b2c0              UXTB     r0,r0                 ;1043
0000d2  2804              CMP      r0,#4                 ;1043
0000d4  d3f9              BCC      |L28.202|
0000d6  31a8              ADDS     r1,r1,#0xa8           ;1048
0000d8  43c9              MVNS     r1,r1                 ;1048
0000da  5429              STRB     r1,[r5,r0]            ;1048
0000dc  8860              LDRH     r0,[r4,#2]            ;1051
0000de  8821              LDRH     r1,[r4,#0]            ;1051
0000e0  7922              LDRB     r2,[r4,#4]            ;1051
0000e2  1d40              ADDS     r0,r0,#5              ;1051
0000e4  fb021000          MLA      r0,r2,r0,r1           ;1051
0000e8  1c80              ADDS     r0,r0,#2              ;1051
0000ea  b285              UXTH     r5,r0                 ;1051
0000ec  2205              MOVS     r2,#5                 ;1052
0000ee  4669              MOV      r1,sp                 ;1052
0000f0  4628              MOV      r0,r5                 ;1052
0000f2  f7fffffe          BL       E2PROM_WriteByteArray
0000f6  1d2d              ADDS     r5,r5,#4              ;1056
0000f8  b2a8              UXTH     r0,r5                 ;1056
0000fa  8862              LDRH     r2,[r4,#2]            ;1057
0000fc  4631              MOV      r1,r6                 ;1057
0000fe  f7fffffe          BL       E2PROM_WriteByteArray
000102  e792              B        |L28.42|
                  |L28.260|
000104  2100              MOVS     r1,#0                 ;1065
000106  2000              MOVS     r0,#0                 ;1066
                  |L28.264|
000108  f1c00703          RSB      r7,r0,#3              ;1068
00010c  00ff              LSLS     r7,r7,#3              ;1068
00010e  fa23f207          LSR      r2,r3,r7              ;1068
000112  542a              STRB     r2,[r5,r0]            ;1068
000114  4411              ADD      r1,r1,r2              ;1069
000116  b2c9              UXTB     r1,r1                 ;1069
000118  1c40              ADDS     r0,r0,#1              ;1066
00011a  b2c0              UXTB     r0,r0                 ;1066
00011c  2804              CMP      r0,#4                 ;1066
00011e  d3f3              BCC      |L28.264|
000120  31a8              ADDS     r1,r1,#0xa8           ;1071
000122  43c9              MVNS     r1,r1                 ;1071
000124  5429              STRB     r1,[r5,r0]            ;1071
000126  8860              LDRH     r0,[r4,#2]            ;1074
000128  8821              LDRH     r1,[r4,#0]            ;1074
00012a  7922              LDRB     r2,[r4,#4]            ;1074
00012c  1d40              ADDS     r0,r0,#5              ;1074
00012e  fb021000          MLA      r0,r2,r0,r1           ;1074
000132  1c80              ADDS     r0,r0,#2              ;1074
000134  b285              UXTH     r5,r0                 ;1074
000136  2205              MOVS     r2,#5                 ;1075
000138  4669              MOV      r1,sp                 ;1075
00013a  4628              MOV      r0,r5                 ;1075
00013c  f7fffffe          BL       E2PROM_WriteByteArray
000140  1d6d              ADDS     r5,r5,#5              ;1079
000142  b2a8              UXTH     r0,r5                 ;1079
000144  8862              LDRH     r2,[r4,#2]            ;1080
000146  4631              MOV      r1,r6                 ;1080
000148  f7fffffe          BL       E2PROM_WriteByteArray
00014c  e76d              B        |L28.42|
;;;1089   
                          ENDP

00014e  0000              DCW      0x0000
                  |L28.336|
                          DCD      ||.bss||
                  |L28.340|
                          DCD      0x000c3500

                          AREA ||i.E2PROM_ServiceWriteByID||, CODE, READONLY, ALIGN=2

                  E2PROM_ServiceWriteByID PROC
;;;1226   // 根据ID写入数值
;;;1227   void E2PROM_ServiceWriteByID(E2PROM_ID id, uint32 param)
000000  4a09              LDR      r2,|L29.40|
;;;1228   {
;;;1229   	if(1 == e2promCB.record[id].length)
000002  eb021200          ADD      r2,r2,r0,LSL #4
000006  8852              LDRH     r2,[r2,#2]
000008  2a01              CMP      r2,#1
00000a  d005              BEQ      |L29.24|
;;;1230   	{
;;;1231   		E2PROM_ServiceWrite8bit(id, (uint8)param);
;;;1232   	}
;;;1233   	else if(2 == e2promCB.record[id].length)
00000c  2a02              CMP      r2,#2
00000e  d006              BEQ      |L29.30|
;;;1234   	{
;;;1235   		E2PROM_ServiceWrite16bit(id, (uint16)param);
;;;1236   	}
;;;1237   	else if(4 == e2promCB.record[id].length)
000010  2a04              CMP      r2,#4
000012  d107              BNE      |L29.36|
;;;1238   	{
;;;1239   		E2PROM_ServiceWrite32bit(id, param);
000014  f7ffbffe          B.W      E2PROM_ServiceWrite32bit
                  |L29.24|
000018  b2c9              UXTB     r1,r1                 ;1231
00001a  f7ffbffe          B.W      E2PROM_ServiceWrite8bit
                  |L29.30|
00001e  b289              UXTH     r1,r1                 ;1235
000020  f7ffbffe          B.W      E2PROM_ServiceWrite16bit
                  |L29.36|
;;;1240   	}
;;;1241   	else
;;;1242   	{}
;;;1243   }
000024  4770              BX       lr
;;;1244   
                          ENDP

000026  0000              DCW      0x0000
                  |L29.40|
                          DCD      ||.bss||

                          AREA ||i.E2PROM_WriteByte||, CODE, READONLY, ALIGN=1

                  E2PROM_WriteByte PROC
;;;584    // 写入一个字节
;;;585    void E2PROM_WriteByte(uint16 writeAddr, uint8 data)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;586    {
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
;;;587    	uint8 dataCheck = ~data;
000008  43e8              MVNS     r0,r5
00000a  b2c0              UXTB     r0,r0
;;;588    	uint8 retry = 5;
00000c  2405              MOVS     r4,#5
;;;589    	uint8 addrH = (uint8)(writeAddr >> 8);	 // 取高8位地址
00000e  0a37              LSRS     r7,r6,#8
;;;590    	uint8 addrL = (uint8)writeAddr; 		 // 取低8位地址
000010  f00608ff          AND      r8,r6,#0xff
000014  e017              B        |L30.70|
                  |L30.22|
;;;591    
;;;592    	// 判断存储地址是否超过8位
;;;593    #if EEPROM_TYPE <= EEPROM_24C16
;;;594    	while((dataCheck != data)&&(retry))
;;;595    	{
;;;596    		retry--;
;;;597    
;;;598    		E2PROM_I2C_Start();
;;;599    		E2PROM_I2C_WriteByte((addrH<<1) | EEPROM_WRCOMMAND);	// 设备地址也是字节地址的高8位
;;;600    		E2PROM_I2C_WriteByte(addrL);
;;;601    	   
;;;602    		E2PROM_I2C_WriteByte(data);
;;;603    		
;;;604    		E2PROM_I2C_Stop();
;;;605    
;;;606    		// 延时ms级别等待buf数据写入EEPROM
;;;607    		E2PROM_DELAY_MS();
;;;608    
;;;609    		dataCheck = E2PROM_ReadByte(writeAddr);
;;;610    	}
;;;611    
;;;612    #else
;;;613    	while((dataCheck != data)&&(retry))
;;;614    	{
;;;615    		retry--;
000016  1e64              SUBS     r4,r4,#1
000018  b2e4              UXTB     r4,r4
;;;616    
;;;617    		E2PROM_I2C_Start();
00001a  f7fffffe          BL       E2PROM_I2C_Start
;;;618    		E2PROM_I2C_WriteByte(EEPROM_WRCOMMAND);
00001e  20a0              MOVS     r0,#0xa0
000020  f7fffffe          BL       E2PROM_I2C_WriteByte
;;;619    		E2PROM_I2C_WriteByte(addrH);
000024  4638              MOV      r0,r7
000026  f7fffffe          BL       E2PROM_I2C_WriteByte
;;;620    		E2PROM_I2C_WriteByte(addrL);
00002a  4640              MOV      r0,r8
00002c  f7fffffe          BL       E2PROM_I2C_WriteByte
;;;621    		
;;;622    		E2PROM_I2C_WriteByte(data);
000030  4628              MOV      r0,r5
000032  f7fffffe          BL       E2PROM_I2C_WriteByte
;;;623    
;;;624    		E2PROM_I2C_Stop();
000036  f7fffffe          BL       E2PROM_I2C_Stop
;;;625    
;;;626    		// 延时ms级别等待buf数据写入EEPROM
;;;627    		E2PROM_DELAY_MS();
00003a  2005              MOVS     r0,#5
00003c  f7fffffe          BL       E2PROM_Delayms
;;;628    
;;;629    		dataCheck = E2PROM_ReadByte(writeAddr);
000040  4630              MOV      r0,r6
000042  f7fffffe          BL       E2PROM_ReadByte
                  |L30.70|
000046  42a8              CMP      r0,r5                 ;613
000048  d001              BEQ      |L30.78|
00004a  2c00              CMP      r4,#0                 ;613
00004c  d1e3              BNE      |L30.22|
                  |L30.78|
;;;630    	}
;;;631    
;;;632    #endif
;;;633    }
00004e  e8bd81f0          POP      {r4-r8,pc}
;;;634    
                          ENDP


                          AREA ||i.E2PROM_WriteByteArray||, CODE, READONLY, ALIGN=1

                  E2PROM_WriteByteArray PROC
;;;374    // 写数据，整个地址内，无需考虑页问题
;;;375    BOOL E2PROM_WriteByteArray(uint16 writeAddr, uint8* pBuf, uint16 writeNum)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;376    {
000004  4605              MOV      r5,r0
000006  4688              MOV      r8,r1
000008  4614              MOV      r4,r2
;;;377    	uint16 pageNum = 0;
;;;378    	uint16 singleNum = 0;
;;;379    	uint16 part = 0;
;;;380    
;;;381    	// 地址不能超出总空间大小
;;;382    	if (writeAddr > EE_TOTAL_SIZE)
00000a  f44f5100          MOV      r1,#0x2000
00000e  428d              CMP      r5,r1
000010  d302              BCC      |L31.24|
;;;383    	{
;;;384    		return FALSE;
000012  2000              MOVS     r0,#0
                  |L31.20|
;;;385    	}
;;;386    
;;;387    	// 写的数量超出总空间大小
;;;388    	if ((writeAddr + writeNum) > EE_TOTAL_SIZE) 
;;;389    	{
;;;390    		return FALSE;
;;;391    	}
;;;392    
;;;393    	// 空指针
;;;394    	if (NULL == pBuf)
;;;395    	{
;;;396    		return FALSE;
;;;397    	}
;;;398    
;;;399    	// 判断起始地址所在的页剩余可写字节个数
;;;400    	part = writeAddr / EE_PAGE_SIZE;			// 起始地址所在的页
;;;401    	part = EE_PAGE_SIZE*(part+1) - writeAddr;	// 此页剩余可写入字节个数
;;;402    
;;;403    	// 判断是否需要跨页写入
;;;404    	if (part >= writeNum)	// 写入的数据个数小于跨页剩余的个数可直接写入
;;;405    	{
;;;406    		E2PROM_WritePageBuf(writeAddr, pBuf, writeNum);
;;;407    	}
;;;408    	else					// 当前页个数不足，需要跨页算法写入
;;;409    	{
;;;410    		// 1.先把当前地址所在的页填充满
;;;411    		E2PROM_WritePageBuf(writeAddr, pBuf, part);
;;;412    
;;;413    		// 2.计算剩余页数及不足一页的字节数
;;;414    		pageNum = (writeNum - part) / EE_PAGE_SIZE; 
;;;415    		singleNum = (writeNum - part) % EE_PAGE_SIZE; 
;;;416    
;;;417    		// 3.计算剩余总个数及下一页开始地址和数据指针
;;;418    		writeNum -= part;	// 剩余写入个数
;;;419    		writeAddr += part;	// 下一页写入地址
;;;420    		pBuf += part;		// 下一页写入指针
;;;421    
;;;422    		// 4.按计算的数据量占页面数，连续写入页面
;;;423    		while (pageNum--)
;;;424    		{ 
;;;425    			E2PROM_WritePageBuf(writeAddr, pBuf, EE_PAGE_SIZE);
;;;426    			
;;;427    			// 每写满一页，地址自增一页，数据指针也自增一页地址
;;;428    			writeAddr += EE_PAGE_SIZE;
;;;429    			pBuf += EE_PAGE_SIZE; 
;;;430    		}
;;;431    
;;;432    		// 5.补充页面写完后超出的不足一页数据量的数据
;;;433    		if (0 != singleNum)
;;;434    		{
;;;435    			E2PROM_WritePageBuf(writeAddr, pBuf, singleNum);
;;;436    		}
;;;437    	}
;;;438      
;;;439    	return TRUE;
;;;440    }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L31.24|
000018  1928              ADDS     r0,r5,r4              ;388
00001a  4288              CMP      r0,r1                 ;388
00001c  d301              BCC      |L31.34|
00001e  2000              MOVS     r0,#0                 ;390
000020  e7f8              B        |L31.20|
                  |L31.34|
000022  f1b80f00          CMP      r8,#0                 ;394
000026  d00c              BEQ      |L31.66|
000028  0968              LSRS     r0,r5,#5              ;400
00002a  1c40              ADDS     r0,r0,#1              ;401
00002c  ebc51040          RSB      r0,r5,r0,LSL #5       ;401
000030  b286              UXTH     r6,r0                 ;401
000032  42a6              CMP      r6,r4                 ;404
000034  d307              BCC      |L31.70|
000036  4622              MOV      r2,r4                 ;406
000038  4641              MOV      r1,r8                 ;406
00003a  4628              MOV      r0,r5                 ;406
00003c  f7fffffe          BL       E2PROM_WritePageBuf
000040  e025              B        |L31.142|
                  |L31.66|
000042  2000              MOVS     r0,#0                 ;396
000044  e7e6              B        |L31.20|
                  |L31.70|
000046  4632              MOV      r2,r6                 ;411
000048  4641              MOV      r1,r8                 ;411
00004a  4628              MOV      r0,r5                 ;411
00004c  f7fffffe          BL       E2PROM_WritePageBuf
000050  1ba0              SUBS     r0,r4,r6              ;414
000052  17c1              ASRS     r1,r0,#31             ;414
000054  eb0061d1          ADD      r1,r0,r1,LSR #27      ;414
000058  f3c1144f          UBFX     r4,r1,#5,#16          ;414
00005c  f021011f          BIC      r1,r1,#0x1f           ;415
000060  1a40              SUBS     r0,r0,r1              ;415
000062  b287              UXTH     r7,r0                 ;415
000064  19a8              ADDS     r0,r5,r6              ;419
000066  b285              UXTH     r5,r0                 ;419
000068  4446              ADD      r6,r6,r8              ;420
00006a  e007              B        |L31.124|
                  |L31.108|
00006c  2220              MOVS     r2,#0x20              ;425
00006e  4631              MOV      r1,r6                 ;425
000070  4628              MOV      r0,r5                 ;425
000072  f7fffffe          BL       E2PROM_WritePageBuf
000076  3520              ADDS     r5,r5,#0x20           ;428
000078  b2ad              UXTH     r5,r5                 ;428
00007a  3620              ADDS     r6,r6,#0x20           ;429
                  |L31.124|
00007c  1e64              SUBS     r4,r4,#1              ;423
00007e  b2a4              UXTH     r4,r4                 ;423
000080  d2f4              BCS      |L31.108|
000082  b127              CBZ      r7,|L31.142|
000084  463a              MOV      r2,r7                 ;435
000086  4631              MOV      r1,r6                 ;435
000088  4628              MOV      r0,r5                 ;435
00008a  f7fffffe          BL       E2PROM_WritePageBuf
                  |L31.142|
00008e  2001              MOVS     r0,#1                 ;439
000090  e7c0              B        |L31.20|
;;;441    
                          ENDP


                          AREA ||i.E2PROM_WriteInt||, CODE, READONLY, ALIGN=1

                  E2PROM_WriteInt PROC
;;;635    // 写入一个双字节数值
;;;636    void E2PROM_WriteInt(uint16 writeAddr, uint16 data)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;637    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;638    	uint8 addrH;
;;;639    	uint8 addrL;
;;;640    	uint8 localData;
;;;641    	uint8 i = 2;
000008  2402              MOVS     r4,#2
;;;642    	uint8 page = writeAddr/EE_PAGE_SIZE;
00000a  f3c51747          UBFX     r7,r5,#5,#8
00000e  e02d              B        |L32.108|
                  |L32.16|
;;;643    
;;;644    	// 判断存储地址是否超过8位
;;;645    #if EEPROM_TYPE <= EEPROM_24C16
;;;646    	while(i)
;;;647    	{
;;;648    		addrH = (uint8)(writeAddr >> 8);	// 取高8位地址
;;;649    		addrL = (uint8)writeAddr; 		 	// 取低8位地址
;;;650    		localData = data >> (8*(i-1));
;;;651    	
;;;652    		E2PROM_I2C_Start();
;;;653    		E2PROM_I2C_WriteByte((addrH<<1) | EEPROM_WRCOMMAND);	// 设备地址也是字节地址的高8位
;;;654    		E2PROM_I2C_WriteByte(addrL);
;;;655    
;;;656    		while(i)
;;;657    		{
;;;658    			E2PROM_I2C_WriteByte(localData);
;;;659    			writeAddr++;
;;;660    			i--;
;;;661    			localData = data >> (8*(i-1));
;;;662    
;;;663    			// 页切换，重新开始
;;;664    			if(page != writeAddr/EE_PAGE_SIZE)
;;;665    			{
;;;666    				break;
;;;667    			}
;;;668    		}
;;;669    		
;;;670    		E2PROM_I2C_Stop();
;;;671    
;;;672    		// 延时ms级别等待buf数据写入EEPROM
;;;673    		E2PROM_DELAY_MS();
;;;674    	}
;;;675    
;;;676    #else
;;;677    	while(i)
;;;678    	{
;;;679    		addrH = (uint8)(writeAddr >> 8);	// 取高8位地址
000010  ea4f2915          LSR      r9,r5,#8
;;;680    		addrL = (uint8)writeAddr; 		 	// 取低8位地址
000014  f0050aff          AND      r10,r5,#0xff
;;;681    		localData = data >> (8*(i-1));
000018  1e60              SUBS     r0,r4,#1
00001a  00c0              LSLS     r0,r0,#3
00001c  fa26f000          LSR      r0,r6,r0
000020  f00008ff          AND      r8,r0,#0xff
;;;682    	
;;;683    		E2PROM_I2C_Start();
000024  f7fffffe          BL       E2PROM_I2C_Start
;;;684    		E2PROM_I2C_WriteByte(EEPROM_WRCOMMAND);
000028  20a0              MOVS     r0,#0xa0
00002a  f7fffffe          BL       E2PROM_I2C_WriteByte
;;;685    		E2PROM_I2C_WriteByte(addrH);
00002e  4648              MOV      r0,r9
000030  f7fffffe          BL       E2PROM_I2C_WriteByte
;;;686    		E2PROM_I2C_WriteByte(addrL);
000034  4650              MOV      r0,r10
000036  f7fffffe          BL       E2PROM_I2C_WriteByte
;;;687    
;;;688    		while(i)
00003a  e010              B        |L32.94|
                  |L32.60|
;;;689    		{
;;;690    			E2PROM_I2C_WriteByte(localData);
00003c  4640              MOV      r0,r8
00003e  f7fffffe          BL       E2PROM_I2C_WriteByte
;;;691    			writeAddr++;
000042  1c6d              ADDS     r5,r5,#1
000044  b2ad              UXTH     r5,r5
;;;692    			i--;
000046  1e64              SUBS     r4,r4,#1
000048  b2e4              UXTB     r4,r4
;;;693    			
;;;694    			if(i != 0)
00004a  b12c              CBZ      r4,|L32.88|
;;;695    			{
;;;696    				localData = data >> (8*(i-1));
00004c  1e60              SUBS     r0,r4,#1
00004e  00c0              LSLS     r0,r0,#3
000050  fa26f000          LSR      r0,r6,r0
000054  f00008ff          AND      r8,r0,#0xff
                  |L32.88|
;;;697    			}
;;;698    
;;;699    			// 页切换，重新开始
;;;700    			if(page != writeAddr/EE_PAGE_SIZE)
000058  ebb71f55          CMP      r7,r5,LSR #5
00005c  d101              BNE      |L32.98|
                  |L32.94|
00005e  2c00              CMP      r4,#0                 ;688
000060  d1ec              BNE      |L32.60|
                  |L32.98|
;;;701    			{
;;;702    				break;
;;;703    			}
;;;704    		}
;;;705    
;;;706    		E2PROM_I2C_Stop();
000062  f7fffffe          BL       E2PROM_I2C_Stop
;;;707    
;;;708    		// 延时ms级别等待buf数据写入EEPROM
;;;709    		E2PROM_DELAY_MS();
000066  2005              MOVS     r0,#5
000068  f7fffffe          BL       E2PROM_Delayms
                  |L32.108|
00006c  2c00              CMP      r4,#0                 ;677
00006e  d1cf              BNE      |L32.16|
;;;710    	}
;;;711    
;;;712    #endif
;;;713    }
000070  e8bd87f0          POP      {r4-r10,pc}
;;;714    
                          ENDP


                          AREA ||i.E2PROM_WritePageBuf||, CODE, READONLY, ALIGN=1

                  E2PROM_WritePageBuf PROC
;;;255    // I2C在页内写数据
;;;256    void E2PROM_WritePageBuf(uint16 writeAddr, uint8 *pBuf, uint16 writeNum)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;257    {
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;258    	uint16	i = 0;
000008  2400              MOVS     r4,#0
;;;259    	uint8 addrH = (uint8)(writeAddr >> 8);	 // 取高8位地址
00000a  0a07              LSRS     r7,r0,#8
;;;260    	uint8 addrL = (uint8)writeAddr; 		 // 取低8位地址
00000c  f00008ff          AND      r8,r0,#0xff
;;;261    
;;;262    	// 判断存储地址是否超过8位
;;;263    #if EEPROM_TYPE <= EEPROM_24C16
;;;264    
;;;265    	E2PROM_I2C_Start();
;;;266    	E2PROM_I2C_WriteByte((addrH<<1) | EEPROM_WRCOMMAND);	// 设备地址也是字节地址的高8位
;;;267    	E2PROM_I2C_WriteByte(addrL);
;;;268       
;;;269    	while (i < writeNum)
;;;270    	{
;;;271    		E2PROM_I2C_WriteByte(pBuf[i++]);
;;;272    	}
;;;273    	E2PROM_I2C_Stop();
;;;274    
;;;275    	// 延时ms级别等待buf数据写入EEPROM
;;;276    	E2PROM_DELAY_MS();
;;;277    
;;;278    #else
;;;279    
;;;280    	E2PROM_I2C_Start();
000010  f7fffffe          BL       E2PROM_I2C_Start
;;;281    	E2PROM_I2C_WriteByte(EEPROM_WRCOMMAND);
000014  20a0              MOVS     r0,#0xa0
000016  f7fffffe          BL       E2PROM_I2C_WriteByte
;;;282    	E2PROM_I2C_WriteByte(addrH);
00001a  4638              MOV      r0,r7
00001c  f7fffffe          BL       E2PROM_I2C_WriteByte
;;;283    	E2PROM_I2C_WriteByte(addrL);
000020  4640              MOV      r0,r8
000022  f7fffffe          BL       E2PROM_I2C_WriteByte
;;;284    	
;;;285    	while (i < writeNum)
000026  e005              B        |L33.52|
                  |L33.40|
;;;286    	{
;;;287    		E2PROM_I2C_WriteByte(pBuf[i++]);
000028  4620              MOV      r0,r4
00002a  1c64              ADDS     r4,r4,#1
00002c  b2a4              UXTH     r4,r4
00002e  5c28              LDRB     r0,[r5,r0]
000030  f7fffffe          BL       E2PROM_I2C_WriteByte
                  |L33.52|
000034  42b4              CMP      r4,r6                 ;285
000036  d3f7              BCC      |L33.40|
;;;288    	}
;;;289    	E2PROM_I2C_Stop();
000038  f7fffffe          BL       E2PROM_I2C_Stop
;;;290    
;;;291    	// 延时ms级别等待buf数据写入EEPROM
;;;292    	E2PROM_DELAY_MS();
00003c  e8bd41f0          POP      {r4-r8,lr}
000040  2005              MOVS     r0,#5
000042  f7ffbffe          B.W      E2PROM_Delayms
;;;293    
;;;294    #endif
;;;295    }
;;;296    
                          ENDP


                          AREA ||i.E2PROM_WriteWord||, CODE, READONLY, ALIGN=1

                  E2PROM_WriteWord PROC
;;;715    // 写入一个四字节数值
;;;716    void E2PROM_WriteWord(uint16 writeAddr, uint32 data)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;717    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;718    	uint8 addrH;
;;;719    	uint8 addrL;
;;;720    	uint8 localData;
;;;721    	uint8 i = 4;
000008  2404              MOVS     r4,#4
;;;722    	uint8 page = writeAddr/EE_PAGE_SIZE;
00000a  f3c51747          UBFX     r7,r5,#5,#8
00000e  e02d              B        |L34.108|
                  |L34.16|
;;;723    
;;;724    	// 判断存储地址是否超过8位
;;;725    #if EEPROM_TYPE <= EEPROM_24C16
;;;726    	while(i)
;;;727    	{
;;;728    		addrH = (uint8)(writeAddr >> 8);	// 取高8位地址
;;;729    		addrL = (uint8)writeAddr; 		 	// 取低8位地址
;;;730    		localData = data >> (8*(i-1));
;;;731    	
;;;732    		E2PROM_I2C_Start();
;;;733    		E2PROM_I2C_WriteByte((addrH<<1) | EEPROM_WRCOMMAND);	// 设备地址也是字节地址的高8位
;;;734    		E2PROM_I2C_WriteByte(addrL);
;;;735    
;;;736    		while(i)
;;;737    		{
;;;738    			E2PROM_I2C_WriteByte(localData);
;;;739    			writeAddr++;
;;;740    			i--;
;;;741    
;;;742    			if(i != 0)
;;;743    			{
;;;744    				localData = data >> (8*(i-1));
;;;745    			}
;;;746    
;;;747    			// 页切换，重新开始
;;;748    			if(page != writeAddr/EE_PAGE_SIZE)
;;;749    			{
;;;750    				break;
;;;751    			}
;;;752    		}
;;;753    		
;;;754    		E2PROM_I2C_Stop();
;;;755    
;;;756    		// 延时ms级别等待buf数据写入EEPROM
;;;757    		E2PROM_DELAY_MS();
;;;758    	}
;;;759    
;;;760    #else
;;;761    	while(i)
;;;762    	{
;;;763    		addrH = (uint8)(writeAddr >> 8);	// 取高8位地址
000010  ea4f2915          LSR      r9,r5,#8
;;;764    		addrL = (uint8)writeAddr; 		 	// 取低8位地址
000014  f0050aff          AND      r10,r5,#0xff
;;;765    		localData = data >> (8*(i-1));
000018  1e60              SUBS     r0,r4,#1
00001a  00c0              LSLS     r0,r0,#3
00001c  fa26f000          LSR      r0,r6,r0
000020  f00008ff          AND      r8,r0,#0xff
;;;766    	
;;;767    		E2PROM_I2C_Start();
000024  f7fffffe          BL       E2PROM_I2C_Start
;;;768    		E2PROM_I2C_WriteByte(EEPROM_WRCOMMAND);
000028  20a0              MOVS     r0,#0xa0
00002a  f7fffffe          BL       E2PROM_I2C_WriteByte
;;;769    		E2PROM_I2C_WriteByte(addrH);
00002e  4648              MOV      r0,r9
000030  f7fffffe          BL       E2PROM_I2C_WriteByte
;;;770    		E2PROM_I2C_WriteByte(addrL);
000034  4650              MOV      r0,r10
000036  f7fffffe          BL       E2PROM_I2C_WriteByte
;;;771    
;;;772    		while(i)
00003a  e010              B        |L34.94|
                  |L34.60|
;;;773    		{
;;;774    			E2PROM_I2C_WriteByte(localData);
00003c  4640              MOV      r0,r8
00003e  f7fffffe          BL       E2PROM_I2C_WriteByte
;;;775    			writeAddr++;
000042  1c6d              ADDS     r5,r5,#1
000044  b2ad              UXTH     r5,r5
;;;776    			i--;
000046  1e64              SUBS     r4,r4,#1
000048  b2e4              UXTB     r4,r4
;;;777    
;;;778    			if(i != 0)
00004a  b12c              CBZ      r4,|L34.88|
;;;779    			{
;;;780    				localData = data >> (8*(i-1));
00004c  1e60              SUBS     r0,r4,#1
00004e  00c0              LSLS     r0,r0,#3
000050  fa26f000          LSR      r0,r6,r0
000054  f00008ff          AND      r8,r0,#0xff
                  |L34.88|
;;;781    			}
;;;782    
;;;783    			// 页切换，重新开始
;;;784    			if(page != writeAddr/EE_PAGE_SIZE)
000058  ebb71f55          CMP      r7,r5,LSR #5
00005c  d101              BNE      |L34.98|
                  |L34.94|
00005e  2c00              CMP      r4,#0                 ;772
000060  d1ec              BNE      |L34.60|
                  |L34.98|
;;;785    			{
;;;786    				break;
;;;787    			}
;;;788    		}
;;;789    
;;;790    		E2PROM_I2C_Stop();
000062  f7fffffe          BL       E2PROM_I2C_Stop
;;;791    
;;;792    		// 延时ms级别等待buf数据写入EEPROM
;;;793    		E2PROM_DELAY_MS();
000066  2005              MOVS     r0,#5
000068  f7fffffe          BL       E2PROM_Delayms
                  |L34.108|
00006c  2c00              CMP      r4,#0                 ;761
00006e  d1cf              BNE      |L34.16|
;;;794    	}
;;;795    
;;;796    #endif
;;;797    }
000070  e8bd87f0          POP      {r4-r10,pc}
;;;798    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  e2promCB
                          %        100

;*** Start embedded assembler ***

#line 1 "User\\e2prom.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_e2prom_c_5406e482____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___8_e2prom_c_5406e482____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_e2prom_c_5406e482____REVSH|
#line 128
|__asm___8_e2prom_c_5406e482____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
