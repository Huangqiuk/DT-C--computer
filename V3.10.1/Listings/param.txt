; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\param.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\param.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -IC:\Users\Administrator\AppData\Local\Arm\Packs\GigaDevice\GD32F10x_DFP\2.0.1\Device\Include -D__MICROLIB -D__UVISION_VERSION=534 -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\param.crf User\param.c]
                          THUMB

                          AREA ||i.PARAM_CmpareN||, CODE, READONLY, ALIGN=1

                  PARAM_CmpareN PROC
;;;269    
;;;270    uint8 PARAM_CmpareN(const uint8 *str1, const uint8 *str2, uint8 len)
000000  b530              PUSH     {r4,r5,lr}
;;;271    {
;;;272    	uint16 i = 0;
000002  2300              MOVS     r3,#0
000004  e007              B        |L1.22|
                  |L1.6|
;;;273    
;;;274    	while(i < len)
;;;275    	{
;;;276    		if(*(str1 +i) != *(str2 +i))
000006  5cc4              LDRB     r4,[r0,r3]
000008  5ccd              LDRB     r5,[r1,r3]
00000a  42ac              CMP      r4,r5
00000c  d001              BEQ      |L1.18|
;;;277    		{
;;;278    			return 0;
00000e  2000              MOVS     r0,#0
;;;279    		}
;;;280    		i++;
;;;281    	}
;;;282    	return 1;
;;;283    }
000010  bd30              POP      {r4,r5,pc}
                  |L1.18|
000012  1c5b              ADDS     r3,r3,#1              ;280
000014  b29b              UXTH     r3,r3                 ;280
                  |L1.22|
000016  4293              CMP      r3,r2                 ;274
000018  d3f5              BCC      |L1.6|
00001a  2001              MOVS     r0,#1                 ;282
00001c  bd30              POP      {r4,r5,pc}
;;;284    
                          ENDP


                          AREA ||i.PARAM_Init||, CODE, READONLY, ALIGN=1

                  PARAM_Init PROC
;;;185    **********************************************************************/
;;;186    void PARAM_Init(void)
000000  f7ffbffe          B.W      PARAM_SetDefaultRunningData
;;;187    {
;;;188    	// 设置默认的运行数据
;;;189    	PARAM_SetDefaultRunningData();
;;;190    }
;;;191    
                          ENDP


                          AREA ||i.PARAM_SetDefaultRunningData||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_sizespec
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  PARAM_SetDefaultRunningData PROC
;;;18     // 默认运行参数
;;;19     void PARAM_SetDefaultRunningData(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;20     {
000004  b090              SUB      sp,sp,#0x40
;;;21     	uint8 length = 0;
000006  2500              MOVS     r5,#0
000008  950f              STR      r5,[sp,#0x3c]
;;;22     	uint8 buf[50];
;;;23     	uint8 i;
;;;24     	uint8 * pBuff;
;;;25     	
;;;26     	// ■■ 不需要保存至NVM的参数 ■■
;;;27     	
;;;28     	paramCB.runtime.jumpFlag = (BOOL)0;
00000a  4c74              LDR      r4,|L3.476|
00000c  f8845169          STRB     r5,[r4,#0x169]
;;;29     	
;;;30     	// 固件版本号
;;;31     	for (i = 0;i < 3;i++)
000010  2000              MOVS     r0,#0
                  |L3.18|
;;;32     	{
;;;33     		paramCB.runtime.devVersion[i] = DEV_VERSION[i];
000012  a173              ADR      r1,|L3.480|
000014  1822              ADDS     r2,r4,r0
000016  5c09              LDRB     r1,[r1,r0]
000018  f882116a          STRB     r1,[r2,#0x16a]
00001c  1c40              ADDS     r0,r0,#1              ;31
00001e  b2c0              UXTB     r0,r0                 ;31
000020  2803              CMP      r0,#3                 ;31
000022  d3f6              BCC      |L3.18|
;;;34     		
;;;35     	}
;;;36     	paramCB.runtime.fwBinNum = FW_BINNUM;
000024  34cc              ADDS     r4,r4,#0xcc
000026  f8a450a2          STRH     r5,[r4,#0xa2]
;;;37     	paramCB.runtime.fwBinVersion.devVersionRemain = DEV_VERSION_REMAIN;
00002a  f88450a4          STRB     r5,[r4,#0xa4]
;;;38     	paramCB.runtime.fwBinVersion.devReleaseVersion = DEV_RELEASE_VERSION;
00002e  2004              MOVS     r0,#4
000030  f88400a5          STRB     r0,[r4,#0xa5]
;;;39     	paramCB.runtime.fwBinVersion.fwUpdateVersion = FW_UPDATE_VERSION;
000034  f88450a6          STRB     r5,[r4,#0xa6]
;;;40     	paramCB.runtime.fwBinVersion.fwDebugReleaseVersion = FW_DEBUG_RELEASE_VERSION;
000038  2001              MOVS     r0,#1
00003a  f88400a7          STRB     r0,[r4,#0xa7]
;;;41     	
;;;42     	// 仪表唯一序列号
;;;43     	paramCB.runtime.watchUid.sn0 = *(uint32*)(0x1FFFF7E8); 
00003e  4869              LDR      r0,|L3.484|
000040  6800              LDR      r0,[r0,#0]
000042  6760              STR      r0,[r4,#0x74]  ; paramCB
;;;44     	paramCB.runtime.watchUid.sn1 = *(uint32*)(0x1FFFF7EC); 
000044  4967              LDR      r1,|L3.484|
000046  1d09              ADDS     r1,r1,#4
000048  680b              LDR      r3,[r1,#0]
00004a  67a3              STR      r3,[r4,#0x78]  ; paramCB
;;;45     	paramCB.runtime.watchUid.sn2 = *(uint32*)(0x1FFFF7F0);
00004c  1d09              ADDS     r1,r1,#4
00004e  680a              LDR      r2,[r1,#0]
000050  67e2              STR      r2,[r4,#0x7c]  ; paramCB
;;;46     
;;;47     	sprintf((char*)paramCB.runtime.watchUid.snStr, "%08lX%08lX%08lX", paramCB.runtime.watchUid.sn2, paramCB.runtime.watchUid.sn1, paramCB.runtime.watchUid.sn0);
000052  9000              STR      r0,[sp,#0]
000054  a164              ADR      r1,|L3.488|
000056  4868              LDR      r0,|L3.504|
000058  f7fffffe          BL       __2sprintf
;;;48     
;;;49     	// 读取标志区数据
;;;50     	SPI_FLASH_ReadArray(paramCB.runtime.flagArr, SPI_FLASH_TEST_FLAG_ADDEESS, 16);
00005c  2210              MOVS     r2,#0x10
00005e  4967              LDR      r1,|L3.508|
000060  485e              LDR      r0,|L3.476|
000062  f7fffffe          BL       SPI_FLASH_ReadArray
;;;51     
;;;52     	
;;;53     	
;;;54     	paramCB.runtime.bootVersion[0] = IAP_VERSION_LENGTH;
000066  261a              MOVS     r6,#0x1a
000068  f8046c6c          STRB     r6,[r4,#-0x6c]
00006c  3ccc              SUBS     r4,r4,#0xcc
;;;55     	for(i = 0; i < IAP_VERSION_LENGTH ; i++)
00006e  2000              MOVS     r0,#0
                  |L3.112|
;;;56     	{
;;;57     		paramCB.runtime.bootVersion[i + 1] = IAP_VERSION[i];
000070  a163              ADR      r1,|L3.512|
000072  1822              ADDS     r2,r4,r0
000074  5c09              LDRB     r1,[r1,r0]
000076  f8821061          STRB     r1,[r2,#0x61]
00007a  1c40              ADDS     r0,r0,#1              ;55
00007c  b2c0              UXTB     r0,r0                 ;55
00007e  281a              CMP      r0,#0x1a              ;55
000080  d3f6              BCC      |L3.112|
;;;58     	}
;;;59     
;;;60     	// 验证BOOT版本
;;;61     	SPI_FLASH_ReadArray(&length, SPI_FLASH_BOOT_ADDEESS, 1);
000082  4c5e              LDR      r4,|L3.508|
000084  2201              MOVS     r2,#1
000086  3440              ADDS     r4,r4,#0x40
000088  4621              MOV      r1,r4
00008a  a80f              ADD      r0,sp,#0x3c
00008c  f7fffffe          BL       SPI_FLASH_ReadArray
;;;62     	if (IAP_VERSION_LENGTH != length)
000090  f89d103c          LDRB     r1,[sp,#0x3c]
000094  291a              CMP      r1,#0x1a
000096  d004              BEQ      |L3.162|
;;;63     	{
;;;64     		length = IAP_VERSION_LENGTH;
000098  4631              MOV      r1,r6
00009a  960f              STR      r6,[sp,#0x3c]
;;;65     		SPI_FLASH_WriteByte(SPI_FLASH_BOOT_ADDEESS, length);
00009c  4620              MOV      r0,r4
00009e  f7fffffe          BL       SPI_FLASH_WriteByte
                  |L3.162|
;;;66     	}
;;;67     	
;;;68     	// 读取BOOT版本字符
;;;69     	SPI_FLASH_ReadArray(buf, SPI_FLASH_BOOT_ADDEESS + 1, IAP_VERSION_LENGTH);
0000a2  4c56              LDR      r4,|L3.508|
0000a4  221a              MOVS     r2,#0x1a
0000a6  3441              ADDS     r4,r4,#0x41
0000a8  4621              MOV      r1,r4
0000aa  a802              ADD      r0,sp,#8
0000ac  f7fffffe          BL       SPI_FLASH_ReadArray
;;;70     	
;;;71     	// 如果读取的版本号不符，则强制更新为当前BOOT版本
;;;72     	if (!PARAM_CmpareN((const uint8*)buf, (const uint8*)IAP_VERSION, IAP_VERSION_LENGTH)) 
0000b0  221a              MOVS     r2,#0x1a
0000b2  a153              ADR      r1,|L3.512|
0000b4  a802              ADD      r0,sp,#8
0000b6  f7fffffe          BL       PARAM_CmpareN
0000ba  b920              CBNZ     r0,|L3.198|
;;;73     	{
;;;74     		SPI_FLASH_WriteWithErase((uint8*)IAP_VERSION, SPI_FLASH_BOOT_ADDEESS + 1, IAP_VERSION_LENGTH);
0000bc  221a              MOVS     r2,#0x1a
0000be  4621              MOV      r1,r4
0000c0  a04f              ADR      r0,|L3.512|
0000c2  f7fffffe          BL       SPI_FLASH_WriteWithErase
                  |L3.198|
;;;75     	}
;;;76     
;;;77     	// 读取APP版本字符
;;;78     	pBuff = &(paramCB.runtime.appVersion[0]);
0000c6  4c45              LDR      r4,|L3.476|
0000c8  3440              ADDS     r4,r4,#0x40
;;;79     	pBuff[0] = SPI_FLASH_ReadByte(SPI_FLASH_APP_ADDEESS);
0000ca  484c              LDR      r0,|L3.508|
0000cc  3060              ADDS     r0,r0,#0x60
0000ce  f7fffffe          BL       SPI_FLASH_ReadByte
0000d2  7020              STRB     r0,[r4,#0]
;;;80     	if (31 < pBuff[0])
;;;81     	{
;;;82     		pBuff[0] = 3;
0000d4  2703              MOVS     r7,#3
;;;83     		pBuff[1] = 'E';
;;;84     		pBuff[2] = 'R';
0000d6  2652              MOVS     r6,#0x52
0000d8  f04f0845          MOV      r8,#0x45              ;83
0000dc  281f              CMP      r0,#0x1f              ;80
0000de  d906              BLS      |L3.238|
0000e0  7027              STRB     r7,[r4,#0]            ;82
0000e2  f8848001          STRB     r8,[r4,#1]            ;83
0000e6  70a6              STRB     r6,[r4,#2]
;;;85     		pBuff[3] = 'R';
0000e8  70e6              STRB     r6,[r4,#3]
;;;86     		pBuff[4] = 0;
0000ea  7125              STRB     r5,[r4,#4]
0000ec  e005              B        |L3.250|
                  |L3.238|
;;;87     	}
;;;88     	else
;;;89     	{
;;;90     		SPI_FLASH_ReadArray(&(pBuff[1]), SPI_FLASH_APP_ADDEESS + 1, pBuff[0]);
0000ee  4943              LDR      r1,|L3.508|
0000f0  4602              MOV      r2,r0
0000f2  3161              ADDS     r1,r1,#0x61
0000f4  1c60              ADDS     r0,r4,#1
0000f6  f7fffffe          BL       SPI_FLASH_ReadArray
                  |L3.250|
;;;91     	}
;;;92     
;;;93     	// 读取二维码版本字符
;;;94     	pBuff = &(paramCB.runtime.qrCodeStr[0]);
0000fa  4c38              LDR      r4,|L3.476|
0000fc  34a0              ADDS     r4,r4,#0xa0
;;;95     	pBuff[0] = SPI_FLASH_ReadByte(SPI_FLASH_QR_CODE_ADDEESS);
0000fe  4847              LDR      r0,|L3.540|
000100  f7fffffe          BL       SPI_FLASH_ReadByte
000104  7020              STRB     r0,[r4,#0]
;;;96     	if (63 < pBuff[0])
000106  283f              CMP      r0,#0x3f
000108  d906              BLS      |L3.280|
;;;97     	{
;;;98     		pBuff[0] = 3;
00010a  7027              STRB     r7,[r4,#0]
;;;99     		pBuff[1] = 'E';
00010c  f8848001          STRB     r8,[r4,#1]
;;;100    		pBuff[2] = 'R';
000110  70a6              STRB     r6,[r4,#2]
;;;101    		pBuff[3] = 'R';
000112  70e6              STRB     r6,[r4,#3]
;;;102    		pBuff[4] = 0;
000114  7125              STRB     r5,[r4,#4]
000116  e005              B        |L3.292|
                  |L3.280|
;;;103    	}
;;;104    	else
;;;105    	{
;;;106    		SPI_FLASH_ReadArray(&(pBuff[1]), SPI_FLASH_QR_CODE_ADDEESS + 1, pBuff[0]);
000118  4940              LDR      r1,|L3.540|
00011a  4602              MOV      r2,r0
00011c  1c49              ADDS     r1,r1,#1
00011e  1c60              ADDS     r0,r4,#1
000120  f7fffffe          BL       SPI_FLASH_ReadArray
                  |L3.292|
;;;107    	}
;;;108    
;;;109    	// 读取UI版本
;;;110    	pBuff = &(paramCB.runtime.uiVersion[0]);
000124  4c2d              LDR      r4,|L3.476|
000126  3480              ADDS     r4,r4,#0x80
;;;111    	pBuff[0] = SPI_FLASH_ReadByte(SPI_FLASH_UI_VERSION_ADDEESS);
000128  483c              LDR      r0,|L3.540|
00012a  3880              SUBS     r0,r0,#0x80
00012c  f7fffffe          BL       SPI_FLASH_ReadByte
000130  7020              STRB     r0,[r4,#0]
;;;112    	if (31 < pBuff[0])
000132  281f              CMP      r0,#0x1f
000134  d906              BLS      |L3.324|
;;;113    	{
;;;114    		pBuff[0] = 3;
000136  7027              STRB     r7,[r4,#0]
;;;115    		pBuff[1] = 'E';
000138  f8848001          STRB     r8,[r4,#1]
;;;116    		pBuff[2] = 'R';
00013c  70a6              STRB     r6,[r4,#2]
;;;117    		pBuff[3] = 'R';
00013e  70e6              STRB     r6,[r4,#3]
;;;118    		pBuff[4] = 0;
000140  7125              STRB     r5,[r4,#4]
000142  e005              B        |L3.336|
                  |L3.324|
;;;119    	}
;;;120    	else
;;;121    	{
;;;122    		SPI_FLASH_ReadArray(&(pBuff[1]), SPI_FLASH_UI_VERSION_ADDEESS + 1, pBuff[0]);
000144  4935              LDR      r1,|L3.540|
000146  4602              MOV      r2,r0
000148  397f              SUBS     r1,r1,#0x7f
00014a  1c60              ADDS     r0,r4,#1
00014c  f7fffffe          BL       SPI_FLASH_ReadArray
                  |L3.336|
;;;123    	}
;;;124    	
;;;125    	// 读取硬件版本
;;;126    	pBuff = &(paramCB.runtime.hardVersion[0]);
000150  4c29              LDR      r4,|L3.504|
000152  3c6c              SUBS     r4,r4,#0x6c
;;;127    	pBuff[0] = SPI_FLASH_ReadByte(SPI_FLASH_HW_VERSION_ADDEESS);
000154  4831              LDR      r0,|L3.540|
000156  3860              SUBS     r0,r0,#0x60
000158  f7fffffe          BL       SPI_FLASH_ReadByte
00015c  7020              STRB     r0,[r4,#0]
;;;128    	if (31 < pBuff[0])
00015e  281f              CMP      r0,#0x1f
000160  d906              BLS      |L3.368|
;;;129    	{
;;;130    		pBuff[0] = 3;
000162  7027              STRB     r7,[r4,#0]
;;;131    		pBuff[1] = 'E';
000164  f8848001          STRB     r8,[r4,#1]
;;;132    		pBuff[2] = 'R';
000168  70a6              STRB     r6,[r4,#2]
;;;133    		pBuff[3] = 'R';
00016a  70e6              STRB     r6,[r4,#3]
;;;134    		pBuff[4] = 0;
00016c  7125              STRB     r5,[r4,#4]
00016e  e005              B        |L3.380|
                  |L3.368|
;;;135    	}
;;;136    	else
;;;137    	{
;;;138    		SPI_FLASH_ReadArray(&(pBuff[1]), SPI_FLASH_HW_VERSION_ADDEESS + 1, pBuff[0]);
000170  492a              LDR      r1,|L3.540|
000172  4602              MOV      r2,r0
000174  395f              SUBS     r1,r1,#0x5f
000176  1c60              ADDS     r0,r4,#1
000178  f7fffffe          BL       SPI_FLASH_ReadArray
                  |L3.380|
;;;139    	}
;;;140    
;;;141    	// 读取SN号
;;;142    	pBuff = &(paramCB.runtime.snCode[0]);
00017c  4c1e              LDR      r4,|L3.504|
00017e  3c4c              SUBS     r4,r4,#0x4c
;;;143    	pBuff[0] = SPI_FLASH_ReadByte(SPI_FLASH_SN_ADDEESS);
000180  4826              LDR      r0,|L3.540|
000182  3840              SUBS     r0,r0,#0x40
000184  f7fffffe          BL       SPI_FLASH_ReadByte
000188  7020              STRB     r0,[r4,#0]
;;;144    	if (31 < pBuff[0])
00018a  281f              CMP      r0,#0x1f
00018c  d906              BLS      |L3.412|
;;;145    	{
;;;146    		pBuff[0] = 3;
00018e  7027              STRB     r7,[r4,#0]
;;;147    		pBuff[1] = 'E';
000190  f8848001          STRB     r8,[r4,#1]
;;;148    		pBuff[2] = 'R';
000194  70a6              STRB     r6,[r4,#2]
;;;149    		pBuff[3] = 'R';
000196  70e6              STRB     r6,[r4,#3]
;;;150    		pBuff[4] = 0;
000198  7125              STRB     r5,[r4,#4]
00019a  e005              B        |L3.424|
                  |L3.412|
;;;151    	}
;;;152    	else
;;;153    	{
;;;154    		SPI_FLASH_ReadArray(&(pBuff[1]), SPI_FLASH_SN_ADDEESS + 1, pBuff[0]);
00019c  491f              LDR      r1,|L3.540|
00019e  4602              MOV      r2,r0
0001a0  393f              SUBS     r1,r1,#0x3f
0001a2  1c60              ADDS     r0,r4,#1
0001a4  f7fffffe          BL       SPI_FLASH_ReadArray
                  |L3.424|
;;;155    	}
;;;156    
;;;157    	// 读取蓝牙MAC地址
;;;158    	pBuff = &(paramCB.runtime.bluMac[0]);
0001a8  4c13              LDR      r4,|L3.504|
0001aa  3c2c              SUBS     r4,r4,#0x2c
;;;159    	pBuff[0] = SPI_FLASH_ReadByte(SPI_FLASH_BLE_MAC_ADDEESS);
0001ac  481b              LDR      r0,|L3.540|
0001ae  3820              SUBS     r0,r0,#0x20
0001b0  f7fffffe          BL       SPI_FLASH_ReadByte
0001b4  7020              STRB     r0,[r4,#0]
;;;160    	if (31 < pBuff[0])
0001b6  281f              CMP      r0,#0x1f
0001b8  d908              BLS      |L3.460|
;;;161    	{
;;;162    		pBuff[0] = 3;
0001ba  7027              STRB     r7,[r4,#0]
;;;163    		pBuff[1] = 'E';
0001bc  f8848001          STRB     r8,[r4,#1]
;;;164    		pBuff[2] = 'R';
0001c0  70a6              STRB     r6,[r4,#2]
;;;165    		pBuff[3] = 'R';
0001c2  70e6              STRB     r6,[r4,#3]
;;;166    		pBuff[4] = 0;
0001c4  7125              STRB     r5,[r4,#4]
                  |L3.454|
;;;167    	}
;;;168    	else
;;;169    	{
;;;170    		SPI_FLASH_ReadArray(&(pBuff[1]), SPI_FLASH_BLE_MAC_ADDEESS + 1, pBuff[0]);
;;;171    	}	
;;;172    }
0001c6  b010              ADD      sp,sp,#0x40
0001c8  e8bd81f0          POP      {r4-r8,pc}
                  |L3.460|
0001cc  4913              LDR      r1,|L3.540|
0001ce  4602              MOV      r2,r0                 ;170
0001d0  391f              SUBS     r1,r1,#0x1f           ;170
0001d2  1c60              ADDS     r0,r4,#1              ;170
0001d4  f7fffffe          BL       SPI_FLASH_ReadArray
0001d8  e7f5              B        |L3.454|
;;;173    
                          ENDP

0001da  0000              DCW      0x0000
                  |L3.476|
                          DCD      ||.bss||
                  |L3.480|
0001e0  42543800          DCB      "BT8",0
                  |L3.484|
                          DCD      0x1ffff7e8
                  |L3.488|
0001e8  2530386c          DCB      "%08lX%08lX%08lX",0
0001ec  58253038
0001f0  6c582530
0001f4  386c5800
                  |L3.504|
                          DCD      ||.bss||+0x14c
                  |L3.508|
                          DCD      0x003ff000
                  |L3.512|
000200  425f434d          DCB      "B_CM_FW_BL_DT_BC182_V4.0.1",0
000204  5f46575f
000208  424c5f44
00020c  545f4243
000210  3138325f
000214  56342e30
000218  2e3100  
00021b  00                DCB      0
                  |L3.540|
                          DCD      0x003fe0a0

                          AREA ||i.Param_Process||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  Param_Process PROC
;;;192    
;;;193    void Param_Process(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;194    {
000002  b0a9              SUB      sp,sp,#0xa4
;;;195    	uint8 i;
;;;196    	uint8 TempStr[140];
;;;197    	uint8 hmiTypeStr[10];
;;;198    	
;;;199    	if ((paramCB.runtime.qrRegEnable) && (bleUartCB.rcvBleMacOK) && (gsmUartCB.rcvIccidOK || gsmUartCB.rcvIccidTimeOut))
000004  4d32              LDR      r5,|L4.208|
000006  f8950168          LDRB     r0,[r5,#0x168]  ; paramCB
00000a  2800              CMP      r0,#0
00000c  d053              BEQ      |L4.182|
00000e  4e31              LDR      r6,|L4.212|
000010  f8960222          LDRB     r0,[r6,#0x222]  ; bleUartCB
000014  2800              CMP      r0,#0
000016  d04e              BEQ      |L4.182|
000018  4c2f              LDR      r4,|L4.216|
00001a  f8940049          LDRB     r0,[r4,#0x49]  ; gsmUartCB
00001e  b918              CBNZ     r0,|L4.40|
000020  f894004a          LDRB     r0,[r4,#0x4a]  ; gsmUartCB
000024  2800              CMP      r0,#0
000026  d046              BEQ      |L4.182|
                  |L4.40|
;;;200    	{
;;;201    		// 读取HMI类型
;;;202    		/*E2PROM_ReadByteArray(PARAM_NVM_HMI_TYPE_START_ADDRESS, hmiTypeStr, PARAM_NVM_HMI_TYPE_SIZE);
;;;203    		hmiTypeStr[PARAM_NVM_HMI_TYPE_SIZE] = '\0';
;;;204    
;;;205    		// 判断目前仪表是何种类型
;;;206    		if (0 == strcmp((const char*)hmiTypeStr, (const char*)HMI_TYPE_BC18SU))
;;;207    		{}
;;;208    		else if (0 == strcmp((const char*)hmiTypeStr, (const char*)HMI_TYPE_BC18SU))
;;;209    		{}
;;;210    		else if (0 == strcmp((const char*)hmiTypeStr, (const char*)HMI_TYPE_BC28EU))
;;;211    		{}
;;;212    		else if (0 == strcmp((const char*)hmiTypeStr, (const char*)HMI_TYPE_BC28SU))
;;;213    		{}
;;;214    		else if (0 == strcmp((const char*)hmiTypeStr, (const char*)HMI_TYPE_BC28NU))
;;;215    		{}
;;;216    		else if (0 == strcmp((const char*)hmiTypeStr, (const char*)HMI_TYPE_BC18EC))
;;;217    		{}
;;;218    		else if (0 == strcmp((const char*)hmiTypeStr, (const char*)HMI_TYPE_BC28EC))
;;;219    		{}
;;;220    		// 不在支持的仪表类型里面
;;;221    		else
;;;222    		{
;;;223    			// 拷贝字符串
;;;224    			strcpy((char*)hmiTypeStr, (const char*)"BC18Uxx");
;;;225    		}
;;;226    		*/
;;;227    
;;;228    		// 拷贝字符串
;;;229    		strcpy((char*)hmiTypeStr, (const char*)"BC18Uxx");
000028  a12c              ADR      r1,|L4.220|
00002a  a803              ADD      r0,sp,#0xc
00002c  f7fffffe          BL       strcpy
;;;230    	
;;;231    		// 复制MAC地址到SPIflash备份	
;;;232    		paramCB.runtime.bluMac[0] = 17;		// 长度
000030  2011              MOVS     r0,#0x11
000032  f8850120          STRB     r0,[r5,#0x120]
;;;233    		for (i = 0; i < 17; i++)
000036  2000              MOVS     r0,#0
                  |L4.56|
;;;234    		{
;;;235    			paramCB.runtime.bluMac[i+1] = bleUartCB.rx.macBuff[i];
000038  1831              ADDS     r1,r6,r0
00003a  182a              ADDS     r2,r5,r0
00003c  f891120d          LDRB     r1,[r1,#0x20d]
000040  f8821121          STRB     r1,[r2,#0x121]
000044  1c40              ADDS     r0,r0,#1              ;233
000046  b2c0              UXTB     r0,r0                 ;233
000048  2811              CMP      r0,#0x11              ;233
00004a  d3f5              BCC      |L4.56|
;;;236    		}
;;;237    		
;;;238    		SPI_FLASH_WriteWithErase(&(paramCB.runtime.bluMac[0]), SPI_FLASH_BLE_MAC_ADDEESS, 17 + 1);
00004c  2212              MOVS     r2,#0x12
00004e  4925              LDR      r1,|L4.228|
000050  4825              LDR      r0,|L4.232|
000052  f7fffffe          BL       SPI_FLASH_WriteWithErase
;;;239    		
;;;240    
;;;241    		// 设置无效GSM		
;;;242    		for (i = 0; i < 20; i++)
000056  2000              MOVS     r0,#0
;;;243    		{
;;;244    			gsmUartCB.rx.iccidBuff[i] = '0';
000058  2130              MOVS     r1,#0x30
                  |L4.90|
00005a  1822              ADDS     r2,r4,r0
00005c  f8821032          STRB     r1,[r2,#0x32]
000060  1c40              ADDS     r0,r0,#1              ;242
000062  b2c0              UXTB     r0,r0                 ;242
000064  2814              CMP      r0,#0x14              ;242
000066  d3f8              BCC      |L4.90|
;;;245    		}
;;;246    		gsmUartCB.rx.iccidBuff[i] = '\0';
000068  4420              ADD      r0,r0,r4
00006a  2700              MOVS     r7,#0
00006c  f8807032          STRB     r7,[r0,#0x32]
000070  4819              LDR      r0,|L4.216|
000072  4a1d              LDR      r2,|L4.232|
;;;247    
;;;248    		
;;;249    		// 存在GSM模块
;;;250    		if ((gsmUartCB.rcvIccidOK) && (!gsmUartCB.rcvIccidTimeOut))
000074  f894c049          LDRB     r12,[r4,#0x49]  ; gsmUartCB
000078  3032              ADDS     r0,r0,#0x32           ;199
00007a  4b1c              LDR      r3,|L4.236|
00007c  322c              ADDS     r2,r2,#0x2c           ;199
00007e  a903              ADD      r1,sp,#0xc            ;197
000080  f1bc0f00          CMP      r12,#0
000084  d004              BEQ      |L4.144|
000086  f894c04a          LDRB     r12,[r4,#0x4a]  ; gsmUartCB
00008a  f1bc0f00          CMP      r12,#0
00008e  d014              BEQ      |L4.186|
                  |L4.144|
;;;251    		{
;;;252    			sprintf((char*)TempStr, "%s%s%s%s%s", paramCB.runtime.watchUid.snStr, bleUartCB.rx.macBuff, gsmUartCB.rx.iccidBuff, GPS_TYPE_YES, hmiTypeStr);
;;;253    		}
;;;254    		// 没有GSM模块，超时导致的
;;;255    		else
;;;256    		{	
;;;257    			sprintf((char*)TempStr, "%s%s%s%s%s", paramCB.runtime.watchUid.snStr, bleUartCB.rx.macBuff, gsmUartCB.rx.iccidBuff, GPS_TYPE_NO, hmiTypeStr);
000090  f20f0c5c          ADR      r12,|L4.240|
000094  e9cdc101          STRD     r12,r1,[sp,#4]
000098  9000              STR      r0,[sp,#0]
00009a  a116              ADR      r1,|L4.244|
00009c  a806              ADD      r0,sp,#0x18
00009e  f7fffffe          BL       __2sprintf
                  |L4.162|
;;;258    		}
;;;259    
;;;260    		// 注册二维码参数准备完毕，立刻上报
;;;261    		IAP_CTRL_UART_SendCmdQrRegParam(TempStr);
0000a2  a806              ADD      r0,sp,#0x18
0000a4  f7fffffe          BL       IAP_CTRL_UART_SendCmdQrRegParam
;;;262    
;;;263    		paramCB.runtime.qrRegEnable = FALSE;
0000a8  f8857168          STRB     r7,[r5,#0x168]
;;;264    		bleUartCB.rcvBleMacOK = FALSE;
0000ac  f8867222          STRB     r7,[r6,#0x222]
;;;265    		gsmUartCB.rcvIccidOK = FALSE;
0000b0  f8047f49          STRB     r7,[r4,#0x49]!
;;;266    		gsmUartCB.rcvIccidTimeOut = FALSE;
0000b4  7067              STRB     r7,[r4,#1]
                  |L4.182|
;;;267    	}
;;;268    }
0000b6  b029              ADD      sp,sp,#0xa4
0000b8  bdf0              POP      {r4-r7,pc}
                  |L4.186|
0000ba  f20f0c44          ADR      r12,|L4.256|
0000be  e9cdc101          STRD     r12,r1,[sp,#4]        ;252
0000c2  9000              STR      r0,[sp,#0]            ;252
0000c4  a10b              ADR      r1,|L4.244|
0000c6  a806              ADD      r0,sp,#0x18           ;252
0000c8  f7fffffe          BL       __2sprintf
0000cc  e7e9              B        |L4.162|
;;;269    
                          ENDP

0000ce  0000              DCW      0x0000
                  |L4.208|
                          DCD      ||.bss||
                  |L4.212|
                          DCD      bleUartCB
                  |L4.216|
                          DCD      gsmUartCB
                  |L4.220|
0000dc  42433138          DCB      "BC18Uxx",0
0000e0  55787800
                  |L4.228|
                          DCD      0x003fe080
                  |L4.232|
                          DCD      ||.bss||+0x120
                  |L4.236|
                          DCD      bleUartCB+0x20d
                  |L4.240|
0000f0  3000              DCB      "0",0
0000f2  00                DCB      0
0000f3  00                DCB      0
                  |L4.244|
0000f4  25732573          DCB      "%s%s%s%s%s",0
0000f8  25732573
0000fc  257300  
0000ff  00                DCB      0
                  |L4.256|
000100  3100              DCB      "1",0
000102  00                DCB      0
000103  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  paramCB
                          %        372

;*** Start embedded assembler ***

#line 1 "User\\param.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_param_c_510448ac____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___7_param_c_510448ac____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_param_c_510448ac____REVSH|
#line 128
|__asm___7_param_c_510448ac____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
