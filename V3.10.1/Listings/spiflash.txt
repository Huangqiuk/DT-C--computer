; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\spiflash.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\spiflash.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -IC:\Users\Administrator\AppData\Local\Arm\Packs\GigaDevice\GD32F10x_DFP\2.0.1\Device\Include -D__MICROLIB -D__UVISION_VERSION=534 -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\spiflash.crf User\spiflash.c]
                          THUMB

                          AREA ||i.DMA0_Channel1_IRQHandler||, CODE, READONLY, ALIGN=2

                  DMA0_Channel1_IRQHandler PROC
;;;837    // DMA接收中断RX
;;;838    void DMA0_Channel1_IRQHandler(void) 
000000  b510              PUSH     {r4,lr}
;;;839    {
;;;840    	if (dma_interrupt_flag_get(DMA0, DMA_CH1, DMA_INT_FLAG_FTF))
000002  4c10              LDR      r4,|L1.68|
000004  2202              MOVS     r2,#2
000006  2101              MOVS     r1,#1
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       dma_interrupt_flag_get
00000e  2800              CMP      r0,#0
000010  d017              BEQ      |L1.66|
;;;841    	{
;;;842    #if STM32_DMA_SPI_DIRECTION
;;;843    		dma_interrupt_flag_clear(DMA0,DMA_CH1, DMA_INT_FLAG_G);
;;;844    		dma_interrupt_flag_clear(DMA0,DMA_CH2, DMA_INT_FLAG_G);
;;;845    		
;;;846    		while (spi_i2s_flag_get(STM32_SPIx_NUM_DEF, I2S_FLAG_TRANS) != RESET);
;;;847    
;;;848    		// 禁止SPI
;;;849    		spi_disable(STM32_SPIx_NUM_DEF);
;;;850    		// 关闭发送，接收DMA
;;;851    		spi_dma_disable(STM32_SPIx_NUM_DEF, SPI_DMA_TRANSMIT);
;;;852    		spi_dma_disable(STM32_SPIx_NUM_DEF, SPI_DMA_RECEIVE);
;;;853    		
;;;854    		// 禁止接收TC中断
;;;855    		dma_interrupt_disable(DMA0,DMA_CH1, DMA_INT_FTF);
;;;856    
;;;857    		SPI_FLASH_CS_H();  // 结束片选
;;;858    
;;;859    		// 设置DMA完成标识
;;;860    		spiCB.dmaFinished = TRUE;
;;;861    #else
;;;862    
;;;863    		dma_interrupt_flag_clear(DMA0,DMA_CH1, DMA_INT_FLAG_FTF);
000012  2202              MOVS     r2,#2
000014  2101              MOVS     r1,#1
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       dma_interrupt_flag_clear
;;;864    		// 注意:当设置模式为双线只接收或单线接收模式下，不能在此加入忙BSY的判断死等，此时该标志已失效
;;;865    		// 传输的完成就已经是彻底的接收完成，无需别的动作
;;;866    		
;;;867    		// 禁止SPI
;;;868    		spi_disable(STM32_SPIx_NUM_DEF);
00001c  480a              LDR      r0,|L1.72|
00001e  f7fffffe          BL       spi_disable
;;;869    		// 关闭接收DMA
;;;870    		dma_channel_disable(DMA0, DMA_CH1);
000022  2101              MOVS     r1,#1
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       dma_channel_disable
;;;871    		// 禁止接收TC中断
;;;872    		dma_interrupt_disable(DMA0,DMA_CH1,DMA_INT_FTF);
00002a  2202              MOVS     r2,#2
00002c  2101              MOVS     r1,#1
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       dma_interrupt_disable
;;;873    
;;;874    		SPI_FLASH_CS_H();  // 结束片选
000034  2110              MOVS     r1,#0x10
000036  4805              LDR      r0,|L1.76|
000038  f7fffffe          BL       gpio_bit_set
;;;875    
;;;876    		// 设置DMA完成标识
;;;877    		spiCB.dmaFinished = TRUE;
00003c  4904              LDR      r1,|L1.80|
00003e  2001              MOVS     r0,#1
000040  7008              STRB     r0,[r1,#0]
                  |L1.66|
;;;878    #endif
;;;879    	}
;;;880    }
000042  bd10              POP      {r4,pc}
;;;881     
                          ENDP

                  |L1.68|
                          DCD      0x40020000
                  |L1.72|
                          DCD      0x40013000
                  |L1.76|
                          DCD      0x40010800
                  |L1.80|
                          DCD      ||.data||

                          AREA ||i.DMA0_Channel2_IRQHandler||, CODE, READONLY, ALIGN=2

                  DMA0_Channel2_IRQHandler PROC
;;;882    // DMA发送中断TX
;;;883    void DMA0_Channel2_IRQHandler(void) 
000000  b570              PUSH     {r4-r6,lr}
;;;884    {
;;;885    	if (dma_interrupt_flag_get(DMA0,DMA_CH2, DMA_INT_FLAG_FTF))
000002  4c12              LDR      r4,|L2.76|
000004  2202              MOVS     r2,#2
000006  4611              MOV      r1,r2
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       dma_interrupt_flag_get
00000e  2800              CMP      r0,#0
000010  d01a              BEQ      |L2.72|
;;;886    	{
;;;887    		dma_interrupt_flag_clear(DMA0,DMA_CH2, DMA_INT_FLAG_FTF);
000012  2202              MOVS     r2,#2
000014  4611              MOV      r1,r2
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       dma_interrupt_flag_clear
;;;888    		
;;;889    		// 注意:上面为止DMA已经将所有的数据搬运到SPI_DR，但是，但是，但是实际上SPI数据还没全发送出去
;;;890    		// 因此，软件等待忙标志，确保所有数据都发送出去才能将其关闭
;;;891    		while (spi_i2s_flag_get(STM32_SPIx_NUM_DEF, I2S_FLAG_TRANS) != RESET);
00001c  4d0c              LDR      r5,|L2.80|
                  |L2.30|
00001e  2180              MOVS     r1,#0x80
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       spi_i2s_flag_get
000026  2800              CMP      r0,#0
000028  d1f9              BNE      |L2.30|
;;;892    
;;;893    		// 关闭发送DMA
;;;894    		spi_dma_disable(STM32_SPIx_NUM_DEF, SPI_DMA_TRANSMIT);
00002a  2100              MOVS     r1,#0
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       spi_dma_disable
;;;895    		// 关闭发送TC中断
;;;896    		dma_interrupt_disable(DMA0,DMA_CH2,DMA_INT_FTF);
000032  2202              MOVS     r2,#2
000034  4611              MOV      r1,r2
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       dma_interrupt_disable
;;;897    
;;;898    		SPI_FLASH_CS_H();  // 结束片选
00003c  e8bd4070          POP      {r4-r6,lr}
000040  2110              MOVS     r1,#0x10
000042  4804              LDR      r0,|L2.84|
000044  f7ffbffe          B.W      gpio_bit_set
                  |L2.72|
;;;899    	}
;;;900    }
000048  bd70              POP      {r4-r6,pc}
;;;901    
                          ENDP

00004a  0000              DCW      0x0000
                  |L2.76|
                          DCD      0x40020000
                  |L2.80|
                          DCD      0x40013000
                  |L2.84|
                          DCD      0x40010800

                          AREA ||i.SPI_FLASH_EraseBlock||, CODE, READONLY, ALIGN=2

                  SPI_FLASH_EraseBlock PROC
;;;150    // 擦除块
;;;151    void SPI_FLASH_EraseBlock(uint32 BlockAddr)
000000  b570              PUSH     {r4-r6,lr}
;;;152    {
000002  4604              MOV      r4,r0
;;;153    	// 使能写入操作
;;;154    	SPI_FLASH_WriteEnable();
000004  f7fffffe          BL       SPI_FLASH_WriteEnable
;;;155    
;;;156    	// 片选
;;;157    	SPI_FLASH_CS_L();
000008  4d0d              LDR      r5,|L3.64|
00000a  2110              MOVS     r1,#0x10
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       gpio_bit_reset
;;;158    
;;;159    	// 发送64K擦除命令
;;;160    	SPI_FLASH_SendByte(CMD_BLOCK_ERASE_64K);
000012  20d8              MOVS     r0,#0xd8
000014  f7fffffe          BL       SPI_FLASH_SendByte
;;;161    
;;;162    	// 发送24位地址
;;;163    	SPI_FLASH_SendByte((BlockAddr & 0xFF0000) >> 16);
000018  f3c44007          UBFX     r0,r4,#16,#8
00001c  f7fffffe          BL       SPI_FLASH_SendByte
;;;164    	SPI_FLASH_SendByte((BlockAddr & 0xFF00) >> 8);
000020  f3c42007          UBFX     r0,r4,#8,#8
000024  f7fffffe          BL       SPI_FLASH_SendByte
;;;165    	SPI_FLASH_SendByte(BlockAddr & 0xFF);
000028  b2e0              UXTB     r0,r4
00002a  f7fffffe          BL       SPI_FLASH_SendByte
;;;166    
;;;167    	// 释放
;;;168    	SPI_FLASH_CS_H();
00002e  2110              MOVS     r1,#0x10
000030  4628              MOV      r0,r5
000032  f7fffffe          BL       gpio_bit_set
;;;169    
;;;170    	// 等待写入完成
;;;171    	SPI_FLASH_WaitForWriteEnd();
000036  e8bd4070          POP      {r4-r6,lr}
00003a  f7ffbffe          B.W      SPI_FLASH_WaitForWriteEnd
;;;172    }
;;;173    
                          ENDP

00003e  0000              DCW      0x0000
                  |L3.64|
                          DCD      0x40010800

                          AREA ||i.SPI_FLASH_EraseChip||, CODE, READONLY, ALIGN=2

                  SPI_FLASH_EraseChip PROC
;;;175    // 擦除整个Flash
;;;176    void SPI_FLASH_EraseChip(void)
000000  b510              PUSH     {r4,lr}
;;;177    {
;;;178    	// 使能写入操作
;;;179    	SPI_FLASH_WriteEnable();
000002  f7fffffe          BL       SPI_FLASH_WriteEnable
;;;180    
;;;181    	// 片选
;;;182    	SPI_FLASH_CS_L();
000006  4c08              LDR      r4,|L4.40|
000008  2110              MOVS     r1,#0x10
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       gpio_bit_reset
;;;183    
;;;184    	// 发送片擦除命令
;;;185    	SPI_FLASH_SendByte(CMD_CHIP_ERASE);
000010  20c7              MOVS     r0,#0xc7
000012  f7fffffe          BL       SPI_FLASH_SendByte
;;;186    
;;;187    	// 释放
;;;188    	SPI_FLASH_CS_H();
000016  2110              MOVS     r1,#0x10
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       gpio_bit_set
;;;189    
;;;190    	// 等待写入完成
;;;191    	SPI_FLASH_WaitForWriteEnd();
00001e  e8bd4010          POP      {r4,lr}
000022  f7ffbffe          B.W      SPI_FLASH_WaitForWriteEnd
;;;192    }
;;;193    
                          ENDP

000026  0000              DCW      0x0000
                  |L4.40|
                          DCD      0x40010800

                          AREA ||i.SPI_FLASH_EraseRoom||, CODE, READONLY, ALIGN=1

                  SPI_FLASH_EraseRoom PROC
;;;511    // 擦除指定空间 先擦扇区再擦块再擦扇区
;;;512    void SPI_FLASH_EraseRoom(uint32 Addr, uint32 size)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;513    {
000004  4605              MOV      r5,r0
000006  4688              MOV      r8,r1
;;;514    	
;;;515    	uint16 blockStartNum = 0;		// 块号
;;;516    	uint16 blockCount = 0;			// 需要擦除块的数量
;;;517    	uint16 blockSectorOffset = 0;	// 块内扇区偏移量
;;;518    	uint16 i;
;;;519    
;;;520    	blockSectorOffset = Addr / SPI_FLASH_SECTOR_SIZE % SPI_FLASH_BLOCK_PER_16SECTORS;
000008  f3c53003          UBFX     r0,r5,#12,#4
;;;521    
;;;522    	if(blockSectorOffset)			// 擦除扇区在块内存在偏移量
00000c  2800              CMP      r0,#0
00000e  d004              BEQ      |L5.26|
;;;523    	{
;;;524    		blockStartNum = Addr / SPI_FLASH_BLOCK_SIZE + 1;
000010  2101              MOVS     r1,#1
000012  eb014115          ADD      r1,r1,r5,LSR #16
000016  b28e              UXTH     r6,r1
000018  e000              B        |L5.28|
                  |L5.26|
;;;525    	}
;;;526    	else							// 擦除开始地址等于块的起始地址，不存在偏移
;;;527    	{
;;;528    		blockStartNum = Addr / SPI_FLASH_BLOCK_SIZE;
00001a  0c2e              LSRS     r6,r5,#16
                  |L5.28|
;;;529    	}
;;;530    
;;;531    	// 擦除起始块内扇区偏移
;;;532    	for(i = 0; i < SPI_FLASH_BLOCK_PER_16SECTORS - blockSectorOffset; i++)
00001c  2400              MOVS     r4,#0
00001e  f1c00710          RSB      r7,r0,#0x10
000022  e006              B        |L5.50|
                  |L5.36|
;;;533    	{
;;;534    		SPI_FLASH_EraseSector((Addr / SPI_FLASH_SECTOR_SIZE + i) * SPI_FLASH_SECTOR_SIZE);
000024  eb043015          ADD      r0,r4,r5,LSR #12
000028  0300              LSLS     r0,r0,#12
00002a  f7fffffe          BL       SPI_FLASH_EraseSector
00002e  1c64              ADDS     r4,r4,#1              ;532
000030  b2a4              UXTH     r4,r4                 ;532
                  |L5.50|
000032  42a7              CMP      r7,r4                 ;532
000034  dcf6              BGT      |L5.36|
;;;535    	}
;;;536    
;;;537    	// 计算出需要擦除的块的数量
;;;538    	blockCount = ((size / SPI_FLASH_SECTOR_SIZE) - (SPI_FLASH_BLOCK_PER_16SECTORS - blockSectorOffset)) / SPI_FLASH_BLOCK_PER_16SECTORS;
000036  ebc73718          RSB      r7,r7,r8,LSR #12
00003a  f3c7150f          UBFX     r5,r7,#4,#16
;;;539    	
;;;540    	// 擦除块
;;;541    	for(i = 0; i < blockCount; i++)
00003e  2400              MOVS     r4,#0
000040  e005              B        |L5.78|
                  |L5.66|
;;;542    	{
;;;543    		SPI_FLASH_EraseBlock((blockStartNum + i) * SPI_FLASH_BLOCK_SIZE);
000042  1930              ADDS     r0,r6,r4
000044  0400              LSLS     r0,r0,#16
000046  f7fffffe          BL       SPI_FLASH_EraseBlock
00004a  1c64              ADDS     r4,r4,#1              ;541
00004c  b2a4              UXTH     r4,r4                 ;541
                  |L5.78|
00004e  42ac              CMP      r4,r5                 ;541
000050  d3f7              BCC      |L5.66|
;;;544    	}
;;;545    	
;;;546    	// 擦除剩余扇区,剩余的扇区不满一个块
;;;547    	for(i = 0; i < ((size / SPI_FLASH_SECTOR_SIZE)- (SPI_FLASH_BLOCK_PER_16SECTORS - blockSectorOffset)) % SPI_FLASH_BLOCK_PER_16SECTORS; i++)
000052  2400              MOVS     r4,#0
;;;548    	{
;;;549    		SPI_FLASH_EraseSector((blockStartNum + blockCount) * SPI_FLASH_BLOCK_SIZE + i * SPI_FLASH_SECTOR_SIZE);
000054  1970              ADDS     r0,r6,r5
000056  0405              LSLS     r5,r0,#16
000058  f007060f          AND      r6,r7,#0xf            ;547
00005c  e005              B        |L5.106|
                  |L5.94|
00005e  eb053004          ADD      r0,r5,r4,LSL #12
000062  f7fffffe          BL       SPI_FLASH_EraseSector
000066  1c64              ADDS     r4,r4,#1              ;547
000068  b2a4              UXTH     r4,r4                 ;547
                  |L5.106|
00006a  42a6              CMP      r6,r4                 ;547
00006c  d8f7              BHI      |L5.94|
;;;550    	}
;;;551    }
00006e  e8bd81f0          POP      {r4-r8,pc}
;;;552    
                          ENDP


                          AREA ||i.SPI_FLASH_EraseSector||, CODE, READONLY, ALIGN=2

                  SPI_FLASH_EraseSector PROC
;;;126    // 擦除扇区
;;;127    void SPI_FLASH_EraseSector(uint32 SectorAddr)
000000  b570              PUSH     {r4-r6,lr}
;;;128    {
000002  4604              MOV      r4,r0
;;;129    	// 使能写入操作
;;;130    	SPI_FLASH_WriteEnable();
000004  f7fffffe          BL       SPI_FLASH_WriteEnable
;;;131    
;;;132    	// 片选
;;;133    	SPI_FLASH_CS_L();
000008  4d0d              LDR      r5,|L6.64|
00000a  2110              MOVS     r1,#0x10
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       gpio_bit_reset
;;;134    
;;;135    	// 发送扇区擦除命令
;;;136    	SPI_FLASH_SendByte(CMD_SECTOR_ERASE_4K);
000012  2020              MOVS     r0,#0x20
000014  f7fffffe          BL       SPI_FLASH_SendByte
;;;137    
;;;138    	// 发送24位地址
;;;139    	SPI_FLASH_SendByte((SectorAddr & 0xFF0000) >> 16);
000018  f3c44007          UBFX     r0,r4,#16,#8
00001c  f7fffffe          BL       SPI_FLASH_SendByte
;;;140    	SPI_FLASH_SendByte((SectorAddr & 0xFF00) >> 8);
000020  f3c42007          UBFX     r0,r4,#8,#8
000024  f7fffffe          BL       SPI_FLASH_SendByte
;;;141    	SPI_FLASH_SendByte(SectorAddr & 0xFF);
000028  b2e0              UXTB     r0,r4
00002a  f7fffffe          BL       SPI_FLASH_SendByte
;;;142    
;;;143    	// 释放
;;;144    	SPI_FLASH_CS_H();
00002e  2110              MOVS     r1,#0x10
000030  4628              MOV      r0,r5
000032  f7fffffe          BL       gpio_bit_set
;;;145    
;;;146    	// 等待写入完成
;;;147    	SPI_FLASH_WaitForWriteEnd();
000036  e8bd4070          POP      {r4-r6,lr}
00003a  f7ffbffe          B.W      SPI_FLASH_WaitForWriteEnd
;;;148    }
;;;149    
                          ENDP

00003e  0000              DCW      0x0000
                  |L6.64|
                          DCD      0x40010800

                          AREA ||i.SPI_FLASH_ReadArray||, CODE, READONLY, ALIGN=2

                  SPI_FLASH_ReadArray PROC
;;;357    // 读取数据至指定缓冲区，数据个数最大可以为整片容量
;;;358    void SPI_FLASH_ReadArray(uint8* pBuffer, uint32 ReadAddr, uint16 NumByteToRead)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;359    {	
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
;;;360    	// 指针非空判断
;;;361    	if (NULL == pBuffer)
00000a  2c00              CMP      r4,#0
00000c  d023              BEQ      |L7.86|
;;;362    	{
;;;363    		return;
;;;364    	}
;;;365    	
;;;366    	// 要读取的数据量为0，退出
;;;367    	if (0 == NumByteToRead)
00000e  2d00              CMP      r5,#0
000010  d021              BEQ      |L7.86|
;;;368    	{
;;;369    		return;
;;;370    	}
;;;371    	
;;;372    	// 片选
;;;373    	SPI_FLASH_CS_L();
000012  4e12              LDR      r6,|L7.92|
000014  2110              MOVS     r1,#0x10
000016  4630              MOV      r0,r6
000018  f7fffffe          BL       gpio_bit_reset
;;;374    
;;;375    	// 发送读取命令
;;;376    	SPI_FLASH_SendByte(CMD_READ_BYTE);
00001c  2003              MOVS     r0,#3
00001e  f7fffffe          BL       SPI_FLASH_SendByte
;;;377    
;;;378    	// 发送24位起始地址
;;;379    	SPI_FLASH_SendByte((ReadAddr & 0xFF0000) >> 16);
000022  f3c74007          UBFX     r0,r7,#16,#8
000026  f7fffffe          BL       SPI_FLASH_SendByte
;;;380    	SPI_FLASH_SendByte((ReadAddr & 0xFF00) >> 8);
00002a  f3c72007          UBFX     r0,r7,#8,#8
00002e  f7fffffe          BL       SPI_FLASH_SendByte
;;;381    	SPI_FLASH_SendByte(ReadAddr & 0xFF);
000032  b2f8              UXTB     r0,r7
000034  f7fffffe          BL       SPI_FLASH_SendByte
;;;382    
;;;383    	// 一直读取完指定的数量为止
;;;384    	while(NumByteToRead--)
000038  e004              B        |L7.68|
                  |L7.58|
;;;385    	{
;;;386    		// 读取一个字节
;;;387    		*(pBuffer++) = SPI_FLASH_SendByte(0);
00003a  2000              MOVS     r0,#0
00003c  f7fffffe          BL       SPI_FLASH_SendByte
000040  f8040b01          STRB     r0,[r4],#1
                  |L7.68|
000044  1e6d              SUBS     r5,r5,#1              ;384
000046  b2ad              UXTH     r5,r5                 ;384
000048  d2f7              BCS      |L7.58|
;;;388    	}
;;;389    
;;;390    	// 释放
;;;391    	SPI_FLASH_CS_H();
00004a  4630              MOV      r0,r6
00004c  e8bd41f0          POP      {r4-r8,lr}
000050  2110              MOVS     r1,#0x10
000052  f7ffbffe          B.W      gpio_bit_set
                  |L7.86|
;;;392    }
000056  e8bd81f0          POP      {r4-r8,pc}
;;;393    
                          ENDP

00005a  0000              DCW      0x0000
                  |L7.92|
                          DCD      0x40010800

                          AREA ||i.SPI_FLASH_ReadByte||, CODE, READONLY, ALIGN=1

                  SPI_FLASH_ReadByte PROC
;;;329    
;;;330    uint8 SPI_FLASH_ReadByte( uint32 ReadAddr)
000000  b508              PUSH     {r3,lr}
;;;331    {
;;;332    	uint8 buff[4];
;;;333    	
;;;334    	SPI_FLASH_ReadArray(buff, ReadAddr, 4);
000002  4601              MOV      r1,r0
000004  2204              MOVS     r2,#4
000006  4668              MOV      r0,sp
000008  f7fffffe          BL       SPI_FLASH_ReadArray
;;;335    	
;;;336    	return buff[0];
00000c  f89d0000          LDRB     r0,[sp,#0]
;;;337    }
000010  bd08              POP      {r3,pc}
;;;338    
                          ENDP


                          AREA ||i.SPI_FLASH_ReadChipID||, CODE, READONLY, ALIGN=2

                  SPI_FLASH_ReadChipID PROC
;;;394    // 读取芯片ID
;;;395    uint16 SPI_FLASH_ReadChipID(void)
000000  b570              PUSH     {r4-r6,lr}
;;;396    {
;;;397    	uint16 W25xXX_ID = 0;
;;;398    	
;;;399    	// 使能写入操作
;;;400    	SPI_FLASH_WriteEnable();
000002  f7fffffe          BL       SPI_FLASH_WriteEnable
;;;401    	
;;;402    	SPI_FLASH_CS_L();
000006  4d11              LDR      r5,|L9.76|
000008  2110              MOVS     r1,#0x10
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       gpio_bit_reset
;;;403    	
;;;404    	// 发送读取ID命令							
;;;405    	SPI_FLASH_SendByte(CMD_MANUFACT_DEVICE_ID);
000010  2090              MOVS     r0,#0x90
000012  f7fffffe          BL       SPI_FLASH_SendByte
;;;406    
;;;407    	// 发送24位的地址		 
;;;408    	SPI_FLASH_SendByte(0x00);	// dummy
000016  2000              MOVS     r0,#0
000018  f7fffffe          BL       SPI_FLASH_SendByte
;;;409    	SPI_FLASH_SendByte(0x00);	// dummy		  
00001c  2000              MOVS     r0,#0
00001e  f7fffffe          BL       SPI_FLASH_SendByte
;;;410    	SPI_FLASH_SendByte(0x00);	// 0x00
000022  2000              MOVS     r0,#0
000024  f7fffffe          BL       SPI_FLASH_SendByte
;;;411    
;;;412    	// 读取返回的16位值 							 
;;;413    	W25xXX_ID = SPI_FLASH_SendByte(0xFF);	// 高8位数据
000028  20ff              MOVS     r0,#0xff
00002a  f7fffffe          BL       SPI_FLASH_SendByte
;;;414    	W25xXX_ID <<= 8;
00002e  f64f71ff          MOV      r1,#0xffff
000032  ea012400          AND      r4,r1,r0,LSL #8
;;;415    	W25xXX_ID += SPI_FLASH_SendByte(0xFF);	// 底8位数据
000036  20ff              MOVS     r0,#0xff
000038  f7fffffe          BL       SPI_FLASH_SendByte
00003c  4420              ADD      r0,r0,r4
00003e  b284              UXTH     r4,r0
;;;416    
;;;417    	SPI_FLASH_CS_H();
000040  2110              MOVS     r1,#0x10
000042  4628              MOV      r0,r5
000044  f7fffffe          BL       gpio_bit_set
;;;418    
;;;419    	return W25xXX_ID;
000048  4620              MOV      r0,r4
;;;420    }
00004a  bd70              POP      {r4-r6,pc}
;;;421    
                          ENDP

                  |L9.76|
                          DCD      0x40010800

                          AREA ||i.SPI_FLASH_ReadHalfWord||, CODE, READONLY, ALIGN=1

                  SPI_FLASH_ReadHalfWord PROC
;;;338    
;;;339    uint16 SPI_FLASH_ReadHalfWord( uint32 ReadAddr)
000000  b508              PUSH     {r3,lr}
;;;340    {
;;;341    	uint8 buff[4];
;;;342    	
;;;343    	SPI_FLASH_ReadArray(buff, ReadAddr, 4);
000002  4601              MOV      r1,r0
000004  2204              MOVS     r2,#4
000006  4668              MOV      r0,sp
000008  f7fffffe          BL       SPI_FLASH_ReadArray
;;;344    	
;;;345    	return ((uint16)buff[0] << 8) + buff[1];
00000c  f89d0001          LDRB     r0,[sp,#1]
000010  f89d1000          LDRB     r1,[sp,#0]
000014  eb002001          ADD      r0,r0,r1,LSL #8
000018  b280              UXTH     r0,r0
;;;346    }
00001a  bd08              POP      {r3,pc}
;;;347    
                          ENDP


                          AREA ||i.SPI_FLASH_ReadWord||, CODE, READONLY, ALIGN=1

                  SPI_FLASH_ReadWord PROC
;;;347    
;;;348    uint32 SPI_FLASH_ReadWord( uint32 ReadAddr)
000000  b508              PUSH     {r3,lr}
;;;349    {
;;;350    	uint8 buff[4];
;;;351    	
;;;352    	SPI_FLASH_ReadArray(buff, ReadAddr, 4);
000002  4601              MOV      r1,r0
000004  2204              MOVS     r2,#4
000006  4668              MOV      r0,sp
000008  f7fffffe          BL       SPI_FLASH_ReadArray
;;;353    	
;;;354    	return ((uint32)buff[0] << 24) + ((uint32)buff[1] << 16) + ((uint32)buff[2] << 8) + buff[3];
00000c  f89d0003          LDRB     r0,[sp,#3]
000010  f89d1000          LDRB     r1,[sp,#0]
000014  f89d2002          LDRB     r2,[sp,#2]
000018  eb006001          ADD      r0,r0,r1,LSL #24
00001c  f89d1001          LDRB     r1,[sp,#1]
000020  0409              LSLS     r1,r1,#16
000022  eb012102          ADD      r1,r1,r2,LSL #8
000026  4408              ADD      r0,r0,r1
;;;355    }
000028  bd08              POP      {r3,pc}
;;;356    
                          ENDP


                          AREA ||i.SPI_FLASH_SendByte||, CODE, READONLY, ALIGN=2

                  SPI_FLASH_SendByte PROC
;;;422    // 发送一个字节
;;;423    uint8 SPI_FLASH_SendByte(uint8 byte)
000000  b570              PUSH     {r4-r6,lr}
;;;424    {
000002  4605              MOV      r5,r0
;;;425    	// 发送寄存器不为空，等待
;;;426    	uint16 spiRetryTime = 0;
000004  2400              MOVS     r4,#0
;;;427    	
;;;428    	while(spi_i2s_flag_get(STM32_SPIx_NUM_DEF,SPI_STAT_TBE) == RESET)
000006  4e14              LDR      r6,|L12.88|
000008  e006              B        |L12.24|
                  |L12.10|
;;;429    	{
;;;430    		if(spiRetryTime++ > SPI_FLASH_RETRY_READ_TIME)
00000a  4620              MOV      r0,r4
00000c  1c64              ADDS     r4,r4,#1
00000e  b2a4              UXTH     r4,r4
000010  28c8              CMP      r0,#0xc8
000012  d901              BLS      |L12.24|
;;;431    		{
;;;432    			return 0x00;
000014  2000              MOVS     r0,#0
;;;433    		}
;;;434    	}
;;;435    	// 发送
;;;436    	spi_i2s_data_transmit(STM32_SPIx_NUM_DEF,byte);
;;;437    
;;;438    	// 接收寄存器为空，等待
;;;439    	spiRetryTime = 0;
;;;440    	while (spi_i2s_flag_get(STM32_SPIx_NUM_DEF, SPI_STAT_RBNE) == RESET)
;;;441    	{
;;;442    		if(spiRetryTime++ > SPI_FLASH_RETRY_READ_TIME)
;;;443    		{
;;;444    			return 0x00;
;;;445    		}
;;;446    	}
;;;447    
;;;448    	// 返回接收到的值
;;;449    	return spi_i2s_data_receive(STM32_SPIx_NUM_DEF);
;;;450    }
000016  bd70              POP      {r4-r6,pc}
                  |L12.24|
000018  2102              MOVS     r1,#2                 ;428
00001a  4630              MOV      r0,r6                 ;428
00001c  f7fffffe          BL       spi_i2s_flag_get
000020  2800              CMP      r0,#0                 ;428
000022  d0f2              BEQ      |L12.10|
000024  4629              MOV      r1,r5                 ;436
000026  4635              MOV      r5,r6                 ;436
000028  4628              MOV      r0,r5                 ;436
00002a  f7fffffe          BL       spi_i2s_data_transmit
00002e  2400              MOVS     r4,#0                 ;439
000030  e006              B        |L12.64|
                  |L12.50|
000032  4620              MOV      r0,r4                 ;442
000034  1c64              ADDS     r4,r4,#1              ;442
000036  b2a4              UXTH     r4,r4                 ;442
000038  28c8              CMP      r0,#0xc8              ;442
00003a  d901              BLS      |L12.64|
00003c  2000              MOVS     r0,#0                 ;444
00003e  bd70              POP      {r4-r6,pc}
                  |L12.64|
000040  2101              MOVS     r1,#1                 ;440
000042  4628              MOV      r0,r5                 ;440
000044  f7fffffe          BL       spi_i2s_flag_get
000048  2800              CMP      r0,#0                 ;440
00004a  d0f2              BEQ      |L12.50|
00004c  4628              MOV      r0,r5                 ;449
00004e  f7fffffe          BL       spi_i2s_data_receive
000052  b2c0              UXTB     r0,r0                 ;449
000054  bd70              POP      {r4-r6,pc}
;;;451    
                          ENDP

000056  0000              DCW      0x0000
                  |L12.88|
                          DCD      0x40013000

                          AREA ||i.SPI_FLASH_WaitForWriteEnd||, CODE, READONLY, ALIGN=2

                  SPI_FLASH_WaitForWriteEnd PROC
;;;488    // 等待写入操作完成
;;;489    void SPI_FLASH_WaitForWriteEnd(void)
000000  b510              PUSH     {r4,lr}
;;;490    {
;;;491    	uint8 flashstatus = 0;
;;;492    
;;;493    	// 片选
;;;494    	SPI_FLASH_CS_L();
000002  4c09              LDR      r4,|L13.40|
000004  2110              MOVS     r1,#0x10
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       gpio_bit_reset
;;;495    
;;;496    	// 发送读取状态寄存器1的命令
;;;497    	SPI_FLASH_SendByte(CMD_READ_STATUS_REGISTER1);
00000c  2005              MOVS     r0,#5
00000e  f7fffffe          BL       SPI_FLASH_SendByte
                  |L13.18|
;;;498    
;;;499    	// 写入中，持续等待
;;;500    	do
;;;501    	{
;;;502    		// 发送一个假数据，即可产生SPI时钟
;;;503    		flashstatus = SPI_FLASH_SendByte(0);
000012  2000              MOVS     r0,#0
000014  f7fffffe          BL       SPI_FLASH_SendByte
;;;504    	}
;;;505    	while((flashstatus & BUSY_FLAG) == BUSY_FLAG);
000018  07c0              LSLS     r0,r0,#31
00001a  d1fa              BNE      |L13.18|
;;;506    
;;;507    	// 释放
;;;508    	SPI_FLASH_CS_H();
00001c  4620              MOV      r0,r4
00001e  e8bd4010          POP      {r4,lr}
000022  2110              MOVS     r1,#0x10
000024  f7ffbffe          B.W      gpio_bit_set
;;;509    }
;;;510    
                          ENDP

                  |L13.40|
                          DCD      0x40010800

                          AREA ||i.SPI_FLASH_WriteArray||, CODE, READONLY, ALIGN=1

                  SPI_FLASH_WriteArray PROC
;;;233    // 将指定缓冲区的数据写入指定开始地址的区域
;;;234    void SPI_FLASH_WriteArray(uint8* pBuffer, uint32 WriteAddr, uint16 NumByteToWrite)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;235    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4690              MOV      r8,r2
;;;236    	uint8 NumOfPage=0, NumOfRestByte=0, StartAddrOffset=0, RestSpace=0, temp=0;
;;;237    
;;;238    	// 指针非空判断
;;;239    	if (NULL == pBuffer)
00000a  2d00              CMP      r5,#0
00000c  d065              BEQ      |L14.218|
;;;240    	{
;;;241    		return;
;;;242    	}
;;;243    	
;;;244    	// 写入数据量为0，退出
;;;245    	if(0 == NumByteToWrite)
00000e  f1b80f00          CMP      r8,#0
000012  d062              BEQ      |L14.218|
;;;246    	{
;;;247    		return ;
;;;248    	}
;;;249    
;;;250    	StartAddrOffset = WriteAddr % SPI_FLASH_PAGE_SIZE;
000014  b2f0              UXTB     r0,r6
;;;251    	RestSpace = SPI_FLASH_PAGE_SIZE - StartAddrOffset;
000016  4241              RSBS     r1,r0,#0
000018  b2cf              UXTB     r7,r1
;;;252    	NumOfPage =  NumByteToWrite / SPI_FLASH_PAGE_SIZE;
00001a  ea4f2418          LSR      r4,r8,#8
;;;253    	NumOfRestByte = NumByteToWrite % SPI_FLASH_PAGE_SIZE;
00001e  f0080aff          AND      r10,r8,#0xff
;;;254    
;;;255    	// 起始地址刚好位于当前页的起点
;;;256    	if(StartAddrOffset == 0)
;;;257    	{
;;;258    		// 数据量不足一页，直接写入
;;;259    		if(NumOfPage == 0)
;;;260    		{
;;;261    			SPI_FLASH_WritePage(pBuffer, WriteAddr, NumByteToWrite);
;;;262    		}
;;;263    		// 数据量超出一页
;;;264    		else
;;;265    		{
;;;266    			// 整页的部分，直接写入整页
;;;267    			while(NumOfPage--)
;;;268    			{
;;;269    				// 在当前页写满
;;;270    				SPI_FLASH_WritePage(pBuffer, WriteAddr, SPI_FLASH_PAGE_SIZE);
000022  f44f7980          MOV      r9,#0x100
000026  b190              CBZ      r0,|L14.78|
000028  b2f0              UXTB     r0,r6                 ;250
00002a  4240              RSBS     r0,r0,#0              ;251
00002c  b2c0              UXTB     r0,r0                 ;251
;;;271    
;;;272    				WriteAddr += SPI_FLASH_PAGE_SIZE;
;;;273    				pBuffer += SPI_FLASH_PAGE_SIZE;
;;;274    			}
;;;275    
;;;276    			// 写入不足一页的部分
;;;277    			SPI_FLASH_WritePage(pBuffer, WriteAddr, NumOfRestByte);
;;;278    		}
;;;279    	}
;;;280    	// 起始地址不是当前页的起点，即从中间插入写入
;;;281    	else
;;;282    	{
;;;283    		// 数据量不足一页，直接写入
;;;284    		if(NumOfPage == 0)
;;;285    		{
;;;286    			// 要写入的数据量超过了当前页剩余空间，则分开两次写入
;;;287    			if(NumOfRestByte > RestSpace)
;;;288    			{
;;;289    				// 先将当前页填满
;;;290    				temp = NumOfRestByte - RestSpace;
;;;291    
;;;292    				SPI_FLASH_WritePage(pBuffer, WriteAddr, RestSpace);
;;;293    				WriteAddr +=  RestSpace;
00002e  eb060b00          ADD      r11,r6,r0
000032  b33c              CBZ      r4,|L14.132|
;;;294    				pBuffer += RestSpace;
;;;295    
;;;296    				// 再将剩余的数据写入下一页
;;;297    				SPI_FLASH_WritePage(pBuffer, WriteAddr, temp);
;;;298    			}
;;;299    			// 要写入的数据量不超过当前页的剩余空间，则直接写入
;;;300    			else
;;;301    			{
;;;302    				SPI_FLASH_WritePage(pBuffer, WriteAddr, NumByteToWrite);
;;;303    			}
;;;304    		}
;;;305    		// 数据量超过一页
;;;306    		else
;;;307    		{
;;;308    			// 先将当前页填满
;;;309    			SPI_FLASH_WritePage(pBuffer, WriteAddr, RestSpace);
000034  463a              MOV      r2,r7
000036  4631              MOV      r1,r6
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       SPI_FLASH_WritePage
;;;310    			WriteAddr +=  RestSpace;
00003e  465e              MOV      r6,r11
;;;311    			pBuffer += RestSpace;
000040  443d              ADD      r5,r5,r7
;;;312    
;;;313    			// 剩余的数据，写入起点就是下一页的起点了，和上面第一种情况相同的处理
;;;314    			NumByteToWrite -= RestSpace;
000042  eba80007          SUB      r0,r8,r7
000046  b280              UXTH     r0,r0
;;;315    			NumOfPage =  NumByteToWrite / SPI_FLASH_PAGE_SIZE;
000048  0a04              LSRS     r4,r0,#8
;;;316    			NumOfRestByte = NumByteToWrite % SPI_FLASH_PAGE_SIZE;
00004a  b2c7              UXTB     r7,r0
;;;317    
;;;318    			while(NumOfPage--)
00004c  e03b              B        |L14.198|
                  |L14.78|
00004e  b97c              CBNZ     r4,|L14.112|
000050  4642              MOV      r2,r8                 ;261
000052  4631              MOV      r1,r6                 ;261
000054  4628              MOV      r0,r5                 ;261
000056  e8bd5ff0          POP      {r4-r12,lr}           ;261
00005a  f7ffbffe          B.W      SPI_FLASH_WritePage
                  |L14.94|
00005e  464a              MOV      r2,r9                 ;270
000060  4631              MOV      r1,r6                 ;270
000062  4628              MOV      r0,r5                 ;270
000064  f7fffffe          BL       SPI_FLASH_WritePage
000068  f5067680          ADD      r6,r6,#0x100          ;272
00006c  f5057580          ADD      r5,r5,#0x100          ;273
                  |L14.112|
000070  1e64              SUBS     r4,r4,#1              ;267
000072  b2e4              UXTB     r4,r4                 ;267
000074  d2f3              BCS      |L14.94|
000076  4652              MOV      r2,r10                ;277
000078  4631              MOV      r1,r6                 ;277
00007a  4628              MOV      r0,r5                 ;277
00007c  e8bd5ff0          POP      {r4-r12,lr}           ;277
000080  f7ffbffe          B.W      SPI_FLASH_WritePage
                  |L14.132|
000084  45ba              CMP      r10,r7                ;287
000086  d90e              BLS      |L14.166|
000088  ebaa0007          SUB      r0,r10,r7             ;290
00008c  b2c4              UXTB     r4,r0                 ;290
00008e  463a              MOV      r2,r7                 ;292
000090  4631              MOV      r1,r6                 ;292
000092  4628              MOV      r0,r5                 ;292
000094  f7fffffe          BL       SPI_FLASH_WritePage
000098  4659              MOV      r1,r11                ;293
00009a  19e8              ADDS     r0,r5,r7              ;294
00009c  4622              MOV      r2,r4                 ;297
00009e  e8bd5ff0          POP      {r4-r12,lr}           ;297
0000a2  f7ffbffe          B.W      SPI_FLASH_WritePage
                  |L14.166|
0000a6  4642              MOV      r2,r8                 ;302
0000a8  4631              MOV      r1,r6                 ;302
0000aa  4628              MOV      r0,r5                 ;302
0000ac  e8bd5ff0          POP      {r4-r12,lr}           ;302
0000b0  f7ffbffe          B.W      SPI_FLASH_WritePage
                  |L14.180|
;;;319    			{
;;;320    				SPI_FLASH_WritePage(pBuffer, WriteAddr, SPI_FLASH_PAGE_SIZE);
0000b4  464a              MOV      r2,r9
0000b6  4631              MOV      r1,r6
0000b8  4628              MOV      r0,r5
0000ba  f7fffffe          BL       SPI_FLASH_WritePage
;;;321    				WriteAddr += SPI_FLASH_PAGE_SIZE;
0000be  f5067680          ADD      r6,r6,#0x100
;;;322    				pBuffer += SPI_FLASH_PAGE_SIZE;
0000c2  f5057580          ADD      r5,r5,#0x100
                  |L14.198|
0000c6  1e64              SUBS     r4,r4,#1              ;318
0000c8  b2e4              UXTB     r4,r4                 ;318
0000ca  d2f3              BCS      |L14.180|
;;;323    			}
;;;324    
;;;325    			SPI_FLASH_WritePage(pBuffer, WriteAddr, NumOfRestByte);
0000cc  463a              MOV      r2,r7
0000ce  4631              MOV      r1,r6
0000d0  4628              MOV      r0,r5
0000d2  e8bd5ff0          POP      {r4-r12,lr}
0000d6  f7ffbffe          B.W      SPI_FLASH_WritePage
                  |L14.218|
;;;326    		}
;;;327    	}
;;;328    }
0000da  e8bd9ff0          POP      {r4-r12,pc}
;;;329    
                          ENDP


                          AREA ||i.SPI_FLASH_WriteByte||, CODE, READONLY, ALIGN=1

                  SPI_FLASH_WriteByte PROC
;;;636    
;;;637    void SPI_FLASH_WriteByte(uint32 WriteAddr, uint8 data)
000000  b508              PUSH     {r3,lr}
;;;638    {
;;;639    	uint8 buff[4];
;;;640    
;;;641    	buff[0] = (data) & 0xFF;
000002  f88d1000          STRB     r1,[sp,#0]
;;;642    	
;;;643    	SPI_FLASH_WriteWithErase(buff, WriteAddr, 1);
000006  4601              MOV      r1,r0
000008  2201              MOVS     r2,#1
00000a  4668              MOV      r0,sp
00000c  f7fffffe          BL       SPI_FLASH_WriteWithErase
;;;644    }
000010  bd08              POP      {r3,pc}
;;;645    
                          ENDP


                          AREA ||i.SPI_FLASH_WriteEnable||, CODE, READONLY, ALIGN=2

                  SPI_FLASH_WriteEnable PROC
;;;452    // 发送写入使能指令
;;;453    void SPI_FLASH_WriteEnable(void)
000000  b510              PUSH     {r4,lr}
;;;454    {
;;;455    	// 片选
;;;456    	SPI_FLASH_CS_L();
000002  4c07              LDR      r4,|L16.32|
000004  2110              MOVS     r1,#0x10
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       gpio_bit_reset
;;;457    
;;;458    	// 发送写入使能指令
;;;459    	SPI_FLASH_SendByte(CMD_WRITE_ENABLE);
00000c  2006              MOVS     r0,#6
00000e  f7fffffe          BL       SPI_FLASH_SendByte
;;;460    
;;;461    	// 释放
;;;462    	SPI_FLASH_CS_H();
000012  4620              MOV      r0,r4
000014  e8bd4010          POP      {r4,lr}
000018  2110              MOVS     r1,#0x10
00001a  f7ffbffe          B.W      gpio_bit_set
;;;463    }
;;;464    
                          ENDP

00001e  0000              DCW      0x0000
                  |L16.32|
                          DCD      0x40010800

                          AREA ||i.SPI_FLASH_WriteHalfWord||, CODE, READONLY, ALIGN=1

                  SPI_FLASH_WriteHalfWord PROC
;;;645    
;;;646    void SPI_FLASH_WriteHalfWord(uint32 WriteAddr, uint16 data)
000000  b508              PUSH     {r3,lr}
;;;647    {
;;;648    	uint8 buff[4];
;;;649    
;;;650    	buff[0] = (data >> 8) & 0xFF;
000002  0a0a              LSRS     r2,r1,#8
000004  f88d2000          STRB     r2,[sp,#0]
;;;651    	buff[1] = (data) & 0xFF;
000008  f88d1001          STRB     r1,[sp,#1]
;;;652    	
;;;653    	SPI_FLASH_WriteWithErase(buff, WriteAddr, 2);
00000c  4601              MOV      r1,r0
00000e  2202              MOVS     r2,#2
000010  4668              MOV      r0,sp
000012  f7fffffe          BL       SPI_FLASH_WriteWithErase
;;;654    }
000016  bd08              POP      {r3,pc}
;;;655    
                          ENDP


                          AREA ||i.SPI_FLASH_WritePage||, CODE, READONLY, ALIGN=2

                  SPI_FLASH_WritePage PROC
;;;194    // 页写入
;;;195    void SPI_FLASH_WritePage(uint8* pBuffer, uint32 WriteAddr, uint16 NumByteToWrite)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;196    {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
;;;197    	// 写入数据量为0，退出
;;;198    	if(0 == NumByteToWrite)
00000a  2c00              CMP      r4,#0
00000c  d024              BEQ      |L18.88|
;;;199    	{
;;;200    		return ;
;;;201    	}
;;;202    	
;;;203    	// 使能写入操作
;;;204    	SPI_FLASH_WriteEnable();
00000e  f7fffffe          BL       SPI_FLASH_WriteEnable
;;;205    
;;;206    	// 片选
;;;207    	SPI_FLASH_CS_L();
000012  4e12              LDR      r6,|L18.92|
000014  2110              MOVS     r1,#0x10
000016  4630              MOV      r0,r6
000018  f7fffffe          BL       gpio_bit_reset
;;;208    
;;;209    	// 发送页写入命令
;;;210    	SPI_FLASH_SendByte(CMD_PAGE_WRITE);
00001c  2002              MOVS     r0,#2
00001e  f7fffffe          BL       SPI_FLASH_SendByte
;;;211    
;;;212    	// 写入24位起始地址
;;;213    	SPI_FLASH_SendByte((WriteAddr >> 16) & 0xFF);
000022  f3c74007          UBFX     r0,r7,#16,#8
000026  f7fffffe          BL       SPI_FLASH_SendByte
;;;214    	SPI_FLASH_SendByte((WriteAddr >> 8) & 0xFF);
00002a  f3c72007          UBFX     r0,r7,#8,#8
00002e  f7fffffe          BL       SPI_FLASH_SendByte
;;;215    	SPI_FLASH_SendByte(WriteAddr & 0xFF);
000032  b2f8              UXTB     r0,r7
000034  f7fffffe          BL       SPI_FLASH_SendByte
;;;216    
;;;217    	// 连续写入指定数量的数据
;;;218    	while(NumByteToWrite--)
000038  e003              B        |L18.66|
                  |L18.58|
;;;219    	{
;;;220    		/// 写入一个字节
;;;221    		SPI_FLASH_SendByte(*pBuffer);
00003a  7828              LDRB     r0,[r5,#0]
00003c  f7fffffe          BL       SPI_FLASH_SendByte
;;;222    
;;;223    		pBuffer++;
000040  1c6d              ADDS     r5,r5,#1
                  |L18.66|
000042  1e64              SUBS     r4,r4,#1              ;218
000044  b2a4              UXTH     r4,r4                 ;218
000046  d2f8              BCS      |L18.58|
;;;224    	}
;;;225    
;;;226    	// 释放
;;;227    	SPI_FLASH_CS_H();
000048  2110              MOVS     r1,#0x10
00004a  4630              MOV      r0,r6
00004c  f7fffffe          BL       gpio_bit_set
;;;228    
;;;229    	// 等待写入完成
;;;230    	SPI_FLASH_WaitForWriteEnd();
000050  e8bd41f0          POP      {r4-r8,lr}
000054  f7ffbffe          B.W      SPI_FLASH_WaitForWriteEnd
                  |L18.88|
;;;231    }
000058  e8bd81f0          POP      {r4-r8,pc}
;;;232    
                          ENDP

                  |L18.92|
                          DCD      0x40010800

                          AREA ||i.SPI_FLASH_WriteStatus||, CODE, READONLY, ALIGN=2

                  SPI_FLASH_WriteStatus PROC
;;;465    // 写状态寄存器
;;;466    void SPI_FLASH_WriteStatus(uint8 data)
000000  b570              PUSH     {r4-r6,lr}
;;;467    {
000002  4605              MOV      r5,r0
;;;468    	// 片选
;;;469    	SPI_FLASH_CS_L();
000004  4c0d              LDR      r4,|L19.60|
000006  2110              MOVS     r1,#0x10
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       gpio_bit_reset
;;;470    
;;;471    	// 允许写状态寄存器
;;;472    	SPI_FLASH_SendByte(CMD_WRITE_REGISTER_ENABLE);
00000e  2050              MOVS     r0,#0x50
000010  f7fffffe          BL       SPI_FLASH_SendByte
;;;473    
;;;474    	// 释放
;;;475    	SPI_FLASH_CS_H();
000014  2110              MOVS     r1,#0x10
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       gpio_bit_set
;;;476    
;;;477    	// 片选
;;;478    	SPI_FLASH_CS_L();
00001c  2110              MOVS     r1,#0x10
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       gpio_bit_reset
;;;479    
;;;480    	// 允许写状态寄存器
;;;481    	SPI_FLASH_SendByte(CMD_WRITE_STATUS_REGISTER);
000024  2001              MOVS     r0,#1
000026  f7fffffe          BL       SPI_FLASH_SendByte
;;;482    	SPI_FLASH_SendByte(data);
00002a  4628              MOV      r0,r5
00002c  f7fffffe          BL       SPI_FLASH_SendByte
;;;483    
;;;484    	// 释放
;;;485    	SPI_FLASH_CS_H();
000030  4620              MOV      r0,r4
000032  e8bd4070          POP      {r4-r6,lr}
000036  2110              MOVS     r1,#0x10
000038  f7ffbffe          B.W      gpio_bit_set
;;;486    }
;;;487    
                          ENDP

                  |L19.60|
                          DCD      0x40010800

                          AREA ||i.SPI_FLASH_WriteWithCheck||, CODE, READONLY, ALIGN=1

                  SPI_FLASH_WriteWithCheck PROC
;;;554    // 数据写入接口，返回写入结果
;;;555    BOOL SPI_FLASH_WriteWithCheck(uint8* pBuffer, uint32 WriteAddr, uint16 NumByteToWrite)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;556    {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4617              MOV      r7,r2
;;;557    	uint16 NumOfInt = 0;
;;;558    	uint16 NumOfRestByte = 0;
;;;559    	uint16 i;
;;;560    	uint8* pFlashBuff = NULL;				// 保存读取扇区的数据
;;;561    	
;;;562    	if ((NULL == pBuffer) || (0 == NumByteToWrite))
00000a  2c00              CMP      r4,#0
00000c  d00e              BEQ      |L20.44|
00000e  b16f              CBZ      r7,|L20.44|
;;;563    	{
;;;564    		return FALSE;
;;;565    	}
;;;566    
;;;567    	// 申请4096Byte空间保存扇区数据
;;;568    	pFlashBuff = (uint8 *)malloc(SPI_FLASH_SECTOR_SIZE);
000010  f44f5980          MOV      r9,#0x1000
000014  4648              MOV      r0,r9
000016  f7fffffe          BL       malloc
00001a  4605              MOV      r5,r0
;;;569    	
;;;570    	// 指针非空判断
;;;571    	if (NULL == pFlashBuff)
00001c  0028              MOVS     r0,r5
00001e  d008              BEQ      |L20.50|
;;;572    	{
;;;573    		return FALSE;
;;;574    	}
;;;575    
;;;576    	if (NumByteToWrite > SPI_FLASH_SECTOR_SIZE)
000020  454f              CMP      r7,r9
000022  d941              BLS      |L20.168|
;;;577    	{
;;;578    		NumOfInt = NumByteToWrite / SPI_FLASH_SECTOR_SIZE;
000024  0b3e              LSRS     r6,r7,#12
;;;579    		NumOfRestByte = NumByteToWrite % SPI_FLASH_SECTOR_SIZE;
000026  f3c7070b          UBFX     r7,r7,#0,#12
;;;580    
;;;581    		while (NumOfInt--)
00002a  e020              B        |L20.110|
                  |L20.44|
00002c  2000              MOVS     r0,#0                 ;564
                  |L20.46|
;;;582    		{
;;;583    			// 执行写入
;;;584    			SPI_FLASH_WriteArray(pBuffer, WriteAddr, SPI_FLASH_SECTOR_SIZE);
;;;585    			// 执行读取
;;;586    			SPI_FLASH_ReadArray(pFlashBuff, WriteAddr, SPI_FLASH_SECTOR_SIZE);
;;;587    
;;;588    			for (i = 0; i < SPI_FLASH_SECTOR_SIZE; i++)
;;;589    			{
;;;590    				if (pBuffer[i] != pFlashBuff[i])
;;;591    				{
;;;592    					free(pFlashBuff);
;;;593    					return FALSE;
;;;594    				}
;;;595    			}
;;;596    
;;;597    			WriteAddr += SPI_FLASH_SECTOR_SIZE;
;;;598    			pBuffer += SPI_FLASH_SECTOR_SIZE;
;;;599    		}
;;;600    
;;;601    		// 执行写入
;;;602    		SPI_FLASH_WriteArray(pBuffer, WriteAddr, NumOfRestByte);
;;;603    		// 执行读取
;;;604    		SPI_FLASH_ReadArray(pFlashBuff, WriteAddr, NumOfRestByte);
;;;605    
;;;606    		for (i = 0; i < NumOfRestByte; i++)
;;;607    		{
;;;608    			if (pBuffer[i] != pFlashBuff[i])
;;;609    			{
;;;610    				free(pFlashBuff);
;;;611    				return FALSE;
;;;612    			}
;;;613    		}
;;;614    	}
;;;615    	else
;;;616    	{
;;;617    		// 执行写入
;;;618    		SPI_FLASH_WriteArray(pBuffer, WriteAddr, NumByteToWrite);
;;;619    		// 执行读取
;;;620    		SPI_FLASH_ReadArray(pFlashBuff, WriteAddr, NumByteToWrite);
;;;621    
;;;622    		for (i = 0; i < NumByteToWrite; i++)
;;;623    		{
;;;624    			if (pBuffer[i] != pFlashBuff[i])
;;;625    			{
;;;626    				free(pFlashBuff);
;;;627    				return FALSE;
;;;628    			}
;;;629    		}
;;;630    	}
;;;631    
;;;632    	free(pFlashBuff);
;;;633    	
;;;634    	return TRUE;
;;;635    }
00002e  e8bd87f0          POP      {r4-r10,pc}
                  |L20.50|
000032  2000              MOVS     r0,#0                 ;573
000034  e7fb              B        |L20.46|
                  |L20.54|
000036  464a              MOV      r2,r9                 ;584
000038  4641              MOV      r1,r8                 ;584
00003a  4620              MOV      r0,r4                 ;584
00003c  f7fffffe          BL       SPI_FLASH_WriteArray
000040  464a              MOV      r2,r9                 ;586
000042  4641              MOV      r1,r8                 ;586
000044  4628              MOV      r0,r5                 ;586
000046  f7fffffe          BL       SPI_FLASH_ReadArray
00004a  2000              MOVS     r0,#0                 ;588
                  |L20.76|
00004c  5c21              LDRB     r1,[r4,r0]            ;590
00004e  5c2a              LDRB     r2,[r5,r0]            ;590
000050  4291              CMP      r1,r2                 ;590
000052  d004              BEQ      |L20.94|
000054  4628              MOV      r0,r5                 ;592
000056  f7fffffe          BL       free
00005a  2000              MOVS     r0,#0                 ;593
00005c  e7e7              B        |L20.46|
                  |L20.94|
00005e  1c40              ADDS     r0,r0,#1              ;588
000060  b280              UXTH     r0,r0                 ;588
000062  4548              CMP      r0,r9                 ;588
000064  d3f2              BCC      |L20.76|
000066  f5085880          ADD      r8,r8,#0x1000         ;597
00006a  f5045480          ADD      r4,r4,#0x1000         ;598
                  |L20.110|
00006e  1e76              SUBS     r6,r6,#1              ;581
000070  b2b6              UXTH     r6,r6                 ;581
000072  d2e0              BCS      |L20.54|
000074  463a              MOV      r2,r7                 ;602
000076  4641              MOV      r1,r8                 ;602
000078  4620              MOV      r0,r4                 ;602
00007a  f7fffffe          BL       SPI_FLASH_WriteArray
00007e  463a              MOV      r2,r7                 ;604
000080  4641              MOV      r1,r8                 ;604
000082  4628              MOV      r0,r5                 ;604
000084  f7fffffe          BL       SPI_FLASH_ReadArray
000088  2000              MOVS     r0,#0                 ;606
00008a  e00a              B        |L20.162|
                  |L20.140|
00008c  5c21              LDRB     r1,[r4,r0]            ;608
00008e  5c2a              LDRB     r2,[r5,r0]            ;608
000090  4291              CMP      r1,r2                 ;608
000092  d004              BEQ      |L20.158|
000094  4628              MOV      r0,r5                 ;610
000096  f7fffffe          BL       free
00009a  2000              MOVS     r0,#0                 ;611
00009c  e7c7              B        |L20.46|
                  |L20.158|
00009e  1c40              ADDS     r0,r0,#1              ;606
0000a0  b280              UXTH     r0,r0                 ;606
                  |L20.162|
0000a2  42b8              CMP      r0,r7                 ;606
0000a4  d3f2              BCC      |L20.140|
0000a6  e018              B        |L20.218|
                  |L20.168|
0000a8  463a              MOV      r2,r7                 ;618
0000aa  4641              MOV      r1,r8                 ;618
0000ac  4620              MOV      r0,r4                 ;618
0000ae  f7fffffe          BL       SPI_FLASH_WriteArray
0000b2  463a              MOV      r2,r7                 ;620
0000b4  4641              MOV      r1,r8                 ;620
0000b6  4628              MOV      r0,r5                 ;620
0000b8  f7fffffe          BL       SPI_FLASH_ReadArray
0000bc  2000              MOVS     r0,#0                 ;622
0000be  e00a              B        |L20.214|
                  |L20.192|
0000c0  5c21              LDRB     r1,[r4,r0]            ;624
0000c2  5c2a              LDRB     r2,[r5,r0]            ;624
0000c4  4291              CMP      r1,r2                 ;624
0000c6  d004              BEQ      |L20.210|
0000c8  4628              MOV      r0,r5                 ;626
0000ca  f7fffffe          BL       free
0000ce  2000              MOVS     r0,#0                 ;627
0000d0  e7ad              B        |L20.46|
                  |L20.210|
0000d2  1c40              ADDS     r0,r0,#1              ;622
0000d4  b280              UXTH     r0,r0                 ;622
                  |L20.214|
0000d6  42b8              CMP      r0,r7                 ;622
0000d8  d3f2              BCC      |L20.192|
                  |L20.218|
0000da  4628              MOV      r0,r5                 ;632
0000dc  f7fffffe          BL       free
0000e0  2001              MOVS     r0,#1                 ;634
0000e2  e7a4              B        |L20.46|
;;;636    
                          ENDP


                          AREA ||i.SPI_FLASH_WriteWithErase||, CODE, READONLY, ALIGN=1

                  SPI_FLASH_WriteWithErase PROC
;;;681    **********************************************************************/
;;;682    void SPI_FLASH_WriteWithErase(uint8* pBuffer, uint32 WriteAddr, uint16 NumByteToWrite)   
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;683    { 
000004  4607              MOV      r7,r0
000006  468b              MOV      r11,r1
000008  4615              MOV      r5,r2
;;;684    	uint32 sectPos = 0;
;;;685    	uint16 sectOff = 0;
;;;686    	uint16 sectRemain = 0;  
;;;687     	uint16 i = 0;
;;;688     	uint8* pFlashBuff = NULL;				// 保存读取扇区的数据
;;;689    
;;;690    	if ((NULL == pBuffer) || (0 == NumByteToWrite))
00000a  2f00              CMP      r7,#0
00000c  d054              BEQ      |L21.184|
00000e  2d00              CMP      r5,#0
000010  d052              BEQ      |L21.184|
;;;691    	{
;;;692    		return;
;;;693    	}
;;;694    	
;;;695    	// 申请4096Byte空间保存扇区数据
;;;696    	pFlashBuff = (uint8 *)malloc(SPI_FLASH_SECTOR_SIZE);
000012  f44f5080          MOV      r0,#0x1000
000016  f7fffffe          BL       malloc
00001a  4680              MOV      r8,r0
;;;697    	
;;;698    	if (NULL == pFlashBuff)
00001c  ea5f0008          MOVS     r0,r8
000020  d04a              BEQ      |L21.184|
;;;699    	{
;;;700    		return;
;;;701    	}
;;;702    	
;;;703    	sectPos = WriteAddr/SPI_FLASH_SECTOR_SIZE;	// 扇区地址
000022  ea4f391b          LSR      r9,r11,#12
;;;704    	sectOff = WriteAddr%SPI_FLASH_SECTOR_SIZE;	// 在扇区内的偏移
000026  f3cb060b          UBFX     r6,r11,#0,#12
;;;705    	sectRemain = SPI_FLASH_SECTOR_SIZE-sectOff;	// 扇区剩余空间大小   
00002a  f5c65480          RSB      r4,r6,#0x1000
;;;706    
;;;707    	if (NumByteToWrite <= sectRemain)
00002e  42a5              CMP      r5,r4
000030  d838              BHI      |L21.164|
;;;708    	{
;;;709    		sectRemain = NumByteToWrite;			// 不大于4096个字节
000032  462c              MOV      r4,r5
000034  e036              B        |L21.164|
                  |L21.54|
;;;710    	}
;;;711    	
;;;712    	while (1) 
;;;713    	{	
;;;714    		// 读出整个扇区的内容
;;;715    		SPI_FLASH_ReadArray(pFlashBuff, sectPos*SPI_FLASH_SECTOR_SIZE, SPI_FLASH_SECTOR_SIZE);
;;;716    		
;;;717    		for (i = 0; i < sectRemain; i++)	// 校验数据
;;;718    		{
;;;719    			if (pFlashBuff[sectOff+i] != 0xFF)
000036  1831              ADDS     r1,r6,r0
000038  f8181001          LDRB     r1,[r8,r1]
00003c  29ff              CMP      r1,#0xff
00003e  d103              BNE      |L21.72|
000040  1c40              ADDS     r0,r0,#1              ;717
000042  b280              UXTH     r0,r0                 ;717
                  |L21.68|
000044  42a0              CMP      r0,r4                 ;717
000046  d3f6              BCC      |L21.54|
                  |L21.72|
;;;720    			{
;;;721    				break;						// 需要擦除  	  
;;;722    			}
;;;723    		}
;;;724    		
;;;725    		if (i < sectRemain)					// 需要擦除
000048  42a0              CMP      r0,r4
00004a  d213              BCS      |L21.116|
;;;726    		{
;;;727    			SPI_FLASH_EraseSector(sectPos * SPI_FLASH_SECTOR_SIZE);// 擦除这个扇区
00004c  4650              MOV      r0,r10
00004e  f7fffffe          BL       SPI_FLASH_EraseSector
;;;728    
;;;729    			// 复制
;;;730    			for (i = 0; i < sectRemain; i++)
000052  2000              MOVS     r0,#0
000054  e005              B        |L21.98|
                  |L21.86|
;;;731    			{
;;;732    				pFlashBuff[i+sectOff] = pBuffer[i];	  
000056  1982              ADDS     r2,r0,r6
000058  5c39              LDRB     r1,[r7,r0]
00005a  f8081002          STRB     r1,[r8,r2]
00005e  1c40              ADDS     r0,r0,#1              ;730
000060  b280              UXTH     r0,r0                 ;730
                  |L21.98|
000062  42a0              CMP      r0,r4                 ;730
000064  d3f7              BCC      |L21.86|
;;;733    			}
;;;734    
;;;735    			// 写入整个扇区
;;;736    			SPI_FLASH_WriteArray(pFlashBuff, sectPos*SPI_FLASH_SECTOR_SIZE, SPI_FLASH_SECTOR_SIZE);
000066  4651              MOV      r1,r10
000068  f44f5280          MOV      r2,#0x1000
00006c  4640              MOV      r0,r8
00006e  f7fffffe          BL       SPI_FLASH_WriteArray
000072  e004              B        |L21.126|
                  |L21.116|
;;;737    		}
;;;738    		else 
;;;739    		{
;;;740    			// 写已经擦除了的,直接写入扇区剩余区间. 	
;;;741    			SPI_FLASH_WriteArray(pBuffer, WriteAddr, sectRemain);	
000074  4622              MOV      r2,r4
000076  4659              MOV      r1,r11
000078  4638              MOV      r0,r7
00007a  f7fffffe          BL       SPI_FLASH_WriteArray
                  |L21.126|
;;;742    		}
;;;743    		
;;;744    		if (NumByteToWrite == sectRemain)
00007e  42a5              CMP      r5,r4
000080  d104              BNE      |L21.140|
;;;745    		{
;;;746    			break;									// 写入结束了
;;;747    		}
;;;748    		else										// 写入未结束
;;;749    		{
;;;750    			sectPos++;								// 扇区地址增1
;;;751    			sectOff = 0;							// 偏移位置为0 	 
;;;752    
;;;753    		   	pBuffer += sectRemain;  				// 指针偏移
;;;754    			WriteAddr += sectRemain;				// 写地址偏移	   
;;;755    		   	NumByteToWrite -= sectRemain;			// 字节数递减
;;;756    		   	
;;;757    			if (NumByteToWrite > SPI_FLASH_SECTOR_SIZE)
;;;758    			{
;;;759    				sectRemain = SPI_FLASH_SECTOR_SIZE;	// 下一个扇区还是写不完
;;;760    			}
;;;761    			else
;;;762    			{
;;;763    				sectRemain=NumByteToWrite;			// 下一个扇区可以写完了	
;;;764    			}
;;;765    		}	 
;;;766    	}
;;;767    
;;;768    	// 释放数据缓存区
;;;769    	free(pFlashBuff);	 	 
000082  4640              MOV      r0,r8
000084  e8bd5ff0          POP      {r4-r12,lr}
000088  f7ffbffe          B.W      free
                  |L21.140|
00008c  f1090901          ADD      r9,r9,#1              ;750
000090  2600              MOVS     r6,#0                 ;751
000092  4427              ADD      r7,r7,r4              ;753
000094  44a3              ADD      r11,r11,r4            ;754
000096  1b28              SUBS     r0,r5,r4              ;755
000098  b285              UXTH     r5,r0                 ;755
00009a  f44f5480          MOV      r4,#0x1000            ;757
00009e  42a5              CMP      r5,r4                 ;757
0000a0  d800              BHI      |L21.164|
0000a2  462c              MOV      r4,r5                 ;763
                  |L21.164|
0000a4  ea4f3a09          LSL      r10,r9,#12            ;715
0000a8  f44f5280          MOV      r2,#0x1000            ;715
0000ac  4651              MOV      r1,r10                ;715
0000ae  4640              MOV      r0,r8                 ;715
0000b0  f7fffffe          BL       SPI_FLASH_ReadArray
0000b4  2000              MOVS     r0,#0                 ;717
0000b6  e7c5              B        |L21.68|
                  |L21.184|
;;;770    }
0000b8  e8bd9ff0          POP      {r4-r12,pc}
;;;771    
                          ENDP


                          AREA ||i.SPI_FLASH_WriteWord||, CODE, READONLY, ALIGN=1

                  SPI_FLASH_WriteWord PROC
;;;655    
;;;656    void SPI_FLASH_WriteWord(uint32 WriteAddr, uint32 data)
000000  b508              PUSH     {r3,lr}
;;;657    {
;;;658    	uint8 buff[4];
;;;659    
;;;660    	buff[0] = (data >> 24) & 0xFF;
000002  0e0a              LSRS     r2,r1,#24
000004  f88d2000          STRB     r2,[sp,#0]
;;;661    	buff[1] = (data >> 16) & 0xFF;
000008  0c0a              LSRS     r2,r1,#16
00000a  f88d2001          STRB     r2,[sp,#1]
;;;662    	buff[2] = (data >> 8) & 0xFF;
00000e  0a0a              LSRS     r2,r1,#8
000010  f88d2002          STRB     r2,[sp,#2]
;;;663    	buff[3] = (data) & 0xFF;
000014  f88d1003          STRB     r1,[sp,#3]
;;;664    	
;;;665    	SPI_FLASH_WriteWithErase(buff, WriteAddr, 4);
000018  4601              MOV      r1,r0
00001a  2204              MOVS     r2,#4
00001c  4668              MOV      r0,sp
00001e  f7fffffe          BL       SPI_FLASH_WriteWithErase
;;;666    }
000022  bd08              POP      {r3,pc}
;;;667    
                          ENDP


                          AREA ||i.SPIx_ConfigureWorkMode||, CODE, READONLY, ALIGN=2

                  SPIx_ConfigureWorkMode PROC
;;;1120   // 配置SPI工作模式
;;;1121   void SPIx_ConfigureWorkMode(uint16 SpiDirection, uint16 SpiDataSize)
000000  b510              PUSH     {r4,lr}
;;;1122   {
;;;1123   	spi_init_struct.trans_mode = SpiDirection;
000002  4a08              LDR      r2,|L23.36|
000004  6050              STR      r0,[r2,#4]  ; spi_init_struct
;;;1124   	spi_init_struct.frame_size = SpiDataSize;
000006  6091              STR      r1,[r2,#8]  ; spi_init_struct
;;;1125   
;;;1126   	spi_init(STM32_SPIx_NUM_DEF, &spi_init_struct);
000008  4c07              LDR      r4,|L23.40|
00000a  4611              MOV      r1,r2
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       spi_init
;;;1127   	spi_enable(STM32_SPIx_NUM_DEF);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       spi_enable
;;;1128   	
;;;1129   	spi_i2s_data_receive(STM32_SPIx_NUM_DEF);
000018  4620              MOV      r0,r4
00001a  e8bd4010          POP      {r4,lr}
00001e  f7ffbffe          B.W      spi_i2s_data_receive
;;;1130   }
;;;1131   
                          ENDP

000022  0000              DCW      0x0000
                  |L23.36|
                          DCD      ||.bss||
                  |L23.40|
                          DCD      0x40013000

                          AREA ||i.SPIx_DMAy_Read||, CODE, READONLY, ALIGN=2

                  SPIx_DMAy_Read PROC
;;;974    // 启动DMA方式读取
;;;975    void SPIx_DMAy_Read(uint32 srcAddr, uint32 dstAddr, uint16 count)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;976    {
000004  4605              MOV      r5,r0
000006  468b              MOV      r11,r1
000008  4690              MOV      r8,r2
;;;977    #if STM32_DMA_SPI_DIRECTION
;;;978    
;;;979    	static uint16 txByte = 0xFF; // dummy
;;;980    
;;;981    	// 入参检查
;;;982    	if (0 == count)
;;;983    	{
;;;984    		return;
;;;985    	}
;;;986    	
;;;987    	// 设置DMA完成标识
;;;988    	spiCB.dmaFinished = FALSE;
;;;989    	// 先禁止SPI以修改配置
;;;990    	spi_disable(STM32_SPIx_NUM_DEF);
;;;991    	
;;;992    	// 关闭DMA
;;;993    	dma_channel_disable(DMA0, DMA_CH1);	
;;;994    	dma_channel_disable(DMA1, DMA_CH2);	
;;;995    
;;;996    	// 先配置全双工模式，以在DMA之前写命令和地址
;;;997    	spi_init_struct.trans_mode = SPI_TRANSMODE_FULLDUPLEX;
;;;998    	spi_init_struct.frame_size = SPI_FRAMESIZE_8BIT;
;;;999    	spi_init(STM32_SPIx_NUM_DEF, &spi_init_struct);
;;;1000   
;;;1001   	// 重新配置接收地址以及接收数量
;;;1002   	dma_rx_init_struct.memory_inc = DMA_MEMORY_INCREASE_ENABLE; // 内存地址增量变化
;;;1003   	dma_rx_init_struct.memory_addr = (uint32)dstAddr;
;;;1004   	dma_rx_init_struct.number = count;
;;;1005   	dma_init(DMA0, DMA_CH1, &dma_rx_init_struct);
;;;1006   
;;;1007   	// 发送为dummy
;;;1008   	dma_tx_init_struct.memory_inc = DMA_MEMORY_INCREASE_DISABLE;// 内存地址增量不变化
;;;1009   	dma_tx_init_struct.memory_addr = (uint32)(&txByte);
;;;1010   	dma_tx_init_struct.number = count;
;;;1011   	dma_init(DMA0, DMA_CH2, &dma_tx_init_struct);
;;;1012   
;;;1013   	// 使能SPI，使用双工模式发送命令和地址
;;;1014   	spi_enable(STM32_SPIx_NUM_DEF);
;;;1015   
;;;1016   	// 片选
;;;1017   	SPI_FLASH_CS_L();
;;;1018   	// 发送读取命令
;;;1019   	SPI_FLASH_SendByte(CMD_READ_BYTE);
;;;1020   	// 发送24位起始地址
;;;1021   	SPI_FLASH_SendByte((srcAddr & 0xFF0000) >> 16);
;;;1022   	SPI_FLASH_SendByte((srcAddr & 0xFF00) >> 8);
;;;1023   	SPI_FLASH_SendByte(srcAddr & 0xFF);
;;;1024   	// 接收前读一次数据DR，保证接收缓冲区为空
;;;1025   	spi_i2s_data_receive(STM32_SPIx_NUM_DEF);
;;;1026   	// 再次禁止SPI以修改配置全双工模式
;;;1027   	spi_disable(STM32_SPIx_NUM_DEF);
;;;1028   	
;;;1029   	// 配置为全双工16位模式
;;;1030   	spi_init_struct.trans_mode = SPI_TRANSMODE_FULLDUPLEX;
;;;1031   	spi_init_struct.frame_size = SPI_FRAMESIZE_8BIT;
;;;1032   	spi_init(STM32_SPIx_NUM_DEF, &spi_init_struct);
;;;1033   	
;;;1034   	// 清DMA标记
;;;1035   	dma_flag_clear(DMA0, DMA_CH1, DMA_FLAG_G);
;;;1036   	dma_flag_clear(DMA0, DMA_CH2, DMA_FLAG_G);
;;;1037   	
;;;1038   	// 使能RX的TC中断
;;;1039   	dma_interrupt_enable(DMA0, DMA_CH1, DMA_INT_FTF);
;;;1040   
;;;1041   	// 重新使能SPI，SCK时钟立刻开始输出，开始发送接收数据
;;;1042   	spi_enable(STM32_SPIx_NUM_DEF);
;;;1043   	spi_i2s_data_receive(STM32_SPIx_NUM_DEF);
;;;1044   
;;;1045   	// 开启DMA通道DMA1_Channel2，DMA1_Channel3
;;;1046   	dma_channel_enable(DMA0, DMA_CH1);	
;;;1047   	dma_channel_enable(DMA1, DMA_CH2);
;;;1048   	
;;;1049   	while(!spiCB.dmaFinished);
;;;1050   
;;;1051   	// DMA读完后，模式重新复位
;;;1052   	SPIx_ConfigureWorkMode(SPI_TRANSMODE_FULLDUPLEX, SPI_FRAMESIZE_8BIT);
;;;1053   	
;;;1054   #else
;;;1055   
;;;1056   	// 入参检查
;;;1057   	if(0 == count)
00000a  f1b80f00          CMP      r8,#0
00000e  d060              BEQ      |L24.210|
;;;1058   	{
;;;1059   		return ;
;;;1060   	}
;;;1061   	
;;;1062   	// 设置DMA完成标识
;;;1063   	spiCB.dmaFinished = FALSE;
000010  4c31              LDR      r4,|L24.216|
000012  2600              MOVS     r6,#0
000014  7026              STRB     r6,[r4,#0]
;;;1064   
;;;1065   	// 先禁止SPI以修改配置
;;;1066   	spi_disable(STM32_SPIx_NUM_DEF);
000016  f8df90c4          LDR      r9,|L24.220|
00001a  4648              MOV      r0,r9
00001c  f7fffffe          BL       spi_disable
;;;1067   	
;;;1068   	// 关闭DMA
;;;1069   	dma_channel_disable(DMA0, DMA_CH1);
000020  f8dfa0bc          LDR      r10,|L24.224|
000024  2101              MOVS     r1,#1
000026  4650              MOV      r0,r10
000028  f7fffffe          BL       dma_channel_disable
;;;1070   	
;;;1071   	// 先配置全双工模式，以在DMA之前写命令和地址
;;;1072   	spi_init_struct.trans_mode = SPI_TRANSMODE_FULLDUPLEX;
00002c  4f2d              LDR      r7,|L24.228|
00002e  607e              STR      r6,[r7,#4]  ; spi_init_struct
;;;1073   	spi_init_struct.frame_size = SPI_FRAMESIZE_8BIT;
000030  60be              STR      r6,[r7,#8]  ; spi_init_struct
;;;1074       spi_init(STM32_SPIx_NUM_DEF, &spi_init_struct);	
000032  4639              MOV      r1,r7
000034  4648              MOV      r0,r9
000036  f7fffffe          BL       spi_init
;;;1075   	
;;;1076   	// 重新配置接收地址以及接收数量
;;;1077   	dma_rx_init_struct.memory_inc = DMA_MEMORY_INCREASE_ENABLE;	// 内存地址增量变化
00003a  f1070038          ADD      r0,r7,#0x38
00003e  2101              MOVS     r1,#1
000040  7641              STRB     r1,[r0,#0x19]
;;;1078   	dma_rx_init_struct.memory_addr = (uint32)dstAddr;
000042  f8c0b008          STR      r11,[r0,#8]  ; dma_rx_init_struct
;;;1079   	dma_rx_init_struct.number = count;
000046  f8c08010          STR      r8,[r0,#0x10]  ; dma_rx_init_struct
;;;1080   	dma_init(DMA0, DMA_CH1, &dma_rx_init_struct);
00004a  4602              MOV      r2,r0
00004c  4650              MOV      r0,r10
00004e  f7fffffe          BL       dma_init
;;;1081   
;;;1082   	// 使能SPI，使用双工模式发送命令和地址
;;;1083   	spi_enable(STM32_SPIx_NUM_DEF);
000052  4648              MOV      r0,r9
000054  f7fffffe          BL       spi_enable
;;;1084   	// 片选
;;;1085   	SPI_FLASH_CS_L();
000058  2110              MOVS     r1,#0x10
00005a  4823              LDR      r0,|L24.232|
00005c  f7fffffe          BL       gpio_bit_reset
;;;1086   	// 发送读取命令
;;;1087   	SPI_FLASH_SendByte(CMD_READ_BYTE);
000060  2003              MOVS     r0,#3
000062  f7fffffe          BL       SPI_FLASH_SendByte
;;;1088   	// 发送24位起始地址
;;;1089   	SPI_FLASH_SendByte((srcAddr & 0xFF0000) >> 16);
000066  f3c54007          UBFX     r0,r5,#16,#8
00006a  f7fffffe          BL       SPI_FLASH_SendByte
;;;1090   	SPI_FLASH_SendByte((srcAddr & 0xFF00) >> 8);
00006e  f3c52007          UBFX     r0,r5,#8,#8
000072  f7fffffe          BL       SPI_FLASH_SendByte
;;;1091   	SPI_FLASH_SendByte(srcAddr & 0xFF);
000076  b2e8              UXTB     r0,r5
000078  f7fffffe          BL       SPI_FLASH_SendByte
;;;1092   	// 接收前读一次数据DR，保证接收缓冲区为空
;;;1093   	spi_i2s_data_receive(STM32_SPIx_NUM_DEF);
00007c  4648              MOV      r0,r9
00007e  f7fffffe          BL       spi_i2s_data_receive
;;;1094   	// 再次禁止SPI以修改配置为只接收模式
;;;1095   	spi_disable(STM32_SPIx_NUM_DEF);
000082  4648              MOV      r0,r9
000084  f7fffffe          BL       spi_disable
;;;1096   	// 配置为只接收16位模式
;;;1097   	spi_init_struct.trans_mode = SPI_TRANSMODE_RECEIVEONLY;
000088  f44f6080          MOV      r0,#0x400
00008c  6078              STR      r0,[r7,#4]  ; spi_init_struct
;;;1098   	spi_init_struct.frame_size = SPI_FRAMESIZE_8BIT; 
00008e  60be              STR      r6,[r7,#8]  ; spi_init_struct
;;;1099   	spi_init(STM32_SPIx_NUM_DEF, &spi_init_struct);
000090  4639              MOV      r1,r7
000092  4648              MOV      r0,r9
000094  f7fffffe          BL       spi_init
;;;1100   
;;;1101   	// 清DMA标记
;;;1102   	dma_flag_clear(DMA0, DMA_CH1, DMA_FLAG_G);// 清RX全局中断标志
000098  2201              MOVS     r2,#1
00009a  4611              MOV      r1,r2
00009c  4650              MOV      r0,r10
00009e  f7fffffe          BL       dma_flag_clear
;;;1103   	// 使能RX的TC中断
;;;1104   	dma_interrupt_enable(DMA0, DMA_CH1, DMA_INT_FTF);
0000a2  2202              MOVS     r2,#2
0000a4  2101              MOVS     r1,#1
0000a6  4650              MOV      r0,r10
0000a8  f7fffffe          BL       dma_interrupt_enable
;;;1105   
;;;1106   	// 重新使能SPI，SCK时钟立刻开始输出，开始接收数据
;;;1107   	spi_enable(STM32_SPIx_NUM_DEF);
0000ac  4648              MOV      r0,r9
0000ae  f7fffffe          BL       spi_enable
;;;1108   	spi_i2s_data_receive(STM32_SPIx_NUM_DEF);
0000b2  4648              MOV      r0,r9
0000b4  f7fffffe          BL       spi_i2s_data_receive
;;;1109   	
;;;1110   	// 开启DMA通道DMA0_Channel1
;;;1111   	dma_channel_enable(DMA0, DMA_CH1);
0000b8  2101              MOVS     r1,#1
0000ba  4650              MOV      r0,r10
0000bc  f7fffffe          BL       dma_channel_enable
                  |L24.192|
;;;1112   
;;;1113   	while(!spiCB.dmaFinished);
0000c0  7820              LDRB     r0,[r4,#0]  ; spiCB
0000c2  2800              CMP      r0,#0
0000c4  d0fc              BEQ      |L24.192|
;;;1114   
;;;1115   	// DMA读完后，模式重新复位
;;;1116   	SPIx_ConfigureWorkMode(SPI_TRANSMODE_FULLDUPLEX, SPI_FRAMESIZE_8BIT);
0000c6  e8bd5ff0          POP      {r4-r12,lr}
0000ca  2100              MOVS     r1,#0
0000cc  4608              MOV      r0,r1
0000ce  f7ffbffe          B.W      SPIx_ConfigureWorkMode
                  |L24.210|
;;;1117   #endif
;;;1118   } 
0000d2  e8bd9ff0          POP      {r4-r12,pc}
;;;1119   
                          ENDP

0000d6  0000              DCW      0x0000
                  |L24.216|
                          DCD      ||.data||
                  |L24.220|
                          DCD      0x40013000
                  |L24.224|
                          DCD      0x40020000
                  |L24.228|
                          DCD      ||.bss||
                  |L24.232|
                          DCD      0x40010800

                          AREA ||i.SPIx_DMAy_SendBuffer||, CODE, READONLY, ALIGN=2

                  SPIx_DMAy_SendBuffer PROC
;;;902    // DMA发送(只支持也写256Byte)
;;;903    void SPIx_DMAy_SendBuffer(uint8 *sendBuffer, uint32 WriteAddr, uint16 ndtr)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;904    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
;;;905    #if STM32_DMA_SPI_DIRECTION
;;;906    	// 关闭DMA
;;;907    	spi_dma_disable(STM32_SPIx_NUM_DEF, SPI_DMA_TRANSMIT);
;;;908    	
;;;909    	dma_tx_init_struct.memory_inc = DMA_MEMORY_INCREASE_ENABLE;
;;;910    	dma_tx_init_struct.memory_addr = (uint32)sendBuffer;
;;;911    	dma_tx_init_struct.number = ndtr;
;;;912    	dma_init(DMA0,DMA_CH2,&dma_tx_init_struct);
;;;913    
;;;914    	// 片选
;;;915    	SPI_FLASH_CS_L();
;;;916    	// 发送页写入命令
;;;917    	SPI_FLASH_SendByte(CMD_PAGE_WRITE);
;;;918    	// 写入24位起始地址
;;;919    	SPI_FLASH_SendByte((WriteAddr >> 16) & 0xFF);
;;;920    	SPI_FLASH_SendByte((WriteAddr >> 8) & 0xFF);
;;;921    	SPI_FLASH_SendByte(WriteAddr & 0xFF);
;;;922    
;;;923    	// 清DMA标记
;;;924    	dma_flag_clear(DMA0,DMA_CH2, DMA_FLAG_G);
;;;925    
;;;926    	// 使能TX的TC中断
;;;927    	dma_interrupt_enable(DMA0, DMA_CH2, DMA_INT_FTF);
;;;928    
;;;929    	// 开启DMA通道DMA0_Channel2
;;;930    	spi_dma_enable(STM32_SPIx_NUM_DEF, SPI_DMA_TRANSMIT);
;;;931    	
;;;932    #else
;;;933    
;;;934    	// 先禁止SPI以修改配置
;;;935    	spi_disable(STM32_SPIx_NUM_DEF);
00000a  4f1f              LDR      r7,|L25.136|
00000c  4638              MOV      r0,r7
00000e  f7fffffe          BL       spi_disable
;;;936    	
;;;937    	// 关闭DMA
;;;938    	spi_dma_disable(STM32_SPIx_NUM_DEF, SPI_DMA_TRANSMIT);
000012  2100              MOVS     r1,#0
000014  4638              MOV      r0,r7
000016  f7fffffe          BL       spi_dma_disable
;;;939    
;;;940    	// 全双工发送接收模式，此时不用理会接收的数据
;;;941    	// 数据的开始以填数据进SPI_DR为启动时刻
;;;942    	spi_init_struct.trans_mode = SPI_TRANSMODE_FULLDUPLEX;
00001a  491c              LDR      r1,|L25.140|
00001c  2000              MOVS     r0,#0
00001e  6048              STR      r0,[r1,#4]  ; spi_init_struct
;;;943    	spi_init(STM32_SPIx_NUM_DEF, &spi_init_struct);
000020  4638              MOV      r0,r7
000022  f7fffffe          BL       spi_init
;;;944    
;;;945    	dma_tx_init_struct.memory_inc = DMA_MEMORY_INCREASE_ENABLE;
000026  4919              LDR      r1,|L25.140|
000028  2001              MOVS     r0,#1
00002a  311c              ADDS     r1,r1,#0x1c
00002c  7648              STRB     r0,[r1,#0x19]
;;;946    	dma_tx_init_struct.memory_addr = (uint32)sendBuffer;
00002e  608d              STR      r5,[r1,#8]  ; dma_tx_init_struct
;;;947    	dma_tx_init_struct.number = ndtr;
000030  610e              STR      r6,[r1,#0x10]  ; dma_tx_init_struct
;;;948    	dma_init(DMA0, DMA_CH2, &dma_tx_init_struct);
000032  4d17              LDR      r5,|L25.144|
000034  460a              MOV      r2,r1
000036  2102              MOVS     r1,#2
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       dma_init
;;;949    
;;;950    	// 使能SPI，使用双工模式发送命令和地址
;;;951    	spi_enable(STM32_SPIx_NUM_DEF);
00003e  4638              MOV      r0,r7
000040  f7fffffe          BL       spi_enable
;;;952    
;;;953    	// 片选
;;;954    	SPI_FLASH_CS_L();
000044  2110              MOVS     r1,#0x10
000046  4813              LDR      r0,|L25.148|
000048  f7fffffe          BL       gpio_bit_reset
;;;955    	// 发送页写入命令
;;;956    	SPI_FLASH_SendByte(CMD_PAGE_WRITE);
00004c  2002              MOVS     r0,#2
00004e  f7fffffe          BL       SPI_FLASH_SendByte
;;;957    	// 写入24位起始地址
;;;958    	SPI_FLASH_SendByte((WriteAddr >> 16) & 0xFF);
000052  f3c44007          UBFX     r0,r4,#16,#8
000056  f7fffffe          BL       SPI_FLASH_SendByte
;;;959    	SPI_FLASH_SendByte((WriteAddr >> 8) & 0xFF);
00005a  f3c42007          UBFX     r0,r4,#8,#8
00005e  f7fffffe          BL       SPI_FLASH_SendByte
;;;960    	SPI_FLASH_SendByte(WriteAddr & 0xFF);
000062  b2e0              UXTB     r0,r4
000064  f7fffffe          BL       SPI_FLASH_SendByte
;;;961    
;;;962    	// 清DMA标记
;;;963    	dma_flag_clear(DMA0, DMA_CH2, DMA_FLAG_G);
000068  2201              MOVS     r2,#1
00006a  2102              MOVS     r1,#2
00006c  4628              MOV      r0,r5
00006e  f7fffffe          BL       dma_flag_clear
;;;964    	
;;;965    	// 使能TX的TC中断
;;;966    	dma_interrupt_enable(DMA0, DMA_CH2, DMA_INT_FTF);
000072  2202              MOVS     r2,#2
000074  4611              MOV      r1,r2
000076  4628              MOV      r0,r5
000078  f7fffffe          BL       dma_interrupt_enable
;;;967    	
;;;968    	// 开启DMA通道DMA0_Channel2
;;;969    	spi_dma_enable(STM32_SPIx_NUM_DEF, SPI_DMA_TRANSMIT);
00007c  4638              MOV      r0,r7
00007e  e8bd41f0          POP      {r4-r8,lr}
000082  2100              MOVS     r1,#0
000084  f7ffbffe          B.W      spi_dma_enable
;;;970    
;;;971    #endif
;;;972    }  
;;;973    
                          ENDP

                  |L25.136|
                          DCD      0x40013000
                  |L25.140|
                          DCD      ||.bss||
                  |L25.144|
                          DCD      0x40020000
                  |L25.148|
                          DCD      0x40010800

                          AREA ||i.SPIx_FLASH_Init||, CODE, READONLY, ALIGN=2

                  SPIx_FLASH_Init PROC
;;;52     // 初始化SPI Flash驱动端口
;;;53     void SPIx_FLASH_Init(void)
000000  b570              PUSH     {r4-r6,lr}
;;;54     {
;;;55     	// GD32 - SPI
;;;56     	if(STM32_SPIx_NUM_DEF == SPI0)
;;;57     	{
;;;58     		/*
;;;59     		* PA5 --> SPI1 SCK 			Mode: GPIO_Mode_AF_PP
;;;60     		* PA7 --> SPI1 MOSI Write	Mode: GPIO_Mode_AF_PP
;;;61     		* PA6 --> SPI1 MISO Read	Mode: GPIO_Mode_IPU
;;;62     		* PA4 --> SPI1 CS			Mode: GPIO_Mode_Out_PP
;;;63     		*/
;;;64     		
;;;65     		// 使能GPIO时钟
;;;66     		rcu_periph_clock_enable(RCU_GPIOA);
000002  f2406002          MOV      r0,#0x602
000006  f7fffffe          BL       rcu_periph_clock_enable
;;;67     		
;;;68     	    // SPI0 GPIO config: SCK/PA5, MOSI/PA7
;;;69     		gpio_init(GPIOA, GPIO_MODE_AF_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_5 | GPIO_PIN_7);
00000a  4c18              LDR      r4,|L26.108|
00000c  23a0              MOVS     r3,#0xa0
00000e  2203              MOVS     r2,#3
000010  2118              MOVS     r1,#0x18
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       gpio_init
;;;70     
;;;71     		// SPI0 GPIO config: MISO/PA6
;;;72     	    gpio_init(GPIOA, GPIO_MODE_IPU, GPIO_OSPEED_50MHZ, GPIO_PIN_6);
000018  2340              MOVS     r3,#0x40
00001a  2203              MOVS     r2,#3
00001c  2148              MOVS     r1,#0x48
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       gpio_init
;;;73     
;;;74     		// SPI0 GPIO config: NSS/PA4
;;;75     		gpio_init(GPIOA, GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_4);
000024  2310              MOVS     r3,#0x10
000026  2203              MOVS     r2,#3
000028  4619              MOV      r1,r3
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       gpio_init
;;;76     		
;;;77     		// SPIx配置选项
;;;78     		rcu_periph_clock_enable(RCU_SPI0);
000030  f240600c          MOV      r0,#0x60c
000034  f7fffffe          BL       rcu_periph_clock_enable
;;;79     	
;;;80     	}
;;;81     	else
;;;82     	{
;;;83     		// 使能GPIO时钟
;;;84     		rcu_periph_clock_enable(RCU_GPIOB);
;;;85     		
;;;86     		// SPI1 GPIO config: SCK/PB13, MOSI/PB15
;;;87     	    gpio_init(GPIOB, GPIO_MODE_AF_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_13 |GPIO_PIN_15);
;;;88     
;;;89     		// SPI1 GPIO config: MISO/PB14
;;;90     	    gpio_init(GPIOB, GPIO_MODE_AF_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_14);
;;;91     
;;;92     		// SPI1 GPIO config: NSS/PB12
;;;93     		gpio_init(GPIOB, GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_12);
;;;94     
;;;95     		// SPIx配置选项
;;;96     		rcu_periph_clock_enable(RCU_SPI1);
;;;97     	}
;;;98     
;;;99     	spi_i2s_deinit(STM32_SPIx_NUM_DEF);
000038  4d0d              LDR      r5,|L26.112|
00003a  4628              MOV      r0,r5
00003c  f7fffffe          BL       spi_i2s_deinit
;;;100    
;;;101        spi_init_struct.trans_mode           = SPI_TRANSMODE_FULLDUPLEX;
000040  490c              LDR      r1,|L26.116|
000042  2400              MOVS     r4,#0
000044  604c              STR      r4,[r1,#4]  ; spi_init_struct
;;;102        spi_init_struct.device_mode          = SPI_MASTER;
000046  f44f7082          MOV      r0,#0x104
00004a  6008              STR      r0,[r1,#0]  ; spi_init_struct
;;;103        spi_init_struct.frame_size           = SPI_FRAMESIZE_8BIT;
00004c  608c              STR      r4,[r1,#8]  ; spi_init_struct
;;;104        spi_init_struct.clock_polarity_phase = SPI_CK_PL_LOW_PH_1EDGE;				// 空闲时CLK拉底，在第一个时钟跳变沿采集第一个数据
00004e  614c              STR      r4,[r1,#0x14]  ; spi_init_struct
;;;105        spi_init_struct.nss                  = SPI_NSS_SOFT;						// 片选软件控制
000050  1568              ASRS     r0,r5,#21
000052  60c8              STR      r0,[r1,#0xc]  ; spi_init_struct
;;;106    
;;;107    	// APB2 - SPI0 - 72M
;;;108    	// APB1 - SPI1/SPI2 - 36M
;;;109    	spi_init_struct.prescale             = SPI_PSC_4;							// 72/2=36M
000054  2008              MOVS     r0,#8
000056  6188              STR      r0,[r1,#0x18]  ; spi_init_struct
;;;110        spi_init_struct.endian               = SPI_ENDIAN_MSB;						// 先发送高位
000058  610c              STR      r4,[r1,#0x10]  ; spi_init_struct
;;;111    	spi_init(STM32_SPIx_NUM_DEF, &spi_init_struct);
00005a  4628              MOV      r0,r5
00005c  f7fffffe          BL       spi_init
;;;112    
;;;113    	// 使能SPIx
;;;114    	spi_enable(STM32_SPIx_NUM_DEF);
000060  4628              MOV      r0,r5
000062  f7fffffe          BL       spi_enable
;;;115    
;;;116    	// 使能DMA功能
;;;117    	//DMAy_SPIx_Configuration();
;;;118    
;;;119    	spiCB.dmaFinished = FALSE;
000066  4804              LDR      r0,|L26.120|
000068  7004              STRB     r4,[r0,#0]
;;;120    
;;;121    #if SPI_FLASH_UNIT_TEST
;;;122    	SPI_FLASH_UnitTest();
;;;123    #endif
;;;124    }
00006a  bd70              POP      {r4-r6,pc}
;;;125    
                          ENDP

                  |L26.108|
                          DCD      0x40010800
                  |L26.112|
                          DCD      0x40013000
                  |L26.116|
                          DCD      ||.bss||
                  |L26.120|
                          DCD      ||.data||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  spi_init_struct
                          %        28
                  dma_tx_init_struct
                          %        28
                  dma_rx_init_struct
                          %        28

                          AREA ||.data||, DATA, ALIGN=0

                  spiCB
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "User\\spiflash.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_spiflash_c_de66f17a____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___10_spiflash_c_de66f17a____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_spiflash_c_de66f17a____REVSH|
#line 128
|__asm___10_spiflash_c_de66f17a____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
