; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\keymsgprocess.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\keymsgprocess.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -IC:\Users\Administrator\AppData\Local\Arm\Packs\GigaDevice\GD32F10x_DFP\2.0.1\Device\Include -D__MICROLIB -D__UVISION_VERSION=534 -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\keymsgprocess.crf User\keyMsgProcess.c]
                          THUMB

                          AREA ||i.KEYMSG_CALLBACK_Scan||, CODE, READONLY, ALIGN=2

                  KEYMSG_CALLBACK_Scan PROC
;;;209    // 【接口功能】按键处理回调函数，在定时器控制下，被周期调用，实现按键扫描
;;;210    void KEYMSG_CALLBACK_Scan(uint32 param)
000000  4901              LDR      r1,|L1.8|
;;;211    {
;;;212    	keyMsgCB.scanRequest = TRUE;
000002  2001              MOVS     r0,#1
000004  7008              STRB     r0,[r1,#0]
;;;213    }
000006  4770              BX       lr
;;;214    
                          ENDP

                  |L1.8|
                          DCD      ||.bss||

                          AREA ||i.KEYMSG_ClearGlobalMaskRequest||, CODE, READONLY, ALIGN=2

                  KEYMSG_ClearGlobalMaskRequest PROC
;;;546    // 清除全局屏蔽请求
;;;547    void KEYMSG_ClearGlobalMaskRequest(void)
000000  4902              LDR      r1,|L2.12|
;;;548    {
;;;549    	keyMsgCB.globalMaskRequest = FALSE;
000002  2000              MOVS     r0,#0
000004  f88100d0          STRB     r0,[r1,#0xd0]
;;;550    }
000008  4770              BX       lr
;;;551    
                          ENDP

00000a  0000              DCW      0x0000
                  |L2.12|
                          DCD      ||.bss||

                          AREA ||i.KEYMSG_ClearMaskRequest||, CODE, READONLY, ALIGN=2

                  KEYMSG_ClearMaskRequest PROC
;;;534    // 清除指定按键的指定消息的屏蔽请求
;;;535    void KEYMSG_ClearMaskRequest(KEY_NAME_E keyName, KEY_MSG_E keyMsg)
000000  4b03              LDR      r3,|L3.16|
;;;536    {
;;;537    	keyMsgCB.msgMaskRequest[keyName][keyMsg] = FALSE;
000002  2200              MOVS     r2,#0
000004  eb030080          ADD      r0,r3,r0,LSL #2
000008  4408              ADD      r0,r0,r1
00000a  f88020c0          STRB     r2,[r0,#0xc0]
;;;538    }
00000e  4770              BX       lr
;;;539    
                          ENDP

                  |L3.16|
                          DCD      ||.bss||

                          AREA ||i.KEYMSG_GetAddDecKeyUpRecoveryRequest||, CODE, READONLY, ALIGN=2

                  KEYMSG_GetAddDecKeyUpRecoveryRequest PROC
;;;558    // 获取+-键弹起恢复请求
;;;559    BOOL KEYMSG_GetAddDecKeyUpRecoveryRequest(void)
000000  4801              LDR      r0,|L4.8|
;;;560    {
;;;561    	return keyMsgCB.addDecKeyUpRercoveryRequest;
000002  f89000d1          LDRB     r0,[r0,#0xd1]  ; keyMsgCB
;;;562    }
000006  4770              BX       lr
;;;563    
                          ENDP

                  |L4.8|
                          DCD      ||.bss||

                          AREA ||i.KEYMSG_Init||, CODE, READONLY, ALIGN=2

                  KEYMSG_Init PROC
;;;81     // 【使用方法】在 main 中大循环之前调用，注意，在调用本接口之前，必须完成定时器模块初始化
;;;82     void KEYMSG_Init(void)
000000  b57c              PUSH     {r2-r6,lr}
;;;83     {
;;;84     	uint8 i,j;
;;;85     
;;;86     	// 数据结构初始化
;;;87     	for(i=0; i<KEY_NAME_MAX; i++)
000002  2100              MOVS     r1,#0
;;;88     	{
;;;89     		keyMsgCB.keyMsgInfo[i].end = 0;
000004  4d22              LDR      r5,|L5.144|
;;;90     		for(j=0; j<KEY_INFO_SIZE; j++)
;;;91     		{
;;;92     			keyMsgCB.keyMsgInfo[i].stateCount[j] = KEY_STATE_MASK;
000006  f44f4200          MOV      r2,#0x8000
00000a  2400              MOVS     r4,#0
                  |L5.12|
00000c  eb010081          ADD      r0,r1,r1,LSL #2       ;89
000010  eb0503c0          ADD      r3,r5,r0,LSL #3       ;89
000014  711c              STRB     r4,[r3,#4]            ;89
000016  2000              MOVS     r0,#0                 ;90
                  |L5.24|
000018  eb030640          ADD      r6,r3,r0,LSL #1
00001c  80f2              STRH     r2,[r6,#6]
00001e  1c40              ADDS     r0,r0,#1              ;90
000020  b2c0              UXTB     r0,r0                 ;90
000022  2802              CMP      r0,#2                 ;90
000024  d3f8              BCC      |L5.24|
;;;93     		}
;;;94     
;;;95     		// 清除所有消息的屏蔽请求
;;;96     		for(j=0; j<KEY_MSG_MAX; j++)
000026  2000              MOVS     r0,#0
;;;97     		{
;;;98     			keyMsgCB.msgMaskRequest[i][j] = FALSE;
000028  eb050381          ADD      r3,r5,r1,LSL #2
                  |L5.44|
00002c  181e              ADDS     r6,r3,r0
00002e  f88640c0          STRB     r4,[r6,#0xc0]
000032  1c40              ADDS     r0,r0,#1              ;96
000034  b2c0              UXTB     r0,r0                 ;96
000036  2804              CMP      r0,#4                 ;96
000038  d3f8              BCC      |L5.44|
00003a  1c49              ADDS     r1,r1,#1              ;87
00003c  b2c9              UXTB     r1,r1                 ;87
00003e  2904              CMP      r1,#4                 ;87
000040  d3e4              BCC      |L5.12|
;;;99     		}
;;;100    	}
;;;101    	for(i=0; i<sizeof(keyMsgCB.keyValue); i++)
000042  2000              MOVS     r0,#0
;;;102    	{
;;;103    		keyMsgCB.keyValue[i] = 0xFF;
000044  21ff              MOVS     r1,#0xff
                  |L5.70|
000046  182a              ADDS     r2,r5,r0
000048  7051              STRB     r1,[r2,#1]
00004a  1c40              ADDS     r0,r0,#1              ;101
00004c  b2c0              UXTB     r0,r0                 ;101
00004e  2800              CMP      r0,#0                 ;101
000050  d0f9              BEQ      |L5.70|
;;;104    		#if 0==KEY_MSG_THROW_KEY_UP_AFTER_REPEAT
;;;105    		keyMsgCB.keyUpMsgMaskBit[i] = 0x00;
;;;106    		#endif
;;;107    	}
;;;108    	
;;;109    	// 消息环形队列初始化
;;;110    	keyMsgCB.msgQueue.head = 0;
000052  f88540a4          STRB     r4,[r5,#0xa4]
;;;111    	keyMsgCB.msgQueue.end  = 0;
000056  f88540a5          STRB     r4,[r5,#0xa5]
;;;112    	for(i=0; i<KEY_MSG_QUEUE_SIZE; i++)
00005a  2000              MOVS     r0,#0
;;;113    	{
;;;114    		keyMsgCB.msgQueue.node[i].keyName = KEY_NAME_NULL;
00005c  2205              MOVS     r2,#5
                  |L5.94|
00005e  eb050140          ADD      r1,r5,r0,LSL #1
000062  f8012fa6          STRB     r2,[r1,#0xa6]!
;;;115    		keyMsgCB.msgQueue.node[i].keyMsg = KEY_MSG_NULL;
000066  704a              STRB     r2,[r1,#1]
000068  1c40              ADDS     r0,r0,#1              ;112
00006a  b2c0              UXTB     r0,r0                 ;112
00006c  280a              CMP      r0,#0xa               ;112
00006e  d3f6              BCC      |L5.94|
;;;116    	}
;;;117    	
;;;118    	keyMsgCB.scanRequest = FALSE;
000070  702c              STRB     r4,[r5,#0]
;;;119     
;;;120    	// 按键消息服务初始化
;;;121    	KEYMSG_StopAllService();
000072  f7fffffe          BL       KEYMSG_StopAllService
;;;122    	
;;;123    	// 按键刷新函数接口初始化
;;;124    	keyMsgCB.KeyUpdate = NULL;
000076  f8c540bc          STR      r4,[r5,#0xbc]  ; keyMsgCB
;;;125    	
;;;126    	// 启动按键扫描
;;;127    	TIMER_AddTask(TIMER_ID_KEY_SCAN,
00007a  f04f30ff          MOV      r0,#0xffffffff
00007e  e9cd0400          STRD     r0,r4,[sp,#0]
000082  2300              MOVS     r3,#0
000084  4a03              LDR      r2,|L5.148|
000086  2132              MOVS     r1,#0x32
000088  2001              MOVS     r0,#1
00008a  f7fffffe          BL       TIMER_AddTask
;;;128    					KEY_SCAN_TIME,
;;;129    					KEYMSG_CALLBACK_Scan,
;;;130    					0,
;;;131    					TIMER_LOOP_FOREVER,
;;;132    					ACTION_MODE_DO_AT_ONCE);
;;;133    }
00008e  bd7c              POP      {r2-r6,pc}
;;;134    
                          ENDP

                  |L5.144|
                          DCD      ||.bss||
                  |L5.148|
                          DCD      KEYMSG_CALLBACK_Scan

                          AREA ||i.KEYMSG_MsgProcess||, CODE, READONLY, ALIGN=2

                  KEYMSG_MsgProcess PROC
;;;292    // 【接口功能】按键消息处理
;;;293    void KEYMSG_MsgProcess(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;294    {
;;;295    	uint8 i;
;;;296    	KEYMSG_INFO_CB* pKeyInfo = NULL;
;;;297    	uint16 currentCount = 0;	// 当前按键状态计数值
;;;298    	uint16 currentState = 0;	// 当前按键状态
;;;299    	uint16* pStateCount = NULL;	// 当前操作中的状态计数值
;;;300    	
;;;301    	// 遍历当前的状态，根据需要抛出按键消息，添加到按键环形队列中
;;;302    	for(i=0; i<KEY_NAME_MAX; i++)
000002  2500              MOVS     r5,#0
;;;303    	{
;;;304    		// 获取当前按键信息结构体指针
;;;305    		pKeyInfo = &keyMsgCB.keyMsgInfo[i];
000004  4f2b              LDR      r7,|L6.180|
;;;306    		
;;;307    		// 获取当前操作中的按键状态计数值指针
;;;308    		pStateCount = &(pKeyInfo->stateCount[pKeyInfo->end]);
;;;309    		
;;;310    		// 获取当前按键状态
;;;311    		currentState = (*pStateCount) & KEY_STATE_MASK;
;;;312    		
;;;313    		// 获取当前按键状态计数值
;;;314    		currentCount = (*pStateCount) & (~KEY_STATE_MASK);
;;;315    		
;;;316    		// 最高位为0，说明当前状态为按键按下
;;;317    		if(0 == currentState)
;;;318    		{
;;;319    			// 当前状态计数值为1，说明当前状态为第一次出现，需要抛出按下消息
;;;320    			if(1 == currentCount)
;;;321    			{
;;;322    			#if 1==KEY_MSG_SWITCH_DOWN
;;;323    				// 抛出按键按下消息
;;;324    				KEYMSG_ThrowMsg((KEY_NAME_E)i, KEY_MSG_DOWN);
;;;325    			#endif
;;;326    			#if 0==KEY_MSG_THROW_KEY_UP_AFTER_REPEAT	// KEY_UP 屏蔽位置位时，不抛出 KEY_UP 消息
;;;327    				keyMsgCB.keyUpMsgMaskBit[i/8] &= (0x01<<(i%8));	// 按键按下时解除 KEY_UP 限制
;;;328    			#endif
;;;329    				// 计数值清零，即代表已抛出消息
;;;330    				(*pStateCount) &= KEY_STATE_MASK;
;;;331    			}
;;;332    			// 当前状态计数值大于1，则判断是否达到长按门限
;;;333    			else if(currentCount > 1)
;;;334    			{
;;;335    				// 达到长按门限，抛出长按消息，注意这里的判断条件，不能用>，否则将不断抛出长按消息
;;;336    			#if 0==KEY_MSG_USE_SAME_HOLD_THRESHOLD
;;;337    				if(currentCount*KEY_SCAN_TIME == keyHoldThreshHold[i])	// 每个按键使用单独的长按门限
000006  4e2c              LDR      r6,|L6.184|
                  |L6.8|
000008  eb050085          ADD      r0,r5,r5,LSL #2       ;305
00000c  eb0700c0          ADD      r0,r7,r0,LSL #3       ;305
000010  1d00              ADDS     r0,r0,#4              ;305
000012  7801              LDRB     r1,[r0,#0]            ;308
000014  eb000441          ADD      r4,r0,r1,LSL #1       ;308
000018  1ca4              ADDS     r4,r4,#2              ;308
00001a  8820              LDRH     r0,[r4,#0]            ;311
00001c  f4004100          AND      r1,r0,#0x8000         ;311
000020  f4204000          BIC      r0,r0,#0x8000         ;314
000024  b111              CBZ      r1,|L6.44|
;;;338    			#else
;;;339    				if(currentCount*KEY_SCAN_TIME == KEY_HOLD_TIME) // 所有按键使用统一的长按门限
;;;340    			#endif
;;;341    				{
;;;342    				#if 1==KEY_MSG_SWITCH_HOLD
;;;343    					// 抛出按键长按消息
;;;344    					KEYMSG_ThrowMsg((KEY_NAME_E)i, KEY_MSG_HOLD);
;;;345    				#endif
;;;346    				#if 0==KEY_MSG_THROW_KEY_UP_AFTER_REPEAT	// KEY_UP 屏蔽位置位时，不抛出 KEY_UP 消息
;;;347    					keyMsgCB.keyUpMsgMaskBit[i/8] |= (0x01<<(i%8));	// 按键长按时设置 KEY_UP 限制
;;;348    				#endif
;;;349    					// 计数值增加1，防止下一次重复抛出长按消息
;;;350    					(*pStateCount)++;
;;;351    				}
;;;352    				// 超出长按门限，判断是否达到重复抛出门限
;;;353    			#if 0==KEY_MSG_USE_SAME_HOLD_THRESHOLD
;;;354    				else if(currentCount*KEY_SCAN_TIME >= keyHoldThreshHold[i] + keyRepeatTime[i])	// 每个按键使用单独的长按门限
;;;355    			#else
;;;356    				else if(currentCount*KEY_SCAN_TIME >= KEY_HOLD_TIME + KEY_RETHROW_TIME) // 所有按键使用统一的长按门限
;;;357    			#endif
;;;358    				{
;;;359    				#if 1==KEY_MSG_SWITCH_REPEAT
;;;360    					// 抛出按键重复消息
;;;361    					KEYMSG_ThrowMsg((KEY_NAME_E)i, KEY_MSG_REPEAT);
;;;362    				#endif
;;;363    					
;;;364    					// 将计数值设置为长按门限+1，为下次抛出重复消息做准备
;;;365    					(*pStateCount) &= KEY_STATE_MASK;
;;;366    				#if 0==KEY_MSG_USE_SAME_HOLD_THRESHOLD
;;;367    					(*pStateCount) += (keyHoldThreshHold[i]/KEY_SCAN_TIME) + 1; // 每个按键使用单独的长按门限
;;;368    				#else
;;;369    					(*pStateCount) += (KEY_HOLD_TIME/KEY_SCAN_TIME) + 1;	// 所有按键使用统一的长按门限
;;;370    				#endif
;;;371    				}
;;;372    				// 未达到长按门限，不予处理
;;;373    				else
;;;374    				{}
;;;375    			}
;;;376    			// 当前状态计数值为0，说明已抛出边沿消息，不再予以处理
;;;377    			else
;;;378    			{}
;;;379    		}
;;;380    		// 最高位为1，说明当前状态为按键释放
;;;381    		else
;;;382    		{
;;;383    			// 当前状态计数值为1，说明当前状态为第一次出现，需要抛出释放消息
;;;384    			if(1 == currentCount)
000026  2801              CMP      r0,#1
000028  d036              BEQ      |L6.152|
00002a  e03d              B        |L6.168|
                  |L6.44|
00002c  2801              CMP      r0,#1                 ;320
00002e  d011              BEQ      |L6.84|
000030  d93a              BLS      |L6.168|
000032  f8361015          LDRH     r1,[r6,r5,LSL #1]     ;337
000036  eb0002c0          ADD      r2,r0,r0,LSL #3       ;337
00003a  eb021000          ADD      r0,r2,r0,LSL #4       ;337
00003e  ebb10f40          CMP      r1,r0,LSL #1          ;337
000042  d110              BNE      |L6.102|
000044  2102              MOVS     r1,#2                 ;344
000046  4628              MOV      r0,r5                 ;344
000048  f7fffffe          BL       KEYMSG_ThrowMsg
00004c  8820              LDRH     r0,[r4,#0]            ;350
00004e  1c40              ADDS     r0,r0,#1              ;350
000050  8020              STRH     r0,[r4,#0]            ;350
000052  e029              B        |L6.168|
                  |L6.84|
000054  2100              MOVS     r1,#0                 ;324
000056  4628              MOV      r0,r5                 ;324
000058  f7fffffe          BL       KEYMSG_ThrowMsg
00005c  8820              LDRH     r0,[r4,#0]            ;330
00005e  f4004000          AND      r0,r0,#0x8000         ;330
000062  8020              STRH     r0,[r4,#0]            ;330
000064  e020              B        |L6.168|
                  |L6.102|
000066  4a14              LDR      r2,|L6.184|
000068  3208              ADDS     r2,r2,#8              ;354
00006a  f8322015          LDRH     r2,[r2,r5,LSL #1]     ;354
00006e  4411              ADD      r1,r1,r2              ;354
000070  ebb10f40          CMP      r1,r0,LSL #1          ;354
000074  d818              BHI      |L6.168|
000076  2103              MOVS     r1,#3                 ;361
000078  4628              MOV      r0,r5                 ;361
00007a  f7fffffe          BL       KEYMSG_ThrowMsg
00007e  8820              LDRH     r0,[r4,#0]            ;365
000080  f4004000          AND      r0,r0,#0x8000         ;365
000084  8020              STRH     r0,[r4,#0]            ;365
000086  f8361015          LDRH     r1,[r6,r5,LSL #1]     ;367
00008a  2232              MOVS     r2,#0x32              ;367
00008c  fbb1f1f2          UDIV     r1,r1,r2              ;367
000090  1c49              ADDS     r1,r1,#1              ;367
000092  4408              ADD      r0,r0,r1              ;367
000094  8020              STRH     r0,[r4,#0]            ;367
000096  e007              B        |L6.168|
                  |L6.152|
;;;385    			{
;;;386    			#if 1==KEY_MSG_SWITCH_UP
;;;387    				// 抛出按键释放消息
;;;388    				KEYMSG_ThrowMsg((KEY_NAME_E)i, KEY_MSG_UP);
000098  2101              MOVS     r1,#1
00009a  4628              MOV      r0,r5
00009c  f7fffffe          BL       KEYMSG_ThrowMsg
;;;389    			#endif
;;;390    				
;;;391    				// 计数值清零，即代表已抛出消息
;;;392    				(*pStateCount) &= KEY_STATE_MASK;
0000a0  8820              LDRH     r0,[r4,#0]
0000a2  f4004000          AND      r0,r0,#0x8000
0000a6  8020              STRH     r0,[r4,#0]
                  |L6.168|
0000a8  1c6d              ADDS     r5,r5,#1              ;302
0000aa  b2ed              UXTB     r5,r5                 ;302
0000ac  2d04              CMP      r5,#4                 ;302
0000ae  d3ab              BCC      |L6.8|
;;;393    			}
;;;394    			// 计数值为0时，说明已抛出边沿消息，不再予以处理
;;;395    			// 计数值>1时，为按键释放状态下计数，不予处理
;;;396    			else
;;;397    			{}
;;;398    		}
;;;399    	}
;;;400    }
0000b0  bdf0              POP      {r4-r7,pc}
;;;401    
                          ENDP

0000b2  0000              DCW      0x0000
                  |L6.180|
                          DCD      ||.bss||
                  |L6.184|
                          DCD      ||.constdata||

                          AREA ||i.KEYMSG_Process||, CODE, READONLY, ALIGN=1

                  KEYMSG_Process PROC
;;;440    // 【使用方法】在 main 中大循环内调用
;;;441    void KEYMSG_Process(void)
000000  b510              PUSH     {r4,lr}
;;;442    {
;;;443    	// 按键扫描处理
;;;444    	KEYMSG_ScanProcess();
000002  f7fffffe          BL       KEYMSG_ScanProcess
;;;445    	
;;;446    	// 按键消息处理
;;;447    	KEYMSG_MsgProcess();
000006  f7fffffe          BL       KEYMSG_MsgProcess
;;;448    	
;;;449    	// 按键服务处理
;;;450    	KEYMSG_ServiceProcess();
00000a  e8bd4010          POP      {r4,lr}
00000e  f7ffbffe          B.W      KEYMSG_ServiceProcess
;;;451    }
;;;452    
                          ENDP


                          AREA ||i.KEYMSG_RegisterKeyScanCallback||, CODE, READONLY, ALIGN=2

                  KEYMSG_RegisterKeyScanCallback PROC
;;;139    //             并通过此接口向本模块注册，需要注意的是：按键按下为0，按键释放为1
;;;140    void KEYMSG_RegisterKeyScanCallback(void(*fun)(uint8* p8bitKeyValueArray))
000000  4901              LDR      r1,|L8.8|
;;;141    {
;;;142    	keyMsgCB.KeyUpdate = fun;
000002  f8c100bc          STR      r0,[r1,#0xbc]  ; keyMsgCB
;;;143    }
000006  4770              BX       lr
;;;144    
                          ENDP

                  |L8.8|
                          DCD      ||.bss||

                          AREA ||i.KEYMSG_RegisterMsgService||, CODE, READONLY, ALIGN=2

                  KEYMSG_RegisterMsgService PROC
;;;148    // 【使用方法】用于注册按键消息服务，执行之前无须先注销，可直接调用本接口改变消息服务，注册的服务函数的形式必须与本接口中形参一致
;;;149    void KEYMSG_RegisterMsgService(KEY_NAME_E keyName, KEY_MSG_E keyMsg, void(*service)(uint32 param), uint32 param)
000000  b510              PUSH     {r4,lr}
;;;150    {
;;;151    	// 参数合法性检验
;;;152    	if(keyName >= KEY_NAME_MAX)
000002  2804              CMP      r0,#4
000004  d20c              BCS      |L9.32|
;;;153    	{
;;;154    		return ;
;;;155    	}
;;;156    	if(keyMsg >= KEY_MSG_MAX)
000006  2904              CMP      r1,#4
000008  d20a              BCS      |L9.32|
;;;157    	{
;;;158    		return ;
;;;159    	}
;;;160    	if(!service)
00000a  2a00              CMP      r2,#0
00000c  d008              BEQ      |L9.32|
;;;161    	{
;;;162    		return ;
;;;163    	}
;;;164    	
;;;165    	// 配置按键服务
;;;166    	keyMsgCB.keyMsgInfo[keyName].service[keyMsg] = service;
00000e  eb000480          ADD      r4,r0,r0,LSL #2
000012  4804              LDR      r0,|L9.36|
000014  eb0000c4          ADD      r0,r0,r4,LSL #3
000018  eb000081          ADD      r0,r0,r1,LSL #2
00001c  60c2              STR      r2,[r0,#0xc]
;;;167    	keyMsgCB.keyMsgInfo[keyName].param[keyMsg] = param;
00001e  61c3              STR      r3,[r0,#0x1c]
                  |L9.32|
;;;168    }
000020  bd10              POP      {r4,pc}
;;;169    
                          ENDP

000022  0000              DCW      0x0000
                  |L9.36|
                          DCD      ||.bss||

                          AREA ||i.KEYMSG_ScanProcess||, CODE, READONLY, ALIGN=2

                  KEYMSG_ScanProcess PROC
;;;216    // 【接口功能】按键扫描处理
;;;217    void KEYMSG_ScanProcess(void)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;218    {
;;;219    	uint8 i;
;;;220    	KEYMSG_INFO_CB* pKeyInfo = NULL;
;;;221    	uint16 currentKeyBit = 0;	// 当前按键状态，无论哪个按键，都需要把按键值移动到最高位，以便与状态队列中的数值进行比较
;;;222    	
;;;223    	uint16 currentCount = 0;	// 当前按键状态计数值
;;;224    	uint16 currentState = 0;	// 当前按键状态
;;;225    	uint16* pStateCount = NULL;	// 当前操作中的状态计数值
;;;226    
;;;227    	if(!keyMsgCB.scanRequest)
000004  4f22              LDR      r7,|L10.144|
000006  7838              LDRB     r0,[r7,#0]  ; keyMsgCB
000008  2800              CMP      r0,#0
00000a  d03f              BEQ      |L10.140|
;;;228    	{
;;;229    		return ;
;;;230    	}
;;;231    	
;;;232    	keyMsgCB.scanRequest = FALSE;
00000c  2000              MOVS     r0,#0
00000e  7038              STRB     r0,[r7,#0]
;;;233    	
;;;234    	// 调用回调函数读取按键值，未注册回调函数时退出
;;;235    	if(NULL == keyMsgCB.KeyUpdate)
000010  f8d710bc          LDR      r1,[r7,#0xbc]  ; keyMsgCB
000014  2900              CMP      r1,#0
000016  d039              BEQ      |L10.140|
;;;236    	{
;;;237    		return ;
;;;238    	}
;;;239    	(*keyMsgCB.KeyUpdate)(keyMsgCB.keyValue);
000018  1c78              ADDS     r0,r7,#1
00001a  4788              BLX      r1
;;;240    	
;;;241    	// 对每个按键当前的状态进行处理，将按键状态放入各自的按键信息节点中
;;;242    	for(i=0; i<KEY_NAME_MAX; i++)
00001c  2100              MOVS     r1,#0
;;;243    	{
;;;244    		// 获取当前按键信息结构体指针
;;;245    		pKeyInfo = &keyMsgCB.keyMsgInfo[i];
;;;246    		
;;;247    		// 获取当前操作中的按键状态计数值指针
;;;248    		pStateCount = &(pKeyInfo->stateCount[pKeyInfo->end]);
;;;249    		
;;;250    		// 获取当前按键状态
;;;251    		currentState = (*pStateCount) & KEY_STATE_MASK;
;;;252    		
;;;253    		// 获取当前按键状态计数值
;;;254    		currentCount = (*pStateCount) & (~KEY_STATE_MASK);
;;;255    		
;;;256    		// 获取当前读取到的按键状态，并移位
;;;257    		currentKeyBit = keyMsgCB.keyValue[i/8]&(0x01<<(i%8));	// 屏蔽其它按键值，只保留当前按键值
00001e  f04f0801          MOV      r8,#1
                  |L10.34|
000022  eb010081          ADD      r0,r1,r1,LSL #2       ;245
000026  eb0702c0          ADD      r2,r7,r0,LSL #3       ;245
00002a  f812cf04          LDRB     r12,[r2,#4]!          ;248
00002e  eb02034c          ADD      r3,r2,r12,LSL #1      ;248
000032  1c9b              ADDS     r3,r3,#2              ;248
000034  881c              LDRH     r4,[r3,#0]            ;251
000036  f4044900          AND      r9,r4,#0x8000         ;251
00003a  f4244600          BIC      r6,r4,#0x8000         ;254
00003e  eb0700d1          ADD      r0,r7,r1,LSR #3
000042  7845              LDRB     r5,[r0,#1]
000044  f0010007          AND      r0,r1,#7
000048  fa08fa00          LSL      r10,r8,r0
00004c  ea05050a          AND      r5,r5,r10
;;;258    		currentKeyBit <<= 7 + 8 - (i%8);					// 将按键值移位到16bit的最高位
000050  f1c0000f          RSB      r0,r0,#0xf
000054  4085              LSLS     r5,r5,r0
000056  b2ad              UXTH     r5,r5
;;;259    
;;;260    		// 如果当前按键状态与上一次状态相同，则最后一个状态计数值递增
;;;261    		if(currentKeyBit == currentState)
000058  454d              CMP      r5,r9
00005a  d10a              BNE      |L10.114|
;;;262    		{
;;;263    			// 次数未溢出时，可以递增，否则不变
;;;264    			if(currentCount < (KEY_STATE_MASK-1))
00005c  f64770ff          MOV      r0,#0x7fff
000060  4286              CMP      r6,r0
000062  d20f              BCS      |L10.132|
;;;265    			{
;;;266    				// 【计数值处理方法说明】
;;;267    				// 计数值为0，说明当前计数值为1，并且已抛出边沿消息；
;;;268    				// 计数值为1，说明当前计数值为1，但未抛出边沿消息；
;;;269    				// 计数值 >1，代表实际的计数值
;;;270    				// 因此遇到计数值为0时，说明前面已经抛出了边沿消息，计数值需要增加2，以避免重复抛出边沿消息
;;;271    				if(0 == currentCount)
000064  b116              CBZ      r6,|L10.108|
;;;272    				{
;;;273    					(*pStateCount) += 2;
;;;274    				}
;;;275    				else
;;;276    				{
;;;277    					(*pStateCount) ++;
000066  1c64              ADDS     r4,r4,#1
000068  801c              STRH     r4,[r3,#0]
00006a  e00b              B        |L10.132|
                  |L10.108|
00006c  1ca4              ADDS     r4,r4,#2              ;273
00006e  801c              STRH     r4,[r3,#0]            ;273
000070  e008              B        |L10.132|
                  |L10.114|
;;;278    				}
;;;279    			}
;;;280    		}
;;;281    		// 当前按键状态与上一次状态不同，则新增状态，同时触发对应消息
;;;282    		else
;;;283    		{
;;;284    			pKeyInfo->end ++;
000072  f10c0c01          ADD      r12,r12,#1
;;;285    			pKeyInfo->end %= KEY_INFO_SIZE;
000076  f00c0001          AND      r0,r12,#1
00007a  7010              STRB     r0,[r2,#0]
;;;286    			pKeyInfo->stateCount[pKeyInfo->end] = currentKeyBit + 1;	// 当前状态添加到队列末尾，并且计数值赋1
00007c  eb020040          ADD      r0,r2,r0,LSL #1
000080  1c6d              ADDS     r5,r5,#1
000082  8045              STRH     r5,[r0,#2]
                  |L10.132|
000084  1c49              ADDS     r1,r1,#1              ;242
000086  b2c9              UXTB     r1,r1                 ;242
000088  2904              CMP      r1,#4                 ;242
00008a  d3ca              BCC      |L10.34|
                  |L10.140|
;;;287    		}
;;;288    	}
;;;289    }
00008c  e8bd87f0          POP      {r4-r10,pc}
;;;290    
                          ENDP

                  |L10.144|
                          DCD      ||.bss||

                          AREA ||i.KEYMSG_ServiceDoNothing||, CODE, READONLY, ALIGN=1

                  KEYMSG_ServiceDoNothing PROC
;;;72     // 【使用方法】空函数，什么也不做
;;;73     void KEYMSG_ServiceDoNothing(uint32 param)
000000  4770              BX       lr
;;;74     {
;;;75     	return ;
;;;76     }
;;;77     
                          ENDP


                          AREA ||i.KEYMSG_ServiceProcess||, CODE, READONLY, ALIGN=2

                  KEYMSG_ServiceProcess PROC
;;;403    // 【接口功能】按键服务处理
;;;404    void KEYMSG_ServiceProcess(void)
000000  b510              PUSH     {r4,lr}
;;;405    {
;;;406    	KEY_NAME_E keyName;
;;;407    	KEY_MSG_E keyMsg;
;;;408    	void (*service)(uint32 param) = 0;
;;;409    	
;;;410    	// 消息队列为空，退出
;;;411    	if(keyMsgCB.msgQueue.head == keyMsgCB.msgQueue.end)
000002  4c12              LDR      r4,|L12.76|
000004  f89400a4          LDRB     r0,[r4,#0xa4]  ; keyMsgCB
000008  f89410a5          LDRB     r1,[r4,#0xa5]  ; keyMsgCB
00000c  4288              CMP      r0,r1
00000e  d01b              BEQ      |L12.72|
;;;412    	{
;;;413    		return ;
;;;414    	}
;;;415    	
;;;416    	// 取出最早的消息执行
;;;417    	keyName  = keyMsgCB.msgQueue.node[keyMsgCB.msgQueue.head].keyName;
000010  eb040140          ADD      r1,r4,r0,LSL #1
000014  f8110fa6          LDRB     r0,[r1,#0xa6]!
;;;418    	keyMsg = keyMsgCB.msgQueue.node[keyMsgCB.msgQueue.head].keyMsg;
000018  7849              LDRB     r1,[r1,#1]
;;;419    	
;;;420    	if(keyName >= KEY_NAME_MAX)
00001a  2804              CMP      r0,#4
00001c  d214              BCS      |L12.72|
;;;421    	{
;;;422    		return ;
;;;423    	}
;;;424    	if(keyMsg >= KEY_MSG_MAX)
00001e  2904              CMP      r1,#4
000020  d212              BCS      |L12.72|
;;;425    	{
;;;426    		return ;
;;;427    	}
;;;428    	
;;;429    	// 执行已注册的按键消息服务
;;;430    	service = keyMsgCB.keyMsgInfo[keyName].service[keyMsg];
000022  eb000080          ADD      r0,r0,r0,LSL #2
000026  eb0400c0          ADD      r0,r4,r0,LSL #3
00002a  eb000081          ADD      r0,r0,r1,LSL #2
00002e  68c1              LDR      r1,[r0,#0xc]
;;;431    	(*service)(keyMsgCB.keyMsgInfo[keyName].param[keyMsg]);
000030  69c0              LDR      r0,[r0,#0x1c]
000032  4788              BLX      r1
;;;432    	
;;;433    	keyMsgCB.msgQueue.head ++;
000034  f8140fa4          LDRB     r0,[r4,#0xa4]!  ; keyMsgCB
000038  1c40              ADDS     r0,r0,#1
00003a  b2c0              UXTB     r0,r0
;;;434    	keyMsgCB.msgQueue.head %= KEY_MSG_QUEUE_SIZE;
00003c  210a              MOVS     r1,#0xa
00003e  fbb0f2f1          UDIV     r2,r0,r1
000042  fb010012          MLS      r0,r1,r2,r0
000046  7020              STRB     r0,[r4,#0]
                  |L12.72|
;;;435    }
000048  bd10              POP      {r4,pc}
;;;436    
                          ENDP

00004a  0000              DCW      0x0000
                  |L12.76|
                          DCD      ||.bss||

                          AREA ||i.KEYMSG_SetAddDecKeyUpRecoveryRequest||, CODE, READONLY, ALIGN=2

                  KEYMSG_SetAddDecKeyUpRecoveryRequest PROC
;;;552    // 设置+-键弹起恢复请求
;;;553    void KEYMSG_SetAddDecKeyUpRecoveryRequest(BOOL state)
000000  4901              LDR      r1,|L13.8|
;;;554    {
;;;555    	keyMsgCB.addDecKeyUpRercoveryRequest = state;
000002  f88100d1          STRB     r0,[r1,#0xd1]
;;;556    }
000006  4770              BX       lr
;;;557    
                          ENDP

                  |L13.8|
                          DCD      ||.bss||

                          AREA ||i.KEYMSG_SetGlobalMaskRequest||, CODE, READONLY, ALIGN=2

                  KEYMSG_SetGlobalMaskRequest PROC
;;;540    // 设置全局屏蔽请求
;;;541    void KEYMSG_SetGlobalMaskRequest(void)
000000  4902              LDR      r1,|L14.12|
;;;542    {
;;;543    	keyMsgCB.globalMaskRequest = TRUE;
000002  2001              MOVS     r0,#1
000004  f88100d0          STRB     r0,[r1,#0xd0]
;;;544    }
000008  4770              BX       lr
;;;545    
                          ENDP

00000a  0000              DCW      0x0000
                  |L14.12|
                          DCD      ||.bss||

                          AREA ||i.KEYMSG_SetMaskRequest||, CODE, READONLY, ALIGN=2

                  KEYMSG_SetMaskRequest PROC
;;;528    // 设置指定按键的指定消息的屏蔽请求
;;;529    void KEYMSG_SetMaskRequest(KEY_NAME_E keyName, KEY_MSG_E keyMsg)
000000  4b03              LDR      r3,|L15.16|
;;;530    {
;;;531    	keyMsgCB.msgMaskRequest[keyName][keyMsg] = TRUE;
000002  2201              MOVS     r2,#1
000004  eb030080          ADD      r0,r3,r0,LSL #2
000008  4408              ADD      r0,r0,r1
00000a  f88020c0          STRB     r2,[r0,#0xc0]
;;;532    }
00000e  4770              BX       lr
;;;533    
                          ENDP

                  |L15.16|
                          DCD      ||.bss||

                          AREA ||i.KEYMSG_StopAllService||, CODE, READONLY, ALIGN=2

                  KEYMSG_StopAllService PROC
;;;193    // 【使用方法】停止所有按键所有消息的响应
;;;194    void KEYMSG_StopAllService(void)
000000  b530              PUSH     {r4,r5,lr}
;;;195    {
;;;196    	uint8 i,j;
;;;197    	
;;;198    	// 按键消息服务初始化
;;;199    	for(i=0; i<KEY_NAME_MAX; i++)
000002  2100              MOVS     r1,#0
;;;200    	{
;;;201    		for(j=0; j<KEY_MSG_MAX; j++)
;;;202    		{
;;;203    			keyMsgCB.keyMsgInfo[i].service[j] = KEYMSG_ServiceDoNothing;
000004  4a09              LDR      r2,|L16.44|
000006  4d0a              LDR      r5,|L16.48|
                  |L16.8|
000008  2000              MOVS     r0,#0                 ;201
00000a  eb010381          ADD      r3,r1,r1,LSL #2
00000e  eb0503c3          ADD      r3,r5,r3,LSL #3
                  |L16.18|
000012  eb030480          ADD      r4,r3,r0,LSL #2
000016  60e2              STR      r2,[r4,#0xc]
000018  1c40              ADDS     r0,r0,#1              ;201
00001a  b2c0              UXTB     r0,r0                 ;201
00001c  2804              CMP      r0,#4                 ;201
00001e  d3f8              BCC      |L16.18|
000020  1c49              ADDS     r1,r1,#1              ;199
000022  b2c9              UXTB     r1,r1                 ;199
000024  2904              CMP      r1,#4                 ;199
000026  d3ef              BCC      |L16.8|
;;;204    		}
;;;205    	}
;;;206    }
000028  bd30              POP      {r4,r5,pc}
;;;207    
                          ENDP

00002a  0000              DCW      0x0000
                  |L16.44|
                          DCD      KEYMSG_ServiceDoNothing
                  |L16.48|
                          DCD      ||.bss||

                          AREA ||i.KEYMSG_StopService||, CODE, READONLY, ALIGN=2

                  KEYMSG_StopService PROC
;;;173    // 【使用方法】需要停止按键消息响应时，通过本接口停止对指定按键的指定消息的响应
;;;174    void KEYMSG_StopService(KEY_NAME_E keyName, KEY_MSG_E keyMsg)
000000  2804              CMP      r0,#4
;;;175    {
000002  d20a              BCS      |L17.26|
;;;176    	// 参数合法性检验
;;;177    	if(keyName >= KEY_NAME_MAX)
;;;178    	{
;;;179    		return ;
;;;180    	}
;;;181    	if(keyMsg >= KEY_MSG_MAX)
000004  2904              CMP      r1,#4
000006  d208              BCS      |L17.26|
;;;182    	{
;;;183    		return ;
;;;184    	}
;;;185    	
;;;186    	// 将对应按键的对应服务设置为空
;;;187    	keyMsgCB.keyMsgInfo[keyName].service[keyMsg] = KEYMSG_ServiceDoNothing;
000008  4b05              LDR      r3,|L17.32|
00000a  eb000080          ADD      r0,r0,r0,LSL #2
00000e  eb0300c0          ADD      r0,r3,r0,LSL #3
000012  eb000081          ADD      r0,r0,r1,LSL #2
000016  4a01              LDR      r2,|L17.28|
000018  60c2              STR      r2,[r0,#0xc]
                  |L17.26|
;;;188    }
00001a  4770              BX       lr
;;;189    
                          ENDP

                  |L17.28|
                          DCD      KEYMSG_ServiceDoNothing
                  |L17.32|
                          DCD      ||.bss||

                          AREA ||i.KEYMSG_ThrowMsg||, CODE, READONLY, ALIGN=2

                  KEYMSG_ThrowMsg PROC
;;;454    // 【接口功能】抛出按键消息，保存在消息环形队列中
;;;455    uint8 KEYMSG_ThrowMsg(KEY_NAME_E keyName, KEY_MSG_E keyMsg)
000000  b570              PUSH     {r4-r6,lr}
;;;456    {
;;;457    	// 当前按键的当前消息有屏蔽请求，则不添加，并清除屏蔽请求
;;;458    	if(keyMsgCB.msgMaskRequest[keyName][keyMsg])
000002  4a1d              LDR      r2,|L18.120|
000004  eb020380          ADD      r3,r2,r0,LSL #2
000008  440b              ADD      r3,r3,r1
00000a  f89340c0          LDRB     r4,[r3,#0xc0]
00000e  2c00              CMP      r4,#0
000010  d003              BEQ      |L18.26|
;;;459    	{
;;;460    		keyMsgCB.msgMaskRequest[keyName][keyMsg] = FALSE;
000012  2000              MOVS     r0,#0
000014  f88300c0          STRB     r0,[r3,#0xc0]
;;;461    
;;;462    		return 0;
;;;463    	}
;;;464    
;;;465    	// 有全局屏蔽请求，则退出
;;;466    	if(keyMsgCB.globalMaskRequest)
;;;467    	{
;;;468    		return 0;
;;;469    	}
;;;470    	
;;;471    	// 消息队列满，禁止添加
;;;472    	if(((keyMsgCB.msgQueue.end+1)%KEY_MSG_QUEUE_SIZE) == keyMsgCB.msgQueue.head)
;;;473    	{
;;;474    #if 0==KEY_MSG_PRIORITY	// 旧消息优先时，队列满禁止添加
;;;475    	  
;;;476    		return 0;
;;;477    		
;;;478    #else	// 新消息优先时，队列满，删除最早的消息
;;;479    		
;;;480    		keyMsgCB.msgQueue.head ++;
;;;481    		keyMsgCB.msgQueue.head %= KEY_MSG_QUEUE_SIZE;
;;;482    #endif
;;;483    	}
;;;484    	
;;;485    #if 0==KEY_MSG_THROW_KEY_UP_AFTER_REPEAT	// KEY_REPEAT 消息后禁止抛出 KEY_UP 消息
;;;486    	// KEY_UP 屏蔽位置位时，不抛出 KEY_UP 消息，并且清除屏蔽位
;;;487    	if((KEY_MSG_UP == keyMsg) && (keyMsgCB.keyUpMsgMaskBit[keyName/8] & (0x01<<(keyName%8))))
;;;488    	{
;;;489    		keyMsgCB.keyUpMsgMaskBit[keyName/8] &= (0x01<<(keyName%8));
;;;490    	}
;;;491    	else
;;;492    	{
;;;493    		// 添加到队列中
;;;494    		keyMsgCB.msgQueue.node[keyMsgCB.msgQueue.end].keyName  = keyName;
;;;495    		keyMsgCB.msgQueue.node[keyMsgCB.msgQueue.end].keyMsg = keyMsg;
;;;496    		// 队尾后移
;;;497    		keyMsgCB.msgQueue.end ++;
;;;498    		keyMsgCB.msgQueue.end %= KEY_MSG_QUEUE_SIZE;
;;;499    	}
;;;500    #else	// 无论何种情况，按键释放时均抛出 KEY_UP 消息
;;;501    	// 添加到队列中
;;;502    	keyMsgCB.msgQueue.node[keyMsgCB.msgQueue.end].keyName  = keyName;
;;;503    	keyMsgCB.msgQueue.node[keyMsgCB.msgQueue.end].keyMsg = keyMsg;
;;;504    	
;;;505    	// 队尾后移
;;;506    	keyMsgCB.msgQueue.end ++;
;;;507    	keyMsgCB.msgQueue.end %= KEY_MSG_QUEUE_SIZE;
;;;508    #endif
;;;509    
;;;510    	return 1;
;;;511    }
000018  bd70              POP      {r4-r6,pc}
                  |L18.26|
00001a  f89230d0          LDRB     r3,[r2,#0xd0]         ;466  ; keyMsgCB
00001e  b10b              CBZ      r3,|L18.36|
000020  2000              MOVS     r0,#0                 ;468
000022  bd70              POP      {r4-r6,pc}
                  |L18.36|
000024  f89240a5          LDRB     r4,[r2,#0xa5]         ;472  ; keyMsgCB
000028  230a              MOVS     r3,#0xa               ;472
00002a  4625              MOV      r5,r4                 ;472
00002c  1c64              ADDS     r4,r4,#1              ;472
00002e  fbb4f6f3          UDIV     r6,r4,r3              ;472
000032  fb034616          MLS      r6,r3,r6,r4           ;472
000036  f89240a4          LDRB     r4,[r2,#0xa4]         ;472  ; keyMsgCB
00003a  42a6              CMP      r6,r4                 ;472
00003c  d107              BNE      |L18.78|
00003e  1c64              ADDS     r4,r4,#1              ;480
000040  b2e4              UXTB     r4,r4                 ;480
000042  fbb4f6f3          UDIV     r6,r4,r3              ;481
000046  fb034416          MLS      r4,r3,r6,r4           ;481
00004a  f88240a4          STRB     r4,[r2,#0xa4]         ;481
                  |L18.78|
00004e  eb020445          ADD      r4,r2,r5,LSL #1       ;502
000052  f88400a6          STRB     r0,[r4,#0xa6]         ;502
000056  f89200a5          LDRB     r0,[r2,#0xa5]         ;503  ; keyMsgCB
00005a  eb020040          ADD      r0,r2,r0,LSL #1       ;503
00005e  f88010a7          STRB     r1,[r0,#0xa7]         ;503
000062  f8120fa5          LDRB     r0,[r2,#0xa5]!        ;506  ; keyMsgCB
000066  1c40              ADDS     r0,r0,#1              ;506
000068  b2c0              UXTB     r0,r0                 ;506
00006a  fbb0f1f3          UDIV     r1,r0,r3              ;507
00006e  fb030011          MLS      r0,r3,r1,r0           ;507
000072  7010              STRB     r0,[r2,#0]            ;507
000074  2001              MOVS     r0,#1                 ;510
000076  bd70              POP      {r4-r6,pc}
;;;512    
                          ENDP

                  |L18.120|
                          DCD      ||.bss||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  keyMsgCB
                          %        212

                          AREA ||.constdata||, DATA, READONLY, ALIGN=1

                  keyHoldThreshHold
000000  07d005dc          DCW      0x07d0,0x05dc
000004  07d003e8          DCW      0x07d0,0x03e8
                  keyRepeatTime
000008  012c012c          DCW      0x012c,0x012c
00000c  012c012c          DCW      0x012c,0x012c

;*** Start embedded assembler ***

#line 1 "User\\keyMsgProcess.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_keyMsgProcess_c_7077c383____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___15_keyMsgProcess_c_7077c383____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_keyMsgProcess_c_7077c383____REVSH|
#line 128
|__asm___15_keyMsgProcess_c_7077c383____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
