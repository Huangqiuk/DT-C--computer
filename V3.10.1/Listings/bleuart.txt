; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\bleuart.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\bleuart.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -IC:\Users\Administrator\AppData\Local\Arm\Packs\GigaDevice\GD32F10x_DFP\2.0.1\Device\Include -D__MICROLIB -D__UVISION_VERSION=534 -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\bleuart.crf User\BleUart.c]
                          THUMB

                          AREA ||i.BLE_CMD_GPIO_CtrlPin||, CODE, READONLY, ALIGN=1

                  BLE_CMD_GPIO_CtrlPin PROC
;;;422    // BLE模块辅助控制引脚
;;;423    void BLE_CMD_GPIO_CtrlPin(void)
000000  4770              BX       lr
;;;424    {
;;;425    //	// 打开时钟
;;;426    //	rcu_periph_clock_enable(RCU_GPIOA);
;;;427    //	rcu_periph_clock_enable(RCU_GPIOC);
;;;428    //	gpio_init(GPIOA, GPIO_MODE_OUT_PP, GPIO_OSPEED_2MHZ, GPIO_PIN_11);
;;;429    //	gpio_init(GPIOA, GPIO_MODE_OUT_PP, GPIO_OSPEED_2MHZ, GPIO_PIN_12);
;;;430    
;;;431    //	// 释放复位
;;;432    //	BLE_RST_RELEASE();
;;;433    //	// 允许开始广播
;;;434    //	BLE_EN_ENABLE();
;;;435    
;;;436    //	gpio_init(GPIOC, GPIO_MODE_OUT_PP, GPIO_OSPEED_2MHZ, GPIO_PIN_12);
;;;437    
;;;438    //	// 上电后一直处于发送准备状态
;;;439    //	gpio_bit_reset(GPIOC, GPIO_PIN_12);
;;;440    }
;;;441    
                          ENDP


                          AREA ||i.BLE_MODULE_Reset||, CODE, READONLY, ALIGN=1

                  BLE_MODULE_Reset PROC
;;;538    // BLE模块复位
;;;539    void BLE_MODULE_Reset(uint32 param)
000000  200a              MOVS     r0,#0xa
;;;540    {
;;;541    	// 蓝牙复位
;;;542    	BLE_RST_RESET();
;;;543    	Delayms(10);
000002  f7ffbffe          B.W      Delayms
;;;544    	
;;;545    	// 释放复位
;;;546    	BLE_RST_RELEASE();
;;;547    
;;;548    	// 允许开始广播
;;;549    	BLE_EN_ENABLE();
;;;550    }
;;;551    
                          ENDP


                          AREA ||i.BLE_UART_AddTxArray||, CODE, READONLY, ALIGN=2

                  BLE_UART_AddTxArray PROC
;;;480    // 向发送缓冲区中添加一条待发送序列
;;;481    BOOL BLE_UART_AddTxArray(uint16 id, uint8 *pArray, uint16 length)
000000  b5f0              PUSH     {r4-r7,lr}
;;;482    {
;;;483    	uint16 i;
;;;484    	uint16 head = bleUartCB.tx.head;
000002  4d1e              LDR      r5,|L3.124|
000004  f8b571d2          LDRH     r7,[r5,#0x1d2]  ; bleUartCB
;;;485    	uint16 end = bleUartCB.tx.end;
000008  f8b531d4          LDRH     r3,[r5,#0x1d4]  ; bleUartCB
;;;486    	
;;;487    	// 参数检验
;;;488    	if ((NULL == pArray) || (0 == length))
00000c  2900              CMP      r1,#0
00000e  d00a              BEQ      |L3.38|
000010  b14a              CBZ      r2,|L3.38|
;;;489    	{
;;;490    		return FALSE;
;;;491    	}
;;;492    
;;;493    	// 发送缓冲区已满，不予接收
;;;494    	if((end + 1) % BLE_UART_DRIVE_TX_QUEUE_SIZE == head)
000012  1c5e              ADDS     r6,r3,#1
000014  2403              MOVS     r4,#3
000016  fbb6fcf4          UDIV     r12,r6,r4
00001a  fb04661c          MLS      r6,r4,r12,r6
00001e  42be              CMP      r6,r7
000020  d103              BNE      |L3.42|
;;;495    	{
;;;496    		return FALSE;
000022  2000              MOVS     r0,#0
;;;497    	}
;;;498    
;;;499    	bleUartCB.tx.cmdQueue[end].deviceID = id;
;;;500    	for (i = 0; i < length; i++)
;;;501    	{
;;;502    		bleUartCB.tx.cmdQueue[end].buff[i] = *pArray++;
;;;503    	}
;;;504    	bleUartCB.tx.cmdQueue[end].length = length;
;;;505    	
;;;506    	// 发送环形队列更新位置
;;;507    	bleUartCB.tx.end ++;
;;;508    	bleUartCB.tx.end %= BLE_UART_DRIVE_TX_QUEUE_SIZE;
;;;509    	bleUartCB.tx.cmdQueue[bleUartCB.tx.end].length = 0;
;;;510    
;;;511    	return TRUE;
;;;512    }
000024  bdf0              POP      {r4-r7,pc}
                  |L3.38|
000026  2000              MOVS     r0,#0                 ;490
000028  bdf0              POP      {r4-r7,pc}
                  |L3.42|
00002a  264d              MOVS     r6,#0x4d              ;499
00002c  4373              MULS     r3,r6,r3              ;499
00002e  eb050343          ADD      r3,r5,r3,LSL #1       ;499
000032  8098              STRH     r0,[r3,#4]            ;499
000034  2000              MOVS     r0,#0                 ;500
000036  e005              B        |L3.68|
                  |L3.56|
000038  181f              ADDS     r7,r3,r0              ;502
00003a  f8116b01          LDRB     r6,[r1],#1            ;502
00003e  71be              STRB     r6,[r7,#6]            ;502
000040  1c40              ADDS     r0,r0,#1              ;500
000042  b280              UXTH     r0,r0                 ;500
                  |L3.68|
000044  4290              CMP      r0,r2                 ;500
000046  d3f7              BCC      |L3.56|
000048  f8a3209c          STRH     r2,[r3,#0x9c]         ;504
00004c  f50575ea          ADD      r5,r5,#0x1d4          ;507
000050  8828              LDRH     r0,[r5,#0]            ;507  ; bleUartCB
000052  1c40              ADDS     r0,r0,#1              ;507
000054  8028              STRH     r0,[r5,#0]            ;507
000056  8828              LDRH     r0,[r5,#0]            ;508  ; bleUartCB
000058  fbb0f1f4          UDIV     r1,r0,r4              ;508
00005c  fb040011          MLS      r0,r4,r1,r0           ;508
000060  8028              STRH     r0,[r5,#0]            ;508
000062  8828              LDRH     r0,[r5,#0]            ;509  ; bleUartCB
000064  2100              MOVS     r1,#0                 ;509
000066  224d              MOVS     r2,#0x4d              ;509
000068  f5a575ea          SUB      r5,r5,#0x1d4          ;509
00006c  4350              MULS     r0,r2,r0              ;509
00006e  eb050040          ADD      r0,r5,r0,LSL #1       ;509
000072  f8a0109c          STRH     r1,[r0,#0x9c]         ;509
000076  2001              MOVS     r0,#1                 ;511
000078  bdf0              POP      {r4-r7,pc}
;;;513    
                          ENDP

00007a  0000              DCW      0x0000
                  |L3.124|
                          DCD      ||.bss||+0x14

                          AREA ||i.BLE_UART_AtChannelDataProcess||, CODE, READONLY, ALIGN=2

                  BLE_UART_AtChannelDataProcess PROC
;;;227    // 接收蓝牙mac地址
;;;228    void BLE_UART_AtChannelDataProcess(uint8 data)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;229    {
;;;230    	uint8 i;
;;;231    	
;;;232    	if (!bleUartCB.rx.startFlag)
000004  4c40              LDR      r4,|L4.264|
;;;233    	{
;;;234    		if (data == 'T')				// 起始标志
;;;235    		{
;;;236    			bleUartCB.rx.startFlag = TRUE;
000006  2601              MOVS     r6,#1
000008  2500              MOVS     r5,#0
00000a  f89411da          LDRB     r1,[r4,#0x1da]        ;232  ; bleUartCB
00000e  2900              CMP      r1,#0                 ;232
000010  d011              BEQ      |L4.54|
;;;237    
;;;238    			bleUartCB.rx.index = 0;
;;;239    
;;;240    			bleUartCB.rx.fifoBuff[bleUartCB.rx.index++] = data;		
;;;241    			
;;;242    			return;
;;;243    		}
;;;244    	}
;;;245    	else
;;;246    	{
;;;247    		// 连续接收数据
;;;248    		bleUartCB.rx.fifoBuff[bleUartCB.rx.index++] = data;
000012  f8941221          LDRB     r1,[r4,#0x221]  ; bleUartCB
000016  1c4a              ADDS     r2,r1,#1
000018  4421              ADD      r1,r1,r4
00001a  f8842221          STRB     r2,[r4,#0x221]
00001e  f88101db          STRB     r0,[r1,#0x1db]
;;;249    
;;;250    		// 越界判断
;;;251    		if (bleUartCB.rx.index >= sizeof(bleUartCB.rx.fifoBuff))
000022  f8941221          LDRB     r1,[r4,#0x221]  ; bleUartCB
000026  2932              CMP      r1,#0x32
000028  d30e              BCC      |L4.72|
;;;252    		{
;;;253    			bleUartCB.rx.startFlag = TRUE;
00002a  f88461da          STRB     r6,[r4,#0x1da]
;;;254    			bleUartCB.rx.index = 0;
00002e  f8845221          STRB     r5,[r4,#0x221]
                  |L4.50|
;;;255    
;;;256    			return;
;;;257    		}
;;;258    		
;;;259    		if (data == '\n')			// 收到结束标志
;;;260    		{
;;;261    			bleUartCB.rx.startFlag = FALSE;
;;;262    			bleUartCB.rx.index = 0;
;;;263    
;;;264    			bleUartCB.rx.macBuff[2] = ':';
;;;265    			bleUartCB.rx.macBuff[5] = ':';
;;;266    			bleUartCB.rx.macBuff[8] = ':';
;;;267    			bleUartCB.rx.macBuff[11] = ':';
;;;268    			bleUartCB.rx.macBuff[14] = ':';
;;;269    			bleUartCB.rx.macBuff[17] = '\0';
;;;270    
;;;271    			// 过滤回显指令
;;;272    			if ((strstr((const char*)bleUartCB.rx.fifoBuff, (const char*)"TTM:MAC-?") != NULL))
;;;273    			{
;;;274    				return ;
;;;275    			}
;;;276    
;;;277    			// 将读到的蓝牙mac地址提取出来
;;;278    			if ((strstr((const char*)bleUartCB.rx.fifoBuff, (const char*)"TTM:MAC-") != NULL) 
;;;279    			&& (bleUartCB.rx.fifoBuff[0] == 'T') && (bleUartCB.rx.fifoBuff[1] == 'T') && (bleUartCB.rx.fifoBuff[2] == 'M'))
;;;280    			{
;;;281    				bleUartCB.rx.macBuff[0] = bleUartCB.rx.fifoBuff[8];
;;;282    				bleUartCB.rx.macBuff[1] = bleUartCB.rx.fifoBuff[9];
;;;283    
;;;284    				bleUartCB.rx.macBuff[3] = bleUartCB.rx.fifoBuff[10];
;;;285    				bleUartCB.rx.macBuff[4] = bleUartCB.rx.fifoBuff[11];
;;;286    
;;;287    				bleUartCB.rx.macBuff[6] = bleUartCB.rx.fifoBuff[12];
;;;288    				bleUartCB.rx.macBuff[7] = bleUartCB.rx.fifoBuff[13];
;;;289    
;;;290    				bleUartCB.rx.macBuff[9] = bleUartCB.rx.fifoBuff[14];
;;;291    				bleUartCB.rx.macBuff[10] = bleUartCB.rx.fifoBuff[15];
;;;292    
;;;293    				bleUartCB.rx.macBuff[12] = bleUartCB.rx.fifoBuff[16];
;;;294    				bleUartCB.rx.macBuff[13] = bleUartCB.rx.fifoBuff[17];
;;;295    
;;;296    				bleUartCB.rx.macBuff[15] = bleUartCB.rx.fifoBuff[18];
;;;297    				bleUartCB.rx.macBuff[16] = bleUartCB.rx.fifoBuff[19];
;;;298    
;;;299    				//for (i = 0; i < 12; i++)
;;;300    				//{
;;;301    				//	bleUartCB.rx.macBuff[i] = bleUartCB.rx.fifoBuff[i+10];
;;;302    				//}
;;;303    				//bleUartCB.rx.macBuff[i] = '\0';
;;;304    				
;;;305    				for (i = 0; i < sizeof(bleUartCB.rx.fifoBuff); i++)
;;;306    				{
;;;307    					bleUartCB.rx.fifoBuff[i] = 0;
;;;308    				}				
;;;309    
;;;310    				// 注销该定时器
;;;311    				TIMER_KillTask(TIMER_ID_BLE_CONTROL);
;;;312    				
;;;313    				// 蓝牙地址接收完成
;;;314    				bleUartCB.rcvBleMacOK = TRUE;
;;;315    			}	
;;;316    		}
;;;317    	}
;;;318    }
000032  e8bd81f0          POP      {r4-r8,pc}
                  |L4.54|
000036  2854              CMP      r0,#0x54              ;234
000038  d1fb              BNE      |L4.50|
00003a  f88461da          STRB     r6,[r4,#0x1da]        ;236
00003e  f8846221          STRB     r6,[r4,#0x221]        ;240
000042  f88401db          STRB     r0,[r4,#0x1db]        ;240
000046  e7f4              B        |L4.50|
                  |L4.72|
000048  280a              CMP      r0,#0xa               ;259
00004a  d1f2              BNE      |L4.50|
00004c  f2042402          ADD      r4,r4,#0x202          ;261
000050  f8045c28          STRB     r5,[r4,#-0x28]        ;261
000054  77e5              STRB     r5,[r4,#0x1f]         ;262
000056  203a              MOVS     r0,#0x3a              ;264
000058  7360              STRB     r0,[r4,#0xd]          ;264
00005a  7420              STRB     r0,[r4,#0x10]         ;265
00005c  74e0              STRB     r0,[r4,#0x13]         ;266
00005e  75a0              STRB     r0,[r4,#0x16]         ;267
000060  7660              STRB     r0,[r4,#0x19]         ;268
000062  7725              STRB     r5,[r4,#0x1c]         ;269
000064  f2a42402          SUB      r4,r4,#0x202          ;269
000068  482b              LDR      r0,|L4.280|
00006a  a128              ADR      r1,|L4.268|
00006c  4607              MOV      r7,r0                 ;272
00006e  f7fffffe          BL       strstr
000072  2800              CMP      r0,#0                 ;272
000074  d1dd              BNE      |L4.50|
000076  a129              ADR      r1,|L4.284|
000078  4638              MOV      r0,r7                 ;278
00007a  f7fffffe          BL       strstr
00007e  2800              CMP      r0,#0                 ;278
000080  d0d7              BEQ      |L4.50|
000082  f89401db          LDRB     r0,[r4,#0x1db]        ;279  ; bleUartCB
000086  2854              CMP      r0,#0x54              ;279
000088  d1d3              BNE      |L4.50|
00008a  f89401dc          LDRB     r0,[r4,#0x1dc]        ;279  ; bleUartCB
00008e  2854              CMP      r0,#0x54              ;279
000090  d1cf              BNE      |L4.50|
000092  f89401dd          LDRB     r0,[r4,#0x1dd]        ;279  ; bleUartCB
000096  284d              CMP      r0,#0x4d              ;279
000098  d1cb              BNE      |L4.50|
00009a  f20414e3          ADD      r4,r4,#0x1e3          ;281
00009e  7820              LDRB     r0,[r4,#0]            ;281  ; bleUartCB
0000a0  f884002a          STRB     r0,[r4,#0x2a]         ;281
0000a4  7860              LDRB     r0,[r4,#1]            ;282  ; bleUartCB
0000a6  f884002b          STRB     r0,[r4,#0x2b]         ;282
0000aa  78a0              LDRB     r0,[r4,#2]            ;284  ; bleUartCB
0000ac  f884002d          STRB     r0,[r4,#0x2d]         ;284
0000b0  78e0              LDRB     r0,[r4,#3]            ;285  ; bleUartCB
0000b2  f884002e          STRB     r0,[r4,#0x2e]         ;285
0000b6  7920              LDRB     r0,[r4,#4]            ;287  ; bleUartCB
0000b8  f8840030          STRB     r0,[r4,#0x30]         ;287
0000bc  7960              LDRB     r0,[r4,#5]            ;288  ; bleUartCB
0000be  f8840031          STRB     r0,[r4,#0x31]         ;288
0000c2  79a0              LDRB     r0,[r4,#6]            ;290  ; bleUartCB
0000c4  f8840033          STRB     r0,[r4,#0x33]         ;290
0000c8  79e0              LDRB     r0,[r4,#7]            ;291  ; bleUartCB
0000ca  f8840034          STRB     r0,[r4,#0x34]         ;291
0000ce  7a20              LDRB     r0,[r4,#8]            ;293  ; bleUartCB
0000d0  f8840036          STRB     r0,[r4,#0x36]         ;293
0000d4  7a60              LDRB     r0,[r4,#9]            ;294  ; bleUartCB
0000d6  f8840037          STRB     r0,[r4,#0x37]         ;294
0000da  7aa0              LDRB     r0,[r4,#0xa]          ;296  ; bleUartCB
0000dc  f8840039          STRB     r0,[r4,#0x39]         ;296
0000e0  7ae0              LDRB     r0,[r4,#0xb]          ;297  ; bleUartCB
0000e2  f884003a          STRB     r0,[r4,#0x3a]         ;297
0000e6  f2a414e3          SUB      r4,r4,#0x1e3          ;297
0000ea  2000              MOVS     r0,#0                 ;305
                  |L4.236|
0000ec  1821              ADDS     r1,r4,r0              ;307
0000ee  f88151db          STRB     r5,[r1,#0x1db]        ;307
0000f2  1c40              ADDS     r0,r0,#1              ;305
0000f4  b2c0              UXTB     r0,r0                 ;305
0000f6  2832              CMP      r0,#0x32              ;305
0000f8  d3f8              BCC      |L4.236|
0000fa  2003              MOVS     r0,#3                 ;311
0000fc  f7fffffe          BL       TIMER_KillTask
000100  f8846222          STRB     r6,[r4,#0x222]        ;314
000104  e795              B        |L4.50|
;;;319    
                          ENDP

000106  0000              DCW      0x0000
                  |L4.264|
                          DCD      ||.bss||+0x14
                  |L4.268|
00010c  54544d3a          DCB      "TTM:MAC-?",0
000110  4d41432d
000114  3f00    
000116  00                DCB      0
000117  00                DCB      0
                  |L4.280|
                          DCD      ||.bss||+0x1ef
                  |L4.284|
00011c  54544d3a          DCB      "TTM:MAC-",0
000120  4d41432d
000124  00      
000125  00                DCB      0
000126  00                DCB      0
000127  00                DCB      0

                          AREA ||i.BLE_UART_BC_SendData||, CODE, READONLY, ALIGN=2

                  BLE_UART_BC_SendData PROC
;;;180    // 阻塞发送一个字节数据
;;;181    void BLE_UART_BC_SendData(uint8 data)
000000  b570              PUSH     {r4-r6,lr}
;;;182    {	
000002  4605              MOV      r5,r0
;;;183    	// 防止丢失第一个字节(清除空标志位,务必加) 
;;;184    	usart_flag_get(BLE_UART_TYPE_DEF, USART_FLAG_TC);		
000004  4c07              LDR      r4,|L5.36|
000006  2106              MOVS     r1,#6
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       usart_flag_get
;;;185    
;;;186    	// 填充数据
;;;187    	usart_data_transmit(BLE_UART_TYPE_DEF, data);
00000e  4629              MOV      r1,r5
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       usart_data_transmit
                  |L5.22|
;;;188    
;;;189    	// 未发送完，持续等待
;;;190    	while(usart_flag_get(BLE_UART_TYPE_DEF, USART_FLAG_TC) != SET);		
000016  2106              MOVS     r1,#6
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       usart_flag_get
00001e  2801              CMP      r0,#1
000020  d1f9              BNE      |L5.22|
;;;191    }
000022  bd70              POP      {r4-r6,pc}
;;;192    
                          ENDP

                  |L5.36|
                          DCD      0x40004400

                          AREA ||i.BLE_UART_BleConnectState||, CODE, READONLY, ALIGN=2

                  BLE_UART_BleConnectState PROC
;;;202    uint8 bleIndex = 0;
;;;203    void BLE_UART_BleConnectState(uint32 param)
000000  4903              LDR      r1,|L6.16|
;;;204    {	
;;;205    	bleIndex = 0;
000002  2000              MOVS     r0,#0
000004  7008              STRB     r0,[r1,#0]
;;;206    
;;;207    	if (-1 != STRING_Find(bleRxBuff, "TTM:CONNECTED"))
000006  a103              ADR      r1,|L6.20|
000008  4806              LDR      r0,|L6.36|
00000a  f7ffbffe          B.W      STRING_Find
;;;208    	{
;;;209    //		PARAM_SetBleConnectState(TRUE);
;;;210    //		
;;;211    //		// 开启鉴权定时器，10s钟内如果没有鉴权成功则退出蓝牙连接
;;;212    //		TIMER_AddTask(TIMER_ID_BLE_CONNECT_VERIFICATE,
;;;213    //					10000,
;;;214    //					BLE_MODULE_Reset,
;;;215    //					0,
;;;216    //					1,
;;;217    //					ACTION_MODE_ADD_TO_QUEUE);
;;;218    
;;;219    	}
;;;220    
;;;221    //	if (-1 != STRING_Find(bleRxBuff, "TTM:DISCONNECT"))
;;;222    //	{
;;;223    //		PARAM_SetBleConnectState(FALSE);
;;;224    //	}
;;;225    }
;;;226    
                          ENDP

00000e  0000              DCW      0x0000
                  |L6.16|
                          DCD      ||.data||
                  |L6.20|
000014  54544d3a          DCB      "TTM:CONNECTED",0
000018  434f4e4e
00001c  45435445
000020  4400    
000022  00                DCB      0
000023  00                DCB      0
                  |L6.36|
                          DCD      ||.bss||

                          AREA ||i.BLE_UART_CALLBALL_GetBleMacAddrRequest||, CODE, READONLY, ALIGN=1

                  BLE_UART_CALLBALL_GetBleMacAddrRequest PROC
;;;531    // 定时器回调发送获取蓝牙地址命令
;;;532    void BLE_UART_CALLBALL_GetBleMacAddrRequest(uint32 param)
000000  2001              MOVS     r0,#1
;;;533    {
;;;534    	// 发送获取MAC地址
;;;535    	BLE_UART_SendCmdGetBleMacAddr(TRUE);
000002  f7ffbffe          B.W      BLE_UART_SendCmdGetBleMacAddr
;;;536    }
;;;537    
                          ENDP


                          AREA ||i.BLE_UART_DataStructureInit||, CODE, READONLY, ALIGN=2

                  BLE_UART_DataStructureInit PROC
;;;69     // 数据结构初始化
;;;70     void BLE_UART_DataStructureInit(BLE_UART_CB* pCB)
000000  2800              CMP      r0,#0
;;;71     {
000002  d016              BEQ      |L8.50|
;;;72     	uint16 i;
;;;73     	
;;;74     	// 参数合法性检验
;;;75     	if (NULL == pCB)
;;;76     	{
;;;77     		return;
;;;78     	}
;;;79     
;;;80     	pCB->tx.txBusy = FALSE;
000004  2200              MOVS     r2,#0
000006  f88021d8          STRB     r2,[r0,#0x1d8]
;;;81     	pCB->tx.index = 0;
00000a  f8a021d6          STRH     r2,[r0,#0x1d6]
;;;82     	pCB->tx.head = 0;
00000e  f8a021d2          STRH     r2,[r0,#0x1d2]
;;;83     	pCB->tx.end = 0;
000012  f8a021d4          STRH     r2,[r0,#0x1d4]
;;;84     	for(i = 0; i < BLE_UART_DRIVE_TX_QUEUE_SIZE; i++)
000016  2100              MOVS     r1,#0
                  |L8.24|
;;;85     	{
;;;86     		pCB->tx.cmdQueue[i].length = 0;
000018  234d              MOVS     r3,#0x4d
00001a  434b              MULS     r3,r1,r3
00001c  eb000343          ADD      r3,r0,r3,LSL #1
000020  f8a3209c          STRH     r2,[r3,#0x9c]
000024  1c49              ADDS     r1,r1,#1              ;84
000026  b289              UXTH     r1,r1                 ;84
000028  2903              CMP      r1,#3                 ;84
00002a  d3f5              BCC      |L8.24|
;;;87     	}	
;;;88     
;;;89     	bleUartCB.rcvBleMacOK = FALSE;
00002c  4801              LDR      r0,|L8.52|
00002e  f8802222          STRB     r2,[r0,#0x222]
                  |L8.50|
;;;90     }
000032  4770              BX       lr
;;;91     
                          ENDP

                  |L8.52|
                          DCD      ||.bss||+0x14

                          AREA ||i.BLE_UART_HwInit||, CODE, READONLY, ALIGN=2

                  BLE_UART_HwInit PROC
;;;38     // UART初始化
;;;39     void BLE_UART_HwInit(uint32 baud)
000000  b570              PUSH     {r4-r6,lr}
;;;40     {
000002  4605              MOV      r5,r0
;;;41     	// 打开时钟
;;;42     	rcu_periph_clock_enable(RCU_GPIOA);
000004  f2406002          MOV      r0,#0x602
000008  f7fffffe          BL       rcu_periph_clock_enable
;;;43     	gpio_init(GPIOA, GPIO_MODE_AF_PP, GPIO_OSPEED_2MHZ, GPIO_PIN_2);
00000c  4c21              LDR      r4,|L9.148|
00000e  2304              MOVS     r3,#4
000010  2202              MOVS     r2,#2
000012  2118              MOVS     r1,#0x18
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       gpio_init
;;;44     	
;;;45     	gpio_init(GPIOA, GPIO_MODE_IPU, GPIO_OSPEED_2MHZ, GPIO_PIN_3);
00001a  2308              MOVS     r3,#8
00001c  2202              MOVS     r2,#2
00001e  2148              MOVS     r1,#0x48
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       gpio_init
;;;46     
;;;47     	// UART时钟配置
;;;48     	rcu_periph_clock_enable(RCU_USART0);
000026  f240600e          MOV      r0,#0x60e
00002a  f7fffffe          BL       rcu_periph_clock_enable
;;;49     	usart_deinit(BLE_UART_TYPE_DEF);									// 复位串口
00002e  4c1a              LDR      r4,|L9.152|
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       usart_deinit
;;;50     		
;;;51     	// 串口配置
;;;52     	usart_baudrate_set(BLE_UART_TYPE_DEF, baud);						// 波特率
000036  4629              MOV      r1,r5
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       usart_baudrate_set
;;;53     	usart_word_length_set(BLE_UART_TYPE_DEF, USART_WL_8BIT);			// 8位数据位
00003e  2100              MOVS     r1,#0
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       usart_word_length_set
;;;54     	usart_stop_bit_set(BLE_UART_TYPE_DEF, USART_STB_1BIT); 				// 一个停止位
000046  2100              MOVS     r1,#0
000048  4620              MOV      r0,r4
00004a  f7fffffe          BL       usart_stop_bit_set
;;;55     	usart_parity_config(BLE_UART_TYPE_DEF, USART_PM_NONE); 				// 无奇偶校验
00004e  2100              MOVS     r1,#0
000050  4620              MOV      r0,r4
000052  f7fffffe          BL       usart_parity_config
;;;56     	usart_hardware_flow_rts_config(BLE_UART_TYPE_DEF, USART_RTS_DISABLE); // 无硬件数据流控制
000056  2100              MOVS     r1,#0
000058  4620              MOV      r0,r4
00005a  f7fffffe          BL       usart_hardware_flow_rts_config
;;;57     	usart_hardware_flow_cts_config(BLE_UART_TYPE_DEF, USART_CTS_DISABLE);
00005e  2100              MOVS     r1,#0
000060  4620              MOV      r0,r4
000062  f7fffffe          BL       usart_hardware_flow_cts_config
;;;58     	usart_transmit_config(BLE_UART_TYPE_DEF, USART_TRANSMIT_ENABLE);	// 使能发射
000066  2108              MOVS     r1,#8
000068  4620              MOV      r0,r4
00006a  f7fffffe          BL       usart_transmit_config
;;;59     	usart_receive_config(BLE_UART_TYPE_DEF, USART_RECEIVE_ENABLE); 		// 使能接收
00006e  2104              MOVS     r1,#4
000070  4620              MOV      r0,r4
000072  f7fffffe          BL       usart_receive_config
;;;60     
;;;61     	// 中断配置
;;;62     	nvic_irq_enable(BLE_UART_IRQn_DEF, 2, 1);
000076  2201              MOVS     r2,#1
000078  2102              MOVS     r1,#2
00007a  2026              MOVS     r0,#0x26
00007c  f7fffffe          BL       nvic_irq_enable
;;;63     
;;;64     	usart_interrupt_enable(BLE_UART_TYPE_DEF, USART_INT_RBNE); 			// 开启中断
000080  f2403105          MOV      r1,#0x305
000084  4620              MOV      r0,r4
000086  f7fffffe          BL       usart_interrupt_enable
;;;65     
;;;66     	usart_enable(BLE_UART_TYPE_DEF);									// 使能串口 
00008a  4620              MOV      r0,r4
00008c  e8bd4070          POP      {r4-r6,lr}
000090  f7ffbffe          B.W      usart_enable
;;;67     }
;;;68     
                          ENDP

                  |L9.148|
                          DCD      0x40010800
                  |L9.152|
                          DCD      0x40004400

                          AREA ||i.BLE_UART_IR_StartSendData||, CODE, READONLY, ALIGN=2

                  BLE_UART_IR_StartSendData PROC
;;;167    // 启动中断字节发送
;;;168    void BLE_UART_IR_StartSendData(uint8 data)
000000  b570              PUSH     {r4-r6,lr}
;;;169    {
000002  4605              MOV      r5,r0
;;;170    	// 先读SR，再填充DR会把TC标志清掉
;;;171    	usart_flag_get(BLE_UART_TYPE_DEF, USART_FLAG_TC);
000004  4c07              LDR      r4,|L10.36|
000006  2106              MOVS     r1,#6
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       usart_flag_get
;;;172    
;;;173    	// 发送一个字节
;;;174    	usart_data_transmit(BLE_UART_TYPE_DEF, data);
00000e  4629              MOV      r1,r5
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       usart_data_transmit
;;;175    
;;;176    	// 打开发送完成中断
;;;177    	usart_interrupt_enable(BLE_UART_TYPE_DEF, USART_INT_TC);
000016  4620              MOV      r0,r4
000018  e8bd4070          POP      {r4-r6,lr}
00001c  f2403106          MOV      r1,#0x306
000020  f7ffbffe          B.W      usart_interrupt_enable
;;;178    }
;;;179    
                          ENDP

                  |L10.36|
                          DCD      0x40004400

                          AREA ||i.BLE_UART_Init||, CODE, READONLY, ALIGN=2

                  BLE_UART_Init PROC
;;;442    // UART初始化
;;;443    void BLE_UART_Init(void)
000000  b510              PUSH     {r4,lr}
;;;444    {
;;;445    	// BLE模块辅助控制引脚初始化
;;;446    //	BLE_CMD_GPIO_CtrlPin();
;;;447    	
;;;448    	// 由安卓端点击蓝牙升级时，应用层跳转boot需要屏蔽掉蓝牙模块初始化，防止蓝牙断开连接
;;;449    	if(0xAA == SPI_FLASH_ReadByte(SPI_FLASH_BLE_UPDATA_FLAG_ADDEESS + 1))
000002  4c0b              LDR      r4,|L11.48|
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       SPI_FLASH_ReadByte
00000a  28aa              CMP      r0,#0xaa
00000c  d00a              BEQ      |L11.36|
;;;450    	{
;;;451    		// 清除蓝牙升级时，跳转boot屏蔽初始化标志位，重启之后需要重新初始化蓝牙，防止升级失败
;;;452    		SPI_FLASH_WriteByte(SPI_FLASH_BLE_UPDATA_FLAG_ADDEESS + 1, 0xFF);
;;;453    	}
;;;454    	else
;;;455    	{
;;;456    		// BLE模块辅助控制引脚初始化
;;;457    		BLE_CMD_GPIO_CtrlPin();
00000e  f7fffffe          BL       BLE_CMD_GPIO_CtrlPin
;;;458    		
;;;459    		// 串口初始化
;;;460    		BLE_UART_HwInit(BLE_UART_BAUD_RATE);
000012  f44f5016          MOV      r0,#0x2580
000016  f7fffffe          BL       BLE_UART_HwInit
                  |L11.26|
;;;461    	}
;;;462    
;;;463    	// UART数据结构初始化
;;;464    	BLE_UART_DataStructureInit(&bleUartCB);
00001a  e8bd4010          POP      {r4,lr}
00001e  4805              LDR      r0,|L11.52|
000020  f7ffbffe          B.W      BLE_UART_DataStructureInit
                  |L11.36|
000024  21ff              MOVS     r1,#0xff              ;452
000026  4620              MOV      r0,r4                 ;452
000028  f7fffffe          BL       SPI_FLASH_WriteByte
00002c  e7f5              B        |L11.26|
;;;465    }
;;;466    
                          ENDP

00002e  0000              DCW      0x0000
                  |L11.48|
                          DCD      0x003ff081
                  |L11.52|
                          DCD      ||.bss||+0x14

                          AREA ||i.BLE_UART_Process||, CODE, READONLY, ALIGN=2

                  BLE_UART_Process PROC
;;;467    // UART模块处理入口
;;;468    void BLE_UART_Process(void)
000000  4801              LDR      r0,|L12.8|
;;;469    {
;;;470    	// 发送处理
;;;471    	BLE_UART_TxProcess(&bleUartCB);
000002  f7ffbffe          B.W      BLE_UART_TxProcess
;;;472    }
;;;473    
                          ENDP

000006  0000              DCW      0x0000
                  |L12.8|
                          DCD      ||.bss||+0x14

                          AREA ||i.BLE_UART_RegisterDataSendService||, CODE, READONLY, ALIGN=2

                  BLE_UART_RegisterDataSendService PROC
;;;474    // 注册数据抛出接口服务
;;;475    void BLE_UART_RegisterDataSendService(void (*service)(uint16 id, uint8 *pData, uint16 length))
000000  4901              LDR      r1,|L13.8|
;;;476    {
;;;477    	bleUartCB.receiveDataThrowService = service;
000002  6008              STR      r0,[r1,#0]  ; bleUartCB
;;;478    }
000004  4770              BX       lr
;;;479    
                          ENDP

000006  0000              DCW      0x0000
                  |L13.8|
                          DCD      ||.bss||+0x14

                          AREA ||i.BLE_UART_SendCmdGetBleMacAddr||, CODE, READONLY, ALIGN=2

                  BLE_UART_SendCmdGetBleMacAddr PROC
;;;514    // 发送获取MAC地址
;;;515    void BLE_UART_SendCmdGetBleMacAddr(uint32 param)
000000  b53e              PUSH     {r1-r5,lr}
;;;516    {
;;;517    	uint8 i;
;;;518    	uint8 bleMacStr[] = "TTM:MAC-?";
000002  a009              ADR      r0,|L14.40|
000004  e9d01200          LDRD     r1,r2,[r0,#0]
000008  6880              LDR      r0,[r0,#8]
00000a  e9cd1200          STRD     r1,r2,[sp,#0]
00000e  9002              STR      r0,[sp,#8]
;;;519    	
;;;520    	// 使能BLE发送
;;;521    	BLE_BRTS_TX_REQUEST();
;;;522    
;;;523    	// 查询蓝牙mac指令,启动阻塞式发送
;;;524    	for (i = 0; bleMacStr[i] != '\0'; i++)
000010  2400              MOVS     r4,#0
000012  466d              MOV      r5,sp                 ;518
000014  e003              B        |L14.30|
                  |L14.22|
;;;525    	{
;;;526    		// 填充数据，启动发送
;;;527    		BLE_UART_BC_SendData(bleMacStr[i]);
000016  f7fffffe          BL       BLE_UART_BC_SendData
00001a  1c64              ADDS     r4,r4,#1              ;524
00001c  b2e4              UXTB     r4,r4                 ;524
                  |L14.30|
00001e  5d28              LDRB     r0,[r5,r4]            ;524
000020  2800              CMP      r0,#0                 ;524
000022  d1f8              BNE      |L14.22|
;;;528    	}	
;;;529    }
000024  bd3e              POP      {r1-r5,pc}
;;;530    
                          ENDP

000026  0000              DCW      0x0000
                  |L14.40|
000028  54544d3a          DCB      "TTM:MAC-?",0
00002c  4d41432d
000030  3f00    
000032  00                DCB      0
000033  00                DCB      0

                          AREA ||i.BLE_UART_TxProcess||, CODE, READONLY, ALIGN=1

                  BLE_UART_TxProcess PROC
;;;92     // 发送处理
;;;93     void BLE_UART_TxProcess(BLE_UART_CB* pCB)
000000  b510              PUSH     {r4,lr}
;;;94     {
000002  4604              MOV      r4,r0
;;;95     // 中断方式
;;;96     #if (BLE_UART_TX_MODE == BLE_UART_INTERRUPT_TX_MODE)
;;;97     	uint16 index = pCB->tx.index;							// 当前发送数据的索引号
000004  f8b401d6          LDRH     r0,[r4,#0x1d6]
;;;98     	uint16 length = pCB->tx.cmdQueue[pCB->tx.head].length;	// 当前发送的命令帧的长度
000008  f8b411d2          LDRH     r1,[r4,#0x1d2]
00000c  224d              MOVS     r2,#0x4d
00000e  4351              MULS     r1,r2,r1
000010  eb040141          ADD      r1,r4,r1,LSL #1
000014  f8b1209c          LDRH     r2,[r1,#0x9c]
;;;99     	uint16 head = pCB->tx.head;								// 发送命令帧队列头索引号
000018  f8b411d2          LDRH     r1,[r4,#0x1d2]
;;;100    	uint16 end = pCB->tx.end;								// 发送命令帧队列尾索引号
00001c  f8b431d4          LDRH     r3,[r4,#0x1d4]
;;;101    
;;;102    	// 参数合法性检验
;;;103    	if (NULL == pCB)
000020  2c00              CMP      r4,#0
000022  d017              BEQ      |L15.84|
;;;104    	{
;;;105    		return;
;;;106    	}
;;;107    	
;;;108    	// 队列为空，不处理
;;;109    	if (head == end)
000024  4299              CMP      r1,r3
000026  d015              BEQ      |L15.84|
;;;110    	{
;;;111    		return;
;;;112    	}
;;;113    
;;;114    	// 发送忙，退出
;;;115    	if (pCB->tx.txBusy)
000028  f89431d8          LDRB     r3,[r4,#0x1d8]
00002c  2b00              CMP      r3,#0
00002e  d111              BNE      |L15.84|
;;;116    	{
;;;117    		return;
;;;118    	}
;;;119    
;;;120    	// ■■执行到这里，说明队列非空■■
;;;121    	
;;;122    	// 当前命令帧未发送完时，取出一个字节放到发送寄存器中
;;;123    	if (index < length)
000030  4290              CMP      r0,r2
000032  d20f              BCS      |L15.84|
;;;124    	{		
;;;125    		BLE_UART_IR_StartSendData(pCB->tx.cmdQueue[head].buff[pCB->tx.index++]);
000034  f8b401d6          LDRH     r0,[r4,#0x1d6]
000038  1c42              ADDS     r2,r0,#1
00003a  f8a421d6          STRH     r2,[r4,#0x1d6]
00003e  224d              MOVS     r2,#0x4d
000040  4351              MULS     r1,r2,r1
000042  eb040141          ADD      r1,r4,r1,LSL #1
000046  4408              ADD      r0,r0,r1
000048  7980              LDRB     r0,[r0,#6]
00004a  f7fffffe          BL       BLE_UART_IR_StartSendData
;;;126    		
;;;127    		// 设置发送忙状态
;;;128    		pCB->tx.txBusy = TRUE;
00004e  2001              MOVS     r0,#1
000050  f88401d8          STRB     r0,[r4,#0x1d8]
                  |L15.84|
;;;129    	}
;;;130    
;;;131    
;;;132    // 阻塞方式时启动发送
;;;133    #else
;;;134    	uint16 index = pCB->tx.index;
;;;135    	uint16 head = pCB->tx.head;
;;;136    	uint16 end = pCB->tx.end;
;;;137    
;;;138    	// 参数合法性检验
;;;139    	if(NULL == pCB)
;;;140    	{
;;;141    		return;
;;;142    	}
;;;143    
;;;144    	// 队列为空，不处理
;;;145    	if(head == end)
;;;146    	{
;;;147    		return;
;;;148    	}
;;;149    	
;;;150    	// 当前命令帧未发送完时，持续发送
;;;151    	while(index < pCB->tx.cmdQueue[head].length)
;;;152    	{
;;;153    		// 一直填充发送
;;;154    		BLE_UART_BC_SendData(pCB->tx.cmdQueue[head].buff[pCB->tx.index++]);
;;;155    		
;;;156    		index = pCB->tx.index;
;;;157    	}
;;;158    	
;;;159    	// 当前命令帧发送完时，删除之
;;;160    	pCB->tx.cmdQueue[head].length = 0;
;;;161    	pCB->tx.head ++;
;;;162    	pCB->tx.head %= BLE_UART_DRIVE_TX_QUEUE_SIZE;
;;;163    	pCB->tx.index = 0;
;;;164    #endif
;;;165    }
000054  bd10              POP      {r4,pc}
;;;166    
                          ENDP


                          AREA ||i.USART1_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART1_IRQHandler PROC
;;;327    *************************************************************/
;;;328    void USART1_IRQHandler(void)
000000  b5fe              PUSH     {r1-r7,lr}
;;;329    {
;;;330    	// 判断DR是否有数据，中断接收
;;;331    	if (usart_interrupt_flag_get(BLE_UART_TYPE_DEF, USART_INT_FLAG_RBNE) != RESET) 
000002  4e45              LDR      r6,|L16.280|
000004  4943              LDR      r1,|L16.276|
000006  4630              MOV      r0,r6
000008  f7fffffe          BL       usart_interrupt_flag_get
;;;332    	{
;;;333    		uint8 rxdata = 0x00;
;;;334    		
;;;335    		// 接收数据
;;;336    		rxdata = (uint8)usart_data_receive(BLE_UART_TYPE_DEF);
;;;337    		
;;;338    		if (NULL != bleUartCB.receiveDataThrowService)
00000c  4c43              LDR      r4,|L16.284|
00000e  2500              MOVS     r5,#0                 ;331
000010  b348              CBZ      r0,|L16.102|
000012  9502              STR      r5,[sp,#8]            ;333
000014  4630              MOV      r0,r6                 ;336
000016  f7fffffe          BL       usart_data_receive
00001a  9002              STR      r0,[sp,#8]            ;336
00001c  6823              LDR      r3,[r4,#0]  ; bleUartCB
00001e  b123              CBZ      r3,|L16.42|
;;;339    		{			
;;;340    			(*bleUartCB.receiveDataThrowService)(0xFFF, &rxdata, 1);
000020  2201              MOVS     r2,#1
000022  a902              ADD      r1,sp,#8
000024  f64070ff          MOV      r0,#0xfff
000028  4798              BLX      r3
                  |L16.42|
;;;341    		}
;;;342    
;;;343    		if (!bleUartCB.rcvBleMacOK)
00002a  f8940222          LDRB     r0,[r4,#0x222]  ; bleUartCB
00002e  b918              CBNZ     r0,|L16.56|
;;;344    		{
;;;345    			BLE_UART_AtChannelDataProcess(rxdata);
000030  f89d0008          LDRB     r0,[sp,#8]
000034  f7fffffe          BL       BLE_UART_AtChannelDataProcess
                  |L16.56|
;;;346    		}
;;;347    
;;;348    //=================================================================
;;;349    		// 蓝牙连接判断
;;;350    		if ((bleIndex + 1)< sizeof(bleRxBuff)/sizeof(bleRxBuff[0]))
000038  4a39              LDR      r2,|L16.288|
00003a  7811              LDRB     r1,[r2,#0]  ; bleIndex
00003c  4608              MOV      r0,r1
00003e  1c49              ADDS     r1,r1,#1
000040  2914              CMP      r1,#0x14
000042  d207              BCS      |L16.84|
;;;351    		{
;;;352    			bleRxBuff[bleIndex++] = rxdata;
000044  f89d3008          LDRB     r3,[sp,#8]
000048  b2c9              UXTB     r1,r1
00004a  7011              STRB     r1,[r2,#0]
00004c  4a33              LDR      r2,|L16.284|
00004e  3a14              SUBS     r2,r2,#0x14
000050  5413              STRB     r3,[r2,r0]
;;;353    			bleRxBuff[bleIndex] = '\0';
000052  5455              STRB     r5,[r2,r1]
                  |L16.84|
;;;354    		}
;;;355    
;;;356    		TIMER_AddTask(TIMER_ID_BLE_CONNECT_STATE,
000054  2001              MOVS     r0,#1
000056  9000              STR      r0,[sp,#0]
000058  9001              STR      r0,[sp,#4]
00005a  2300              MOVS     r3,#0
00005c  4a31              LDR      r2,|L16.292|
00005e  2164              MOVS     r1,#0x64
000060  200a              MOVS     r0,#0xa
000062  f7fffffe          BL       TIMER_AddTask
                  |L16.102|
;;;357    					100,
;;;358    					BLE_UART_BleConnectState,
;;;359    					0,
;;;360    					1,
;;;361    					ACTION_MODE_ADD_TO_QUEUE);
;;;362    	}
;;;363    
;;;364    
;;;365    // 中断模式发送
;;;366    #if (BLE_UART_TX_MODE == BLE_UART_INTERRUPT_TX_MODE)
;;;367    	// 判断DR是否有数据，中断发送
;;;368    	if (usart_interrupt_flag_get(BLE_UART_TYPE_DEF, USART_INT_FLAG_TC) != RESET)
000066  4930              LDR      r1,|L16.296|
000068  4630              MOV      r0,r6
00006a  f7fffffe          BL       usart_interrupt_flag_get
00006e  b3c8              CBZ      r0,|L16.228|
;;;369    	{
;;;370    		uint16 head = bleUartCB.tx.head;
000070  f8b401d2          LDRH     r0,[r4,#0x1d2]  ; bleUartCB
;;;371    		uint16 end;
;;;372    		uint16 index = bleUartCB.tx.index;
000074  f8b411d6          LDRH     r1,[r4,#0x1d6]  ; bleUartCB
;;;373    		uint8 txdata = 0x00;
;;;374    
;;;375    		// 执行到这里，说明上一个数据已经发送完毕，当前命令帧未发送完时，取出一个字节放到发送寄存器中
;;;376    		if (index < bleUartCB.tx.cmdQueue[head].length)
000078  224d              MOVS     r2,#0x4d
00007a  4350              MULS     r0,r2,r0
00007c  eb040240          ADD      r2,r4,r0,LSL #1
000080  f8b2009c          LDRH     r0,[r2,#0x9c]
000084  4288              CMP      r0,r1
000086  d90a              BLS      |L16.158|
;;;377    		{
;;;378    			txdata = bleUartCB.tx.cmdQueue[head].buff[bleUartCB.tx.index++];
000088  f8b411d6          LDRH     r1,[r4,#0x1d6]  ; bleUartCB
00008c  1c48              ADDS     r0,r1,#1
00008e  f8a401d6          STRH     r0,[r4,#0x1d6]
000092  1888              ADDS     r0,r1,r2
000094  7981              LDRB     r1,[r0,#6]
;;;379    			
;;;380    			// 填充数据
;;;381    			usart_data_transmit(BLE_UART_TYPE_DEF, txdata);
000096  4630              MOV      r0,r6
000098  f7fffffe          BL       usart_data_transmit
00009c  e02a              B        |L16.244|
                  |L16.158|
;;;382    		}
;;;383    		// 当前命令帧发送完时，删除之
;;;384    		else
;;;385    		{
;;;386    			bleUartCB.tx.cmdQueue[head].length = 0;
00009e  f8a2509c          STRH     r5,[r2,#0x9c]
;;;387    			bleUartCB.tx.head ++;
0000a2  f50474e9          ADD      r4,r4,#0x1d2
0000a6  8820              LDRH     r0,[r4,#0]  ; bleUartCB
0000a8  1c40              ADDS     r0,r0,#1
0000aa  8020              STRH     r0,[r4,#0]
;;;388    			bleUartCB.tx.head %= BLE_UART_DRIVE_TX_QUEUE_SIZE;
0000ac  8820              LDRH     r0,[r4,#0]  ; bleUartCB
0000ae  2103              MOVS     r1,#3
0000b0  fbb0f2f1          UDIV     r2,r0,r1
0000b4  fb010012          MLS      r0,r1,r2,r0
0000b8  8020              STRH     r0,[r4,#0]
;;;389    			bleUartCB.tx.index = 0;
0000ba  80a5              STRH     r5,[r4,#4]
;;;390    
;;;391    			head = bleUartCB.tx.head;
0000bc  8822              LDRH     r2,[r4,#0]  ; bleUartCB
;;;392    			end = bleUartCB.tx.end;
0000be  8860              LDRH     r0,[r4,#2]  ; bleUartCB
0000c0  f5a474e9          SUB      r4,r4,#0x1d2
;;;393    			
;;;394    			// 命令帧队列非空，继续发送下一个命令帧
;;;395    			if (head != end)
0000c4  4282              CMP      r2,r0
0000c6  d00e              BEQ      |L16.230|
;;;396    			{
;;;397    				txdata = bleUartCB.tx.cmdQueue[head].buff[bleUartCB.tx.index++];
0000c8  f8b411d6          LDRH     r1,[r4,#0x1d6]  ; bleUartCB
0000cc  1c48              ADDS     r0,r1,#1
0000ce  f8a401d6          STRH     r0,[r4,#0x1d6]
0000d2  204d              MOVS     r0,#0x4d
0000d4  4342              MULS     r2,r0,r2
0000d6  eb040042          ADD      r0,r4,r2,LSL #1
0000da  4408              ADD      r0,r0,r1
0000dc  7981              LDRB     r1,[r0,#6]
;;;398    
;;;399    				// 填充数据
;;;400    				usart_data_transmit(BLE_UART_TYPE_DEF, txdata);
0000de  4630              MOV      r0,r6
0000e0  f7fffffe          BL       usart_data_transmit
                  |L16.228|
0000e4  e006              B        |L16.244|
                  |L16.230|
;;;401    			}
;;;402    			// 命令帧队列为空停止发送，设置空闲
;;;403    			else
;;;404    			{
;;;405    				// 关闭发送完成中断
;;;406    				usart_interrupt_disable(BLE_UART_TYPE_DEF, USART_INT_TC);
0000e6  f2403106          MOV      r1,#0x306
0000ea  4630              MOV      r0,r6
0000ec  f7fffffe          BL       usart_interrupt_disable
;;;407    				
;;;408    				bleUartCB.tx.txBusy = FALSE;				
0000f0  f88451d8          STRB     r5,[r4,#0x1d8]
                  |L16.244|
;;;409    			}
;;;410    		}		
;;;411    	}
;;;412    #endif
;;;413    
;;;414    	// Other USARTx interrupts handler can go here ...				 
;;;415    	if (usart_interrupt_flag_get(BLE_UART_TYPE_DEF, USART_INT_FLAG_ERR_ORERR) != RESET)	//----------------------- 接收溢出中断 
0000f4  490d              LDR      r1,|L16.300|
0000f6  4630              MOV      r0,r6
0000f8  f7fffffe          BL       usart_interrupt_flag_get
0000fc  2800              CMP      r0,#0
0000fe  d008              BEQ      |L16.274|
;;;416    	{
;;;417    		usart_flag_get(BLE_UART_TYPE_DEF, USART_FLAG_ORERR); 			//----------------------- 清除接收溢出中断标志位 
000100  2103              MOVS     r1,#3
000102  4630              MOV      r0,r6
000104  f7fffffe          BL       usart_flag_get
;;;418    		usart_data_receive(BLE_UART_TYPE_DEF);									//----------------------- 清空寄存器
000108  4630              MOV      r0,r6
00010a  e8bd40fe          POP      {r1-r7,lr}
00010e  f7ffbffe          B.W      usart_data_receive
                  |L16.274|
;;;419    	}
;;;420    }
000112  bdfe              POP      {r1-r7,pc}
;;;421    
                          ENDP

                  |L16.276|
                          DCD      0x00050305
                  |L16.280|
                          DCD      0x40004400
                  |L16.284|
                          DCD      ||.bss||+0x14
                  |L16.288|
                          DCD      ||.data||
                  |L16.292|
                          DCD      BLE_UART_BleConnectState
                  |L16.296|
                          DCD      0x00060306
                  |L16.300|
                          DCD      0x00030500

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  bleRxBuff
                          %        20
                  bleUartCB
                          %        548

                          AREA ||.data||, DATA, ALIGN=0

                  bleIndex
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "User\\BleUart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_BleUart_c_ff9078f0____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___9_BleUart_c_ff9078f0____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_BleUart_c_ff9078f0____REVSH|
#line 128
|__asm___9_BleUart_c_ff9078f0____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
