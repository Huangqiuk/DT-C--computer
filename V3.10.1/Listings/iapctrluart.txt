; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\iapctrluart.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\iapctrluart.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -IC:\Users\Administrator\AppData\Local\Arm\Packs\GigaDevice\GD32F10x_DFP\2.0.1\Device\Include -D__MICROLIB -D__UVISION_VERSION=534 -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\iapctrluart.crf User\iapCtrlUart.c]
                          THUMB

                          AREA ||i.IAP_CTRL_UART_CheckSUM||, CODE, READONLY, ALIGN=1

                  IAP_CTRL_UART_CheckSUM PROC
;;;411    // 对传入的命令帧进行校验，返回校验结果
;;;412    BOOL IAP_CTRL_UART_CheckSUM(IAP_CTRL_CMD_FRAME* pCmdFrame)
000000  b530              PUSH     {r4,r5,lr}
;;;413    {
;;;414    	uint8 cc = 0;
000002  2200              MOVS     r2,#0
;;;415    	uint16 i = 0;
000004  2100              MOVS     r1,#0
;;;416    	
;;;417    	if(NULL == pCmdFrame)
000006  2800              CMP      r0,#0
000008  d003              BEQ      |L1.18|
;;;418    	{
;;;419    		return FALSE;
;;;420    	}
;;;421    
;;;422    	// 从命令头开始，到校验码之前的一个字节，依次进行异或运算
;;;423    	for(i=0; i<pCmdFrame->length-1; i++)
00000a  f8b050a0          LDRH     r5,[r0,#0xa0]
00000e  1e6b              SUBS     r3,r5,#1
000010  e005              B        |L1.30|
                  |L1.18|
000012  2000              MOVS     r0,#0                 ;419
;;;424    	{
;;;425    		cc ^= pCmdFrame->buff[i];
;;;426    	}
;;;427    
;;;428    	cc = ~cc;
;;;429    
;;;430    	// 判断计算得到的校验码与命令帧中的校验码是否相同
;;;431    	if(pCmdFrame->buff[pCmdFrame->length-1] != cc)
;;;432    	{
;;;433    		return FALSE;
;;;434    	}
;;;435    	
;;;436    	return TRUE;
;;;437    }
000014  bd30              POP      {r4,r5,pc}
                  |L1.22|
000016  5c44              LDRB     r4,[r0,r1]            ;425
000018  4062              EORS     r2,r2,r4              ;425
00001a  1c49              ADDS     r1,r1,#1              ;423
00001c  b289              UXTH     r1,r1                 ;423
                  |L1.30|
00001e  428b              CMP      r3,r1                 ;423
000020  dcf9              BGT      |L1.22|
000022  43d1              MVNS     r1,r2                 ;428
000024  b2c9              UXTB     r1,r1                 ;428
000026  1e40              SUBS     r0,r0,#1              ;431
000028  5c28              LDRB     r0,[r5,r0]            ;431
00002a  4288              CMP      r0,r1                 ;431
00002c  d001              BEQ      |L1.50|
00002e  2000              MOVS     r0,#0                 ;433
000030  bd30              POP      {r4,r5,pc}
                  |L1.50|
000032  2001              MOVS     r0,#1                 ;436
000034  bd30              POP      {r4,r5,pc}
;;;438    
                          ENDP


                          AREA ||i.IAP_CTRL_UART_CmdFrameProcess||, CODE, READONLY, ALIGN=2

                  IAP_CTRL_UART_CmdFrameProcess PROC
;;;447    // UART命令帧缓冲区处理
;;;448    void IAP_CTRL_UART_CmdFrameProcess(IAP_CTRL_UART_CB* pCB)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;449    {
000004  4605              MOV      r5,r0
;;;450    	IAP_CTRL_UART_CMD cmd = IAP_CTRL_UART_CMD_NULL;
;;;451    	IAP_CTRL_CMD_FRAME* pCmdFrame = NULL;
;;;452    	uint32 temp = 0;
;;;453    	uint32 temp2= 0;
;;;454    	uint16 length = 0;
;;;455    	uint8 errStatus;
;;;456    	uint16 i;
;;;457    	BOOL bTemp;
;;;458    	uint8* updateBuff = NULL;
;;;459    	uint8 localBuf[50];
;;;460    
;;;461    	// 参数合法性检验
;;;462    	if(NULL == pCB)
000006  2d00              CMP      r5,#0
000008  d019              BEQ      |L2.62|
;;;463    	{
;;;464    		return;
;;;465    	}
;;;466    
;;;467    	// 命令帧缓冲区为空，退出
;;;468    	if(pCB->rx.head == pCB->rx.end)
00000a  f8b5042a          LDRH     r0,[r5,#0x42a]
00000e  f8b5142c          LDRH     r1,[r5,#0x42c]
000012  4288              CMP      r0,r1
000014  d013              BEQ      |L2.62|
;;;469    	{
;;;470    		return;
;;;471    	}
;;;472    
;;;473    	// 获取当前要处理的命令帧指针
;;;474    	pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.head];
000016  eb001100          ADD      r1,r0,r0,LSL #4
00001a  eb011180          ADD      r1,r1,r0,LSL #6
00001e  eb050441          ADD      r4,r5,r1,LSL #1
000022  f5047480          ADD      r4,r4,#0x100
;;;475    	
;;;476    	// 命令头非法，退出
;;;477    	if(IAP_CTRL_UART_CMD_HEAD != pCmdFrame->buff[IAP_CTRL_UART_CMD_HEAD_INDEX])
;;;478    	{
;;;479    		// 删除命令帧
;;;480    		pCB->rx.head ++;
;;;481    		pCB->rx.head %= IAP_CTRL_UART_RX_QUEUE_SIZE;
000026  2605              MOVS     r6,#5
000028  7821              LDRB     r1,[r4,#0]            ;477
00002a  2955              CMP      r1,#0x55              ;477
00002c  d009              BEQ      |L2.66|
00002e  1c40              ADDS     r0,r0,#1              ;480
000030  b280              UXTH     r0,r0                 ;480
000032  fbb0f1f6          UDIV     r1,r0,r6
000036  fb060011          MLS      r0,r6,r1,r0
00003a  f8a5042a          STRH     r0,[r5,#0x42a]
                  |L2.62|
;;;482    		return;
;;;483    	}
;;;484    
;;;485    	// 命令头合法，则提取命令
;;;486    	cmd = (IAP_CTRL_UART_CMD)pCmdFrame->buff[IAP_CTRL_UART_CMD_CMD_INDEX];
;;;487    	
;;;488    	// 执行命令帧
;;;489    	switch(cmd)
;;;490    	{		
;;;491    		case IAP_CTRL_UART_CMD_NULL:
;;;492    			break;
;;;493    
;;;494    		// 收到对发ECO请求
;;;495    		case IAP_CTRL_UART_CMD_UP_PROJECT_APPLY:
;;;496    //			// 关闭跳入APP1定时器
;;;497    //			TIMER_KillTask(TIMER_ID_IAP_RUN_WINDOW_TIME);
;;;498    //			
;;;499    //			// 如果成功跳入指定APP,如果指定地址APP非法，上报失败
;;;500    //			errStatus = IAP_CheckAppRightful(IAP_FLASH_APP1_ADDR);
;;;501    //			if(0 == paramCB.runtime.jumpFlag)
;;;502    //			{
;;;503    //				paramCB.runtime.jumpFlag = (BOOL)1;
;;;504    //				
;;;505    //				// 升级完成延时回复后跳转
;;;506    //				TIMER_AddTask(TIMER_ID_ECO_JUMP,
;;;507    //								200,
;;;508    //								IAP_JumpToAppFun,
;;;509    //								IAP_FLASH_APP1_ADDR,
;;;510    //								1,
;;;511    //								ACTION_MODE_ADD_TO_QUEUE);
;;;512    //			}
;;;513    			// 关闭跳入APP1定时器
;;;514    			TIMER_KillTask(TIMER_ID_IAP_RUN_WINDOW_TIME);
;;;515    
;;;516    			TIMER_AddTask(TIMER_ID_IAP_RUN_WINDOW_TIME,
;;;517    								500,
;;;518    								IAP_JumpToAppFun,
;;;519    								IAP_FLASH_APP1_ADDR,
;;;520    								1,
;;;521    								ACTION_MODE_ADD_TO_QUEUE);
;;;522    								
;;;523    			UART_PROTOCOL_SendMcuUid(1);
;;;524    			
;;;525    			// 发送MCU_UID
;;;526    			TIMER_AddTask(TIMER_ID_MCU_UID,
;;;527    							50,
;;;528    							UART_PROTOCOL_SendMcuUid,
;;;529    							1,
;;;530    							4,
;;;531    							ACTION_MODE_ADD_TO_QUEUE);	
;;;532    	
;;;533    			break;
;;;534    
;;;535    		// 工程模式批准
;;;536    		case IAP_CTRL_UART_CMD_DOWN_PROJECT_APPLY_ACK:
;;;537    			// 关闭此定时器
;;;538    			TIMER_KillTask(TIMER_ID_IAP_RUN_WINDOW_TIME);
;;;539    			TIMER_KillTask(TIMER_ID_IAP_ECO_REQUEST);
;;;540    
;;;541    			// 发送结果
;;;542    			IAP_CTRL_UART_SendCmdWithResult(IAP_CTRL_UART_CMD_UP_PROJECT_READY, TRUE);
;;;543    			break;
;;;544    
;;;545    		// 恢复出厂设置
;;;546    		case IAP_CTRL_UART_CMD_DOWN_FACTORY_RESET:
;;;547    			break;
;;;548    
;;;549    		// 设置RTC
;;;550    		case IAP_CTRL_UART_CMD_DOWN_RTC_SET:
;;;551    			break;
;;;552    
;;;553    		// 系统参数写入
;;;554    		case IAP_CTRL_UART_CMD_DOWN_PARAM_SET:
;;;555    			break;
;;;556    
;;;557    		// UI数据擦除
;;;558    		case IAP_CTRL_UART_CMD_DOWN_UI_DATA_ERASE:
;;;559    			// 以块方式擦除
;;;560    #if (0 == SPI_FLASH_ERASE_MODE)
;;;561    			// 扇区擦除
;;;562    			SPI_FLASH_EraseRoom(SPI_FLASH_UI_OFFSET_ADDR, SPI_FLASH_UI_SIZE);
;;;563    			
;;;564    #elif (1 == SPI_FLASH_ERASE_MODE)
;;;565    			// 擦除整个FLASH
;;;566    			SPI_FLASH_EraseChip();
;;;567    			
;;;568    #elif (2 == SPI_FLASH_ERASE_MODE)
;;;569    			SPI_FLASH_EraseRoom(SPI_FLASH_UI_OFFSET_ADDR, SPI_FLASH_UI_SIZE);
;;;570    #endif
;;;571    
;;;572    			// 发送结果
;;;573    			IAP_CTRL_UART_SendCmdWithResult(IAP_CTRL_UART_CMD_UP_UI_DATA_ERASE_ACK, TRUE);
;;;574    			break;
;;;575    
;;;576    		// UI数据写入
;;;577    		case IAP_CTRL_UART_CMD_DOWN_UI_DATA_WRITE:
;;;578    			// 禁止SPI以修改配置
;;;579    			spi_disable(STM32_SPIx_NUM_DEF);
;;;580    			SPIx_ConfigureWorkMode(SPI_TRANSMODE_FULLDUPLEX, SPI_FRAMESIZE_8BIT);
;;;581    			spi_enable(STM32_SPIx_NUM_DEF);
;;;582    			temp  = pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA1_INDEX];
;;;583    			temp <<= 8;
;;;584    			temp += pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA2_INDEX];
;;;585    			temp <<= 8;
;;;586    			temp += pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA3_INDEX];
;;;587    			temp <<= 8;
;;;588    			temp += pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA4_INDEX];
;;;589    
;;;590    			length = pCmdFrame->buff[IAP_CTRL_UART_CMD_LENGTH_INDEX] - 4;
;;;591    
;;;592    			// 写入数据到flash里面
;;;593    			errStatus = SPI_FLASH_WriteWithCheck(SPI_FLASH_UI_OFFSET_ADDR + (uint8*)&pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA5_INDEX], temp, length);
;;;594    
;;;595    			// 发送结果
;;;596    			IAP_CTRL_UART_SendCmdWithResult(IAP_CTRL_UART_CMD_UP_UI_DATA_WRITE_RESULT, errStatus);
;;;597    			break;
;;;598    
;;;599    		// APP擦除
;;;600    		case IAP_CTRL_UART_CMD_DOWN_IAP_ERASE_FLASH:
;;;601    			// 先擦除APP代码区
;;;602    			IAP_EraseAPPArea();
;;;603    
;;;604    			// 擦除完后需要读出来检查是否为空
;;;605    			errStatus = IAP_CheckFlashIsBlank();
;;;606    
;;;607    			// 发送结果
;;;608    			IAP_CTRL_UART_SendCmdWithResult(IAP_CTRL_UART_CMD_UP_IAP_ERASE_FLASH_RESULT, errStatus);
;;;609    
;;;610    			break;
;;;611    			
;;;612    		// APP数据写入
;;;613    		case IAP_CTRL_UART_CMD_DOWN_IAP_WRITE_FLASH:
;;;614    			{
;;;615    				uint8 encryptionMode;
;;;616    				uint8 key;
;;;617    				static uint8 arrbuf[IAP_CTRL_UART_CMD_LENGTH_MAX];
;;;618    				
;;;619    				encryptionMode = pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA1_INDEX];
;;;620    				key 		   = pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA2_INDEX];
;;;621    
;;;622    				switch (encryptionMode)
;;;623    				{
;;;624    					case 0x00:	// 无加密，【密钥】无意义
;;;625    						temp  = pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA3_INDEX];
;;;626    						temp <<= 8;
;;;627    						temp += pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA4_INDEX];
;;;628    						temp <<= 8;
;;;629    						temp += pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA5_INDEX];
;;;630    						temp <<= 8;
;;;631    						temp += pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA6_INDEX];
;;;632    
;;;633    						length = pCmdFrame->buff[IAP_CTRL_UART_CMD_LENGTH_INDEX] - 6;
;;;634    
;;;635    						// 写入数据
;;;636    						errStatus = IAP_WriteAppBin(temp, (uint8*)&pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA7_INDEX], length);
;;;637    						break;
;;;638    
;;;639    					case 0x01:	// 加密，地址与数据均与【密钥】相亦或后使用
;;;640    						temp  = (pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA3_INDEX] ^ key);
;;;641    						temp <<= 8;
;;;642    						temp += (pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA4_INDEX] ^ key);
;;;643    						temp <<= 8;
;;;644    						temp += (pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA5_INDEX] ^ key);
;;;645    						temp <<= 8;
;;;646    						temp += (pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA6_INDEX] ^ key);
;;;647    
;;;648    						length = pCmdFrame->buff[IAP_CTRL_UART_CMD_LENGTH_INDEX] - 6;
;;;649    
;;;650    						for (i = 0; i < length; i++)
;;;651    						{
;;;652    							arrbuf[i] = pCmdFrame->buff[IAP_CTRL_UART_CMD_DATA7_INDEX + i] ^ key;
;;;653    						}
;;;654    
;;;655    						// 写入数据
;;;656    						errStatus = IAP_WriteAppBin(temp, arrbuf, length);
;;;657    						break;
;;;658    
;;;659    					case 0x02:
;;;660    						errStatus = FALSE;
;;;661    						break;
;;;662    
;;;663    					default:
;;;664    						errStatus = FALSE;
;;;665    						break;
;;;666    				}
;;;667    
;;;668    				// 发送结果
;;;669    				IAP_CTRL_UART_SendCmdWithResult(IAP_CTRL_UART_CMD_UP_IAP_WRITE_FLASH_RESULT, errStatus);
;;;670    			}
;;;671    
;;;672    			break;
;;;673    
;;;674    		// 查空
;;;675    		case IAP_CTRL_UART_CMD_DOWN_CHECK_FALSH_BLANK:
;;;676    			errStatus = IAP_CheckApp2FlashIsBlank();
;;;677    
;;;678    			// 发送结果
;;;679    			IAP_CTRL_UART_SendCmdWithResult(IAP_CTRL_UART_CMD_UP_CHECK_FLASH_BLANK_RESULT, errStatus);
;;;680    			break;
;;;681    
;;;682    		// APP升级完成
;;;683    		case IAP_CTRL_UART_CMD_DOWN_UPDATA_FINISH:
;;;684    			// 发送应答
;;;685    			IAP_CTRL_UART_SendCmdNoResult(IAP_CTRL_UART_CMD_UP_UPDATA_FINISH_RESULT);
;;;686    			break;
;;;687    			
;;;688    		default:
;;;689    			break;
;;;690    	}
;;;691    	
;;;692    	// 删除命令帧
;;;693    	pCB->rx.head ++;
;;;694    	pCB->rx.head %= IAP_CTRL_UART_RX_QUEUE_SIZE;
;;;695    }
00003e  e8bd81fc          POP      {r2-r8,pc}
                  |L2.66|
000042  7860              LDRB     r0,[r4,#1]            ;486
000044  2812              CMP      r0,#0x12              ;489
000046  d03b              BEQ      |L2.192|
000048  dc08              BGT      |L2.92|
00004a  2804              CMP      r0,#4                 ;489
00004c  da2c              BGE      |L2.168|
00004e  2800              CMP      r0,#0                 ;489
000050  d02a              BEQ      |L2.168|
000052  2801              CMP      r0,#1                 ;489
000054  d00f              BEQ      |L2.118|
000056  2802              CMP      r0,#2                 ;489
                  |L2.88|
000058  d126              BNE      |L2.168|
00005a  e026              B        |L2.170|
                  |L2.92|
00005c  2826              CMP      r0,#0x26              ;489
00005e  d062              BEQ      |L2.294|
000060  dc04              BGT      |L2.108|
000062  2814              CMP      r0,#0x14              ;489
000064  d036              BEQ      |L2.212|
000066  2824              CMP      r0,#0x24              ;489
000068  d1f6              BNE      |L2.88|
00006a  e053              B        |L2.276|
                  |L2.108|
00006c  2828              CMP      r0,#0x28              ;489
00006e  d079              BEQ      |L2.356|
000070  282a              CMP      r0,#0x2a              ;489
000072  d1f1              BNE      |L2.88|
000074  e0a6              B        |L2.452|
                  |L2.118|
000076  2000              MOVS     r0,#0                 ;514
000078  f7fffffe          BL       TIMER_KillTask
00007c  2401              MOVS     r4,#1                 ;516
00007e  9400              STR      r4,[sp,#0]            ;516
000080  4b57              LDR      r3,|L2.480|
000082  4a58              LDR      r2,|L2.484|
000084  f44f71fa          MOV      r1,#0x1f4             ;516
000088  2000              MOVS     r0,#0                 ;516
00008a  9401              STR      r4,[sp,#4]            ;516
00008c  f7fffffe          BL       TIMER_AddTask
000090  2001              MOVS     r0,#1                 ;523
000092  f7fffffe          BL       UART_PROTOCOL_SendMcuUid
000096  2004              MOVS     r0,#4                 ;526
000098  e9cd0400          STRD     r0,r4,[sp,#0]         ;526
00009c  2301              MOVS     r3,#1                 ;526
00009e  4a52              LDR      r2,|L2.488|
0000a0  2132              MOVS     r1,#0x32              ;526
0000a2  2007              MOVS     r0,#7                 ;526
0000a4  f7fffffe          BL       TIMER_AddTask
                  |L2.168|
0000a8  e08f              B        |L2.458|
                  |L2.170|
0000aa  2000              MOVS     r0,#0                 ;538
0000ac  f7fffffe          BL       TIMER_KillTask
0000b0  2002              MOVS     r0,#2                 ;539
0000b2  f7fffffe          BL       TIMER_KillTask
0000b6  2101              MOVS     r1,#1                 ;542
0000b8  2003              MOVS     r0,#3                 ;542
0000ba  f7fffffe          BL       IAP_CTRL_UART_SendCmdWithResult
0000be  e084              B        |L2.458|
                  |L2.192|
0000c0  f44f1140          MOV      r1,#0x300000          ;569
0000c4  2000              MOVS     r0,#0                 ;569
0000c6  f7fffffe          BL       SPI_FLASH_EraseRoom
0000ca  2101              MOVS     r1,#1                 ;573
0000cc  2013              MOVS     r0,#0x13              ;573
0000ce  f7fffffe          BL       IAP_CTRL_UART_SendCmdWithResult
0000d2  e07a              B        |L2.458|
                  |L2.212|
0000d4  4f45              LDR      r7,|L2.492|
0000d6  4638              MOV      r0,r7                 ;579
0000d8  f7fffffe          BL       spi_disable
0000dc  2100              MOVS     r1,#0                 ;580
0000de  4608              MOV      r0,r1                 ;580
0000e0  f7fffffe          BL       SPIx_ConfigureWorkMode
0000e4  4638              MOV      r0,r7                 ;581
0000e6  f7fffffe          BL       spi_enable
0000ea  78e0              LDRB     r0,[r4,#3]            ;582
0000ec  0200              LSLS     r0,r0,#8              ;583
0000ee  7921              LDRB     r1,[r4,#4]            ;584
0000f0  4408              ADD      r0,r0,r1              ;584
0000f2  0200              LSLS     r0,r0,#8              ;585
0000f4  7961              LDRB     r1,[r4,#5]            ;586
0000f6  4408              ADD      r0,r0,r1              ;586
0000f8  0200              LSLS     r0,r0,#8              ;587
0000fa  79a1              LDRB     r1,[r4,#6]            ;588
0000fc  4401              ADD      r1,r1,r0              ;588
0000fe  78a0              LDRB     r0,[r4,#2]            ;590
000100  1f00              SUBS     r0,r0,#4              ;590
000102  b282              UXTH     r2,r0                 ;590
000104  1de0              ADDS     r0,r4,#7              ;593
000106  f7fffffe          BL       SPI_FLASH_WriteWithCheck
00010a  4601              MOV      r1,r0                 ;593
00010c  2015              MOVS     r0,#0x15              ;596
00010e  f7fffffe          BL       IAP_CTRL_UART_SendCmdWithResult
000112  e05a              B        |L2.458|
                  |L2.276|
000114  f7fffffe          BL       IAP_EraseAPPArea
000118  f7fffffe          BL       IAP_CheckFlashIsBlank
00011c  4601              MOV      r1,r0                 ;605
00011e  2025              MOVS     r0,#0x25              ;608
000120  f7fffffe          BL       IAP_CTRL_UART_SendCmdWithResult
000124  e051              B        |L2.458|
                  |L2.294|
000126  78e0              LDRB     r0,[r4,#3]            ;619
000128  7921              LDRB     r1,[r4,#4]            ;620
00012a  b140              CBZ      r0,|L2.318|
00012c  2801              CMP      r0,#1                 ;622
00012e  d01a              BEQ      |L2.358|
000130  2802              CMP      r0,#2                 ;622
000132  d03e              BEQ      |L2.434|
000134  2100              MOVS     r1,#0                 ;664
                  |L2.310|
000136  2027              MOVS     r0,#0x27              ;669
000138  f7fffffe          BL       IAP_CTRL_UART_SendCmdWithResult
00013c  e045              B        |L2.458|
                  |L2.318|
00013e  7960              LDRB     r0,[r4,#5]            ;625
000140  0200              LSLS     r0,r0,#8              ;626
000142  79a1              LDRB     r1,[r4,#6]            ;627
000144  4408              ADD      r0,r0,r1              ;627
000146  0200              LSLS     r0,r0,#8              ;628
000148  79e1              LDRB     r1,[r4,#7]            ;629
00014a  4408              ADD      r0,r0,r1              ;629
00014c  0200              LSLS     r0,r0,#8              ;630
00014e  7a21              LDRB     r1,[r4,#8]            ;631
000150  4408              ADD      r0,r0,r1              ;631
000152  78a1              LDRB     r1,[r4,#2]            ;633
000154  1f89              SUBS     r1,r1,#6              ;633
000156  b28a              UXTH     r2,r1                 ;633
000158  f1040109          ADD      r1,r4,#9              ;636
00015c  f7fffffe          BL       IAP_WriteAppBin
000160  4601              MOV      r1,r0                 ;636
000162  e7e8              B        |L2.310|
                  |L2.356|
000164  e027              B        |L2.438|
                  |L2.358|
000166  7960              LDRB     r0,[r4,#5]            ;640
000168  4048              EORS     r0,r0,r1              ;640
00016a  0200              LSLS     r0,r0,#8              ;641
00016c  79a2              LDRB     r2,[r4,#6]            ;642
00016e  404a              EORS     r2,r2,r1              ;642
000170  4410              ADD      r0,r0,r2              ;642
000172  0200              LSLS     r0,r0,#8              ;643
000174  79e2              LDRB     r2,[r4,#7]            ;644
000176  404a              EORS     r2,r2,r1              ;644
000178  4410              ADD      r0,r0,r2              ;644
00017a  0200              LSLS     r0,r0,#8              ;645
00017c  7a22              LDRB     r2,[r4,#8]            ;646
00017e  404a              EORS     r2,r2,r1              ;646
000180  1813              ADDS     r3,r2,r0              ;646
000182  78a0              LDRB     r0,[r4,#2]            ;648
000184  1f80              SUBS     r0,r0,#6              ;648
000186  b282              UXTH     r2,r0                 ;648
000188  2000              MOVS     r0,#0                 ;650
00018a  4f19              LDR      r7,|L2.496|
00018c  e009              B        |L2.418|
                  |L2.398|
00018e  eb040c00          ADD      r12,r4,r0             ;652
000192  f89cc009          LDRB     r12,[r12,#9]          ;652
000196  ea8c0c01          EOR      r12,r12,r1            ;652
00019a  f807c000          STRB     r12,[r7,r0]           ;652
00019e  1c40              ADDS     r0,r0,#1              ;650
0001a0  b280              UXTH     r0,r0                 ;650
                  |L2.418|
0001a2  4290              CMP      r0,r2                 ;650
0001a4  d3f3              BCC      |L2.398|
0001a6  4912              LDR      r1,|L2.496|
0001a8  4618              MOV      r0,r3                 ;656
0001aa  f7fffffe          BL       IAP_WriteAppBin
0001ae  4601              MOV      r1,r0                 ;656
0001b0  e7c1              B        |L2.310|
                  |L2.434|
0001b2  2100              MOVS     r1,#0                 ;660
0001b4  e7bf              B        |L2.310|
                  |L2.438|
0001b6  f7fffffe          BL       IAP_CheckApp2FlashIsBlank
0001ba  4601              MOV      r1,r0                 ;676
0001bc  2029              MOVS     r0,#0x29              ;679
0001be  f7fffffe          BL       IAP_CTRL_UART_SendCmdWithResult
0001c2  e002              B        |L2.458|
                  |L2.452|
0001c4  202b              MOVS     r0,#0x2b              ;685
0001c6  f7fffffe          BL       IAP_CTRL_UART_SendCmdNoResult
                  |L2.458|
0001ca  f8b5042a          LDRH     r0,[r5,#0x42a]        ;693
0001ce  1c40              ADDS     r0,r0,#1              ;693
0001d0  b280              UXTH     r0,r0                 ;693
0001d2  fbb0f1f6          UDIV     r1,r0,r6              ;694
0001d6  fb060011          MLS      r0,r6,r1,r0           ;694
0001da  f8a5042a          STRH     r0,[r5,#0x42a]        ;694
0001de  e72e              B        |L2.62|
;;;696    
                          ENDP

                  |L2.480|
                          DCD      0x08008000
                  |L2.484|
                          DCD      IAP_JumpToAppFun
                  |L2.488|
                          DCD      UART_PROTOCOL_SendMcuUid
                  |L2.492|
                          DCD      0x40013000
                  |L2.496|
                          DCD      ||.bss||

                          AREA ||i.IAP_CTRL_UART_ConfirmTempCmdFrameBuff||, CODE, READONLY, ALIGN=1

                  IAP_CTRL_UART_ConfirmTempCmdFrameBuff PROC
;;;230    // 将临时缓冲区添加到命令帧缓冲区中，其本质操作是承认临时缓冲区数据有效
;;;231    BOOL IAP_CTRL_UART_ConfirmTempCmdFrameBuff(IAP_CTRL_UART_CB* pCB)
000000  2800              CMP      r0,#0
;;;232    {
000002  d01e              BEQ      |L3.66|
;;;233    	IAP_CTRL_CMD_FRAME* pCmdFrame = NULL;
;;;234    	
;;;235    	// 参数合法性检验
;;;236    	if(NULL == pCB)
;;;237    	{
;;;238    		return FALSE;
;;;239    	}
;;;240    
;;;241    	// 临时缓冲区为空，不予添加
;;;242    	pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.end];
000004  f8b0142c          LDRH     r1,[r0,#0x42c]
000008  eb011201          ADD      r2,r1,r1,LSL #4
00000c  eb021281          ADD      r2,r2,r1,LSL #6
000010  eb000242          ADD      r2,r0,r2,LSL #1
;;;243    	if(0 == pCmdFrame->length)
000014  f8b221a0          LDRH     r2,[r2,#0x1a0]
000018  b1aa              CBZ      r2,|L3.70|
;;;244    	{
;;;245    		return FALSE;
;;;246    	}
;;;247    
;;;248    	// 添加
;;;249    	pCB->rx.end ++;
00001a  1c49              ADDS     r1,r1,#1
00001c  b289              UXTH     r1,r1
;;;250    	pCB->rx.end %= IAP_CTRL_UART_RX_QUEUE_SIZE;
00001e  2205              MOVS     r2,#5
000020  fbb1f3f2          UDIV     r3,r1,r2
000024  fb021113          MLS      r1,r2,r3,r1
000028  f8a0142c          STRH     r1,[r0,#0x42c]
;;;251    	pCB->rx.cmdQueue[pCB->rx.end].length = 0;	// 该行的作用是将新的添加位置有效数据个数清零，以便将这个位置当做临时帧缓冲区
00002c  eb011301          ADD      r3,r1,r1,LSL #4
000030  eb031181          ADD      r1,r3,r1,LSL #6
000034  eb000041          ADD      r0,r0,r1,LSL #1
000038  2200              MOVS     r2,#0
00003a  f8a021a0          STRH     r2,[r0,#0x1a0]
;;;252    	
;;;253    	return TRUE;
00003e  2001              MOVS     r0,#1
;;;254    }
000040  4770              BX       lr
                  |L3.66|
000042  2000              MOVS     r0,#0                 ;238
000044  4770              BX       lr
                  |L3.70|
000046  2000              MOVS     r0,#0                 ;245
000048  4770              BX       lr
;;;255    
                          ENDP


                          AREA ||i.IAP_CTRL_UART_DataStructureInit||, CODE, READONLY, ALIGN=1

                  IAP_CTRL_UART_DataStructureInit PROC
;;;163    // 数据结构初始化
;;;164    void IAP_CTRL_UART_DataStructureInit(IAP_CTRL_UART_CB* pCB)
000000  2800              CMP      r0,#0
;;;165    {
000002  d02b              BEQ      |L4.92|
;;;166    	uint8 i;
;;;167    	
;;;168    	// 参数合法性检验
;;;169    	if(NULL == pCB)
;;;170    	{
;;;171    		return;
;;;172    	}
;;;173    
;;;174    	pCB->tx.txBusy = FALSE;
000004  2200              MOVS     r2,#0
000006  f880275e          STRB     r2,[r0,#0x75e]
;;;175    	pCB->tx.index = 0;
00000a  f8a0275c          STRH     r2,[r0,#0x75c]
;;;176    	pCB->tx.head = 0;
00000e  f8a02758          STRH     r2,[r0,#0x758]
;;;177    	pCB->tx.end = 0;
000012  f8a0275a          STRH     r2,[r0,#0x75a]
;;;178    	for(i=0; i<IAP_CTRL_UART_TX_QUEUE_SIZE; i++)
000016  2100              MOVS     r1,#0
                  |L4.24|
;;;179    	{
;;;180    		pCB->tx.cmdQueue[i].length = 0;
000018  eb011301          ADD      r3,r1,r1,LSL #4
00001c  eb031381          ADD      r3,r3,r1,LSL #6
000020  eb000343          ADD      r3,r0,r3,LSL #1
000024  f8a324ce          STRH     r2,[r3,#0x4ce]
000028  1c49              ADDS     r1,r1,#1              ;178
00002a  b2c9              UXTB     r1,r1                 ;178
00002c  2905              CMP      r1,#5                 ;178
00002e  d3f3              BCC      |L4.24|
;;;181    	}
;;;182    	
;;;183    	pCB->rxFIFO.head = 0;
000030  f8202ffa          STRH     r2,[r0,#0xfa]!
;;;184    	pCB->rxFIFO.currentProcessIndex = 0;
000034  8082              STRH     r2,[r0,#4]
;;;185    	pCB->rxFIFO.end  = 0;
000036  8042              STRH     r2,[r0,#2]
;;;186    
;;;187    	pCB->rx.head = 0;
000038  f8a02330          STRH     r2,[r0,#0x330]
;;;188    	pCB->rx.end  = 0;
00003c  f8a02332          STRH     r2,[r0,#0x332]
000040  38fa              SUBS     r0,r0,#0xfa
;;;189    	for(i=0; i<IAP_CTRL_UART_RX_QUEUE_SIZE; i++)
000042  2100              MOVS     r1,#0
                  |L4.68|
;;;190    	{
;;;191    		pCB->rx.cmdQueue[i].length = 0;
000044  eb011301          ADD      r3,r1,r1,LSL #4
000048  eb031381          ADD      r3,r3,r1,LSL #6
00004c  eb000343          ADD      r3,r0,r3,LSL #1
000050  f8a321a0          STRH     r2,[r3,#0x1a0]
000054  1c49              ADDS     r1,r1,#1              ;189
000056  b2c9              UXTB     r1,r1                 ;189
000058  2905              CMP      r1,#5                 ;189
00005a  d3f3              BCC      |L4.68|
                  |L4.92|
;;;192    	}
;;;193    }
00005c  4770              BX       lr
;;;194    
                          ENDP


                          AREA ||i.IAP_CTRL_UART_HwInit||, CODE, READONLY, ALIGN=2

                  IAP_CTRL_UART_HwInit PROC
;;;195    // UART初始化
;;;196    void IAP_CTRL_UART_HwInit(uint32 baud)
000000  b570              PUSH     {r4-r6,lr}
;;;197    {
000002  4605              MOV      r5,r0
;;;198    	// GD32
;;;199    	// 时钟配置
;;;200    	rcu_periph_clock_enable(RCU_GPIOC);
000004  f2406004          MOV      r0,#0x604
000008  f7fffffe          BL       rcu_periph_clock_enable
;;;201    	
;;;202    	// GPIO配置
;;;203    	gpio_init(GPIOC, GPIO_MODE_AF_PP, GPIO_OSPEED_2MHZ, GPIO_PIN_10);   //复用推挽
00000c  4c22              LDR      r4,|L5.152|
00000e  f44f6380          MOV      r3,#0x400
000012  2202              MOVS     r2,#2
000014  2118              MOVS     r1,#0x18
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       gpio_init
;;;204    
;;;205    	gpio_init(GPIOC, GPIO_MODE_IPU, GPIO_OSPEED_2MHZ, GPIO_PIN_11); 	// 上拉输入
00001c  14e3              ASRS     r3,r4,#19
00001e  2202              MOVS     r2,#2
000020  2148              MOVS     r1,#0x48
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       gpio_init
;;;206    	
;;;207    	// UART时钟配置
;;;208    	rcu_periph_clock_enable(RCU_UART3);								// 时能USART时钟
000028  f2407013          MOV      r0,#0x713
00002c  f7fffffe          BL       rcu_periph_clock_enable
;;;209    	usart_deinit(IAP_CTRL_UART_TYPE_DEF);									// 复位串口
000030  4c1a              LDR      r4,|L5.156|
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       usart_deinit
;;;210    
;;;211    	// 串口配置
;;;212    	usart_baudrate_set(IAP_CTRL_UART_TYPE_DEF, baud);						// 波特率
000038  4629              MOV      r1,r5
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       usart_baudrate_set
;;;213    	usart_word_length_set(IAP_CTRL_UART_TYPE_DEF, USART_WL_8BIT);			// 8位数据位
000040  2100              MOVS     r1,#0
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       usart_word_length_set
;;;214    	usart_stop_bit_set(IAP_CTRL_UART_TYPE_DEF, USART_STB_1BIT);			// 一个停止位
000048  2100              MOVS     r1,#0
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       usart_stop_bit_set
;;;215    	usart_parity_config(IAP_CTRL_UART_TYPE_DEF, USART_PM_NONE);			// 无奇偶校验
000050  2100              MOVS     r1,#0
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       usart_parity_config
;;;216    	usart_hardware_flow_rts_config(IAP_CTRL_UART_TYPE_DEF, USART_RTS_DISABLE); // 无硬件数据流控制
000058  2100              MOVS     r1,#0
00005a  4620              MOV      r0,r4
00005c  f7fffffe          BL       usart_hardware_flow_rts_config
;;;217    	usart_hardware_flow_cts_config(IAP_CTRL_UART_TYPE_DEF, USART_CTS_DISABLE);
000060  2100              MOVS     r1,#0
000062  4620              MOV      r0,r4
000064  f7fffffe          BL       usart_hardware_flow_cts_config
;;;218    	usart_transmit_config(IAP_CTRL_UART_TYPE_DEF, USART_TRANSMIT_ENABLE);	// 使能发射
000068  2108              MOVS     r1,#8
00006a  4620              MOV      r0,r4
00006c  f7fffffe          BL       usart_transmit_config
;;;219    	usart_receive_config(IAP_CTRL_UART_TYPE_DEF, USART_RECEIVE_ENABLE);		// 使能接收
000070  2104              MOVS     r1,#4
000072  4620              MOV      r0,r4
000074  f7fffffe          BL       usart_receive_config
;;;220    
;;;221    	// 中断配置
;;;222    	nvic_irq_enable(IAP_CTRL_UART_IRQn_DEF, 2, 1);
000078  2201              MOVS     r2,#1
00007a  2102              MOVS     r1,#2
00007c  2034              MOVS     r0,#0x34
00007e  f7fffffe          BL       nvic_irq_enable
;;;223    
;;;224    	usart_interrupt_enable(IAP_CTRL_UART_TYPE_DEF, USART_INT_RBNE);			// 开启中断
000082  f2403105          MOV      r1,#0x305
000086  4620              MOV      r0,r4
000088  f7fffffe          BL       usart_interrupt_enable
;;;225    
;;;226    	usart_enable(IAP_CTRL_UART_TYPE_DEF);									// 使能串口 
00008c  4620              MOV      r0,r4
00008e  e8bd4070          POP      {r4-r6,lr}
000092  f7ffbffe          B.W      usart_enable
;;;227    
;;;228    }
;;;229    
                          ENDP

000096  0000              DCW      0x0000
                  |L5.152|
                          DCD      0x40011000
                  |L5.156|
                          DCD      0x40004c00

                          AREA ||i.IAP_CTRL_UART_IR_StartSendData||, CODE, READONLY, ALIGN=2

                  IAP_CTRL_UART_IR_StartSendData PROC
;;;927    // 启动中断字节发送
;;;928    void IAP_CTRL_UART_IR_StartSendData(uint8 data)
000000  b570              PUSH     {r4-r6,lr}
;;;929    {
000002  4605              MOV      r5,r0
;;;930    	// 先读SR，再填充DR会把TC标志清掉
;;;931    	usart_flag_get(IAP_CTRL_UART_TYPE_DEF, USART_FLAG_TC);
000004  4c07              LDR      r4,|L6.36|
000006  2106              MOVS     r1,#6
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       usart_flag_get
;;;932    
;;;933    	// 发送一个字节
;;;934    	usart_data_transmit(IAP_CTRL_UART_TYPE_DEF, data);
00000e  4629              MOV      r1,r5
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       usart_data_transmit
;;;935    
;;;936    	// 打开发送完成中断
;;;937    	usart_interrupt_enable(IAP_CTRL_UART_TYPE_DEF, USART_INT_TC);	
000016  4620              MOV      r0,r4
000018  e8bd4070          POP      {r4-r6,lr}
00001c  f2403106          MOV      r1,#0x306
000020  f7ffbffe          B.W      usart_interrupt_enable
;;;938    }
;;;939    
                          ENDP

                  |L6.36|
                          DCD      0x40004c00

                          AREA ||i.IAP_CTRL_UART_Init||, CODE, READONLY, ALIGN=2

                  IAP_CTRL_UART_Init PROC
;;;99     // UART初始化
;;;100    void IAP_CTRL_UART_Init(void)
000000  b510              PUSH     {r4,lr}
;;;101    {	
;;;102    	// 硬件UART配置
;;;103    	IAP_CTRL_UART_HwInit(IAP_CTRL_UART_BAUD_RATE);
000002  f44f30e1          MOV      r0,#0x1c200
000006  f7fffffe          BL       IAP_CTRL_UART_HwInit
;;;104    
;;;105    	// UART数据结构初始化
;;;106    	IAP_CTRL_UART_DataStructureInit(&iapCtrlUartCB);
00000a  e8bd4010          POP      {r4,lr}
00000e  4801              LDR      r0,|L7.20|
000010  f7ffbffe          B.W      IAP_CTRL_UART_DataStructureInit
;;;107    
;;;108    #if 0
;;;109    	
;;;110    	iapCtrlUartCB.rxFIFO.buff[iapCtrlUartCB.rxFIFO.end++]=0x55;
;;;111    	iapCtrlUartCB.rxFIFO.buff[iapCtrlUartCB.rxFIFO.end++]=0x26;
;;;112    	iapCtrlUartCB.rxFIFO.buff[iapCtrlUartCB.rxFIFO.end++]=0x14;
;;;113    	iapCtrlUartCB.rxFIFO.buff[iapCtrlUartCB.rxFIFO.end++]=0x08;
;;;114    	iapCtrlUartCB.rxFIFO.buff[iapCtrlUartCB.rxFIFO.end++]=0x00;
;;;115    	iapCtrlUartCB.rxFIFO.buff[iapCtrlUartCB.rxFIFO.end++]=0x66;
;;;116    	iapCtrlUartCB.rxFIFO.buff[iapCtrlUartCB.rxFIFO.end++]=0x50;
;;;117    	iapCtrlUartCB.rxFIFO.buff[iapCtrlUartCB.rxFIFO.end++]=0x00;
;;;118    	iapCtrlUartCB.rxFIFO.buff[iapCtrlUartCB.rxFIFO.end++]=0x5d;
;;;119    	iapCtrlUartCB.rxFIFO.buff[iapCtrlUartCB.rxFIFO.end++]=0xc0;
;;;120    	iapCtrlUartCB.rxFIFO.buff[iapCtrlUartCB.rxFIFO.end++]=0x43;
;;;121    	iapCtrlUartCB.rxFIFO.buff[iapCtrlUartCB.rxFIFO.end++]=0x33;
;;;122    	iapCtrlUartCB.rxFIFO.buff[iapCtrlUartCB.rxFIFO.end++]=0x49;
;;;123    	iapCtrlUartCB.rxFIFO.buff[iapCtrlUartCB.rxFIFO.end++]=0x09;
;;;124    	iapCtrlUartCB.rxFIFO.buff[iapCtrlUartCB.rxFIFO.end++]=0x5d;
;;;125    	iapCtrlUartCB.rxFIFO.buff[iapCtrlUartCB.rxFIFO.end++]=0x60;
;;;126    	iapCtrlUartCB.rxFIFO.buff[iapCtrlUartCB.rxFIFO.end++]=0xf3;
;;;127    	iapCtrlUartCB.rxFIFO.buff[iapCtrlUartCB.rxFIFO.end++]=0x00;
;;;128    	iapCtrlUartCB.rxFIFO.buff[iapCtrlUartCB.rxFIFO.end++]=0x01;
;;;129    	iapCtrlUartCB.rxFIFO.buff[iapCtrlUartCB.rxFIFO.end++]=0x31;
;;;130    	iapCtrlUartCB.rxFIFO.buff[iapCtrlUartCB.rxFIFO.end++]=0x48;
;;;131    	iapCtrlUartCB.rxFIFO.buff[iapCtrlUartCB.rxFIFO.end++]=0x01;
;;;132    	iapCtrlUartCB.rxFIFO.buff[iapCtrlUartCB.rxFIFO.end++]=0x55;
;;;133    	iapCtrlUartCB.rxFIFO.buff[iapCtrlUartCB.rxFIFO.end++]=0xe9;
;;;134    	iapCtrlUartCB.rxFIFO.buff[iapCtrlUartCB.rxFIFO.end++]=0x55;
;;;135    	iapCtrlUartCB.rxFIFO.buff[iapCtrlUartCB.rxFIFO.end++]=0x26;
;;;136    	iapCtrlUartCB.rxFIFO.buff[iapCtrlUartCB.rxFIFO.end++]=0x14;
;;;137    	iapCtrlUartCB.rxFIFO.buff[iapCtrlUartCB.rxFIFO.end++]=0x08;
;;;138    	iapCtrlUartCB.rxFIFO.buff[iapCtrlUartCB.rxFIFO.end++]=0x00;
;;;139    	iapCtrlUartCB.rxFIFO.buff[iapCtrlUartCB.rxFIFO.end++]=0x66;
;;;140    	iapCtrlUartCB.rxFIFO.buff[iapCtrlUartCB.rxFIFO.end++]=0x60;
;;;141    	iapCtrlUartCB.rxFIFO.buff[iapCtrlUartCB.rxFIFO.end++]=0x5d;
;;;142    	iapCtrlUartCB.rxFIFO.buff[iapCtrlUartCB.rxFIFO.end++]=0xe0;
;;;143    	iapCtrlUartCB.rxFIFO.buff[iapCtrlUartCB.rxFIFO.end++]=0x5b;
;;;144    	iapCtrlUartCB.rxFIFO.buff[iapCtrlUartCB.rxFIFO.end++]=0xe0;
;;;145    	iapCtrlUartCB.rxFIFO.buff[iapCtrlUartCB.rxFIFO.end++]=0x33;
;;;146    	iapCtrlUartCB.rxFIFO.buff[iapCtrlUartCB.rxFIFO.end++]=0x48;
;;;147    	iapCtrlUartCB.rxFIFO.buff[iapCtrlUartCB.rxFIFO.end++]=0x01;
;;;148    	iapCtrlUartCB.rxFIFO.buff[iapCtrlUartCB.rxFIFO.end++]=0x68;
;;;149    	iapCtrlUartCB.rxFIFO.buff[iapCtrlUartCB.rxFIFO.end++]=0x33;
;;;150    	iapCtrlUartCB.rxFIFO.buff[iapCtrlUartCB.rxFIFO.end++]=0x48;
;;;151    	iapCtrlUartCB.rxFIFO.buff[iapCtrlUartCB.rxFIFO.end++]=0x00;
;;;152    	iapCtrlUartCB.rxFIFO.buff[iapCtrlUartCB.rxFIFO.end++]=0x68;
;;;153    	iapCtrlUartCB.rxFIFO.buff[iapCtrlUartCB.rxFIFO.end++]=0xff;
;;;154    	iapCtrlUartCB.rxFIFO.buff[iapCtrlUartCB.rxFIFO.end++]=0xf7;
;;;155    	iapCtrlUartCB.rxFIFO.buff[iapCtrlUartCB.rxFIFO.end++]=0x32;
;;;156    	iapCtrlUartCB.rxFIFO.buff[iapCtrlUartCB.rxFIFO.end++]=0xff;
;;;157    	iapCtrlUartCB.rxFIFO.buff[iapCtrlUartCB.rxFIFO.end++]=0x54;
;;;158    	iapCtrlUartCB.rxFIFO.buff[iapCtrlUartCB.rxFIFO.end++]=0x28;
;;;159    #endif
;;;160    	
;;;161    }
;;;162    
                          ENDP

                  |L7.20|
                          DCD      ||.bss||+0xa0

                          AREA ||i.IAP_CTRL_UART_LcdControl||, CODE, READONLY, ALIGN=2

                  IAP_CTRL_UART_LcdControl PROC
;;;702    // 串口显示控制
;;;703    uint8 IAP_CTRL_UART_LcdControl(uint8 lcdCmd)
000000  b538              PUSH     {r3-r5,lr}
;;;704    {
000002  4604              MOV      r4,r0
;;;705    	switch (lcdCmd)
;;;706    	{
;;;707    		case 0:
;;;708    			gpio_bit_set(GPIOA, GPIO_PIN_8);	
000004  481e              LDR      r0,|L8.128|
000006  f44f7180          MOV      r1,#0x100
00000a  2c08              CMP      r4,#8                 ;705
00000c  d235              BCS      |L8.122|
00000e  e8dff004          TBB      [pc,r4]               ;705
000012  042a              DCB      0x04,0x2a
000014  2a2a2a2a          DCB      0x2a,0x2a,0x2a,0x2a
000018  2a32              DCB      0x2a,0x32
00001a  f7fffffe          BL       gpio_bit_set
;;;709    			LCD_DrawAreaColor(	 		0, 		      0, LCD_WIDTH/2, LCD_HEIGHT/2,LCD_COLOR_RED);
00001e  f44f4078          MOV      r0,#0xf800
000022  2100              MOVS     r1,#0
000024  9000              STR      r0,[sp,#0]
000026  2350              MOVS     r3,#0x50
000028  2240              MOVS     r2,#0x40
00002a  4608              MOV      r0,r1
00002c  f7fffffe          BL       LCD_DrawAreaColor
;;;710    			LCD_DrawAreaColor(LCD_HEIGHT/2,			  0, LCD_WIDTH/2,LCD_HEIGHT/2,LCD_COLOR_GREEN);
000030  f44f60fc          MOV      r0,#0x7e0
000034  2350              MOVS     r3,#0x50
000036  9000              STR      r0,[sp,#0]
000038  2240              MOVS     r2,#0x40
00003a  2100              MOVS     r1,#0
00003c  4618              MOV      r0,r3
00003e  f7fffffe          BL       LCD_DrawAreaColor
;;;711    			LCD_DrawAreaColor(			0, LCD_WIDTH/2, LCD_WIDTH/2,LCD_HEIGHT/2,LCD_COLOR_BLUE);
000042  201f              MOVS     r0,#0x1f
000044  2240              MOVS     r2,#0x40
000046  9000              STR      r0,[sp,#0]
000048  2350              MOVS     r3,#0x50
00004a  4611              MOV      r1,r2
00004c  2000              MOVS     r0,#0
00004e  f7fffffe          BL       LCD_DrawAreaColor
;;;712    			LCD_DrawAreaColor(LCD_HEIGHT/2, LCD_WIDTH/2, LCD_WIDTH/2,LCD_HEIGHT/2,LCD_COLOR_WHITE);
000052  f64f70ff          MOV      r0,#0xffff
000056  2350              MOVS     r3,#0x50
000058  2240              MOVS     r2,#0x40
00005a  9000              STR      r0,[sp,#0]
00005c  4611              MOV      r1,r2
00005e  4618              MOV      r0,r3
000060  f7fffffe          BL       LCD_DrawAreaColor
;;;713    			break;
000064  e009              B        |L8.122|
;;;714    
;;;715    		case 1:
;;;716    		case 2:
;;;717    		case 3:
;;;718    		case 4:
;;;719    		case 5:
;;;720    		case 6:
;;;721    			gpio_bit_set(GPIOA, GPIO_PIN_8);
000066  f7fffffe          BL       gpio_bit_set
;;;722    			LCD_FillColor(colorDisplay[lcdCmd]);
00006a  4806              LDR      r0,|L8.132|
00006c  f8300014          LDRH     r0,[r0,r4,LSL #1]
000070  f7fffffe          BL       LCD_FillColor
;;;723    			break;
000074  e001              B        |L8.122|
;;;724    
;;;725    		case 7:
;;;726    			gpio_bit_reset(GPIOA, GPIO_PIN_8);
000076  f7fffffe          BL       gpio_bit_reset
                  |L8.122|
;;;727    			break;
;;;728    
;;;729    		default:		
;;;730    			break;
;;;731    	}
;;;732    	return 0;
00007a  2000              MOVS     r0,#0
;;;733    }
00007c  bd38              POP      {r3-r5,pc}
;;;734    			
                          ENDP

00007e  0000              DCW      0x0000
                  |L8.128|
                          DCD      0x40010800
                  |L8.132|
                          DCD      ||.data||+0x2

                          AREA ||i.IAP_CTRL_UART_Process||, CODE, READONLY, ALIGN=2

                  IAP_CTRL_UART_Process PROC
;;;816    // UART模块处理入口
;;;817    void IAP_CTRL_UART_Process(void)
000000  b510              PUSH     {r4,lr}
;;;818    {
;;;819    	// 内部通讯接口的一级接收缓冲区处理
;;;820    	IAP_CTRL_UART_RxFIFOProcess(&iapCtrlUartCB);
000002  4805              LDR      r0,|L9.24|
000004  f7fffffe          BL       IAP_CTRL_UART_RxFIFOProcess
;;;821    
;;;822    	// 内部通讯接口的命令帧缓冲区处理
;;;823    	IAP_CTRL_UART_CmdFrameProcess(&iapCtrlUartCB);
000008  4803              LDR      r0,|L9.24|
00000a  f7fffffe          BL       IAP_CTRL_UART_CmdFrameProcess
;;;824    	
;;;825    	//中断发送方式
;;;826    #if (IAP_CTRL_UART_TX_MODE == IAP_CTRL_INTERRUPT_TX_MODE)
;;;827    	// 内部通讯接口的发送处理
;;;828    	IAP_CTRL_UART_TxProcess(&iapCtrlUartCB);
00000e  e8bd4010          POP      {r4,lr}
000012  4801              LDR      r0,|L9.24|
000014  f7ffbffe          B.W      IAP_CTRL_UART_TxProcess
;;;829    #endif
;;;830    
;;;831    }
;;;832    
                          ENDP

                  |L9.24|
                          DCD      ||.bss||+0xa0

                          AREA ||i.IAP_CTRL_UART_RxFIFOProcess||, CODE, READONLY, ALIGN=1

                  IAP_CTRL_UART_RxFIFOProcess PROC
;;;256    // 一级接收缓冲区处理，从一级接收缓冲区中取出一个字节添加到命令帧缓冲区中
;;;257    void IAP_CTRL_UART_RxFIFOProcess(IAP_CTRL_UART_CB* pCB)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;258    {
000004  4604              MOV      r4,r0
;;;259    	uint16 end = pCB->rxFIFO.end;
000006  f8b410fc          LDRH     r1,[r4,#0xfc]
;;;260    	uint16 head = pCB->rxFIFO.head;
00000a  f8b400fa          LDRH     r0,[r4,#0xfa]
;;;261    	IAP_CTRL_CMD_FRAME* pCmdFrame = NULL;
;;;262    	uint16 length = 0;
;;;263    	uint8 currentData = 0;
;;;264    	
;;;265    	// 参数合法性检验
;;;266    	if(NULL == pCB)
00000e  2c00              CMP      r4,#0
000010  d024              BEQ      |L10.92|
;;;267    	{
;;;268    		return;
;;;269    	}
;;;270    	
;;;271    	// 一级缓冲区为空，退出
;;;272    	if(head == end)
000012  4288              CMP      r0,r1
000014  d022              BEQ      |L10.92|
;;;273    	{
;;;274    		return;
;;;275    	}
;;;276    
;;;277    	// 获取临时缓冲区指针
;;;278    	pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.end];
000016  f8b4042c          LDRH     r0,[r4,#0x42c]
00001a  eb001200          ADD      r2,r0,r0,LSL #4
00001e  eb021280          ADD      r2,r2,r0,LSL #6
000022  eb040542          ADD      r5,r4,r2,LSL #1
000026  f5057580          ADD      r5,r5,#0x100
;;;279    	// 取出当前要处理的字节
;;;280    	currentData = pCB->rxFIFO.buff[pCB->rxFIFO.currentProcessIndex];
00002a  f8b420fe          LDRH     r2,[r4,#0xfe]
00002e  5ca2              LDRB     r2,[r4,r2]
;;;281    	
;;;282    	// 临时缓冲区长度为0时，搜索首字节
;;;283    	if(0 == pCmdFrame->length)
000030  f8b530a0          LDRH     r3,[r5,#0xa0]
;;;284    	{
;;;285    		// 命令头错误，删除当前字节并退出
;;;286    		if(IAP_CTRL_UART_CMD_HEAD != currentData)
;;;287    		{
;;;288    			pCB->rxFIFO.head ++;
;;;289    			pCB->rxFIFO.head %= IAP_CTRL_UART_RX_FIFO_SIZE;
000034  27fa              MOVS     r7,#0xfa
000036  b19b              CBZ      r3,|L10.96|
;;;290    			pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;291    
;;;292    			return;
;;;293    		}
;;;294    		
;;;295    		// 命令头正确，但无临时缓冲区可用，退出
;;;296    		if((pCB->rx.end + 1)%IAP_CTRL_UART_RX_QUEUE_SIZE == pCB->rx.head)
;;;297    		{
;;;298    			return;
;;;299    		}
;;;300    
;;;301    		// 添加UART通讯超时时间设置-2016.1.5增加
;;;302    		#if IAP_CTRL_UART_RX_TIME_OUT_CHECK_ENABLE
;;;303    		TIMER_AddTask(TIMER_ID_UART_RX_TIME_OUT_CONTROL, IAP_CTRL_UART_BUS_UNIDIRECTIONAL_TIME_OUT, IAP_CTRL_UART_CALLBACK_RxTimeOut, 0, 1, ACTION_MODE_ADD_TO_QUEUE);
;;;304    		#endif
;;;305    		
;;;306    		// 命令头正确，有临时缓冲区可用，则将其添加到命令帧临时缓冲区中
;;;307    		pCmdFrame->buff[pCmdFrame->length++]= currentData;
;;;308    		pCB->rxFIFO.currentProcessIndex ++;
;;;309    		pCB->rxFIFO.currentProcessIndex %= IAP_CTRL_UART_RX_FIFO_SIZE;
;;;310    	}
;;;311    	// 非首字节，将数据添加到命令帧临时缓冲区中，但暂不删除当前数据
;;;312    	else
;;;313    	{
;;;314    		// 临时缓冲区溢出，说明当前正在接收的命令帧是错误的，正确的命令帧不会出现长度溢出的情况
;;;315    		if(pCmdFrame->length >= IAP_CTRL_UART_CMD_LENGTH_MAX)
000038  f04f0800          MOV      r8,#0
00003c  2ba0              CMP      r3,#0xa0
00003e  d37d              BCC      |L10.316|
;;;316    		{
;;;317    			#if IAP_CTRL_UART_RX_TIME_OUT_CHECK_ENABLE
;;;318    			// 停止RX通讯超时检测
;;;319    			IAP_CTRL_UART_StopRxTimeOutCheck();
;;;320    			#endif
;;;321    
;;;322    			// 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;323    			pCmdFrame->length = 0;	// 2016.1.5增加
000040  f8a580a0          STRH     r8,[r5,#0xa0]
;;;324    			// 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;325    			pCB->rxFIFO.head ++;
000044  f8340ffa          LDRH     r0,[r4,#0xfa]!
000048  1c40              ADDS     r0,r0,#1
00004a  8020              STRH     r0,[r4,#0]
;;;326    			pCB->rxFIFO.head %= IAP_CTRL_UART_RX_FIFO_SIZE;
00004c  8820              LDRH     r0,[r4,#0]
00004e  fbb0f1f7          UDIV     r1,r0,r7
000052  fb070011          MLS      r0,r7,r1,r0
000056  8020              STRH     r0,[r4,#0]
;;;327    			pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
000058  8820              LDRH     r0,[r4,#0]
00005a  80a0              STRH     r0,[r4,#4]
                  |L10.92|
;;;328    
;;;329    			return;
;;;330    		}
;;;331    
;;;332    		// 一直取到末尾
;;;333    		while(end != pCB->rxFIFO.currentProcessIndex)
;;;334    		{
;;;335    			// 取出当前要处理的字节
;;;336    			currentData = pCB->rxFIFO.buff[pCB->rxFIFO.currentProcessIndex];
;;;337    			// 缓冲区未溢出，正常接收，将数据添加到临时缓冲区中
;;;338    			pCmdFrame->buff[pCmdFrame->length++]= currentData;
;;;339    			pCB->rxFIFO.currentProcessIndex ++;
;;;340    			pCB->rxFIFO.currentProcessIndex %= IAP_CTRL_UART_RX_FIFO_SIZE;
;;;341    
;;;342    			// ■■接下来，需要检查命令帧是否完整，如果完整，则将命令帧临时缓冲区扶正■■
;;;343    			
;;;344    			// 首先判断命令帧最小长度，一个完整的命令字至少包括4个字节: 命令头 + 命令字 + 数据长度 + 校验码，因此不足4个字节的必定不完整
;;;345    			if(pCmdFrame->length < IAP_CTRL_UART_CMD_FRAME_LENGTH_MIN)
;;;346    			{
;;;347    				// 继续接收
;;;348    				continue;
;;;349    			}
;;;350    
;;;351    			// 命令帧长度数值越界，说明当前命令帧错误，停止接收
;;;352    			if(pCmdFrame->buff[IAP_CTRL_UART_CMD_LENGTH_INDEX] > IAP_CTRL_UART_CMD_LENGTH_MAX-IAP_CTRL_UART_CMD_FRAME_LENGTH_MIN)
;;;353    			{
;;;354    				#if IAP_CTRL_UART_RX_TIME_OUT_CHECK_ENABLE
;;;355    				// 停止RX通讯超时检测
;;;356    				IAP_CTRL_UART_StopRxTimeOutCheck();
;;;357    				#endif
;;;358    			
;;;359    				// 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;360    				pCmdFrame->length = 0;
;;;361    				// 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;362    				pCB->rxFIFO.head ++;
;;;363    				pCB->rxFIFO.head %= IAP_CTRL_UART_RX_FIFO_SIZE;
;;;364    				pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;365    
;;;366    				return;
;;;367    			}
;;;368    
;;;369    			// 命令帧长度校验，在命令长度描述字的数值上，增加命令头、命令字、数据长度、校验码，即为命令帧实际长度
;;;370    			length = pCmdFrame->length;
;;;371    			if(length < pCmdFrame->buff[IAP_CTRL_UART_CMD_LENGTH_INDEX] + IAP_CTRL_UART_CMD_FRAME_LENGTH_MIN)
;;;372    			{
;;;373    				// 长度要求不一致，说明未接收完毕，退出继续
;;;374    				continue;
;;;375    			}
;;;376    
;;;377    			// 命令帧长度OK，则进行校验，失败时删除命令头
;;;378    			if(!IAP_CTRL_UART_CheckSUM(pCmdFrame))
;;;379    			{
;;;380    				#if IAP_CTRL_UART_RX_TIME_OUT_CHECK_ENABLE
;;;381    				// 停止RX通讯超时检测
;;;382    				IAP_CTRL_UART_StopRxTimeOutCheck();
;;;383    				#endif
;;;384    				
;;;385    				// 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;386    				pCmdFrame->length = 0;
;;;387    				// 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;388    				pCB->rxFIFO.head ++;
;;;389    				pCB->rxFIFO.head %= IAP_CTRL_UART_RX_FIFO_SIZE;
;;;390    				pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;391    				
;;;392    				return;
;;;393    			}
;;;394    
;;;395    			#if IAP_CTRL_UART_RX_TIME_OUT_CHECK_ENABLE
;;;396    			// 停止RX通讯超时检测
;;;397    			IAP_CTRL_UART_StopRxTimeOutCheck();
;;;398    			#endif
;;;399    			
;;;400    			// 执行到这里，即说明接收到了一个完整并且正确的命令帧，此时需将处理过的数据从一级缓冲区中删除，并将该命令帧扶正
;;;401    			pCB->rxFIFO.head += length;		// head必须要用16位，否则这一行有时会溢出
;;;402    			pCB->rxFIFO.head %= IAP_CTRL_UART_RX_FIFO_SIZE;
;;;403    			pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;404    			IAP_CTRL_UART_ConfirmTempCmdFrameBuff(pCB);
;;;405    
;;;406    			return;
;;;407    		}
;;;408    	}
;;;409    }
00005c  e8bd81f0          POP      {r4-r8,pc}
                  |L10.96|
000060  2a55              CMP      r2,#0x55              ;286
000062  d00c              BEQ      |L10.126|
000064  f8340ffa          LDRH     r0,[r4,#0xfa]!        ;288
000068  1c40              ADDS     r0,r0,#1              ;288
00006a  8020              STRH     r0,[r4,#0]            ;288
00006c  8820              LDRH     r0,[r4,#0]            ;289
00006e  fbb0f1f7          UDIV     r1,r0,r7              ;289
000072  fb070011          MLS      r0,r7,r1,r0           ;289
000076  8020              STRH     r0,[r4,#0]            ;289
000078  8820              LDRH     r0,[r4,#0]            ;290
00007a  80a0              STRH     r0,[r4,#4]            ;290
00007c  e7ee              B        |L10.92|
                  |L10.126|
00007e  1c40              ADDS     r0,r0,#1              ;296
000080  2105              MOVS     r1,#5                 ;296
000082  fbb0f3f1          UDIV     r3,r0,r1              ;296
000086  fb010013          MLS      r0,r1,r3,r0           ;296
00008a  f8b4142a          LDRH     r1,[r4,#0x42a]        ;296
00008e  4288              CMP      r0,r1                 ;296
000090  d0e4              BEQ      |L10.92|
000092  2001              MOVS     r0,#1                 ;307
000094  f8a500a0          STRH     r0,[r5,#0xa0]         ;307
000098  702a              STRB     r2,[r5,#0]            ;307
00009a  f8340ffe          LDRH     r0,[r4,#0xfe]!        ;308
00009e  1c40              ADDS     r0,r0,#1              ;308
0000a0  b280              UXTH     r0,r0                 ;308
0000a2  fbb0f1f7          UDIV     r1,r0,r7              ;309
0000a6  fb070011          MLS      r0,r7,r1,r0           ;309
0000aa  8020              STRH     r0,[r4,#0]            ;309
0000ac  e7d6              B        |L10.92|
                  |L10.174|
0000ae  5c22              LDRB     r2,[r4,r0]            ;336
0000b0  f8b500a0          LDRH     r0,[r5,#0xa0]         ;338
0000b4  1c43              ADDS     r3,r0,#1              ;338
0000b6  f8a530a0          STRH     r3,[r5,#0xa0]         ;338
0000ba  542a              STRB     r2,[r5,r0]            ;338
0000bc  f8b400fe          LDRH     r0,[r4,#0xfe]         ;339
0000c0  1c40              ADDS     r0,r0,#1              ;339
0000c2  b280              UXTH     r0,r0                 ;339
0000c4  fbb0f2f7          UDIV     r2,r0,r7              ;340
0000c8  fb070012          MLS      r0,r7,r2,r0           ;340
0000cc  f8a400fe          STRH     r0,[r4,#0xfe]         ;340
0000d0  f8b560a0          LDRH     r6,[r5,#0xa0]         ;345
0000d4  2e04              CMP      r6,#4                 ;345
0000d6  d33b              BCC      |L10.336|
0000d8  78a8              LDRB     r0,[r5,#2]            ;352
0000da  289c              CMP      r0,#0x9c              ;352
0000dc  d90e              BLS      |L10.252|
0000de  f8a580a0          STRH     r8,[r5,#0xa0]         ;360
0000e2  f8340ffa          LDRH     r0,[r4,#0xfa]!        ;362
0000e6  1c40              ADDS     r0,r0,#1              ;362
0000e8  8020              STRH     r0,[r4,#0]            ;362
0000ea  8820              LDRH     r0,[r4,#0]            ;363
0000ec  fbb0f1f7          UDIV     r1,r0,r7              ;363
0000f0  fb070011          MLS      r0,r7,r1,r0           ;363
0000f4  8020              STRH     r0,[r4,#0]            ;363
0000f6  8820              LDRH     r0,[r4,#0]            ;364
0000f8  80a0              STRH     r0,[r4,#4]            ;364
0000fa  e7af              B        |L10.92|
                  |L10.252|
0000fc  1d00              ADDS     r0,r0,#4              ;371
0000fe  42b0              CMP      r0,r6                 ;371
000100  d826              BHI      |L10.336|
000102  4628              MOV      r0,r5                 ;378
000104  f7fffffe          BL       IAP_CTRL_UART_CheckSUM
000108  b188              CBZ      r0,|L10.302|
00010a  f8340ffa          LDRH     r0,[r4,#0xfa]!        ;401
00010e  4430              ADD      r0,r0,r6              ;401
000110  8020              STRH     r0,[r4,#0]            ;401
000112  8820              LDRH     r0,[r4,#0]            ;402
000114  fbb0f1f7          UDIV     r1,r0,r7              ;402
000118  fb070011          MLS      r0,r7,r1,r0           ;402
00011c  8020              STRH     r0,[r4,#0]            ;402
00011e  8820              LDRH     r0,[r4,#0]            ;403
000120  80a0              STRH     r0,[r4,#4]            ;403
000122  3cfa              SUBS     r4,r4,#0xfa           ;403
000124  4620              MOV      r0,r4                 ;404
000126  e8bd41f0          POP      {r4-r8,lr}            ;404
00012a  f7ffbffe          B.W      IAP_CTRL_UART_ConfirmTempCmdFrameBuff
                  |L10.302|
00012e  f8a580a0          STRH     r8,[r5,#0xa0]         ;386
000132  f8340ffa          LDRH     r0,[r4,#0xfa]!        ;388
000136  1c40              ADDS     r0,r0,#1              ;388
000138  8020              STRH     r0,[r4,#0]            ;388
00013a  e000              B        |L10.318|
                  |L10.316|
00013c  e008              B        |L10.336|
                  |L10.318|
00013e  8820              LDRH     r0,[r4,#0]            ;389
000140  fbb0f1f7          UDIV     r1,r0,r7              ;389
000144  fb070011          MLS      r0,r7,r1,r0           ;389
000148  8020              STRH     r0,[r4,#0]            ;389
00014a  8820              LDRH     r0,[r4,#0]            ;390
00014c  80a0              STRH     r0,[r4,#4]            ;390
00014e  e785              B        |L10.92|
                  |L10.336|
000150  f8b400fe          LDRH     r0,[r4,#0xfe]         ;333
000154  4288              CMP      r0,r1                 ;333
000156  d1aa              BNE      |L10.174|
000158  e780              B        |L10.92|
;;;410    
                          ENDP


                          AREA ||i.IAP_CTRL_UART_SendCmdCheckFlashBlankResult||, CODE, READONLY, ALIGN=2

                  IAP_CTRL_UART_SendCmdCheckFlashBlankResult PROC
;;;1081   // 查空结果上报
;;;1082   void IAP_CTRL_UART_SendCmdCheckFlashBlankResult(uint8 param)
000000  b510              PUSH     {r4,lr}
;;;1083   {
000002  4604              MOV      r4,r0
;;;1084   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_HEAD);
000004  2155              MOVS     r1,#0x55
000006  480a              LDR      r0,|L11.48|
000008  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1085   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_UP_CHECK_FLASH_BLANK_RESULT);
00000c  2129              MOVS     r1,#0x29
00000e  4808              LDR      r0,|L11.48|
000010  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1086   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, 1);		// 数据长度
000014  2101              MOVS     r1,#1
000016  4806              LDR      r0,|L11.48|
000018  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1087   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, param);
00001c  4621              MOV      r1,r4
00001e  4804              LDR      r0,|L11.48|
000020  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1088   	IAP_CTRL_UART_TxAddFrame(&iapCtrlUartCB);
000024  e8bd4010          POP      {r4,lr}
000028  4801              LDR      r0,|L11.48|
00002a  f7ffbffe          B.W      IAP_CTRL_UART_TxAddFrame
;;;1089   }
;;;1090   
                          ENDP

00002e  0000              DCW      0x0000
                  |L11.48|
                          DCD      ||.bss||+0xa0

                          AREA ||i.IAP_CTRL_UART_SendCmdEraseFlashResult||, CODE, READONLY, ALIGN=2

                  IAP_CTRL_UART_SendCmdEraseFlashResult PROC
;;;1061   // 擦除FLASH结果上报
;;;1062   void IAP_CTRL_UART_SendCmdEraseFlashResult(uint8 param)
000000  b510              PUSH     {r4,lr}
;;;1063   {
000002  4604              MOV      r4,r0
;;;1064   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_HEAD);
000004  2155              MOVS     r1,#0x55
000006  480a              LDR      r0,|L12.48|
000008  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1065   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_UP_IAP_ERASE_FLASH_RESULT);
00000c  2125              MOVS     r1,#0x25
00000e  4808              LDR      r0,|L12.48|
000010  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1066   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, 1);		// 数据长度
000014  2101              MOVS     r1,#1
000016  4806              LDR      r0,|L12.48|
000018  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1067   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, param);
00001c  4621              MOV      r1,r4
00001e  4804              LDR      r0,|L12.48|
000020  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1068   	IAP_CTRL_UART_TxAddFrame(&iapCtrlUartCB);
000024  e8bd4010          POP      {r4,lr}
000028  4801              LDR      r0,|L12.48|
00002a  f7ffbffe          B.W      IAP_CTRL_UART_TxAddFrame
;;;1069   }
;;;1070   
                          ENDP

00002e  0000              DCW      0x0000
                  |L12.48|
                          DCD      ||.bss||+0xa0

                          AREA ||i.IAP_CTRL_UART_SendCmdNoResult||, CODE, READONLY, ALIGN=2

                  IAP_CTRL_UART_SendCmdNoResult PROC
;;;1249   // 发送命令无结果
;;;1250   void IAP_CTRL_UART_SendCmdNoResult(uint8 cmdWord)
000000  b510              PUSH     {r4,lr}
;;;1251   {
000002  4604              MOV      r4,r0
;;;1252   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_HEAD);
000004  2155              MOVS     r1,#0x55
000006  4808              LDR      r0,|L13.40|
000008  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1253   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, cmdWord);
00000c  4621              MOV      r1,r4
00000e  4806              LDR      r0,|L13.40|
000010  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1254   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, 0);		// 数据长度
000014  2100              MOVS     r1,#0
000016  4804              LDR      r0,|L13.40|
000018  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1255   	IAP_CTRL_UART_TxAddFrame(&iapCtrlUartCB);
00001c  e8bd4010          POP      {r4,lr}
000020  4801              LDR      r0,|L13.40|
000022  f7ffbffe          B.W      IAP_CTRL_UART_TxAddFrame
;;;1256   }
;;;1257   
                          ENDP

000026  0000              DCW      0x0000
                  |L13.40|
                          DCD      ||.bss||+0xa0

                          AREA ||i.IAP_CTRL_UART_SendCmdProjectApply||, CODE, READONLY, ALIGN=2

                  IAP_CTRL_UART_SendCmdProjectApply PROC
;;;1032   // 工程模式启用
;;;1033   void IAP_CTRL_UART_SendCmdProjectApply(uint32 para)
000000  b570              PUSH     {r4-r6,lr}
;;;1034   {
000002  b088              SUB      sp,sp,#0x20
;;;1035   	uint8 param[] = IAP_VERSION;
000004  221c              MOVS     r2,#0x1c
000006  a112              ADR      r1,|L14.80|
000008  a801              ADD      r0,sp,#4
00000a  f7fffffe          BL       __aeabi_memcpy4
;;;1036   	uint8 len = strlen((char*)param);
00000e  a801              ADD      r0,sp,#4
000010  f7fffffe          BL       strlen
000014  b2c6              UXTB     r6,r0
;;;1037   	uint8 i;
;;;1038   	
;;;1039   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_HEAD);
000016  2155              MOVS     r1,#0x55
000018  4814              LDR      r0,|L14.108|
00001a  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1040   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_UP_PROJECT_APPLY);
00001e  2101              MOVS     r1,#1
000020  4812              LDR      r0,|L14.108|
000022  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1041   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, len);		// 数据长度
000026  4631              MOV      r1,r6
000028  4810              LDR      r0,|L14.108|
00002a  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1042   
;;;1043   	for (i = 0; i < len; i++)
00002e  2400              MOVS     r4,#0
000030  ad01              ADD      r5,sp,#4              ;1035
000032  e005              B        |L14.64|
                  |L14.52|
;;;1044   	{
;;;1045   		IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, param[i]);
000034  5d29              LDRB     r1,[r5,r4]
000036  480d              LDR      r0,|L14.108|
000038  f7fffffe          BL       IAP_CTRL_UART_TxAddData
00003c  1c64              ADDS     r4,r4,#1              ;1043
00003e  b2e4              UXTB     r4,r4                 ;1043
                  |L14.64|
000040  42b4              CMP      r4,r6                 ;1043
000042  d3f7              BCC      |L14.52|
;;;1046   	}
;;;1047   	
;;;1048   	IAP_CTRL_UART_TxAddFrame(&iapCtrlUartCB);
000044  4809              LDR      r0,|L14.108|
000046  f7fffffe          BL       IAP_CTRL_UART_TxAddFrame
;;;1049   }
00004a  b008              ADD      sp,sp,#0x20
00004c  bd70              POP      {r4-r6,pc}
;;;1050   
                          ENDP

00004e  0000              DCW      0x0000
                  |L14.80|
000050  425f434d          DCB      "B_CM_FW_BL_DT_BC182_V4.0.1",0
000054  5f46575f
000058  424c5f44
00005c  545f4243
000060  3138325f
000064  56342e30
000068  2e3100  
00006b  00                DCB      0
                  |L14.108|
                          DCD      ||.bss||+0xa0

                          AREA ||i.IAP_CTRL_UART_SendCmdProjectReady||, CODE, READONLY, ALIGN=2

                  IAP_CTRL_UART_SendCmdProjectReady PROC
;;;1051   // 工程模式准备就绪报告
;;;1052   void IAP_CTRL_UART_SendCmdProjectReady(uint8 param)
000000  b510              PUSH     {r4,lr}
;;;1053   {
000002  4604              MOV      r4,r0
;;;1054   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_HEAD);
000004  2155              MOVS     r1,#0x55
000006  480a              LDR      r0,|L15.48|
000008  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1055   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_UP_PROJECT_READY);
00000c  2103              MOVS     r1,#3
00000e  4808              LDR      r0,|L15.48|
000010  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1056   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, 1);		// 数据长度
000014  2101              MOVS     r1,#1
000016  4806              LDR      r0,|L15.48|
000018  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1057   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, param);
00001c  4621              MOV      r1,r4
00001e  4804              LDR      r0,|L15.48|
000020  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1058   	IAP_CTRL_UART_TxAddFrame(&iapCtrlUartCB);
000024  e8bd4010          POP      {r4,lr}
000028  4801              LDR      r0,|L15.48|
00002a  f7ffbffe          B.W      IAP_CTRL_UART_TxAddFrame
;;;1059   }
;;;1060   
                          ENDP

00002e  0000              DCW      0x0000
                  |L15.48|
                          DCD      ||.bss||+0xa0

                          AREA ||i.IAP_CTRL_UART_SendCmdQrRegParam||, CODE, READONLY, ALIGN=2

                  IAP_CTRL_UART_SendCmdQrRegParam PROC
;;;1120   // 二维码注册参数上报
;;;1121   void IAP_CTRL_UART_SendCmdQrRegParam(uint8 *param)
000000  b570              PUSH     {r4-r6,lr}
;;;1122   {
000002  4605              MOV      r5,r0
;;;1123   	uint8 len = strlen((char*)param);
000004  4628              MOV      r0,r5
000006  f7fffffe          BL       strlen
00000a  b2c6              UXTB     r6,r0
;;;1124   	uint8 i;
;;;1125   	
;;;1126   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_HEAD);
00000c  2155              MOVS     r1,#0x55
00000e  480d              LDR      r0,|L16.68|
000010  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1127   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_UP_QR_PARAM_REPORT);
000014  2141              MOVS     r1,#0x41
000016  480b              LDR      r0,|L16.68|
000018  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1128   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, len);		// 数据长度
00001c  4631              MOV      r1,r6
00001e  4809              LDR      r0,|L16.68|
000020  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1129   
;;;1130   	for (i = 0; i < len; i++)
000024  2400              MOVS     r4,#0
000026  e005              B        |L16.52|
                  |L16.40|
;;;1131   	{
;;;1132   		IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, param[i]);
000028  5d29              LDRB     r1,[r5,r4]
00002a  4806              LDR      r0,|L16.68|
00002c  f7fffffe          BL       IAP_CTRL_UART_TxAddData
000030  1c64              ADDS     r4,r4,#1              ;1130
000032  b2e4              UXTB     r4,r4                 ;1130
                  |L16.52|
000034  42b4              CMP      r4,r6                 ;1130
000036  d3f7              BCC      |L16.40|
;;;1133   	}
;;;1134   	
;;;1135   	IAP_CTRL_UART_TxAddFrame(&iapCtrlUartCB);
000038  e8bd4070          POP      {r4-r6,lr}
00003c  4801              LDR      r0,|L16.68|
00003e  f7ffbffe          B.W      IAP_CTRL_UART_TxAddFrame
;;;1136   }
;;;1137   
                          ENDP

000042  0000              DCW      0x0000
                  |L16.68|
                          DCD      ||.bss||+0xa0

                          AREA ||i.IAP_CTRL_UART_SendCmdQrWriteResultReport||, CODE, READONLY, ALIGN=2

                  IAP_CTRL_UART_SendCmdQrWriteResultReport PROC
;;;1138   // 发送写入二维码数据结果
;;;1139   void IAP_CTRL_UART_SendCmdQrWriteResultReport(uint8 param)
000000  b510              PUSH     {r4,lr}
;;;1140   {
000002  4604              MOV      r4,r0
;;;1141   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_HEAD);
000004  2155              MOVS     r1,#0x55
000006  480a              LDR      r0,|L17.48|
000008  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1142   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_UP_QR_DATA_WRITE_RESULT);
00000c  2143              MOVS     r1,#0x43
00000e  4808              LDR      r0,|L17.48|
000010  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1143   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, 1);		// 数据长度
000014  2101              MOVS     r1,#1
000016  4806              LDR      r0,|L17.48|
000018  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1144   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, param);
00001c  4621              MOV      r1,r4
00001e  4804              LDR      r0,|L17.48|
000020  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1145   	IAP_CTRL_UART_TxAddFrame(&iapCtrlUartCB);
000024  e8bd4010          POP      {r4,lr}
000028  4801              LDR      r0,|L17.48|
00002a  f7ffbffe          B.W      IAP_CTRL_UART_TxAddFrame
;;;1146   }
;;;1147   
                          ENDP

00002e  0000              DCW      0x0000
                  |L17.48|
                          DCD      ||.bss||+0xa0

                          AREA ||i.IAP_CTRL_UART_SendCmdUIEraseResultReport||, CODE, READONLY, ALIGN=2

                  IAP_CTRL_UART_SendCmdUIEraseResultReport PROC
;;;1100   // 发送UI数据擦除结果
;;;1101   void IAP_CTRL_UART_SendCmdUIEraseResultReport(uint8 param)
000000  b510              PUSH     {r4,lr}
;;;1102   {
000002  4604              MOV      r4,r0
;;;1103   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_HEAD);
000004  2155              MOVS     r1,#0x55
000006  480a              LDR      r0,|L18.48|
000008  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1104   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_UP_UI_DATA_ERASE_ACK);
00000c  2113              MOVS     r1,#0x13
00000e  4808              LDR      r0,|L18.48|
000010  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1105   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, 1);		// 数据长度
000014  2101              MOVS     r1,#1
000016  4806              LDR      r0,|L18.48|
000018  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1106   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, param);
00001c  4621              MOV      r1,r4
00001e  4804              LDR      r0,|L18.48|
000020  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1107   	IAP_CTRL_UART_TxAddFrame(&iapCtrlUartCB);
000024  e8bd4010          POP      {r4,lr}
000028  4801              LDR      r0,|L18.48|
00002a  f7ffbffe          B.W      IAP_CTRL_UART_TxAddFrame
;;;1108   }
;;;1109   
                          ENDP

00002e  0000              DCW      0x0000
                  |L18.48|
                          DCD      ||.bss||+0xa0

                          AREA ||i.IAP_CTRL_UART_SendCmdUIWriteDataResultReport||, CODE, READONLY, ALIGN=2

                  IAP_CTRL_UART_SendCmdUIWriteDataResultReport PROC
;;;1110   // 发送UI数据写入结果
;;;1111   void IAP_CTRL_UART_SendCmdUIWriteDataResultReport(uint8 param)
000000  b510              PUSH     {r4,lr}
;;;1112   {
000002  4604              MOV      r4,r0
;;;1113   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_HEAD);
000004  2155              MOVS     r1,#0x55
000006  480a              LDR      r0,|L19.48|
000008  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1114   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_UP_UI_DATA_WRITE_RESULT);
00000c  2115              MOVS     r1,#0x15
00000e  4808              LDR      r0,|L19.48|
000010  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1115   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, 1);		// 数据长度
000014  2101              MOVS     r1,#1
000016  4806              LDR      r0,|L19.48|
000018  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1116   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, param);
00001c  4621              MOV      r1,r4
00001e  4804              LDR      r0,|L19.48|
000020  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1117   	IAP_CTRL_UART_TxAddFrame(&iapCtrlUartCB);
000024  e8bd4010          POP      {r4,lr}
000028  4801              LDR      r0,|L19.48|
00002a  f7ffbffe          B.W      IAP_CTRL_UART_TxAddFrame
;;;1118   }
;;;1119   
                          ENDP

00002e  0000              DCW      0x0000
                  |L19.48|
                          DCD      ||.bss||+0xa0

                          AREA ||i.IAP_CTRL_UART_SendCmdUpdataFinishResult||, CODE, READONLY, ALIGN=2

                  IAP_CTRL_UART_SendCmdUpdataFinishResult PROC
;;;1091   // 系统升级结束确认
;;;1092   void IAP_CTRL_UART_SendCmdUpdataFinishResult(uint8 param)
000000  b500              PUSH     {lr}
;;;1093   {
;;;1094   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_HEAD);
000002  2155              MOVS     r1,#0x55
000004  4807              LDR      r0,|L20.36|
000006  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1095   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_UP_UPDATA_FINISH_RESULT);
00000a  212b              MOVS     r1,#0x2b
00000c  4805              LDR      r0,|L20.36|
00000e  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1096   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, 0);		// 数据长度
000012  2100              MOVS     r1,#0
000014  4803              LDR      r0,|L20.36|
000016  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1097   	IAP_CTRL_UART_TxAddFrame(&iapCtrlUartCB);
00001a  4802              LDR      r0,|L20.36|
00001c  f85deb04          POP      {lr}
000020  f7ffbffe          B.W      IAP_CTRL_UART_TxAddFrame
;;;1098   }
;;;1099   
                          ENDP

                  |L20.36|
                          DCD      ||.bss||+0xa0

                          AREA ||i.IAP_CTRL_UART_SendCmdWithResult||, CODE, READONLY, ALIGN=2

                  IAP_CTRL_UART_SendCmdWithResult PROC
;;;1239   // 发送命令带结果
;;;1240   void IAP_CTRL_UART_SendCmdWithResult(uint8 cmdWord, uint8 result)
000000  b530              PUSH     {r4,r5,lr}
;;;1241   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1242   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_HEAD);
000006  2155              MOVS     r1,#0x55
000008  4809              LDR      r0,|L21.48|
00000a  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1243   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, cmdWord);
00000e  4629              MOV      r1,r5
000010  4807              LDR      r0,|L21.48|
000012  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1244   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, 1);		// 数据长度
000016  2101              MOVS     r1,#1
000018  4805              LDR      r0,|L21.48|
00001a  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1245   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, result);
00001e  4621              MOV      r1,r4
000020  4803              LDR      r0,|L21.48|
000022  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1246   	IAP_CTRL_UART_TxAddFrame(&iapCtrlUartCB);
000026  e8bd4030          POP      {r4,r5,lr}
00002a  4801              LDR      r0,|L21.48|
00002c  f7ffbffe          B.W      IAP_CTRL_UART_TxAddFrame
;;;1247   }
;;;1248   
                          ENDP

                  |L21.48|
                          DCD      ||.bss||+0xa0

                          AREA ||i.IAP_CTRL_UART_SendCmdWriteFlashResult||, CODE, READONLY, ALIGN=2

                  IAP_CTRL_UART_SendCmdWriteFlashResult PROC
;;;1071   // IAP数据写入结果上报
;;;1072   void IAP_CTRL_UART_SendCmdWriteFlashResult(uint8 param)
000000  b510              PUSH     {r4,lr}
;;;1073   {
000002  4604              MOV      r4,r0
;;;1074   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_HEAD);
000004  2155              MOVS     r1,#0x55
000006  480a              LDR      r0,|L22.48|
000008  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1075   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_UP_IAP_WRITE_FLASH_RESULT);
00000c  2127              MOVS     r1,#0x27
00000e  4808              LDR      r0,|L22.48|
000010  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1076   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, 1);		// 数据长度
000014  2101              MOVS     r1,#1
000016  4806              LDR      r0,|L22.48|
000018  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1077   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, param);
00001c  4621              MOV      r1,r4
00001e  4804              LDR      r0,|L22.48|
000020  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1078   	IAP_CTRL_UART_TxAddFrame(&iapCtrlUartCB);
000024  e8bd4010          POP      {r4,lr}
000028  4801              LDR      r0,|L22.48|
00002a  f7ffbffe          B.W      IAP_CTRL_UART_TxAddFrame
;;;1079   }
;;;1080   
                          ENDP

00002e  0000              DCW      0x0000
                  |L22.48|
                          DCD      ||.bss||+0xa0

                          AREA ||i.IAP_CTRL_UART_SendFlagCheck||, CODE, READONLY, ALIGN=2

                  IAP_CTRL_UART_SendFlagCheck PROC
;;;1220   
;;;1221   void IAP_CTRL_UART_SendFlagCheck(uint32 checkNum)
000000  b530              PUSH     {r4,r5,lr}
;;;1222   {
;;;1223   	uint8 *buff;
;;;1224   	uint8 i;
;;;1225   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_HEAD);
000002  2155              MOVS     r1,#0x55
000004  480c              LDR      r0,|L23.56|
000006  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1226   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_FLAG_ARRAY);
00000a  2191              MOVS     r1,#0x91
00000c  480a              LDR      r0,|L23.56|
00000e  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1227   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, 0);				// 数据长度
000012  2100              MOVS     r1,#0
000014  4808              LDR      r0,|L23.56|
000016  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1228   
;;;1229   	buff = paramCB.runtime.flagArr;
00001a  4d08              LDR      r5,|L23.60|
;;;1230   	for (i = 0; i < 64; i++)
00001c  2400              MOVS     r4,#0
                  |L23.30|
;;;1231   	{
;;;1232   		IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, buff[i]);		// 版本字符内容
00001e  4806              LDR      r0,|L23.56|
000020  5d29              LDRB     r1,[r5,r4]
000022  f7fffffe          BL       IAP_CTRL_UART_TxAddData
000026  1c64              ADDS     r4,r4,#1              ;1230
000028  b2e4              UXTB     r4,r4                 ;1230
00002a  2c40              CMP      r4,#0x40              ;1230
00002c  d3f7              BCC      |L23.30|
;;;1233   	}
;;;1234   	
;;;1235   	IAP_CTRL_UART_TxAddFrame(&iapCtrlUartCB);
00002e  e8bd4030          POP      {r4,r5,lr}
000032  4801              LDR      r0,|L23.56|
000034  f7ffbffe          B.W      IAP_CTRL_UART_TxAddFrame
;;;1236   }
;;;1237   
                          ENDP

                  |L23.56|
                          DCD      ||.bss||+0xa0
                  |L23.60|
                          DCD      paramCB

                          AREA ||i.IAP_CTRL_UART_SendSpiFlashData||, CODE, READONLY, ALIGN=2

                  IAP_CTRL_UART_SendSpiFlashData PROC
;;;1258   // 读取数据上报
;;;1259   void IAP_CTRL_UART_SendSpiFlashData(uint32 ReadAddr, uint8 NumByteToRead)
000000  b570              PUSH     {r4-r6,lr}
;;;1260   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;1261   	uint16 i;
;;;1262   	uint8* pFlashBuff = NULL;				// 保存读取扇区的数据
;;;1263   
;;;1264   	pFlashBuff = (uint8 *)malloc(NumByteToRead);
000006  4630              MOV      r0,r6
000008  f7fffffe          BL       malloc
00000c  4605              MOV      r5,r0
;;;1265   	if (NULL == pFlashBuff)
00000e  0028              MOVS     r0,r5
000010  d038              BEQ      |L24.132|
;;;1266   	{
;;;1267   		return;
;;;1268   	}
;;;1269   	
;;;1270   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_HEAD);
000012  2155              MOVS     r1,#0x55
000014  481c              LDR      r0,|L24.136|
000016  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1271   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_SPI_FLASH_ABSOLUTE_READ);
00001a  2162              MOVS     r1,#0x62
00001c  481a              LDR      r0,|L24.136|
00001e  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1272   	
;;;1273   	// 发送数据长度，随意填写即可
;;;1274   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, (128+4));
000022  2184              MOVS     r1,#0x84
000024  4818              LDR      r0,|L24.136|
000026  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1275   
;;;1276   	// 发送读取的地址
;;;1277   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, ((ReadAddr & 0xFF000000) >> 24));
00002a  0e21              LSRS     r1,r4,#24
00002c  4816              LDR      r0,|L24.136|
00002e  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1278   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, ((ReadAddr & 0x00FF0000) >> 16));
000032  f3c44107          UBFX     r1,r4,#16,#8
000036  4814              LDR      r0,|L24.136|
000038  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1279   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, ((ReadAddr & 0x0000FF00) >> 8));
00003c  f3c42107          UBFX     r1,r4,#8,#8
000040  4811              LDR      r0,|L24.136|
000042  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1280   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, ((ReadAddr & 0x000000FF) >> 0));
000046  b2e1              UXTB     r1,r4
000048  480f              LDR      r0,|L24.136|
00004a  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1281   
;;;1282   	// 发送读取数据字节数
;;;1283   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, (NumByteToRead & 0xFF));
00004e  4631              MOV      r1,r6
000050  480d              LDR      r0,|L24.136|
000052  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1284   
;;;1285   	// 从外部spiflash读取数据
;;;1286   	SPI_FLASH_ReadArray(pFlashBuff, ReadAddr, NumByteToRead);
000056  4632              MOV      r2,r6
000058  4621              MOV      r1,r4
00005a  4628              MOV      r0,r5
00005c  f7fffffe          BL       SPI_FLASH_ReadArray
;;;1287   	// 填充数据到命令帧数据中
;;;1288   	for (i = 0; i < NumByteToRead; i++)
000060  2400              MOVS     r4,#0
000062  e005              B        |L24.112|
                  |L24.100|
;;;1289   	{
;;;1290   		IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, pFlashBuff[i]);
000064  5d29              LDRB     r1,[r5,r4]
000066  4808              LDR      r0,|L24.136|
000068  f7fffffe          BL       IAP_CTRL_UART_TxAddData
00006c  1c64              ADDS     r4,r4,#1              ;1288
00006e  b2a4              UXTH     r4,r4                 ;1288
                  |L24.112|
000070  42b4              CMP      r4,r6                 ;1288
000072  d3f7              BCC      |L24.100|
;;;1291   	}
;;;1292   	
;;;1293   	IAP_CTRL_UART_TxAddFrame(&iapCtrlUartCB);
000074  4804              LDR      r0,|L24.136|
000076  f7fffffe          BL       IAP_CTRL_UART_TxAddFrame
;;;1294   
;;;1295   	free(pFlashBuff);
00007a  4628              MOV      r0,r5
00007c  e8bd4070          POP      {r4-r6,lr}
000080  f7ffbffe          B.W      free
                  |L24.132|
;;;1296   }
000084  bd70              POP      {r4-r6,pc}
;;;1297   
                          ENDP

000086  0000              DCW      0x0000
                  |L24.136|
                          DCD      ||.bss||+0xa0

                          AREA ||i.IAP_CTRL_UART_SendVersionCheck||, CODE, READONLY, ALIGN=2

                  IAP_CTRL_UART_SendVersionCheck PROC
;;;1149   // 发送指定核对的版本
;;;1150   void IAP_CTRL_UART_SendVersionCheck(uint32 checkNum)
000000  b530              PUSH     {r4,r5,lr}
;;;1151   {
000002  4605              MOV      r5,r0
;;;1152   	uint8 *buff;
;;;1153   	uint8 i;
;;;1154   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_HEAD);
000004  2155              MOVS     r1,#0x55
000006  4824              LDR      r0,|L25.152|
000008  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1155   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_CHECK_VERSION);
00000c  2190              MOVS     r1,#0x90
00000e  4822              LDR      r0,|L25.152|
000010  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1156   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, 0);				// 数据长度
000014  2100              MOVS     r1,#0
000016  4820              LDR      r0,|L25.152|
000018  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1157   
;;;1158   	// 根据版本号，选择发送的版本
;;;1159   	switch ((IAP_CTRL_UART_CHECK_VERSION_E)checkNum)
00001c  b2e8              UXTB     r0,r5
00001e  2808              CMP      r0,#8
000020  d219              BCS      |L25.86|
000022  e8dff000          TBB      [pc,r0]
000026  1804              DCB      0x18,0x04
000028  06090c0f          DCB      0x06,0x09,0x0c,0x0f
00002c  1215              DCB      0x12,0x15
;;;1160   	{
;;;1161   		// APP
;;;1162   		case IAP_CTRL_UART_CHECK_VERSION_APP:
;;;1163   			buff = paramCB.runtime.appVersion;
00002e  4c1b              LDR      r4,|L25.156|
;;;1164   			break;
000030  e012              B        |L25.88|
;;;1165   
;;;1166   		// BOOT
;;;1167   		case IAP_CTRL_UART_CHECK_VERSION_BOOT:
;;;1168   			buff = paramCB.runtime.bootVersion;
000032  4c1a              LDR      r4,|L25.156|
000034  3420              ADDS     r4,r4,#0x20
;;;1169   			break;
000036  e00f              B        |L25.88|
;;;1170   
;;;1171   		// UI
;;;1172   		case IAP_CTRL_UART_CHECK_VERSION_UI:
;;;1173   			buff = paramCB.runtime.uiVersion;
000038  4c18              LDR      r4,|L25.156|
00003a  3440              ADDS     r4,r4,#0x40
;;;1174   			break;
00003c  e00c              B        |L25.88|
;;;1175   			
;;;1176   		// 硬件版本
;;;1177   		case IAP_CTRL_UART_CHECK_VERSION_HW:
;;;1178   			buff = paramCB.runtime.hardVersion;
00003e  4c17              LDR      r4,|L25.156|
000040  34a0              ADDS     r4,r4,#0xa0
;;;1179   			break;
000042  e009              B        |L25.88|
;;;1180   			
;;;1181   		// SN版本
;;;1182   		case IAP_CTRL_UART_CHECK_VERSION_SN_NUM:
;;;1183   			buff = paramCB.runtime.snCode;
000044  4c15              LDR      r4,|L25.156|
000046  34c0              ADDS     r4,r4,#0xc0
;;;1184   			break;
000048  e006              B        |L25.88|
;;;1185   			
;;;1186   		// 蓝牙MAC
;;;1187   		case IAP_CTRL_UART_CHECK_VERSION_BLE_MAC:
;;;1188   			buff = paramCB.runtime.bluMac;
00004a  4c14              LDR      r4,|L25.156|
00004c  34e0              ADDS     r4,r4,#0xe0
;;;1189   			break;
00004e  e003              B        |L25.88|
;;;1190   			
;;;1191   		// 二维码字符
;;;1192   		case IAP_CTRL_UART_CHECK_VERSION_QR_CODE:
;;;1193   			buff = paramCB.runtime.qrCodeStr;
000050  4c12              LDR      r4,|L25.156|
000052  3460              ADDS     r4,r4,#0x60
;;;1194   			break;
000054  e000              B        |L25.88|
                  |L25.86|
;;;1195   
;;;1196   		default:
;;;1197   			buff = NULL;
000056  2400              MOVS     r4,#0
                  |L25.88|
;;;1198   			break;
;;;1199   	
;;;1200   	}
;;;1201   
;;;1202   	// 判断指针是否合法
;;;1203   	if (NULL == buff)
000058  b14c              CBZ      r4,|L25.110|
;;;1204   	{
;;;1205   		IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, checkNum & 0xFF);		// 比对号
;;;1206   	}
;;;1207   	else
;;;1208   	{		
;;;1209   		IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, checkNum & 0xFF);		// 比对号
00005a  b2e9              UXTB     r1,r5
00005c  480e              LDR      r0,|L25.152|
00005e  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1210   		IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, buff[0]);		// 版本长度
000062  7821              LDRB     r1,[r4,#0]
000064  480c              LDR      r0,|L25.152|
000066  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1211   
;;;1212   		for (i = 0; i < buff[0]; i++)
00006a  2500              MOVS     r5,#0
00006c  e00b              B        |L25.134|
                  |L25.110|
00006e  b2e9              UXTB     r1,r5                 ;1205
000070  4809              LDR      r0,|L25.152|
000072  f7fffffe          BL       IAP_CTRL_UART_TxAddData
000076  e009              B        |L25.140|
                  |L25.120|
;;;1213   		{
;;;1214   			IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, buff[1 + i]);		// 版本字符内容
000078  1960              ADDS     r0,r4,r5
00007a  7841              LDRB     r1,[r0,#1]
00007c  4806              LDR      r0,|L25.152|
00007e  f7fffffe          BL       IAP_CTRL_UART_TxAddData
000082  1c6d              ADDS     r5,r5,#1              ;1212
000084  b2ed              UXTB     r5,r5                 ;1212
                  |L25.134|
000086  7820              LDRB     r0,[r4,#0]            ;1212
000088  42a8              CMP      r0,r5                 ;1212
00008a  d8f5              BHI      |L25.120|
                  |L25.140|
;;;1215   		}
;;;1216   	}
;;;1217   	
;;;1218   	IAP_CTRL_UART_TxAddFrame(&iapCtrlUartCB);
00008c  e8bd4030          POP      {r4,r5,lr}
000090  4801              LDR      r0,|L25.152|
000092  f7ffbffe          B.W      IAP_CTRL_UART_TxAddFrame
;;;1219   }
;;;1220   
                          ENDP

000096  0000              DCW      0x0000
                  |L25.152|
                          DCD      ||.bss||+0xa0
                  |L25.156|
                          DCD      paramCB+0x40

                          AREA ||i.IAP_CTRL_UART_TxAddData||, CODE, READONLY, ALIGN=1

                  IAP_CTRL_UART_TxAddData PROC
;;;736    // 向发送命令帧队列中添加数据
;;;737    void IAP_CTRL_UART_TxAddData(IAP_CTRL_UART_CB* pCB, uint8 data)
000000  b530              PUSH     {r4,r5,lr}
;;;738    {
;;;739    	IAP_CTRL_CMD_FRAME* pCmdFrame = &pCB->tx.cmdQueue[pCB->tx.end];
000002  f8b0275a          LDRH     r2,[r0,#0x75a]
000006  eb021302          ADD      r3,r2,r2,LSL #4
00000a  eb031282          ADD      r2,r3,r2,LSL #6
00000e  eb000242          ADD      r2,r0,r2,LSL #1
000012  f202422e          ADD      r2,r2,#0x42e
;;;740    	uint16 head = pCB->tx.head;
000016  f8b04758          LDRH     r4,[r0,#0x758]
;;;741    	uint16 end =  pCB->tx.end;	// 2015.12.29
00001a  f8b0375a          LDRH     r3,[r0,#0x75a]
;;;742    
;;;743    	// 参数合法性检验
;;;744    	if(NULL == pCB)
00001e  2800              CMP      r0,#0
000020  d010              BEQ      |L26.68|
;;;745    	{
;;;746    		return;
;;;747    	}
;;;748    
;;;749    	// 发送缓冲区已满，不予接收
;;;750    	if((end + 1) % IAP_CTRL_UART_TX_QUEUE_SIZE == head)
000022  1c5b              ADDS     r3,r3,#1
000024  2005              MOVS     r0,#5
000026  fbb3f5f0          UDIV     r5,r3,r0
00002a  fb003015          MLS      r0,r0,r5,r3
00002e  42a0              CMP      r0,r4
000030  d008              BEQ      |L26.68|
;;;751    	{
;;;752    		return;
;;;753    	}
;;;754    	
;;;755    	// 队尾命令帧已满，退出
;;;756    	if(pCmdFrame->length >= IAP_CTRL_UART_CMD_LENGTH_MAX)
000032  f8b200a0          LDRH     r0,[r2,#0xa0]
000036  28a0              CMP      r0,#0xa0
000038  d204              BCS      |L26.68|
;;;757    	{
;;;758    		return;
;;;759    	}
;;;760    
;;;761    	// 数据添加到帧末尾，并更新帧长度
;;;762    	pCmdFrame->buff[pCmdFrame->length] = data;
00003a  5411              STRB     r1,[r2,r0]
;;;763    	pCmdFrame->length ++;
00003c  f8320fa0          LDRH     r0,[r2,#0xa0]!
000040  1c40              ADDS     r0,r0,#1
000042  8010              STRH     r0,[r2,#0]
                  |L26.68|
;;;764    }
000044  bd30              POP      {r4,r5,pc}
;;;765    
                          ENDP


                          AREA ||i.IAP_CTRL_UART_TxAddFrame||, CODE, READONLY, ALIGN=1

                  IAP_CTRL_UART_TxAddFrame PROC
;;;766    // 确认添加命令帧，即承认之前填充的数据为命令帧，将其添加到发送队列中，由main进行调度发送，本函数内会自动校正命令长度，并添加校验码
;;;767    void IAP_CTRL_UART_TxAddFrame(IAP_CTRL_UART_CB* pCB)
000000  b5f0              PUSH     {r4-r7,lr}
;;;768    {
;;;769    	uint8 cc = 0;
000002  2400              MOVS     r4,#0
;;;770    	uint16 i = 0;
000004  2200              MOVS     r2,#0
;;;771    	IAP_CTRL_CMD_FRAME* pCmdFrame = &pCB->tx.cmdQueue[pCB->tx.end];
000006  f8b0175a          LDRH     r1,[r0,#0x75a]
00000a  eb011301          ADD      r3,r1,r1,LSL #4
00000e  eb031181          ADD      r1,r3,r1,LSL #6
000012  eb000141          ADD      r1,r0,r1,LSL #1
000016  f201412e          ADD      r1,r1,#0x42e
;;;772    	uint16 length = pCmdFrame->length;
00001a  f8b130a0          LDRH     r3,[r1,#0xa0]
;;;773    	uint16 head = pCB->tx.head;
00001e  f8b07758          LDRH     r7,[r0,#0x758]
;;;774    	uint16 end =  pCB->tx.end;	// 2015.12.29
000022  f8b0575a          LDRH     r5,[r0,#0x75a]
;;;775    
;;;776    	// 参数合法性检验
;;;777    	if(NULL == pCB)
000026  2800              CMP      r0,#0
000028  d00c              BEQ      |L27.68|
;;;778    	{
;;;779    		return;
;;;780    	}
;;;781    
;;;782    	// 发送缓冲区已满，不予接收
;;;783    	if((end + 1) % IAP_CTRL_UART_TX_QUEUE_SIZE == head)
00002a  1c6d              ADDS     r5,r5,#1
00002c  2605              MOVS     r6,#5
00002e  fbb5fcf6          UDIV     r12,r5,r6
000032  fb06551c          MLS      r5,r6,r12,r5
000036  42bd              CMP      r5,r7
000038  d004              BEQ      |L27.68|
;;;784    	{
;;;785    		return;
;;;786    	}
;;;787    	
;;;788    	// 命令帧长度不足，清除已填充的数据，退出
;;;789    	if(IAP_CTRL_UART_CMD_FRAME_LENGTH_MIN-1 > length)//2016.1.5修改减1
00003a  2b03              CMP      r3,#3
00003c  d203              BCS      |L27.70|
;;;790    	{
;;;791    		pCmdFrame->length = 0;
00003e  2000              MOVS     r0,#0
000040  f8a100a0          STRH     r0,[r1,#0xa0]
                  |L27.68|
;;;792    		
;;;793    		return;
;;;794    	}
;;;795    
;;;796    	// 重新设置数据长度，系统在准备数据时，填充的"数据长度"可以为任意值，并且不需要添加校验码，在这里重新设置为正确的值
;;;797    	pCmdFrame->buff[IAP_CTRL_UART_CMD_LENGTH_INDEX] = length - 3;	// 重设数据长度
;;;798    	for(i=0; i<length; i++)
;;;799    	{
;;;800    		cc ^= pCmdFrame->buff[i];
;;;801    	}
;;;802    	pCmdFrame->buff[length] = ~cc;
;;;803    	pCmdFrame->length ++;
;;;804    
;;;805    	pCB->tx.end ++;
;;;806    	pCB->tx.end %= IAP_CTRL_UART_TX_QUEUE_SIZE;
;;;807    	//pCB->tx.cmdQueue[pCB->tx.end].length = 0;   //2015.12.2修改
;;;808    
;;;809    	// 阻塞方式时启动发送
;;;810    #if (IAP_CTRL_UART_TX_MODE == IAP_CTRL_BLOCKING_TX_MODE)
;;;811    	IAP_CTRL_UART_BC_StartTx(pCB);
;;;812    #endif
;;;813    
;;;814    }
000044  bdf0              POP      {r4-r7,pc}
                  |L27.70|
000046  1edd              SUBS     r5,r3,#3              ;797
000048  708d              STRB     r5,[r1,#2]            ;797
00004a  e003              B        |L27.84|
                  |L27.76|
00004c  5c8d              LDRB     r5,[r1,r2]            ;800
00004e  406c              EORS     r4,r4,r5              ;800
000050  1c52              ADDS     r2,r2,#1              ;798
000052  b292              UXTH     r2,r2                 ;798
                  |L27.84|
000054  429a              CMP      r2,r3                 ;798
000056  d3f9              BCC      |L27.76|
000058  43e2              MVNS     r2,r4                 ;802
00005a  54ca              STRB     r2,[r1,r3]            ;802
00005c  f8312fa0          LDRH     r2,[r1,#0xa0]!        ;803
000060  1c52              ADDS     r2,r2,#1              ;803
000062  800a              STRH     r2,[r1,#0]            ;803
000064  f200705a          ADD      r0,r0,#0x75a          ;805
000068  8801              LDRH     r1,[r0,#0]            ;805
00006a  1c49              ADDS     r1,r1,#1              ;805
00006c  8001              STRH     r1,[r0,#0]            ;805
00006e  8801              LDRH     r1,[r0,#0]            ;806
000070  fbb1f2f6          UDIV     r2,r1,r6              ;806
000074  fb061112          MLS      r1,r6,r2,r1           ;806
000078  8001              STRH     r1,[r0,#0]            ;806
00007a  bdf0              POP      {r4-r7,pc}
;;;815    
                          ENDP


                          AREA ||i.IAP_CTRL_UART_TxProcess||, CODE, READONLY, ALIGN=1

                  IAP_CTRL_UART_TxProcess PROC
;;;983    // 发送处理,发现发送缓冲区非空时,启动中断发送
;;;984    void IAP_CTRL_UART_TxProcess(IAP_CTRL_UART_CB* pCB)
000000  b510              PUSH     {r4,lr}
;;;985    {
000002  4604              MOV      r4,r0
;;;986    	uint16 index = pCB->tx.index;							// 当前发送数据的索引号
000004  f8b4175c          LDRH     r1,[r4,#0x75c]
;;;987    	uint16 length = pCB->tx.cmdQueue[pCB->tx.head].length;	// 当前发送的命令帧的长度
000008  f8b40758          LDRH     r0,[r4,#0x758]
00000c  eb001200          ADD      r2,r0,r0,LSL #4
000010  eb021080          ADD      r0,r2,r0,LSL #6
000014  eb040040          ADD      r0,r4,r0,LSL #1
000018  f8b024ce          LDRH     r2,[r0,#0x4ce]
;;;988    	uint16 head = pCB->tx.head;								// 发送命令帧队列头索引号
00001c  f8b40758          LDRH     r0,[r4,#0x758]
;;;989    	uint16 end = pCB->tx.end;								// 发送命令帧队列尾索引号
000020  f8b4375a          LDRH     r3,[r4,#0x75a]
;;;990    
;;;991    	// 参数合法性检验
;;;992    	if(NULL == pCB)
000024  2c00              CMP      r4,#0
000026  d01a              BEQ      |L28.94|
;;;993    	{
;;;994    		return;
;;;995    	}
;;;996    	
;;;997    	// 队列为空，不处理
;;;998    	if(head == end)
000028  4298              CMP      r0,r3
00002a  d018              BEQ      |L28.94|
;;;999    	{
;;;1000   		return;
;;;1001   	}
;;;1002   
;;;1003   	// ■■执行到这里，说明队列非空■■
;;;1004   	
;;;1005   	// 当前命令帧未发送完时，取出一个字节放到发送寄存器中
;;;1006   	if(index < length)
00002c  4291              CMP      r1,r2
00002e  d216              BCS      |L28.94|
;;;1007   	{
;;;1008   		// 发送忙，退出
;;;1009   		if(pCB->tx.txBusy)
000030  f894175e          LDRB     r1,[r4,#0x75e]
000034  2900              CMP      r1,#0
000036  d112              BNE      |L28.94|
;;;1010   		{
;;;1011   			return;
;;;1012   		}
;;;1013   		
;;;1014   		IAP_CTRL_UART_IR_StartSendData(pCB->tx.cmdQueue[head].buff[pCB->tx.index++]);
000038  f8b4175c          LDRH     r1,[r4,#0x75c]
00003c  1c4a              ADDS     r2,r1,#1
00003e  f8a4275c          STRH     r2,[r4,#0x75c]
000042  eb001200          ADD      r2,r0,r0,LSL #4
000046  eb021080          ADD      r0,r2,r0,LSL #6
00004a  eb040040          ADD      r0,r4,r0,LSL #1
00004e  4408              ADD      r0,r0,r1
000050  f890042e          LDRB     r0,[r0,#0x42e]
000054  f7fffffe          BL       IAP_CTRL_UART_IR_StartSendData
;;;1015   		
;;;1016   		// 设置发送忙状态
;;;1017   		pCB->tx.txBusy = TRUE;
000058  2001              MOVS     r0,#1
00005a  f884075e          STRB     r0,[r4,#0x75e]
                  |L28.94|
;;;1018   
;;;1019   	}
;;;1020   	// 当前命令帧发送完时，删除之
;;;1021   	else
;;;1022   	{
;;;1023   	//	pCB->tx.head ++;
;;;1024   	//	pCB->tx.head %= IAP_CTRL_UART_TX_QUEUE_SIZE;
;;;1025   	//	pCB->tx.index = 0;
;;;1026   	}
;;;1027   }
00005e  bd10              POP      {r4,pc}
;;;1028   
                          ENDP


                          AREA ||i.UART3_IRQHandler||, CODE, READONLY, ALIGN=2

                  UART3_IRQHandler PROC
;;;839    *************************************************************/
;;;840    void UART3_IRQHandler(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;841    {
;;;842    	// 判断DR是否有数据，中断接收
;;;843    	if(usart_interrupt_flag_get(IAP_CTRL_UART_TYPE_DEF, USART_INT_FLAG_RBNE) != RESET) 	 
000004  4e43              LDR      r6,|L29.276|
000006  4942              LDR      r1,|L29.272|
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       usart_interrupt_flag_get
;;;844    	{
;;;845    		uint16 end = iapCtrlUartCB.rxFIFO.end;
00000e  4c42              LDR      r4,|L29.280|
000010  b1d8              CBZ      r0,|L29.74|
000012  f8b450fc          LDRH     r5,[r4,#0xfc]  ; iapCtrlUartCB
;;;846    		uint16 head = iapCtrlUartCB.rxFIFO.head;
000016  f8b470fa          LDRH     r7,[r4,#0xfa]  ; iapCtrlUartCB
;;;847    		uint8 rxdata = 0x00;
;;;848    		
;;;849    		// 接收数据
;;;850    		rxdata = (uint8)usart_data_receive(IAP_CTRL_UART_TYPE_DEF);
00001a  4630              MOV      r0,r6
00001c  f7fffffe          BL       usart_data_receive
000020  b2c0              UXTB     r0,r0
;;;851    
;;;852    		// 一级缓冲区已满，不予接收
;;;853    		if((end + 1)%IAP_CTRL_UART_RX_FIFO_SIZE == head)
000022  1c69              ADDS     r1,r5,#1
000024  22fa              MOVS     r2,#0xfa
000026  fbb1f3f2          UDIV     r3,r1,r2
00002a  fb021113          MLS      r1,r2,r3,r1
00002e  42b9              CMP      r1,r7
000030  d06b              BEQ      |L29.266|
;;;854    		{
;;;855    			return;
;;;856    		}
;;;857    		// 一级缓冲区未满，接收 
;;;858    		else
;;;859    		{
;;;860    			// 将接收到的数据放到临时缓冲区中
;;;861    			iapCtrlUartCB.rxFIFO.buff[end] = rxdata;
000032  5560              STRB     r0,[r4,r5]
;;;862    			iapCtrlUartCB.rxFIFO.end ++;
000034  f8340ffc          LDRH     r0,[r4,#0xfc]!  ; iapCtrlUartCB
000038  1c40              ADDS     r0,r0,#1
00003a  8020              STRH     r0,[r4,#0]
;;;863    			iapCtrlUartCB.rxFIFO.end %= IAP_CTRL_UART_RX_FIFO_SIZE;
00003c  8821              LDRH     r1,[r4,#0]  ; iapCtrlUartCB
00003e  fbb1f0f2          UDIV     r0,r1,r2
000042  fb021010          MLS      r0,r2,r0,r1
000046  f82409fc          STRH     r0,[r4],#-0xfc
                  |L29.74|
;;;864    		}	
;;;865    
;;;866    	}
;;;867    
;;;868    // 中断模式发送
;;;869    #if (IAP_CTRL_UART_TX_MODE == IAP_CTRL_INTERRUPT_TX_MODE)
;;;870    	// 判断DR是否有数据，中断发送
;;;871    	if(usart_interrupt_flag_get(IAP_CTRL_UART_TYPE_DEF, USART_INT_FLAG_TC) != RESET)
00004a  4635              MOV      r5,r6
00004c  4933              LDR      r1,|L29.284|
00004e  4628              MOV      r0,r5
000050  f7fffffe          BL       usart_interrupt_flag_get
000054  b3f0              CBZ      r0,|L29.212|
;;;872    	{
;;;873    		uint16 head = iapCtrlUartCB.tx.head;
000056  f8b41758          LDRH     r1,[r4,#0x758]  ; iapCtrlUartCB
;;;874    		uint16 end;
;;;875    		uint16 index = iapCtrlUartCB.tx.index;
00005a  f8b4075c          LDRH     r0,[r4,#0x75c]  ; iapCtrlUartCB
;;;876    		uint8 txdata = 0x00;
;;;877    
;;;878    		// 执行到这里，说明上一个数据已经发送完毕，当前命令帧未发送完时，取出一个字节放到发送寄存器中
;;;879    		if(index < iapCtrlUartCB.tx.cmdQueue[head].length)
00005e  eb011201          ADD      r2,r1,r1,LSL #4
000062  eb021181          ADD      r1,r2,r1,LSL #6
000066  eb040241          ADD      r2,r4,r1,LSL #1
00006a  f8b214ce          LDRH     r1,[r2,#0x4ce]
00006e  4281              CMP      r1,r0
000070  d90b              BLS      |L29.138|
;;;880    		{
;;;881    			txdata = iapCtrlUartCB.tx.cmdQueue[head].buff[iapCtrlUartCB.tx.index++];
000072  f8b4175c          LDRH     r1,[r4,#0x75c]  ; iapCtrlUartCB
000076  1c48              ADDS     r0,r1,#1
000078  f8a4075c          STRH     r0,[r4,#0x75c]
00007c  1888              ADDS     r0,r1,r2
00007e  f890142e          LDRB     r1,[r0,#0x42e]
;;;882    			
;;;883    			// 填充数据
;;;884    			usart_data_transmit(IAP_CTRL_UART_TYPE_DEF, txdata);
000082  4628              MOV      r0,r5
000084  f7fffffe          BL       usart_data_transmit
000088  e030              B        |L29.236|
                  |L29.138|
;;;885    		}
;;;886    		// 当前命令帧发送完时，删除之
;;;887    		else
;;;888    		{
;;;889    			iapCtrlUartCB.tx.cmdQueue[head].length = 0;
00008a  2600              MOVS     r6,#0
00008c  f8a264ce          STRH     r6,[r2,#0x4ce]
;;;890    			iapCtrlUartCB.tx.head ++;
000090  f50464eb          ADD      r4,r4,#0x758
000094  8820              LDRH     r0,[r4,#0]  ; iapCtrlUartCB
000096  1c40              ADDS     r0,r0,#1
000098  8020              STRH     r0,[r4,#0]
;;;891    			iapCtrlUartCB.tx.head %= IAP_CTRL_UART_TX_QUEUE_SIZE;
00009a  8820              LDRH     r0,[r4,#0]  ; iapCtrlUartCB
00009c  2105              MOVS     r1,#5
00009e  fbb0f2f1          UDIV     r2,r0,r1
0000a2  fb010012          MLS      r0,r1,r2,r0
0000a6  8020              STRH     r0,[r4,#0]
;;;892    			iapCtrlUartCB.tx.index = 0;
0000a8  80a6              STRH     r6,[r4,#4]
;;;893    
;;;894    			head = iapCtrlUartCB.tx.head;
0000aa  8821              LDRH     r1,[r4,#0]  ; iapCtrlUartCB
;;;895    			end = iapCtrlUartCB.tx.end;
0000ac  8860              LDRH     r0,[r4,#2]  ; iapCtrlUartCB
0000ae  f5a464eb          SUB      r4,r4,#0x758
;;;896    			
;;;897    			// 命令帧队列非空，继续发送下一个命令帧
;;;898    			if(head != end)
0000b2  4281              CMP      r1,r0
0000b4  d013              BEQ      |L29.222|
;;;899    			{
;;;900    				txdata = iapCtrlUartCB.tx.cmdQueue[head].buff[iapCtrlUartCB.tx.index++];
0000b6  f8b4275c          LDRH     r2,[r4,#0x75c]  ; iapCtrlUartCB
0000ba  1c50              ADDS     r0,r2,#1
0000bc  f8a4075c          STRH     r0,[r4,#0x75c]
0000c0  eb011001          ADD      r0,r1,r1,LSL #4
0000c4  eb001081          ADD      r0,r0,r1,LSL #6
0000c8  eb040040          ADD      r0,r4,r0,LSL #1
0000cc  4410              ADD      r0,r0,r2
0000ce  f890142e          LDRB     r1,[r0,#0x42e]
;;;901    
;;;902    				// 填充数据
;;;903    				usart_data_transmit(IAP_CTRL_UART_TYPE_DEF, txdata);
0000d2  e000              B        |L29.214|
                  |L29.212|
0000d4  e00a              B        |L29.236|
                  |L29.214|
0000d6  4628              MOV      r0,r5
0000d8  f7fffffe          BL       usart_data_transmit
0000dc  e006              B        |L29.236|
                  |L29.222|
;;;904    			}
;;;905    			// 命令帧队列为空停止发送，设置空闲
;;;906    			else
;;;907    			{
;;;908    				// 关闭发送空中断
;;;909    				usart_interrupt_disable(IAP_CTRL_UART_TYPE_DEF, USART_INT_TC);
0000de  f2403106          MOV      r1,#0x306
0000e2  4628              MOV      r0,r5
0000e4  f7fffffe          BL       usart_interrupt_disable
;;;910    				
;;;911    				iapCtrlUartCB.tx.txBusy = FALSE;				
0000e8  f884675e          STRB     r6,[r4,#0x75e]
                  |L29.236|
;;;912    			}
;;;913    		}		
;;;914    	}
;;;915    #endif
;;;916    
;;;917    	// Other USARTx interrupts handler can go here ...				 
;;;918    	if(usart_interrupt_flag_get(IAP_CTRL_UART_TYPE_DEF, USART_INT_FLAG_ERR_ORERR) != RESET) //----------------------- 接收溢出中断 	
0000ec  490c              LDR      r1,|L29.288|
0000ee  4628              MOV      r0,r5
0000f0  f7fffffe          BL       usart_interrupt_flag_get
0000f4  2800              CMP      r0,#0
0000f6  d008              BEQ      |L29.266|
;;;919    	{
;;;920    		// 用户手册 434  --- 软件先读USART_STAT0，再读USART_DATA可清除该位
;;;921    		usart_flag_get(IAP_CTRL_UART_TYPE_DEF, USART_FLAG_ORERR);		
0000f8  2103              MOVS     r1,#3
0000fa  4628              MOV      r0,r5
0000fc  f7fffffe          BL       usart_flag_get
;;;922    		usart_data_receive(IAP_CTRL_UART_TYPE_DEF);						  //----------------------- 清空寄存器
000100  4628              MOV      r0,r5
000102  e8bd41f0          POP      {r4-r8,lr}
000106  f7ffbffe          B.W      usart_data_receive
                  |L29.266|
;;;923    	}
;;;924    }
00010a  e8bd81f0          POP      {r4-r8,pc}
;;;925    
                          ENDP

00010e  0000              DCW      0x0000
                  |L29.272|
                          DCD      0x00050305
                  |L29.276|
                          DCD      0x40004c00
                  |L29.280|
                          DCD      ||.bss||+0xa0
                  |L29.284|
                          DCD      0x00060306
                  |L29.288|
                          DCD      0x00030500

                          AREA ||i.UART_PROTOCOL_SendMcuUid||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL_SendMcuUid PROC
;;;1336   // 发送自身MCU的唯一序列号，防止误入老化
;;;1337   void UART_PROTOCOL_SendMcuUid(uint32 param)
000000  b53e              PUSH     {r1-r5,lr}
;;;1338   {
;;;1339   	uint8 buff[UART_PROTOCOL_MCU_UID_BUFF_LENGTH];
;;;1340   	uint8 i;
;;;1341   
;;;1342   	// 按位发送sn0
;;;1343   	buff[0] = iapCB.mcuUID.sn0 & 0xff;
000002  4824              LDR      r0,|L30.148|
000004  6841              LDR      r1,[r0,#4]  ; iapCB
000006  f88d1000          STRB     r1,[sp,#0]
;;;1344   	buff[1] = (iapCB.mcuUID.sn0 >> 8)  & 0xff;
00000a  6841              LDR      r1,[r0,#4]  ; iapCB
00000c  0a09              LSRS     r1,r1,#8
00000e  f88d1001          STRB     r1,[sp,#1]
;;;1345   	buff[2] = (iapCB.mcuUID.sn0 >> 16) & 0xff;
000012  6841              LDR      r1,[r0,#4]  ; iapCB
000014  0c09              LSRS     r1,r1,#16
000016  f88d1002          STRB     r1,[sp,#2]
;;;1346   	buff[3] = (iapCB.mcuUID.sn0 >> 24) & 0xff;
00001a  6841              LDR      r1,[r0,#4]  ; iapCB
00001c  0e09              LSRS     r1,r1,#24
00001e  f88d1003          STRB     r1,[sp,#3]
;;;1347   
;;;1348   	// 按位发送sn1
;;;1349   	buff[4] = iapCB.mcuUID.sn1 & 0xff;
000022  6881              LDR      r1,[r0,#8]  ; iapCB
000024  f88d1004          STRB     r1,[sp,#4]
;;;1350   	buff[5] = (iapCB.mcuUID.sn1 >> 8)  & 0xff;
000028  6881              LDR      r1,[r0,#8]  ; iapCB
00002a  0a09              LSRS     r1,r1,#8
00002c  f88d1005          STRB     r1,[sp,#5]
;;;1351   	buff[6] = (iapCB.mcuUID.sn1 >> 16) & 0xff;
000030  6881              LDR      r1,[r0,#8]  ; iapCB
000032  0c09              LSRS     r1,r1,#16
000034  f88d1006          STRB     r1,[sp,#6]
;;;1352   	buff[7] = (iapCB.mcuUID.sn1 >> 24) & 0xff;
000038  6881              LDR      r1,[r0,#8]  ; iapCB
00003a  0e09              LSRS     r1,r1,#24
00003c  f88d1007          STRB     r1,[sp,#7]
;;;1353   
;;;1354   	// 按位发送sn2
;;;1355   	buff[8]  = iapCB.mcuUID.sn2 & 0xff;
000040  68c1              LDR      r1,[r0,#0xc]  ; iapCB
000042  f88d1008          STRB     r1,[sp,#8]
;;;1356   	buff[9]  = (iapCB.mcuUID.sn2 >> 8)  & 0xff;
000046  68c1              LDR      r1,[r0,#0xc]  ; iapCB
000048  0a09              LSRS     r1,r1,#8
00004a  f88d1009          STRB     r1,[sp,#9]
;;;1357   	buff[10] = (iapCB.mcuUID.sn2 >> 16) & 0xff;
00004e  68c1              LDR      r1,[r0,#0xc]  ; iapCB
000050  0c09              LSRS     r1,r1,#16
000052  f88d100a          STRB     r1,[sp,#0xa]
;;;1358   	buff[11] = (iapCB.mcuUID.sn2 >> 24) & 0xff;
000056  68c0              LDR      r0,[r0,#0xc]  ; iapCB
000058  0e00              LSRS     r0,r0,#24
00005a  f88d000b          STRB     r0,[sp,#0xb]
;;;1359   
;;;1360   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, IAP_CTRL_UART_CMD_HEAD);
00005e  2155              MOVS     r1,#0x55
000060  480d              LDR      r0,|L30.152|
000062  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1361   	
;;;1362   	// MCU_UID
;;;1363   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, UART_ECO_CMD_ECO_MCU_UID);	
000066  2108              MOVS     r1,#8
000068  480b              LDR      r0,|L30.152|
00006a  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1364   	IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, 0x00);	
00006e  2100              MOVS     r1,#0
000070  4809              LDR      r0,|L30.152|
000072  f7fffffe          BL       IAP_CTRL_UART_TxAddData
;;;1365   	
;;;1366   	for (i = 0; i < UART_PROTOCOL_MCU_UID_BUFF_LENGTH; i++)
000076  2400              MOVS     r4,#0
000078  466d              MOV      r5,sp                 ;1339
                  |L30.122|
;;;1367   	{
;;;1368   		IAP_CTRL_UART_TxAddData(&iapCtrlUartCB, buff[i]);
00007a  4807              LDR      r0,|L30.152|
00007c  5d29              LDRB     r1,[r5,r4]
00007e  f7fffffe          BL       IAP_CTRL_UART_TxAddData
000082  1c64              ADDS     r4,r4,#1              ;1366
000084  b2e4              UXTB     r4,r4                 ;1366
000086  2c0c              CMP      r4,#0xc               ;1366
000088  d3f7              BCC      |L30.122|
;;;1369   	}
;;;1370   	
;;;1371   	IAP_CTRL_UART_TxAddFrame(&iapCtrlUartCB);
00008a  e8bd403e          POP      {r1-r5,lr}
00008e  4802              LDR      r0,|L30.152|
000090  f7ffbffe          B.W      IAP_CTRL_UART_TxAddFrame
;;;1372   }
                          ENDP

                  |L30.148|
                          DCD      iapCB
                  |L30.152|
                          DCD      ||.bss||+0xa0

                          AREA ||i.checkVersion||, CODE, READONLY, ALIGN=2

                  checkVersion PROC
;;;440    
;;;441    void checkVersion(uint32 param)
000000  b510              PUSH     {r4,lr}
;;;442    {
;;;443    	IAP_CTRL_UART_SendVersionCheck(checkFlag);
000002  4c04              LDR      r4,|L31.20|
000004  7820              LDRB     r0,[r4,#0]  ; checkFlag
000006  f7fffffe          BL       IAP_CTRL_UART_SendVersionCheck
;;;444    	checkFlag++;
00000a  7820              LDRB     r0,[r4,#0]  ; checkFlag
00000c  1c40              ADDS     r0,r0,#1
00000e  7020              STRB     r0,[r4,#0]
;;;445    }
000010  bd10              POP      {r4,pc}
;;;446    
                          ENDP

000012  0000              DCW      0x0000
                  |L31.20|
                          DCD      ||.data||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  arrbuf
                          %        160
                  iapCtrlUartCB
                          %        1888

                          AREA ||.data||, DATA, ALIGN=1

                  checkFlag
000000  0000              DCB      0x00,0x00
                  colorDisplay
000002  f800              DCW      0xf800
000004  f80007e0          DCW      0xf800,0x07e0
000008  001fffff          DCW      0x001f,0xffff
00000c  0000f800          DCW      0x0000,0xf800

;*** Start embedded assembler ***

#line 1 "User\\iapCtrlUart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_iapCtrlUart_c_5e3d4376____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___13_iapCtrlUart_c_5e3d4376____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_iapCtrlUart_c_5e3d4376____REVSH|
#line 128
|__asm___13_iapCtrlUart_c_5e3d4376____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
