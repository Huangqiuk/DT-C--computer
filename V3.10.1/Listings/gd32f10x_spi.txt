; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\gd32f10x_spi.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\gd32f10x_spi.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -IC:\Users\Administrator\AppData\Local\Arm\Packs\GigaDevice\GD32F10x_DFP\2.0.1\Device\Include -D__MICROLIB -D__UVISION_VERSION=534 -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\gd32f10x_spi.crf Libraries\src\gd32f10x_spi.c]
                          THUMB

                          AREA ||i.i2s_disable||, CODE, READONLY, ALIGN=1

                  i2s_disable PROC
;;;331    */
;;;332    void i2s_disable(uint32_t spi_periph)
000000  69c1              LDR      r1,[r0,#0x1c]
;;;333    {
;;;334        SPI_I2SCTL(spi_periph) &= (uint32_t)(~SPI_I2SCTL_I2SEN);
000002  f4216180          BIC      r1,r1,#0x400
000006  61c1              STR      r1,[r0,#0x1c]
;;;335    }
000008  4770              BX       lr
;;;336    
                          ENDP


                          AREA ||i.i2s_enable||, CODE, READONLY, ALIGN=1

                  i2s_enable PROC
;;;320    */
;;;321    void i2s_enable(uint32_t spi_periph)
000000  69c1              LDR      r1,[r0,#0x1c]
;;;322    {
;;;323        SPI_I2SCTL(spi_periph) |= (uint32_t)SPI_I2SCTL_I2SEN;
000002  f4416180          ORR      r1,r1,#0x400
000006  61c1              STR      r1,[r0,#0x1c]
;;;324    }
000008  4770              BX       lr
;;;325    
                          ENDP


                          AREA ||i.i2s_init||, CODE, READONLY, ALIGN=1

                  i2s_init PROC
;;;190    */
;;;191    void i2s_init(uint32_t spi_periph, uint32_t mode, uint32_t standard, uint32_t ckpl)
000000  b530              PUSH     {r4,r5,lr}
;;;192    {
;;;193        uint32_t reg = 0U;
;;;194        reg = SPI_I2SCTL(spi_periph);
000002  69c4              LDR      r4,[r0,#0x1c]
;;;195        reg &= I2S_INIT_MASK;
000004  f24f0547          MOV      r5,#0xf047
000008  402c              ANDS     r4,r4,r5
;;;196    
;;;197        /* enable I2S mode */
;;;198        reg |= (uint32_t)SPI_I2SCTL_I2SSEL; 
00000a  f4446400          ORR      r4,r4,#0x800
;;;199        /* select I2S mode */
;;;200        reg |= (uint32_t)mode;
00000e  430c              ORRS     r4,r4,r1
;;;201        /* select I2S standard */
;;;202        reg |= (uint32_t)standard;
000010  4314              ORRS     r4,r4,r2
;;;203        /* select I2S polarity */
;;;204        reg |= (uint32_t)ckpl;
000012  431c              ORRS     r4,r4,r3
;;;205    
;;;206        /* write to SPI_I2SCTL register */
;;;207        SPI_I2SCTL(spi_periph) = (uint32_t)reg;
000014  61c4              STR      r4,[r0,#0x1c]
;;;208    }
000016  bd30              POP      {r4,r5,pc}
;;;209    
                          ENDP


                          AREA ||i.i2s_psc_config||, CODE, READONLY, ALIGN=1

                  i2s_psc_config PROC
;;;236    */
;;;237    void i2s_psc_config(uint32_t spi_periph, uint32_t audiosample, uint32_t frameformat, uint32_t mckout)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;238    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;239        uint32_t i2sdiv = 2U, i2sof = 0U;
;;;240        uint32_t clks = 0U;
;;;241        uint32_t i2sclock = 0U;
;;;242    
;;;243        /* deinit SPI_I2SPSC register */
;;;244        SPI_I2SPSC(spi_periph) = SPI_I2SPSC_DEFAULT_VALUE;
00000c  2002              MOVS     r0,#2
00000e  6220              STR      r0,[r4,#0x20]
;;;245    
;;;246    #ifdef GD32F10X_CL
;;;247        /* get the I2S clock source */
;;;248        if(SPI1 == ((uint32_t)spi_periph)){
;;;249            /* I2S1 clock source selection */
;;;250            clks = I2S1_CLOCK_SEL;
;;;251        }else{
;;;252            /* I2S2 clock source selection */
;;;253            clks = I2S2_CLOCK_SEL;
;;;254        }
;;;255        
;;;256        if(0U != (RCU_CFG1 & clks)){
;;;257            /* get RCU PLL2 clock multiplication factor */
;;;258            clks = (uint32_t)((RCU_CFG1 & I2S_CLOCK_MUL_MASK) >> RCU_CFG1_PLL2MF_OFFSET);
;;;259     
;;;260            if((clks > 5U) && (clks < 15U)){
;;;261                /* multiplier is between 8 and 14 */
;;;262                clks += 2U;
;;;263            }else{
;;;264                if(15U == clks){
;;;265                    /* multiplier is 20 */
;;;266                    clks = 20U;
;;;267                }
;;;268            }
;;;269            
;;;270            /* get the PREDV1 value */
;;;271            i2sclock = (uint32_t)(((RCU_CFG1 & I2S_CLOCK_DIV_MASK) >>  RCU_CFG1_PREDV1_OFFSET) + 1U);
;;;272            /* calculate I2S clock based on PLL2 and PREDV1 */
;;;273            i2sclock = (uint32_t)((HXTAL_VALUE / i2sclock) * clks * 2U); 
;;;274        }else{
;;;275            /* get system clock */
;;;276            i2sclock = rcu_clock_freq_get(CK_SYS);
;;;277        }
;;;278    #else
;;;279        /* get system clock */
;;;280        i2sclock = rcu_clock_freq_get(CK_SYS);
000010  2000              MOVS     r0,#0
000012  f7fffffe          BL       rcu_clock_freq_get
;;;281    #endif /* GD32F10X_CL */ 
;;;282        
;;;283        /* config the prescaler depending on the mclk output state, the frame format and audio sample rate */
;;;284        if(I2S_MCKOUT_ENABLE == mckout){
000016  f5b77f00          CMP      r7,#0x200
00001a  d020              BEQ      |L4.94|
;;;285            clks = (uint32_t)(((i2sclock / 256U) * 10U) / audiosample);
;;;286        }else{
;;;287            if(I2S_FRAMEFORMAT_DT16B_CH16B == frameformat){
00001c  b336              CBZ      r6,|L4.108|
;;;288                clks = (uint32_t)(((i2sclock / 32U) *10U ) / audiosample);
;;;289            }else{
;;;290                clks = (uint32_t)(((i2sclock / 64U) *10U ) / audiosample);
00001e  0980              LSRS     r0,r0,#6
000020  eb000080          ADD      r0,r0,r0,LSL #2
000024  0040              LSLS     r0,r0,#1
000026  fbb0f0f5          UDIV     r0,r0,r5
                  |L4.42|
;;;291            }
;;;292        }
;;;293        
;;;294        /* remove the floating point */
;;;295        clks = (clks + 5U) / 10U;
00002a  1d40              ADDS     r0,r0,#5
00002c  210a              MOVS     r1,#0xa
00002e  fbb0f0f1          UDIV     r0,r0,r1
;;;296        i2sof  = (clks & 0x00000001U);
000032  f0000101          AND      r1,r0,#1
;;;297        i2sdiv = ((clks - i2sof) / 2U);
000036  1a40              SUBS     r0,r0,r1
000038  0840              LSRS     r0,r0,#1
;;;298        i2sof  = (i2sof << 8U);
00003a  0209              LSLS     r1,r1,#8
;;;299    
;;;300        /* set the default values */
;;;301        if((i2sdiv < 2U) || (i2sdiv > 255U)){
00003c  1e82              SUBS     r2,r0,#2
00003e  2afe              CMP      r2,#0xfe
000040  d301              BCC      |L4.70|
;;;302            i2sdiv = 2U;
000042  2002              MOVS     r0,#2
;;;303            i2sof = 0U;
000044  2100              MOVS     r1,#0
                  |L4.70|
;;;304        }
;;;305    
;;;306        /* configure SPI_I2SPSC */
;;;307        SPI_I2SPSC(spi_periph) = (uint32_t)(i2sdiv | i2sof | mckout);
000046  4308              ORRS     r0,r0,r1
000048  4338              ORRS     r0,r0,r7
00004a  6220              STR      r0,[r4,#0x20]
;;;308    
;;;309        /* clear SPI_I2SCTL_DTLEN and SPI_I2SCTL_CHLEN bits */
;;;310        SPI_I2SCTL(spi_periph) &= (uint32_t)(~(SPI_I2SCTL_DTLEN | SPI_I2SCTL_CHLEN));
00004c  69e0              LDR      r0,[r4,#0x1c]
00004e  f0200007          BIC      r0,r0,#7
000052  61e0              STR      r0,[r4,#0x1c]
;;;311        /* configure data frame format */
;;;312        SPI_I2SCTL(spi_periph) |= (uint32_t)frameformat;
000054  69e0              LDR      r0,[r4,#0x1c]
000056  4330              ORRS     r0,r0,r6
000058  61e0              STR      r0,[r4,#0x1c]
;;;313    }
00005a  e8bd81f0          POP      {r4-r8,pc}
                  |L4.94|
00005e  0a00              LSRS     r0,r0,#8              ;285
000060  eb000080          ADD      r0,r0,r0,LSL #2       ;285
000064  0040              LSLS     r0,r0,#1              ;285
000066  fbb0f0f5          UDIV     r0,r0,r5              ;285
00006a  e7de              B        |L4.42|
                  |L4.108|
00006c  0940              LSRS     r0,r0,#5              ;288
00006e  eb000080          ADD      r0,r0,r0,LSL #2       ;288
000072  0040              LSLS     r0,r0,#1              ;288
000074  fbb0f0f5          UDIV     r0,r0,r5              ;288
000078  e7d7              B        |L4.42|
;;;314    
                          ENDP


                          AREA ||i.spi_bidirectional_transfer_config||, CODE, READONLY, ALIGN=1

                  spi_bidirectional_transfer_config PROC
;;;469    */
;;;470    void spi_bidirectional_transfer_config(uint32_t spi_periph, uint32_t transfer_direction)
000000  f5b14f80          CMP      r1,#0x4000
;;;471    {
000004  d004              BEQ      |L5.16|
;;;472        if(SPI_BIDIRECTIONAL_TRANSMIT == transfer_direction){
;;;473            /* set the transmit only mode */
;;;474            SPI_CTL0(spi_periph) |= (uint32_t)SPI_BIDIRECTIONAL_TRANSMIT;
;;;475        }else{
;;;476            /* set the receive only mode */
;;;477            SPI_CTL0(spi_periph) &= SPI_BIDIRECTIONAL_RECEIVE;
000006  6801              LDR      r1,[r0,#0]
000008  f4214180          BIC      r1,r1,#0x4000
00000c  6001              STR      r1,[r0,#0]
;;;478        }
;;;479    }
00000e  4770              BX       lr
                  |L5.16|
000010  6801              LDR      r1,[r0,#0]            ;474
000012  f4414180          ORR      r1,r1,#0x4000         ;474
000016  6001              STR      r1,[r0,#0]            ;474
000018  4770              BX       lr
;;;480    
                          ENDP


                          AREA ||i.spi_crc_error_clear||, CODE, READONLY, ALIGN=1

                  spi_crc_error_clear PROC
;;;714    */
;;;715    void spi_crc_error_clear(uint32_t spi_periph)
000000  6881              LDR      r1,[r0,#8]
;;;716    {
;;;717        SPI_STAT(spi_periph) &= (uint32_t)(~SPI_FLAG_CRCERR);
000002  f0210110          BIC      r1,r1,#0x10
000006  6081              STR      r1,[r0,#8]
;;;718    }
000008  4770              BX       lr
                          ENDP


                          AREA ||i.spi_crc_get||, CODE, READONLY, ALIGN=1

                  spi_crc_get PROC
;;;548    */
;;;549    uint16_t spi_crc_get(uint32_t spi_periph, uint8_t crc)
000000  2900              CMP      r1,#0
;;;550    {
000002  d002              BEQ      |L7.10|
;;;551        if(SPI_CRC_TX == crc){
;;;552            return ((uint16_t)(SPI_TCRC(spi_periph)));
;;;553        }else{
;;;554            return ((uint16_t)(SPI_RCRC(spi_periph)));
000004  6940              LDR      r0,[r0,#0x14]
000006  b280              UXTH     r0,r0
;;;555        }
;;;556    }
000008  4770              BX       lr
                  |L7.10|
00000a  6980              LDR      r0,[r0,#0x18]         ;552
00000c  b280              UXTH     r0,r0                 ;552
00000e  4770              BX       lr
;;;557    
                          ENDP


                          AREA ||i.spi_crc_next||, CODE, READONLY, ALIGN=1

                  spi_crc_next PROC
;;;533    */
;;;534    void spi_crc_next(uint32_t spi_periph)
000000  6801              LDR      r1,[r0,#0]
;;;535    {
;;;536        SPI_CTL0(spi_periph) |= (uint32_t)SPI_CTL0_CRCNT;
000002  f4415180          ORR      r1,r1,#0x1000
000006  6001              STR      r1,[r0,#0]
;;;537    }
000008  4770              BX       lr
;;;538    
                          ENDP


                          AREA ||i.spi_crc_off||, CODE, READONLY, ALIGN=1

                  spi_crc_off PROC
;;;523    */
;;;524    void spi_crc_off(uint32_t spi_periph)
000000  6801              LDR      r1,[r0,#0]
;;;525    {
;;;526        SPI_CTL0(spi_periph) &= (uint32_t)(~SPI_CTL0_CRCEN);
000002  f4215100          BIC      r1,r1,#0x2000
000006  6001              STR      r1,[r0,#0]
;;;527    }
000008  4770              BX       lr
;;;528    /*!
                          ENDP


                          AREA ||i.spi_crc_on||, CODE, READONLY, ALIGN=1

                  spi_crc_on PROC
;;;512    */
;;;513    void spi_crc_on(uint32_t spi_periph)
000000  6801              LDR      r1,[r0,#0]
;;;514    {
;;;515        SPI_CTL0(spi_periph) |= (uint32_t)SPI_CTL0_CRCEN;
000002  f4415100          ORR      r1,r1,#0x2000
000006  6001              STR      r1,[r0,#0]
;;;516    }
000008  4770              BX       lr
;;;517    
                          ENDP


                          AREA ||i.spi_crc_polynomial_get||, CODE, READONLY, ALIGN=1

                  spi_crc_polynomial_get PROC
;;;501    */
;;;502    uint16_t spi_crc_polynomial_get(uint32_t spi_periph)
000000  6900              LDR      r0,[r0,#0x10]
;;;503    {
;;;504        return ((uint16_t)SPI_CRCPOLY(spi_periph));
000002  b280              UXTH     r0,r0
;;;505    }
000004  4770              BX       lr
;;;506    
                          ENDP


                          AREA ||i.spi_crc_polynomial_set||, CODE, READONLY, ALIGN=1

                  spi_crc_polynomial_set PROC
;;;487    */
;;;488    void spi_crc_polynomial_set(uint32_t spi_periph, uint16_t crc_poly)
000000  6802              LDR      r2,[r0,#0]
;;;489    {
;;;490        /* enable SPI CRC */
;;;491        SPI_CTL0(spi_periph) |= (uint32_t)SPI_CTL0_CRCEN;
000002  f4425200          ORR      r2,r2,#0x2000
000006  6002              STR      r2,[r0,#0]
;;;492        /* set SPI CRC polynomial */
;;;493        SPI_CRCPOLY(spi_periph) = (uint32_t)crc_poly;
000008  6101              STR      r1,[r0,#0x10]
;;;494    }
00000a  4770              BX       lr
;;;495    
                          ENDP


                          AREA ||i.spi_disable||, CODE, READONLY, ALIGN=1

                  spi_disable PROC
;;;162    */
;;;163    void spi_disable(uint32_t spi_periph)
000000  6801              LDR      r1,[r0,#0]
;;;164    {
;;;165        SPI_CTL0(spi_periph) &= (uint32_t)(~SPI_CTL0_SPIEN);
000002  f0210140          BIC      r1,r1,#0x40
000006  6001              STR      r1,[r0,#0]
;;;166    }
000008  4770              BX       lr
;;;167    
                          ENDP


                          AREA ||i.spi_dma_disable||, CODE, READONLY, ALIGN=1

                  spi_dma_disable PROC
;;;409    */
;;;410    void spi_dma_disable(uint32_t spi_periph, uint8_t dma)
000000  2900              CMP      r1,#0
;;;411    {
000002  d004              BEQ      |L14.14|
;;;412        if(SPI_DMA_TRANSMIT == dma){
;;;413            SPI_CTL1(spi_periph) &= (uint32_t)(~SPI_CTL1_DMATEN);
;;;414        }else{
;;;415            SPI_CTL1(spi_periph) &= (uint32_t)(~SPI_CTL1_DMAREN);
000004  6841              LDR      r1,[r0,#4]
000006  f0210101          BIC      r1,r1,#1
00000a  6041              STR      r1,[r0,#4]
;;;416        }
;;;417    }
00000c  4770              BX       lr
                  |L14.14|
00000e  6841              LDR      r1,[r0,#4]            ;413
000010  f0210102          BIC      r1,r1,#2              ;413
000014  6041              STR      r1,[r0,#4]            ;413
000016  4770              BX       lr
;;;418    
                          ENDP


                          AREA ||i.spi_dma_enable||, CODE, READONLY, ALIGN=1

                  spi_dma_enable PROC
;;;390    */
;;;391    void spi_dma_enable(uint32_t spi_periph, uint8_t dma)
000000  2900              CMP      r1,#0
;;;392    {
000002  d004              BEQ      |L15.14|
;;;393        if(SPI_DMA_TRANSMIT == dma){
;;;394            SPI_CTL1(spi_periph) |= (uint32_t)SPI_CTL1_DMATEN;
;;;395        }else{
;;;396            SPI_CTL1(spi_periph) |= (uint32_t)SPI_CTL1_DMAREN;
000004  6841              LDR      r1,[r0,#4]
000006  f0410101          ORR      r1,r1,#1
00000a  6041              STR      r1,[r0,#4]
;;;397        }
;;;398    }
00000c  4770              BX       lr
                  |L15.14|
00000e  6841              LDR      r1,[r0,#4]            ;394
000010  f0410102          ORR      r1,r1,#2              ;394
000014  6041              STR      r1,[r0,#4]            ;394
000016  4770              BX       lr
;;;399    
                          ENDP


                          AREA ||i.spi_enable||, CODE, READONLY, ALIGN=1

                  spi_enable PROC
;;;151    */
;;;152    void spi_enable(uint32_t spi_periph)
000000  6801              LDR      r1,[r0,#0]
;;;153    {
;;;154        SPI_CTL0(spi_periph) |= (uint32_t)SPI_CTL0_SPIEN;
000002  f0410140          ORR      r1,r1,#0x40
000006  6001              STR      r1,[r0,#0]
;;;155    }
000008  4770              BX       lr
;;;156    
                          ENDP


                          AREA ||i.spi_i2s_data_frame_format_config||, CODE, READONLY, ALIGN=1

                  spi_i2s_data_frame_format_config PROC
;;;428    */
;;;429    void spi_i2s_data_frame_format_config(uint32_t spi_periph, uint16_t frame_format)
000000  6802              LDR      r2,[r0,#0]
;;;430    {
;;;431        /* clear SPI_CTL0_FF16 bit */
;;;432        SPI_CTL0(spi_periph) &= (uint32_t)(~SPI_CTL0_FF16);
000002  f4226200          BIC      r2,r2,#0x800
000006  6002              STR      r2,[r0,#0]
;;;433        /* configure SPI_CTL0_FF16 bit */
;;;434        SPI_CTL0(spi_periph) |= (uint32_t)frame_format;
000008  6802              LDR      r2,[r0,#0]
00000a  430a              ORRS     r2,r2,r1
00000c  6002              STR      r2,[r0,#0]
;;;435    }
00000e  4770              BX       lr
;;;436    
                          ENDP


                          AREA ||i.spi_i2s_data_receive||, CODE, READONLY, ALIGN=1

                  spi_i2s_data_receive PROC
;;;454    */
;;;455    uint16_t spi_i2s_data_receive(uint32_t spi_periph)
000000  68c0              LDR      r0,[r0,#0xc]
;;;456    {
;;;457        return ((uint16_t)SPI_DATA(spi_periph));
000002  b280              UXTH     r0,r0
;;;458    }
000004  4770              BX       lr
;;;459    
                          ENDP


                          AREA ||i.spi_i2s_data_transmit||, CODE, READONLY, ALIGN=1

                  spi_i2s_data_transmit PROC
;;;443    */
;;;444    void spi_i2s_data_transmit(uint32_t spi_periph, uint16_t data)
000000  60c1              STR      r1,[r0,#0xc]
;;;445    {
;;;446        SPI_DATA(spi_periph) = (uint32_t)data;
;;;447    }
000002  4770              BX       lr
;;;448    
                          ENDP


                          AREA ||i.spi_i2s_deinit||, CODE, READONLY, ALIGN=2

                  spi_i2s_deinit PROC
;;;61     */
;;;62     void spi_i2s_deinit(uint32_t spi_periph)
000000  b510              PUSH     {r4,lr}
;;;63     {
;;;64         switch(spi_periph){
000002  4914              LDR      r1,|L20.84|
000004  1840              ADDS     r0,r0,r1
000006  d00f              BEQ      |L20.40|
000008  f5b06f80          CMP      r0,#0x400
00000c  d016              BEQ      |L20.60|
00000e  f5b04f78          CMP      r0,#0xf800
000012  d11d              BNE      |L20.80|
;;;65         case SPI0:
;;;66             /* reset SPI0 */
;;;67             rcu_periph_reset_enable(RCU_SPI0RST);
000014  f44f7443          MOV      r4,#0x30c
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       rcu_periph_reset_enable
;;;68             rcu_periph_reset_disable(RCU_SPI0RST);
00001e  4620              MOV      r0,r4
000020  e8bd4010          POP      {r4,lr}
000024  f7ffbffe          B.W      rcu_periph_reset_disable
                  |L20.40|
;;;69             break;
;;;70         case SPI1:
;;;71             /* reset SPI1 and I2S1 */
;;;72             rcu_periph_reset_enable(RCU_SPI1RST);
000028  f240440e          MOV      r4,#0x40e
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       rcu_periph_reset_enable
;;;73             rcu_periph_reset_disable(RCU_SPI1RST);
000032  4620              MOV      r0,r4
000034  e8bd4010          POP      {r4,lr}
000038  f7ffbffe          B.W      rcu_periph_reset_disable
                  |L20.60|
;;;74             break;
;;;75         case SPI2:
;;;76             /* reset SPI2 and I2S2 */
;;;77             rcu_periph_reset_enable(RCU_SPI2RST);
00003c  f240440f          MOV      r4,#0x40f
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       rcu_periph_reset_enable
;;;78             rcu_periph_reset_disable(RCU_SPI2RST);
000046  4620              MOV      r0,r4
000048  e8bd4010          POP      {r4,lr}
00004c  f7ffbffe          B.W      rcu_periph_reset_disable
                  |L20.80|
;;;79             break;
;;;80         default :
;;;81             break;
;;;82         }
;;;83     }
000050  bd10              POP      {r4,pc}
;;;84     
                          ENDP

000052  0000              DCW      0x0000
                  |L20.84|
                          DCD      0xbfffc800

                          AREA ||i.spi_i2s_flag_get||, CODE, READONLY, ALIGN=1

                  spi_i2s_flag_get PROC
;;;699    */
;;;700    FlagStatus spi_i2s_flag_get(uint32_t spi_periph, uint32_t flag)
000000  6880              LDR      r0,[r0,#8]
;;;701    {
;;;702        if(RESET != (SPI_STAT(spi_periph) & flag)){
000002  4208              TST      r0,r1
000004  d001              BEQ      |L21.10|
;;;703            return SET;
000006  2001              MOVS     r0,#1
;;;704        }else{
;;;705            return RESET;
;;;706        }
;;;707    }
000008  4770              BX       lr
                  |L21.10|
00000a  2000              MOVS     r0,#0                 ;705
00000c  4770              BX       lr
;;;708    
                          ENDP


                          AREA ||i.spi_i2s_interrupt_disable||, CODE, READONLY, ALIGN=1

                  spi_i2s_interrupt_disable PROC
;;;601    */
;;;602    void spi_i2s_interrupt_disable(uint32_t spi_periph, uint8_t interrupt)
000000  2900              CMP      r1,#0
;;;603    {
000002  d008              BEQ      |L22.22|
;;;604        switch(interrupt){
000004  2901              CMP      r1,#1
000006  d00b              BEQ      |L22.32|
000008  2902              CMP      r1,#2
00000a  d103              BNE      |L22.20|
;;;605        /* SPI/I2S transmit buffer empty interrupt */
;;;606        case SPI_I2S_INT_TBE:
;;;607            SPI_CTL1(spi_periph) &= (uint32_t)(~SPI_CTL1_TBEIE);
;;;608            break;
;;;609        /* SPI/I2S receive buffer not empty interrupt */
;;;610        case SPI_I2S_INT_RBNE:
;;;611            SPI_CTL1(spi_periph) &= (uint32_t)(~SPI_CTL1_RBNEIE);
;;;612            break;
;;;613        /* SPI/I2S error */
;;;614        case SPI_I2S_INT_ERR:
;;;615            SPI_CTL1(spi_periph) &= (uint32_t)(~SPI_CTL1_ERRIE);
00000c  6841              LDR      r1,[r0,#4]
00000e  f0210120          BIC      r1,r1,#0x20
000012  6041              STR      r1,[r0,#4]
                  |L22.20|
;;;616            break;
;;;617        default :
;;;618            break;
;;;619        }
;;;620    }
000014  4770              BX       lr
                  |L22.22|
000016  6841              LDR      r1,[r0,#4]            ;607
000018  f0210180          BIC      r1,r1,#0x80           ;607
00001c  6041              STR      r1,[r0,#4]            ;607
00001e  4770              BX       lr
                  |L22.32|
000020  6841              LDR      r1,[r0,#4]            ;611
000022  f0210140          BIC      r1,r1,#0x40           ;611
000026  6041              STR      r1,[r0,#4]            ;611
000028  4770              BX       lr
;;;621    
                          ENDP


                          AREA ||i.spi_i2s_interrupt_enable||, CODE, READONLY, ALIGN=1

                  spi_i2s_interrupt_enable PROC
;;;569    */
;;;570    void spi_i2s_interrupt_enable(uint32_t spi_periph, uint8_t interrupt)
000000  2900              CMP      r1,#0
;;;571    {
000002  d008              BEQ      |L23.22|
;;;572        switch(interrupt){
000004  2901              CMP      r1,#1
000006  d00b              BEQ      |L23.32|
000008  2902              CMP      r1,#2
00000a  d103              BNE      |L23.20|
;;;573        /* SPI/I2S transmit buffer empty interrupt */
;;;574        case SPI_I2S_INT_TBE:
;;;575            SPI_CTL1(spi_periph) |= (uint32_t)SPI_CTL1_TBEIE;
;;;576            break;
;;;577        /* SPI/I2S receive buffer not empty interrupt */
;;;578        case SPI_I2S_INT_RBNE:
;;;579            SPI_CTL1(spi_periph) |= (uint32_t)SPI_CTL1_RBNEIE;
;;;580            break;
;;;581        /* SPI/I2S error */
;;;582        case SPI_I2S_INT_ERR:
;;;583            SPI_CTL1(spi_periph) |= (uint32_t)SPI_CTL1_ERRIE;
00000c  6841              LDR      r1,[r0,#4]
00000e  f0410120          ORR      r1,r1,#0x20
000012  6041              STR      r1,[r0,#4]
                  |L23.20|
;;;584            break;
;;;585        default:
;;;586            break;
;;;587        }
;;;588    }
000014  4770              BX       lr
                  |L23.22|
000016  6841              LDR      r1,[r0,#4]            ;575
000018  f0410180          ORR      r1,r1,#0x80           ;575
00001c  6041              STR      r1,[r0,#4]            ;575
00001e  4770              BX       lr
                  |L23.32|
000020  6841              LDR      r1,[r0,#4]            ;579
000022  f0410140          ORR      r1,r1,#0x40           ;579
000026  6041              STR      r1,[r0,#4]            ;579
000028  4770              BX       lr
;;;589    
                          ENDP


                          AREA ||i.spi_i2s_interrupt_flag_get||, CODE, READONLY, ALIGN=1

                  spi_i2s_interrupt_flag_get PROC
;;;635    */
;;;636    FlagStatus spi_i2s_interrupt_flag_get(uint32_t spi_periph, uint8_t interrupt)
000000  6882              LDR      r2,[r0,#8]
;;;637    {
;;;638        uint32_t reg1 = SPI_STAT(spi_periph);
;;;639        uint32_t reg2 = SPI_CTL1(spi_periph);
000002  6840              LDR      r0,[r0,#4]
;;;640    
;;;641        switch(interrupt){
000004  2906              CMP      r1,#6
000006  d221              BCS      |L24.76|
000008  e8dff001          TBB      [pc,r1]
00000c  03080d12          DCB      0x03,0x08,0x0d,0x12
000010  171c              DCB      0x17,0x1c
;;;642        /* SPI/I2S transmit buffer empty interrupt */
;;;643        case SPI_I2S_INT_FLAG_TBE:
;;;644            reg1 = reg1 & SPI_STAT_TBE;
000012  f0020202          AND      r2,r2,#2
;;;645            reg2 = reg2 & SPI_CTL1_TBEIE;
000016  f0000080          AND      r0,r0,#0x80
;;;646            break;
00001a  e017              B        |L24.76|
;;;647        /* SPI/I2S receive buffer not empty interrupt */
;;;648        case SPI_I2S_INT_FLAG_RBNE:
;;;649            reg1 = reg1 & SPI_STAT_RBNE;
00001c  f0020201          AND      r2,r2,#1
;;;650            reg2 = reg2 & SPI_CTL1_RBNEIE;
000020  f0000040          AND      r0,r0,#0x40
;;;651            break;
000024  e012              B        |L24.76|
;;;652        /* SPI/I2S overrun interrupt */
;;;653        case SPI_I2S_INT_FLAG_RXORERR:
;;;654            reg1 = reg1 & SPI_STAT_RXORERR;
000026  f0020240          AND      r2,r2,#0x40
;;;655            reg2 = reg2 & SPI_CTL1_ERRIE;
00002a  f0000020          AND      r0,r0,#0x20
;;;656            break;
00002e  e00d              B        |L24.76|
;;;657        /* SPI config error interrupt */
;;;658        case SPI_INT_FLAG_CONFERR:
;;;659            reg1 = reg1 & SPI_STAT_CONFERR;
000030  f0020220          AND      r2,r2,#0x20
;;;660            reg2 = reg2 & SPI_CTL1_ERRIE;
000034  f0000020          AND      r0,r0,#0x20
;;;661            break;
000038  e008              B        |L24.76|
;;;662        /* SPI CRC error interrupt */
;;;663        case SPI_INT_FLAG_CRCERR:
;;;664            reg1 = reg1 & SPI_STAT_CRCERR;
00003a  f0020210          AND      r2,r2,#0x10
;;;665            reg2 = reg2 & SPI_CTL1_ERRIE;
00003e  f0000020          AND      r0,r0,#0x20
;;;666            break;
000042  e003              B        |L24.76|
;;;667        /* I2S underrun error interrupt */
;;;668        case I2S_INT_FLAG_TXURERR:
;;;669            reg1 = reg1 & SPI_STAT_TXURERR;
000044  f0020208          AND      r2,r2,#8
;;;670            reg2 = reg2 & SPI_CTL1_ERRIE;
000048  f0000020          AND      r0,r0,#0x20
                  |L24.76|
;;;671            break;
;;;672        default :
;;;673            break;
;;;674        }
;;;675        /*get SPI/I2S interrupt flag status */
;;;676        if((0U != reg1) && (0U != reg2)){
00004c  b112              CBZ      r2,|L24.84|
00004e  b108              CBZ      r0,|L24.84|
;;;677            return SET;
000050  2001              MOVS     r0,#1
;;;678        }else{
;;;679            return RESET;
;;;680        }
;;;681    }
000052  4770              BX       lr
                  |L24.84|
000054  2000              MOVS     r0,#0                 ;679
000056  4770              BX       lr
;;;682    
                          ENDP


                          AREA ||i.spi_init||, CODE, READONLY, ALIGN=1

                  spi_init PROC
;;;118    */
;;;119    void spi_init(uint32_t spi_periph, spi_parameter_struct* spi_struct)
000000  6802              LDR      r2,[r0,#0]
;;;120    {   
;;;121        uint32_t reg = 0U;
;;;122        reg = SPI_CTL0(spi_periph);
;;;123        reg &= SPI_INIT_MASK;
000002  f4025241          AND      r2,r2,#0x3040
;;;124    
;;;125        /* select SPI as master or slave */
;;;126        reg |= spi_struct->device_mode;
000006  680b              LDR      r3,[r1,#0]
000008  4313              ORRS     r3,r3,r2
;;;127        /* select SPI transfer mode */
;;;128        reg |= spi_struct->trans_mode;
00000a  684a              LDR      r2,[r1,#4]
00000c  431a              ORRS     r2,r2,r3
;;;129        /* select SPI frame size */
;;;130        reg |= spi_struct->frame_size;
00000e  688b              LDR      r3,[r1,#8]
000010  4313              ORRS     r3,r3,r2
;;;131        /* select SPI NSS use hardware or software */
;;;132        reg |= spi_struct->nss;
000012  68ca              LDR      r2,[r1,#0xc]
000014  431a              ORRS     r2,r2,r3
;;;133        /* select SPI LSB or MSB */
;;;134        reg |= spi_struct->endian;
000016  690b              LDR      r3,[r1,#0x10]
000018  4313              ORRS     r3,r3,r2
;;;135        /* select SPI polarity and phase */
;;;136        reg |= spi_struct->clock_polarity_phase;
00001a  694a              LDR      r2,[r1,#0x14]
00001c  431a              ORRS     r2,r2,r3
;;;137        /* select SPI prescale to adjust transmit speed */
;;;138        reg |= spi_struct->prescale;
00001e  6989              LDR      r1,[r1,#0x18]
000020  4311              ORRS     r1,r1,r2
;;;139    
;;;140        /* write to SPI_CTL0 register */
;;;141        SPI_CTL0(spi_periph) = (uint32_t)reg;
000022  6001              STR      r1,[r0,#0]
;;;142    
;;;143        SPI_I2SCTL(spi_periph) &= (uint32_t)(~SPI_I2SCTL_I2SSEL);
000024  69c1              LDR      r1,[r0,#0x1c]
000026  f4216100          BIC      r1,r1,#0x800
00002a  61c1              STR      r1,[r0,#0x1c]
;;;144    }
00002c  4770              BX       lr
;;;145    
                          ENDP


                          AREA ||i.spi_nss_internal_high||, CODE, READONLY, ALIGN=1

                  spi_nss_internal_high PROC
;;;364    */
;;;365    void spi_nss_internal_high(uint32_t spi_periph)
000000  6801              LDR      r1,[r0,#0]
;;;366    {
;;;367        SPI_CTL0(spi_periph) |= (uint32_t)SPI_CTL0_SWNSS;
000002  f4417180          ORR      r1,r1,#0x100
000006  6001              STR      r1,[r0,#0]
;;;368    }
000008  4770              BX       lr
;;;369    
                          ENDP


                          AREA ||i.spi_nss_internal_low||, CODE, READONLY, ALIGN=1

                  spi_nss_internal_low PROC
;;;375    */
;;;376    void spi_nss_internal_low(uint32_t spi_periph)
000000  6801              LDR      r1,[r0,#0]
;;;377    {
;;;378        SPI_CTL0(spi_periph) &= (uint32_t)(~SPI_CTL0_SWNSS);
000002  f4217180          BIC      r1,r1,#0x100
000006  6001              STR      r1,[r0,#0]
;;;379    }
000008  4770              BX       lr
;;;380    
                          ENDP


                          AREA ||i.spi_nss_output_disable||, CODE, READONLY, ALIGN=1

                  spi_nss_output_disable PROC
;;;353    */
;;;354    void spi_nss_output_disable(uint32_t spi_periph)
000000  6841              LDR      r1,[r0,#4]
;;;355    {
;;;356        SPI_CTL1(spi_periph) &= (uint32_t)(~SPI_CTL1_NSSDRV);
000002  f0210104          BIC      r1,r1,#4
000006  6041              STR      r1,[r0,#4]
;;;357    }
000008  4770              BX       lr
;;;358    
                          ENDP


                          AREA ||i.spi_nss_output_enable||, CODE, READONLY, ALIGN=1

                  spi_nss_output_enable PROC
;;;342    */
;;;343    void spi_nss_output_enable(uint32_t spi_periph)
000000  6841              LDR      r1,[r0,#4]
;;;344    {
;;;345        SPI_CTL1(spi_periph) |= (uint32_t)SPI_CTL1_NSSDRV;
000002  f0410104          ORR      r1,r1,#4
000006  6041              STR      r1,[r0,#4]
;;;346    }
000008  4770              BX       lr
;;;347    
                          ENDP


                          AREA ||i.spi_struct_para_init||, CODE, READONLY, ALIGN=1

                  spi_struct_para_init PROC
;;;90     */
;;;91     void spi_struct_para_init(spi_parameter_struct* spi_struct)
000000  2100              MOVS     r1,#0
;;;92     {
;;;93         /* set the SPI struct with the default values */
;;;94         spi_struct->device_mode = SPI_SLAVE;
000002  6001              STR      r1,[r0,#0]
;;;95         spi_struct->trans_mode = SPI_TRANSMODE_FULLDUPLEX;
000004  6041              STR      r1,[r0,#4]
;;;96         spi_struct->frame_size = SPI_FRAMESIZE_8BIT;
000006  6081              STR      r1,[r0,#8]
;;;97         spi_struct->nss = SPI_NSS_HARD;
000008  60c1              STR      r1,[r0,#0xc]
;;;98         spi_struct->clock_polarity_phase = SPI_CK_PL_LOW_PH_1EDGE;
00000a  6141              STR      r1,[r0,#0x14]
;;;99         spi_struct->prescale = SPI_PSC_2;
00000c  6181              STR      r1,[r0,#0x18]
;;;100    }
00000e  4770              BX       lr
;;;101    
                          ENDP


;*** Start embedded assembler ***

#line 1 "Libraries\\src\\gd32f10x_spi.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_gd32f10x_spi_c_5c0caa7c____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___14_gd32f10x_spi_c_5c0caa7c____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_gd32f10x_spi_c_5c0caa7c____REVSH|
#line 128
|__asm___14_gd32f10x_spi_c_5c0caa7c____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
