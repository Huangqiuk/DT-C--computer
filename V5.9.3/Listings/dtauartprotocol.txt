; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\dtauartprotocol.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\dtauartprotocol.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -I.\User\qrencode -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.3\Device\Include -D__MICROLIB -D__UVISION_VERSION=539 -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\dtauartprotocol.crf User\DtaUartProtocol.c]
                          THUMB

                          AREA ||i.DTA_UART_PROTOCOL_CALLBACK_SetTxPeriodRequest||, CODE, READONLY, ALIGN=2

                  DTA_UART_PROTOCOL_CALLBACK_SetTxPeriodRequest PROC
;;;645    // 码表设置周期下发数据请求标志
;;;646    void DTA_UART_PROTOCOL_CALLBACK_SetTxPeriodRequest(uint32 param)
000000  4a01              LDR      r2,|L1.8|
;;;647    {
;;;648    	dtaUartProtocolCB.txPeriodRequest = (BOOL)param;
000002  f88206e4          STRB     r0,[r2,#0x6e4]
;;;649    }
000006  4770              BX       lr
;;;650    
                          ENDP

                  |L1.8|
                          DCD      dtaUartProtocolCB

                          AREA ||i.DTA_UART_PROTOCOL_CALLBACK_UartBusError||, CODE, READONLY, ALIGN=1

                  DTA_UART_PROTOCOL_CALLBACK_UartBusError PROC
;;;651    // 	UART总线超时错误处理
;;;652    void DTA_UART_PROTOCOL_CALLBACK_UartBusError(uint32 param)
000000  4770              BX       lr
;;;653    {
;;;654    }
;;;655    
                          ENDP


                          AREA ||i.DTA_UART_PROTOCOL_CheckSUM||, CODE, READONLY, ALIGN=1

                  DTA_UART_PROTOCOL_CheckSUM PROC
;;;431    // 对传入的命令帧进行校验，返回校验结果
;;;432    BOOL DTA_UART_PROTOCOL_CheckSUM(DTA_UART_PROTOCOL_RX_CMD_FRAME *pCmdFrame)
000000  b510              PUSH     {r4,lr}
;;;433    {
000002  4601              MOV      r1,r0
;;;434    	uint8 cc = 0;
000004  2300              MOVS     r3,#0
;;;435    	uint16 i = 0;
000006  2200              MOVS     r2,#0
;;;436    
;;;437    	if (NULL == pCmdFrame)
000008  b909              CBNZ     r1,|L3.14|
;;;438    	{
;;;439    		return FALSE;
00000a  2000              MOVS     r0,#0
                  |L3.12|
;;;440    	}
;;;441    
;;;442    	// 从命令头开始，到校验码之前的一个字节，依次进行异或运算
;;;443    	for (i = 0; i < pCmdFrame->length - 1; i++)
;;;444    	{
;;;445    		cc ^= pCmdFrame->buff[i];
;;;446    	}
;;;447    
;;;448    	// 判断计算得到的校验码与命令帧中的校验码是否相同
;;;449    	if (pCmdFrame->buff[pCmdFrame->length - 1] != cc)
;;;450    	{
;;;451    		return FALSE;
;;;452    	}
;;;453    
;;;454    	return TRUE;
;;;455    }
00000c  bd10              POP      {r4,pc}
                  |L3.14|
00000e  2200              MOVS     r2,#0                 ;443
000010  e004              B        |L3.28|
                  |L3.18|
000012  1c88              ADDS     r0,r1,#2              ;445
000014  5c80              LDRB     r0,[r0,r2]            ;445
000016  4043              EORS     r3,r3,r0              ;445
000018  1c50              ADDS     r0,r2,#1              ;443
00001a  b282              UXTH     r2,r0                 ;443
                  |L3.28|
00001c  f8b10098          LDRH     r0,[r1,#0x98]         ;443
000020  1e40              SUBS     r0,r0,#1              ;443
000022  4290              CMP      r0,r2                 ;443
000024  dcf5              BGT      |L3.18|
000026  f8b10098          LDRH     r0,[r1,#0x98]         ;449
00002a  1e40              SUBS     r0,r0,#1              ;449
00002c  1c8c              ADDS     r4,r1,#2              ;449
00002e  5c20              LDRB     r0,[r4,r0]            ;449
000030  4298              CMP      r0,r3                 ;449
000032  d001              BEQ      |L3.56|
000034  2000              MOVS     r0,#0                 ;451
000036  e7e9              B        |L3.12|
                  |L3.56|
000038  2001              MOVS     r0,#1                 ;454
00003a  e7e7              B        |L3.12|
;;;456    
                          ENDP


                          AREA ||i.DTA_UART_PROTOCOL_CmdFrameProcess||, CODE, READONLY, ALIGN=2

                  DTA_UART_PROTOCOL_CmdFrameProcess PROC
;;;509    // UART命令帧缓冲区处理
;;;510    void DTA_UART_PROTOCOL_CmdFrameProcess(DTA_UART_PROTOCOL_CB *pCB)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;511    {
000004  4604              MOV      r4,r0
;;;512    	DTA_UART_PROTOCOL_CMD cmd = DTA_UART_PROTOCOL_CMD_NULL;
000006  2700              MOVS     r7,#0
;;;513    	DTA_UART_PROTOCOL_RX_CMD_FRAME *pCmdFrame = NULL;
000008  2500              MOVS     r5,#0
;;;514    
;;;515    	// 我的变量
;;;516    	uint8 eraResual = 0;
00000a  2600              MOVS     r6,#0
;;;517    
;;;518    	// 参数合法性检验
;;;519    	if (NULL == pCB)
00000c  b90c              CBNZ     r4,|L4.18|
                  |L4.14|
;;;520    	{
;;;521    		return;
;;;522    	}
;;;523    
;;;524    	// 命令帧缓冲区为空，退出
;;;525    	if (pCB->rx.head == pCB->rx.end)
;;;526    	{
;;;527    		return;
;;;528    	}
;;;529    
;;;530    	// 获取当前要处理的命令帧指针
;;;531    	pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.head];
;;;532    
;;;533    	// 命令头非法，退出
;;;534    	if (DTA_UART_PROTOCOL_CMD_HEAD != pCmdFrame->buff[DTA_UART_PROTOCOL_CMD_HEAD_INDEX])
;;;535    	{
;;;536    		// 删除命令帧
;;;537    		pCB->rx.head++;
;;;538    		pCB->rx.head %= DTA_UART_PROTOCOL_RX_QUEUE_SIZE;
;;;539    		return;
;;;540    	}
;;;541    
;;;542    	// 命令头合法，则提取命令
;;;543    	cmd = (DTA_UART_PROTOCOL_CMD)pCmdFrame->buff[DTA_UART_PROTOCOL_CMD_CMD_INDEX];
;;;544    	
;;;545    	switch (dut_info.ID)
;;;546    	{
;;;547    		case DUT_TYPE_NULL:
;;;548    			break;
;;;549    
;;;550    		case DUT_TYPE_CM: // 串口通用升级
;;;551    		
;;;552    			switch (cmd)
;;;553    			{
;;;554    				case DTA_UART_PROTOCOL_CMD_NULL: // = 0			         	// 空命令
;;;555    					break;
;;;556                        
;;;557    				case DTA_UART_CMD_DUT_BOOT_ERASE_FLASH: 			        // DUT_BOOT擦除
;;;558                        eraResual = pCmdFrame->buff[DTA_UART_PROTOCOL_CMD_DATA1_INDEX];
;;;559                        
;;;560                        // 擦除失败
;;;561                        if (0 == eraResual)
;;;562                        {
;;;563                            // 擦除失败再擦除一次
;;;564                            STATE_SwitchStep(STEP_CM_UART_BC_UPGRADE_SEND_BOOT_EAR);
;;;565                            break;
;;;566                        }
;;;567    
;;;568                        // 发送BOOT数据
;;;569                        dut_info.currentBootSize = 0;
;;;570                        TIMER_KillTask(TIMER_ID_UPGRADE_DUT_BOOT);
;;;571                        STATE_SwitchStep(STEP_CM_UART_BC_UPGRADE_SEND_BOOT_PACKET);                
;;;572    					break;
;;;573                        
;;;574    				case DTA_UART_CMD_DUT_BOOT_WRITE_FLASH: 				    // DUT_BOOT写入
;;;575                        eraResual = pCmdFrame->buff[DTA_UART_PROTOCOL_CMD_DATA1_INDEX];
;;;576    
;;;577                        if (0 == eraResual) // 如果仪表写入失败就退出
;;;578                        {
;;;579                            dut_info.currentBootSize--;
;;;580                        }
;;;581                        if (dut_info.currentBootSize < dut_info.bootSize)
;;;582                        {
;;;583                            STATE_SwitchStep(STEP_CM_UART_BC_UPGRADE_SEND_BOOT_PACKET);
;;;584                        }
;;;585                        else
;;;586                        {
;;;587                            STATE_SwitchStep(STEP_CM_UART_BC_UPGRADE_BOOT_UP_SUCCESS);
;;;588                        }                
;;;589    					break;
;;;590                        
;;;591    				case DTA_UART_CMD_DUT_UPDATA_FINISH: 		            	// DUT_BOOT写入完成
;;;592                    	STATE_SwitchStep(STEP_CM_UART_BC_UPGRADE_ITEM_FINISH);
;;;593    					break;                    
;;;594    			}
;;;595    			break;
;;;596    
;;;597    		default:
;;;598    			break;
;;;599    	}
;;;600    
;;;601    	// 删除命令帧
;;;602    	pCB->rx.head++;
;;;603    	pCB->rx.head %= DTA_UART_PROTOCOL_RX_QUEUE_SIZE;
;;;604    }
00000e  e8bd81f0          POP      {r4-r8,pc}
                  |L4.18|
000012  f8b413d0          LDRH     r1,[r4,#0x3d0]        ;525
000016  f8b403d2          LDRH     r0,[r4,#0x3d2]        ;525
00001a  4281              CMP      r1,r0                 ;525
00001c  d100              BNE      |L4.32|
00001e  e7f6              B        |L4.14|
                  |L4.32|
000020  f8b403d0          LDRH     r0,[r4,#0x3d0]        ;531
000024  214d              MOVS     r1,#0x4d              ;531
000026  4348              MULS     r0,r1,r0              ;531
000028  f10401ce          ADD      r1,r4,#0xce           ;531
00002c  eb010540          ADD      r5,r1,r0,LSL #1       ;531
000030  78a8              LDRB     r0,[r5,#2]            ;534
000032  2855              CMP      r0,#0x55              ;534
000034  d00e              BEQ      |L4.84|
000036  f8b403d0          LDRH     r0,[r4,#0x3d0]        ;537
00003a  1c40              ADDS     r0,r0,#1              ;537
00003c  f8a403d0          STRH     r0,[r4,#0x3d0]        ;537
000040  f8b403d0          LDRH     r0,[r4,#0x3d0]        ;538
000044  2105              MOVS     r1,#5                 ;538
000046  fb90f2f1          SDIV     r2,r0,r1              ;538
00004a  fb010012          MLS      r0,r1,r2,r0           ;538
00004e  f8a403d0          STRH     r0,[r4,#0x3d0]        ;538
000052  e7dc              B        |L4.14|
                  |L4.84|
000054  78ef              LDRB     r7,[r5,#3]            ;543
000056  4826              LDR      r0,|L4.240|
000058  7d80              LDRB     r0,[r0,#0x16]         ;545  ; dut_info
00005a  b110              CBZ      r0,|L4.98|
00005c  2802              CMP      r0,#2                 ;545
00005e  d135              BNE      |L4.204|
000060  e000              B        |L4.100|
                  |L4.98|
000062  e034              B        |L4.206|
                  |L4.100|
000064  b137              CBZ      r7,|L4.116|
000066  2fd0              CMP      r7,#0xd0              ;552
000068  d005              BEQ      |L4.118|
00006a  2fd1              CMP      r7,#0xd1              ;552
00006c  d013              BEQ      |L4.150|
00006e  2fd2              CMP      r7,#0xd2              ;552
000070  d12a              BNE      |L4.200|
000072  e025              B        |L4.192|
                  |L4.116|
000074  e028              B        |L4.200|
                  |L4.118|
000076  796e              LDRB     r6,[r5,#5]            ;558
000078  b91e              CBNZ     r6,|L4.130|
00007a  20a2              MOVS     r0,#0xa2              ;564
00007c  f7fffffe          BL       STATE_SwitchStep
000080  e022              B        |L4.200|
                  |L4.130|
000082  2000              MOVS     r0,#0                 ;569
000084  491a              LDR      r1,|L4.240|
000086  62c8              STR      r0,[r1,#0x2c]         ;569  ; dut_info
000088  2003              MOVS     r0,#3                 ;570
00008a  f7fffffe          BL       TIMER_KillTask
00008e  20a4              MOVS     r0,#0xa4              ;571
000090  f7fffffe          BL       STATE_SwitchStep
000094  e018              B        |L4.200|
                  |L4.150|
000096  796e              LDRB     r6,[r5,#5]            ;575
000098  b926              CBNZ     r6,|L4.164|
00009a  4815              LDR      r0,|L4.240|
00009c  6ac0              LDR      r0,[r0,#0x2c]         ;579  ; dut_info
00009e  1e40              SUBS     r0,r0,#1              ;579
0000a0  4913              LDR      r1,|L4.240|
0000a2  62c8              STR      r0,[r1,#0x2c]         ;579  ; dut_info
                  |L4.164|
0000a4  4812              LDR      r0,|L4.240|
0000a6  6ac0              LDR      r0,[r0,#0x2c]         ;581  ; dut_info
0000a8  4911              LDR      r1,|L4.240|
0000aa  6a09              LDR      r1,[r1,#0x20]         ;581  ; dut_info
0000ac  4288              CMP      r0,r1                 ;581
0000ae  d203              BCS      |L4.184|
0000b0  20a4              MOVS     r0,#0xa4              ;583
0000b2  f7fffffe          BL       STATE_SwitchStep
0000b6  e002              B        |L4.190|
                  |L4.184|
0000b8  20a5              MOVS     r0,#0xa5              ;587
0000ba  f7fffffe          BL       STATE_SwitchStep
                  |L4.190|
0000be  e003              B        |L4.200|
                  |L4.192|
0000c0  2064              MOVS     r0,#0x64              ;592
0000c2  f7fffffe          BL       STATE_SwitchStep
0000c6  bf00              NOP                            ;593
                  |L4.200|
0000c8  bf00              NOP                            ;555
0000ca  e000              B        |L4.206|
                  |L4.204|
0000cc  bf00              NOP                            ;598
                  |L4.206|
0000ce  bf00              NOP                            ;548
0000d0  f8b403d0          LDRH     r0,[r4,#0x3d0]        ;602
0000d4  1c40              ADDS     r0,r0,#1              ;602
0000d6  f8a403d0          STRH     r0,[r4,#0x3d0]        ;602
0000da  f8b403d0          LDRH     r0,[r4,#0x3d0]        ;603
0000de  2105              MOVS     r1,#5                 ;603
0000e0  fb90f2f1          SDIV     r2,r0,r1              ;603
0000e4  fb010012          MLS      r0,r1,r2,r0           ;603
0000e8  f8a403d0          STRH     r0,[r4,#0x3d0]        ;603
0000ec  bf00              NOP      
0000ee  e78e              B        |L4.14|
;;;605    
                          ENDP

                  |L4.240|
                          DCD      dut_info

                          AREA ||i.DTA_UART_PROTOCOL_ConfirmTempCmdFrameBuff||, CODE, READONLY, ALIGN=1

                  DTA_UART_PROTOCOL_ConfirmTempCmdFrameBuff PROC
;;;212    // 将临时缓冲区添加到命令帧缓冲区中，其本质操作是承认临时缓冲区数据有效
;;;213    BOOL DTA_UART_PROTOCOL_ConfirmTempCmdFrameBuff(DTA_UART_PROTOCOL_CB *pCB)
000000  b510              PUSH     {r4,lr}
;;;214    {
000002  4601              MOV      r1,r0
;;;215    	DTA_UART_PROTOCOL_RX_CMD_FRAME *pCmdFrame = NULL;
000004  2200              MOVS     r2,#0
;;;216    
;;;217    	// 参数合法性检验
;;;218    	if (NULL == pCB)
000006  b909              CBNZ     r1,|L5.12|
;;;219    	{
;;;220    		return FALSE;
000008  2000              MOVS     r0,#0
                  |L5.10|
;;;221    	}
;;;222    
;;;223    	// 临时缓冲区为空，不予添加
;;;224    	pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.end];
;;;225    	if (0 == pCmdFrame->length)
;;;226    	{
;;;227    		return FALSE;
;;;228    	}
;;;229    
;;;230    	// 添加
;;;231    	pCB->rx.end++;
;;;232    	pCB->rx.end %= DTA_UART_PROTOCOL_RX_QUEUE_SIZE;
;;;233    	pCB->rx.cmdQueue[pCB->rx.end].length = 0; // 该行的作用是将新的添加位置有效数据个数清零，以便将这个位置当做临时帧缓冲区
;;;234    
;;;235    	return TRUE;
;;;236    }
00000a  bd10              POP      {r4,pc}
                  |L5.12|
00000c  f8b103d2          LDRH     r0,[r1,#0x3d2]        ;224
000010  234d              MOVS     r3,#0x4d              ;224
000012  4358              MULS     r0,r3,r0              ;224
000014  f10103ce          ADD      r3,r1,#0xce           ;224
000018  eb030240          ADD      r2,r3,r0,LSL #1       ;224
00001c  f8b20098          LDRH     r0,[r2,#0x98]         ;225
000020  b908              CBNZ     r0,|L5.38|
000022  2000              MOVS     r0,#0                 ;227
000024  e7f1              B        |L5.10|
                  |L5.38|
000026  f8b103d2          LDRH     r0,[r1,#0x3d2]        ;231
00002a  1c40              ADDS     r0,r0,#1              ;231
00002c  f8a103d2          STRH     r0,[r1,#0x3d2]        ;231
000030  f8b103d2          LDRH     r0,[r1,#0x3d2]        ;232
000034  2305              MOVS     r3,#5                 ;232
000036  fb90f4f3          SDIV     r4,r0,r3              ;232
00003a  fb030014          MLS      r0,r3,r4,r0           ;232
00003e  f8a103d2          STRH     r0,[r1,#0x3d2]        ;232
000042  2400              MOVS     r4,#0                 ;233
000044  f8b103d2          LDRH     r0,[r1,#0x3d2]        ;233
000048  234d              MOVS     r3,#0x4d              ;233
00004a  4358              MULS     r0,r3,r0              ;233
00004c  f10103ce          ADD      r3,r1,#0xce           ;233
000050  eb030040          ADD      r0,r3,r0,LSL #1       ;233
000054  f8a04098          STRH     r4,[r0,#0x98]         ;233
000058  2001              MOVS     r0,#1                 ;235
00005a  e7d6              B        |L5.10|
;;;237    
                          ENDP


                          AREA ||i.DTA_UART_PROTOCOL_DataStructInit||, CODE, READONLY, ALIGN=1

                  DTA_UART_PROTOCOL_DataStructInit PROC
;;;149    // 数据结构初始化
;;;150    void DTA_UART_PROTOCOL_DataStructInit(DTA_UART_PROTOCOL_CB *pCB)
000000  b510              PUSH     {r4,lr}
;;;151    {
;;;152    	uint16 i;
;;;153    
;;;154    	// 参数合法性检验
;;;155    	if (NULL == pCB)
000002  b900              CBNZ     r0,|L6.6|
                  |L6.4|
;;;156    	{
;;;157    		return;
;;;158    	}
;;;159    
;;;160    	pCB->tx.txBusy = FALSE;
;;;161    	pCB->tx.index = 0;
;;;162    	pCB->tx.head = 0;
;;;163    	pCB->tx.end = 0;
;;;164    	for (i = 0; i < DTA_UART_PROTOCOL_TX_QUEUE_SIZE; i++)
;;;165    	{
;;;166    		pCB->tx.cmdQueue[i].length = 0;
;;;167    	}
;;;168    
;;;169    	pCB->rxFIFO.head = 0;
;;;170    	pCB->rxFIFO.end = 0;
;;;171    	pCB->rxFIFO.currentProcessIndex = 0;
;;;172    
;;;173    	pCB->rx.head = 0;
;;;174    	pCB->rx.end = 0;
;;;175    	for (i = 0; i < DTA_UART_PROTOCOL_RX_QUEUE_SIZE; i++)
;;;176    	{
;;;177    		pCB->rx.cmdQueue[i].length = 0;
;;;178    	}
;;;179    }
000004  bd10              POP      {r4,pc}
                  |L6.6|
000006  2300              MOVS     r3,#0                 ;160
000008  f88036dc          STRB     r3,[r0,#0x6dc]        ;160
00000c  f8a036da          STRH     r3,[r0,#0x6da]        ;161
000010  f8a036d6          STRH     r3,[r0,#0x6d6]        ;162
000014  f8a036d8          STRH     r3,[r0,#0x6d8]        ;163
000018  2100              MOVS     r1,#0                 ;164
00001a  e00a              B        |L6.50|
                  |L6.28|
00001c  2400              MOVS     r4,#0                 ;166
00001e  224d              MOVS     r2,#0x4d              ;166
000020  434a              MULS     r2,r1,r2              ;166
000022  f5007375          ADD      r3,r0,#0x3d4          ;166
000026  eb030242          ADD      r2,r3,r2,LSL #1       ;166
00002a  f8a24098          STRH     r4,[r2,#0x98]         ;166
00002e  1c4a              ADDS     r2,r1,#1              ;164
000030  b291              UXTH     r1,r2                 ;164
                  |L6.50|
000032  2905              CMP      r1,#5                 ;164
000034  dbf2              BLT      |L6.28|
000036  2200              MOVS     r2,#0                 ;169
000038  f8202fc8          STRH     r2,[r0,#0xc8]!        ;169
00003c  8042              STRH     r2,[r0,#2]            ;170
00003e  8082              STRH     r2,[r0,#4]            ;171
000040  38c8              SUBS     r0,r0,#0xc8           ;171
000042  2300              MOVS     r3,#0                 ;173
000044  f8a033d0          STRH     r3,[r0,#0x3d0]        ;173
000048  f8a033d2          STRH     r3,[r0,#0x3d2]        ;174
00004c  2100              MOVS     r1,#0                 ;175
00004e  e00a              B        |L6.102|
                  |L6.80|
000050  2400              MOVS     r4,#0                 ;177
000052  224d              MOVS     r2,#0x4d              ;177
000054  434a              MULS     r2,r1,r2              ;177
000056  f10003ce          ADD      r3,r0,#0xce           ;177
00005a  eb030242          ADD      r2,r3,r2,LSL #1       ;177
00005e  f8a24098          STRH     r4,[r2,#0x98]         ;177
000062  1c4a              ADDS     r2,r1,#1              ;175
000064  b291              UXTH     r1,r2                 ;175
                  |L6.102|
000066  2905              CMP      r1,#5                 ;175
000068  dbf2              BLT      |L6.80|
00006a  bf00              NOP      
00006c  e7ca              B        |L6.4|
;;;180    
                          ENDP


                          AREA ||i.DTA_UART_PROTOCOL_Init||, CODE, READONLY, ALIGN=2

                  DTA_UART_PROTOCOL_Init PROC
;;;54     // 协议初始化
;;;55     void DTA_UART_PROTOCOL_Init(void)
000000  b500              PUSH     {lr}
;;;56     {
;;;57     	// 协议层数据结构初始化
;;;58     	DTA_UART_PROTOCOL_DataStructInit(&dtaUartProtocolCB);
000002  4803              LDR      r0,|L7.16|
000004  f7fffffe          BL       DTA_UART_PROTOCOL_DataStructInit
;;;59     
;;;60     	// 向驱动层注册数据接收接口
;;;61     	// UART_DRIVE_RegisterDataSendService(DTA_UART_PROTOCOL_MacProcess);
;;;62     
;;;63     	// 向驱动层注册数据发送接口
;;;64     	DTA_UART_PROTOCOL_RegisterDataSendService(UART_DRIVE_AddTxArray);
000008  4802              LDR      r0,|L7.20|
00000a  f7fffffe          BL       DTA_UART_PROTOCOL_RegisterDataSendService
;;;65     }
00000e  bd00              POP      {pc}
;;;66     
                          ENDP

                  |L7.16|
                          DCD      dtaUartProtocolCB
                  |L7.20|
                          DCD      UART_DRIVE_AddTxArray

                          AREA ||i.DTA_UART_PROTOCOL_MacProcess||, CODE, READONLY, ALIGN=2

                  DTA_UART_PROTOCOL_MacProcess PROC
;;;181    // UART报文接收处理函数(注意根据具体模块修改)
;;;182    void DTA_UART_PROTOCOL_MacProcess(uint16 standarID, uint8 *pData, uint16 length)
000000  b5f0              PUSH     {r4-r7,lr}
;;;183    {
000002  4604              MOV      r4,r0
000004  4615              MOV      r5,r2
;;;184    	uint16 end = dtaUartProtocolCB.rxFIFO.end;
000006  4e12              LDR      r6,|L8.80|
000008  f8b600ca          LDRH     r0,[r6,#0xca]  ; dtaUartProtocolCB
;;;185    	uint16 head = dtaUartProtocolCB.rxFIFO.head;
00000c  f8b620c8          LDRH     r2,[r6,#0xc8]  ; dtaUartProtocolCB
;;;186    	uint8 rxdata = 0x00;
000010  2300              MOVS     r3,#0
;;;187    
;;;188    	// 接收数据
;;;189    	rxdata = *pData;
000012  780b              LDRB     r3,[r1,#0]
;;;190    
;;;191    	// 一级缓冲区已满，不予接收
;;;192    	if ((end + 1) % DTA_UART_PROTOCOL_RX_FIFO_SIZE == head)
000014  1c46              ADDS     r6,r0,#1
000016  27c8              MOVS     r7,#0xc8
000018  fb96fcf7          SDIV     r12,r6,r7
00001c  fb07661c          MLS      r6,r7,r12,r6
000020  4296              CMP      r6,r2
000022  d100              BNE      |L8.38|
                  |L8.36|
;;;193    	{
;;;194    		return;
;;;195    	}
;;;196    	// 一级缓冲区未满，接收
;;;197    	else
;;;198    	{
;;;199    		// 将接收到的数据放到临时缓冲区中
;;;200    		dtaUartProtocolCB.rxFIFO.buff[end] = rxdata;
;;;201    		dtaUartProtocolCB.rxFIFO.end++;
;;;202    		dtaUartProtocolCB.rxFIFO.end %= DTA_UART_PROTOCOL_RX_FIFO_SIZE;
;;;203    	}
;;;204    }
000024  bdf0              POP      {r4-r7,pc}
                  |L8.38|
000026  4e0a              LDR      r6,|L8.80|
000028  5433              STRB     r3,[r6,r0]            ;200
00002a  f8b660ca          LDRH     r6,[r6,#0xca]         ;201  ; dtaUartProtocolCB
00002e  1c76              ADDS     r6,r6,#1              ;201
000030  4f07              LDR      r7,|L8.80|
000032  f8a760ca          STRH     r6,[r7,#0xca]         ;201
000036  463e              MOV      r6,r7                 ;202
000038  f8b660ca          LDRH     r6,[r6,#0xca]         ;202  ; dtaUartProtocolCB
00003c  27c8              MOVS     r7,#0xc8              ;202
00003e  fb96fcf7          SDIV     r12,r6,r7             ;202
000042  fb07661c          MLS      r6,r7,r12,r6          ;202
000046  4f02              LDR      r7,|L8.80|
000048  f8a760ca          STRH     r6,[r7,#0xca]         ;202
00004c  bf00              NOP      
00004e  e7e9              B        |L8.36|
;;;205    
                          ENDP

                  |L8.80|
                          DCD      dtaUartProtocolCB

                          AREA ||i.DTA_UART_PROTOCOL_Process||, CODE, READONLY, ALIGN=2

                  DTA_UART_PROTOCOL_Process PROC
;;;67     // UART协议层过程处理
;;;68     void DTA_UART_PROTOCOL_Process(void)
000000  b510              PUSH     {r4,lr}
;;;69     {
;;;70     	//  UART接收FIFO缓冲区处理
;;;71     	DTA_UART_PROTOCOL_RxFIFOProcess(&dtaUartProtocolCB);
000002  4804              LDR      r0,|L9.20|
000004  f7fffffe          BL       DTA_UART_PROTOCOL_RxFIFOProcess
;;;72     
;;;73     	// UART接收命令缓冲区处理
;;;74     	DTA_UART_PROTOCOL_CmdFrameProcess(&dtaUartProtocolCB);
000008  4802              LDR      r0,|L9.20|
00000a  f7fffffe          BL       DTA_UART_PROTOCOL_CmdFrameProcess
;;;75     
;;;76     	// UART协议层发送处理过程
;;;77     	DTA_UART_PROTOCOL_TxStateProcess();
00000e  f7fffffe          BL       DTA_UART_PROTOCOL_TxStateProcess
;;;78     }
000012  bd10              POP      {r4,pc}
;;;79     
                          ENDP

                  |L9.20|
                          DCD      dtaUartProtocolCB

                          AREA ||i.DTA_UART_PROTOCOL_RegisterDataSendService||, CODE, READONLY, ALIGN=2

                  DTA_UART_PROTOCOL_RegisterDataSendService PROC
;;;206    // UART协议层向驱动层注册数据发送接口
;;;207    void DTA_UART_PROTOCOL_RegisterDataSendService(BOOL (*service)(uint16 id, uint8 *pData, uint16 length))
000000  4901              LDR      r1,|L10.8|
;;;208    {
;;;209    	dtaUartProtocolCB.sendDataThrowService = service;
000002  f8c106e0          STR      r0,[r1,#0x6e0]  ; dtaUartProtocolCB
;;;210    }
000006  4770              BX       lr
;;;211    
                          ENDP

                  |L10.8|
                          DCD      dtaUartProtocolCB

                          AREA ||i.DTA_UART_PROTOCOL_RxFIFOProcess||, CODE, READONLY, ALIGN=1

                  DTA_UART_PROTOCOL_RxFIFOProcess PROC
;;;271    // 一级接收缓冲区处理，从一级接收缓冲区中取出一个字节添加到命令帧缓冲区中
;;;272    void DTA_UART_PROTOCOL_RxFIFOProcess(DTA_UART_PROTOCOL_CB *pCB)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;273    {
000004  4604              MOV      r4,r0
;;;274    	uint16 end = pCB->rxFIFO.end;
000006  f8b470ca          LDRH     r7,[r4,#0xca]
;;;275    	uint16 head = pCB->rxFIFO.head;
00000a  f8b490c8          LDRH     r9,[r4,#0xc8]
;;;276    	DTA_UART_PROTOCOL_RX_CMD_FRAME *pCmdFrame = NULL;
00000e  2500              MOVS     r5,#0
;;;277    	uint16 length = 0;
000010  46a8              MOV      r8,r5
;;;278    	uint8 currentData = 0;
000012  2600              MOVS     r6,#0
;;;279    
;;;280    	// 参数合法性检验
;;;281    	if (NULL == pCB)
000014  b90c              CBNZ     r4,|L11.26|
                  |L11.22|
;;;282    	{
;;;283    		return;
;;;284    	}
;;;285    
;;;286    	// 一级缓冲区为空，退出
;;;287    	if (head == end)
;;;288    	{
;;;289    		return;
;;;290    	}
;;;291    
;;;292    	// 获取临时缓冲区指针
;;;293    	pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.end];
;;;294    	// 取出当前要处理的字节
;;;295    	currentData = pCB->rxFIFO.buff[pCB->rxFIFO.currentProcessIndex];
;;;296    
;;;297    	// 临时缓冲区长度为0时，搜索首字节
;;;298    	if (0 == pCmdFrame->length)
;;;299    	{
;;;300    		// 命令头错误，删除当前字节并退出
;;;301    		if (DTA_UART_PROTOCOL_CMD_HEAD != currentData)
;;;302    		{
;;;303    			pCB->rxFIFO.head++;
;;;304    			pCB->rxFIFO.head %= DTA_UART_PROTOCOL_RX_FIFO_SIZE;
;;;305    			pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;306    
;;;307    			return;
;;;308    		}
;;;309    
;;;310    		// 命令头正确，但无临时缓冲区可用，退出
;;;311    		if ((pCB->rx.end + 1) % DTA_UART_PROTOCOL_RX_QUEUE_SIZE == pCB->rx.head)
;;;312    		{
;;;313    			return;
;;;314    		}
;;;315    
;;;316    		// 添加UART通讯超时时间设置-2016.1.5增加
;;;317    #if DTA_UART_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;318    		TIMER_AddTask(TIMER_ID_UART_RX_TIME_OUT_CONTROL,
;;;319    					  DTA_UART_PROTOCOL_BUS_UNIDIRECTIONAL_TIME_OUT,
;;;320    					  DTA_UART_PROTOCOL_CALLBACK_RxTimeOut,
;;;321    					  0,
;;;322    					  1,
;;;323    					  ACTION_MODE_ADD_TO_QUEUE);
;;;324    #endif
;;;325    
;;;326    		// 命令头正确，有临时缓冲区可用，则将其添加到命令帧临时缓冲区中
;;;327    		pCmdFrame->buff[pCmdFrame->length++] = currentData;
;;;328    		pCB->rxFIFO.currentProcessIndex++;
;;;329    		pCB->rxFIFO.currentProcessIndex %= DTA_UART_PROTOCOL_RX_FIFO_SIZE;
;;;330    	}
;;;331    	// 非首字节，将数据添加到命令帧临时缓冲区中，但暂不删除当前数据
;;;332    	else
;;;333    	{
;;;334    		// 临时缓冲区溢出，说明当前正在接收的命令帧是错误的，正确的命令帧不会出现长度溢出的情况
;;;335    		if (pCmdFrame->length >= DTA_UART_PROTOCOL_RX_CMD_FRAME_LENGTH_MAX)
;;;336    		{
;;;337    #if DTA_UART_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;338    			// 停止RX通讯超时检测
;;;339    			DTA_UART_PROTOCOL_StopRxTimeOutCheck();
;;;340    #endif
;;;341    
;;;342    			// 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;343    			pCmdFrame->length = 0; // 2016.1.5增加
;;;344    			// 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;345    			pCB->rxFIFO.head++;
;;;346    			pCB->rxFIFO.head %= DTA_UART_PROTOCOL_RX_FIFO_SIZE;
;;;347    			pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;348    
;;;349    			return;
;;;350    		}
;;;351    
;;;352    		// 一直取到末尾
;;;353    		while (end != pCB->rxFIFO.currentProcessIndex)
;;;354    		{
;;;355    			// 取出当前要处理的字节
;;;356    			currentData = pCB->rxFIFO.buff[pCB->rxFIFO.currentProcessIndex];
;;;357    			// 缓冲区未溢出，正常接收，将数据添加到临时缓冲区中
;;;358    			pCmdFrame->buff[pCmdFrame->length++] = currentData;
;;;359    			pCB->rxFIFO.currentProcessIndex++;
;;;360    			pCB->rxFIFO.currentProcessIndex %= DTA_UART_PROTOCOL_RX_FIFO_SIZE;
;;;361    
;;;362    			// ■■接下来，需要检查命令帧是否完整，如果完整，则将命令帧临时缓冲区扶正■■
;;;363    
;;;364    			// 首先判断命令帧最小长度，一个完整的命令字至少包括8个字节: 命令头、设备地址、命令字、数据长度、校验和L、校验和H、结束标识0xD、结束标识OxA，因此不足8个字节的必定不完整
;;;365    			if (pCmdFrame->length < DTA_UART_PROTOCOL_CMD_FRAME_LENGTH_MIN)
;;;366    			{
;;;367    				// 继续接收
;;;368    				continue;
;;;369    			}
;;;370    
;;;371    			// 命令帧长度数值越界，说明当前命令帧错误，停止接收
;;;372    			if (pCmdFrame->buff[DTA_UART_PROTOCOL_CMD_LENGTH_INDEX] > DTA_UART_PROTOCOL_RX_CMD_FRAME_LENGTH_MAX - DTA_UART_PROTOCOL_CMD_FRAME_LENGTH_MIN)
;;;373    			{
;;;374    #if DTA_UART_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;375    				// 停止RX通讯超时检测
;;;376    				DTA_UART_PROTOCOL_StopRxTimeOutCheck();
;;;377    #endif
;;;378    
;;;379    				// 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;380    				pCmdFrame->length = 0;
;;;381    				// 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;382    				pCB->rxFIFO.head++;
;;;383    				pCB->rxFIFO.head %= DTA_UART_PROTOCOL_RX_FIFO_SIZE;
;;;384    				pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;385    
;;;386    				return;
;;;387    			}
;;;388    
;;;389    			// 命令帧长度校验，在命令长度描述字的数值上，增加命令头、设备地址、命令字、数据长度、校验和L、校验和H、结束标识0xD、结束标识OxA，即为命令帧实际长度
;;;390    			length = pCmdFrame->length;
;;;391    			if (length < pCmdFrame->buff[DTA_UART_PROTOCOL_CMD_LENGTH_INDEX] + DTA_UART_PROTOCOL_CMD_FRAME_LENGTH_MIN)
;;;392    			{
;;;393    				// 长度要求不一致，说明未接收完毕，退出继续
;;;394    				continue;
;;;395    			}
;;;396    
;;;397    			// 命令帧长度OK，则进行校验，失败时删除命令头
;;;398    			if (!DTA_UART_PROTOCOL_CheckSUM(pCmdFrame))
;;;399    			{
;;;400    #if DTA_UART_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;401    				// 停止RX通讯超时检测
;;;402    				DTA_UART_PROTOCOL_StopRxTimeOutCheck();
;;;403    #endif
;;;404    
;;;405    				// 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;406    				pCmdFrame->length = 0;
;;;407    				// 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;408    				pCB->rxFIFO.head++;
;;;409    				pCB->rxFIFO.head %= DTA_UART_PROTOCOL_RX_FIFO_SIZE;
;;;410    				pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;411    
;;;412    				return;
;;;413    			}
;;;414    
;;;415    #if DTA_UART_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;416    			// 停止RX通讯超时检测
;;;417    			DTA_UART_PROTOCOL_StopRxTimeOutCheck();
;;;418    #endif
;;;419    
;;;420    			// 执行到这里，即说明接收到了一个完整并且正确的命令帧，此时需将处理过的数据从一级缓冲区中删除，并将该命令帧扶正
;;;421    			pCB->rxFIFO.head += length;
;;;422    			pCB->rxFIFO.head %= DTA_UART_PROTOCOL_RX_FIFO_SIZE;
;;;423    			pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;424    			DTA_UART_PROTOCOL_ConfirmTempCmdFrameBuff(pCB);
;;;425    
;;;426    			return;
;;;427    		}
;;;428    	}
;;;429    }
000016  e8bd83f0          POP      {r4-r9,pc}
                  |L11.26|
00001a  45b9              CMP      r9,r7                 ;287
00001c  d100              BNE      |L11.32|
00001e  e7fa              B        |L11.22|
                  |L11.32|
000020  f8b403d2          LDRH     r0,[r4,#0x3d2]        ;293
000024  214d              MOVS     r1,#0x4d              ;293
000026  4348              MULS     r0,r1,r0              ;293
000028  f10401ce          ADD      r1,r4,#0xce           ;293
00002c  eb010540          ADD      r5,r1,r0,LSL #1       ;293
000030  f8b400cc          LDRH     r0,[r4,#0xcc]         ;295
000034  5c26              LDRB     r6,[r4,r0]            ;295
000036  f8b50098          LDRH     r0,[r5,#0x98]         ;298
00003a  bb90              CBNZ     r0,|L11.162|
00003c  2e55              CMP      r6,#0x55              ;301
00003e  d00e              BEQ      |L11.94|
000040  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;303
000044  1c40              ADDS     r0,r0,#1              ;303
000046  8020              STRH     r0,[r4,#0]            ;303
000048  8820              LDRH     r0,[r4,#0]            ;304
00004a  21c8              MOVS     r1,#0xc8              ;304
00004c  fb90f2f1          SDIV     r2,r0,r1              ;304
000050  fb010012          MLS      r0,r1,r2,r0           ;304
000054  8020              STRH     r0,[r4,#0]            ;304
000056  8820              LDRH     r0,[r4,#0]            ;305
000058  80a0              STRH     r0,[r4,#4]            ;305
00005a  3cc8              SUBS     r4,r4,#0xc8           ;305
00005c  e7db              B        |L11.22|
                  |L11.94|
00005e  f8b403d2          LDRH     r0,[r4,#0x3d2]        ;311
000062  1c40              ADDS     r0,r0,#1              ;311
000064  2105              MOVS     r1,#5                 ;311
000066  fb90f2f1          SDIV     r2,r0,r1              ;311
00006a  fb010112          MLS      r1,r1,r2,r0           ;311
00006e  f8b403d0          LDRH     r0,[r4,#0x3d0]        ;311
000072  4281              CMP      r1,r0                 ;311
000074  d100              BNE      |L11.120|
000076  e7ce              B        |L11.22|
                  |L11.120|
000078  f8351f98          LDRH     r1,[r5,#0x98]!        ;327
00007c  8828              LDRH     r0,[r5,#0]            ;327
00007e  1c40              ADDS     r0,r0,#1              ;327
000080  f8250998          STRH     r0,[r5],#-0x98        ;327
000084  1ca8              ADDS     r0,r5,#2              ;327
000086  5446              STRB     r6,[r0,r1]            ;327
000088  f8340fcc          LDRH     r0,[r4,#0xcc]!        ;328
00008c  1c40              ADDS     r0,r0,#1              ;328
00008e  8020              STRH     r0,[r4,#0]            ;328
000090  8820              LDRH     r0,[r4,#0]            ;329
000092  21c8              MOVS     r1,#0xc8              ;329
000094  fb90f2f1          SDIV     r2,r0,r1              ;329
000098  fb010012          MLS      r0,r1,r2,r0           ;329
00009c  f82409cc          STRH     r0,[r4],#-0xcc        ;329
0000a0  e07b              B        |L11.410|
                  |L11.162|
0000a2  e7ff              B        |L11.164|
                  |L11.164|
0000a4  f8b50098          LDRH     r0,[r5,#0x98]         ;335
0000a8  2896              CMP      r0,#0x96              ;335
0000aa  db11              BLT      |L11.208|
0000ac  2000              MOVS     r0,#0                 ;343
0000ae  f8a50098          STRH     r0,[r5,#0x98]         ;343
0000b2  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;345
0000b6  1c40              ADDS     r0,r0,#1              ;345
0000b8  8020              STRH     r0,[r4,#0]            ;345
0000ba  8820              LDRH     r0,[r4,#0]            ;346
0000bc  21c8              MOVS     r1,#0xc8              ;346
0000be  fb90f2f1          SDIV     r2,r0,r1              ;346
0000c2  fb010012          MLS      r0,r1,r2,r0           ;346
0000c6  8020              STRH     r0,[r4,#0]            ;346
0000c8  8820              LDRH     r0,[r4,#0]            ;347
0000ca  80a0              STRH     r0,[r4,#4]            ;347
0000cc  3cc8              SUBS     r4,r4,#0xc8           ;347
0000ce  e7a2              B        |L11.22|
                  |L11.208|
0000d0  e05f              B        |L11.402|
                  |L11.210|
0000d2  f8b400cc          LDRH     r0,[r4,#0xcc]         ;356
0000d6  5c26              LDRB     r6,[r4,r0]            ;356
0000d8  f8351f98          LDRH     r1,[r5,#0x98]!        ;358
0000dc  8828              LDRH     r0,[r5,#0]            ;358
0000de  1c40              ADDS     r0,r0,#1              ;358
0000e0  f8250998          STRH     r0,[r5],#-0x98        ;358
0000e4  1ca8              ADDS     r0,r5,#2              ;358
0000e6  5446              STRB     r6,[r0,r1]            ;358
0000e8  f8340fcc          LDRH     r0,[r4,#0xcc]!        ;359
0000ec  1c40              ADDS     r0,r0,#1              ;359
0000ee  8020              STRH     r0,[r4,#0]            ;359
0000f0  8820              LDRH     r0,[r4,#0]            ;360
0000f2  21c8              MOVS     r1,#0xc8              ;360
0000f4  fb90f2f1          SDIV     r2,r0,r1              ;360
0000f8  fb010012          MLS      r0,r1,r2,r0           ;360
0000fc  f82409cc          STRH     r0,[r4],#-0xcc        ;360
000100  f8b50098          LDRH     r0,[r5,#0x98]         ;365
000104  2804              CMP      r0,#4                 ;365
000106  da00              BGE      |L11.266|
000108  e043              B        |L11.402|
                  |L11.266|
00010a  7928              LDRB     r0,[r5,#4]            ;372
00010c  2892              CMP      r0,#0x92              ;372
00010e  dd11              BLE      |L11.308|
000110  2000              MOVS     r0,#0                 ;380
000112  f8a50098          STRH     r0,[r5,#0x98]         ;380
000116  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;382
00011a  1c40              ADDS     r0,r0,#1              ;382
00011c  8020              STRH     r0,[r4,#0]            ;382
00011e  8820              LDRH     r0,[r4,#0]            ;383
000120  21c8              MOVS     r1,#0xc8              ;383
000122  fb90f2f1          SDIV     r2,r0,r1              ;383
000126  fb010012          MLS      r0,r1,r2,r0           ;383
00012a  8020              STRH     r0,[r4,#0]            ;383
00012c  8820              LDRH     r0,[r4,#0]            ;384
00012e  80a0              STRH     r0,[r4,#4]            ;384
000130  3cc8              SUBS     r4,r4,#0xc8           ;384
000132  e770              B        |L11.22|
                  |L11.308|
000134  f8b58098          LDRH     r8,[r5,#0x98]         ;390
000138  7928              LDRB     r0,[r5,#4]            ;391
00013a  1d00              ADDS     r0,r0,#4              ;391
00013c  4540              CMP      r0,r8                 ;391
00013e  dd00              BLE      |L11.322|
000140  e027              B        |L11.402|
                  |L11.322|
000142  4628              MOV      r0,r5                 ;398
000144  f7fffffe          BL       DTA_UART_PROTOCOL_CheckSUM
000148  b988              CBNZ     r0,|L11.366|
00014a  2000              MOVS     r0,#0                 ;406
00014c  f8a50098          STRH     r0,[r5,#0x98]         ;406
000150  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;408
000154  1c40              ADDS     r0,r0,#1              ;408
000156  8020              STRH     r0,[r4,#0]            ;408
000158  8820              LDRH     r0,[r4,#0]            ;409
00015a  21c8              MOVS     r1,#0xc8              ;409
00015c  fb90f2f1          SDIV     r2,r0,r1              ;409
000160  fb010012          MLS      r0,r1,r2,r0           ;409
000164  8020              STRH     r0,[r4,#0]            ;409
000166  8820              LDRH     r0,[r4,#0]            ;410
000168  80a0              STRH     r0,[r4,#4]            ;410
00016a  3cc8              SUBS     r4,r4,#0xc8           ;410
00016c  e753              B        |L11.22|
                  |L11.366|
00016e  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;421
000172  4440              ADD      r0,r0,r8              ;421
000174  8020              STRH     r0,[r4,#0]            ;421
000176  8820              LDRH     r0,[r4,#0]            ;422
000178  21c8              MOVS     r1,#0xc8              ;422
00017a  fb90f2f1          SDIV     r2,r0,r1              ;422
00017e  fb010012          MLS      r0,r1,r2,r0           ;422
000182  8020              STRH     r0,[r4,#0]            ;422
000184  8820              LDRH     r0,[r4,#0]            ;423
000186  80a0              STRH     r0,[r4,#4]            ;423
000188  3cc8              SUBS     r4,r4,#0xc8           ;423
00018a  4620              MOV      r0,r4                 ;424
00018c  f7fffffe          BL       DTA_UART_PROTOCOL_ConfirmTempCmdFrameBuff
000190  e741              B        |L11.22|
                  |L11.402|
000192  f8b400cc          LDRH     r0,[r4,#0xcc]         ;353
000196  42b8              CMP      r0,r7                 ;353
000198  d19b              BNE      |L11.210|
                  |L11.410|
00019a  bf00              NOP      
00019c  e73b              B        |L11.22|
;;;430    
                          ENDP


                          AREA ||i.DTA_UART_PROTOCOL_SendCmdNoResult||, CODE, READONLY, ALIGN=1

                  DTA_UART_PROTOCOL_SendCmdNoResult PROC
;;;693    // 发送命令无结果
;;;694    void DTA_UART_PROTOCOL_SendCmdNoResult(uint8 cmdWord)
000000  b510              PUSH     {r4,lr}
;;;695    {
000002  4604              MOV      r4,r0
;;;696    	// 添加命令头
;;;697    	DTA_UART_PROTOCOL_TxAddData(DTA_UART_PROTOCOL_CMD_HEAD);
000004  2055              MOVS     r0,#0x55
000006  f7fffffe          BL       DTA_UART_PROTOCOL_TxAddData
;;;698    
;;;699    	// 添加命令字
;;;700    	DTA_UART_PROTOCOL_TxAddData(cmdWord);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       DTA_UART_PROTOCOL_TxAddData
;;;701    
;;;702    	DTA_UART_PROTOCOL_TxAddData(0); // 数据长度
000010  2000              MOVS     r0,#0
000012  f7fffffe          BL       DTA_UART_PROTOCOL_TxAddData
;;;703    
;;;704    	DTA_UART_PROTOCOL_TxAddFrame();
000016  f7fffffe          BL       DTA_UART_PROTOCOL_TxAddFrame
;;;705    }
00001a  bd10              POP      {r4,pc}
                          ENDP


                          AREA ||i.DTA_UART_PROTOCOL_SendCmdParamAck||, CODE, READONLY, ALIGN=1

                  DTA_UART_PROTOCOL_SendCmdParamAck PROC
;;;606    // 发送命令回复，带一个参数
;;;607    void DTA_UART_PROTOCOL_SendCmdParamAck(uint8 ackCmd, uint8 ackParam)
000000  b530              PUSH     {r4,r5,lr}
;;;608    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;609    	DTA_UART_PROTOCOL_TxAddData(0x55);
000006  2055              MOVS     r0,#0x55
000008  f7fffffe          BL       DTA_UART_PROTOCOL_TxAddData
;;;610    	DTA_UART_PROTOCOL_TxAddData(ackCmd);
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       DTA_UART_PROTOCOL_TxAddData
;;;611    	DTA_UART_PROTOCOL_TxAddData(0x01);
000012  2001              MOVS     r0,#1
000014  f7fffffe          BL       DTA_UART_PROTOCOL_TxAddData
;;;612    	DTA_UART_PROTOCOL_TxAddData(ackParam);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       DTA_UART_PROTOCOL_TxAddData
;;;613    	DTA_UART_PROTOCOL_TxAddFrame();
00001e  f7fffffe          BL       DTA_UART_PROTOCOL_TxAddFrame
;;;614    }
000022  bd30              POP      {r4,r5,pc}
;;;615    
                          ENDP


                          AREA ||i.DTA_UART_PROTOCOL_SendCmdWithResult||, CODE, READONLY, ALIGN=1

                  DTA_UART_PROTOCOL_SendCmdWithResult PROC
;;;676    // 发送命令带结果
;;;677    void DTA_UART_PROTOCOL_SendCmdWithResult(uint8 cmdWord, uint8 result)
000000  b530              PUSH     {r4,r5,lr}
;;;678    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;679    	// 添加命令头
;;;680    	DTA_UART_PROTOCOL_TxAddData(DTA_UART_PROTOCOL_CMD_HEAD);
000006  2055              MOVS     r0,#0x55
000008  f7fffffe          BL       DTA_UART_PROTOCOL_TxAddData
;;;681    
;;;682    	// 添加命令字
;;;683    	DTA_UART_PROTOCOL_TxAddData(cmdWord);
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       DTA_UART_PROTOCOL_TxAddData
;;;684    
;;;685    	// 添加数据长度
;;;686    	DTA_UART_PROTOCOL_TxAddData(1);
000012  2001              MOVS     r0,#1
000014  f7fffffe          BL       DTA_UART_PROTOCOL_TxAddData
;;;687    
;;;688    	DTA_UART_PROTOCOL_TxAddData(result);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       DTA_UART_PROTOCOL_TxAddData
;;;689    
;;;690    	DTA_UART_PROTOCOL_TxAddFrame();
00001e  f7fffffe          BL       DTA_UART_PROTOCOL_TxAddFrame
;;;691    }
000022  bd30              POP      {r4,r5,pc}
;;;692    
                          ENDP


                          AREA ||i.DTA_UART_PROTOCOL_SendLdoV||, CODE, READONLY, ALIGN=1

                  DTA_UART_PROTOCOL_SendLdoV PROC
;;;656    // 发送命令带结果
;;;657    void DTA_UART_PROTOCOL_SendLdoV(uint8 cmdWord, uint32 result)
000000  b530              PUSH     {r4,r5,lr}
;;;658    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;659    	// 添加命令头
;;;660    	DTA_UART_PROTOCOL_TxAddData(DTA_UART_PROTOCOL_CMD_HEAD);
000006  2055              MOVS     r0,#0x55
000008  f7fffffe          BL       DTA_UART_PROTOCOL_TxAddData
;;;661    
;;;662    	// 添加命令字
;;;663    	DTA_UART_PROTOCOL_TxAddData(cmdWord);
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       DTA_UART_PROTOCOL_TxAddData
;;;664    
;;;665    	// 添加数据长度
;;;666    	DTA_UART_PROTOCOL_TxAddData(4);
000012  2004              MOVS     r0,#4
000014  f7fffffe          BL       DTA_UART_PROTOCOL_TxAddData
;;;667    
;;;668    	DTA_UART_PROTOCOL_TxAddData((result >> 24) & 0xFF);
000018  0e20              LSRS     r0,r4,#24
00001a  f7fffffe          BL       DTA_UART_PROTOCOL_TxAddData
;;;669    	DTA_UART_PROTOCOL_TxAddData((result >> 16) & 0xFF);
00001e  f3c44007          UBFX     r0,r4,#16,#8
000022  f7fffffe          BL       DTA_UART_PROTOCOL_TxAddData
;;;670    	DTA_UART_PROTOCOL_TxAddData((result >> 8) & 0xFF);
000026  f3c42007          UBFX     r0,r4,#8,#8
00002a  f7fffffe          BL       DTA_UART_PROTOCOL_TxAddData
;;;671    	DTA_UART_PROTOCOL_TxAddData((result >> 0) & 0xFF);
00002e  b2e0              UXTB     r0,r4
000030  f7fffffe          BL       DTA_UART_PROTOCOL_TxAddData
;;;672    
;;;673    	DTA_UART_PROTOCOL_TxAddFrame();
000034  f7fffffe          BL       DTA_UART_PROTOCOL_TxAddFrame
;;;674    }
000038  bd30              POP      {r4,r5,pc}
;;;675    
                          ENDP


                          AREA ||i.DTA_UART_PROTOCOL_SetTxAtOnceRequest||, CODE, READONLY, ALIGN=2

                  DTA_UART_PROTOCOL_SetTxAtOnceRequest PROC
;;;639    // 码表设置立刻下发数据请求标志
;;;640    void DTA_UART_PROTOCOL_SetTxAtOnceRequest(uint32 param)
000000  4a01              LDR      r2,|L16.8|
;;;641    {
;;;642    	dtaUartProtocolCB.txAtOnceRequest = (BOOL)param;
000002  f88206e5          STRB     r0,[r2,#0x6e5]
;;;643    }
000006  4770              BX       lr
;;;644    
                          ENDP

                  |L16.8|
                          DCD      dtaUartProtocolCB

                          AREA ||i.DTA_UART_PROTOCOL_TxAddData||, CODE, READONLY, ALIGN=2

                  DTA_UART_PROTOCOL_TxAddData PROC
;;;80     // 向发送命令帧队列中添加数据
;;;81     void DTA_UART_PROTOCOL_TxAddData(uint8 data)
000000  b570              PUSH     {r4-r6,lr}
;;;82     {
000002  4601              MOV      r1,r0
;;;83     	uint16 head = dtaUartProtocolCB.tx.head;
000004  4c12              LDR      r4,|L17.80|
000006  f8b426d6          LDRH     r2,[r4,#0x6d6]
;;;84     	uint16 end = dtaUartProtocolCB.tx.end;
00000a  f8b436d8          LDRH     r3,[r4,#0x6d8]
;;;85     	DTA_UART_PROTOCOL_TX_CMD_FRAME *pCmdFrame = &dtaUartProtocolCB.tx.cmdQueue[dtaUartProtocolCB.tx.end];
00000e  f8b446d8          LDRH     r4,[r4,#0x6d8]
000012  254d              MOVS     r5,#0x4d
000014  436c              MULS     r4,r5,r4
000016  4d0f              LDR      r5,|L17.84|
000018  eb050044          ADD      r0,r5,r4,LSL #1
;;;86     
;;;87     	// 发送缓冲区已满，不予接收
;;;88     	if ((end + 1) % DTA_UART_PROTOCOL_TX_QUEUE_SIZE == head)
00001c  1c5c              ADDS     r4,r3,#1
00001e  2505              MOVS     r5,#5
000020  fb94f6f5          SDIV     r6,r4,r5
000024  fb054416          MLS      r4,r5,r6,r4
000028  4294              CMP      r4,r2
00002a  d100              BNE      |L17.46|
                  |L17.44|
;;;89     	{
;;;90     		return;
;;;91     	}
;;;92     
;;;93     	// 队尾命令帧已满，退出
;;;94     	if (pCmdFrame->length >= DTA_UART_PROTOCOL_TX_CMD_FRAME_LENGTH_MAX)
;;;95     	{
;;;96     		return;
;;;97     	}
;;;98     	// 数据添加到帧末尾，并更新帧长度
;;;99     	pCmdFrame->buff[pCmdFrame->length] = data;
;;;100    	pCmdFrame->length++;
;;;101    }
00002c  bd70              POP      {r4-r6,pc}
                  |L17.46|
00002e  f8b04098          LDRH     r4,[r0,#0x98]         ;94
000032  2c96              CMP      r4,#0x96              ;94
000034  db00              BLT      |L17.56|
000036  e7f9              B        |L17.44|
                  |L17.56|
000038  f8b05098          LDRH     r5,[r0,#0x98]         ;99
00003c  1c84              ADDS     r4,r0,#2              ;99
00003e  5561              STRB     r1,[r4,r5]            ;99
000040  f8b04098          LDRH     r4,[r0,#0x98]         ;100
000044  1c64              ADDS     r4,r4,#1              ;100
000046  f8a04098          STRH     r4,[r0,#0x98]         ;100
00004a  bf00              NOP      
00004c  e7ee              B        |L17.44|
;;;102    
                          ENDP

00004e  0000              DCW      0x0000
                  |L17.80|
                          DCD      dtaUartProtocolCB
                  |L17.84|
                          DCD      dtaUartProtocolCB+0x3d4

                          AREA ||i.DTA_UART_PROTOCOL_TxAddFrame||, CODE, READONLY, ALIGN=2

                  DTA_UART_PROTOCOL_TxAddFrame PROC
;;;103    // 确认添加命令帧，即承认之前填充的数据为命令帧，将其添加到发送队列中，由main进行调度发送，本函数内会自动校正命令长度，并添加校验码
;;;104    void DTA_UART_PROTOCOL_TxAddFrame(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;105    {
;;;106    	uint16 cc = 0;
000002  2300              MOVS     r3,#0
;;;107    	uint16 i = 0;
000004  2200              MOVS     r2,#0
;;;108    	uint16 head = dtaUartProtocolCB.tx.head;
000006  4e29              LDR      r6,|L18.172|
000008  f8b646d6          LDRH     r4,[r6,#0x6d6]
;;;109    	uint16 end = dtaUartProtocolCB.tx.end;
00000c  f8b656d8          LDRH     r5,[r6,#0x6d8]
;;;110    	DTA_UART_PROTOCOL_TX_CMD_FRAME *pCmdFrame = &dtaUartProtocolCB.tx.cmdQueue[dtaUartProtocolCB.tx.end];
000010  f8b666d8          LDRH     r6,[r6,#0x6d8]
000014  274d              MOVS     r7,#0x4d
000016  437e              MULS     r6,r7,r6
000018  4f25              LDR      r7,|L18.176|
00001a  eb070046          ADD      r0,r7,r6,LSL #1
;;;111    	uint16 length = pCmdFrame->length;
00001e  f8b01098          LDRH     r1,[r0,#0x98]
;;;112    
;;;113    	// 发送缓冲区已满，不予接收
;;;114    	if ((end + 1) % DTA_UART_PROTOCOL_TX_QUEUE_SIZE == head)
000022  1c6e              ADDS     r6,r5,#1
000024  2705              MOVS     r7,#5
000026  fb96fcf7          SDIV     r12,r6,r7
00002a  fb07661c          MLS      r6,r7,r12,r6
00002e  42a6              CMP      r6,r4
000030  d100              BNE      |L18.52|
                  |L18.50|
;;;115    	{
;;;116    		return;
;;;117    	}
;;;118    
;;;119        // 队尾命令帧已满，退出
;;;120        if ((length >= DTA_UART_PROTOCOL_TX_CMD_FRAME_LENGTH_MAX) || (length + 1 >= DTA_UART_PROTOCOL_TX_CMD_FRAME_LENGTH_MAX)
;;;121                || (length + 2 >= DTA_UART_PROTOCOL_TX_CMD_FRAME_LENGTH_MAX) || (length + 3 >= DTA_UART_PROTOCOL_TX_CMD_FRAME_LENGTH_MAX))
;;;122        {
;;;123            pCmdFrame->length = 0;
;;;124    
;;;125            return;
;;;126        }
;;;127    
;;;128    	// 队尾命令帧已满，退出
;;;129    	if (length >= DTA_UART_PROTOCOL_TX_CMD_FRAME_LENGTH_MAX)
;;;130    	{
;;;131    		return;
;;;132    	}
;;;133    
;;;134    	// 重新设置数据长度，系统在准备数据时，填充的"数据长度"可以为任意值，并且不需要添加校验码，在这里重新设置为正确的值
;;;135    	pCmdFrame->buff[DTA_UART_PROTOCOL_CMD_LENGTH_INDEX] = length - 3; // 重设数据长度
;;;136    
;;;137    	for (i = 0; i < length; i++)
;;;138    	{
;;;139    		cc ^= pCmdFrame->buff[i];
;;;140    	}
;;;141    	pCmdFrame->buff[pCmdFrame->length++] = cc;
;;;142    
;;;143    	dtaUartProtocolCB.tx.end++;
;;;144    	dtaUartProtocolCB.tx.end %= DTA_UART_PROTOCOL_TX_QUEUE_SIZE;
;;;145    
;;;146    	// pCB->tx.cmdQueue[pCB->tx.end].length = 0;   //2015.12.2修改
;;;147    }
000032  bdf0              POP      {r4-r7,pc}
                  |L18.52|
000034  2996              CMP      r1,#0x96              ;120
000036  da08              BGE      |L18.74|
000038  1c4e              ADDS     r6,r1,#1              ;120
00003a  2e96              CMP      r6,#0x96              ;120
00003c  da05              BGE      |L18.74|
00003e  1c8e              ADDS     r6,r1,#2              ;121
000040  2e96              CMP      r6,#0x96              ;121
000042  da02              BGE      |L18.74|
000044  1cce              ADDS     r6,r1,#3              ;121
000046  2e96              CMP      r6,#0x96              ;121
000048  db03              BLT      |L18.82|
                  |L18.74|
00004a  2600              MOVS     r6,#0                 ;123
00004c  f8a06098          STRH     r6,[r0,#0x98]         ;123
000050  e7ef              B        |L18.50|
                  |L18.82|
000052  2996              CMP      r1,#0x96              ;129
000054  db00              BLT      |L18.88|
000056  e7ec              B        |L18.50|
                  |L18.88|
000058  1ece              SUBS     r6,r1,#3              ;135
00005a  7106              STRB     r6,[r0,#4]            ;135
00005c  2200              MOVS     r2,#0                 ;137
00005e  e004              B        |L18.106|
                  |L18.96|
000060  1c86              ADDS     r6,r0,#2              ;139
000062  5cb6              LDRB     r6,[r6,r2]            ;139
000064  4073              EORS     r3,r3,r6              ;139
000066  1c56              ADDS     r6,r2,#1              ;137
000068  b2b2              UXTH     r2,r6                 ;137
                  |L18.106|
00006a  428a              CMP      r2,r1                 ;137
00006c  dbf8              BLT      |L18.96|
00006e  f8b0c098          LDRH     r12,[r0,#0x98]        ;141
000072  f10c0601          ADD      r6,r12,#1             ;141
000076  f8a06098          STRH     r6,[r0,#0x98]         ;141
00007a  1c86              ADDS     r6,r0,#2              ;141
00007c  f806300c          STRB     r3,[r6,r12]           ;141
000080  4e0a              LDR      r6,|L18.172|
000082  f8b666d8          LDRH     r6,[r6,#0x6d8]        ;143
000086  1c76              ADDS     r6,r6,#1              ;143
000088  b2b7              UXTH     r7,r6                 ;143
00008a  4e08              LDR      r6,|L18.172|
00008c  f8a676d8          STRH     r7,[r6,#0x6d8]        ;143
000090  f8b666d8          LDRH     r6,[r6,#0x6d8]        ;144
000094  2705              MOVS     r7,#5                 ;144
000096  fb96fcf7          SDIV     r12,r6,r7             ;144
00009a  fb07661c          MLS      r6,r7,r12,r6          ;144
00009e  b2b7              UXTH     r7,r6                 ;144
0000a0  4e02              LDR      r6,|L18.172|
0000a2  f8a676d8          STRH     r7,[r6,#0x6d8]        ;144
0000a6  bf00              NOP      
0000a8  e7c3              B        |L18.50|
;;;148    
                          ENDP

0000aa  0000              DCW      0x0000
                  |L18.172|
                          DCD      dtaUartProtocolCB
                  |L18.176|
                          DCD      dtaUartProtocolCB+0x3d4

                          AREA ||i.DTA_UART_PROTOCOL_TxStateProcess||, CODE, READONLY, ALIGN=2

                  DTA_UART_PROTOCOL_TxStateProcess PROC
;;;238    // 协议层发送处理过程
;;;239    void DTA_UART_PROTOCOL_TxStateProcess(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;240    {
;;;241    	uint16 head = dtaUartProtocolCB.tx.head;
000004  4821              LDR      r0,|L19.140|
000006  f8b046d6          LDRH     r4,[r0,#0x6d6]
;;;242    	uint16 end = dtaUartProtocolCB.tx.end;
00000a  f8b056d8          LDRH     r5,[r0,#0x6d8]
;;;243    	uint16 length = dtaUartProtocolCB.tx.cmdQueue[head].length;
00000e  204d              MOVS     r0,#0x4d
000010  4360              MULS     r0,r4,r0
000012  491f              LDR      r1,|L19.144|
000014  eb010040          ADD      r0,r1,r0,LSL #1
000018  f8b06098          LDRH     r6,[r0,#0x98]
;;;244    	uint8 *pCmd = dtaUartProtocolCB.tx.cmdQueue[head].buff;
00001c  204d              MOVS     r0,#0x4d
00001e  4360              MULS     r0,r4,r0
000020  eb010040          ADD      r0,r1,r0,LSL #1
000024  1c87              ADDS     r7,r0,#2
;;;245    	uint16 localDeviceID = dtaUartProtocolCB.tx.cmdQueue[head].deviceID;
000026  204d              MOVS     r0,#0x4d
000028  4360              MULS     r0,r4,r0
00002a  f8318010          LDRH     r8,[r1,r0,LSL #1]
;;;246    
;;;247    	// 发送缓冲区为空，说明无数据
;;;248    	if (head == end)
00002e  42ac              CMP      r4,r5
000030  d101              BNE      |L19.54|
                  |L19.50|
;;;249    	{
;;;250    		return;
;;;251    	}
;;;252    
;;;253    	// 发送函数没有注册直接返回
;;;254    	if (NULL == dtaUartProtocolCB.sendDataThrowService)
;;;255    	{
;;;256    		return;
;;;257    	}
;;;258    
;;;259    	// 协议层有数据需要发送到驱动层
;;;260    	if (!(*dtaUartProtocolCB.sendDataThrowService)(localDeviceID, pCmd, length))
;;;261    	{
;;;262    		return;
;;;263    	}
;;;264    
;;;265    	// 发送环形队列更新位置
;;;266    	dtaUartProtocolCB.tx.cmdQueue[head].length = 0;
;;;267    	dtaUartProtocolCB.tx.head++;
;;;268    	dtaUartProtocolCB.tx.head %= DTA_UART_PROTOCOL_TX_QUEUE_SIZE;
;;;269    }
000032  e8bd81f0          POP      {r4-r8,pc}
                  |L19.54|
000036  4815              LDR      r0,|L19.140|
000038  f8d006e0          LDR      r0,[r0,#0x6e0]        ;254  ; dtaUartProtocolCB
00003c  b900              CBNZ     r0,|L19.64|
00003e  e7f8              B        |L19.50|
                  |L19.64|
000040  4812              LDR      r0,|L19.140|
000042  4632              MOV      r2,r6                 ;260
000044  4639              MOV      r1,r7                 ;260
000046  f8d036e0          LDR      r3,[r0,#0x6e0]        ;260  ; dtaUartProtocolCB
00004a  4640              MOV      r0,r8                 ;260
00004c  4798              BLX      r3                    ;260
00004e  b900              CBNZ     r0,|L19.82|
000050  e7ef              B        |L19.50|
                  |L19.82|
000052  2200              MOVS     r2,#0                 ;266
000054  204d              MOVS     r0,#0x4d              ;266
000056  4360              MULS     r0,r4,r0              ;266
000058  490d              LDR      r1,|L19.144|
00005a  eb010040          ADD      r0,r1,r0,LSL #1       ;266
00005e  f8a02098          STRH     r2,[r0,#0x98]         ;266
000062  480a              LDR      r0,|L19.140|
000064  f8b006d6          LDRH     r0,[r0,#0x6d6]        ;267
000068  1c40              ADDS     r0,r0,#1              ;267
00006a  b281              UXTH     r1,r0                 ;267
00006c  4807              LDR      r0,|L19.140|
00006e  f8a016d6          STRH     r1,[r0,#0x6d6]        ;267
000072  f8b006d6          LDRH     r0,[r0,#0x6d6]        ;268
000076  2105              MOVS     r1,#5                 ;268
000078  fb90f2f1          SDIV     r2,r0,r1              ;268
00007c  fb010012          MLS      r0,r1,r2,r0           ;268
000080  b281              UXTH     r1,r0                 ;268
000082  4802              LDR      r0,|L19.140|
000084  f8a016d6          STRH     r1,[r0,#0x6d6]        ;268
000088  bf00              NOP      
00008a  e7d2              B        |L19.50|
;;;270    
                          ENDP

                  |L19.140|
                          DCD      dtaUartProtocolCB
                  |L19.144|
                          DCD      dtaUartProtocolCB+0x3d4

                          AREA ||i.dtaUartProtocol_SendOnePacket||, CODE, READONLY, ALIGN=1

                  dtaUartProtocol_SendOnePacket PROC
;;;457    
;;;458    void dtaUartProtocol_SendOnePacket(uint32 flashAddr, uint32 addr)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;459    {
000004  b0a6              SUB      sp,sp,#0x98
000006  4606              MOV      r6,r0
000008  460c              MOV      r4,r1
;;;460    	uint8 addr1, addr2, addr3, addr4;
;;;461    	uint8 appUpdateOnePacket[150] = {0};
00000a  2198              MOVS     r1,#0x98
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       __aeabi_memclr4
;;;462    	uint8 appUpdateOnePacket_i = 0;
000012  2500              MOVS     r5,#0
;;;463        
;;;464    	addr1 = (addr & 0xFF000000) >> 24;
000014  0e27              LSRS     r7,r4,#24
;;;465    	addr2 = (addr & 0x00FF0000) >> 16;
000016  f3c44807          UBFX     r8,r4,#16,#8
;;;466    	addr3 = (addr & 0x0000FF00) >> 8;
00001a  f3c42907          UBFX     r9,r4,#8,#8
;;;467    	addr4 = (addr & 0x000000FF);
00001e  f0040aff          AND      r10,r4,#0xff
;;;468        
;;;469    	SPI_FLASH_ReadArray(appUpdateOnePacket, flashAddr + addr, 128); // 工具读取128字节
000022  1931              ADDS     r1,r6,r4
000024  2280              MOVS     r2,#0x80
000026  4668              MOV      r0,sp
000028  f7fffffe          BL       SPI_FLASH_ReadArray
;;;470    
;;;471    	DTA_UART_PROTOCOL_TxAddData(DTA_UART_PROTOCOL_CMD_HEAD); // 头
00002c  2055              MOVS     r0,#0x55
00002e  f7fffffe          BL       DTA_UART_PROTOCOL_TxAddData
;;;472        DTA_UART_PROTOCOL_TxAddData(DTA_UART_CMD_DUT_BOOT_WRITE_FLASH);
000032  20d1              MOVS     r0,#0xd1
000034  f7fffffe          BL       DTA_UART_PROTOCOL_TxAddData
;;;473    	DTA_UART_PROTOCOL_TxAddData(0x00);													   // 长度暂时为0
000038  2000              MOVS     r0,#0
00003a  f7fffffe          BL       DTA_UART_PROTOCOL_TxAddData
;;;474    	DTA_UART_PROTOCOL_TxAddData(addr1);													   // 添加地址
00003e  4638              MOV      r0,r7
000040  f7fffffe          BL       DTA_UART_PROTOCOL_TxAddData
;;;475    	DTA_UART_PROTOCOL_TxAddData(addr2);													   // 添加地址
000044  4640              MOV      r0,r8
000046  f7fffffe          BL       DTA_UART_PROTOCOL_TxAddData
;;;476    	DTA_UART_PROTOCOL_TxAddData(addr3);													   // 添加地址
00004a  4648              MOV      r0,r9
00004c  f7fffffe          BL       DTA_UART_PROTOCOL_TxAddData
;;;477    	DTA_UART_PROTOCOL_TxAddData(addr4);													   // 添加地址
000050  4650              MOV      r0,r10
000052  f7fffffe          BL       DTA_UART_PROTOCOL_TxAddData
;;;478    	for (appUpdateOnePacket_i = 0; appUpdateOnePacket_i < 128; appUpdateOnePacket_i++) // 添加数据
000056  bf00              NOP      
000058  e005              B        |L20.102|
                  |L20.90|
;;;479    	{
;;;480    		DTA_UART_PROTOCOL_TxAddData(appUpdateOnePacket[appUpdateOnePacket_i]);
00005a  f81d0005          LDRB     r0,[sp,r5]
00005e  f7fffffe          BL       DTA_UART_PROTOCOL_TxAddData
000062  1c68              ADDS     r0,r5,#1              ;478
000064  b2c5              UXTB     r5,r0                 ;478
                  |L20.102|
000066  2d80              CMP      r5,#0x80              ;478
000068  dbf7              BLT      |L20.90|
;;;481    	}
;;;482    	DTA_UART_PROTOCOL_TxAddFrame(); // 调整帧格式,修改长度和添加校验
00006a  f7fffffe          BL       DTA_UART_PROTOCOL_TxAddFrame
;;;483    }
00006e  b026              ADD      sp,sp,#0x98
000070  e8bd87f0          POP      {r4-r10,pc}
;;;484    
                          ENDP


                          AREA ||i.dtaUartProtocol_SendOnePacket_Hex||, CODE, READONLY, ALIGN=2

                  dtaUartProtocol_SendOnePacket_Hex PROC
;;;484    
;;;485    void dtaUartProtocol_SendOnePacket_Hex(uint32 flashAddr)
000000  b530              PUSH     {r4,r5,lr}
;;;486    {
000002  b0a7              SUB      sp,sp,#0x9c
000004  4605              MOV      r5,r0
;;;487    	uint8 appUpdateOnePacket[150] = {0};
000006  2198              MOVS     r1,#0x98
000008  a801              ADD      r0,sp,#4
00000a  f7fffffe          BL       __aeabi_memclr4
;;;488    	uint8 appUpdateOnePacket_i = 0;		
00000e  bf00              NOP      
;;;489        
;;;490        // app起始地址
;;;491    	SPI_FLASH_ReadArray(appUpdateOnePacket, flashAddr + dut_info.currentBootSize * 116, 116); // 工具读取 4+112 个字节
000010  481c              LDR      r0,|L21.132|
000012  6ac0              LDR      r0,[r0,#0x2c]  ; dut_info
000014  eb000240          ADD      r2,r0,r0,LSL #1
000018  ebc21040          RSB      r0,r2,r0,LSL #5
00001c  eb050180          ADD      r1,r5,r0,LSL #2
000020  2274              MOVS     r2,#0x74
000022  a801              ADD      r0,sp,#4
000024  f7fffffe          BL       SPI_FLASH_ReadArray
;;;492    	DTA_UART_PROTOCOL_TxAddData(DTA_UART_PROTOCOL_CMD_HEAD);										 // 添加命令头;//头
000028  2055              MOVS     r0,#0x55
00002a  f7fffffe          BL       DTA_UART_PROTOCOL_TxAddData
;;;493    	DTA_UART_PROTOCOL_TxAddData(DTA_UART_CMD_DUT_BOOT_WRITE_FLASH);									 // 命令
00002e  20d1              MOVS     r0,#0xd1
000030  f7fffffe          BL       DTA_UART_PROTOCOL_TxAddData
;;;494    	DTA_UART_PROTOCOL_TxAddData(0x00);															 // 添加临时数据长度
000034  2000              MOVS     r0,#0
000036  f7fffffe          BL       DTA_UART_PROTOCOL_TxAddData
;;;495    	DTA_UART_PROTOCOL_TxAddData(0);																 // 添加是否加密
00003a  2000              MOVS     r0,#0
00003c  f7fffffe          BL       DTA_UART_PROTOCOL_TxAddData
;;;496    	DTA_UART_PROTOCOL_TxAddData(0);																 // 添加密钥
000040  2000              MOVS     r0,#0
000042  f7fffffe          BL       DTA_UART_PROTOCOL_TxAddData
;;;497    	DTA_UART_PROTOCOL_TxAddData(appUpdateOnePacket[0]);											 // 添加地址
000046  f89d0004          LDRB     r0,[sp,#4]
00004a  f7fffffe          BL       DTA_UART_PROTOCOL_TxAddData
;;;498    	DTA_UART_PROTOCOL_TxAddData(appUpdateOnePacket[1]);											 // 添加地址
00004e  f89d0005          LDRB     r0,[sp,#5]
000052  f7fffffe          BL       DTA_UART_PROTOCOL_TxAddData
;;;499    	DTA_UART_PROTOCOL_TxAddData(appUpdateOnePacket[2]);											 // 添加地址
000056  f89d0006          LDRB     r0,[sp,#6]
00005a  f7fffffe          BL       DTA_UART_PROTOCOL_TxAddData
;;;500    	DTA_UART_PROTOCOL_TxAddData(appUpdateOnePacket[3]);											 // 添加地址
00005e  f89d0007          LDRB     r0,[sp,#7]
000062  f7fffffe          BL       DTA_UART_PROTOCOL_TxAddData
;;;501    
;;;502    	for (appUpdateOnePacket_i = 0; appUpdateOnePacket_i < 112; appUpdateOnePacket_i++) // 添加数据
000066  2400              MOVS     r4,#0
000068  e006              B        |L21.120|
                  |L21.106|
;;;503    	{
;;;504    		DTA_UART_PROTOCOL_TxAddData(appUpdateOnePacket[appUpdateOnePacket_i + 4]);
00006a  aa01              ADD      r2,sp,#4
00006c  1d21              ADDS     r1,r4,#4
00006e  5c50              LDRB     r0,[r2,r1]
000070  f7fffffe          BL       DTA_UART_PROTOCOL_TxAddData
000074  1c60              ADDS     r0,r4,#1              ;502
000076  b2c4              UXTB     r4,r0                 ;502
                  |L21.120|
000078  2c70              CMP      r4,#0x70              ;502
00007a  dbf6              BLT      |L21.106|
;;;505    	}
;;;506    	DTA_UART_PROTOCOL_TxAddFrame(); // 调整帧格式,修改长度和添加校验
00007c  f7fffffe          BL       DTA_UART_PROTOCOL_TxAddFrame
;;;507    }
000080  b027              ADD      sp,sp,#0x9c
000082  bd30              POP      {r4,r5,pc}
;;;508    
                          ENDP

                  |L21.132|
                          DCD      dut_info

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  dtaUartProtocolCB
                          %        1768

;*** Start embedded assembler ***

#line 1 "User\\DtaUartProtocol.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___17_DtaUartProtocol_c_f3e342c2____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___17_DtaUartProtocol_c_f3e342c2____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___17_DtaUartProtocol_c_f3e342c2____REVSH|
#line 128
|__asm___17_DtaUartProtocol_c_f3e342c2____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
