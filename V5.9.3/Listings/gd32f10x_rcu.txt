; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\gd32f10x_rcu.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\gd32f10x_rcu.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -I.\User\qrencode -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.3\Device\Include -D__MICROLIB -D__UVISION_VERSION=539 -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\gd32f10x_rcu.crf Libraries\src\gd32f10x_rcu.c]
                          THUMB

                          AREA ||i.rcu_adc_clock_config||, CODE, READONLY, ALIGN=2

                  rcu_adc_clock_config PROC
;;;527    */
;;;528    void rcu_adc_clock_config(uint32_t adc_psc)
000000  4a0f              LDR      r2,|L1.64|
;;;529    {
;;;530        uint32_t reg0;
;;;531    
;;;532        /* reset the ADCPSC bits */
;;;533        reg0 = RCU_CFG0;
000002  6851              LDR      r1,[r2,#4]
;;;534        reg0 &= ~(RCU_CFG0_ADCPSC_2 | RCU_CFG0_ADCPSC);
000004  4a0f              LDR      r2,|L1.68|
000006  4011              ANDS     r1,r1,r2
;;;535    
;;;536        /* set the ADC prescaler factor */
;;;537        switch(adc_psc){
000008  2808              CMP      r0,#8
00000a  d214              BCS      |L1.54|
00000c  e8dff000          TBB      [pc,r0]
000010  04050607          DCB      0x04,0x05,0x06,0x07
000014  130a130b          DCB      0x13,0x0a,0x13,0x0b
;;;538            case RCU_CKADC_CKAPB2_DIV2:
;;;539            case RCU_CKADC_CKAPB2_DIV4:
000018  bf00              NOP      
;;;540            case RCU_CKADC_CKAPB2_DIV6:
00001a  bf00              NOP      
;;;541            case RCU_CKADC_CKAPB2_DIV8:
00001c  bf00              NOP      
;;;542                reg0 |= (adc_psc << 14);
00001e  ea413180          ORR      r1,r1,r0,LSL #14
;;;543                break;
000022  e009              B        |L1.56|
;;;544    
;;;545            case RCU_CKADC_CKAPB2_DIV12:
;;;546            case RCU_CKADC_CKAPB2_DIV16:
000024  bf00              NOP      
;;;547                adc_psc &= ~BIT(2);
000026  f0200004          BIC      r0,r0,#4
;;;548                reg0 |= (adc_psc << 14 | RCU_CFG0_ADCPSC_2);
00002a  f04f5280          MOV      r2,#0x10000000
00002e  ea423280          ORR      r2,r2,r0,LSL #14
000032  4311              ORRS     r1,r1,r2
;;;549                break;
000034  e000              B        |L1.56|
                  |L1.54|
;;;550    
;;;551            default:
;;;552                break;
000036  bf00              NOP      
                  |L1.56|
000038  bf00              NOP                            ;543
;;;553        }
;;;554    
;;;555        /* set the register */
;;;556        RCU_CFG0 = reg0;
00003a  4a01              LDR      r2,|L1.64|
00003c  6051              STR      r1,[r2,#4]
;;;557    }
00003e  4770              BX       lr
;;;558    
                          ENDP

                  |L1.64|
                          DCD      0x40021000
                  |L1.68|
                          DCD      0xefff3fff

                          AREA ||i.rcu_ahb_clock_config||, CODE, READONLY, ALIGN=2

                  rcu_ahb_clock_config PROC
;;;306    */
;;;307    void rcu_ahb_clock_config(uint32_t ck_ahb)
000000  4a04              LDR      r2,|L2.20|
;;;308    {
;;;309        uint32_t reg;
;;;310        
;;;311        reg = RCU_CFG0;
000002  6851              LDR      r1,[r2,#4]
;;;312    
;;;313        /* reset the AHBPSC bits and set according to ck_ahb */
;;;314        reg &= ~RCU_CFG0_AHBPSC;
000004  f02101f0          BIC      r1,r1,#0xf0
;;;315        RCU_CFG0 = (reg | ck_ahb);
000008  ea410200          ORR      r2,r1,r0
00000c  4b01              LDR      r3,|L2.20|
00000e  605a              STR      r2,[r3,#4]
;;;316    }
000010  4770              BX       lr
;;;317    
                          ENDP

000012  0000              DCW      0x0000
                  |L2.20|
                          DCD      0x40021000

                          AREA ||i.rcu_all_reset_flag_clear||, CODE, READONLY, ALIGN=2

                  rcu_all_reset_flag_clear PROC
;;;682    */
;;;683    void rcu_all_reset_flag_clear(void)
000000  4803              LDR      r0,|L3.16|
;;;684    {
;;;685        RCU_RSTSCK |= RCU_RSTSCK_RSTFC;
000002  6a40              LDR      r0,[r0,#0x24]
000004  f0407080          ORR      r0,r0,#0x1000000
000008  4901              LDR      r1,|L3.16|
00000a  6248              STR      r0,[r1,#0x24]
;;;686    }
00000c  4770              BX       lr
;;;687    
                          ENDP

00000e  0000              DCW      0x0000
                  |L3.16|
                          DCD      0x40021000

                          AREA ||i.rcu_apb1_clock_config||, CODE, READONLY, ALIGN=2

                  rcu_apb1_clock_config PROC
;;;329    */
;;;330    void rcu_apb1_clock_config(uint32_t ck_apb1)
000000  4a04              LDR      r2,|L4.20|
;;;331    {
;;;332        uint32_t reg;
;;;333        
;;;334        reg = RCU_CFG0;
000002  6851              LDR      r1,[r2,#4]
;;;335    
;;;336        /* reset the APB1PSC and set according to ck_apb1 */
;;;337        reg &= ~RCU_CFG0_APB1PSC;
000004  f42161e0          BIC      r1,r1,#0x700
;;;338        RCU_CFG0 = (reg | ck_apb1);
000008  ea410200          ORR      r2,r1,r0
00000c  4b01              LDR      r3,|L4.20|
00000e  605a              STR      r2,[r3,#4]
;;;339    }
000010  4770              BX       lr
;;;340    
                          ENDP

000012  0000              DCW      0x0000
                  |L4.20|
                          DCD      0x40021000

                          AREA ||i.rcu_apb2_clock_config||, CODE, READONLY, ALIGN=2

                  rcu_apb2_clock_config PROC
;;;352    */
;;;353    void rcu_apb2_clock_config(uint32_t ck_apb2)
000000  4a04              LDR      r2,|L5.20|
;;;354    {
;;;355        uint32_t reg;
;;;356        
;;;357        reg = RCU_CFG0;
000002  6851              LDR      r1,[r2,#4]
;;;358    
;;;359        /* reset the APB2PSC and set according to ck_apb2 */
;;;360        reg &= ~RCU_CFG0_APB2PSC;
000004  f4215160          BIC      r1,r1,#0x3800
;;;361        RCU_CFG0 = (reg | ck_apb2);
000008  ea410200          ORR      r2,r1,r0
00000c  4b01              LDR      r3,|L5.20|
00000e  605a              STR      r2,[r3,#4]
;;;362    }
000010  4770              BX       lr
;;;363    
                          ENDP

000012  0000              DCW      0x0000
                  |L5.20|
                          DCD      0x40021000

                          AREA ||i.rcu_bkp_reset_disable||, CODE, READONLY, ALIGN=2

                  rcu_bkp_reset_disable PROC
;;;259    */
;;;260    void rcu_bkp_reset_disable(void)
000000  4803              LDR      r0,|L6.16|
;;;261    {
;;;262        RCU_BDCTL &= ~RCU_BDCTL_BKPRST;
000002  6a00              LDR      r0,[r0,#0x20]
000004  f4203080          BIC      r0,r0,#0x10000
000008  4901              LDR      r1,|L6.16|
00000a  6208              STR      r0,[r1,#0x20]
;;;263    }
00000c  4770              BX       lr
;;;264    
                          ENDP

00000e  0000              DCW      0x0000
                  |L6.16|
                          DCD      0x40021000

                          AREA ||i.rcu_bkp_reset_enable||, CODE, READONLY, ALIGN=2

                  rcu_bkp_reset_enable PROC
;;;248    */
;;;249    void rcu_bkp_reset_enable(void)
000000  4803              LDR      r0,|L7.16|
;;;250    {
;;;251        RCU_BDCTL |= RCU_BDCTL_BKPRST;
000002  6a00              LDR      r0,[r0,#0x20]
000004  f4403080          ORR      r0,r0,#0x10000
000008  4901              LDR      r1,|L7.16|
00000a  6208              STR      r0,[r1,#0x20]
;;;252    }
00000c  4770              BX       lr
;;;253    
                          ENDP

00000e  0000              DCW      0x0000
                  |L7.16|
                          DCD      0x40021000

                          AREA ||i.rcu_ckout0_config||, CODE, READONLY, ALIGN=2

                  rcu_ckout0_config PROC
;;;379    */
;;;380    void rcu_ckout0_config(uint32_t ckout0_src)
000000  4a04              LDR      r2,|L8.20|
;;;381    {
;;;382        uint32_t reg;
;;;383        
;;;384        reg = RCU_CFG0;
000002  6851              LDR      r1,[r2,#4]
;;;385    
;;;386        /* reset the CKOUT0SRC, set according to ckout0_src */
;;;387        reg &= ~RCU_CFG0_CKOUT0SEL;
000004  f02161e0          BIC      r1,r1,#0x7000000
;;;388        RCU_CFG0 = (reg | ckout0_src);
000008  ea410200          ORR      r2,r1,r0
00000c  4b01              LDR      r3,|L8.20|
00000e  605a              STR      r2,[r3,#4]
;;;389    }
000010  4770              BX       lr
;;;390    
                          ENDP

000012  0000              DCW      0x0000
                  |L8.20|
                          DCD      0x40021000

                          AREA ||i.rcu_clock_freq_get||, CODE, READONLY, ALIGN=2

                  rcu_clock_freq_get PROC
;;;1074   */
;;;1075   uint32_t rcu_clock_freq_get(rcu_clock_freq_enum clock)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1076   {
000004  b08b              SUB      sp,sp,#0x2c
000006  4607              MOV      r7,r0
;;;1077       uint32_t sws, ck_freq = 0U;
000008  2000              MOVS     r0,#0
00000a  9009              STR      r0,[sp,#0x24]
;;;1078       uint32_t cksys_freq, ahb_freq, apb1_freq, apb2_freq;
;;;1079       uint32_t pllsel, predv0sel, pllmf,ck_src, idx, clk_exp;
;;;1080   #ifdef GD32F10X_CL
;;;1081       uint32_t predv0, predv1, pll1mf;
;;;1082   #endif /* GD32F10X_CL */
;;;1083   
;;;1084       /* exponent of AHB, APB1 and APB2 clock divider */
;;;1085       uint8_t ahb_exp[16] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 6, 7, 8, 9};
00000c  a03e              ADR      r0,|L9.264|
00000e  e8904c00          LDM      r0,{r10,r11,lr}
000012  68c0              LDR      r0,[r0,#0xc]
000014  e9cdbe05          STRD     r11,lr,[sp,#0x14]
000018  f8cda010          STR      r10,[sp,#0x10]
00001c  9007              STR      r0,[sp,#0x1c]
;;;1086       uint8_t apb1_exp[8] = {0, 0, 0, 0, 1, 2, 3, 4};
00001e  f20f0aec          ADR      r10,|L9.268|
000022  e9da0a00          LDRD     r0,r10,[r10,#0]
000026  e9cd0a02          STRD     r0,r10,[sp,#8]
;;;1087       uint8_t apb2_exp[8] = {0, 0, 0, 0, 1, 2, 3, 4};
00002a  f20f0ae0          ADR      r10,|L9.268|
00002e  e9da0a00          LDRD     r0,r10,[r10,#0]
000032  e9cd0a00          STRD     r0,r10,[sp,#0]
;;;1088   
;;;1089       sws = GET_BITS(RCU_CFG0, 2, 3);
000036  4838              LDR      r0,|L9.280|
000038  6840              LDR      r0,[r0,#4]
00003a  f3c00081          UBFX     r0,r0,#2,#2
00003e  900a              STR      r0,[sp,#0x28]
;;;1090       switch(sws){
000040  980a              LDR      r0,[sp,#0x28]
000042  b120              CBZ      r0,|L9.78|
000044  2801              CMP      r0,#1
000046  d004              BEQ      |L9.82|
000048  2802              CMP      r0,#2
00004a  d129              BNE      |L9.160|
00004c  e003              B        |L9.86|
                  |L9.78|
;;;1091       /* IRC8M is selected as CK_SYS */
;;;1092       case SEL_IRC8M:
;;;1093           cksys_freq = IRC8M_VALUE;
00004e  4933              LDR      r1,|L9.284|
;;;1094           break;
000050  e028              B        |L9.164|
                  |L9.82|
;;;1095       /* HXTAL is selected as CK_SYS */
;;;1096       case SEL_HXTAL:
;;;1097           cksys_freq = HXTAL_VALUE;
000052  4932              LDR      r1,|L9.284|
;;;1098           break;
000054  e026              B        |L9.164|
                  |L9.86|
;;;1099       /* PLL is selected as CK_SYS */
;;;1100       case SEL_PLL:
;;;1101           /* PLL clock source selection, HXTAL or IRC8M/2 */
;;;1102           pllsel = (RCU_CFG0 & RCU_CFG0_PLLSEL);
000056  4830              LDR      r0,|L9.280|
000058  6840              LDR      r0,[r0,#4]
00005a  f4003880          AND      r8,r0,#0x10000
;;;1103   
;;;1104           if(RCU_PLLSRC_HXTAL == pllsel) {
00005e  f5b83f80          CMP      r8,#0x10000
000062  d109              BNE      |L9.120|
;;;1105               /* PLL clock source is HXTAL */
;;;1106               ck_src = HXTAL_VALUE;
000064  4c2d              LDR      r4,|L9.284|
;;;1107   
;;;1108   #if (defined(GD32F10X_MD) || defined(GD32F10X_HD) || defined(GD32F10X_XD))
;;;1109               predv0sel = (RCU_CFG0 & RCU_CFG0_PREDV0);
000066  482c              LDR      r0,|L9.280|
000068  6840              LDR      r0,[r0,#4]
00006a  f4003900          AND      r9,r0,#0x20000
;;;1110               /* PREDV0 input source clock divided by 2 */
;;;1111               if(RCU_CFG0_PREDV0 == predv0sel){
00006e  f5b93f00          CMP      r9,#0x20000
000072  d102              BNE      |L9.122|
;;;1112                   ck_src = HXTAL_VALUE/2U;
000074  1064              ASRS     r4,r4,#1
000076  e000              B        |L9.122|
                  |L9.120|
;;;1113               }
;;;1114   #elif defined(GD32F10X_CL)
;;;1115               predv0sel = (RCU_CFG1 & RCU_CFG1_PREDV0SEL);
;;;1116               /* source clock use PLL1 */
;;;1117               if(RCU_PREDV0SRC_CKPLL1 == predv0sel){
;;;1118                   predv1 = (uint32_t)((RCU_CFG1 & RCU_CFG1_PREDV1) >> 4) + 1U;
;;;1119                   pll1mf = (uint32_t)((RCU_CFG1 & RCU_CFG1_PLL1MF) >> 8) + 2U;
;;;1120                   if(17U == pll1mf){
;;;1121                       pll1mf = 20U;
;;;1122                   }
;;;1123                   ck_src = (ck_src / predv1) * pll1mf;
;;;1124               }
;;;1125               predv0 = (RCU_CFG1 & RCU_CFG1_PREDV0) + 1U;
;;;1126               ck_src /= predv0;
;;;1127   #endif /* GD32F10X_HD and GD32F10X_XD */
;;;1128           }else{
;;;1129               /* PLL clock source is IRC8M/2 */
;;;1130               ck_src = IRC8M_VALUE/2U;
000078  4c29              LDR      r4,|L9.288|
                  |L9.122|
;;;1131           }
;;;1132   
;;;1133           /* PLL multiplication factor */
;;;1134           pllmf = GET_BITS(RCU_CFG0, 18, 21);
00007a  4827              LDR      r0,|L9.280|
00007c  6840              LDR      r0,[r0,#4]
00007e  f3c04283          UBFX     r2,r0,#18,#4
;;;1135           if((RCU_CFG0 & RCU_CFG0_PLLMF_4)){
000082  4825              LDR      r0,|L9.280|
000084  6840              LDR      r0,[r0,#4]
000086  f0006000          AND      r0,r0,#0x8000000
00008a  b108              CBZ      r0,|L9.144|
;;;1136               pllmf |= 0x10U;
00008c  f0420210          ORR      r2,r2,#0x10
                  |L9.144|
;;;1137           }
;;;1138           if(pllmf < 15U){
000090  2a0f              CMP      r2,#0xf
000092  d201              BCS      |L9.152|
;;;1139               pllmf += 2U;
000094  1c92              ADDS     r2,r2,#2
000096  e000              B        |L9.154|
                  |L9.152|
;;;1140           }else{
;;;1141               pllmf += 1U;
000098  1c52              ADDS     r2,r2,#1
                  |L9.154|
;;;1142           }
;;;1143   
;;;1144           cksys_freq = ck_src * pllmf;
00009a  fb04f102          MUL      r1,r4,r2
;;;1145   
;;;1146       #ifdef GD32F10X_CL
;;;1147           if(15U == pllmf){
;;;1148               /* PLL source clock multiply by 6.5 */
;;;1149               cksys_freq = ck_src * 6U + ck_src / 2U;
;;;1150           }
;;;1151       #endif /* GD32F10X_CL */
;;;1152   
;;;1153           break;
00009e  e001              B        |L9.164|
                  |L9.160|
;;;1154       /* IRC8M is selected as CK_SYS */
;;;1155       default:
;;;1156           cksys_freq = IRC8M_VALUE;
0000a0  491e              LDR      r1,|L9.284|
;;;1157           break;
0000a2  bf00              NOP      
                  |L9.164|
0000a4  bf00              NOP                            ;1094
;;;1158       }
;;;1159   
;;;1160       /* calculate AHB clock frequency */
;;;1161       idx = GET_BITS(RCU_CFG0, 4, 7);
0000a6  481c              LDR      r0,|L9.280|
0000a8  6840              LDR      r0,[r0,#4]
0000aa  f3c01503          UBFX     r5,r0,#4,#4
;;;1162       clk_exp = ahb_exp[idx];
0000ae  a804              ADD      r0,sp,#0x10
0000b0  5d46              LDRB     r6,[r0,r5]
;;;1163       ahb_freq = cksys_freq >> clk_exp;
0000b2  fa21f306          LSR      r3,r1,r6
;;;1164       
;;;1165       /* calculate APB1 clock frequency */
;;;1166       idx = GET_BITS(RCU_CFG0, 8, 10);
0000b6  4818              LDR      r0,|L9.280|
0000b8  6840              LDR      r0,[r0,#4]
0000ba  f3c02502          UBFX     r5,r0,#8,#3
;;;1167       clk_exp = apb1_exp[idx];
0000be  a802              ADD      r0,sp,#8
0000c0  5d46              LDRB     r6,[r0,r5]
;;;1168       apb1_freq = ahb_freq >> clk_exp;
0000c2  fa23fc06          LSR      r12,r3,r6
;;;1169       
;;;1170       /* calculate APB2 clock frequency */
;;;1171       idx = GET_BITS(RCU_CFG0, 11, 13);
0000c6  4814              LDR      r0,|L9.280|
0000c8  6840              LDR      r0,[r0,#4]
0000ca  f3c025c2          UBFX     r5,r0,#11,#3
;;;1172       clk_exp = apb2_exp[idx];
0000ce  f81d6005          LDRB     r6,[sp,r5]
;;;1173       apb2_freq = ahb_freq >> clk_exp;
0000d2  fa23f006          LSR      r0,r3,r6
0000d6  9008              STR      r0,[sp,#0x20]
;;;1174       
;;;1175       /* return the clocks frequency */
;;;1176       switch(clock){
0000d8  b137              CBZ      r7,|L9.232|
0000da  2f01              CMP      r7,#1
0000dc  d006              BEQ      |L9.236|
0000de  2f02              CMP      r7,#2
0000e0  d006              BEQ      |L9.240|
0000e2  2f03              CMP      r7,#3
0000e4  d10a              BNE      |L9.252|
0000e6  e006              B        |L9.246|
                  |L9.232|
;;;1177       case CK_SYS:
;;;1178           ck_freq = cksys_freq;
0000e8  9109              STR      r1,[sp,#0x24]
;;;1179           break;
0000ea  e008              B        |L9.254|
                  |L9.236|
;;;1180       case CK_AHB:
;;;1181           ck_freq = ahb_freq;
0000ec  9309              STR      r3,[sp,#0x24]
;;;1182           break;
0000ee  e006              B        |L9.254|
                  |L9.240|
;;;1183       case CK_APB1:
;;;1184           ck_freq = apb1_freq;
0000f0  f8cdc024          STR      r12,[sp,#0x24]
;;;1185           break;
0000f4  e003              B        |L9.254|
                  |L9.246|
;;;1186       case CK_APB2:
;;;1187           ck_freq = apb2_freq;
0000f6  9808              LDR      r0,[sp,#0x20]
0000f8  9009              STR      r0,[sp,#0x24]
;;;1188           break;
0000fa  e000              B        |L9.254|
                  |L9.252|
;;;1189       default:
;;;1190           break;
0000fc  bf00              NOP      
                  |L9.254|
0000fe  bf00              NOP                            ;1179
;;;1191       }
;;;1192       return ck_freq;
000100  9809              LDR      r0,[sp,#0x24]
;;;1193   }
000102  b00b              ADD      sp,sp,#0x2c
000104  e8bd8ff0          POP      {r4-r11,pc}
                          ENDP

                  |L9.264|
000108  00                DCB      0
000109  00                DCB      0
00010a  00                DCB      0
00010b  00                DCB      0
                  |L9.268|
00010c  00                DCB      0
00010d  00                DCB      0
00010e  00                DCB      0
00010f  00                DCB      0
000110  01020304          DCB      1,2,3,4,6,"\a\b\t"
000114  06070809
                  |L9.280|
                          DCD      0x40021000
                  |L9.284|
                          DCD      0x007a1200
                  |L9.288|
                          DCD      0x003d0900

                          AREA ||i.rcu_deepsleep_voltage_set||, CODE, READONLY, ALIGN=2

                  rcu_deepsleep_voltage_set PROC
;;;1057   */
;;;1058   void rcu_deepsleep_voltage_set(uint32_t dsvol)
000000  f0000007          AND      r0,r0,#7
;;;1059   {    
;;;1060       dsvol &= RCU_DSV_DSLPVS;
;;;1061       RCU_DSV = dsvol;
000004  4901              LDR      r1,|L10.12|
000006  6348              STR      r0,[r1,#0x34]
;;;1062   }
000008  4770              BX       lr
;;;1063   
                          ENDP

00000a  0000              DCW      0x0000
                  |L10.12|
                          DCD      0x40021000

                          AREA ||i.rcu_deinit||, CODE, READONLY, ALIGN=2

                  rcu_deinit PROC
;;;55     */
;;;56     void rcu_deinit(void)
000000  b500              PUSH     {lr}
;;;57     {
;;;58         /* enable IRC8M */
;;;59         RCU_CTL |= RCU_CTL_IRC8MEN;
000002  480f              LDR      r0,|L11.64|
000004  6800              LDR      r0,[r0,#0]
000006  f0400001          ORR      r0,r0,#1
00000a  490d              LDR      r1,|L11.64|
00000c  6008              STR      r0,[r1,#0]
;;;60         rcu_osci_stab_wait(RCU_IRC8M);
00000e  2000              MOVS     r0,#0
000010  f7fffffe          BL       rcu_osci_stab_wait
;;;61     
;;;62         /* reset CFG0 register */
;;;63     #if (defined(GD32F10X_MD) || defined(GD32F10X_HD) || defined(GD32F10X_XD))
;;;64         RCU_CFG0 &= ~(RCU_CFG0_SCS | RCU_CFG0_AHBPSC | RCU_CFG0_APB1PSC | RCU_CFG0_APB2PSC |
000014  480a              LDR      r0,|L11.64|
000016  6840              LDR      r0,[r0,#4]
000018  490a              LDR      r1,|L11.68|
00001a  4008              ANDS     r0,r0,r1
00001c  4908              LDR      r1,|L11.64|
00001e  6048              STR      r0,[r1,#4]
;;;65                       RCU_CFG0_ADCPSC | RCU_CFG0_PLLSEL | RCU_CFG0_PREDV0 | RCU_CFG0_PLLMF |
;;;66                       RCU_CFG0_USBDPSC | RCU_CFG0_CKOUT0SEL | RCU_CFG0_PLLMF_4 | RCU_CFG0_ADCPSC_2);
;;;67     #elif defined(GD32F10X_CL)
;;;68         RCU_CFG0 &= ~(RCU_CFG0_SCS | RCU_CFG0_AHBPSC | RCU_CFG0_APB1PSC | RCU_CFG0_APB2PSC |
;;;69                       RCU_CFG0_ADCPSC | RCU_CFG0_PLLSEL | RCU_CFG0_PREDV0_LSB | RCU_CFG0_PLLMF |
;;;70                       RCU_CFG0_USBFSPSC | RCU_CFG0_CKOUT0SEL | RCU_CFG0_ADCPSC_2 | RCU_CFG0_PLLMF_4);
;;;71     #endif /* GD32F10X_MD and GD32F10X_HD and GD32F10X_XD */
;;;72         /* reset CTL register */
;;;73         RCU_CTL &= ~(RCU_CTL_HXTALEN | RCU_CTL_CKMEN | RCU_CTL_PLLEN);
000020  4608              MOV      r0,r1
000022  6800              LDR      r0,[r0,#0]
000024  4908              LDR      r1,|L11.72|
000026  4008              ANDS     r0,r0,r1
000028  4905              LDR      r1,|L11.64|
00002a  6008              STR      r0,[r1,#0]
;;;74         RCU_CTL &= ~RCU_CTL_HXTALBPS;
00002c  4608              MOV      r0,r1
00002e  6800              LDR      r0,[r0,#0]
000030  f4202080          BIC      r0,r0,#0x40000
000034  6008              STR      r0,[r1,#0]
;;;75     #ifdef GD32F10X_CL
;;;76         RCU_CTL &= ~(RCU_CTL_PLL1EN | RCU_CTL_PLL2EN);
;;;77     #endif /* GD32F10X_CL */
;;;78     
;;;79         /* reset INT and CFG1 register */
;;;80     #if (defined(GD32F10X_MD) || defined(GD32F10X_HD) || defined(GD32F10X_XD))
;;;81         RCU_INT = 0x009f0000U;
000036  f44f001f          MOV      r0,#0x9f0000
00003a  6088              STR      r0,[r1,#8]
;;;82     #elif defined(GD32F10X_CL)
;;;83         RCU_INT = 0x00ff0000U;
;;;84         RCU_CFG1 &= ~(RCU_CFG1_PREDV0 | RCU_CFG1_PREDV1 | RCU_CFG1_PLL1MF | RCU_CFG1_PLL2MF |
;;;85                       RCU_CFG1_PREDV0SEL | RCU_CFG1_I2S1SEL | RCU_CFG1_I2S2SEL);
;;;86     #endif /* GD32F10X_MD and GD32F10X_HD and GD32F10X_XD */
;;;87     }
00003c  bd00              POP      {pc}
;;;88     
                          ENDP

00003e  0000              DCW      0x0000
                  |L11.64|
                          DCD      0x40021000
                  |L11.68|
                          DCD      0xe000000c
                  |L11.72|
                          DCD      0xfef6ffff

                          AREA ||i.rcu_flag_get||, CODE, READONLY, ALIGN=2

                  rcu_flag_get PROC
;;;666    */
;;;667    FlagStatus rcu_flag_get(rcu_flag_enum flag)
000000  4601              MOV      r1,r0
;;;668    {
;;;669        /* get the rcu flag */
;;;670        if(RESET != (RCU_REG_VAL(flag) & BIT(RCU_BIT_POS(flag)))){
000002  4a07              LDR      r2,|L12.32|
000004  eb021091          ADD      r0,r2,r1,LSR #6
000008  6800              LDR      r0,[r0,#0]
00000a  f001031f          AND      r3,r1,#0x1f
00000e  2201              MOVS     r2,#1
000010  409a              LSLS     r2,r2,r3
000012  4010              ANDS     r0,r0,r2
000014  b108              CBZ      r0,|L12.26|
;;;671            return SET;
000016  2001              MOVS     r0,#1
                  |L12.24|
;;;672        }else{
;;;673            return RESET;
;;;674        }
;;;675    }
000018  4770              BX       lr
                  |L12.26|
00001a  2000              MOVS     r0,#0                 ;673
00001c  e7fc              B        |L12.24|
;;;676    
                          ENDP

00001e  0000              DCW      0x0000
                  |L12.32|
                          DCD      0x40021000

                          AREA ||i.rcu_hxtal_clock_monitor_disable||, CODE, READONLY, ALIGN=2

                  rcu_hxtal_clock_monitor_disable PROC
;;;1025   */
;;;1026   void rcu_hxtal_clock_monitor_disable(void)
000000  4803              LDR      r0,|L13.16|
;;;1027   {
;;;1028       RCU_CTL &= ~RCU_CTL_CKMEN;
000002  6800              LDR      r0,[r0,#0]
000004  f4202000          BIC      r0,r0,#0x80000
000008  4901              LDR      r1,|L13.16|
00000a  6008              STR      r0,[r1,#0]
;;;1029   }
00000c  4770              BX       lr
;;;1030   
                          ENDP

00000e  0000              DCW      0x0000
                  |L13.16|
                          DCD      0x40021000

                          AREA ||i.rcu_hxtal_clock_monitor_enable||, CODE, READONLY, ALIGN=2

                  rcu_hxtal_clock_monitor_enable PROC
;;;1014   
;;;1015   void rcu_hxtal_clock_monitor_enable(void)
000000  4803              LDR      r0,|L14.16|
;;;1016   {
;;;1017       RCU_CTL |= RCU_CTL_CKMEN;
000002  6800              LDR      r0,[r0,#0]
000004  f4402000          ORR      r0,r0,#0x80000
000008  4901              LDR      r1,|L14.16|
00000a  6008              STR      r0,[r1,#0]
;;;1018   }
00000c  4770              BX       lr
;;;1019   
                          ENDP

00000e  0000              DCW      0x0000
                  |L14.16|
                          DCD      0x40021000

                          AREA ||i.rcu_interrupt_disable||, CODE, READONLY, ALIGN=2

                  rcu_interrupt_disable PROC
;;;765    */
;;;766    void rcu_interrupt_disable(rcu_int_enum stab_int)
000000  4a06              LDR      r2,|L15.28|
;;;767    {
;;;768        RCU_REG_VAL(stab_int) &= ~BIT(RCU_BIT_POS(stab_int));
000002  eb021190          ADD      r1,r2,r0,LSR #6
000006  6809              LDR      r1,[r1,#0]
000008  f000031f          AND      r3,r0,#0x1f
00000c  2201              MOVS     r2,#1
00000e  409a              LSLS     r2,r2,r3
000010  4391              BICS     r1,r1,r2
000012  4b02              LDR      r3,|L15.28|
000014  eb031290          ADD      r2,r3,r0,LSR #6
000018  6011              STR      r1,[r2,#0]
;;;769    }
00001a  4770              BX       lr
;;;770    
                          ENDP

                  |L15.28|
                          DCD      0x40021000

                          AREA ||i.rcu_interrupt_enable||, CODE, READONLY, ALIGN=2

                  rcu_interrupt_enable PROC
;;;746    */
;;;747    void rcu_interrupt_enable(rcu_int_enum stab_int)
000000  4a06              LDR      r2,|L16.28|
;;;748    {
;;;749        RCU_REG_VAL(stab_int) |= BIT(RCU_BIT_POS(stab_int));
000002  eb021190          ADD      r1,r2,r0,LSR #6
000006  6809              LDR      r1,[r1,#0]
000008  f000031f          AND      r3,r0,#0x1f
00000c  2201              MOVS     r2,#1
00000e  409a              LSLS     r2,r2,r3
000010  4311              ORRS     r1,r1,r2
000012  4b02              LDR      r3,|L16.28|
000014  eb031290          ADD      r2,r3,r0,LSR #6
000018  6011              STR      r1,[r2,#0]
;;;750    }
00001a  4770              BX       lr
;;;751    
                          ENDP

                  |L16.28|
                          DCD      0x40021000

                          AREA ||i.rcu_interrupt_flag_clear||, CODE, READONLY, ALIGN=2

                  rcu_interrupt_flag_clear PROC
;;;727    */
;;;728    void rcu_interrupt_flag_clear(rcu_int_flag_clear_enum int_flag_clear)
000000  4a06              LDR      r2,|L17.28|
;;;729    {
;;;730        RCU_REG_VAL(int_flag_clear) |= BIT(RCU_BIT_POS(int_flag_clear));
000002  eb021190          ADD      r1,r2,r0,LSR #6
000006  6809              LDR      r1,[r1,#0]
000008  f000031f          AND      r3,r0,#0x1f
00000c  2201              MOVS     r2,#1
00000e  409a              LSLS     r2,r2,r3
000010  4311              ORRS     r1,r1,r2
000012  4b02              LDR      r3,|L17.28|
000014  eb031290          ADD      r2,r3,r0,LSR #6
000018  6011              STR      r1,[r2,#0]
;;;731    }
00001a  4770              BX       lr
;;;732    
                          ENDP

                  |L17.28|
                          DCD      0x40021000

                          AREA ||i.rcu_interrupt_flag_get||, CODE, READONLY, ALIGN=2

                  rcu_interrupt_flag_get PROC
;;;702    */
;;;703    FlagStatus rcu_interrupt_flag_get(rcu_int_flag_enum int_flag)
000000  4601              MOV      r1,r0
;;;704    {
;;;705        /* get the rcu interrupt flag */
;;;706        if(RESET != (RCU_REG_VAL(int_flag) & BIT(RCU_BIT_POS(int_flag)))){
000002  4a07              LDR      r2,|L18.32|
000004  eb021091          ADD      r0,r2,r1,LSR #6
000008  6800              LDR      r0,[r0,#0]
00000a  f001031f          AND      r3,r1,#0x1f
00000e  2201              MOVS     r2,#1
000010  409a              LSLS     r2,r2,r3
000012  4010              ANDS     r0,r0,r2
000014  b108              CBZ      r0,|L18.26|
;;;707            return SET;
000016  2001              MOVS     r0,#1
                  |L18.24|
;;;708        }else{
;;;709            return RESET;
;;;710        }
;;;711    }
000018  4770              BX       lr
                  |L18.26|
00001a  2000              MOVS     r0,#0                 ;709
00001c  e7fc              B        |L18.24|
;;;712    
                          ENDP

00001e  0000              DCW      0x0000
                  |L18.32|
                          DCD      0x40021000

                          AREA ||i.rcu_irc8m_adjust_value_set||, CODE, READONLY, ALIGN=2

                  rcu_irc8m_adjust_value_set PROC
;;;1036   */
;;;1037   void rcu_irc8m_adjust_value_set(uint8_t irc8m_adjval)
000000  4a05              LDR      r2,|L19.24|
;;;1038   {
;;;1039       uint32_t reg;
;;;1040       
;;;1041       reg = RCU_CTL;
000002  6811              LDR      r1,[r2,#0]
;;;1042       /* reset the IRC8MADJ bits and set according to irc8m_adjval */
;;;1043       reg &= ~RCU_CTL_IRC8MADJ;
000004  f02101f8          BIC      r1,r1,#0xf8
;;;1044       RCU_CTL = (reg | ((irc8m_adjval & 0x1FU) << 3));
000008  f000021f          AND      r2,r0,#0x1f
00000c  ea4102c2          ORR      r2,r1,r2,LSL #3
000010  4b01              LDR      r3,|L19.24|
000012  601a              STR      r2,[r3,#0]
;;;1045   }
000014  4770              BX       lr
;;;1046   
                          ENDP

000016  0000              DCW      0x0000
                  |L19.24|
                          DCD      0x40021000

                          AREA ||i.rcu_osci_bypass_mode_disable||, CODE, READONLY, ALIGN=2

                  rcu_osci_bypass_mode_disable PROC
;;;977    */
;;;978    void rcu_osci_bypass_mode_disable(rcu_osci_type_enum osci)
000000  4601              MOV      r1,r0
;;;979    {
;;;980        uint32_t reg;
;;;981        
;;;982        switch(osci){
000002  2918              CMP      r1,#0x18
000004  d023              BEQ      |L20.78|
000006  dc03              BGT      |L20.16|
000008  b1f9              CBZ      r1,|L20.74|
00000a  2910              CMP      r1,#0x10
00000c  d120              BNE      |L20.80|
00000e  e006              B        |L20.30|
                  |L20.16|
000010  f5b16f00          CMP      r1,#0x800
000014  d00e              BEQ      |L20.52|
000016  f5b16f10          CMP      r1,#0x900
00001a  d119              BNE      |L20.80|
00001c  e016              B        |L20.76|
                  |L20.30|
;;;983        /* disable HXTAL to bypass mode */
;;;984        case RCU_HXTAL:
;;;985            reg = RCU_CTL;
00001e  4a0e              LDR      r2,|L20.88|
000020  6810              LDR      r0,[r2,#0]
;;;986            RCU_CTL &= ~RCU_CTL_HXTALEN;
000022  6812              LDR      r2,[r2,#0]
000024  f4223280          BIC      r2,r2,#0x10000
000028  4b0b              LDR      r3,|L20.88|
00002a  601a              STR      r2,[r3,#0]
;;;987            RCU_CTL = (reg & ~RCU_CTL_HXTALBPS);
00002c  f4202280          BIC      r2,r0,#0x40000
000030  601a              STR      r2,[r3,#0]
;;;988            break;
000032  e00e              B        |L20.82|
                  |L20.52|
;;;989        /* disable LXTAL to bypass mode */
;;;990        case RCU_LXTAL:
;;;991            reg = RCU_BDCTL;
000034  4a08              LDR      r2,|L20.88|
000036  6a10              LDR      r0,[r2,#0x20]
;;;992            RCU_BDCTL &= ~RCU_BDCTL_LXTALEN;
000038  6a12              LDR      r2,[r2,#0x20]
00003a  f0220201          BIC      r2,r2,#1
00003e  4b06              LDR      r3,|L20.88|
000040  621a              STR      r2,[r3,#0x20]
;;;993            RCU_BDCTL = (reg & ~RCU_BDCTL_LXTALBPS);
000042  f0200204          BIC      r2,r0,#4
000046  621a              STR      r2,[r3,#0x20]
;;;994            break;
000048  e003              B        |L20.82|
                  |L20.74|
;;;995        case RCU_IRC8M:
;;;996        case RCU_IRC40K:
00004a  bf00              NOP      
                  |L20.76|
;;;997        case RCU_PLL_CK:
00004c  bf00              NOP      
                  |L20.78|
;;;998    #ifdef GD32F10X_CL
;;;999        case RCU_PLL1_CK:
;;;1000       case RCU_PLL2_CK:
;;;1001   #endif /* GD32F10X_CL */
;;;1002           break;
00004e  e000              B        |L20.82|
                  |L20.80|
;;;1003       default:
;;;1004           break;
000050  bf00              NOP      
                  |L20.82|
000052  bf00              NOP                            ;988
;;;1005       }
;;;1006   }
000054  4770              BX       lr
;;;1007   
                          ENDP

000056  0000              DCW      0x0000
                  |L20.88|
                          DCD      0x40021000

                          AREA ||i.rcu_osci_bypass_mode_enable||, CODE, READONLY, ALIGN=2

                  rcu_osci_bypass_mode_enable PROC
;;;938    */
;;;939    void rcu_osci_bypass_mode_enable(rcu_osci_type_enum osci)
000000  4601              MOV      r1,r0
;;;940    {
;;;941        uint32_t reg;
;;;942    
;;;943        switch(osci){
000002  2918              CMP      r1,#0x18
000004  d023              BEQ      |L21.78|
000006  dc03              BGT      |L21.16|
000008  b1f9              CBZ      r1,|L21.74|
00000a  2910              CMP      r1,#0x10
00000c  d120              BNE      |L21.80|
00000e  e006              B        |L21.30|
                  |L21.16|
000010  f5b16f00          CMP      r1,#0x800
000014  d00e              BEQ      |L21.52|
000016  f5b16f10          CMP      r1,#0x900
00001a  d119              BNE      |L21.80|
00001c  e016              B        |L21.76|
                  |L21.30|
;;;944        /* enable HXTAL to bypass mode */
;;;945        case RCU_HXTAL:
;;;946            reg = RCU_CTL;
00001e  4a0e              LDR      r2,|L21.88|
000020  6810              LDR      r0,[r2,#0]
;;;947            RCU_CTL &= ~RCU_CTL_HXTALEN;
000022  6812              LDR      r2,[r2,#0]
000024  f4223280          BIC      r2,r2,#0x10000
000028  4b0b              LDR      r3,|L21.88|
00002a  601a              STR      r2,[r3,#0]
;;;948            RCU_CTL = (reg | RCU_CTL_HXTALBPS);
00002c  f4402280          ORR      r2,r0,#0x40000
000030  601a              STR      r2,[r3,#0]
;;;949            break;
000032  e00e              B        |L21.82|
                  |L21.52|
;;;950        /* enable LXTAL to bypass mode */
;;;951        case RCU_LXTAL:
;;;952            reg = RCU_BDCTL;
000034  4a08              LDR      r2,|L21.88|
000036  6a10              LDR      r0,[r2,#0x20]
;;;953            RCU_BDCTL &= ~RCU_BDCTL_LXTALEN;
000038  6a12              LDR      r2,[r2,#0x20]
00003a  f0220201          BIC      r2,r2,#1
00003e  4b06              LDR      r3,|L21.88|
000040  621a              STR      r2,[r3,#0x20]
;;;954            RCU_BDCTL = (reg | RCU_BDCTL_LXTALBPS);
000042  f0400204          ORR      r2,r0,#4
000046  621a              STR      r2,[r3,#0x20]
;;;955            break;
000048  e003              B        |L21.82|
                  |L21.74|
;;;956        case RCU_IRC8M:
;;;957        case RCU_IRC40K:
00004a  bf00              NOP      
                  |L21.76|
;;;958        case RCU_PLL_CK:
00004c  bf00              NOP      
                  |L21.78|
;;;959    #ifdef GD32F10X_CL
;;;960        case RCU_PLL1_CK:
;;;961        case RCU_PLL2_CK:
;;;962    #endif /* GD32F10X_CL */
;;;963            break;
00004e  e000              B        |L21.82|
                  |L21.80|
;;;964        default:
;;;965            break;
000050  bf00              NOP      
                  |L21.82|
000052  bf00              NOP                            ;949
;;;966        }
;;;967    }
000054  4770              BX       lr
;;;968    
                          ENDP

000056  0000              DCW      0x0000
                  |L21.88|
                          DCD      0x40021000

                          AREA ||i.rcu_osci_off||, CODE, READONLY, ALIGN=2

                  rcu_osci_off PROC
;;;924    */
;;;925    void rcu_osci_off(rcu_osci_type_enum osci)
000000  4a06              LDR      r2,|L22.28|
;;;926    {
;;;927        RCU_REG_VAL(osci) &= ~BIT(RCU_BIT_POS(osci));
000002  eb021190          ADD      r1,r2,r0,LSR #6
000006  6809              LDR      r1,[r1,#0]
000008  f000031f          AND      r3,r0,#0x1f
00000c  2201              MOVS     r2,#1
00000e  409a              LSLS     r2,r2,r3
000010  4391              BICS     r1,r1,r2
000012  4b02              LDR      r3,|L22.28|
000014  eb031290          ADD      r2,r3,r0,LSR #6
000018  6011              STR      r1,[r2,#0]
;;;928    }
00001a  4770              BX       lr
;;;929    
                          ENDP

                  |L22.28|
                          DCD      0x40021000

                          AREA ||i.rcu_osci_on||, CODE, READONLY, ALIGN=2

                  rcu_osci_on PROC
;;;905    */
;;;906    void rcu_osci_on(rcu_osci_type_enum osci)
000000  4a06              LDR      r2,|L23.28|
;;;907    {
;;;908        RCU_REG_VAL(osci) |= BIT(RCU_BIT_POS(osci));
000002  eb021190          ADD      r1,r2,r0,LSR #6
000006  6809              LDR      r1,[r1,#0]
000008  f000031f          AND      r3,r0,#0x1f
00000c  2201              MOVS     r2,#1
00000e  409a              LSLS     r2,r2,r3
000010  4311              ORRS     r1,r1,r2
000012  4b02              LDR      r3,|L23.28|
000014  eb031290          ADD      r2,r3,r0,LSR #6
000018  6011              STR      r1,[r2,#0]
;;;909    }
00001a  4770              BX       lr
;;;910    
                          ENDP

                  |L23.28|
                          DCD      0x40021000

                          AREA ||i.rcu_osci_stab_wait||, CODE, READONLY, ALIGN=2

                  rcu_osci_stab_wait PROC
;;;784    */
;;;785    ErrStatus rcu_osci_stab_wait(rcu_osci_type_enum osci)
000000  b5f0              PUSH     {r4-r7,lr}
;;;786    {
000002  4606              MOV      r6,r0
;;;787        uint32_t stb_cnt = 0U;
000004  2400              MOVS     r4,#0
;;;788        ErrStatus reval = ERROR;
000006  2700              MOVS     r7,#0
;;;789        FlagStatus osci_stat = RESET;
000008  2500              MOVS     r5,#0
;;;790        
;;;791        switch(osci){
00000a  2e18              CMP      r6,#0x18
00000c  d051              BEQ      |L24.178|
00000e  dc03              BGT      |L24.24|
000010  b36e              CBZ      r6,|L24.110|
000012  2e10              CMP      r6,#0x10
000014  d15d              BNE      |L24.210|
000016  e006              B        |L24.38|
                  |L24.24|
000018  f5b66f00          CMP      r6,#0x800
00001c  d014              BEQ      |L24.72|
00001e  f5b66f10          CMP      r6,#0x900
000022  d156              BNE      |L24.210|
000024  e033              B        |L24.142|
                  |L24.38|
;;;792        /* wait HXTAL stable */
;;;793        case RCU_HXTAL:
;;;794            while((RESET == osci_stat) && (HXTAL_STARTUP_TIMEOUT != stb_cnt)){
000026  e004              B        |L24.50|
                  |L24.40|
;;;795                osci_stat = rcu_flag_get(RCU_FLAG_HXTALSTB);
000028  2011              MOVS     r0,#0x11
00002a  f7fffffe          BL       rcu_flag_get
00002e  4605              MOV      r5,r0
;;;796                stb_cnt++;
000030  1c64              ADDS     r4,r4,#1
                  |L24.50|
000032  b91d              CBNZ     r5,|L24.60|
000034  f64f70ff          MOV      r0,#0xffff            ;794
000038  4284              CMP      r4,r0                 ;794
00003a  d1f5              BNE      |L24.40|
                  |L24.60|
;;;797            }
;;;798    
;;;799            /* check whether flag is set or not */
;;;800            if(RESET != rcu_flag_get(RCU_FLAG_HXTALSTB)){
00003c  2011              MOVS     r0,#0x11
00003e  f7fffffe          BL       rcu_flag_get
000042  b100              CBZ      r0,|L24.70|
;;;801                reval = SUCCESS;
000044  2701              MOVS     r7,#1
                  |L24.70|
;;;802            }
;;;803            break;
000046  e045              B        |L24.212|
                  |L24.72|
;;;804    
;;;805        /* wait LXTAL stable */
;;;806        case RCU_LXTAL:
;;;807            while((RESET == osci_stat) && (LXTAL_STARTUP_TIMEOUT != stb_cnt)){
000048  e005              B        |L24.86|
                  |L24.74|
;;;808                osci_stat = rcu_flag_get(RCU_FLAG_LXTALSTB);
00004a  f6400001          MOV      r0,#0x801
00004e  f7fffffe          BL       rcu_flag_get
000052  4605              MOV      r5,r0
;;;809                stb_cnt++;
000054  1c64              ADDS     r4,r4,#1
                  |L24.86|
000056  b91d              CBNZ     r5,|L24.96|
000058  f06f407c          MVN      r0,#0xfc000000        ;807
00005c  4284              CMP      r4,r0                 ;807
00005e  d1f4              BNE      |L24.74|
                  |L24.96|
;;;810            }
;;;811    
;;;812            /* check whether flag is set or not */
;;;813            if(RESET != rcu_flag_get(RCU_FLAG_LXTALSTB)){
000060  f6400001          MOV      r0,#0x801
000064  f7fffffe          BL       rcu_flag_get
000068  b100              CBZ      r0,|L24.108|
;;;814                reval = SUCCESS;
00006a  2701              MOVS     r7,#1
                  |L24.108|
;;;815            }
;;;816            break;
00006c  e032              B        |L24.212|
                  |L24.110|
;;;817    
;;;818        /* wait IRC8M stable */
;;;819        case RCU_IRC8M:
;;;820            while((RESET == osci_stat) && (IRC8M_STARTUP_TIMEOUT != stb_cnt)){
00006e  e004              B        |L24.122|
                  |L24.112|
;;;821                osci_stat = rcu_flag_get(RCU_FLAG_IRC8MSTB);
000070  2001              MOVS     r0,#1
000072  f7fffffe          BL       rcu_flag_get
000076  4605              MOV      r5,r0
;;;822                stb_cnt++;
000078  1c64              ADDS     r4,r4,#1
                  |L24.122|
00007a  b915              CBNZ     r5,|L24.130|
00007c  f5b46fa0          CMP      r4,#0x500             ;820
000080  d1f6              BNE      |L24.112|
                  |L24.130|
;;;823            }
;;;824    
;;;825            /* check whether flag is set or not */
;;;826            if(RESET != rcu_flag_get(RCU_FLAG_IRC8MSTB)){
000082  2001              MOVS     r0,#1
000084  f7fffffe          BL       rcu_flag_get
000088  b100              CBZ      r0,|L24.140|
;;;827                reval = SUCCESS;
00008a  2701              MOVS     r7,#1
                  |L24.140|
;;;828            }
;;;829            break;
00008c  e022              B        |L24.212|
                  |L24.142|
;;;830    
;;;831        /* wait IRC40K stable */
;;;832        case RCU_IRC40K:
;;;833            while((RESET == osci_stat) && (OSC_STARTUP_TIMEOUT != stb_cnt)){
00008e  e005              B        |L24.156|
                  |L24.144|
;;;834                osci_stat = rcu_flag_get(RCU_FLAG_IRC40KSTB);
000090  f6401001          MOV      r0,#0x901
000094  f7fffffe          BL       rcu_flag_get
000098  4605              MOV      r5,r0
;;;835                stb_cnt++;
00009a  1c64              ADDS     r4,r4,#1
                  |L24.156|
00009c  b915              CBNZ     r5,|L24.164|
00009e  480f              LDR      r0,|L24.220|
0000a0  4284              CMP      r4,r0                 ;833
0000a2  d1f5              BNE      |L24.144|
                  |L24.164|
;;;836            }
;;;837    
;;;838            /* check whether flag is set or not */
;;;839            if(RESET != rcu_flag_get(RCU_FLAG_IRC40KSTB)){
0000a4  f6401001          MOV      r0,#0x901
0000a8  f7fffffe          BL       rcu_flag_get
0000ac  b100              CBZ      r0,|L24.176|
;;;840                reval = SUCCESS;
0000ae  2701              MOVS     r7,#1
                  |L24.176|
;;;841            }
;;;842            break;
0000b0  e010              B        |L24.212|
                  |L24.178|
;;;843    
;;;844        /* wait PLL stable */
;;;845        case RCU_PLL_CK:
;;;846            while((RESET == osci_stat) && (OSC_STARTUP_TIMEOUT != stb_cnt)){
0000b2  e004              B        |L24.190|
                  |L24.180|
;;;847                osci_stat = rcu_flag_get(RCU_FLAG_PLLSTB);
0000b4  2019              MOVS     r0,#0x19
0000b6  f7fffffe          BL       rcu_flag_get
0000ba  4605              MOV      r5,r0
;;;848                stb_cnt++;
0000bc  1c64              ADDS     r4,r4,#1
                  |L24.190|
0000be  b915              CBNZ     r5,|L24.198|
0000c0  4806              LDR      r0,|L24.220|
0000c2  4284              CMP      r4,r0                 ;846
0000c4  d1f6              BNE      |L24.180|
                  |L24.198|
;;;849            }
;;;850    
;;;851            /* check whether flag is set or not */
;;;852            if(RESET != rcu_flag_get(RCU_FLAG_PLLSTB)){
0000c6  2019              MOVS     r0,#0x19
0000c8  f7fffffe          BL       rcu_flag_get
0000cc  b100              CBZ      r0,|L24.208|
;;;853                reval = SUCCESS;
0000ce  2701              MOVS     r7,#1
                  |L24.208|
;;;854            }
;;;855            break;
0000d0  e000              B        |L24.212|
                  |L24.210|
;;;856    
;;;857    #ifdef GD32F10X_CL
;;;858        /* wait PLL1 stable */
;;;859        case RCU_PLL1_CK:
;;;860            while((RESET == osci_stat) && (OSC_STARTUP_TIMEOUT != stb_cnt)){
;;;861                osci_stat = rcu_flag_get(RCU_FLAG_PLL1STB);
;;;862                stb_cnt++;
;;;863            }
;;;864    
;;;865            /* check whether flag is set or not */
;;;866            if(RESET != rcu_flag_get(RCU_FLAG_PLL1STB)){
;;;867                reval = SUCCESS;
;;;868            }
;;;869            break;
;;;870        /* wait PLL2 stable */
;;;871        case RCU_PLL2_CK:
;;;872            while((RESET == osci_stat) && (OSC_STARTUP_TIMEOUT != stb_cnt)){
;;;873                osci_stat = rcu_flag_get(RCU_FLAG_PLL2STB);
;;;874                stb_cnt++;
;;;875            }
;;;876    
;;;877            /* check whether flag is set or not */
;;;878            if(RESET != rcu_flag_get(RCU_FLAG_PLL2STB)){
;;;879                reval = SUCCESS;
;;;880            }
;;;881            break;
;;;882    #endif /* GD32F10X_CL */
;;;883    
;;;884        default:
;;;885            break;
0000d2  bf00              NOP      
                  |L24.212|
0000d4  bf00              NOP                            ;803
;;;886        }
;;;887    
;;;888        /* return value */
;;;889        return reval;
0000d6  4638              MOV      r0,r7
;;;890    }
0000d8  bdf0              POP      {r4-r7,pc}
;;;891    
                          ENDP

0000da  0000              DCW      0x0000
                  |L24.220|
                          DCD      0x000fffff

                          AREA ||i.rcu_periph_clock_disable||, CODE, READONLY, ALIGN=2

                  rcu_periph_clock_disable PROC
;;;153    */
;;;154    void rcu_periph_clock_disable(rcu_periph_enum periph)
000000  4a06              LDR      r2,|L25.28|
;;;155    {
;;;156        RCU_REG_VAL(periph) &= ~BIT(RCU_BIT_POS(periph));
000002  eb021190          ADD      r1,r2,r0,LSR #6
000006  6809              LDR      r1,[r1,#0]
000008  f000031f          AND      r3,r0,#0x1f
00000c  2201              MOVS     r2,#1
00000e  409a              LSLS     r2,r2,r3
000010  4391              BICS     r1,r1,r2
000012  4b02              LDR      r3,|L25.28|
000014  eb031290          ADD      r2,r3,r0,LSR #6
000018  6011              STR      r1,[r2,#0]
;;;157    }
00001a  4770              BX       lr
;;;158    
                          ENDP

                  |L25.28|
                          DCD      0x40021000

                          AREA ||i.rcu_periph_clock_enable||, CODE, READONLY, ALIGN=2

                  rcu_periph_clock_enable PROC
;;;118    */
;;;119    void rcu_periph_clock_enable(rcu_periph_enum periph)
000000  4a06              LDR      r2,|L26.28|
;;;120    {
;;;121        RCU_REG_VAL(periph) |= BIT(RCU_BIT_POS(periph));
000002  eb021190          ADD      r1,r2,r0,LSR #6
000006  6809              LDR      r1,[r1,#0]
000008  f000031f          AND      r3,r0,#0x1f
00000c  2201              MOVS     r2,#1
00000e  409a              LSLS     r2,r2,r3
000010  4311              ORRS     r1,r1,r2
000012  4b02              LDR      r3,|L26.28|
000014  eb031290          ADD      r2,r3,r0,LSR #6
000018  6011              STR      r1,[r2,#0]
;;;122    }
00001a  4770              BX       lr
;;;123    
                          ENDP

                  |L26.28|
                          DCD      0x40021000

                          AREA ||i.rcu_periph_clock_sleep_disable||, CODE, READONLY, ALIGN=2

                  rcu_periph_clock_sleep_disable PROC
;;;181    */
;;;182    void rcu_periph_clock_sleep_disable(rcu_periph_sleep_enum periph)
000000  4a06              LDR      r2,|L27.28|
;;;183    {
;;;184        RCU_REG_VAL(periph) &= ~BIT(RCU_BIT_POS(periph));
000002  eb021190          ADD      r1,r2,r0,LSR #6
000006  6809              LDR      r1,[r1,#0]
000008  f000031f          AND      r3,r0,#0x1f
00000c  2201              MOVS     r2,#1
00000e  409a              LSLS     r2,r2,r3
000010  4391              BICS     r1,r1,r2
000012  4b02              LDR      r3,|L27.28|
000014  eb031290          ADD      r2,r3,r0,LSR #6
000018  6011              STR      r1,[r2,#0]
;;;185    }
00001a  4770              BX       lr
;;;186    
                          ENDP

                  |L27.28|
                          DCD      0x40021000

                          AREA ||i.rcu_periph_clock_sleep_enable||, CODE, READONLY, ALIGN=2

                  rcu_periph_clock_sleep_enable PROC
;;;167    */
;;;168    void rcu_periph_clock_sleep_enable(rcu_periph_sleep_enum periph)
000000  4a06              LDR      r2,|L28.28|
;;;169    {
;;;170        RCU_REG_VAL(periph) |= BIT(RCU_BIT_POS(periph));
000002  eb021190          ADD      r1,r2,r0,LSR #6
000006  6809              LDR      r1,[r1,#0]
000008  f000031f          AND      r3,r0,#0x1f
00000c  2201              MOVS     r2,#1
00000e  409a              LSLS     r2,r2,r3
000010  4311              ORRS     r1,r1,r2
000012  4b02              LDR      r3,|L28.28|
000014  eb031290          ADD      r2,r3,r0,LSR #6
000018  6011              STR      r1,[r2,#0]
;;;171    }
00001a  4770              BX       lr
;;;172    
                          ENDP

                  |L28.28|
                          DCD      0x40021000

                          AREA ||i.rcu_periph_reset_disable||, CODE, READONLY, ALIGN=2

                  rcu_periph_reset_disable PROC
;;;237    */
;;;238    void rcu_periph_reset_disable(rcu_periph_reset_enum periph_reset)
000000  4a06              LDR      r2,|L29.28|
;;;239    {
;;;240        RCU_REG_VAL(periph_reset) &= ~BIT(RCU_BIT_POS(periph_reset));
000002  eb021190          ADD      r1,r2,r0,LSR #6
000006  6809              LDR      r1,[r1,#0]
000008  f000031f          AND      r3,r0,#0x1f
00000c  2201              MOVS     r2,#1
00000e  409a              LSLS     r2,r2,r3
000010  4391              BICS     r1,r1,r2
000012  4b02              LDR      r3,|L29.28|
000014  eb031290          ADD      r2,r3,r0,LSR #6
000018  6011              STR      r1,[r2,#0]
;;;241    }
00001a  4770              BX       lr
;;;242    
                          ENDP

                  |L29.28|
                          DCD      0x40021000

                          AREA ||i.rcu_periph_reset_enable||, CODE, READONLY, ALIGN=2

                  rcu_periph_reset_enable PROC
;;;209    */
;;;210    void rcu_periph_reset_enable(rcu_periph_reset_enum periph_reset)
000000  4a06              LDR      r2,|L30.28|
;;;211    {
;;;212        RCU_REG_VAL(periph_reset) |= BIT(RCU_BIT_POS(periph_reset));
000002  eb021190          ADD      r1,r2,r0,LSR #6
000006  6809              LDR      r1,[r1,#0]
000008  f000031f          AND      r3,r0,#0x1f
00000c  2201              MOVS     r2,#1
00000e  409a              LSLS     r2,r2,r3
000010  4311              ORRS     r1,r1,r2
000012  4b02              LDR      r3,|L30.28|
000014  eb031290          ADD      r2,r3,r0,LSR #6
000018  6011              STR      r1,[r2,#0]
;;;213    }
00001a  4770              BX       lr
;;;214    
                          ENDP

                  |L30.28|
                          DCD      0x40021000

                          AREA ||i.rcu_pll_config||, CODE, READONLY, ALIGN=2

                  rcu_pll_config PROC
;;;402    */
;;;403    void rcu_pll_config(uint32_t pll_src, uint32_t pll_mul)
000000  4602              MOV      r2,r0
;;;404    {
;;;405        uint32_t reg = 0U;
000002  2000              MOVS     r0,#0
;;;406    
;;;407        reg = RCU_CFG0;
000004  4b04              LDR      r3,|L31.24|
000006  6858              LDR      r0,[r3,#4]
;;;408    
;;;409        /* PLL clock source and multiplication factor configuration */
;;;410        reg &= ~(RCU_CFG0_PLLSEL | RCU_CFG0_PLLMF | RCU_CFG0_PLLMF_4);
000008  4b04              LDR      r3,|L31.28|
00000a  4018              ANDS     r0,r0,r3
;;;411        reg |= (pll_src | pll_mul);
00000c  ea420301          ORR      r3,r2,r1
000010  4318              ORRS     r0,r0,r3
;;;412    
;;;413        RCU_CFG0 = reg;
000012  4b01              LDR      r3,|L31.24|
000014  6058              STR      r0,[r3,#4]
;;;414    }
000016  4770              BX       lr
;;;415    
                          ENDP

                  |L31.24|
                          DCD      0x40021000
                  |L31.28|
                          DCD      0xf7c2ffff

                          AREA ||i.rcu_predv0_config||, CODE, READONLY, ALIGN=2

                  rcu_predv0_config PROC
;;;424    */
;;;425    void rcu_predv0_config(uint32_t predv0_div)
000000  4601              MOV      r1,r0
;;;426    {
;;;427        uint32_t reg = 0U;
000002  2000              MOVS     r0,#0
;;;428    
;;;429        reg = RCU_CFG0;
000004  4a05              LDR      r2,|L32.28|
000006  6850              LDR      r0,[r2,#4]
;;;430        /* reset PREDV0 bit */
;;;431        reg &= ~RCU_CFG0_PREDV0;
000008  f4203000          BIC      r0,r0,#0x20000
;;;432        if(RCU_PREDV0_DIV2 == predv0_div){
00000c  2901              CMP      r1,#1
00000e  d101              BNE      |L32.20|
;;;433            /* set the PREDV0 bit */
;;;434            reg |= RCU_CFG0_PREDV0;
000010  f4403000          ORR      r0,r0,#0x20000
                  |L32.20|
;;;435        }
;;;436    
;;;437        RCU_CFG0 = reg;
000014  4a01              LDR      r2,|L32.28|
000016  6050              STR      r0,[r2,#4]
;;;438    }
000018  4770              BX       lr
;;;439    #elif defined(GD32F10X_CL)
                          ENDP

00001a  0000              DCW      0x0000
                  |L32.28|
                          DCD      0x40021000

                          AREA ||i.rcu_rtc_clock_config||, CODE, READONLY, ALIGN=2

                  rcu_rtc_clock_config PROC
;;;596    */
;;;597    void rcu_rtc_clock_config(uint32_t rtc_clock_source)
000000  4a04              LDR      r2,|L33.20|
;;;598    {
;;;599        uint32_t reg;
;;;600        
;;;601        reg = RCU_BDCTL; 
000002  6a11              LDR      r1,[r2,#0x20]
;;;602        /* reset the RTCSRC bits and set according to rtc_clock_source */
;;;603        reg &= ~RCU_BDCTL_RTCSRC;
000004  f4217140          BIC      r1,r1,#0x300
;;;604        RCU_BDCTL = (reg | rtc_clock_source);
000008  ea410200          ORR      r2,r1,r0
00000c  4b01              LDR      r3,|L33.20|
00000e  621a              STR      r2,[r3,#0x20]
;;;605    }
000010  4770              BX       lr
;;;606    
                          ENDP

000012  0000              DCW      0x0000
                  |L33.20|
                          DCD      0x40021000

                          AREA ||i.rcu_system_clock_source_config||, CODE, READONLY, ALIGN=2

                  rcu_system_clock_source_config PROC
;;;274    */
;;;275    void rcu_system_clock_source_config(uint32_t ck_sys)
000000  4a04              LDR      r2,|L34.20|
;;;276    {
;;;277        uint32_t reg;
;;;278        
;;;279        reg = RCU_CFG0;
000002  6851              LDR      r1,[r2,#4]
;;;280        /* reset the SCS bits and set according to ck_sys */
;;;281        reg &= ~RCU_CFG0_SCS;
000004  f0210103          BIC      r1,r1,#3
;;;282        RCU_CFG0 = (reg | ck_sys);
000008  ea410200          ORR      r2,r1,r0
00000c  4b01              LDR      r3,|L34.20|
00000e  605a              STR      r2,[r3,#4]
;;;283    }
000010  4770              BX       lr
;;;284    
                          ENDP

000012  0000              DCW      0x0000
                  |L34.20|
                          DCD      0x40021000

                          AREA ||i.rcu_system_clock_source_get||, CODE, READONLY, ALIGN=2

                  rcu_system_clock_source_get PROC
;;;293    */
;;;294    uint32_t rcu_system_clock_source_get(void)
000000  4802              LDR      r0,|L35.12|
;;;295    {
;;;296        return (RCU_CFG0 & RCU_CFG0_SCSS);
000002  6840              LDR      r0,[r0,#4]
000004  f000000c          AND      r0,r0,#0xc
;;;297    }
000008  4770              BX       lr
;;;298    
                          ENDP

00000a  0000              DCW      0x0000
                  |L35.12|
                          DCD      0x40021000

                          AREA ||i.rcu_usb_clock_config||, CODE, READONLY, ALIGN=2

                  rcu_usb_clock_config PROC
;;;569    */
;;;570    void rcu_usb_clock_config(uint32_t usb_psc)
000000  4a04              LDR      r2,|L36.20|
;;;571    {
;;;572        uint32_t reg;
;;;573        
;;;574        reg = RCU_CFG0;
000002  6851              LDR      r1,[r2,#4]
;;;575    
;;;576        /* configure the USBD/USBFS prescaler factor */
;;;577    #if (defined(GD32F10X_MD) || defined(GD32F10X_HD) || defined(GD32F10X_XD))
;;;578        reg &= ~RCU_CFG0_USBDPSC;
000004  f4210140          BIC      r1,r1,#0xc00000
;;;579    #elif defined(GD32F10X_CL)
;;;580        reg &= ~RCU_CFG0_USBFSPSC;
;;;581    #endif /* GD32F10X_MD and GD32F10X_HD and GD32F10X_XD */
;;;582    
;;;583        RCU_CFG0 = (reg | usb_psc);
000008  ea410200          ORR      r2,r1,r0
00000c  4b01              LDR      r3,|L36.20|
00000e  605a              STR      r2,[r3,#4]
;;;584    }
000010  4770              BX       lr
;;;585    
                          ENDP

000012  0000              DCW      0x0000
                  |L36.20|
                          DCD      0x40021000

;*** Start embedded assembler ***

#line 1 "Libraries\\src\\gd32f10x_rcu.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_gd32f10x_rcu_c_60720801____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___14_gd32f10x_rcu_c_60720801____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_gd32f10x_rcu_c_60720801____REVSH|
#line 128
|__asm___14_gd32f10x_rcu_c_60720801____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
