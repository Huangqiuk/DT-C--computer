; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\uartprotocol1.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\uartprotocol1.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -I.\User\qrencode -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.1\Device\Include -D__MICROLIB -D__UVISION_VERSION=534 -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\uartprotocol1.crf User\UartProtocol1.c]
                          THUMB

                          AREA ||i.UART_PROTOCOL1_CALLBACK_SetTxPeriodRequest||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL1_CALLBACK_SetTxPeriodRequest PROC
;;;1072   // 码表设置周期下发数据请求标志
;;;1073   void UART_PROTOCOL1_CALLBACK_SetTxPeriodRequest(uint32 param)
000000  4901              LDR      r1,|L1.8|
;;;1074   {
;;;1075   	uartProtocolCB1.txPeriodRequest = (BOOL)param;
000002  f881047c          STRB     r0,[r1,#0x47c]
;;;1076   }
000006  4770              BX       lr
;;;1077   
                          ENDP

                  |L1.8|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOL1_CALLBACK_SpeedFilterProcess||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL1_CALLBACK_SpeedFilterProcess PROC
;;;124    // 速度平滑滤波处理
;;;125    void UART_PROTOCOL1_CALLBACK_SpeedFilterProcess(uint32 param)
000000  b510              PUSH     {r4,lr}
;;;126    {
;;;127    	if (uartProtocolCB1.speedFilter.realSpeed > uartProtocolCB1.speedFilter.proSpeed)
000002  4b15              LDR      r3,|L2.88|
000004  4619              MOV      r1,r3
000006  f8b3247e          LDRH     r2,[r3,#0x47e]  ; uartProtocolCB1
00000a  f8b30480          LDRH     r0,[r3,#0x480]  ; uartProtocolCB1
;;;128    	{
;;;129    		uartProtocolCB1.speedFilter.proSpeed += uartProtocolCB1.speedFilter.difSpeed;
00000e  f8b11482          LDRH     r1,[r1,#0x482]
000012  4282              CMP      r2,r0                 ;127
000014  d908              BLS      |L2.40|
000016  4408              ADD      r0,r0,r1
000018  b280              UXTH     r0,r0
00001a  f8a30480          STRH     r0,[r3,#0x480]
;;;130    
;;;131    		if (uartProtocolCB1.speedFilter.proSpeed >= uartProtocolCB1.speedFilter.realSpeed)
00001e  4290              CMP      r0,r2
000020  d30b              BCC      |L2.58|
;;;132    		{
;;;133    			uartProtocolCB1.speedFilter.proSpeed = uartProtocolCB1.speedFilter.realSpeed;
000022  f8a32480          STRH     r2,[r3,#0x480]
000026  e008              B        |L2.58|
                  |L2.40|
;;;134    		}
;;;135    	}
;;;136    	else
;;;137    	{
;;;138    		if (uartProtocolCB1.speedFilter.proSpeed >= uartProtocolCB1.speedFilter.difSpeed)
000028  4288              CMP      r0,r1
00002a  d303              BCC      |L2.52|
;;;139    		{
;;;140    			uartProtocolCB1.speedFilter.proSpeed -= uartProtocolCB1.speedFilter.difSpeed;
00002c  1a40              SUBS     r0,r0,r1
00002e  f8a30480          STRH     r0,[r3,#0x480]
000032  e002              B        |L2.58|
                  |L2.52|
;;;141    		}
;;;142    		else
;;;143    		{
;;;144    			uartProtocolCB1.speedFilter.proSpeed = 0;
000034  2000              MOVS     r0,#0
000036  f8a30480          STRH     r0,[r3,#0x480]
                  |L2.58|
;;;145    		}
;;;146    	}
;;;147    
;;;148    	PARAM_SetSpeed(uartProtocolCB1.speedFilter.proSpeed);
00003a  4908              LDR      r1,|L2.92|
00003c  f8b30480          LDRH     r0,[r3,#0x480]  ; uartProtocolCB1
000040  f8a10210          STRH     r0,[r1,#0x210]
;;;149    
;;;150    	// 速度不为0，重置定时关机任务
;;;151    	if (PARAM_GetSpeed() != 0)
000044  f7fffffe          BL       PARAM_GetSpeed
000048  2800              CMP      r0,#0
00004a  d003              BEQ      |L2.84|
;;;152    	{
;;;153    		STATE_ResetAutoPowerOffControl();
00004c  e8bd4010          POP      {r4,lr}
000050  f7ffbffe          B.W      STATE_ResetAutoPowerOffControl
                  |L2.84|
;;;154    	}
;;;155    }
000054  bd10              POP      {r4,pc}
;;;156    
                          ENDP

000056  0000              DCW      0x0000
                  |L2.88|
                          DCD      ||.bss||
                  |L2.92|
                          DCD      paramCB

                          AREA ||i.UART_PROTOCOL1_CALLBACK_UartBusError||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL1_CALLBACK_UartBusError PROC
;;;1098   // 	UART总线超时错误处理
;;;1099   void UART_PROTOCOL1_CALLBACK_UartBusError(uint32 param)
000000  4902              LDR      r1,|L3.12|
;;;1100   {
;;;1101   	PARAM_SetErrorCode(ERROR_TYPE_COMMUNICATION_TIME_OUT);
000002  2030              MOVS     r0,#0x30
000004  f8810219          STRB     r0,[r1,#0x219]
;;;1102   }
000008  4770              BX       lr
;;;1103   
                          ENDP

00000a  0000              DCW      0x0000
                  |L3.12|
                          DCD      paramCB

                          AREA ||i.UART_PROTOCOL1_CheckSUM||, CODE, READONLY, ALIGN=1

                  UART_PROTOCOL1_CheckSUM PROC
;;;532    // 对传入的命令帧进行校验，返回校验结果
;;;533    BOOL UART_PROTOCOL1_CheckSUM(UART_PROTOCOL1_RX_CMD_FRAME* pCmdFrame)
000000  b530              PUSH     {r4,r5,lr}
;;;534    {
;;;535    	uint16 cc = 0;
000002  2200              MOVS     r2,#0
;;;536    	uint16 i = 0;
000004  2100              MOVS     r1,#0
;;;537    	
;;;538    	if(NULL == pCmdFrame)
000006  2800              CMP      r0,#0
000008  d003              BEQ      |L4.18|
;;;539    	{
;;;540    		return FALSE;
;;;541    	}
;;;542    
;;;543    	// 从设备地址开始，到校验码之前的一个字节，依次进行异或运算
;;;544    	for(i=0; i<pCmdFrame->length-1; i++)
00000a  f8b05098          LDRH     r5,[r0,#0x98]
00000e  1e6b              SUBS     r3,r5,#1
000010  e006              B        |L4.32|
                  |L4.18|
000012  2000              MOVS     r0,#0                 ;540
;;;545    	{
;;;546    		cc ^= pCmdFrame->buff[i];
;;;547    	}
;;;548    	
;;;549    	// 判断计算得到的校验码与命令帧中的校验码是否相同
;;;550    	if(pCmdFrame->buff[pCmdFrame->length-1] != cc)
;;;551    	{
;;;552    		return FALSE;
;;;553    	}
;;;554    	
;;;555    	return TRUE;
;;;556    }
000014  bd30              POP      {r4,r5,pc}
                  |L4.22|
000016  1844              ADDS     r4,r0,r1              ;546
000018  78a4              LDRB     r4,[r4,#2]            ;546
00001a  4062              EORS     r2,r2,r4              ;546
00001c  1c49              ADDS     r1,r1,#1              ;544
00001e  b289              UXTH     r1,r1                 ;544
                  |L4.32|
000020  428b              CMP      r3,r1                 ;544
000022  dcf8              BGT      |L4.22|
000024  1c40              ADDS     r0,r0,#1              ;550
000026  5c28              LDRB     r0,[r5,r0]            ;550
000028  4290              CMP      r0,r2                 ;550
00002a  d001              BEQ      |L4.48|
00002c  2000              MOVS     r0,#0                 ;552
00002e  bd30              POP      {r4,r5,pc}
                  |L4.48|
000030  2001              MOVS     r0,#1                 ;555
000032  bd30              POP      {r4,r5,pc}
;;;557    
                          ENDP


                          AREA ||i.UART_PROTOCOL1_CmdFrameProcess||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL1_CmdFrameProcess PROC
;;;558    // UART命令帧缓冲区处理
;;;559    void UART_PROTOCOL1_CmdFrameProcess(UART_PROTOCOL1_CB* pCB)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;560    {
000004  4605              MOV      r5,r0
;;;561    	UART_PROTOCOL1_CMD cmd = UART_PROTOCOL1_CMD_NULL;
;;;562    	UART_PROTOCOL1_RX_CMD_FRAME* pCmdFrame = NULL;
;;;563    	uint32 tempVal;
;;;564    	uint32 tempVal2;
;;;565    	uint16 i;
;;;566    	uint8* pBuff = NULL;
;;;567    	BOOL bTemp;
;;;568    
;;;569    	// 参数合法性检验
;;;570    	if(NULL == pCB)
000006  2d00              CMP      r5,#0
000008  d017              BEQ      |L5.58|
;;;571    	{
;;;572    		return;
;;;573    	}
;;;574    
;;;575    	// 命令帧缓冲区为空，退出
;;;576    	if(pCB->rx.head == pCB->rx.end)
00000a  f8b5029c          LDRH     r0,[r5,#0x29c]
00000e  f8b5129e          LDRH     r1,[r5,#0x29e]
000012  4288              CMP      r0,r1
000014  d011              BEQ      |L5.58|
;;;577    	{
;;;578    		return;
;;;579    	}
;;;580    
;;;581    	// 获取当前要处理的命令帧指针
;;;582    	pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.head];
000016  214d              MOVS     r1,#0x4d
000018  4341              MULS     r1,r0,r1
00001a  eb050441          ADD      r4,r5,r1,LSL #1
00001e  34ce              ADDS     r4,r4,#0xce
;;;583    	
;;;584    	// 命令头非法，退出
;;;585    	if(UART_PROTOCOL1_CMD_RX_DEVICE_ADDR != pCmdFrame->buff[UART_PROTOCOL1_CMD_DEVICE_ADDR_INDEX])
;;;586    	{
;;;587    		// 删除命令帧
;;;588    		pCB->rx.head ++;
;;;589    		pCB->rx.head %= UART_PROTOCOL1_RX_QUEUE_SIZE;
000020  f04f0903          MOV      r9,#3
000024  78a1              LDRB     r1,[r4,#2]            ;585
000026  2902              CMP      r1,#2                 ;585
000028  d009              BEQ      |L5.62|
00002a  1c40              ADDS     r0,r0,#1              ;588
00002c  b280              UXTH     r0,r0                 ;588
00002e  fbb0f1f9          UDIV     r1,r0,r9
000032  fb090011          MLS      r0,r9,r1,r0
000036  f8a5029c          STRH     r0,[r5,#0x29c]
                  |L5.58|
;;;590    		return;
;;;591    	}
;;;592    
;;;593    	// 命令头合法，则提取命令
;;;594    	cmd = (UART_PROTOCOL1_CMD)pCmdFrame->buff[UART_PROTOCOL1_CMD_CMD_INDEX];
;;;595    	
;;;596    	// 执行命令帧
;;;597    	switch(cmd)
;;;598    	{
;;;599    		// 空命令，不予执行
;;;600    		case UART_PROTOCOL1_CMD_NULL:
;;;601    			break;
;;;602    
;;;603    		// 正常运行状态
;;;604    		case UART_PROTOCOL1_CMD_HMI_CTRL_RUN:
;;;605    
;;;606    			UART_PROTOCOL1_OnReceiveReport(&pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA1_INDEX], UART_PROTOCOL1_RX_PARAM_SIZE);
;;;607    			
;;;608    			// 参数计算标志打开
;;;609    			PARAM_SetRecaculateRequest(TRUE);
;;;610    					
;;;611    			break;
;;;612    
;;;613    		// 上位机写仪表参数
;;;614    		case UART_PROTOCOL1_CMD_WRITE_CONTROL_PARAM:
;;;615    			// 电池电压等级
;;;616    			if ((24 == pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA2_INDEX]) || (36 == pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA1_INDEX]) || (48 == pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA1_INDEX]))
;;;617    			{
;;;618    				PARAM_SetBatteryVoltageLevel(pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA1_INDEX]);
;;;619    			}
;;;620    
;;;621    			// 背光亮度
;;;622    			if ((pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA2_INDEX] >= 1) && (pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA2_INDEX] <= 5))
;;;623    			{
;;;624    				PARAM_SetBrightness(pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA2_INDEX]);
;;;625    			}
;;;626    
;;;627    			// 休眠时间
;;;628    			if (pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA3_INDEX] <= 10)
;;;629    			{
;;;630    				PARAM_SetPowerOffTime(pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA3_INDEX]);
;;;631    			}
;;;632    
;;;633    			// 驱动器驱动方式
;;;634    			if (pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA4_INDEX] <= 2)
;;;635    			{
;;;636    				PARAM_SetDriverControlMode(pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA4_INDEX]);
;;;637    			}
;;;638    
;;;639    			// 助力档位数
;;;640    			if ((3 == pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA5_INDEX]) || (5 == pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA5_INDEX]) || (9 == pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA5_INDEX]))
;;;641    			{
;;;642    				PARAM_SetMaxAssist((ASSIST_ID_E)pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA5_INDEX]);
;;;643    			}
;;;644    
;;;645    			// 零或非零启动方式
;;;646    			PARAM_SetZeroStartOrNot((BOOL)pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA6_INDEX]);
;;;647    
;;;648    			// 切换巡航的方式
;;;649    			PARAM_SetSwitchCruiseWay((BOOL)pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA7_INDEX]);
;;;650    
;;;651    			// 巡航切换模式
;;;652    			PARAM_SetSwitchCruiseMode((BOOL)pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA8_INDEX]);
;;;653    
;;;654    			// 测速磁钢
;;;655    			if ((pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA9_INDEX] >= 1) && (pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA9_INDEX] <= 255))
;;;656    			{
;;;657    				PARAM_SetCycleOfSteelNum(pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA9_INDEX]);
;;;658    			}
;;;659    
;;;660    			// 轮径
;;;661    			tempVal = pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA10_INDEX];
;;;662    			tempVal <<= 8;
;;;663    			tempVal |= pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA11_INDEX];
;;;664    
;;;665    			PARAM_SetNewWheelSizeInch(tempVal);
;;;666    			/*switch (tempVal)
;;;667    			{
;;;668    				case 45:
;;;669    					//PARAM_SetWheelSizeID(PARAM_WHEEL_SIZE_4_5_INCH);
;;;670    					break;
;;;671    
;;;672    				case 60:
;;;673    					//PARAM_SetWheelSizeID(PARAM_WHEEL_SIZE_6_INCH);
;;;674    					break;
;;;675    
;;;676    				case 64:
;;;677    					//PARAM_SetWheelSizeID(PARAM_WHEEL_SIZE_6_4_INCH);
;;;678    					break;
;;;679    
;;;680    				case 80:
;;;681    					//PARAM_SetWheelSizeID(PARAM_WHEEL_SIZE_8_INCH);
;;;682    					break;
;;;683    
;;;684    				case 100:
;;;685    					//PARAM_SetWheelSizeID(PARAM_WHEEL_SIZE_10_INCH);
;;;686    					break;
;;;687    
;;;688    				case 120:
;;;689    					//PARAM_SetWheelSizeID(PARAM_WHEEL_SIZE_12_INCH);
;;;690    					break;
;;;691    
;;;692    				case 140:
;;;693    					PARAM_SetWheelSizeID(PARAM_WHEEL_SIZE_14_INCH);
;;;694    					break;
;;;695    
;;;696    				case 160:
;;;697    					PARAM_SetWheelSizeID(PARAM_WHEEL_SIZE_16_INCH);
;;;698    					break;
;;;699    
;;;700    				case 200:
;;;701    					PARAM_SetWheelSizeID(PARAM_WHEEL_SIZE_20_INCH);
;;;702    					break;
;;;703    
;;;704    				case 240:
;;;705    					PARAM_SetWheelSizeID(PARAM_WHEEL_SIZE_24_INCH);
;;;706    					break;
;;;707    
;;;708    				case 260:
;;;709    					PARAM_SetWheelSizeID(PARAM_WHEEL_SIZE_26_INCH);
;;;710    					break;
;;;711    
;;;712    				case 280:
;;;713    					PARAM_SetWheelSizeID(PARAM_WHEEL_SIZE_28_INCH);
;;;714    					break;
;;;715    
;;;716    				case 7000:
;;;717    					PARAM_SetWheelSizeID(PARAM_WHEEL_SIZE_700C);
;;;718    					break;
;;;719    
;;;720    				default:
;;;721    					break;
;;;722    			}
;;;723    			*/
;;;724    
;;;725    			// 助力灵敏度
;;;726    			if ((pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA12_INDEX] >= 3) && (pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA12_INDEX] <= 24))
;;;727    			{
;;;728    				PARAM_SetAssistSensitivity(pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA12_INDEX]);
;;;729    			}
;;;730    
;;;731    			// 助力启动强度
;;;732    			if (pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA13_INDEX] <= 5)
;;;733    			{
;;;734    				PARAM_SetAssistStartIntensity(pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA13_INDEX]);
;;;735    			}
;;;736    
;;;737    			// 限速电机换向霍尔磁钢数
;;;738    			PARAM_SetReversalHolzerSteelNum(pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA14_INDEX]);
;;;739    
;;;740    			// 限速
;;;741    			PARAM_SetSpeedLimit(pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA15_INDEX]*10);
;;;742    
;;;743    			// 限流
;;;744    			PARAM_SetCurrentLimit(pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA16_INDEX]*1000);
;;;745    
;;;746    			// 欠压门限
;;;747    			tempVal = pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA17_INDEX];
;;;748    			tempVal <<= 8;
;;;749    			tempVal |= pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA18_INDEX];			
;;;750    			PARAM_SetLowVoltageThreshold(tempVal);
;;;751    
;;;752    			// 助力磁钢类型
;;;753    			if ((5 == pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA19_INDEX]) || (8 == pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA19_INDEX]) || (12 == pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA19_INDEX]))
;;;754    			{
;;;755    				PARAM_SetSteelType(pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA19_INDEX]);
;;;756    			}
;;;757    
;;;758    			// 限速使能禁止标识
;;;759    			PARAM_SetSpeedLimitSwitch((BOOL)pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA20_INDEX]);
;;;760    
;;;761    			// 电量显示变化时间，单位:s
;;;762    			if ((pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA21_INDEX] >= 1) && (pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA21_INDEX] <= 60))
;;;763    			{
;;;764    				PARAM_SetBatteryCapVaryTime(pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA21_INDEX]);
;;;765    			}
;;;766    
;;;767    			// 总线故障超时时间，单位:ms
;;;768    			if ((pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA22_INDEX] >= 5) && (pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA22_INDEX] <= 255))
;;;769    			{
;;;770    				PARAM_SetBusAliveTime(pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA22_INDEX] * 1000UL);	// 秒转为毫秒
;;;771    			}
;;;772    
;;;773    				// 系统时间，年月日时分
;;;774    			if ((pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA23_INDEX] <= 99) 
;;;775    			&& (pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA24_INDEX] >= 1) && (pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA24_INDEX] <= 12)
;;;776    			&& (pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA25_INDEX] >= 1) && (pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA25_INDEX] <= 31)
;;;777    			&& (pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA26_INDEX] <= 23)
;;;778    			&& (pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA27_INDEX] <= 59))
;;;779    			{
;;;780    			}
;;;781    			
;;;782    			// 速度平滑度等级
;;;783    			if (pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA28_INDEX] <= 10)
;;;784    			{
;;;785    				PARAM_SetSpeedFilterLevel(pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA28_INDEX]);
;;;786    			}
;;;787    
;;;788    			// 公英制单位 0公制 1英制
;;;789    			if (pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA29_INDEX])
;;;790    			{
;;;791    				PARAM_SetUnit(UNIT_INCH);
;;;792    			}
;;;793    			else
;;;794    			{
;;;795    				PARAM_SetUnit(UNIT_METRIC);
;;;796    			}
;;;797    
;;;798    			// 蓝牙 0无蓝牙 1有蓝牙
;;;799    			if (pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA30_INDEX])
;;;800    			{
;;;801    				PARAM_SetExistBle(TRUE);
;;;802    			}
;;;803    			else
;;;804    			{
;;;805    				PARAM_SetExistBle(FALSE);
;;;806    			}
;;;807    
;;;808    			// NVM更新，立即写入
;;;809    			NVM_SetDirtyFlag(TRUE);
;;;810    			
;;;811    			// 发送应答
;;;812    			UART_PROTOCOL1_ReportWriteParamResult(TRUE);
;;;813    			break;
;;;814    
;;;815    		// 上位机读参数
;;;816    		case UART_PROTOCOL1_CMD_READ_CONTROL_PARAM:
;;;817    			UART_PROTOCOL1_ReportConfigureParam(TRUE);			
;;;818    			break;
;;;819    
;;;820    		case UART_PROTOCOL1_CMD_FLAG_ARRAY_READ:
;;;821    			// 读出数据并串口发送			
;;;822    			pBuff = (uint8 *)malloc(128);
;;;823    			if (NULL == pBuff)
;;;824    			{
;;;825    				break;
;;;826    			}
;;;827    			
;;;828    			// 添加设备地址
;;;829    			UART_PROTOCOL1_TxAddData(UART_PROTOCOL1_CMD_TX_DEVICE_ADDR);	
;;;830    						
;;;831    			// 添加帧长
;;;832    			UART_PROTOCOL1_TxAddData(64+5);
;;;833    							
;;;834    			// 添加命令字 
;;;835    			UART_PROTOCOL1_TxAddData(UART_PROTOCOL1_CMD_FLAG_ARRAY_READ);
;;;836    
;;;837    			// 标志区数据长度
;;;838    			UART_PROTOCOL1_TxAddData(64);
;;;839    
;;;840    			// 读出FALSH指定长度数据
;;;841    			SPI_FLASH_ReadArray(paramCB.runtime.flagArr, SPI_FLASH_TEST_FLAG_ADDEESS, 64);
;;;842    			for (i = 0; i < 64; i++)
;;;843    			{
;;;844    				UART_PROTOCOL_TxAddData(paramCB.runtime.flagArr[i]);
;;;845    			}
;;;846    			
;;;847    			UART_PROTOCOL1_TxAddFrame();
;;;848    
;;;849    			free(pBuff);
;;;850    			break;
;;;851    			
;;;852    		case UART_PROTOCOL1_CMD_FLAG_ARRAY_WRITE:
;;;853    			// 写入标志位置
;;;854    			tempVal = pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA1_INDEX];
;;;855    
;;;856    			// 写入数据到spiflash
;;;857    			SPI_FLASH_WriteWithErase(&pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA2_INDEX], SPI_FLASH_TEST_FLAG_ADDEESS + tempVal*4, 4);
;;;858    
;;;859    			// 更新标志
;;;860    			PARAM_Init();
;;;861    
;;;862    
;;;863    			// 添加设备地址
;;;864    			UART_PROTOCOL1_TxAddData(UART_PROTOCOL1_CMD_TX_DEVICE_ADDR);	
;;;865    						
;;;866    			// 添加帧长
;;;867    			UART_PROTOCOL1_TxAddData(5);
;;;868    							
;;;869    			// 添加命令字 
;;;870    			UART_PROTOCOL1_TxAddData(UART_PROTOCOL1_CMD_FLAG_ARRAY_WRITE);
;;;871    
;;;872    			UART_PROTOCOL1_TxAddData(TRUE);
;;;873    			
;;;874    			UART_PROTOCOL1_TxAddFrame();
;;;875    
;;;876    			break;
;;;877    			
;;;878    		case UART_PROTOCOL1_CMD_VERSION_TYPE_WRITE:
;;;879    			// 第一个写入类型
;;;880    			tempVal = pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA1_INDEX];
;;;881    			
;;;882    			// 第二个为信息长度
;;;883    			tempVal2 = pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA2_INDEX];
;;;884    
;;;885    			pBuff = (uint8 *)malloc(128);
;;;886    			if (NULL == pBuff)
;;;887    			{
;;;888    				break;
;;;889    			}
;;;890    			
;;;891    			// 清零
;;;892    			for (i = 0; i < 128; i++)
;;;893    			{
;;;894    				pBuff[i] = 0;
;;;895    			}
;;;896    			// 类型信息
;;;897    			for (i = 0; i < tempVal2 + 1; i++)
;;;898    			{
;;;899    				pBuff[i] = pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA1_INDEX+1+i];
;;;900    			}
;;;901    			
;;;902    			// 判断类型种类是否合法
;;;903    			if (16 >= tempVal)
;;;904    			{
;;;905    				SPI_FLASH_WriteWithErase(pBuff, PARAM_MCU_VERSION_ADDRESS[tempVal], tempVal2+1);
;;;906    				PARAM_Init();
;;;907    
;;;908    				bTemp = TRUE;
;;;909    			}
;;;910    			else
;;;911    			{
;;;912    				bTemp = FALSE;
;;;913    			}
;;;914    
;;;915    			// 添加设备地址
;;;916    			UART_PROTOCOL1_TxAddData(UART_PROTOCOL1_CMD_TX_DEVICE_ADDR);	
;;;917    						
;;;918    			// 添加帧长
;;;919    			UART_PROTOCOL1_TxAddData(5);
;;;920    							
;;;921    			// 添加命令字 
;;;922    			UART_PROTOCOL1_TxAddData(UART_PROTOCOL1_CMD_VERSION_TYPE_WRITE);
;;;923    
;;;924    			// 类型
;;;925    			UART_PROTOCOL1_TxAddData(tempVal);
;;;926    
;;;927    			// 结果
;;;928    			UART_PROTOCOL1_TxAddData(bTemp);
;;;929    			
;;;930    			UART_PROTOCOL1_TxAddFrame();
;;;931    
;;;932    			free(pBuff);
;;;933    			
;;;934    			break;
;;;935    			
;;;936    		case UART_PROTOCOL1_CMD_VERSION_TYPE_READ:
;;;937    			tempVal = pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA1_INDEX];
;;;938    			
;;;939    			pBuff = (uint8 *)malloc(128);
;;;940    			if (NULL == pBuff)
;;;941    			{
;;;942    				break;
;;;943    			}
;;;944    			
;;;945    			// 清零
;;;946    			for (i = 0; i < 128; i++)
;;;947    			{
;;;948    				pBuff[i] = 0;
;;;949    			}
;;;950    
;;;951    			// 读取数据
;;;952    			SPI_FLASH_ReadArray(pBuff, PARAM_MCU_VERSION_ADDRESS[tempVal], 64+1);
;;;953    
;;;954    
;;;955    			// 添加设备地址
;;;956    			UART_PROTOCOL1_TxAddData(UART_PROTOCOL1_CMD_TX_DEVICE_ADDR);	
;;;957    						
;;;958    			// 添加帧长
;;;959    			UART_PROTOCOL1_TxAddData(5);
;;;960    							
;;;961    			// 添加命令字 
;;;962    			UART_PROTOCOL1_TxAddData(UART_PROTOCOL1_CMD_VERSION_TYPE_READ);
;;;963    
;;;964    			// 类型
;;;965    			UART_PROTOCOL1_TxAddData(tempVal);
;;;966    
;;;967    			switch (tempVal)
;;;968    			{
;;;969    				case 0:
;;;970    				case 1:
;;;971    				case 2:
;;;972    				case 3:
;;;973    				case 4:
;;;974    					if ((pBuff[0] > 0) && (pBuff[0] < 64))
;;;975    					{
;;;976    						// 信息长度
;;;977    						UART_PROTOCOL1_TxAddData(pBuff[0]);
;;;978    
;;;979    						// 类型信息
;;;980    						for (i = 0; i < pBuff[0]; i++)
;;;981    						{
;;;982    							UART_PROTOCOL1_TxAddData(pBuff[i+1]);
;;;983    						}
;;;984    					}
;;;985    					else
;;;986    					{
;;;987    						// 信息长度
;;;988    						UART_PROTOCOL1_TxAddData(0);
;;;989    					}
;;;990    					break;
;;;991    
;;;992    				case 5:
;;;993    				case 6:
;;;994    					// 信息长度
;;;995    					UART_PROTOCOL1_TxAddData(4);
;;;996    					
;;;997    					// 类型信息，高字节在前，低字节在后
;;;998    					UART_PROTOCOL1_TxAddData(pBuff[1]);
;;;999    					UART_PROTOCOL1_TxAddData(pBuff[2]);
;;;1000   					UART_PROTOCOL1_TxAddData(pBuff[3]);
;;;1001   					UART_PROTOCOL1_TxAddData(pBuff[4]);
;;;1002   					break;
;;;1003   					
;;;1004   				case 7:
;;;1005   					// 信息长度
;;;1006   					UART_PROTOCOL1_TxAddData(32);
;;;1007   
;;;1008   					// 类型信息
;;;1009   					for (i = 0; i < 32; i++)
;;;1010   					{
;;;1011   						UART_PROTOCOL1_TxAddData(pBuff[i+1]);
;;;1012   					}
;;;1013   					break;
;;;1014   
;;;1015   				default:
;;;1016   					break;
;;;1017   			}
;;;1018   
;;;1019   			UART_PROTOCOL1_TxAddFrame();
;;;1020   
;;;1021   			free(pBuff);
;;;1022   			
;;;1023   			break;
;;;1024   
;;;1025   		case UART_PROTOCOL1_CMD_TEST_LCD:
;;;1026   			STATE_EnterState(STATE_MAX);
;;;1027   			
;;;1028   			//LCD_ColorControl(pCmdFrame->buff[UART_PROTOCOL1_CMD_DATA1_INDEX]);
;;;1029   			break;
;;;1030   			
;;;1031   		default:
;;;1032   			break;
;;;1033   	}
;;;1034   
;;;1035   	// 启动UART总线通讯超时判断
;;;1036   	UART_PROTOCOL1_StartTimeoutCheckTask();
;;;1037   	
;;;1038   	// 删除命令帧
;;;1039   	pCB->rx.head ++;
;;;1040   	pCB->rx.head %= UART_PROTOCOL1_RX_QUEUE_SIZE;
;;;1041   }
00003a  e8bd9ff0          POP      {r4-r12,pc}
                  |L5.62|
00003e  7920              LDRB     r0,[r4,#4]            ;594
000040  f8dfa35c          LDR      r10,|L5.928|
000044  2701              MOVS     r7,#1                 ;609
000046  4ed7              LDR      r6,|L5.932|
000048  f04f0800          MOV      r8,#0                 ;609
00004c  28a8              CMP      r0,#0xa8              ;597
00004e  d07d              BEQ      |L5.332|
000050  dc0a              BGT      |L5.104|
000052  2800              CMP      r0,#0                 ;597
000054  d017              BEQ      |L5.134|
000056  2801              CMP      r0,#1                 ;597
000058  d00f              BEQ      |L5.122|
00005a  f8df834c          LDR      r8,|L5.936|
00005e  28a6              CMP      r0,#0xa6              ;597
000060  d075              BEQ      |L5.334|
000062  28a7              CMP      r0,#0xa7              ;597
                  |L5.100|
000064  d10f              BNE      |L5.134|
000066  e0d5              B        |L5.532|
                  |L5.104|
000068  28a9              CMP      r0,#0xa9              ;597
00006a  d071              BEQ      |L5.336|
00006c  28aa              CMP      r0,#0xaa              ;597
00006e  d070              BEQ      |L5.338|
000070  28c0              CMP      r0,#0xc0              ;597
000072  d009              BEQ      |L5.136|
000074  28c2              CMP      r0,#0xc2              ;597
000076  d1f5              BNE      |L5.100|
000078  e0a3              B        |L5.450|
                  |L5.122|
00007a  210a              MOVS     r1,#0xa               ;606
00007c  1d60              ADDS     r0,r4,#5              ;606
00007e  f7fffffe          BL       UART_PROTOCOL1_OnReceiveReport
000082  f886747e          STRB     r7,[r6,#0x47e]        ;609
                  |L5.134|
000086  e17e              B        |L5.902|
                  |L5.136|
000088  79a0              LDRB     r0,[r4,#6]            ;616
00008a  2818              CMP      r0,#0x18              ;616
00008c  d004              BEQ      |L5.152|
00008e  7960              LDRB     r0,[r4,#5]            ;616
000090  2824              CMP      r0,#0x24              ;616
000092  d001              BEQ      |L5.152|
000094  2830              CMP      r0,#0x30              ;616
000096  d102              BNE      |L5.158|
                  |L5.152|
000098  7960              LDRB     r0,[r4,#5]            ;618
00009a  f8860330          STRB     r0,[r6,#0x330]        ;618
                  |L5.158|
00009e  79a0              LDRB     r0,[r4,#6]            ;622
0000a0  1e41              SUBS     r1,r0,#1              ;622
0000a2  2904              CMP      r1,#4                 ;622
0000a4  d801              BHI      |L5.170|
0000a6  f8860318          STRB     r0,[r6,#0x318]        ;624
                  |L5.170|
0000aa  79e0              LDRB     r0,[r4,#7]            ;628
0000ac  280a              CMP      r0,#0xa               ;628
0000ae  d801              BHI      |L5.180|
0000b0  f8860319          STRB     r0,[r6,#0x319]        ;630
                  |L5.180|
0000b4  7a20              LDRB     r0,[r4,#8]            ;634
0000b6  2802              CMP      r0,#2                 ;634
0000b8  d801              BHI      |L5.190|
0000ba  f88602fc          STRB     r0,[r6,#0x2fc]        ;636
                  |L5.190|
0000be  7a60              LDRB     r0,[r4,#9]            ;640
0000c0  2803              CMP      r0,#3                 ;640
0000c2  d003              BEQ      |L5.204|
0000c4  2805              CMP      r0,#5                 ;640
0000c6  d001              BEQ      |L5.204|
0000c8  2809              CMP      r0,#9                 ;640
0000ca  d103              BNE      |L5.212|
                  |L5.204|
0000cc  f8860312          STRB     r0,[r6,#0x312]        ;642
0000d0  f7fffffe          BL       NVM_SetPWMLimitValue
                  |L5.212|
0000d4  7aa0              LDRB     r0,[r4,#0xa]          ;646
0000d6  f88602fd          STRB     r0,[r6,#0x2fd]        ;646
0000da  7ae0              LDRB     r0,[r4,#0xb]          ;649
0000dc  f88602fe          STRB     r0,[r6,#0x2fe]        ;649
0000e0  7b20              LDRB     r0,[r4,#0xc]          ;652
0000e2  f88602ff          STRB     r0,[r6,#0x2ff]        ;652
0000e6  7b60              LDRB     r0,[r4,#0xd]          ;655
0000e8  1e41              SUBS     r1,r0,#1              ;655
0000ea  29fe              CMP      r1,#0xfe              ;655
0000ec  d801              BHI      |L5.242|
0000ee  f88602f1          STRB     r0,[r6,#0x2f1]        ;657
                  |L5.242|
0000f2  7ba0              LDRB     r0,[r4,#0xe]          ;661
0000f4  0201              LSLS     r1,r0,#8              ;662
0000f6  7be0              LDRB     r0,[r4,#0xf]          ;663
0000f8  4308              ORRS     r0,r0,r1              ;663
0000fa  f8a602ae          STRH     r0,[r6,#0x2ae]        ;665
0000fe  7c20              LDRB     r0,[r4,#0x10]         ;726
000100  1ec1              SUBS     r1,r0,#3              ;726
000102  2915              CMP      r1,#0x15              ;726
000104  d801              BHI      |L5.266|
000106  f8860300          STRB     r0,[r6,#0x300]        ;728
                  |L5.266|
00010a  7c60              LDRB     r0,[r4,#0x11]         ;732
00010c  2805              CMP      r0,#5                 ;732
00010e  d801              BHI      |L5.276|
000110  f8860301          STRB     r0,[r6,#0x301]        ;734
                  |L5.276|
000114  7ca0              LDRB     r0,[r4,#0x12]         ;738
000116  f8860303          STRB     r0,[r6,#0x303]        ;738
00011a  7ce0              LDRB     r0,[r4,#0x13]         ;741
00011c  eb000080          ADD      r0,r0,r0,LSL #2       ;741
000120  0040              LSLS     r0,r0,#1              ;741
000122  f8a6032c          STRH     r0,[r6,#0x32c]        ;741
000126  7d20              LDRB     r0,[r4,#0x14]         ;744
000128  eb000140          ADD      r1,r0,r0,LSL #1       ;744
00012c  ebc110c0          RSB      r0,r1,r0,LSL #7       ;744
000130  f64f71ff          MOV      r1,#0xffff            ;744
000134  ea0100c0          AND      r0,r1,r0,LSL #3       ;744
000138  f8a602f8          STRH     r0,[r6,#0x2f8]        ;744
00013c  7d60              LDRB     r0,[r4,#0x15]         ;747
00013e  0201              LSLS     r1,r0,#8              ;748
000140  7da0              LDRB     r0,[r4,#0x16]         ;749
000142  4308              ORRS     r0,r0,r1              ;749
000144  f8a602fa          STRH     r0,[r6,#0x2fa]        ;750
000148  7de0              LDRB     r0,[r4,#0x17]         ;753
00014a  e003              B        |L5.340|
                  |L5.332|
00014c  e07a              B        |L5.580|
                  |L5.334|
00014e  e03c              B        |L5.458|
                  |L5.336|
000150  e0b6              B        |L5.704|
                  |L5.338|
000152  e115              B        |L5.896|
                  |L5.340|
000154  2805              CMP      r0,#5                 ;753
000156  d003              BEQ      |L5.352|
000158  2808              CMP      r0,#8                 ;753
00015a  d001              BEQ      |L5.352|
00015c  280c              CMP      r0,#0xc               ;753
00015e  d101              BNE      |L5.356|
                  |L5.352|
000160  f8860302          STRB     r0,[r6,#0x302]        ;755
                  |L5.356|
000164  7e20              LDRB     r0,[r4,#0x18]         ;759
000166  f886030d          STRB     r0,[r6,#0x30d]        ;759
00016a  7e60              LDRB     r0,[r4,#0x19]         ;762
00016c  1e41              SUBS     r1,r0,#1              ;762
00016e  293b              CMP      r1,#0x3b              ;762
000170  d801              BHI      |L5.374|
000172  f8860331          STRB     r0,[r6,#0x331]        ;764
                  |L5.374|
000176  7ea0              LDRB     r0,[r4,#0x1a]         ;768
000178  1f41              SUBS     r1,r0,#5              ;768
00017a  29fa              CMP      r1,#0xfa              ;768
00017c  d804              BHI      |L5.392|
00017e  f44f717a          MOV      r1,#0x3e8             ;770
000182  4348              MULS     r0,r1,r0              ;770
000184  f8c60314          STR      r0,[r6,#0x314]        ;770  ; paramCB
                  |L5.392|
000188  f8940020          LDRB     r0,[r4,#0x20]         ;783
00018c  280a              CMP      r0,#0xa               ;783
00018e  d801              BHI      |L5.404|
000190  f886032e          STRB     r0,[r6,#0x32e]        ;785
                  |L5.404|
000194  f8940021          LDRB     r0,[r4,#0x21]         ;789
000198  b110              CBZ      r0,|L5.416|
00019a  f8867311          STRB     r7,[r6,#0x311]        ;791
00019e  e001              B        |L5.420|
                  |L5.416|
0001a0  f8868311          STRB     r8,[r6,#0x311]        ;795
                  |L5.420|
0001a4  f8940022          LDRB     r0,[r4,#0x22]         ;799
0001a8  b110              CBZ      r0,|L5.432|
0001aa  f886731b          STRB     r7,[r6,#0x31b]        ;801
0001ae  e001              B        |L5.436|
                  |L5.432|
0001b0  f886831b          STRB     r8,[r6,#0x31b]        ;805
                  |L5.436|
0001b4  2001              MOVS     r0,#1                 ;809
0001b6  f7fffffe          BL       NVM_SetDirtyFlag
0001ba  2001              MOVS     r0,#1                 ;812
0001bc  f7fffffe          BL       UART_PROTOCOL1_ReportWriteParamResult
                  |L5.448|
0001c0  e0e1              B        |L5.902|
                  |L5.450|
0001c2  2001              MOVS     r0,#1                 ;817
0001c4  f7fffffe          BL       UART_PROTOCOL1_ReportConfigureParam
0001c8  e0dd              B        |L5.902|
                  |L5.458|
0001ca  2080              MOVS     r0,#0x80              ;822
0001cc  f7fffffe          BL       malloc
0001d0  4607              MOV      r7,r0                 ;822
0001d2  0038              MOVS     r0,r7                 ;823
0001d4  d0f4              BEQ      |L5.448|
0001d6  2001              MOVS     r0,#1                 ;829
0001d8  f7fffffe          BL       UART_PROTOCOL1_TxAddData
0001dc  2045              MOVS     r0,#0x45              ;832
0001de  f7fffffe          BL       UART_PROTOCOL1_TxAddData
0001e2  20a6              MOVS     r0,#0xa6              ;835
0001e4  f7fffffe          BL       UART_PROTOCOL1_TxAddData
0001e8  2040              MOVS     r0,#0x40              ;838
0001ea  f7fffffe          BL       UART_PROTOCOL1_TxAddData
0001ee  2240              MOVS     r2,#0x40              ;841
0001f0  4641              MOV      r1,r8                 ;841
0001f2  486c              LDR      r0,|L5.932|
0001f4  f7fffffe          BL       SPI_FLASH_ReadArray
0001f8  2400              MOVS     r4,#0                 ;842
                  |L5.506|
0001fa  5d30              LDRB     r0,[r6,r4]            ;844
0001fc  f7fffffe          BL       UART_PROTOCOL_TxAddData
000200  1c64              ADDS     r4,r4,#1              ;842
000202  b2a4              UXTH     r4,r4                 ;842
000204  2c40              CMP      r4,#0x40              ;842
000206  d3f8              BCC      |L5.506|
000208  f7fffffe          BL       UART_PROTOCOL1_TxAddFrame
00020c  4638              MOV      r0,r7                 ;849
00020e  f7fffffe          BL       free
000212  e0b8              B        |L5.902|
                  |L5.532|
000214  7960              LDRB     r0,[r4,#5]            ;854
000216  2204              MOVS     r2,#4                 ;857
000218  eb080180          ADD      r1,r8,r0,LSL #2       ;857
00021c  1da0              ADDS     r0,r4,#6              ;857
00021e  f7fffffe          BL       SPI_FLASH_WriteWithErase
000222  f7fffffe          BL       PARAM_Init
000226  2001              MOVS     r0,#1                 ;864
000228  f7fffffe          BL       UART_PROTOCOL1_TxAddData
00022c  2005              MOVS     r0,#5                 ;867
00022e  f7fffffe          BL       UART_PROTOCOL1_TxAddData
000232  20a7              MOVS     r0,#0xa7              ;870
000234  f7fffffe          BL       UART_PROTOCOL1_TxAddData
000238  2001              MOVS     r0,#1                 ;872
00023a  f7fffffe          BL       UART_PROTOCOL1_TxAddData
00023e  f7fffffe          BL       UART_PROTOCOL1_TxAddFrame
000242  e0a0              B        |L5.902|
                  |L5.580|
000244  7967              LDRB     r7,[r4,#5]            ;880
000246  f894b006          LDRB     r11,[r4,#6]           ;883
00024a  2080              MOVS     r0,#0x80              ;885
00024c  f7fffffe          BL       malloc
000250  4606              MOV      r6,r0                 ;885
000252  0030              MOVS     r0,r6                 ;886
000254  d033              BEQ      |L5.702|
000256  2000              MOVS     r0,#0                 ;892
                  |L5.600|
000258  f8068000          STRB     r8,[r6,r0]            ;894
00025c  1c40              ADDS     r0,r0,#1              ;892
00025e  b280              UXTH     r0,r0                 ;892
000260  2880              CMP      r0,#0x80              ;892
000262  d3f9              BCC      |L5.600|
000264  2000              MOVS     r0,#0                 ;897
000266  f10b0b01          ADD      r11,r11,#1            ;897
00026a  e004              B        |L5.630|
                  |L5.620|
00026c  1821              ADDS     r1,r4,r0              ;899
00026e  7989              LDRB     r1,[r1,#6]            ;899
000270  5431              STRB     r1,[r6,r0]            ;899
000272  1c40              ADDS     r0,r0,#1              ;897
000274  b280              UXTH     r0,r0                 ;897
                  |L5.630|
000276  4558              CMP      r0,r11                ;897
000278  d3f8              BCC      |L5.620|
00027a  2f10              CMP      r7,#0x10              ;903
00027c  d80a              BHI      |L5.660|
00027e  fa1ff28b          UXTH     r2,r11                ;905
000282  f85a1027          LDR      r1,[r10,r7,LSL #2]    ;905
000286  4630              MOV      r0,r6                 ;905
000288  f7fffffe          BL       SPI_FLASH_WriteWithErase
00028c  f7fffffe          BL       PARAM_Init
000290  2401              MOVS     r4,#1                 ;908
000292  e000              B        |L5.662|
                  |L5.660|
000294  2400              MOVS     r4,#0                 ;912
                  |L5.662|
000296  2001              MOVS     r0,#1                 ;916
000298  f7fffffe          BL       UART_PROTOCOL1_TxAddData
00029c  2005              MOVS     r0,#5                 ;919
00029e  f7fffffe          BL       UART_PROTOCOL1_TxAddData
0002a2  20a8              MOVS     r0,#0xa8              ;922
0002a4  f7fffffe          BL       UART_PROTOCOL1_TxAddData
0002a8  b2f8              UXTB     r0,r7                 ;925
0002aa  f7fffffe          BL       UART_PROTOCOL1_TxAddData
0002ae  4620              MOV      r0,r4                 ;928
0002b0  f7fffffe          BL       UART_PROTOCOL1_TxAddData
0002b4  f7fffffe          BL       UART_PROTOCOL1_TxAddFrame
0002b8  4630              MOV      r0,r6                 ;932
0002ba  f7fffffe          BL       free
                  |L5.702|
0002be  e062              B        |L5.902|
                  |L5.704|
0002c0  7966              LDRB     r6,[r4,#5]            ;937
0002c2  2080              MOVS     r0,#0x80              ;939
0002c4  f7fffffe          BL       malloc
0002c8  4604              MOV      r4,r0                 ;939
0002ca  0020              MOVS     r0,r4                 ;940
0002cc  d05b              BEQ      |L5.902|
0002ce  2000              MOVS     r0,#0                 ;946
                  |L5.720|
0002d0  f8048000          STRB     r8,[r4,r0]            ;948
0002d4  1c40              ADDS     r0,r0,#1              ;946
0002d6  b280              UXTH     r0,r0                 ;946
0002d8  2880              CMP      r0,#0x80              ;946
0002da  d3f9              BCC      |L5.720|
0002dc  f85a1026          LDR      r1,[r10,r6,LSL #2]    ;952
0002e0  2241              MOVS     r2,#0x41              ;952
0002e2  4620              MOV      r0,r4                 ;952
0002e4  f7fffffe          BL       SPI_FLASH_ReadArray
0002e8  2001              MOVS     r0,#1                 ;956
0002ea  f7fffffe          BL       UART_PROTOCOL1_TxAddData
0002ee  2005              MOVS     r0,#5                 ;959
0002f0  f7fffffe          BL       UART_PROTOCOL1_TxAddData
0002f4  20a9              MOVS     r0,#0xa9              ;962
0002f6  f7fffffe          BL       UART_PROTOCOL1_TxAddData
0002fa  b2f0              UXTB     r0,r6                 ;965
0002fc  f7fffffe          BL       UART_PROTOCOL1_TxAddData
000300  2e08              CMP      r6,#8                 ;967
000302  d237              BCS      |L5.884|
000304  e8dff006          TBB      [pc,r6]               ;967
000308  04040404          DCB      0x04,0x04,0x04,0x04
00030c  041a1a2a          DCB      0x04,0x1a,0x1a,0x2a
000310  7820              LDRB     r0,[r4,#0]            ;974
000312  1e41              SUBS     r1,r0,#1              ;974
000314  293f              CMP      r1,#0x3f              ;974
000316  d20d              BCS      |L5.820|
000318  f7fffffe          BL       UART_PROTOCOL1_TxAddData
00031c  2600              MOVS     r6,#0                 ;980
00031e  e005              B        |L5.812|
                  |L5.800|
000320  19a0              ADDS     r0,r4,r6              ;982
000322  7840              LDRB     r0,[r0,#1]            ;982
000324  f7fffffe          BL       UART_PROTOCOL1_TxAddData
000328  1c76              ADDS     r6,r6,#1              ;980
00032a  b2b6              UXTH     r6,r6                 ;980
                  |L5.812|
00032c  7820              LDRB     r0,[r4,#0]            ;980
00032e  42b0              CMP      r0,r6                 ;980
000330  d8f6              BHI      |L5.800|
000332  e01f              B        |L5.884|
                  |L5.820|
000334  2000              MOVS     r0,#0                 ;988
000336  f7fffffe          BL       UART_PROTOCOL1_TxAddData
00033a  e01b              B        |L5.884|
00033c  2004              MOVS     r0,#4                 ;995
00033e  f7fffffe          BL       UART_PROTOCOL1_TxAddData
000342  7860              LDRB     r0,[r4,#1]            ;998
000344  f7fffffe          BL       UART_PROTOCOL1_TxAddData
000348  78a0              LDRB     r0,[r4,#2]            ;999
00034a  f7fffffe          BL       UART_PROTOCOL1_TxAddData
00034e  78e0              LDRB     r0,[r4,#3]            ;1000
000350  f7fffffe          BL       UART_PROTOCOL1_TxAddData
000354  7920              LDRB     r0,[r4,#4]            ;1001
000356  f7fffffe          BL       UART_PROTOCOL1_TxAddData
00035a  e00b              B        |L5.884|
00035c  2020              MOVS     r0,#0x20              ;1006
00035e  f7fffffe          BL       UART_PROTOCOL1_TxAddData
000362  2600              MOVS     r6,#0                 ;1009
                  |L5.868|
000364  19a0              ADDS     r0,r4,r6              ;1011
000366  7840              LDRB     r0,[r0,#1]            ;1011
000368  f7fffffe          BL       UART_PROTOCOL1_TxAddData
00036c  1c76              ADDS     r6,r6,#1              ;1009
00036e  b2b6              UXTH     r6,r6                 ;1009
000370  2e20              CMP      r6,#0x20              ;1009
000372  d3f7              BCC      |L5.868|
                  |L5.884|
000374  f7fffffe          BL       UART_PROTOCOL1_TxAddFrame
000378  4620              MOV      r0,r4                 ;1021
00037a  f7fffffe          BL       free
00037e  e002              B        |L5.902|
                  |L5.896|
000380  2027              MOVS     r0,#0x27              ;1026
000382  f7fffffe          BL       STATE_EnterState
                  |L5.902|
000386  f7fffffe          BL       UART_PROTOCOL1_StartTimeoutCheckTask
00038a  f8b5029c          LDRH     r0,[r5,#0x29c]        ;1039
00038e  1c40              ADDS     r0,r0,#1              ;1039
000390  b280              UXTH     r0,r0                 ;1039
000392  fbb0f1f9          UDIV     r1,r0,r9              ;1040
000396  fb090011          MLS      r0,r9,r1,r0           ;1040
00039a  f8a5029c          STRH     r0,[r5,#0x29c]        ;1040
00039e  e64c              B        |L5.58|
;;;1042   
                          ENDP

                  |L5.928|
                          DCD      PARAM_MCU_VERSION_ADDRESS
                  |L5.932|
                          DCD      paramCB
                  |L5.936|
                          DCD      0x003ff000

                          AREA ||i.UART_PROTOCOL1_ConfirmTempCmdFrameBuff||, CODE, READONLY, ALIGN=1

                  UART_PROTOCOL1_ConfirmTempCmdFrameBuff PROC
;;;313    // 将临时缓冲区添加到命令帧缓冲区中，其本质操作是承认临时缓冲区数据有效
;;;314    BOOL UART_PROTOCOL1_ConfirmTempCmdFrameBuff(UART_PROTOCOL1_CB* pCB)
000000  2800              CMP      r0,#0
;;;315    {
000002  d01a              BEQ      |L6.58|
;;;316    	UART_PROTOCOL1_RX_CMD_FRAME* pCmdFrame = NULL;
;;;317    	
;;;318    	// 参数合法性检验
;;;319    	if(NULL == pCB)
;;;320    	{
;;;321    		return FALSE;
;;;322    	}
;;;323    
;;;324    	// 临时缓冲区为空，不予添加
;;;325    	pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.end];
000004  f8b0129e          LDRH     r1,[r0,#0x29e]
000008  224d              MOVS     r2,#0x4d
00000a  434a              MULS     r2,r1,r2
00000c  eb000242          ADD      r2,r0,r2,LSL #1
;;;326    	if(0 == pCmdFrame->length)
000010  f8b22166          LDRH     r2,[r2,#0x166]
000014  b19a              CBZ      r2,|L6.62|
;;;327    	{
;;;328    		return FALSE;
;;;329    	}
;;;330    
;;;331    	// 添加
;;;332    	pCB->rx.end ++;
000016  1c49              ADDS     r1,r1,#1
000018  b289              UXTH     r1,r1
;;;333    	pCB->rx.end %= UART_PROTOCOL1_RX_QUEUE_SIZE;
00001a  2203              MOVS     r2,#3
00001c  fbb1f3f2          UDIV     r3,r1,r2
000020  fb021113          MLS      r1,r2,r3,r1
000024  f8a0129e          STRH     r1,[r0,#0x29e]
;;;334    	pCB->rx.cmdQueue[pCB->rx.end].length = 0;	// 该行的作用是将新的添加位置有效数据个数清零，以便将这个位置当做临时帧缓冲区
000028  2200              MOVS     r2,#0
00002a  234d              MOVS     r3,#0x4d
00002c  4359              MULS     r1,r3,r1
00002e  eb000041          ADD      r0,r0,r1,LSL #1
000032  f8a02166          STRH     r2,[r0,#0x166]
;;;335    	
;;;336    	return TRUE;
000036  2001              MOVS     r0,#1
;;;337    }
000038  4770              BX       lr
                  |L6.58|
00003a  2000              MOVS     r0,#0                 ;321
00003c  4770              BX       lr
                  |L6.62|
00003e  2000              MOVS     r0,#0                 ;328
000040  4770              BX       lr
;;;338    
                          ENDP


                          AREA ||i.UART_PROTOCOL1_DataCommunicationSequenceProcess||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL1_DataCommunicationSequenceProcess PROC
;;;1078   // 码表发送数据通讯时序处理
;;;1079   void UART_PROTOCOL1_DataCommunicationSequenceProcess(void)
000000  b510              PUSH     {r4,lr}
;;;1080   {
;;;1081   	// 立即发送请求或是周期性发送请求
;;;1082   	if ((uartProtocolCB1.txAtOnceRequest) || (uartProtocolCB1.txPeriodRequest))
000002  4c08              LDR      r4,|L7.36|
000004  f894047d          LDRB     r0,[r4,#0x47d]  ; uartProtocolCB1
000008  2800              CMP      r0,#0
00000a  d103              BNE      |L7.20|
00000c  f894047c          LDRB     r0,[r4,#0x47c]  ; uartProtocolCB1
000010  2800              CMP      r0,#0
000012  d006              BEQ      |L7.34|
                  |L7.20|
;;;1083   	{
;;;1084   		// 发送运行参数命令
;;;1085   		UART_PROTOCOL1_SendRuntimeParam();
000014  f7fffffe          BL       UART_PROTOCOL1_SendRuntimeParam
;;;1086   
;;;1087   		if (uartProtocolCB1.txAtOnceRequest)
;;;1088   		{
;;;1089   			// 重新复位参数下发定时器
;;;1090   //			TIMER_ResetTimer(TIMER_ID_PROTOCOL_PARAM_TX);
;;;1091   		}
;;;1092   
;;;1093   		uartProtocolCB1.txAtOnceRequest = FALSE;
000018  2000              MOVS     r0,#0
00001a  f884047d          STRB     r0,[r4,#0x47d]
;;;1094   		uartProtocolCB1.txPeriodRequest = FALSE;
00001e  f884047c          STRB     r0,[r4,#0x47c]
                  |L7.34|
;;;1095   	}
;;;1096   }
000022  bd10              POP      {r4,pc}
;;;1097   
                          ENDP

                  |L7.36|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOL1_DataStructInit||, CODE, READONLY, ALIGN=1

                  UART_PROTOCOL1_DataStructInit PROC
;;;246    // 数据结构初始化
;;;247    void UART_PROTOCOL1_DataStructInit(UART_PROTOCOL1_CB* pCB)
000000  2800              CMP      r0,#0
;;;248    {
000002  d027              BEQ      |L8.84|
;;;249    	uint16 i;
;;;250    	
;;;251    	// 参数合法性检验
;;;252    	if (NULL == pCB)
;;;253    	{
;;;254    		return;
;;;255    	}
;;;256    
;;;257    	pCB->tx.txBusy = FALSE;
000004  2200              MOVS     r2,#0
000006  f8802474          STRB     r2,[r0,#0x474]
;;;258    	pCB->tx.index = 0;
00000a  f8a02472          STRH     r2,[r0,#0x472]
;;;259    	pCB->tx.head = 0;
00000e  f8a0246e          STRH     r2,[r0,#0x46e]
;;;260    	pCB->tx.end = 0;
000012  f8a02470          STRH     r2,[r0,#0x470]
;;;261    	for(i = 0; i < UART_PROTOCOL1_TX_QUEUE_SIZE; i++)
000016  2100              MOVS     r1,#0
                  |L8.24|
;;;262    	{
;;;263    		pCB->tx.cmdQueue[i].length = 0;
000018  234d              MOVS     r3,#0x4d
00001a  434b              MULS     r3,r1,r3
00001c  eb000343          ADD      r3,r0,r3,LSL #1
000020  f8a32338          STRH     r2,[r3,#0x338]
000024  1c49              ADDS     r1,r1,#1              ;261
000026  b289              UXTH     r1,r1                 ;261
000028  2903              CMP      r1,#3                 ;261
00002a  d3f5              BCC      |L8.24|
;;;264    	}
;;;265    
;;;266    	pCB->rxFIFO.head = 0;
00002c  f8202fc8          STRH     r2,[r0,#0xc8]!
;;;267    	pCB->rxFIFO.end = 0;
000030  8042              STRH     r2,[r0,#2]
;;;268    	pCB->rxFIFO.currentProcessIndex = 0;
000032  8082              STRH     r2,[r0,#4]
;;;269    
;;;270    	pCB->rx.head = 0;
000034  f8a021d4          STRH     r2,[r0,#0x1d4]
;;;271    	pCB->rx.end  = 0;
000038  f8a021d6          STRH     r2,[r0,#0x1d6]
00003c  38c8              SUBS     r0,r0,#0xc8
;;;272    	for(i=0; i<UART_PROTOCOL1_RX_QUEUE_SIZE; i++)
00003e  2100              MOVS     r1,#0
                  |L8.64|
;;;273    	{
;;;274    		pCB->rx.cmdQueue[i].length = 0;
000040  234d              MOVS     r3,#0x4d
000042  434b              MULS     r3,r1,r3
000044  eb000343          ADD      r3,r0,r3,LSL #1
000048  f8a32166          STRH     r2,[r3,#0x166]
00004c  1c49              ADDS     r1,r1,#1              ;272
00004e  b289              UXTH     r1,r1                 ;272
000050  2903              CMP      r1,#3                 ;272
000052  d3f5              BCC      |L8.64|
                  |L8.84|
;;;275    	}
;;;276    }
000054  4770              BX       lr
;;;277    
                          ENDP


                          AREA ||i.UART_PROTOCOL1_Init||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL1_Init PROC
;;;98     // 协议初始化
;;;99     void UART_PROTOCOL1_Init(void)
000000  b510              PUSH     {r4,lr}
;;;100    {
;;;101    	// 协议层数据结构初始化
;;;102    	UART_PROTOCOL1_DataStructInit(&uartProtocolCB1);
000002  4808              LDR      r0,|L9.36|
000004  f7fffffe          BL       UART_PROTOCOL1_DataStructInit
;;;103    
;;;104    	// 向驱动层注册数据接收接口
;;;105    	UART_DRIVE_RegisterDataSendService(UART_PROTOCOL1_MacProcess);
000008  4807              LDR      r0,|L9.40|
00000a  f7fffffe          BL       UART_DRIVE_RegisterDataSendService
;;;106    
;;;107    	// 向驱动层注册数据发送接口
;;;108    	UART_PROTOCOL1_RegisterDataSendService(UART_DRIVE_AddTxArray);
00000e  4807              LDR      r0,|L9.44|
000010  f7fffffe          BL       UART_PROTOCOL1_RegisterDataSendService
;;;109    
;;;110    	// 注册间隔参数设置时间
;;;111    
;;;112    
;;;113    	// 设置参数层参数周期更新时间
;;;114    	PARAM_SetParamCycleTime(UART_PROTOCOL1_CMD_SEND_TIME);
000014  4906              LDR      r1,|L9.48|
000016  2064              MOVS     r0,#0x64
000018  f8a1021e          STRH     r0,[r1,#0x21e]
;;;115    
;;;116    	// 启动UART总线通讯超时判断
;;;117    	UART_PROTOCOL1_StartTimeoutCheckTask();
00001c  e8bd4010          POP      {r4,lr}
000020  f7ffbffe          B.W      UART_PROTOCOL1_StartTimeoutCheckTask
;;;118    
;;;119    	// 启动速度显示滤波控制定时器
;;;120    
;;;121    
;;;122    }
;;;123    
                          ENDP

                  |L9.36|
                          DCD      ||.bss||
                  |L9.40|
                          DCD      UART_PROTOCOL1_MacProcess
                  |L9.44|
                          DCD      UART_DRIVE_AddTxArray
                  |L9.48|
                          DCD      paramCB

                          AREA ||i.UART_PROTOCOL1_MacProcess||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL1_MacProcess PROC
;;;278    // UART报文接收处理函数(注意根据具体模块修改)
;;;279    void UART_PROTOCOL1_MacProcess(uint16 standarID, uint8* pData, uint16 length)
000000  e92d03f0          PUSH     {r4-r9}
;;;280    {
;;;281    	uint16 end = uartProtocolCB1.rxFIFO.end;
000004  4b10              LDR      r3,|L10.72|
000006  f8b340ca          LDRH     r4,[r3,#0xca]  ; uartProtocolCB1
;;;282    	uint16 head = uartProtocolCB1.rxFIFO.head;
00000a  f8b370c8          LDRH     r7,[r3,#0xc8]  ; uartProtocolCB1
;;;283    	uint8 rxdata = 0x00;
;;;284    	
;;;285    	// 接收数据
;;;286    	rxdata = *pData;
00000e  f891c000          LDRB     r12,[r1,#0]
;;;287    
;;;288    	// 一级缓冲区已满，不予接收
;;;289    	if((end + 1)%UART_PROTOCOL1_RX_FIFO_SIZE == head)
000012  1c65              ADDS     r5,r4,#1
000014  26c8              MOVS     r6,#0xc8
000016  fbb5f8f6          UDIV     r8,r5,r6
00001a  fb065518          MLS      r5,r6,r8,r5
00001e  42bd              CMP      r5,r7
000020  d00f              BEQ      |L10.66|
;;;290    	{
;;;291    		return;
;;;292    	}
;;;293    	// 一级缓冲区未满，接收 
;;;294    	else
;;;295    	{
;;;296    		// 将接收到的数据放到临时缓冲区中
;;;297    		uartProtocolCB1.rxFIFO.buff[end] = rxdata;
000022  f803c004          STRB     r12,[r3,r4]
;;;298    		uartProtocolCB1.rxFIFO.end ++;
000026  f8334fca          LDRH     r4,[r3,#0xca]!  ; uartProtocolCB1
00002a  1c64              ADDS     r4,r4,#1
00002c  801c              STRH     r4,[r3,#0]
;;;299    		uartProtocolCB1.rxFIFO.end %= UART_PROTOCOL1_RX_FIFO_SIZE;
00002e  881c              LDRH     r4,[r3,#0]  ; uartProtocolCB1
000030  fbb4f5f6          UDIV     r5,r4,r6
000034  fb064415          MLS      r4,r6,r5,r4
000038  801c              STRH     r4,[r3,#0]
;;;300    	}
;;;301    
;;;302    //====================================================================
;;;303    	// 借用KM5S协议解析
;;;304    	UART_PROTOCOL_MacProcess(standarID, pData, length);
00003a  e8bd03f0          POP      {r4-r9}
00003e  f7ffbffe          B.W      UART_PROTOCOL_MacProcess
                  |L10.66|
;;;305    }
000042  e8bd03f0          POP      {r4-r9}
000046  4770              BX       lr
;;;306    
                          ENDP

                  |L10.72|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOL1_OnReceiveReport||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL1_OnReceiveReport PROC
;;;1376   // 驱动器上报参数处理
;;;1377   void UART_PROTOCOL1_OnReceiveReport(uint8* pBuff, uint32 len)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;1378   {
;;;1379   	uint8 i;
;;;1380   	float fSpeedTemp;
;;;1381   	//PARAM_WHEEL_SIZE_ID wheelSizeID = PARAM_GetWheelSizeID();
;;;1382   	uint16 perimeter = 0;
;;;1383   	uint16 tempVal;
;;;1384   
;;;1385   	CHECK_PARAM_SAME_RETURN(NULL, pBuff);	
000004  2800              CMP      r0,#0
000006  d07d              BEQ      |L11.260|
;;;1386   	CHECK_PARAM_SAME_RETURN(0, len);
000008  2900              CMP      r1,#0
00000a  d07b              BEQ      |L11.260|
;;;1387   	//CHECK_PARAM_OVER_SAME_RETURN(wheelSizeID, PARAM_WHEEL_SIZE_MAX);
;;;1388   
;;;1389   	// 从缓存取出数据到结构体
;;;1390   	for (i = 0; (i < len) && (i < UART_PROTOCOL1_RX_PARAM_SIZE); i++)
00000c  2200              MOVS     r2,#0
;;;1391   	{
;;;1392   		hmiDriveCB1.rx.buff[i] = pBuff[i];
00000e  f8df91b0          LDR      r9,|L11.448|
000012  e005              B        |L11.32|
                  |L11.20|
000014  eb090402          ADD      r4,r9,r2
000018  5c83              LDRB     r3,[r0,r2]
00001a  70a3              STRB     r3,[r4,#2]
00001c  1c52              ADDS     r2,r2,#1              ;1390
00001e  b2d2              UXTB     r2,r2                 ;1390
                  |L11.32|
000020  428a              CMP      r2,r1                 ;1390
000022  d201              BCS      |L11.40|
000024  2a0a              CMP      r2,#0xa               ;1390
000026  d3f5              BCC      |L11.20|
                  |L11.40|
;;;1393   	}
;;;1394   
;;;1395   	// 到这里，即把驱动器上报的数据放入了 hmiDriveCB1.rx.buff 中
;;;1396   
;;;1397   	// 提取故障状态
;;;1398   	// 刹把故障
;;;1399   	if (hmiDriveCB1.rx.param.breakError)
000028  f8990002          LDRB     r0,[r9,#2]  ; hmiDriveCB1
;;;1400   	{
;;;1401   		PARAM_SetErrorCode(ERROR_TYPE_BREAK_ERROR);
00002c  4e65              LDR      r6,|L11.452|
00002e  0781              LSLS     r1,r0,#30             ;1399
000030  f04f0700          MOV      r7,#0                 ;1399
000034  d503              BPL      |L11.62|
000036  2102              MOVS     r1,#2
000038  f8861219          STRB     r1,[r6,#0x219]
00003c  e01f              B        |L11.126|
                  |L11.62|
;;;1402   	}
;;;1403   	// 欠压故障
;;;1404   	else if (hmiDriveCB1.rx.param.underVoltageProtectionError)
00003e  0701              LSLS     r1,r0,#28
000040  d503              BPL      |L11.74|
;;;1405   	{
;;;1406   		PARAM_SetErrorCode(ERROR_TYPE_BATTERY_UNDER_VOLTAGE_ERROR);
000042  2106              MOVS     r1,#6
000044  f8861219          STRB     r1,[r6,#0x219]
000048  e019              B        |L11.126|
                  |L11.74|
;;;1407   	}
;;;1408   	// 电机缺相故障
;;;1409   	else if (hmiDriveCB1.rx.param.motorPhaseError)
00004a  07c1              LSLS     r1,r0,#31
00004c  d003              BEQ      |L11.86|
;;;1410   	{
;;;1411   		PARAM_SetErrorCode(ERROR_TYPE_MOTOR_ERROR);
00004e  2107              MOVS     r1,#7
000050  f8861219          STRB     r1,[r6,#0x219]
000054  e013              B        |L11.126|
                  |L11.86|
;;;1412   	}
;;;1413   	// 转把故障
;;;1414   	else if (hmiDriveCB1.rx.param.turnBarError)
000056  0681              LSLS     r1,r0,#26
000058  d503              BPL      |L11.98|
;;;1415   	{
;;;1416   		PARAM_SetErrorCode(ERROR_TYPE_TURN_ERROR);
00005a  2108              MOVS     r1,#8
00005c  f8861219          STRB     r1,[r6,#0x219]
000060  e00d              B        |L11.126|
                  |L11.98|
;;;1417   	}
;;;1418   	// 控制器故障
;;;1419   	else if (hmiDriveCB1.rx.param.driverError)
000062  06c1              LSLS     r1,r0,#27
000064  d503              BPL      |L11.110|
;;;1420   	{
;;;1421   		PARAM_SetErrorCode(ERROR_TYPE_DRIVER_ERROR);
000066  2109              MOVS     r1,#9
000068  f8861219          STRB     r1,[r6,#0x219]
00006c  e007              B        |L11.126|
                  |L11.110|
;;;1422   	}
;;;1423   	// 霍尔故障
;;;1424   	else if (hmiDriveCB1.rx.param.holzerError)
00006e  0641              LSLS     r1,r0,#25
000070  d503              BPL      |L11.122|
;;;1425   	{
;;;1426   		PARAM_SetErrorCode(ERROR_TYPE_HALL_ERROR);
000072  2114              MOVS     r1,#0x14
000074  f8861219          STRB     r1,[r6,#0x219]
000078  e001              B        |L11.126|
                  |L11.122|
;;;1427   	}
;;;1428   	// 能收到命令，又排除所有的故障，确定无错误了
;;;1429   	else
;;;1430   	{
;;;1431   		PARAM_SetErrorCode(ERROR_TYPE_NO_ERROR);
00007a  f8867219          STRB     r7,[r6,#0x219]
                  |L11.126|
;;;1432   	}
;;;1433   
;;;1434   	// 提取定时巡航状态
;;;1435   	if (hmiDriveCB1.rx.param.cruiseState)
00007e  0742              LSLS     r2,r0,#29
;;;1436   	{
;;;1437   		PARAM_SetCruiseState(TRUE);
000080  f04f0101          MOV      r1,#1
000084  d502              BPL      |L11.140|
000086  f88611f6          STRB     r1,[r6,#0x1f6]
00008a  e001              B        |L11.144|
                  |L11.140|
;;;1438   	}
;;;1439   	else
;;;1440   	{
;;;1441   		PARAM_SetCruiseState(FALSE);
00008c  f88671f6          STRB     r7,[r6,#0x1f6]
                  |L11.144|
;;;1442   	}
;;;1443   
;;;1444   	// 提取6KM推车助力状态
;;;1445   	if (hmiDriveCB1.rx.param.cruise6kmState)
000090  0600              LSLS     r0,r0,#24
000092  d502              BPL      |L11.154|
;;;1446   	{
;;;1447   		PARAM_SetPushAssistState(TRUE);
000094  f88611f8          STRB     r1,[r6,#0x1f8]
000098  e001              B        |L11.158|
                  |L11.154|
;;;1448   	}
;;;1449   	else
;;;1450   	{
;;;1451   		PARAM_SetPushAssistState(FALSE);
00009a  f88671f8          STRB     r7,[r6,#0x1f8]
                  |L11.158|
;;;1452   	}
;;;1453   
;;;1454   	// 提取运行电流
;;;1455   	// 预留高字节的bit7为正负，目前保持为0; 当高字节的bit6为1时，表示单位为0.1A，为0时，电流的单位依然是1A
;;;1456   	tempVal = hmiDriveCB1.rx.param.ucCurBatteryCurrentH;
00009e  f8990004          LDRB     r0,[r9,#4]  ; hmiDriveCB1
;;;1457   	tempVal <<= 8;
0000a2  f64f7aff          MOV      r10,#0xffff
0000a6  ea0a2100          AND      r1,r10,r0,LSL #8
;;;1458   	tempVal |= hmiDriveCB1.rx.param.ucCurBatteryCurrentL;
0000aa  f8990005          LDRB     r0,[r9,#5]  ; hmiDriveCB1
0000ae  4308              ORRS     r0,r0,r1
;;;1459   	if (tempVal & 0x4000)
0000b0  0441              LSLS     r1,r0,#17
0000b2  d50e              BPL      |L11.210|
;;;1460   	{
;;;1461   		tempVal &= ~0xC000;
0000b4  f4204040          BIC      r0,r0,#0xc000
;;;1462   		PARAM_SetBatteryCurrent((uint16)(tempVal*0.1f*1000));
0000b8  f7fffffe          BL       __aeabi_ui2f
0000bc  4942              LDR      r1,|L11.456|
0000be  f7fffffe          BL       __aeabi_fmul
0000c2  4942              LDR      r1,|L11.460|
0000c4  f7fffffe          BL       __aeabi_fmul
0000c8  f7fffffe          BL       __aeabi_f2uiz
0000cc  f8a6016c          STRH     r0,[r6,#0x16c]
0000d0  e007              B        |L11.226|
                  |L11.210|
;;;1463   	}
;;;1464   	else
;;;1465   	{
;;;1466   		tempVal &= ~0xC000;
;;;1467   		PARAM_SetBatteryCurrent((uint16)(tempVal*1000));
0000d2  eb000140          ADD      r1,r0,r0,LSL #1
0000d6  ebc110c0          RSB      r0,r1,r0,LSL #7
0000da  ea0a00c0          AND      r0,r10,r0,LSL #3
0000de  f8a6016c          STRH     r0,[r6,#0x16c]
                  |L11.226|
;;;1468   	}
;;;1469   
;;;1470   	// 提取实时速度，单位:KM/H
;;;1471   	tempVal = 0;
;;;1472   	tempVal = hmiDriveCB1.rx.param.oneCycleTimeH;
0000e2  f8990007          LDRB     r0,[r9,#7]  ; hmiDriveCB1
;;;1473   	tempVal <<= 8;
0000e6  ea0a2000          AND      r0,r10,r0,LSL #8
;;;1474   	tempVal |= hmiDriveCB1.rx.param.oneCycleTimeL;
0000ea  f899b008          LDRB     r11,[r9,#8]  ; hmiDriveCB1
0000ee  ea4b0b00          ORR      r11,r11,r0
;;;1475   	// 建诺孙工确认大于等于3000时速度为零
;;;1476   	// 当收到控制器上报转一圈时间为3000时，就认为速度为0
;;;1477   	if(tempVal >= 3000UL)
0000f2  f64030b8          MOV      r0,#0xbb8
;;;1478   	{
;;;1479   		uartProtocolCB1.speedFilter.realSpeed = 0;
0000f6  f8df80d8          LDR      r8,|L11.464|
0000fa  4583              CMP      r11,r0                ;1477
0000fc  d303              BCC      |L11.262|
0000fe  f8a8747e          STRH     r7,[r8,#0x47e]
000102  e026              B        |L11.338|
                  |L11.260|
000104  e04f              B        |L11.422|
                  |L11.262|
;;;1480   	}
;;;1481   	else
;;;1482   	{
;;;1483   		//perimeter = PARAM_GetPerimeter((uint8)wheelSizeID);
;;;1484   		perimeter = PARAM_GetNewperimeter();
000106  f8b602b2          LDRH     r0,[r6,#0x2b2]  ; paramCB
;;;1485   		fSpeedTemp = (tempVal ? (3.6 / tempVal * perimeter) : 0);		
00010a  f1bb0f00          CMP      r11,#0
00010e  d011              BEQ      |L11.308|
000110  f7fffffe          BL       __aeabi_ui2d
000114  4604              MOV      r4,r0
000116  460d              MOV      r5,r1
000118  4658              MOV      r0,r11
00011a  f7fffffe          BL       __aeabi_ui2d
00011e  4602              MOV      r2,r0
000120  460b              MOV      r3,r1
000122  482c              LDR      r0,|L11.468|
000124  492c              LDR      r1,|L11.472|
000126  f7fffffe          BL       __aeabi_ddiv
00012a  4622              MOV      r2,r4
00012c  462b              MOV      r3,r5
00012e  f7fffffe          BL       __aeabi_dmul
000132  e001              B        |L11.312|
                  |L11.308|
000134  2000              MOVS     r0,#0
000136  4601              MOV      r1,r0
                  |L11.312|
000138  f7fffffe          BL       __aeabi_d2f
;;;1486   		LIMIT_TO_MAX(fSpeedTemp, 99.9);
00013c  4927              LDR      r1,|L11.476|
00013e  4288              CMP      r0,r1
000140  db00              BLT      |L11.324|
000142  4608              MOV      r0,r1
                  |L11.324|
;;;1487   		
;;;1488   		uartProtocolCB1.speedFilter.realSpeed = (uint16)(fSpeedTemp*10);		// 转换为0.1KM/H
000144  4926              LDR      r1,|L11.480|
000146  f7fffffe          BL       __aeabi_fmul
00014a  f7fffffe          BL       __aeabi_f2uiz
00014e  f8a8047e          STRH     r0,[r8,#0x47e]
                  |L11.338|
;;;1489   	}
;;;1490   
;;;1491   	// 另外一种方法滤波2017/12/04
;;;1492   	if (uartProtocolCB1.speedFilter.realSpeed >= uartProtocolCB1.speedFilter.proSpeed)
000152  f8b8447e          LDRH     r4,[r8,#0x47e]  ; uartProtocolCB1
000156  f8b80480          LDRH     r0,[r8,#0x480]  ; uartProtocolCB1
;;;1493   	{
;;;1494   		uartProtocolCB1.speedFilter.difSpeed = (uartProtocolCB1.speedFilter.realSpeed - uartProtocolCB1.speedFilter.proSpeed) / 5.0f;
00015a  4d22              LDR      r5,|L11.484|
00015c  4284              CMP      r4,r0                 ;1492
00015e  d30a              BCC      |L11.374|
000160  1a20              SUBS     r0,r4,r0
000162  f7fffffe          BL       __aeabi_i2f
000166  4629              MOV      r1,r5
000168  f7fffffe          BL       __aeabi_fdiv
00016c  f7fffffe          BL       __aeabi_f2uiz
000170  f8a80482          STRH     r0,[r8,#0x482]
000174  e00e              B        |L11.404|
                  |L11.374|
;;;1495   	}
;;;1496   	else
;;;1497   	{
;;;1498   		uartProtocolCB1.speedFilter.difSpeed = (uartProtocolCB1.speedFilter.proSpeed -  uartProtocolCB1.speedFilter.realSpeed) / 5.0f;
000176  1b00              SUBS     r0,r0,r4
000178  f7fffffe          BL       __aeabi_i2f
00017c  4629              MOV      r1,r5
00017e  f7fffffe          BL       __aeabi_fdiv
000182  f7fffffe          BL       __aeabi_f2uiz
000186  b280              UXTH     r0,r0
000188  f8a80482          STRH     r0,[r8,#0x482]
;;;1499   
;;;1500   		// 实际速度为0，差值也为0，显示速度也应该为0，避免1km/h以下的值
;;;1501   		if ((0 == uartProtocolCB1.speedFilter.difSpeed) && (0 == uartProtocolCB1.speedFilter.realSpeed))
00018c  b910              CBNZ     r0,|L11.404|
00018e  b90c              CBNZ     r4,|L11.404|
;;;1502   		{
;;;1503   			uartProtocolCB1.speedFilter.proSpeed = 0;
000190  f8a87480          STRH     r7,[r8,#0x480]
                  |L11.404|
;;;1504   		}
;;;1505   	}
;;;1506   
;;;1507   	if (BATTERY_DATA_SRC_CONTROLLER == PARAM_GetBatteryDataSrc())
000194  f8960173          LDRB     r0,[r6,#0x173]  ; paramCB
000198  b138              CBZ      r0,|L11.426|
;;;1508   	{
;;;1509   		// 锂电2号没有电压上报的字段，故为了兼容人为采用固定电压
;;;1510   		tempVal = PARAM_GetBatteryVoltageLevel();
;;;1511   		tempVal *= 1000;											// 单位转换: 1V转换为1000mV	
;;;1512   		
;;;1513   		PARAM_SetBatteryVoltage(tempVal);
;;;1514   	}
;;;1515   	else if (BATTERY_DATA_SRC_BMS == PARAM_GetBatteryDataSrc())
00019a  2801              CMP      r0,#1
00019c  d103              BNE      |L11.422|
;;;1516   	{
;;;1517   		// 电量
;;;1518   		PARAM_SetBatteryPercent(hmiDriveCB1.rx.param.batteryCapacity);
00019e  f8990009          LDRB     r0,[r9,#9]  ; hmiDriveCB1
0001a2  f8860172          STRB     r0,[r6,#0x172]
                  |L11.422|
;;;1519   	}
;;;1520   
;;;1521   }
0001a6  e8bd9ff0          POP      {r4-r12,pc}
                  |L11.426|
0001aa  f8960330          LDRB     r0,[r6,#0x330]        ;1510  ; paramCB
0001ae  eb000140          ADD      r1,r0,r0,LSL #1       ;1511
0001b2  ebc110c0          RSB      r0,r1,r0,LSL #7       ;1511
0001b6  ea0a00c0          AND      r0,r10,r0,LSL #3      ;1511
0001ba  f8c60168          STR      r0,[r6,#0x168]        ;1513  ; paramCB
0001be  e7f2              B        |L11.422|
;;;1522   
                          ENDP

                  |L11.448|
                          DCD      ||.bss||+0x484
                  |L11.452|
                          DCD      paramCB
                  |L11.456|
                          DCD      0x3dcccccd
                  |L11.460|
                          DCD      0x447a0000
                  |L11.464|
                          DCD      ||.bss||
                  |L11.468|
                          DCD      0xcccccccd
                  |L11.472|
                          DCD      0x400ccccc
                  |L11.476|
                          DCD      0x42c7cccd
                  |L11.480|
                          DCD      0x41200000
                  |L11.484|
                          DCD      0x40a00000

                          AREA ||i.UART_PROTOCOL1_Process||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL1_Process PROC
;;;158    // UART协议层过程处理
;;;159    void UART_PROTOCOL1_Process(void)
000000  b510              PUSH     {r4,lr}
;;;160    {
;;;161    	// UART接收FIFO缓冲区处理
;;;162    	UART_PROTOCOL1_RxFIFOProcess(&uartProtocolCB1);
000002  4807              LDR      r0,|L12.32|
000004  f7fffffe          BL       UART_PROTOCOL1_RxFIFOProcess
;;;163    
;;;164    	// UART接收命令缓冲区处理
;;;165    	UART_PROTOCOL1_CmdFrameProcess(&uartProtocolCB1);
000008  4805              LDR      r0,|L12.32|
00000a  f7fffffe          BL       UART_PROTOCOL1_CmdFrameProcess
;;;166    	
;;;167    	// UART协议层发送处理过程
;;;168    	UART_PROTOCOL1_TxStateProcess();
00000e  f7fffffe          BL       UART_PROTOCOL1_TxStateProcess
;;;169    
;;;170    	// 码表发送数据通讯时序处理
;;;171    	UART_PROTOCOL1_DataCommunicationSequenceProcess();
000012  f7fffffe          BL       UART_PROTOCOL1_DataCommunicationSequenceProcess
;;;172    
;;;173    //=========================================================
;;;174    	// 在锂电2号协议中嵌入KM5S协议
;;;175    	UART_PROTOCOL_Process();
000016  e8bd4010          POP      {r4,lr}
00001a  f7ffbffe          B.W      UART_PROTOCOL_Process
;;;176    }
;;;177    
                          ENDP

00001e  0000              DCW      0x0000
                  |L12.32|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOL1_RegisterDataSendService||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL1_RegisterDataSendService PROC
;;;307    // UART协议层向驱动层注册数据发送接口
;;;308    void UART_PROTOCOL1_RegisterDataSendService(BOOL (*service)(uint16 id, uint8 *pData, uint16 length))
000000  4901              LDR      r1,|L13.8|
;;;309    {		
;;;310    	uartProtocolCB1.sendDataThrowService = service;
000002  f8c10478          STR      r0,[r1,#0x478]  ; uartProtocolCB1
;;;311    }
000006  4770              BX       lr
;;;312    
                          ENDP

                  |L13.8|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOL1_ReportConfigureParam||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL1_ReportConfigureParam PROC
;;;1543   // 上报配置参数
;;;1544   void UART_PROTOCOL1_ReportConfigureParam(uint32 param)
000000  b570              PUSH     {r4-r6,lr}
;;;1545   {
;;;1546   	uint32 tempVal;
;;;1547   	uint16 wheelSize;
;;;1548   	
;;;1549   	// 添加设备地址
;;;1550   	UART_PROTOCOL1_TxAddData(UART_PROTOCOL1_CMD_TX_DEVICE_ADDR);
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1551   
;;;1552   	// 添加数据长度
;;;1553   	UART_PROTOCOL1_TxAddData(27);
000008  201b              MOVS     r0,#0x1b
00000a  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1554   
;;;1555   	// 添加命令字
;;;1556   	UART_PROTOCOL1_TxAddData(UART_PROTOCOL1_CMD_READ_CONTROL_PARAM_REPORT);
00000e  20c3              MOVS     r0,#0xc3
000010  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1557   
;;;1558   	// 电池电压等级
;;;1559   	UART_PROTOCOL1_TxAddData(PARAM_GetBatteryVoltageLevel());
000014  4c32              LDR      r4,|L14.224|
000016  f8940034          LDRB     r0,[r4,#0x34]  ; paramCB
00001a  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1560   
;;;1561   	// 背光亮度
;;;1562   	UART_PROTOCOL1_TxAddData(PARAM_GetBrightness());
00001e  7f20              LDRB     r0,[r4,#0x1c]  ; paramCB
000020  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1563   
;;;1564   	// 休眠时间
;;;1565   	UART_PROTOCOL1_TxAddData(PARAM_GetPowerOffTime());
000024  7f60              LDRB     r0,[r4,#0x1d]  ; paramCB
000026  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1566   
;;;1567   	// 驱动器驱动方式
;;;1568   	UART_PROTOCOL1_TxAddData(PARAM_GetDriverControlMode());
00002a  7820              LDRB     r0,[r4,#0]  ; paramCB
00002c  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1569   
;;;1570   	// 助力档位数
;;;1571   	UART_PROTOCOL1_TxAddData(PARAM_GetMaxAssist());
000030  7da0              LDRB     r0,[r4,#0x16]  ; paramCB
000032  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1572   
;;;1573   	// 零或非零启动方式
;;;1574   	UART_PROTOCOL1_TxAddData(PARAM_GetZeroStartOrNot());
000036  7860              LDRB     r0,[r4,#1]  ; paramCB
000038  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1575   
;;;1576   	// 切换巡航的方式
;;;1577   	UART_PROTOCOL1_TxAddData(PARAM_GetSwitchCruiseWay());
00003c  78a0              LDRB     r0,[r4,#2]  ; paramCB
00003e  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1578   
;;;1579   	// 巡航切换模式
;;;1580   	UART_PROTOCOL1_TxAddData(PARAM_GetSwitchCruiseMode());
000042  78e0              LDRB     r0,[r4,#3]  ; paramCB
000044  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1581   
;;;1582   	// 测速磁钢
;;;1583   	UART_PROTOCOL1_TxAddData(PARAM_GetCycleOfSteelNum());
000048  f8140c0b          LDRB     r0,[r4,#-0xb]  ; paramCB
00004c  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1584   
;;;1585   	// 轮径
;;;1586   	/*switch (PARAM_GetWheelSizeID())
;;;1587   	{
;;;1588   		case PARAM_WHEEL_SIZE_14_INCH:
;;;1589   			wheelSize = 140;
;;;1590   			break;
;;;1591   
;;;1592   		case PARAM_WHEEL_SIZE_16_INCH:
;;;1593   			wheelSize = 160;
;;;1594   			break;
;;;1595   
;;;1596   		case PARAM_WHEEL_SIZE_18_INCH:
;;;1597   			wheelSize = 180;
;;;1598   			break;
;;;1599   
;;;1600   		case PARAM_WHEEL_SIZE_20_INCH:
;;;1601   			wheelSize = 200;
;;;1602   			break;
;;;1603   
;;;1604   		case PARAM_WHEEL_SIZE_22_INCH:
;;;1605   			wheelSize = 220;
;;;1606   			break;
;;;1607   
;;;1608   		case PARAM_WHEEL_SIZE_24_INCH:
;;;1609   			wheelSize = 240;
;;;1610   			break;
;;;1611   
;;;1612   		case PARAM_WHEEL_SIZE_26_INCH:
;;;1613   			wheelSize = 260;
;;;1614   			break;
;;;1615   
;;;1616   		case PARAM_WHEEL_SIZE_27_INCH:
;;;1617   			wheelSize = 270;
;;;1618   			break;
;;;1619   
;;;1620   		case PARAM_WHEEL_SIZE_27_5_INCH:
;;;1621   			wheelSize = 275;
;;;1622   			break;
;;;1623   
;;;1624   		case PARAM_WHEEL_SIZE_28_INCH:
;;;1625   			wheelSize = 280;
;;;1626   			break;
;;;1627   
;;;1628   		case PARAM_WHEEL_SIZE_29_INCH:
;;;1629   			wheelSize = 290;
;;;1630   			break;
;;;1631   
;;;1632   		case PARAM_WHEEL_SIZE_700C:
;;;1633   			wheelSize = 7000;
;;;1634   			break;
;;;1635   
;;;1636   		default:
;;;1637   			wheelSize = 260;
;;;1638   			break;
;;;1639   			
;;;1640   	}
;;;1641   	*/
;;;1642   	wheelSize = PARAM_GetNewWheelSizeInch();
000050  f8345c4e          LDRH     r5,[r4,#-0x4e]  ; paramCB
;;;1643   	UART_PROTOCOL1_TxAddData(wheelSize>>8);
000054  0a28              LSRS     r0,r5,#8
000056  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1644   	UART_PROTOCOL1_TxAddData(wheelSize&0xFF);
00005a  b2e8              UXTB     r0,r5
00005c  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1645   
;;;1646   	// 助力灵敏度
;;;1647   	UART_PROTOCOL1_TxAddData(PARAM_GetAssistSensitivity());
000060  7920              LDRB     r0,[r4,#4]  ; paramCB
000062  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1648   
;;;1649   	// 助力启动强度
;;;1650   	UART_PROTOCOL1_TxAddData(PARAM_GetAssistStartIntensity());
000066  7960              LDRB     r0,[r4,#5]  ; paramCB
000068  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1651   
;;;1652   	// 限速电机换向霍尔磁钢数
;;;1653   	UART_PROTOCOL1_TxAddData(PARAM_GetReversalHolzerSteelNum());
00006c  79e0              LDRB     r0,[r4,#7]  ; paramCB
00006e  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1654   
;;;1655   	// 限速
;;;1656   	UART_PROTOCOL1_TxAddData(paramCB.nvm.param.common.speed.limitVal/10);
000072  8e20              LDRH     r0,[r4,#0x30]  ; paramCB
000074  210a              MOVS     r1,#0xa
000076  fbb0f0f1          UDIV     r0,r0,r1
00007a  b2c0              UXTB     r0,r0
00007c  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1657   
;;;1658   	// 限流
;;;1659   	UART_PROTOCOL1_TxAddData(PARAM_GetCurrentLimit()/1000);
000080  f8340c04          LDRH     r0,[r4,#-4]  ; paramCB
000084  f44f767a          MOV      r6,#0x3e8
000088  fbb0f0f6          UDIV     r0,r0,r6
00008c  b2c0              UXTB     r0,r0
00008e  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1660   
;;;1661   	// 欠压门限
;;;1662   	tempVal = PARAM_GetLowVoltageThreshold();		
000092  f8345c02          LDRH     r5,[r4,#-2]  ; paramCB
;;;1663   	UART_PROTOCOL1_TxAddData(tempVal>>8);
000096  0a28              LSRS     r0,r5,#8
000098  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1664   	UART_PROTOCOL1_TxAddData(tempVal&0xFF);
00009c  b2e8              UXTB     r0,r5
00009e  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1665   
;;;1666   	// 助力磁钢类型
;;;1667   	UART_PROTOCOL1_TxAddData(PARAM_GetSteelType());
0000a2  79a0              LDRB     r0,[r4,#6]  ; paramCB
0000a4  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1668   
;;;1669   	// 限速使能禁止标识
;;;1670   	UART_PROTOCOL1_TxAddData(PARAM_GetSpeedLimitSwitch());
0000a8  7c60              LDRB     r0,[r4,#0x11]  ; paramCB
0000aa  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1671   
;;;1672   	// 电量显示变化时间
;;;1673   	UART_PROTOCOL1_TxAddData(PARAM_GetBatteryCapVaryTime());
0000ae  f8940035          LDRB     r0,[r4,#0x35]  ; paramCB
0000b2  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1674   
;;;1675   	// 总线故障超时时间
;;;1676   	UART_PROTOCOL1_TxAddData(PARAM_GetBusAliveTime()/1000);
0000b6  69a0              LDR      r0,[r4,#0x18]  ; paramCB
0000b8  fbb0f0f6          UDIV     r0,r0,r6
0000bc  b2c0              UXTB     r0,r0
0000be  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1677   
;;;1678   	// 速度平滑度等级
;;;1679   	UART_PROTOCOL1_TxAddData(PARAM_GetSpeedFilterLevel());
0000c2  f8940032          LDRB     r0,[r4,#0x32]  ; paramCB
0000c6  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1680   
;;;1681   	// 公英制单位
;;;1682   	UART_PROTOCOL1_TxAddData(PARAM_GetUnit());
0000ca  7d60              LDRB     r0,[r4,#0x15]  ; paramCB
0000cc  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1683   	
;;;1684   	// 硬件是否有蓝牙
;;;1685   	UART_PROTOCOL1_TxAddData(PARAM_GetExistBle());
0000d0  7fe0              LDRB     r0,[r4,#0x1f]  ; paramCB
0000d2  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1686   	
;;;1687   	// 添加检验和，并添加至发送
;;;1688   	UART_PROTOCOL1_TxAddFrame();
0000d6  e8bd4070          POP      {r4-r6,lr}
0000da  f7ffbffe          B.W      UART_PROTOCOL1_TxAddFrame
;;;1689   }
;;;1690   
                          ENDP

0000de  0000              DCW      0x0000
                  |L14.224|
                          DCD      paramCB+0x2fc

                          AREA ||i.UART_PROTOCOL1_ReportWriteParamResult||, CODE, READONLY, ALIGN=1

                  UART_PROTOCOL1_ReportWriteParamResult PROC
;;;1524   // 上报写配置参数结果
;;;1525   void UART_PROTOCOL1_ReportWriteParamResult(uint32 param)
000000  b510              PUSH     {r4,lr}
;;;1526   {
000002  4604              MOV      r4,r0
;;;1527   	// 添加设备地址
;;;1528   	UART_PROTOCOL1_TxAddData(UART_PROTOCOL1_CMD_TX_DEVICE_ADDR);
000004  2001              MOVS     r0,#1
000006  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1529   
;;;1530   	// 添加数据长度，固定为5
;;;1531   	UART_PROTOCOL1_TxAddData(5);
00000a  2005              MOVS     r0,#5
00000c  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1532   
;;;1533   	// 添加命令字
;;;1534   	UART_PROTOCOL1_TxAddData(UART_PROTOCOL1_CMD_WRITE_CONTROL_PARAM_RESULT);
000010  20c1              MOVS     r0,#0xc1
000012  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1535   
;;;1536   	// 写入结果
;;;1537   	UART_PROTOCOL1_TxAddData(param);
000016  b2e0              UXTB     r0,r4
000018  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1538   
;;;1539   	// 添加检验和，并添加至发送
;;;1540   	UART_PROTOCOL1_TxAddFrame();
00001c  e8bd4010          POP      {r4,lr}
000020  f7ffbffe          B.W      UART_PROTOCOL1_TxAddFrame
;;;1541   }
;;;1542   
                          ENDP


                          AREA ||i.UART_PROTOCOL1_RxFIFOProcess||, CODE, READONLY, ALIGN=1

                  UART_PROTOCOL1_RxFIFOProcess PROC
;;;372    // 一级接收缓冲区处理，从一级接收缓冲区中取出一个字节添加到命令帧缓冲区中
;;;373    void UART_PROTOCOL1_RxFIFOProcess(UART_PROTOCOL1_CB* pCB)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;374    {
000004  4604              MOV      r4,r0
;;;375    	uint16 end = pCB->rxFIFO.end;
000006  f8b410ca          LDRH     r1,[r4,#0xca]
;;;376    	uint16 head = pCB->rxFIFO.head;
00000a  f8b400c8          LDRH     r0,[r4,#0xc8]
;;;377    	UART_PROTOCOL1_RX_CMD_FRAME* pCmdFrame = NULL;
;;;378    	uint16 length = 0;
;;;379    	uint8 currentData = 0;
;;;380    	
;;;381    	// 参数合法性检验
;;;382    	if(NULL == pCB)
00000e  2c00              CMP      r4,#0
000010  d021              BEQ      |L16.86|
;;;383    	{
;;;384    		return;
;;;385    	}
;;;386    	
;;;387    	// 一级缓冲区为空，退出
;;;388    	if(head == end)
000012  4288              CMP      r0,r1
000014  d01f              BEQ      |L16.86|
;;;389    	{
;;;390    		return;
;;;391    	}
;;;392    
;;;393    	// 获取临时缓冲区指针
;;;394    	pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.end];
000016  f8b4229e          LDRH     r2,[r4,#0x29e]
00001a  204d              MOVS     r0,#0x4d
00001c  4350              MULS     r0,r2,r0
00001e  eb040540          ADD      r5,r4,r0,LSL #1
000022  35ce              ADDS     r5,r5,#0xce
;;;395    	// 取出当前要处理的字节
;;;396    	currentData = pCB->rxFIFO.buff[pCB->rxFIFO.currentProcessIndex];
000024  f8b400cc          LDRH     r0,[r4,#0xcc]
000028  5c20              LDRB     r0,[r4,r0]
;;;397    	
;;;398    	// 临时缓冲区长度为0时，搜索首字节
;;;399    	if(0 == pCmdFrame->length)
00002a  f8b53098          LDRH     r3,[r5,#0x98]
;;;400    	{
;;;401    		// 命令头错误，删除当前字节并退出
;;;402    		if(UART_PROTOCOL1_CMD_RX_DEVICE_ADDR != currentData)
;;;403    		{
;;;404    			pCB->rxFIFO.head ++;
;;;405    			pCB->rxFIFO.head %= UART_PROTOCOL1_RX_FIFO_SIZE;
00002e  26c8              MOVS     r6,#0xc8
000030  b19b              CBZ      r3,|L16.90|
;;;406    			pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;407    
;;;408    			return;
;;;409    		}
;;;410    		
;;;411    		// 命令头正确，但无临时缓冲区可用，退出
;;;412    		if((pCB->rx.end + 1)%UART_PROTOCOL1_RX_QUEUE_SIZE == pCB->rx.head)
;;;413    		{
;;;414    			return;
;;;415    		}
;;;416    
;;;417    		// 添加UART通讯超时时间设置-2016.1.5增加
;;;418    #if UART_PROTOCOL1_RX_TIME_OUT_CHECK_ENABLE
;;;419    		TIMER_AddTask(TIMER_ID_UART_RX_TIME_OUT_CONTROL,
;;;420    						UART_PROTOCOL1_BUS_UNIDIRECTIONAL_TIME_OUT,
;;;421    						UART_PROTOCOL1_CALLBACK_RxTimeOut,
;;;422    						0,
;;;423    						1,
;;;424    						ACTION_MODE_ADD_TO_QUEUE);
;;;425    #endif
;;;426    		
;;;427    		// 命令头正确，有临时缓冲区可用，则将其添加到命令帧临时缓冲区中
;;;428    		pCmdFrame->buff[pCmdFrame->length++]= currentData;
;;;429    		pCB->rxFIFO.currentProcessIndex ++;
;;;430    		pCB->rxFIFO.currentProcessIndex %= UART_PROTOCOL1_RX_FIFO_SIZE;
;;;431    	}
;;;432    	// 非首字节，将数据添加到命令帧临时缓冲区中，但暂不删除当前数据
;;;433    	else
;;;434    	{
;;;435    		// 临时缓冲区溢出，说明当前正在接收的命令帧是错误的，正确的命令帧不会出现长度溢出的情况
;;;436    		if(pCmdFrame->length >= UART_PROTOCOL1_RX_CMD_FRAME_LENGTH_MAX)
000032  f04f0800          MOV      r8,#0
000036  2b96              CMP      r3,#0x96
000038  d37e              BCC      |L16.312|
;;;437    		{
;;;438    #if UART_PROTOCOL1_RX_TIME_OUT_CHECK_ENABLE
;;;439    			// 停止RX通讯超时检测
;;;440    			UART_PROTOCOL1_StopRxTimeOutCheck();
;;;441    #endif
;;;442    
;;;443    			// 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;444    			pCmdFrame->length = 0;	// 2016.1.5增加
00003a  f8a58098          STRH     r8,[r5,#0x98]
;;;445    			// 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;446    			pCB->rxFIFO.head ++;
00003e  f8340fc8          LDRH     r0,[r4,#0xc8]!
000042  1c40              ADDS     r0,r0,#1
000044  8020              STRH     r0,[r4,#0]
;;;447    			pCB->rxFIFO.head %= UART_PROTOCOL1_RX_FIFO_SIZE;
000046  8820              LDRH     r0,[r4,#0]
000048  fbb0f1f6          UDIV     r1,r0,r6
00004c  fb060011          MLS      r0,r6,r1,r0
000050  8020              STRH     r0,[r4,#0]
;;;448    			pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
000052  8820              LDRH     r0,[r4,#0]
000054  80a0              STRH     r0,[r4,#4]
                  |L16.86|
;;;449    
;;;450    			return;
;;;451    		}
;;;452    
;;;453    		// 一直取到末尾
;;;454    		while(end != pCB->rxFIFO.currentProcessIndex)
;;;455    		{
;;;456    			// 取出当前要处理的字节
;;;457    			currentData = pCB->rxFIFO.buff[pCB->rxFIFO.currentProcessIndex];
;;;458    			// 缓冲区未溢出，正常接收，将数据添加到临时缓冲区中
;;;459    			pCmdFrame->buff[pCmdFrame->length++] = currentData;
;;;460    			pCB->rxFIFO.currentProcessIndex ++;
;;;461    			pCB->rxFIFO.currentProcessIndex %= UART_PROTOCOL1_RX_FIFO_SIZE;
;;;462    
;;;463    			// ■■接下来，需要检查命令帧是否完整，如果完整，则将命令帧临时缓冲区扶正 ■■
;;;464    						
;;;465    			// 首先判断命令帧最小长度，一个完整的命令字至少包括4个字节: 命令帧最小长度，包含:设备地址、数据长度、命令字、校验和，因此不足4个字节的必定不完整
;;;466    			if(pCmdFrame->length < UART_PROTOCOL1_CMD_FRAME_LENGTH_MIN)
;;;467    			{
;;;468    				// 继续接收
;;;469    				continue;
;;;470    			}
;;;471    
;;;472    			// 命令帧长度数值越界，说明当前命令帧错误，停止接收
;;;473    			if(pCmdFrame->buff[UART_PROTOCOL1_CMD_LENGTH_INDEX] > UART_PROTOCOL1_RX_CMD_FRAME_LENGTH_MAX)
;;;474    			{
;;;475    #if UART_PROTOCOL1_RX_TIME_OUT_CHECK_ENABLE
;;;476    				// 停止RX通讯超时检测
;;;477    				UART_PROTOCOL1_StopRxTimeOutCheck();
;;;478    #endif
;;;479    			
;;;480    				// 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;481    				pCmdFrame->length = 0;
;;;482    				// 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;483    				pCB->rxFIFO.head ++;
;;;484    				pCB->rxFIFO.head %= UART_PROTOCOL1_RX_FIFO_SIZE;
;;;485    				pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;486    
;;;487    				return;
;;;488    			}
;;;489    
;;;490    			// 命令帧长度校验
;;;491    			length = pCmdFrame->length;
;;;492    			if(length < pCmdFrame->buff[UART_PROTOCOL1_CMD_LENGTH_INDEX])
;;;493    			{
;;;494    				// 长度要求不一致，说明未接收完毕，退出继续
;;;495    				continue;
;;;496    			}
;;;497    
;;;498    			// 命令帧长度OK，则进行校验，失败时删除命令头
;;;499    			if(!UART_PROTOCOL1_CheckSUM(pCmdFrame))
;;;500    			{
;;;501    #if UART_PROTOCOL1_RX_TIME_OUT_CHECK_ENABLE
;;;502    				// 停止RX通讯超时检测
;;;503    				UART_PROTOCOL1_StopRxTimeOutCheck();
;;;504    #endif
;;;505    				
;;;506    				// 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;507    				pCmdFrame->length = 0;
;;;508    				// 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;509    				pCB->rxFIFO.head ++;
;;;510    				pCB->rxFIFO.head %= UART_PROTOCOL1_RX_FIFO_SIZE;
;;;511    				pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;512    				
;;;513    				return;
;;;514    			}
;;;515    
;;;516    #if UART_PROTOCOL1_RX_TIME_OUT_CHECK_ENABLE
;;;517    			// 停止RX通讯超时检测
;;;518    			UART_PROTOCOL1_StopRxTimeOutCheck();
;;;519    #endif
;;;520    			
;;;521    			// 执行到这里，即说明接收到了一个完整并且正确的命令帧，此时需将处理过的数据从一级缓冲区中删除，并将该命令帧扶正
;;;522    			pCB->rxFIFO.head += length;
;;;523    			pCB->rxFIFO.head %= UART_PROTOCOL1_RX_FIFO_SIZE;
;;;524    			pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;525    			UART_PROTOCOL1_ConfirmTempCmdFrameBuff(pCB);
;;;526    
;;;527    			return;
;;;528    		}
;;;529    	}
;;;530    }
000056  e8bd81f0          POP      {r4-r8,pc}
                  |L16.90|
00005a  2802              CMP      r0,#2                 ;402
00005c  d00c              BEQ      |L16.120|
00005e  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;404
000062  1c40              ADDS     r0,r0,#1              ;404
000064  8020              STRH     r0,[r4,#0]            ;404
000066  8820              LDRH     r0,[r4,#0]            ;405
000068  fbb0f1f6          UDIV     r1,r0,r6              ;405
00006c  fb060011          MLS      r0,r6,r1,r0           ;405
000070  8020              STRH     r0,[r4,#0]            ;405
000072  8820              LDRH     r0,[r4,#0]            ;406
000074  80a0              STRH     r0,[r4,#4]            ;406
000076  e7ee              B        |L16.86|
                  |L16.120|
000078  1c52              ADDS     r2,r2,#1              ;412
00007a  2103              MOVS     r1,#3                 ;412
00007c  fbb2f3f1          UDIV     r3,r2,r1              ;412
000080  fb012113          MLS      r1,r1,r3,r2           ;412
000084  f8b4229c          LDRH     r2,[r4,#0x29c]        ;412
000088  4291              CMP      r1,r2                 ;412
00008a  d0e4              BEQ      |L16.86|
00008c  2101              MOVS     r1,#1                 ;428
00008e  f8a51098          STRH     r1,[r5,#0x98]         ;428
000092  70a8              STRB     r0,[r5,#2]            ;428
000094  f8340fcc          LDRH     r0,[r4,#0xcc]!        ;429
000098  1c40              ADDS     r0,r0,#1              ;429
00009a  b280              UXTH     r0,r0                 ;429
00009c  fbb0f1f6          UDIV     r1,r0,r6              ;430
0000a0  fb060011          MLS      r0,r6,r1,r0           ;430
0000a4  8020              STRH     r0,[r4,#0]            ;430
0000a6  e7d6              B        |L16.86|
                  |L16.168|
0000a8  5c22              LDRB     r2,[r4,r0]            ;457
0000aa  f8b50098          LDRH     r0,[r5,#0x98]         ;459
0000ae  1c43              ADDS     r3,r0,#1              ;459
0000b0  4428              ADD      r0,r0,r5              ;459
0000b2  f8a53098          STRH     r3,[r5,#0x98]         ;459
0000b6  7082              STRB     r2,[r0,#2]            ;459
0000b8  f8b400cc          LDRH     r0,[r4,#0xcc]         ;460
0000bc  1c40              ADDS     r0,r0,#1              ;460
0000be  b280              UXTH     r0,r0                 ;460
0000c0  fbb0f2f6          UDIV     r2,r0,r6              ;461
0000c4  fb060012          MLS      r0,r6,r2,r0           ;461
0000c8  f8a400cc          STRH     r0,[r4,#0xcc]         ;461
0000cc  f8b57098          LDRH     r7,[r5,#0x98]         ;466
0000d0  2f04              CMP      r7,#4                 ;466
0000d2  d33a              BCC      |L16.330|
0000d4  78e8              LDRB     r0,[r5,#3]            ;473
0000d6  2896              CMP      r0,#0x96              ;473
0000d8  d90e              BLS      |L16.248|
0000da  f8a58098          STRH     r8,[r5,#0x98]         ;481
0000de  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;483
0000e2  1c40              ADDS     r0,r0,#1              ;483
0000e4  8020              STRH     r0,[r4,#0]            ;483
0000e6  8820              LDRH     r0,[r4,#0]            ;484
0000e8  fbb0f1f6          UDIV     r1,r0,r6              ;484
0000ec  fb060011          MLS      r0,r6,r1,r0           ;484
0000f0  8020              STRH     r0,[r4,#0]            ;484
0000f2  8820              LDRH     r0,[r4,#0]            ;485
0000f4  80a0              STRH     r0,[r4,#4]            ;485
0000f6  e7ae              B        |L16.86|
                  |L16.248|
0000f8  42b8              CMP      r0,r7                 ;492
0000fa  d826              BHI      |L16.330|
0000fc  4628              MOV      r0,r5                 ;499
0000fe  f7fffffe          BL       UART_PROTOCOL1_CheckSUM
000102  b188              CBZ      r0,|L16.296|
000104  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;522
000108  4438              ADD      r0,r0,r7              ;522
00010a  8020              STRH     r0,[r4,#0]            ;522
00010c  8820              LDRH     r0,[r4,#0]            ;523
00010e  fbb0f1f6          UDIV     r1,r0,r6              ;523
000112  fb060011          MLS      r0,r6,r1,r0           ;523
000116  8020              STRH     r0,[r4,#0]            ;523
000118  8820              LDRH     r0,[r4,#0]            ;524
00011a  80a0              STRH     r0,[r4,#4]            ;524
00011c  3cc8              SUBS     r4,r4,#0xc8           ;524
00011e  4620              MOV      r0,r4                 ;525
000120  e8bd41f0          POP      {r4-r8,lr}            ;525
000124  f7ffbffe          B.W      UART_PROTOCOL1_ConfirmTempCmdFrameBuff
                  |L16.296|
000128  f8a58098          STRH     r8,[r5,#0x98]         ;507
00012c  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;509
000130  1c40              ADDS     r0,r0,#1              ;509
000132  8020              STRH     r0,[r4,#0]            ;509
000134  8820              LDRH     r0,[r4,#0]            ;510
000136  e000              B        |L16.314|
                  |L16.312|
000138  e007              B        |L16.330|
                  |L16.314|
00013a  fbb0f1f6          UDIV     r1,r0,r6              ;510
00013e  fb060011          MLS      r0,r6,r1,r0           ;510
000142  8020              STRH     r0,[r4,#0]            ;510
000144  8820              LDRH     r0,[r4,#0]            ;511
000146  80a0              STRH     r0,[r4,#4]            ;511
000148  e785              B        |L16.86|
                  |L16.330|
00014a  f8b400cc          LDRH     r0,[r4,#0xcc]         ;454
00014e  4288              CMP      r0,r1                 ;454
000150  d1aa              BNE      |L16.168|
000152  e780              B        |L16.86|
;;;531    
                          ENDP


                          AREA ||i.UART_PROTOCOL1_SendCmdAging||, CODE, READONLY, ALIGN=1

                  UART_PROTOCOL1_SendCmdAging PROC
;;;1691   // 发送老化累加次数
;;;1692   void UART_PROTOCOL1_SendCmdAging(uint32 param)
000000  b500              PUSH     {lr}
;;;1693   {
;;;1694   	// 添加设备地址
;;;1695   	UART_PROTOCOL1_TxAddData(UART_PROTOCOL1_CMD_RX_DEVICE_ADDR);
000002  2002              MOVS     r0,#2
000004  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1696   
;;;1697   	// 添加数据长度，固定为20
;;;1698   	UART_PROTOCOL1_TxAddData(20);
000008  2014              MOVS     r0,#0x14
00000a  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1699   
;;;1700   	// 添加命令字
;;;1701   	UART_PROTOCOL1_TxAddData(UART_PROTOCOL1_CMD_HMI_CTRL_RUN);
00000e  2001              MOVS     r0,#1
000010  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1702   
;;;1703   	// 填充假的数据即可
;;;1704   	UART_PROTOCOL1_TxAddData(1);
000014  2001              MOVS     r0,#1
000016  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1705   	UART_PROTOCOL1_TxAddData(2);
00001a  2002              MOVS     r0,#2
00001c  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1706   	UART_PROTOCOL1_TxAddData(3);
000020  2003              MOVS     r0,#3
000022  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1707   	UART_PROTOCOL1_TxAddData(4);
000026  2004              MOVS     r0,#4
000028  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1708   	UART_PROTOCOL1_TxAddData(5);
00002c  2005              MOVS     r0,#5
00002e  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1709   	UART_PROTOCOL1_TxAddData(6);
000032  2006              MOVS     r0,#6
000034  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1710   	UART_PROTOCOL1_TxAddData(7);
000038  2007              MOVS     r0,#7
00003a  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1711   	UART_PROTOCOL1_TxAddData(8);
00003e  2008              MOVS     r0,#8
000040  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1712   	UART_PROTOCOL1_TxAddData(9);
000044  2009              MOVS     r0,#9
000046  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1713   	UART_PROTOCOL1_TxAddData(10);
00004a  200a              MOVS     r0,#0xa
00004c  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1714   
;;;1715   	// 添加检验和，并添加至发送
;;;1716   	UART_PROTOCOL1_TxAddFrame();
000050  f85deb04          POP      {lr}
000054  f7ffbffe          B.W      UART_PROTOCOL1_TxAddFrame
;;;1717   }
;;;1718   
                          ENDP


                          AREA ||i.UART_PROTOCOL1_SendRuntimeParam||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL1_SendRuntimeParam PROC
;;;1104   // 发送运行参数命令到驱动器
;;;1105   void UART_PROTOCOL1_SendRuntimeParam(void)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;1106   {
;;;1107   	static uint8 assistCode;
;;;1108   	uint16 wheelSize;
;;;1109   	uint16 pwm;
;;;1110   	uint16 lowVoltageThreshold;
;;;1111   
;;;1112   	// 添加设备地址
;;;1113   	UART_PROTOCOL1_TxAddData(UART_PROTOCOL1_CMD_TX_DEVICE_ADDR);
000004  2001              MOVS     r0,#1
000006  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1114   
;;;1115   	// 添加数据长度，固定为20
;;;1116   	UART_PROTOCOL1_TxAddData(20);
00000a  2014              MOVS     r0,#0x14
00000c  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1117   
;;;1118   	// 添加命令字
;;;1119   	UART_PROTOCOL1_TxAddData(UART_PROTOCOL1_CMD_HMI_CTRL_RUN);
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1120   
;;;1121   	// 驱动方式设定
;;;1122   	// 0 : 助力驱动(通过助力档位决定输出多少助力，此时转把无效)。
;;;1123   	// 1 : 电驱动(通过转把驱动, 此时助力档位无效)。
;;;1124   	// 2 : 助力驱动和电驱动同时共存(电驱动零启动状态下无效)。
;;;1125   	UART_PROTOCOL1_TxAddData(PARAM_GetDriverControlMode());
000016  4d83              LDR      r5,|L18.548|
000018  f89502fc          LDRB     r0,[r5,#0x2fc]  ; paramCB
00001c  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1126   
;;;1127   	// 助力档位
;;;1128   	switch (PARAM_GetMaxAssist())
000020  f8950312          LDRB     r0,[r5,#0x312]  ; paramCB
;;;1129   	{
;;;1130   		case ASSIST_3:
;;;1131   			switch (PARAM_GetAssistLevel())
;;;1132   			{
;;;1133   				case ASSIST_0:
;;;1134   					assistCode = 0;
;;;1135   					break;
;;;1136   
;;;1137   				case ASSIST_1:
;;;1138   					assistCode = 5;
;;;1139   					break;
;;;1140   
;;;1141   				case ASSIST_2:
;;;1142   					assistCode = 10;
;;;1143   					break;
;;;1144   
;;;1145   				case ASSIST_3:
;;;1146   					assistCode = 15;
000024  270f              MOVS     r7,#0xf
000026  2600              MOVS     r6,#0                 ;1142
000028  4c7f              LDR      r4,|L18.552|
00002a  f04f0905          MOV      r9,#5                 ;1128
00002e  f04f080a          MOV      r8,#0xa               ;1142
000032  2803              CMP      r0,#3                 ;1128
000034  d008              BEQ      |L18.72|
000036  f04f0a03          MOV      r10,#3                ;1128
00003a  f04f0b09          MOV      r11,#9                ;1128
00003e  2805              CMP      r0,#5                 ;1128
000040  d01d              BEQ      |L18.126|
000042  2809              CMP      r0,#9                 ;1128
000044  d164              BNE      |L18.272|
000046  e039              B        |L18.188|
                  |L18.72|
000048  f7fffffe          BL       PARAM_GetAssistLevel
00004c  2802              CMP      r0,#2                 ;1131
00004e  d00e              BEQ      |L18.110|
000050  dc03              BGT      |L18.90|
000052  b138              CBZ      r0,|L18.100|
000054  2801              CMP      r0,#1                 ;1131
000056  d15b              BNE      |L18.272|
000058  e006              B        |L18.104|
                  |L18.90|
00005a  2803              CMP      r0,#3                 ;1131
00005c  d00a              BEQ      |L18.116|
00005e  280a              CMP      r0,#0xa               ;1131
000060  d156              BNE      |L18.272|
000062  e009              B        |L18.120|
                  |L18.100|
000064  7026              STRB     r6,[r4,#0]            ;1134
000066  e053              B        |L18.272|
                  |L18.104|
000068  f8849000          STRB     r9,[r4,#0]            ;1138
00006c  e050              B        |L18.272|
                  |L18.110|
00006e  f8848000          STRB     r8,[r4,#0]            ;1142
000072  e04d              B        |L18.272|
                  |L18.116|
000074  7027              STRB     r7,[r4,#0]
;;;1147   					break;
000076  e04b              B        |L18.272|
                  |L18.120|
;;;1148   
;;;1149   				// 推车
;;;1150   				case ASSIST_P:
;;;1151   					assistCode = assistCode;
000078  7820              LDRB     r0,[r4,#0]  ; assistCode
00007a  7020              STRB     r0,[r4,#0]
;;;1152   					break;
00007c  e048              B        |L18.272|
                  |L18.126|
;;;1153   			}
;;;1154   			break;
;;;1155   
;;;1156   		case ASSIST_5:
;;;1157   			switch (PARAM_GetAssistLevel())
00007e  f7fffffe          BL       PARAM_GetAssistLevel
000082  280b              CMP      r0,#0xb
000084  d244              BCS      |L18.272|
000086  e8dff000          TBB      [pc,r0]
00008a  0608              DCB      0x06,0x08
00008c  0b0e1114          DCB      0x0b,0x0e,0x11,0x14
000090  43434343          DCB      0x43,0x43,0x43,0x43
000094  1600              DCB      0x16,0x00
;;;1158   			{
;;;1159   				case ASSIST_0:
;;;1160   					assistCode = 0;
000096  7026              STRB     r6,[r4,#0]
;;;1161   					break;
000098  e03a              B        |L18.272|
;;;1162   
;;;1163   				case ASSIST_1:
;;;1164   					assistCode = 3;
00009a  f884a000          STRB     r10,[r4,#0]
;;;1165   					break;
00009e  e037              B        |L18.272|
;;;1166   
;;;1167   				case ASSIST_2:
;;;1168   					assistCode = 6;
0000a0  2006              MOVS     r0,#6
0000a2  7020              STRB     r0,[r4,#0]
;;;1169   					break;
0000a4  e034              B        |L18.272|
;;;1170   
;;;1171   				case ASSIST_3:
;;;1172   					assistCode = 9;
0000a6  f884b000          STRB     r11,[r4,#0]
;;;1173   					break;
0000aa  e031              B        |L18.272|
;;;1174   
;;;1175   				case ASSIST_4:
;;;1176   					assistCode = 12;
0000ac  200c              MOVS     r0,#0xc
0000ae  7020              STRB     r0,[r4,#0]
;;;1177   					break;
0000b0  e02e              B        |L18.272|
;;;1178   
;;;1179   				case ASSIST_5:
;;;1180   					assistCode = 15;
0000b2  7027              STRB     r7,[r4,#0]
;;;1181   					break;
0000b4  e02c              B        |L18.272|
;;;1182   
;;;1183   				// 推车
;;;1184   				case ASSIST_P:
;;;1185   					assistCode = assistCode;
0000b6  7820              LDRB     r0,[r4,#0]  ; assistCode
0000b8  7020              STRB     r0,[r4,#0]
;;;1186   					break;
0000ba  e029              B        |L18.272|
                  |L18.188|
;;;1187   
;;;1188   			}
;;;1189   			break;
;;;1190   
;;;1191   		case ASSIST_9:
;;;1192   			switch (PARAM_GetAssistLevel())
0000bc  f7fffffe          BL       PARAM_GetAssistLevel
0000c0  280b              CMP      r0,#0xb
0000c2  d225              BCS      |L18.272|
0000c4  e8dff000          TBB      [pc,r0]
0000c8  06080b0e          DCB      0x06,0x08,0x0b,0x0e
0000cc  1114171a          DCB      0x11,0x14,0x17,0x1a
0000d0  1d202200          DCB      0x1d,0x20,0x22,0x00
;;;1193   			{
;;;1194   				case ASSIST_0:
;;;1195   					assistCode = 0;
0000d4  7026              STRB     r6,[r4,#0]
;;;1196   					break;
0000d6  e01b              B        |L18.272|
;;;1197   
;;;1198   				case ASSIST_1:
;;;1199   					assistCode = 1;
0000d8  2001              MOVS     r0,#1
0000da  7020              STRB     r0,[r4,#0]
;;;1200   					break;
0000dc  e018              B        |L18.272|
;;;1201   
;;;1202   				case ASSIST_2:
;;;1203   					assistCode = 3;
0000de  f884a000          STRB     r10,[r4,#0]
;;;1204   					break;
0000e2  e015              B        |L18.272|
;;;1205   
;;;1206   				case ASSIST_3:
;;;1207   					assistCode = 5;
0000e4  f8849000          STRB     r9,[r4,#0]
;;;1208   					break;
0000e8  e012              B        |L18.272|
;;;1209   
;;;1210   				case ASSIST_4:
;;;1211   					assistCode = 7;
0000ea  2007              MOVS     r0,#7
0000ec  7020              STRB     r0,[r4,#0]
;;;1212   					break;
0000ee  e00f              B        |L18.272|
;;;1213   
;;;1214   				case ASSIST_5:
;;;1215   					assistCode = 9;
0000f0  f884b000          STRB     r11,[r4,#0]
;;;1216   					break;
0000f4  e00c              B        |L18.272|
;;;1217   
;;;1218   				case ASSIST_6:
;;;1219   					assistCode = 11;
0000f6  200b              MOVS     r0,#0xb
0000f8  7020              STRB     r0,[r4,#0]
;;;1220   					break;
0000fa  e009              B        |L18.272|
;;;1221   
;;;1222   				case ASSIST_7:
;;;1223   					assistCode = 13;
0000fc  200d              MOVS     r0,#0xd
0000fe  7020              STRB     r0,[r4,#0]
;;;1224   					break;
000100  e006              B        |L18.272|
;;;1225   
;;;1226   				case ASSIST_8:
;;;1227   					assistCode = 14;
000102  200e              MOVS     r0,#0xe
000104  7020              STRB     r0,[r4,#0]
;;;1228   					break;
000106  e003              B        |L18.272|
;;;1229   
;;;1230   				case ASSIST_9:
;;;1231   					assistCode = 15;
000108  7027              STRB     r7,[r4,#0]
;;;1232   					break;
00010a  e001              B        |L18.272|
;;;1233   
;;;1234   				// 推车
;;;1235   				case ASSIST_P:
;;;1236   					assistCode = assistCode;
00010c  7820              LDRB     r0,[r4,#0]  ; assistCode
00010e  7020              STRB     r0,[r4,#0]
                  |L18.272|
;;;1237   					break;
;;;1238   			}
;;;1239   			break;
;;;1240   	}
;;;1241   	UART_PROTOCOL1_TxAddData(assistCode);
000110  7820              LDRB     r0,[r4,#0]  ; assistCode
000112  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1242   
;;;1243   	// 控制器控制设定1
;;;1244   	// bit7：0: 控制器不工作，1: 控制器工作
;;;1245   	// bit6：0: 零启动 1: 非零启动
;;;1246   	// bit5：灯光控制 0: 关闭 1: 开
;;;1247   	// bit4：0: 通讯正常 1: 通讯故障(不能接收到控制器的数据)
;;;1248   	// bit3：切换巡航的方式
;;;1249   	//		 0: 使用触发方式，是否巡航见BIT0 (仪表默认状态)
;;;1250   	//		 1: 使用长按键方式 见BIT1
;;;1251   	//		 多数情况下，控制器出厂时，巡航方式已确定，可以不考虑本Bit3，直接根据需要读取Bit1，或者Bit0 即可
;;;1252   	// bit2：限速状态 1：超过限速值；0：未超过限速值（不限速一直为0)；
;;;1253   	// bit1：巡航保持模式 (0: 非巡航，1: 巡航中)
;;;1254   	//		(如果要”6KM/助推“ 这种按住保持，松手推出的巡航，控制器可以直接读此位置）
;;;1255   	// bit0：巡航切换模式 (0: 不需要切换巡航状态 1: 要切换巡航状态)
;;;1256   	//		（如果需要按住后反转状态的巡航，比如定速巡航，可以直接读此位置）
;;;1257   	hmiDriveCB1.DriverSet1.param.driverState = 1;
000116  4c45              LDR      r4,|L18.556|
000118  7820              LDRB     r0,[r4,#0]  ; hmiDriveCB1
00011a  f0400080          ORR      r0,r0,#0x80
;;;1258   	hmiDriveCB1.DriverSet1.param.zeroStartOrNot = PARAM_GetZeroStartOrNot();
00011e  f89512fd          LDRB     r1,[r5,#0x2fd]  ; paramCB
000122  f3611086          BFI      r0,r1,#6,#1
;;;1259   	hmiDriveCB1.DriverSet1.param.isLightOn = PARAM_GetLightSwitch();
000126  f89511fa          LDRB     r1,[r5,#0x1fa]  ; paramCB
00012a  f3611045          BFI      r0,r1,#5,#1
;;;1260   	hmiDriveCB1.DriverSet1.param.comunicationError = 0;
00012e  f0200010          BIC      r0,r0,#0x10
;;;1261   	hmiDriveCB1.DriverSet1.param.switchCruiseWay = PARAM_GetSwitchCruiseWay();
000132  f89512fe          LDRB     r1,[r5,#0x2fe]  ; paramCB
000136  f36100c3          BFI      r0,r1,#3,#1
00013a  7020              STRB     r0,[r4,#0]
;;;1262   
;;;1263   	// 限速使能
;;;1264   	if (PARAM_GetSpeedLimitSwitch())
00013c  f895230d          LDRB     r2,[r5,#0x30d]  ; paramCB
000140  b16a              CBZ      r2,|L18.350|
;;;1265   	{
;;;1266   		// 超过限速值
;;;1267   		if (paramCB.runtime.speed > paramCB.nvm.param.common.speed.limitVal)
000142  f8b52210          LDRH     r2,[r5,#0x210]  ; paramCB
000146  f8b5332c          LDRH     r3,[r5,#0x32c]  ; paramCB
00014a  429a              CMP      r2,r3
00014c  d903              BLS      |L18.342|
;;;1268   		{
;;;1269   			hmiDriveCB1.DriverSet1.param.speedLimitState = 1;
00014e  f0400004          ORR      r0,r0,#4
000152  7020              STRB     r0,[r4,#0]
000154  e006              B        |L18.356|
                  |L18.342|
;;;1270   		}
;;;1271   		// 未超过限速值
;;;1272   		else
;;;1273   		{
;;;1274   			hmiDriveCB1.DriverSet1.param.speedLimitState = 0;
000156  f0200004          BIC      r0,r0,#4
00015a  7020              STRB     r0,[r4,#0]
00015c  e002              B        |L18.356|
                  |L18.350|
;;;1275   		}
;;;1276   	}
;;;1277   	// 不限速一直为0
;;;1278   	else
;;;1279   	{
;;;1280   		hmiDriveCB1.DriverSet1.param.speedLimitState = 0;
00015e  f0200004          BIC      r0,r0,#4
000162  7020              STRB     r0,[r4,#0]
                  |L18.356|
;;;1281   	}
;;;1282   
;;;1283   	// 定时巡航和6KM助推
;;;1284   	/*if (PARAM_GetSwitchCruiseWay())	// 长按键方式
;;;1285   	{
;;;1286   		//hmiDriveCB1.DriverSet1.param.isPushModeOn = PARAM_IsPushAssistOn();
;;;1287   		
;;;1288   		hmiDriveCB1.DriverSet1.param.switchCruiseMode = 1;	// 长按键方式,不关心此位
;;;1289   	}
;;;1290   	else							// 触发方式
;;;1291   	{
;;;1292   		hmiDriveCB1.DriverSet1.param.isPushModeOn = 0;		// 触发方式,不关心此位
;;;1293   
;;;1294   		hmiDriveCB1.DriverSet1.param.switchCruiseMode = PARAM_GetCruiseSwitch();
;;;1295   
;;;1296   	}*/
;;;1297   
;;;1298   	// 定时巡航和6KM助推
;;;1299   	if (PARAM_GetSwitchCruiseWay())	// 长按键方式
000164  b121              CBZ      r1,|L18.368|
;;;1300   	{		
;;;1301   		hmiDriveCB1.DriverSet1.param.switchCruiseMode = 0;
000166  7820              LDRB     r0,[r4,#0]  ; hmiDriveCB1
000168  f0200001          BIC      r0,r0,#1
00016c  7020              STRB     r0,[r4,#0]
00016e  e00d              B        |L18.396|
                  |L18.368|
;;;1302   	}
;;;1303   	else							// 触发方式
;;;1304   	{
;;;1305   		if (PARAM_GetCruiseSwitch())
000170  f89501f5          LDRB     r0,[r5,#0x1f5]  ; paramCB
000174  b130              CBZ      r0,|L18.388|
;;;1306   		{
;;;1307   			hmiDriveCB1.DriverSet1.param.switchCruiseMode = 1;
000176  7820              LDRB     r0,[r4,#0]  ; hmiDriveCB1
000178  f0400001          ORR      r0,r0,#1
00017c  7020              STRB     r0,[r4,#0]
;;;1308   
;;;1309   			// 巡航开关使用后立刻关闭
;;;1310   			PARAM_SetCruiseSwitch(FALSE);
00017e  f88561f5          STRB     r6,[r5,#0x1f5]
000182  e003              B        |L18.396|
                  |L18.388|
;;;1311   		}
;;;1312   		else
;;;1313   		{
;;;1314   			hmiDriveCB1.DriverSet1.param.switchCruiseMode = 0;
000184  7820              LDRB     r0,[r4,#0]  ; hmiDriveCB1
000186  f0200001          BIC      r0,r0,#1
00018a  7020              STRB     r0,[r4,#0]
                  |L18.396|
;;;1315   		}
;;;1316   	}
;;;1317   	
;;;1318   	// 推车助力状态
;;;1319   	hmiDriveCB1.DriverSet1.param.isPushModeOn = PARAM_IsPushAssistOn();
00018c  f20525ee          ADD      r5,r5,#0x2ee
000190  7820              LDRB     r0,[r4,#0]  ; hmiDriveCB1
000192  f8151cf7          LDRB     r1,[r5,#-0xf7]  ; paramCB
000196  f3610041          BFI      r0,r1,#1,#1
00019a  7020              STRB     r0,[r4,#0]
;;;1320   	
;;;1321   	UART_PROTOCOL1_TxAddData(hmiDriveCB1.DriverSet1.val);
00019c  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1322   
;;;1323   	// 测速磁钢
;;;1324   	UART_PROTOCOL1_TxAddData(PARAM_GetCycleOfSteelNum());
0001a0  78e8              LDRB     r0,[r5,#3]  ; paramCB
0001a2  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1325   
;;;1326   	// 轮径
;;;1327   	wheelSize = PARAM_GetNewWheelSizeInch();
0001a6  f8356c40          LDRH     r6,[r5,#-0x40]  ; paramCB
;;;1328   	UART_PROTOCOL1_TxAddData(wheelSize>>8);
0001aa  0a30              LSRS     r0,r6,#8
0001ac  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1329   	UART_PROTOCOL1_TxAddData(wheelSize&0xFF);
0001b0  b2f0              UXTB     r0,r6
0001b2  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1330   
;;;1331   	// 助力灵敏度
;;;1332   	UART_PROTOCOL1_TxAddData(PARAM_GetAssistSensitivity());
0001b6  7ca8              LDRB     r0,[r5,#0x12]  ; paramCB
0001b8  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1333   
;;;1334   	// 助力启动强度
;;;1335   	UART_PROTOCOL1_TxAddData(PARAM_GetAssistStartIntensity());
0001bc  7ce8              LDRB     r0,[r5,#0x13]  ; paramCB
0001be  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1336   
;;;1337   	// 限速专用电机换向霍尔磁钢片数
;;;1338   	UART_PROTOCOL1_TxAddData(PARAM_GetReversalHolzerSteelNum());
0001c2  7d68              LDRB     r0,[r5,#0x15]  ; paramCB
0001c4  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1339   
;;;1340   	// 限速值，此处一定要用公制km/h
;;;1341   	UART_PROTOCOL1_TxAddData(paramCB.nvm.param.common.speed.limitVal/10);
0001c8  8fe8              LDRH     r0,[r5,#0x3e]  ; paramCB
0001ca  fbb0f0f8          UDIV     r0,r0,r8
0001ce  b2c0              UXTB     r0,r0
0001d0  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1342   
;;;1343   	// 控制器限流值
;;;1344   	UART_PROTOCOL1_TxAddData(PARAM_GetCurrentLimit()/1000);		// 客户的单位为1A
0001d4  8968              LDRH     r0,[r5,#0xa]  ; paramCB
0001d6  f44f717a          MOV      r1,#0x3e8
0001da  fbb0f0f1          UDIV     r0,r0,r1
0001de  b2c0              UXTB     r0,r0
0001e0  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1345   
;;;1346   	// 控制器欠压值
;;;1347   	lowVoltageThreshold = PARAM_GetLowVoltageThreshold()/100;
0001e4  89a8              LDRH     r0,[r5,#0xc]  ; paramCB
0001e6  2164              MOVS     r1,#0x64
0001e8  fbb0f6f1          UDIV     r6,r0,r1
;;;1348   	UART_PROTOCOL1_TxAddData(lowVoltageThreshold>>8);			// 客户的单位为0.1V
0001ec  0a30              LSRS     r0,r6,#8
0001ee  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1349   	UART_PROTOCOL1_TxAddData(lowVoltageThreshold&0xFF);
0001f2  b2f0              UXTB     r0,r6
0001f4  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1350   
;;;1351   	// 转把调速PWM占空比
;;;1352   	//pwm = PARAM_GetPwmTopLimit(PARAM_GetAssistLevel())*10;			// 客户的单位为0.1%
;;;1353   	
;;;1354   	pwm = 0;
;;;1355   	UART_PROTOCOL1_TxAddData(pwm>>8);
0001f8  2000              MOVS     r0,#0
0001fa  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1356   	UART_PROTOCOL1_TxAddData(pwm&0xFF);
0001fe  2000              MOVS     r0,#0
000200  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1357   
;;;1358   	// 控制器控制设定2 + 助力磁钢盘磁钢个数
;;;1359   	// bit7：倒车标志 0: 无效，1: 倒车
;;;1360   	// bit6：自动巡航标志 0: 无自动巡航， 1: 有自动巡航（时间控制器确定）
;;;1361   	// bit5：备用0
;;;1362   	// bit4：备用0
;;;1363   	// bit3 2 1 0：助力磁钢盘磁钢个数
;;;1364   	// 			   5 : 5 颗磁钢
;;;1365   	// 			   8 : 8 颗磁钢
;;;1366   	// 			   12: 12 颗磁钢
;;;1367   	hmiDriveCB1.DriverSet2.param.astern = 0;
000204  7860              LDRB     r0,[r4,#1]  ; hmiDriveCB1
000206  f0200080          BIC      r0,r0,#0x80
;;;1368   	hmiDriveCB1.DriverSet2.param.autoCruise = 0;
00020a  f0200040          BIC      r0,r0,#0x40
;;;1369   	hmiDriveCB1.DriverSet2.param.assistSteelType = PARAM_GetSteelType();
00020e  7d29              LDRB     r1,[r5,#0x14]  ; paramCB
000210  f3610003          BFI      r0,r1,#0,#4
000214  7060              STRB     r0,[r4,#1]
;;;1370   	UART_PROTOCOL1_TxAddData(hmiDriveCB1.DriverSet2.val);
000216  f7fffffe          BL       UART_PROTOCOL1_TxAddData
;;;1371   
;;;1372   	// 添加检验和，并添加至发送
;;;1373   	UART_PROTOCOL1_TxAddFrame();
00021a  e8bd5ff0          POP      {r4-r12,lr}
00021e  f7ffbffe          B.W      UART_PROTOCOL1_TxAddFrame
;;;1374   }
;;;1375   
                          ENDP

000222  0000              DCW      0x0000
                  |L18.548|
                          DCD      paramCB
                  |L18.552|
                          DCD      ||.data||
                  |L18.556|
                          DCD      ||.bss||+0x484

                          AREA ||i.UART_PROTOCOL1_SetTxAtOnceRequest||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL1_SetTxAtOnceRequest PROC
;;;1066   // 码表设置立刻下发数据请求标志
;;;1067   void UART_PROTOCOL1_SetTxAtOnceRequest(uint32 param)
000000  4901              LDR      r1,|L19.8|
;;;1068   {
;;;1069   	uartProtocolCB1.txAtOnceRequest = (BOOL)param;
000002  f881047d          STRB     r0,[r1,#0x47d]
;;;1070   }
000006  4770              BX       lr
;;;1071   
                          ENDP

                  |L19.8|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOL1_StartTimeoutCheckTask||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL1_StartTimeoutCheckTask PROC
;;;82     // 启动通讯超时判断任务
;;;83     void UART_PROTOCOL1_StartTimeoutCheckTask(void)
000000  4804              LDR      r0,|L20.20|
;;;84     {
;;;85     	// 清除通讯异常
;;;86     	if(ERROR_TYPE_COMMUNICATION_TIME_OUT == PARAM_GetErrorCode())
000002  f8901219          LDRB     r1,[r0,#0x219]  ; paramCB
000006  2930              CMP      r1,#0x30
000008  d102              BNE      |L20.16|
;;;87     	{
;;;88     		PARAM_SetErrorCode(ERROR_TYPE_NO_ERROR);
00000a  2100              MOVS     r1,#0
00000c  f8801219          STRB     r1,[r0,#0x219]
                  |L20.16|
;;;89     	}
;;;90     
;;;91     	// 开启UART通讯超时定时器
;;;92     #if __SYSTEM_NO_TIME_OUT_ERROR__	// 研发调试时不启用
;;;93     #else
;;;94     
;;;95     #endif
;;;96     }
000010  4770              BX       lr
;;;97     
                          ENDP

000012  0000              DCW      0x0000
                  |L20.20|
                          DCD      paramCB

                          AREA ||i.UART_PROTOCOL1_TxAddData||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL1_TxAddData PROC
;;;178    // 向发送命令帧队列中添加数据
;;;179    void UART_PROTOCOL1_TxAddData(uint8 data)
000000  b530              PUSH     {r4,r5,lr}
;;;180    {
;;;181    	uint16 head = uartProtocolCB1.tx.head;
000002  490f              LDR      r1,|L21.64|
000004  f8b1446e          LDRH     r4,[r1,#0x46e]  ; uartProtocolCB1
;;;182    	uint16 end =  uartProtocolCB1.tx.end;
000008  f8b12470          LDRH     r2,[r1,#0x470]  ; uartProtocolCB1
;;;183    	UART_PROTOCOL1_TX_CMD_FRAME* pCmdFrame = &uartProtocolCB1.tx.cmdQueue[uartProtocolCB1.tx.end];
00000c  234d              MOVS     r3,#0x4d
00000e  4353              MULS     r3,r2,r3
000010  eb010143          ADD      r1,r1,r3,LSL #1
000014  f5017128          ADD      r1,r1,#0x2a0
;;;184    
;;;185    	// 发送缓冲区已满，不予接收
;;;186    	if((end + 1) % UART_PROTOCOL1_TX_QUEUE_SIZE == head)
000018  1c52              ADDS     r2,r2,#1
00001a  2303              MOVS     r3,#3
00001c  fbb2f5f3          UDIV     r5,r2,r3
000020  fb032215          MLS      r2,r3,r5,r2
000024  42a2              CMP      r2,r4
000026  d009              BEQ      |L21.60|
;;;187    	{
;;;188    		return;
;;;189    	}
;;;190    	
;;;191    	// 队尾命令帧已满，退出
;;;192    	if(pCmdFrame->length >= UART_PROTOCOL1_TX_CMD_FRAME_LENGTH_MAX)
000028  f8b12098          LDRH     r2,[r1,#0x98]
00002c  2a96              CMP      r2,#0x96
00002e  d205              BCS      |L21.60|
;;;193    	{
;;;194    		return;
;;;195    	}
;;;196    
;;;197    	// 数据添加到帧末尾，并更新帧长度
;;;198    	pCmdFrame->buff[pCmdFrame->length] = data;
000030  1c8b              ADDS     r3,r1,#2
000032  54d0              STRB     r0,[r2,r3]
;;;199    	pCmdFrame->length ++;
000034  f8310f98          LDRH     r0,[r1,#0x98]!
000038  1c40              ADDS     r0,r0,#1
00003a  8008              STRH     r0,[r1,#0]
                  |L21.60|
;;;200    }
00003c  bd30              POP      {r4,r5,pc}
;;;201    
                          ENDP

00003e  0000              DCW      0x0000
                  |L21.64|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOL1_TxAddFrame||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL1_TxAddFrame PROC
;;;202    // 确认添加命令帧，即承认之前填充的数据为命令帧，将其添加到发送队列中，由main进行调度发送，本函数内会自动校正命令长度，并添加校验码
;;;203    void UART_PROTOCOL1_TxAddFrame(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;204    {
;;;205    	uint16 cc = 0;
000002  2300              MOVS     r3,#0
;;;206    	uint16 i = 0;
000004  2100              MOVS     r1,#0
;;;207    	uint16 head = uartProtocolCB1.tx.head;
000006  4d1c              LDR      r5,|L22.120|
000008  f8b5746e          LDRH     r7,[r5,#0x46e]  ; uartProtocolCB1
;;;208    	uint16 end  = uartProtocolCB1.tx.end;
00000c  f8b54470          LDRH     r4,[r5,#0x470]  ; uartProtocolCB1
;;;209    	UART_PROTOCOL1_TX_CMD_FRAME* pCmdFrame = &uartProtocolCB1.tx.cmdQueue[uartProtocolCB1.tx.end];
000010  204d              MOVS     r0,#0x4d
000012  4360              MULS     r0,r4,r0
000014  eb050040          ADD      r0,r5,r0,LSL #1
000018  f5007028          ADD      r0,r0,#0x2a0
;;;210    	uint16 length = pCmdFrame->length;
00001c  f8b02098          LDRH     r2,[r0,#0x98]
;;;211    
;;;212    	// 发送缓冲区已满，不予接收
;;;213    	if((end + 1) % UART_PROTOCOL1_TX_QUEUE_SIZE == head)
000020  1c64              ADDS     r4,r4,#1
000022  2603              MOVS     r6,#3
000024  fbb4fcf6          UDIV     r12,r4,r6
000028  fb06441c          MLS      r4,r6,r12,r4
00002c  42bc              CMP      r4,r7
00002e  d003              BEQ      |L22.56|
;;;214    	{
;;;215    		return;
;;;216    	}
;;;217    	
;;;218    	// 命令帧长度不足，清除已填充的数据，退出
;;;219    	if(UART_PROTOCOL1_CMD_FRAME_LENGTH_MIN-1 > length)	// 减去"校验和"1个字节
000030  2a03              CMP      r2,#3
000032  d202              BCS      |L22.58|
;;;220    	{
;;;221    		pCmdFrame->length = 0;
000034  f8a01098          STRH     r1,[r0,#0x98]
                  |L22.56|
;;;222    		
;;;223    		return;
;;;224    	}
;;;225    
;;;226    	// 队尾命令帧已满，退出
;;;227    	if(length >= UART_PROTOCOL1_TX_CMD_FRAME_LENGTH_MAX)
;;;228    	{
;;;229    		return;
;;;230    	}
;;;231    
;;;232    	// 重新设置数据长度，系统在准备数据时，填充的"数据长度"可以为任意值，并且不需要添加校验码，在这里重新设置为正确的值
;;;233    	pCmdFrame->buff[UART_PROTOCOL1_CMD_LENGTH_INDEX] = length + 1;	// 重设数据长度，要加上1字节校验长度
;;;234    
;;;235    	for(i=0; i<length; i++)
;;;236    	{
;;;237    		cc ^= pCmdFrame->buff[i];
;;;238    	}
;;;239    	pCmdFrame->buff[pCmdFrame->length++] = cc ;
;;;240    
;;;241    	uartProtocolCB1.tx.end ++;
;;;242    	uartProtocolCB1.tx.end %= UART_PROTOCOL1_TX_QUEUE_SIZE;
;;;243    	//pCB->tx.cmdQueue[pCB->tx.end].length = 0;   //2015.12.2修改
;;;244    }
000038  bdf0              POP      {r4-r7,pc}
                  |L22.58|
00003a  2a96              CMP      r2,#0x96              ;227
00003c  d2fc              BCS      |L22.56|
00003e  1c54              ADDS     r4,r2,#1              ;233
000040  70c4              STRB     r4,[r0,#3]            ;233
000042  e004              B        |L22.78|
                  |L22.68|
000044  1844              ADDS     r4,r0,r1              ;237
000046  78a4              LDRB     r4,[r4,#2]            ;237
000048  4063              EORS     r3,r3,r4              ;237
00004a  1c49              ADDS     r1,r1,#1              ;235
00004c  b289              UXTH     r1,r1                 ;235
                  |L22.78|
00004e  4291              CMP      r1,r2                 ;235
000050  d3f8              BCC      |L22.68|
000052  f8b01098          LDRH     r1,[r0,#0x98]         ;239
000056  1c4a              ADDS     r2,r1,#1              ;239
000058  f8a02098          STRH     r2,[r0,#0x98]         ;239
00005c  4408              ADD      r0,r0,r1              ;239
00005e  7083              STRB     r3,[r0,#2]            ;239
000060  f8b50470          LDRH     r0,[r5,#0x470]        ;241  ; uartProtocolCB1
000064  1c40              ADDS     r0,r0,#1              ;241
000066  b280              UXTH     r0,r0                 ;241
000068  fbb0f1f6          UDIV     r1,r0,r6              ;242
00006c  fb060011          MLS      r0,r6,r1,r0           ;242
000070  f8a50470          STRH     r0,[r5,#0x470]        ;242
000074  bdf0              POP      {r4-r7,pc}
;;;245    
                          ENDP

000076  0000              DCW      0x0000
                  |L22.120|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOL1_TxStateProcess||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL1_TxStateProcess PROC
;;;339    // 协议层发送处理过程
;;;340    void UART_PROTOCOL1_TxStateProcess(void)
000000  b570              PUSH     {r4-r6,lr}
;;;341    {
;;;342    	uint16 head = uartProtocolCB1.tx.head;
000002  4c14              LDR      r4,|L23.84|
000004  f8b4346e          LDRH     r3,[r4,#0x46e]  ; uartProtocolCB1
;;;343    	uint16 end =  uartProtocolCB1.tx.end;
000008  f8b46470          LDRH     r6,[r4,#0x470]  ; uartProtocolCB1
;;;344    	uint16 length = uartProtocolCB1.tx.cmdQueue[head].length;
00000c  204d              MOVS     r0,#0x4d
00000e  4358              MULS     r0,r3,r0
000010  eb040040          ADD      r0,r4,r0,LSL #1
000014  4605              MOV      r5,r0
000016  f8b02338          LDRH     r2,[r0,#0x338]
;;;345    	uint8* pCmd = uartProtocolCB1.tx.cmdQueue[head].buff;
00001a  f20021a2          ADD      r1,r0,#0x2a2
;;;346    	uint16 localDeviceID = uartProtocolCB1.tx.cmdQueue[head].deviceID;
00001e  f8b002a0          LDRH     r0,[r0,#0x2a0]
;;;347    
;;;348    	// 发送缓冲区为空，说明无数据
;;;349    	if (head == end)
000022  42b3              CMP      r3,r6
000024  d014              BEQ      |L23.80|
;;;350    	{
;;;351    		return;
;;;352    	}
;;;353    
;;;354    	// 发送函数没有注册直接返回
;;;355    	if (NULL == uartProtocolCB1.sendDataThrowService)
000026  f8d43478          LDR      r3,[r4,#0x478]  ; uartProtocolCB1
00002a  2b00              CMP      r3,#0
00002c  d010              BEQ      |L23.80|
;;;356    	{
;;;357    		return;
;;;358    	}
;;;359    
;;;360    	// 协议层有数据需要发送到驱动层		
;;;361    	if (!(*uartProtocolCB1.sendDataThrowService)(localDeviceID, pCmd, length))
00002e  4798              BLX      r3
000030  2800              CMP      r0,#0
000032  d00d              BEQ      |L23.80|
;;;362    	{
;;;363    		return;
;;;364    	}
;;;365    
;;;366    	// 发送环形队列更新位置
;;;367    	uartProtocolCB1.tx.cmdQueue[head].length = 0;
000034  2000              MOVS     r0,#0
000036  f8a50338          STRH     r0,[r5,#0x338]
;;;368    	uartProtocolCB1.tx.head ++;
00003a  f8b4046e          LDRH     r0,[r4,#0x46e]  ; uartProtocolCB1
00003e  1c40              ADDS     r0,r0,#1
000040  b280              UXTH     r0,r0
;;;369    	uartProtocolCB1.tx.head %= UART_PROTOCOL1_TX_QUEUE_SIZE;
000042  2103              MOVS     r1,#3
000044  fbb0f2f1          UDIV     r2,r0,r1
000048  fb010012          MLS      r0,r1,r2,r0
00004c  f8a4046e          STRH     r0,[r4,#0x46e]
                  |L23.80|
;;;370    }
000050  bd70              POP      {r4-r6,pc}
;;;371    
                          ENDP

000052  0000              DCW      0x0000
                  |L23.84|
                          DCD      ||.bss||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  uartProtocolCB1
                          %        1156
                  hmiDriveCB1
                          %        12

                          AREA ||.data||, DATA, ALIGN=0

                  assistCode
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "User\\UartProtocol1.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_UartProtocol1_c_6ec6eee3____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___15_UartProtocol1_c_6ec6eee3____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_UartProtocol1_c_6ec6eee3____REVSH|
#line 128
|__asm___15_UartProtocol1_c_6ec6eee3____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
