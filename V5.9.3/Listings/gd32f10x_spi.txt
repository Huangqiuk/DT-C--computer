; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\gd32f10x_spi.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\gd32f10x_spi.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -I.\User\qrencode -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.3\Device\Include -D__MICROLIB -D__UVISION_VERSION=539 -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\gd32f10x_spi.crf Libraries\src\gd32f10x_spi.c]
                          THUMB

                          AREA ||i.i2s_disable||, CODE, READONLY, ALIGN=1

                  i2s_disable PROC
;;;331    */
;;;332    void i2s_disable(uint32_t spi_periph)
000000  69c1              LDR      r1,[r0,#0x1c]
;;;333    {
;;;334        SPI_I2SCTL(spi_periph) &= (uint32_t)(~SPI_I2SCTL_I2SEN);
000002  f4216180          BIC      r1,r1,#0x400
000006  61c1              STR      r1,[r0,#0x1c]
;;;335    }
000008  4770              BX       lr
;;;336    
                          ENDP


                          AREA ||i.i2s_enable||, CODE, READONLY, ALIGN=1

                  i2s_enable PROC
;;;320    */
;;;321    void i2s_enable(uint32_t spi_periph)
000000  69c1              LDR      r1,[r0,#0x1c]
;;;322    {
;;;323        SPI_I2SCTL(spi_periph) |= (uint32_t)SPI_I2SCTL_I2SEN;
000002  f4416180          ORR      r1,r1,#0x400
000006  61c1              STR      r1,[r0,#0x1c]
;;;324    }
000008  4770              BX       lr
;;;325    
                          ENDP


                          AREA ||i.i2s_init||, CODE, READONLY, ALIGN=1

                  i2s_init PROC
;;;190    */
;;;191    void i2s_init(uint32_t spi_periph, uint32_t mode, uint32_t standard, uint32_t ckpl)
000000  b530              PUSH     {r4,r5,lr}
;;;192    {
000002  4604              MOV      r4,r0
;;;193        uint32_t reg = 0U;
000004  2000              MOVS     r0,#0
;;;194        reg = SPI_I2SCTL(spi_periph);
000006  69e0              LDR      r0,[r4,#0x1c]
;;;195        reg &= I2S_INIT_MASK;
000008  f24f0547          MOV      r5,#0xf047
00000c  4028              ANDS     r0,r0,r5
;;;196    
;;;197        /* enable I2S mode */
;;;198        reg |= (uint32_t)SPI_I2SCTL_I2SSEL; 
00000e  f4406000          ORR      r0,r0,#0x800
;;;199        /* select I2S mode */
;;;200        reg |= (uint32_t)mode;
000012  4308              ORRS     r0,r0,r1
;;;201        /* select I2S standard */
;;;202        reg |= (uint32_t)standard;
000014  4310              ORRS     r0,r0,r2
;;;203        /* select I2S polarity */
;;;204        reg |= (uint32_t)ckpl;
000016  4318              ORRS     r0,r0,r3
;;;205    
;;;206        /* write to SPI_I2SCTL register */
;;;207        SPI_I2SCTL(spi_periph) = (uint32_t)reg;
000018  61e0              STR      r0,[r4,#0x1c]
;;;208    }
00001a  bd30              POP      {r4,r5,pc}
;;;209    
                          ENDP


                          AREA ||i.i2s_psc_config||, CODE, READONLY, ALIGN=1

                  i2s_psc_config PROC
;;;236    */
;;;237    void i2s_psc_config(uint32_t spi_periph, uint32_t audiosample, uint32_t frameformat, uint32_t mckout)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;238    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;239        uint32_t i2sdiv = 2U, i2sof = 0U;
00000c  f04f0902          MOV      r9,#2
000010  f04f0a00          MOV      r10,#0
;;;240        uint32_t clks = 0U;
000014  bf00              NOP      
;;;241        uint32_t i2sclock = 0U;
000016  f04f0b00          MOV      r11,#0
;;;242    
;;;243        /* deinit SPI_I2SPSC register */
;;;244        SPI_I2SPSC(spi_periph) = SPI_I2SPSC_DEFAULT_VALUE;
00001a  2002              MOVS     r0,#2
00001c  6220              STR      r0,[r4,#0x20]
;;;245    
;;;246    #ifdef GD32F10X_CL
;;;247        /* get the I2S clock source */
;;;248        if(SPI1 == ((uint32_t)spi_periph)){
;;;249            /* I2S1 clock source selection */
;;;250            clks = I2S1_CLOCK_SEL;
;;;251        }else{
;;;252            /* I2S2 clock source selection */
;;;253            clks = I2S2_CLOCK_SEL;
;;;254        }
;;;255        
;;;256        if(0U != (RCU_CFG1 & clks)){
;;;257            /* get RCU PLL2 clock multiplication factor */
;;;258            clks = (uint32_t)((RCU_CFG1 & I2S_CLOCK_MUL_MASK) >> RCU_CFG1_PLL2MF_OFFSET);
;;;259     
;;;260            if((clks > 5U) && (clks < 15U)){
;;;261                /* multiplier is between 8 and 14 */
;;;262                clks += 2U;
;;;263            }else{
;;;264                if(15U == clks){
;;;265                    /* multiplier is 20 */
;;;266                    clks = 20U;
;;;267                }
;;;268            }
;;;269            
;;;270            /* get the PREDV1 value */
;;;271            i2sclock = (uint32_t)(((RCU_CFG1 & I2S_CLOCK_DIV_MASK) >>  RCU_CFG1_PREDV1_OFFSET) + 1U);
;;;272            /* calculate I2S clock based on PLL2 and PREDV1 */
;;;273            i2sclock = (uint32_t)((HXTAL_VALUE / i2sclock) * clks * 2U); 
;;;274        }else{
;;;275            /* get system clock */
;;;276            i2sclock = rcu_clock_freq_get(CK_SYS);
;;;277        }
;;;278    #else
;;;279        /* get system clock */
;;;280        i2sclock = rcu_clock_freq_get(CK_SYS);
00001e  2000              MOVS     r0,#0
000020  f7fffffe          BL       rcu_clock_freq_get
000024  4683              MOV      r11,r0
;;;281    #endif /* GD32F10X_CL */ 
;;;282        
;;;283        /* config the prescaler depending on the mclk output state, the frame format and audio sample rate */
;;;284        if(I2S_MCKOUT_ENABLE == mckout){
000026  f5b87f00          CMP      r8,#0x200
00002a  d107              BNE      |L4.60|
;;;285            clks = (uint32_t)(((i2sclock / 256U) * 10U) / audiosample);
00002c  ea4f201b          LSR      r0,r11,#8
000030  eb000080          ADD      r0,r0,r0,LSL #2
000034  0040              LSLS     r0,r0,#1
000036  fbb0f5f6          UDIV     r5,r0,r6
00003a  e00f              B        |L4.92|
                  |L4.60|
;;;286        }else{
;;;287            if(I2S_FRAMEFORMAT_DT16B_CH16B == frameformat){
00003c  b93f              CBNZ     r7,|L4.78|
;;;288                clks = (uint32_t)(((i2sclock / 32U) *10U ) / audiosample);
00003e  ea4f105b          LSR      r0,r11,#5
000042  eb000080          ADD      r0,r0,r0,LSL #2
000046  0040              LSLS     r0,r0,#1
000048  fbb0f5f6          UDIV     r5,r0,r6
00004c  e006              B        |L4.92|
                  |L4.78|
;;;289            }else{
;;;290                clks = (uint32_t)(((i2sclock / 64U) *10U ) / audiosample);
00004e  ea4f109b          LSR      r0,r11,#6
000052  eb000080          ADD      r0,r0,r0,LSL #2
000056  0040              LSLS     r0,r0,#1
000058  fbb0f5f6          UDIV     r5,r0,r6
                  |L4.92|
;;;291            }
;;;292        }
;;;293        
;;;294        /* remove the floating point */
;;;295        clks = (clks + 5U) / 10U;
00005c  1d68              ADDS     r0,r5,#5
00005e  210a              MOVS     r1,#0xa
000060  fbb0f5f1          UDIV     r5,r0,r1
;;;296        i2sof  = (clks & 0x00000001U);
000064  f0050a01          AND      r10,r5,#1
;;;297        i2sdiv = ((clks - i2sof) / 2U);
000068  eba5000a          SUB      r0,r5,r10
00006c  ea4f0950          LSR      r9,r0,#1
;;;298        i2sof  = (i2sof << 8U);
000070  ea4f2a0a          LSL      r10,r10,#8
;;;299    
;;;300        /* set the default values */
;;;301        if((i2sdiv < 2U) || (i2sdiv > 255U)){
000074  f1b90f02          CMP      r9,#2
000078  d302              BCC      |L4.128|
00007a  f1b90fff          CMP      r9,#0xff
00007e  d903              BLS      |L4.136|
                  |L4.128|
;;;302            i2sdiv = 2U;
000080  f04f0902          MOV      r9,#2
;;;303            i2sof = 0U;
000084  f04f0a00          MOV      r10,#0
                  |L4.136|
;;;304        }
;;;305    
;;;306        /* configure SPI_I2SPSC */
;;;307        SPI_I2SPSC(spi_periph) = (uint32_t)(i2sdiv | i2sof | mckout);
000088  ea49000a          ORR      r0,r9,r10
00008c  ea400008          ORR      r0,r0,r8
000090  6220              STR      r0,[r4,#0x20]
;;;308    
;;;309        /* clear SPI_I2SCTL_DTLEN and SPI_I2SCTL_CHLEN bits */
;;;310        SPI_I2SCTL(spi_periph) &= (uint32_t)(~(SPI_I2SCTL_DTLEN | SPI_I2SCTL_CHLEN));
000092  69e0              LDR      r0,[r4,#0x1c]
000094  f0200007          BIC      r0,r0,#7
000098  61e0              STR      r0,[r4,#0x1c]
;;;311        /* configure data frame format */
;;;312        SPI_I2SCTL(spi_periph) |= (uint32_t)frameformat;
00009a  69e0              LDR      r0,[r4,#0x1c]
00009c  4338              ORRS     r0,r0,r7
00009e  61e0              STR      r0,[r4,#0x1c]
;;;313    }
0000a0  e8bd9ff0          POP      {r4-r12,pc}
;;;314    
                          ENDP


                          AREA ||i.spi_bidirectional_transfer_config||, CODE, READONLY, ALIGN=1

                  spi_bidirectional_transfer_config PROC
;;;469    */
;;;470    void spi_bidirectional_transfer_config(uint32_t spi_periph, uint32_t transfer_direction)
000000  f5b14f80          CMP      r1,#0x4000
;;;471    {
;;;472        if(SPI_BIDIRECTIONAL_TRANSMIT == transfer_direction){
000004  d104              BNE      |L5.16|
;;;473            /* set the transmit only mode */
;;;474            SPI_CTL0(spi_periph) |= (uint32_t)SPI_BIDIRECTIONAL_TRANSMIT;
000006  6802              LDR      r2,[r0,#0]
000008  f4424280          ORR      r2,r2,#0x4000
00000c  6002              STR      r2,[r0,#0]
00000e  e003              B        |L5.24|
                  |L5.16|
;;;475        }else{
;;;476            /* set the receive only mode */
;;;477            SPI_CTL0(spi_periph) &= SPI_BIDIRECTIONAL_RECEIVE;
000010  6802              LDR      r2,[r0,#0]
000012  f4224280          BIC      r2,r2,#0x4000
000016  6002              STR      r2,[r0,#0]
                  |L5.24|
;;;478        }
;;;479    }
000018  4770              BX       lr
;;;480    
                          ENDP


                          AREA ||i.spi_crc_error_clear||, CODE, READONLY, ALIGN=1

                  spi_crc_error_clear PROC
;;;714    */
;;;715    void spi_crc_error_clear(uint32_t spi_periph)
000000  6881              LDR      r1,[r0,#8]
;;;716    {
;;;717        SPI_STAT(spi_periph) &= (uint32_t)(~SPI_FLAG_CRCERR);
000002  f0210110          BIC      r1,r1,#0x10
000006  6081              STR      r1,[r0,#8]
;;;718    }
000008  4770              BX       lr
                          ENDP


                          AREA ||i.spi_crc_get||, CODE, READONLY, ALIGN=1

                  spi_crc_get PROC
;;;548    */
;;;549    uint16_t spi_crc_get(uint32_t spi_periph, uint8_t crc)
000000  4602              MOV      r2,r0
;;;550    {
;;;551        if(SPI_CRC_TX == crc){
000002  b911              CBNZ     r1,|L7.10|
;;;552            return ((uint16_t)(SPI_TCRC(spi_periph)));
000004  6990              LDR      r0,[r2,#0x18]
000006  b280              UXTH     r0,r0
                  |L7.8|
;;;553        }else{
;;;554            return ((uint16_t)(SPI_RCRC(spi_periph)));
;;;555        }
;;;556    }
000008  4770              BX       lr
                  |L7.10|
00000a  6950              LDR      r0,[r2,#0x14]         ;554
00000c  b280              UXTH     r0,r0                 ;554
00000e  e7fb              B        |L7.8|
;;;557    
                          ENDP


                          AREA ||i.spi_crc_next||, CODE, READONLY, ALIGN=1

                  spi_crc_next PROC
;;;533    */
;;;534    void spi_crc_next(uint32_t spi_periph)
000000  6801              LDR      r1,[r0,#0]
;;;535    {
;;;536        SPI_CTL0(spi_periph) |= (uint32_t)SPI_CTL0_CRCNT;
000002  f4415180          ORR      r1,r1,#0x1000
000006  6001              STR      r1,[r0,#0]
;;;537    }
000008  4770              BX       lr
;;;538    
                          ENDP


                          AREA ||i.spi_crc_off||, CODE, READONLY, ALIGN=1

                  spi_crc_off PROC
;;;523    */
;;;524    void spi_crc_off(uint32_t spi_periph)
000000  6801              LDR      r1,[r0,#0]
;;;525    {
;;;526        SPI_CTL0(spi_periph) &= (uint32_t)(~SPI_CTL0_CRCEN);
000002  f4215100          BIC      r1,r1,#0x2000
000006  6001              STR      r1,[r0,#0]
;;;527    }
000008  4770              BX       lr
;;;528    /*!
                          ENDP


                          AREA ||i.spi_crc_on||, CODE, READONLY, ALIGN=1

                  spi_crc_on PROC
;;;512    */
;;;513    void spi_crc_on(uint32_t spi_periph)
000000  6801              LDR      r1,[r0,#0]
;;;514    {
;;;515        SPI_CTL0(spi_periph) |= (uint32_t)SPI_CTL0_CRCEN;
000002  f4415100          ORR      r1,r1,#0x2000
000006  6001              STR      r1,[r0,#0]
;;;516    }
000008  4770              BX       lr
;;;517    
                          ENDP


                          AREA ||i.spi_crc_polynomial_get||, CODE, READONLY, ALIGN=1

                  spi_crc_polynomial_get PROC
;;;501    */
;;;502    uint16_t spi_crc_polynomial_get(uint32_t spi_periph)
000000  4601              MOV      r1,r0
;;;503    {
;;;504        return ((uint16_t)SPI_CRCPOLY(spi_periph));
000002  6908              LDR      r0,[r1,#0x10]
000004  b280              UXTH     r0,r0
;;;505    }
000006  4770              BX       lr
;;;506    
                          ENDP


                          AREA ||i.spi_crc_polynomial_set||, CODE, READONLY, ALIGN=1

                  spi_crc_polynomial_set PROC
;;;487    */
;;;488    void spi_crc_polynomial_set(uint32_t spi_periph, uint16_t crc_poly)
000000  6802              LDR      r2,[r0,#0]
;;;489    {
;;;490        /* enable SPI CRC */
;;;491        SPI_CTL0(spi_periph) |= (uint32_t)SPI_CTL0_CRCEN;
000002  f4425200          ORR      r2,r2,#0x2000
000006  6002              STR      r2,[r0,#0]
;;;492        /* set SPI CRC polynomial */
;;;493        SPI_CRCPOLY(spi_periph) = (uint32_t)crc_poly;
000008  6101              STR      r1,[r0,#0x10]
;;;494    }
00000a  4770              BX       lr
;;;495    
                          ENDP


                          AREA ||i.spi_disable||, CODE, READONLY, ALIGN=1

                  spi_disable PROC
;;;162    */
;;;163    void spi_disable(uint32_t spi_periph)
000000  6801              LDR      r1,[r0,#0]
;;;164    {
;;;165        SPI_CTL0(spi_periph) &= (uint32_t)(~SPI_CTL0_SPIEN);
000002  f0210140          BIC      r1,r1,#0x40
000006  6001              STR      r1,[r0,#0]
;;;166    }
000008  4770              BX       lr
;;;167    
                          ENDP


                          AREA ||i.spi_dma_disable||, CODE, READONLY, ALIGN=1

                  spi_dma_disable PROC
;;;409    */
;;;410    void spi_dma_disable(uint32_t spi_periph, uint8_t dma)
000000  b921              CBNZ     r1,|L14.12|
;;;411    {
;;;412        if(SPI_DMA_TRANSMIT == dma){
;;;413            SPI_CTL1(spi_periph) &= (uint32_t)(~SPI_CTL1_DMATEN);
000002  6842              LDR      r2,[r0,#4]
000004  f0220202          BIC      r2,r2,#2
000008  6042              STR      r2,[r0,#4]
00000a  e003              B        |L14.20|
                  |L14.12|
;;;414        }else{
;;;415            SPI_CTL1(spi_periph) &= (uint32_t)(~SPI_CTL1_DMAREN);
00000c  6842              LDR      r2,[r0,#4]
00000e  f0220201          BIC      r2,r2,#1
000012  6042              STR      r2,[r0,#4]
                  |L14.20|
;;;416        }
;;;417    }
000014  4770              BX       lr
;;;418    
                          ENDP


                          AREA ||i.spi_dma_enable||, CODE, READONLY, ALIGN=1

                  spi_dma_enable PROC
;;;390    */
;;;391    void spi_dma_enable(uint32_t spi_periph, uint8_t dma)
000000  b921              CBNZ     r1,|L15.12|
;;;392    {
;;;393        if(SPI_DMA_TRANSMIT == dma){
;;;394            SPI_CTL1(spi_periph) |= (uint32_t)SPI_CTL1_DMATEN;
000002  6842              LDR      r2,[r0,#4]
000004  f0420202          ORR      r2,r2,#2
000008  6042              STR      r2,[r0,#4]
00000a  e003              B        |L15.20|
                  |L15.12|
;;;395        }else{
;;;396            SPI_CTL1(spi_periph) |= (uint32_t)SPI_CTL1_DMAREN;
00000c  6842              LDR      r2,[r0,#4]
00000e  f0420201          ORR      r2,r2,#1
000012  6042              STR      r2,[r0,#4]
                  |L15.20|
;;;397        }
;;;398    }
000014  4770              BX       lr
;;;399    
                          ENDP


                          AREA ||i.spi_enable||, CODE, READONLY, ALIGN=1

                  spi_enable PROC
;;;151    */
;;;152    void spi_enable(uint32_t spi_periph)
000000  6801              LDR      r1,[r0,#0]
;;;153    {
;;;154        SPI_CTL0(spi_periph) |= (uint32_t)SPI_CTL0_SPIEN;
000002  f0410140          ORR      r1,r1,#0x40
000006  6001              STR      r1,[r0,#0]
;;;155    }
000008  4770              BX       lr
;;;156    
                          ENDP


                          AREA ||i.spi_i2s_data_frame_format_config||, CODE, READONLY, ALIGN=1

                  spi_i2s_data_frame_format_config PROC
;;;428    */
;;;429    void spi_i2s_data_frame_format_config(uint32_t spi_periph, uint16_t frame_format)
000000  6802              LDR      r2,[r0,#0]
;;;430    {
;;;431        /* clear SPI_CTL0_FF16 bit */
;;;432        SPI_CTL0(spi_periph) &= (uint32_t)(~SPI_CTL0_FF16);
000002  f4226200          BIC      r2,r2,#0x800
000006  6002              STR      r2,[r0,#0]
;;;433        /* configure SPI_CTL0_FF16 bit */
;;;434        SPI_CTL0(spi_periph) |= (uint32_t)frame_format;
000008  6802              LDR      r2,[r0,#0]
00000a  430a              ORRS     r2,r2,r1
00000c  6002              STR      r2,[r0,#0]
;;;435    }
00000e  4770              BX       lr
;;;436    
                          ENDP


                          AREA ||i.spi_i2s_data_receive||, CODE, READONLY, ALIGN=1

                  spi_i2s_data_receive PROC
;;;454    */
;;;455    uint16_t spi_i2s_data_receive(uint32_t spi_periph)
000000  4601              MOV      r1,r0
;;;456    {
;;;457        return ((uint16_t)SPI_DATA(spi_periph));
000002  68c8              LDR      r0,[r1,#0xc]
000004  b280              UXTH     r0,r0
;;;458    }
000006  4770              BX       lr
;;;459    
                          ENDP


                          AREA ||i.spi_i2s_data_transmit||, CODE, READONLY, ALIGN=1

                  spi_i2s_data_transmit PROC
;;;443    */
;;;444    void spi_i2s_data_transmit(uint32_t spi_periph, uint16_t data)
000000  60c1              STR      r1,[r0,#0xc]
;;;445    {
;;;446        SPI_DATA(spi_periph) = (uint32_t)data;
;;;447    }
000002  4770              BX       lr
;;;448    
                          ENDP


                          AREA ||i.spi_i2s_deinit||, CODE, READONLY, ALIGN=2

                  spi_i2s_deinit PROC
;;;61     */
;;;62     void spi_i2s_deinit(uint32_t spi_periph)
000000  b510              PUSH     {r4,lr}
;;;63     {
000002  4604              MOV      r4,r0
;;;64         switch(spi_periph){
000004  4813              LDR      r0,|L20.84|
000006  4420              ADD      r0,r0,r4
000008  b170              CBZ      r0,|L20.40|
00000a  f5b06f80          CMP      r0,#0x400
00000e  d014              BEQ      |L20.58|
000010  f5b04f78          CMP      r0,#0xf800
000014  d11a              BNE      |L20.76|
;;;65         case SPI0:
;;;66             /* reset SPI0 */
;;;67             rcu_periph_reset_enable(RCU_SPI0RST);
000016  f44f7043          MOV      r0,#0x30c
00001a  f7fffffe          BL       rcu_periph_reset_enable
;;;68             rcu_periph_reset_disable(RCU_SPI0RST);
00001e  f44f7043          MOV      r0,#0x30c
000022  f7fffffe          BL       rcu_periph_reset_disable
;;;69             break;
000026  e012              B        |L20.78|
                  |L20.40|
;;;70         case SPI1:
;;;71             /* reset SPI1 and I2S1 */
;;;72             rcu_periph_reset_enable(RCU_SPI1RST);
000028  f240400e          MOV      r0,#0x40e
00002c  f7fffffe          BL       rcu_periph_reset_enable
;;;73             rcu_periph_reset_disable(RCU_SPI1RST);
000030  f240400e          MOV      r0,#0x40e
000034  f7fffffe          BL       rcu_periph_reset_disable
;;;74             break;
000038  e009              B        |L20.78|
                  |L20.58|
;;;75         case SPI2:
;;;76             /* reset SPI2 and I2S2 */
;;;77             rcu_periph_reset_enable(RCU_SPI2RST);
00003a  f240400f          MOV      r0,#0x40f
00003e  f7fffffe          BL       rcu_periph_reset_enable
;;;78             rcu_periph_reset_disable(RCU_SPI2RST);
000042  f240400f          MOV      r0,#0x40f
000046  f7fffffe          BL       rcu_periph_reset_disable
;;;79             break;
00004a  e000              B        |L20.78|
                  |L20.76|
;;;80         default :
;;;81             break;
00004c  bf00              NOP      
                  |L20.78|
00004e  bf00              NOP                            ;69
;;;82         }
;;;83     }
000050  bd10              POP      {r4,pc}
;;;84     
                          ENDP

000052  0000              DCW      0x0000
                  |L20.84|
                          DCD      0xbfffc800

                          AREA ||i.spi_i2s_flag_get||, CODE, READONLY, ALIGN=1

                  spi_i2s_flag_get PROC
;;;699    */
;;;700    FlagStatus spi_i2s_flag_get(uint32_t spi_periph, uint32_t flag)
000000  4602              MOV      r2,r0
;;;701    {
;;;702        if(RESET != (SPI_STAT(spi_periph) & flag)){
000002  6890              LDR      r0,[r2,#8]
000004  4008              ANDS     r0,r0,r1
000006  b108              CBZ      r0,|L21.12|
;;;703            return SET;
000008  2001              MOVS     r0,#1
                  |L21.10|
;;;704        }else{
;;;705            return RESET;
;;;706        }
;;;707    }
00000a  4770              BX       lr
                  |L21.12|
00000c  2000              MOVS     r0,#0                 ;705
00000e  e7fc              B        |L21.10|
;;;708    
                          ENDP


                          AREA ||i.spi_i2s_interrupt_disable||, CODE, READONLY, ALIGN=1

                  spi_i2s_interrupt_disable PROC
;;;601    */
;;;602    void spi_i2s_interrupt_disable(uint32_t spi_periph, uint8_t interrupt)
000000  b121              CBZ      r1,|L22.12|
;;;603    {
;;;604        switch(interrupt){
000002  2901              CMP      r1,#1
000004  d007              BEQ      |L22.22|
000006  2902              CMP      r1,#2
000008  d10f              BNE      |L22.42|
00000a  e009              B        |L22.32|
                  |L22.12|
;;;605        /* SPI/I2S transmit buffer empty interrupt */
;;;606        case SPI_I2S_INT_TBE:
;;;607            SPI_CTL1(spi_periph) &= (uint32_t)(~SPI_CTL1_TBEIE);
00000c  6842              LDR      r2,[r0,#4]
00000e  f0220280          BIC      r2,r2,#0x80
000012  6042              STR      r2,[r0,#4]
;;;608            break;
000014  e00a              B        |L22.44|
                  |L22.22|
;;;609        /* SPI/I2S receive buffer not empty interrupt */
;;;610        case SPI_I2S_INT_RBNE:
;;;611            SPI_CTL1(spi_periph) &= (uint32_t)(~SPI_CTL1_RBNEIE);
000016  6842              LDR      r2,[r0,#4]
000018  f0220240          BIC      r2,r2,#0x40
00001c  6042              STR      r2,[r0,#4]
;;;612            break;
00001e  e005              B        |L22.44|
                  |L22.32|
;;;613        /* SPI/I2S error */
;;;614        case SPI_I2S_INT_ERR:
;;;615            SPI_CTL1(spi_periph) &= (uint32_t)(~SPI_CTL1_ERRIE);
000020  6842              LDR      r2,[r0,#4]
000022  f0220220          BIC      r2,r2,#0x20
000026  6042              STR      r2,[r0,#4]
;;;616            break;
000028  e000              B        |L22.44|
                  |L22.42|
;;;617        default :
;;;618            break;
00002a  bf00              NOP      
                  |L22.44|
00002c  bf00              NOP                            ;608
;;;619        }
;;;620    }
00002e  4770              BX       lr
;;;621    
                          ENDP


                          AREA ||i.spi_i2s_interrupt_enable||, CODE, READONLY, ALIGN=1

                  spi_i2s_interrupt_enable PROC
;;;569    */
;;;570    void spi_i2s_interrupt_enable(uint32_t spi_periph, uint8_t interrupt)
000000  b121              CBZ      r1,|L23.12|
;;;571    {
;;;572        switch(interrupt){
000002  2901              CMP      r1,#1
000004  d007              BEQ      |L23.22|
000006  2902              CMP      r1,#2
000008  d10f              BNE      |L23.42|
00000a  e009              B        |L23.32|
                  |L23.12|
;;;573        /* SPI/I2S transmit buffer empty interrupt */
;;;574        case SPI_I2S_INT_TBE:
;;;575            SPI_CTL1(spi_periph) |= (uint32_t)SPI_CTL1_TBEIE;
00000c  6842              LDR      r2,[r0,#4]
00000e  f0420280          ORR      r2,r2,#0x80
000012  6042              STR      r2,[r0,#4]
;;;576            break;
000014  e00a              B        |L23.44|
                  |L23.22|
;;;577        /* SPI/I2S receive buffer not empty interrupt */
;;;578        case SPI_I2S_INT_RBNE:
;;;579            SPI_CTL1(spi_periph) |= (uint32_t)SPI_CTL1_RBNEIE;
000016  6842              LDR      r2,[r0,#4]
000018  f0420240          ORR      r2,r2,#0x40
00001c  6042              STR      r2,[r0,#4]
;;;580            break;
00001e  e005              B        |L23.44|
                  |L23.32|
;;;581        /* SPI/I2S error */
;;;582        case SPI_I2S_INT_ERR:
;;;583            SPI_CTL1(spi_periph) |= (uint32_t)SPI_CTL1_ERRIE;
000020  6842              LDR      r2,[r0,#4]
000022  f0420220          ORR      r2,r2,#0x20
000026  6042              STR      r2,[r0,#4]
;;;584            break;
000028  e000              B        |L23.44|
                  |L23.42|
;;;585        default:
;;;586            break;
00002a  bf00              NOP      
                  |L23.44|
00002c  bf00              NOP                            ;576
;;;587        }
;;;588    }
00002e  4770              BX       lr
;;;589    
                          ENDP


                          AREA ||i.spi_i2s_interrupt_flag_get||, CODE, READONLY, ALIGN=1

                  spi_i2s_interrupt_flag_get PROC
;;;635    */
;;;636    FlagStatus spi_i2s_interrupt_flag_get(uint32_t spi_periph, uint8_t interrupt)
000000  b510              PUSH     {r4,lr}
;;;637    {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;638        uint32_t reg1 = SPI_STAT(spi_periph);
000006  6899              LDR      r1,[r3,#8]
;;;639        uint32_t reg2 = SPI_CTL1(spi_periph);
000008  685a              LDR      r2,[r3,#4]
;;;640    
;;;641        switch(interrupt){
00000a  2c06              CMP      r4,#6
00000c  d222              BCS      |L24.84|
00000e  e8dff004          TBB      [pc,r4]
000012  0308              DCB      0x03,0x08
000014  0d12171c          DCB      0x0d,0x12,0x17,0x1c
;;;642        /* SPI/I2S transmit buffer empty interrupt */
;;;643        case SPI_I2S_INT_FLAG_TBE:
;;;644            reg1 = reg1 & SPI_STAT_TBE;
000018  f0010102          AND      r1,r1,#2
;;;645            reg2 = reg2 & SPI_CTL1_TBEIE;
00001c  f0020280          AND      r2,r2,#0x80
;;;646            break;
000020  e019              B        |L24.86|
;;;647        /* SPI/I2S receive buffer not empty interrupt */
;;;648        case SPI_I2S_INT_FLAG_RBNE:
;;;649            reg1 = reg1 & SPI_STAT_RBNE;
000022  f0010101          AND      r1,r1,#1
;;;650            reg2 = reg2 & SPI_CTL1_RBNEIE;
000026  f0020240          AND      r2,r2,#0x40
;;;651            break;
00002a  e014              B        |L24.86|
;;;652        /* SPI/I2S overrun interrupt */
;;;653        case SPI_I2S_INT_FLAG_RXORERR:
;;;654            reg1 = reg1 & SPI_STAT_RXORERR;
00002c  f0010140          AND      r1,r1,#0x40
;;;655            reg2 = reg2 & SPI_CTL1_ERRIE;
000030  f0020220          AND      r2,r2,#0x20
;;;656            break;
000034  e00f              B        |L24.86|
;;;657        /* SPI config error interrupt */
;;;658        case SPI_INT_FLAG_CONFERR:
;;;659            reg1 = reg1 & SPI_STAT_CONFERR;
000036  f0010120          AND      r1,r1,#0x20
;;;660            reg2 = reg2 & SPI_CTL1_ERRIE;
00003a  f0020220          AND      r2,r2,#0x20
;;;661            break;
00003e  e00a              B        |L24.86|
;;;662        /* SPI CRC error interrupt */
;;;663        case SPI_INT_FLAG_CRCERR:
;;;664            reg1 = reg1 & SPI_STAT_CRCERR;
000040  f0010110          AND      r1,r1,#0x10
;;;665            reg2 = reg2 & SPI_CTL1_ERRIE;
000044  f0020220          AND      r2,r2,#0x20
;;;666            break;
000048  e005              B        |L24.86|
;;;667        /* I2S underrun error interrupt */
;;;668        case I2S_INT_FLAG_TXURERR:
;;;669            reg1 = reg1 & SPI_STAT_TXURERR;
00004a  f0010108          AND      r1,r1,#8
;;;670            reg2 = reg2 & SPI_CTL1_ERRIE;
00004e  f0020220          AND      r2,r2,#0x20
;;;671            break;
000052  e000              B        |L24.86|
                  |L24.84|
;;;672        default :
;;;673            break;
000054  bf00              NOP      
                  |L24.86|
000056  bf00              NOP                            ;646
;;;674        }
;;;675        /*get SPI/I2S interrupt flag status */
;;;676        if((0U != reg1) && (0U != reg2)){
000058  b111              CBZ      r1,|L24.96|
00005a  b10a              CBZ      r2,|L24.96|
;;;677            return SET;
00005c  2001              MOVS     r0,#1
                  |L24.94|
;;;678        }else{
;;;679            return RESET;
;;;680        }
;;;681    }
00005e  bd10              POP      {r4,pc}
                  |L24.96|
000060  2000              MOVS     r0,#0                 ;679
000062  e7fc              B        |L24.94|
;;;682    
                          ENDP


                          AREA ||i.spi_init||, CODE, READONLY, ALIGN=1

                  spi_init PROC
;;;118    */
;;;119    void spi_init(uint32_t spi_periph, spi_parameter_struct* spi_struct)
000000  4602              MOV      r2,r0
;;;120    {   
;;;121        uint32_t reg = 0U;
000002  2000              MOVS     r0,#0
;;;122        reg = SPI_CTL0(spi_periph);
000004  6810              LDR      r0,[r2,#0]
;;;123        reg &= SPI_INIT_MASK;
000006  f4005041          AND      r0,r0,#0x3040
;;;124    
;;;125        /* select SPI as master or slave */
;;;126        reg |= spi_struct->device_mode;
00000a  680b              LDR      r3,[r1,#0]
00000c  4318              ORRS     r0,r0,r3
;;;127        /* select SPI transfer mode */
;;;128        reg |= spi_struct->trans_mode;
00000e  684b              LDR      r3,[r1,#4]
000010  4318              ORRS     r0,r0,r3
;;;129        /* select SPI frame size */
;;;130        reg |= spi_struct->frame_size;
000012  688b              LDR      r3,[r1,#8]
000014  4318              ORRS     r0,r0,r3
;;;131        /* select SPI NSS use hardware or software */
;;;132        reg |= spi_struct->nss;
000016  68cb              LDR      r3,[r1,#0xc]
000018  4318              ORRS     r0,r0,r3
;;;133        /* select SPI LSB or MSB */
;;;134        reg |= spi_struct->endian;
00001a  690b              LDR      r3,[r1,#0x10]
00001c  4318              ORRS     r0,r0,r3
;;;135        /* select SPI polarity and phase */
;;;136        reg |= spi_struct->clock_polarity_phase;
00001e  694b              LDR      r3,[r1,#0x14]
000020  4318              ORRS     r0,r0,r3
;;;137        /* select SPI prescale to adjust transmit speed */
;;;138        reg |= spi_struct->prescale;
000022  698b              LDR      r3,[r1,#0x18]
000024  4318              ORRS     r0,r0,r3
;;;139    
;;;140        /* write to SPI_CTL0 register */
;;;141        SPI_CTL0(spi_periph) = (uint32_t)reg;
000026  6010              STR      r0,[r2,#0]
;;;142    
;;;143        SPI_I2SCTL(spi_periph) &= (uint32_t)(~SPI_I2SCTL_I2SSEL);
000028  69d3              LDR      r3,[r2,#0x1c]
00002a  f4236300          BIC      r3,r3,#0x800
00002e  61d3              STR      r3,[r2,#0x1c]
;;;144    }
000030  4770              BX       lr
;;;145    
                          ENDP


                          AREA ||i.spi_nss_internal_high||, CODE, READONLY, ALIGN=1

                  spi_nss_internal_high PROC
;;;364    */
;;;365    void spi_nss_internal_high(uint32_t spi_periph)
000000  6801              LDR      r1,[r0,#0]
;;;366    {
;;;367        SPI_CTL0(spi_periph) |= (uint32_t)SPI_CTL0_SWNSS;
000002  f4417180          ORR      r1,r1,#0x100
000006  6001              STR      r1,[r0,#0]
;;;368    }
000008  4770              BX       lr
;;;369    
                          ENDP


                          AREA ||i.spi_nss_internal_low||, CODE, READONLY, ALIGN=1

                  spi_nss_internal_low PROC
;;;375    */
;;;376    void spi_nss_internal_low(uint32_t spi_periph)
000000  6801              LDR      r1,[r0,#0]
;;;377    {
;;;378        SPI_CTL0(spi_periph) &= (uint32_t)(~SPI_CTL0_SWNSS);
000002  f4217180          BIC      r1,r1,#0x100
000006  6001              STR      r1,[r0,#0]
;;;379    }
000008  4770              BX       lr
;;;380    
                          ENDP


                          AREA ||i.spi_nss_output_disable||, CODE, READONLY, ALIGN=1

                  spi_nss_output_disable PROC
;;;353    */
;;;354    void spi_nss_output_disable(uint32_t spi_periph)
000000  6841              LDR      r1,[r0,#4]
;;;355    {
;;;356        SPI_CTL1(spi_periph) &= (uint32_t)(~SPI_CTL1_NSSDRV);
000002  f0210104          BIC      r1,r1,#4
000006  6041              STR      r1,[r0,#4]
;;;357    }
000008  4770              BX       lr
;;;358    
                          ENDP


                          AREA ||i.spi_nss_output_enable||, CODE, READONLY, ALIGN=1

                  spi_nss_output_enable PROC
;;;342    */
;;;343    void spi_nss_output_enable(uint32_t spi_periph)
000000  6841              LDR      r1,[r0,#4]
;;;344    {
;;;345        SPI_CTL1(spi_periph) |= (uint32_t)SPI_CTL1_NSSDRV;
000002  f0410104          ORR      r1,r1,#4
000006  6041              STR      r1,[r0,#4]
;;;346    }
000008  4770              BX       lr
;;;347    
                          ENDP


                          AREA ||i.spi_struct_para_init||, CODE, READONLY, ALIGN=1

                  spi_struct_para_init PROC
;;;90     */
;;;91     void spi_struct_para_init(spi_parameter_struct* spi_struct)
000000  2100              MOVS     r1,#0
;;;92     {
;;;93         /* set the SPI struct with the default values */
;;;94         spi_struct->device_mode = SPI_SLAVE;
000002  6001              STR      r1,[r0,#0]
;;;95         spi_struct->trans_mode = SPI_TRANSMODE_FULLDUPLEX;
000004  6041              STR      r1,[r0,#4]
;;;96         spi_struct->frame_size = SPI_FRAMESIZE_8BIT;
000006  6081              STR      r1,[r0,#8]
;;;97         spi_struct->nss = SPI_NSS_HARD;
000008  60c1              STR      r1,[r0,#0xc]
;;;98         spi_struct->clock_polarity_phase = SPI_CK_PL_LOW_PH_1EDGE;
00000a  6141              STR      r1,[r0,#0x14]
;;;99         spi_struct->prescale = SPI_PSC_2;
00000c  6181              STR      r1,[r0,#0x18]
;;;100    }
00000e  4770              BX       lr
;;;101    
                          ENDP


;*** Start embedded assembler ***

#line 1 "Libraries\\src\\gd32f10x_spi.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_gd32f10x_spi_c_5c0caa7c____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___14_gd32f10x_spi_c_5c0caa7c____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_gd32f10x_spi_c_5c0caa7c____REVSH|
#line 128
|__asm___14_gd32f10x_spi_c_5c0caa7c____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
