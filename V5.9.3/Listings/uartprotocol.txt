; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\uartprotocol.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\uartprotocol.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -I.\User\qrencode -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.3\Device\Include -D__MICROLIB -D__UVISION_VERSION=539 -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\uartprotocol.crf User\UartProtocol.c]
                          THUMB

                          AREA ||i.UART_PROTOCOL_CALLBACK_SetTxPeriodRequest||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL_CALLBACK_SetTxPeriodRequest PROC
;;;1133   // 码表设置周期下发数据请求标志
;;;1134   void UART_PROTOCOL_CALLBACK_SetTxPeriodRequest(uint32 param)
000000  4a01              LDR      r2,|L1.8|
;;;1135   {
;;;1136   	uartProtocolCB.txPeriodRequest = (BOOL)param;
000002  f88206e4          STRB     r0,[r2,#0x6e4]
;;;1137   }
000006  4770              BX       lr
;;;1138   
                          ENDP

                  |L1.8|
                          DCD      uartProtocolCB

                          AREA ||i.UART_PROTOCOL_CALLBACK_UartBusError||, CODE, READONLY, ALIGN=1

                  UART_PROTOCOL_CALLBACK_UartBusError PROC
;;;1139   // 	UART总线超时错误处理
;;;1140   void UART_PROTOCOL_CALLBACK_UartBusError(uint32 param)
000000  4770              BX       lr
;;;1141   {
;;;1142   }
;;;1143   
                          ENDP


                          AREA ||i.UART_PROTOCOL_CheckSUM||, CODE, READONLY, ALIGN=1

                  UART_PROTOCOL_CheckSUM PROC
;;;507    // 对传入的命令帧进行校验，返回校验结果
;;;508    BOOL UART_PROTOCOL_CheckSUM(UART_PROTOCOL_RX_CMD_FRAME *pCmdFrame)
000000  b510              PUSH     {r4,lr}
;;;509    {
000002  4601              MOV      r1,r0
;;;510    	uint8 cc = 0;
000004  2200              MOVS     r2,#0
;;;511    	uint16 i = 0;
000006  2300              MOVS     r3,#0
;;;512    
;;;513    	if (NULL == pCmdFrame)
000008  b909              CBNZ     r1,|L3.14|
;;;514    	{
;;;515    		return FALSE;
00000a  2000              MOVS     r0,#0
                  |L3.12|
;;;516    	}
;;;517    
;;;518    	// 从命令头开始，到校验码之前的一个字节，依次进行异或运算
;;;519    	for (i = 0; i < pCmdFrame->length - 1; i++)
;;;520    	{
;;;521    		cc ^= pCmdFrame->buff[i];
;;;522    	}
;;;523    
;;;524    	cc = ~cc;
;;;525    
;;;526    	// 判断计算得到的校验码与命令帧中的校验码是否相同
;;;527    	if (pCmdFrame->buff[pCmdFrame->length - 1] != cc)
;;;528    	{
;;;529    		return FALSE;
;;;530    	}
;;;531    
;;;532    	return TRUE;
;;;533    }
00000c  bd10              POP      {r4,pc}
                  |L3.14|
00000e  2300              MOVS     r3,#0                 ;519
000010  e004              B        |L3.28|
                  |L3.18|
000012  1c88              ADDS     r0,r1,#2              ;521
000014  5cc0              LDRB     r0,[r0,r3]            ;521
000016  4042              EORS     r2,r2,r0              ;521
000018  1c58              ADDS     r0,r3,#1              ;519
00001a  b283              UXTH     r3,r0                 ;519
                  |L3.28|
00001c  f8b10098          LDRH     r0,[r1,#0x98]         ;519
000020  1e40              SUBS     r0,r0,#1              ;519
000022  4298              CMP      r0,r3                 ;519
000024  dcf5              BGT      |L3.18|
000026  43d0              MVNS     r0,r2                 ;524
000028  b2c2              UXTB     r2,r0                 ;524
00002a  f8b10098          LDRH     r0,[r1,#0x98]         ;527
00002e  1e40              SUBS     r0,r0,#1              ;527
000030  1c8c              ADDS     r4,r1,#2              ;527
000032  5c20              LDRB     r0,[r4,r0]            ;527
000034  4290              CMP      r0,r2                 ;527
000036  d001              BEQ      |L3.60|
000038  2000              MOVS     r0,#0                 ;529
00003a  e7e7              B        |L3.12|
                  |L3.60|
00003c  2001              MOVS     r0,#1                 ;532
00003e  e7e5              B        |L3.12|
;;;534    
                          ENDP


                          AREA ||i.UART_PROTOCOL_CmdFrameProcess||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL_CmdFrameProcess PROC
;;;622    // UART命令帧缓冲区处理
;;;623    void UART_PROTOCOL_CmdFrameProcess(UART_PROTOCOL_CB *pCB)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;624    {
000004  4605              MOV      r5,r0
;;;625    	UART_PROTOCOL_CMD cmd = UART_PROTOCOL_CMD_NULL;
000006  2700              MOVS     r7,#0
;;;626    	UART_PROTOCOL_RX_CMD_FRAME *pCmdFrame = NULL;
000008  2400              MOVS     r4,#0
;;;627    
;;;628    	// 我的变量
;;;629    	uint8 eraResual = 0;
00000a  2600              MOVS     r6,#0
;;;630    
;;;631    	// 参数合法性检验
;;;632    	if (NULL == pCB)
00000c  b90d              CBNZ     r5,|L4.18|
                  |L4.14|
;;;633    	{
;;;634    		return;
;;;635    	}
;;;636    
;;;637    	// 命令帧缓冲区为空，退出
;;;638    	if (pCB->rx.head == pCB->rx.end)
;;;639    	{
;;;640    		return;
;;;641    	}
;;;642    
;;;643    	// 获取当前要处理的命令帧指针
;;;644    	pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.head];
;;;645    
;;;646    	// 命令头非法，退出
;;;647    	if (UART_PROTOCOL_CMD_HEAD != pCmdFrame->buff[UART_PROTOCOL_CMD_HEAD_INDEX])
;;;648    	{
;;;649    		// 删除命令帧
;;;650    		pCB->rx.head++;
;;;651    		pCB->rx.head %= UART_PROTOCOL_RX_QUEUE_SIZE;
;;;652    		return;
;;;653    	}
;;;654    
;;;655    	// 命令头合法，则提取命令
;;;656    	cmd = (UART_PROTOCOL_CMD)pCmdFrame->buff[UART_PROTOCOL_CMD_CMD_INDEX];
;;;657    	switch (dut_info.ID)
;;;658    	{
;;;659    	case DUT_TYPE_NULL:
;;;660    		break;
;;;661    
;;;662    	case DUT_TYPE_CM: // 串口通用升级
;;;663    	
;;;664    		switch (cmd)
;;;665    		{
;;;666    		case UART_PROTOCOL_CMD_NULL: // = 0				// 空命令
;;;667    			break;
;;;668    
;;;669    		case UART_CMD_UP_PROJECT_APPLY: // 0x01			//DUT工程模式申请,bc280ul
;;;670    			// 发送允许进入工程模式
;;;671    			if (dut_info.bootUpFlag)
;;;672    			{
;;;673    				STATE_SwitchStep(STEP_CM_UART_BC_UPGRADE_BOOT_ENTRY);
;;;674    			}
;;;675    			else if (!dut_info.dutPowerOnAllow)
;;;676    			{
;;;677    				STATE_SwitchStep(STEP_CM_UART_BC_UPGRADE_UP_ALLOW);
;;;678    			}
;;;679    			else
;;;680    			{
;;;681    				/*不操作，仪表自动跳过工程模式*/
;;;682    			}
;;;683    			break;
;;;684    
;;;685    		case UART_CMD_UP_PROJECT_READY: // 0x03			//DUT工程模式准备就绪
;;;686    			// 选择升级
;;;687    //			if (dut_info.bootUpFlag)
;;;688    //			{
;;;689    //				STATE_SwitchStep(STEP_CM_UART_BC_UPGRADE_BOOT_ENTRY);
;;;690    //			}
;;;691                if (dut_info.appUpFlag)
;;;692    			{
;;;693    				STATE_SwitchStep(STEP_CM_UART_BC_UPGRADE_SEND_APP_EAR);
;;;694    			}            
;;;695    			else if (dut_info.uiUpFlag)
;;;696    			{
;;;697    				STATE_SwitchStep(STEP_CM_UART_BC_UPGRADE_SEND_UI_EAR);
;;;698    			}
;;;699    			else if (dut_info.configUpFlag)
;;;700    			{
;;;701    				STATE_SwitchStep(STEP_UART_SET_CONFIG_ENTRY);
;;;702    			}  
;;;703    			break;
;;;704    
;;;705    		case UART_CMD_DUT_UI_DATA_ERASE_ACK: // 0x13		//DUT_UI擦写成功
;;;706    			// 提取DUT_UI擦除结果
;;;707    			eraResual = pCmdFrame->buff[UART_PROTOCOL_CMD_DATA1_INDEX];
;;;708    
;;;709    			// 擦除失败
;;;710    			if (0 == eraResual)
;;;711    			{
;;;712    				// 擦除失败再擦除一次
;;;713    				STATE_SwitchStep(STEP_CM_UART_BC_UPGRADE_SEND_UI_EAR);
;;;714    				break;
;;;715    			}
;;;716    			// 擦除成功
;;;717    			dut_info.currentUiSize = 0;
;;;718    			STATE_SwitchStep(STEP_CM_UART_BC_UPGRADE_SEND_UI_PACKET);
;;;719    			break;
;;;720    
;;;721    		case UART_CMD_DUT_UI_DATA_WRITE_RES: // 0x15			//DUT_UI写入结果
;;;722    			eraResual = pCmdFrame->buff[UART_PROTOCOL_CMD_DATA1_INDEX];
;;;723    
;;;724    			if (0 == eraResual) // 如果仪表写入失败就退出
;;;725    			{
;;;726    				dut_info.currentUiSize--;
;;;727    			}
;;;728    
;;;729    			if (dut_info.currentUiSize < (dut_info.uiSize + 1))
;;;730    			{
;;;731    				STATE_SwitchStep(STEP_CM_UART_BC_UPGRADE_SEND_UI_PACKET);
;;;732    			}
;;;733    			else
;;;734    			{
;;;735    				STATE_SwitchStep(STEP_CM_UART_BC_UPGRADE_UI_UP_SUCCESS);
;;;736    			}
;;;737    			break;
;;;738    
;;;739    		case UART_CMD_DUT_APP_ERASE_FLASH: // 0x24		//DUT_APP擦写
;;;740    			break;
;;;741    
;;;742    		case UART_CMD_DUT_APP_ERASE_RESULT: // 0x25			//DUT_APP擦写结果查询
;;;743    			eraResual = pCmdFrame->buff[UART_PROTOCOL_CMD_DATA1_INDEX];
;;;744    			// 擦除失败
;;;745    			if (0 == eraResual)
;;;746    			{
;;;747    				// 擦除失败再擦除一次
;;;748    				STATE_SwitchStep(STEP_CM_UART_BC_UPGRADE_SEND_APP_EAR);
;;;749    				break;
;;;750    			}
;;;751    
;;;752    			// 发送第一帧数据
;;;753    			dut_info.currentAppSize = 0;
;;;754    			STATE_SwitchStep(STEP_CM_UART_BC_UPGRADE_SEND_APP_PACKET);
;;;755    			break;
;;;756    
;;;757    		case UART_CMD_DUT_APP_WRITE_FLASH: // 0x26		//DUT_APP写入
;;;758    			break;
;;;759    
;;;760    		case UART_CMD_DUT_APP_WRITE_FLASH_RES: // 0x27		//DUT_APP写入结果
;;;761    			eraResual = pCmdFrame->buff[UART_PROTOCOL_CMD_DATA1_INDEX];
;;;762    
;;;763    			if (0 == eraResual) // 如果仪表写入失败就退出
;;;764    			{
;;;765    				dut_info.currentAppSize--;
;;;766    			}
;;;767    			if (dut_info.currentAppSize < dut_info.appSize)
;;;768    			{
;;;769    				STATE_SwitchStep(STEP_CM_UART_BC_UPGRADE_SEND_APP_PACKET);
;;;770    			}
;;;771    			else
;;;772    			{
;;;773    				STATE_SwitchStep(STEP_CM_UART_BC_UPGRADE_APP_UP_SUCCESS);
;;;774    			}
;;;775    			break;
;;;776    
;;;777    		case UART_CMD_UP_UPDATA_FINISH_RESULT: // 0x2B  			//DUT写入结果确定
;;;778    			STATE_SwitchStep(STEP_CM_UART_BC_UPGRADE_ITEM_FINISH);
;;;779    			break;
;;;780    
;;;781    		default:
;;;782    			break;
;;;783    		}
;;;784    		break;
;;;785    		
;;;786    	case DUT_TYPE_HUAXIN: // 华芯微特串口升级
;;;787    		// 执行命令帧
;;;788    		switch (cmd)
;;;789    		{
;;;790    		// 收到仪表发送的ECO请求
;;;791    		case UART_CMD_UP_PROJECT_ALLOW:	   // 02
;;;792    			if (!dut_info.dutPowerOnAllow) // 允许开机就不应答
;;;793    			{
;;;794    				STATE_SwitchStep(STEP_HUAXIN_UART_BC_UPGRADE_UP_ALLOW);
;;;795    			}
;;;796    			break;
;;;797    
;;;798    		// 仪表回应准备就绪
;;;799    		case UART_CMD_UP_PROJECT_READY: // 03
;;;800    
;;;801    			/*判断还有是否要升级的标志位*/
;;;802    			if (dut_info.appUpFlag)
;;;803    			{
;;;804    				// 向仪表发送擦除app区命令
;;;805    				STATE_SwitchStep(STEP_HUAXIN_UART_BC_UPGRADE_SEND_APP_EAR);
;;;806    			}
;;;807    			else if (dut_info.uiUpFlag)
;;;808    			{
;;;809    				// 向仪表发送擦除ui区命令
;;;810    				STATE_SwitchStep(STEP_HUAXIN_UART_BC_UPGRADE_SEND_UI_EAR);
;;;811    			}
;;;812    			else if (dut_info.configUpFlag)
;;;813    			{
;;;814    				STATE_SwitchStep(STEP_UART_SET_CONFIG_ENTRY);
;;;815    			}
;;;816    			break;
;;;817    
;;;818    		case UART_CMD_UP_APP_EAR: // 05
;;;819    			// 提取仪表擦除结果
;;;820    			eraResual = pCmdFrame->buff[UART_PROTOCOL_CMD_DATA1_INDEX];
;;;821    
;;;822    			// 擦除失败
;;;823    			if (0 == eraResual)
;;;824    			{
;;;825    				// 擦除失败再擦除一次
;;;826    				STATE_SwitchStep(STEP_HUAXIN_UART_BC_UPGRADE_SEND_APP_EAR);
;;;827    				break;
;;;828    			}
;;;829    			// 擦除成功
;;;830    			STATE_SwitchStep(STEP_HUAXIN_UART_BC_UPGRADE_SEND_FIRST_APP_PACKET);
;;;831    			break;
;;;832    
;;;833    		case UART_CMD_UP_APP_UP: // 06,app写入
;;;834    			eraResual = pCmdFrame->buff[UART_PROTOCOL_CMD_DATA1_INDEX];
;;;835    			if (0 == eraResual) // 如果仪表写入失败
;;;836    			{
;;;837    				dut_info.currentAppSize--;
;;;838    			}
;;;839    
;;;840    			if (dut_info.currentAppSize < dut_info.appSize)
;;;841    			{
;;;842    				STATE_SwitchStep(STEP_HUAXIN_UART_BC_UPGRADE_SEND_APP_PACKET);
;;;843    			}
;;;844    			else
;;;845    			{
;;;846    				STATE_SwitchStep(STEP_HUAXIN_UART_BC_UPGRADE_APP_UP_SUCCESS);
;;;847    			}
;;;848    
;;;849    			break;
;;;850    
;;;851    		case UART_CMD_UP_APP_UP_OVER: // 07，升级项结束，开始升级下一项
;;;852    			STATE_SwitchStep(STEP_HUAXIN_UART_BC_UPGRADE_ITEM_FINISH);
;;;853    
;;;854    			break;
;;;855    
;;;856    		case UART_CMD_DUT_UI_DATA_ERASE: // 0x12,ui擦除
;;;857    
;;;858    			break;
;;;859    
;;;860    		case UART_CMD_DUT_UI_DATA_ERASE_ACK: // 0x13,ui擦除应答
;;;861    			// 提取DUT_UI擦除结果
;;;862    			eraResual = pCmdFrame->buff[UART_PROTOCOL_CMD_DATA1_INDEX];
;;;863    
;;;864    			// 擦除失败
;;;865    			if (0 == eraResual)
;;;866    			{
;;;867    				// 擦除失败再擦除一次
;;;868    				STATE_SwitchStep(STEP_HUAXIN_UART_BC_UPGRADE_SEND_UI_EAR);
;;;869    				break;
;;;870    			}
;;;871    			// 擦除成功
;;;872    			dut_info.currentUiSize = 0;
;;;873    			STATE_SwitchStep(STEP_HUAXIN_UART_BC_UPGRADE_SEND_FIRST_UI_PACKET);
;;;874    			break;
;;;875    		case UART_CMD_DUT_UI_DATA_WRITE: // 0x14,ui写入
;;;876    
;;;877    			break;
;;;878    		case UART_CMD_DUT_UI_DATA_WRITE_RES: // 0x15,ui写入结果
;;;879    
;;;880    			eraResual = pCmdFrame->buff[UART_PROTOCOL_CMD_DATA1_INDEX];
;;;881    
;;;882    			if (0 == eraResual) // 如果仪表写入失败就退出
;;;883    			{
;;;884    				dut_info.currentUiSize--;
;;;885    			}
;;;886    
;;;887    			if (dut_info.currentUiSize < (dut_info.uiSize + 1))
;;;888    			{
;;;889    				STATE_SwitchStep(STEP_HUAXIN_UART_BC_UPGRADE_SEND_UI_PACKET);
;;;890    			}
;;;891    			else
;;;892    			{
;;;893    				STATE_SwitchStep(STEP_HUAXIN_UART_BC_UPGRADE_UI_UP_SUCCESS);
;;;894    			}
;;;895    			break;
;;;896    		default:
;;;897    			break;
;;;898    		}
;;;899    
;;;900    		break;
;;;901    
;;;902    	// 串口段码屏升级
;;;903    	case DUT_TYPE_SEG:
;;;904    		switch (cmd)
;;;905    		{
;;;906    		// 收到仪表发送的ECO请求
;;;907    		case UART_CMD_UP_PROJECT_ALLOW: // 02
;;;908    			// 发送允许进入工程模式
;;;909    			STATE_SwitchStep(STEP_CM_UART_SEG_UPGRADE_UP_ALLOW);
;;;910    			break;
;;;911    		case UART_CMD_UP_PROJECT_READY: // 03
;;;912    			// 发送app擦除指令
;;;913    			if (dut_info.appUpFlag)
;;;914    			{
;;;915    				STATE_SwitchStep(STEP_CM_UART_SEG_UPGRADE_SEND_APP_EAR);
;;;916    			}
;;;917    			else if (dut_info.configUpFlag)
;;;918    			{
;;;919    				STATE_SwitchStep(STEP_CM_UART_SEG_UPGRADE_ITEM_FINISH);
;;;920    			}
;;;921    			break;
;;;922    
;;;923    		// dut擦除结果查询
;;;924    		case UART_CMD_UP_APP_EAR:
;;;925    			// 提取仪表擦除结果
;;;926    			eraResual = pCmdFrame->buff[UART_PROTOCOL_CMD_DATA1_INDEX];
;;;927    
;;;928    			// 擦除失败
;;;929    			if (0 == eraResual)
;;;930    			{
;;;931    				// 擦除失败再擦除一次
;;;932    				STATE_SwitchStep(STEP_CM_UART_SEG_UPGRADE_SEND_APP_EAR);
;;;933    				break;
;;;934    			}
;;;935    			// 擦除成功
;;;936    			// 发送第一包数据
;;;937    			STATE_SwitchStep(STEP_CM_UART_SEG_UPGRADE_SEND_FIRST_APP_PACKET);
;;;938    
;;;939    			break;
;;;940    		case UART_CMD_UP_APP_UP: // 06,app数据写入
;;;941    			eraResual = pCmdFrame->buff[UART_PROTOCOL_CMD_DATA1_INDEX];
;;;942    
;;;943    			if (0 == eraResual) // 如果仪表写入失败
;;;944    			{
;;;945    				break;
;;;946    			}
;;;947    			else
;;;948    			{
;;;949    				if (dut_info.currentAppSize < dut_info.appSize)
;;;950    				{
;;;951    					STATE_SwitchStep(STEP_CM_UART_SEG_UPGRADE_SEND_APP_PACKET); // 发送app数据包
;;;952    				}
;;;953    				else
;;;954    				{
;;;955    					STATE_SwitchStep(STEP_CM_UART_SEG_UPGRADE_APP_UP_SUCCESS);
;;;956    				}
;;;957    			}
;;;958    			break;
;;;959    		case UART_CMD_UP_APP_UP_OVER: // 07，app升级完毕
;;;960    			STATE_SwitchStep(STEP_CM_UART_SEG_UPGRADE_ITEM_FINISH);
;;;961    			break;
;;;962    		default:
;;;963    			break;
;;;964    		}
;;;965    		break;
;;;966    		
;;;967    	// 开阳升级流程
;;;968    	case DUT_TYPE_KAIYANG:
;;;969    		// 执行命令帧
;;;970    		switch (cmd)
;;;971    		{
;;;972    		// 收到仪表发送的ECO请求
;;;973    		case UART_CMD_UP_PROJECT_APPLY: // 01
;;;974    			if (!dut_info.dutPowerOnAllow)
;;;975    			{
;;;976    				if (dut_info.uiUpFlag || dut_info.appUpFlag)
;;;977    				{
;;;978    					STATE_SwitchStep(STEP_KAIYANG_UART_UPGRADE_UP_ALLOW);
;;;979    				}
;;;980    				else if (dut_info.configUpFlag)
;;;981    				{
;;;982    					STATE_SwitchStep(STEP_UART_SET_CONFIG_ENTRY);
;;;983    				}
;;;984    				dut_info.dutPowerOnAllow = TRUE; // 不在接收eco请求
;;;985    			}
;;;986    			break;
;;;987    
;;;988    		// 仪表回应准备就绪
;;;989    		case UART_CMD_UP_PROJECT_ALLOW: // 02
;;;990    			if (dut_info.appUpFlag)
;;;991    			{
;;;992    				dut_info.currentAppSize = 0;
;;;993    				STATE_SwitchStep(STEP_KAIYANG_UART_UPGRADE_SEND_APP_WRITE);
;;;994    				TIMER_AddTask(TIMER_ID_RECONNECTION, 
;;;995    							1000, 
;;;996    							STATE_SwitchStep, 
;;;997    							STEP_KAIYANG_UART_UPGRADE_SEND_APP_AGAIN, 
;;;998    							TIMER_LOOP_FOREVER, 
;;;999    							ACTION_MODE_ADD_TO_QUEUE);
;;;1000   			}
;;;1001   			else if (dut_info.uiUpFlag)
;;;1002   			{
;;;1003   				dut_info.currentUiSize = 0;
;;;1004   				STATE_SwitchStep(STEP_KAIYANG_UART_UPGRADE_SEND_UI_WRITE);
;;;1005   				TIMER_AddTask(TIMER_ID_RECONNECTION, 
;;;1006   							1000, 
;;;1007   							STATE_SwitchStep, 
;;;1008   							STEP_KAIYANG_UART_UPGRADE_SEND_UI_AGAIN, 
;;;1009   							TIMER_LOOP_FOREVER, 
;;;1010   							ACTION_MODE_ADD_TO_QUEUE);
;;;1011   			}
;;;1012   			break;
;;;1013   
;;;1014   		case UART_CMD_UP_PROJECT_READY: // 03
;;;1015   			TIMER_ResetTimer(TIMER_ID_DUT_TIMEOUT);	// 喂狗
;;;1016   			if (dut_info.appUpFlag)
;;;1017   			{
;;;1018   				if (dut_info.currentAppSize < dut_info.appSize - 1)
;;;1019   				{
;;;1020   					if (pCmdFrame->buff[UART_PROTOCOL_CMD_DATA1_INDEX])
;;;1021   					{
;;;1022   						dut_info.currentAppSize++;
;;;1023   					}
;;;1024   					STATE_SwitchStep(STEP_KAIYANG_UART_UPGRADE_SEND_APP_WRITE);
;;;1025   				}
;;;1026   				else
;;;1027   				{
;;;1028   					STATE_SwitchStep(STEP_KAIYANG_UART_UPGRADE_APP_UP_SUCCESS);
;;;1029   				}
;;;1030   			}
;;;1031   			else if (dut_info.uiUpFlag)
;;;1032   			{
;;;1033   				if (dut_info.currentUiSize < dut_info.uiSize - 1)
;;;1034   				{
;;;1035   					if (pCmdFrame->buff[UART_PROTOCOL_CMD_DATA1_INDEX])
;;;1036   					{
;;;1037   						dut_info.currentUiSize++;
;;;1038   					}
;;;1039   					STATE_SwitchStep(STEP_KAIYANG_UART_UPGRADE_SEND_UI_WRITE);
;;;1040   				}
;;;1041   				else
;;;1042   				{
;;;1043   					STATE_SwitchStep(STEP_KAIYANG_UART_UPGRADE_APP_UP_SUCCESS);
;;;1044   				}
;;;1045   			}
;;;1046   
;;;1047   			break;
;;;1048   		case UART_ECO_CMD_ECO_JUMP_APP: // 04
;;;1049   			if (pCmdFrame->buff[UART_PROTOCOL_CMD_DATA1_INDEX])
;;;1050   			{
;;;1051   				// 升级成功
;;;1052   				if (dut_info.appUpFlag)
;;;1053   				{
;;;1054   					dut_info.appUpSuccesss = TRUE;
;;;1055   					dut_info.appUpFlag = FALSE;
;;;1056   				}
;;;1057   				else if (dut_info.uiUpFlag)
;;;1058   				{
;;;1059   					dut_info.uiUpSuccesss = TRUE;
;;;1060   					dut_info.uiUpFlag = FALSE;
;;;1061   				}
;;;1062   			}
;;;1063   			else // 升级失败
;;;1064   			{
;;;1065   				if (dut_info.appUpFlag)
;;;1066   				{
;;;1067   					dut_info.appUpFaile = TRUE;
;;;1068   					dut_info.appUpFlag = FALSE;
;;;1069   				}
;;;1070   				else if (dut_info.uiUpFlag)
;;;1071   				{
;;;1072   					dut_info.appUpFaile = TRUE;
;;;1073   					dut_info.uiUpFlag = FALSE;
;;;1074   				}
;;;1075   			}
;;;1076   			TIMER_KillTask(TIMER_ID_DUT_TIMEOUT);
;;;1077   			STATE_SwitchStep(STEP_KAIYANG_UART_UPGRADE_ITEM_FINISH);
;;;1078   			break;
;;;1079   
;;;1080   		default:
;;;1081   			break;
;;;1082   		}
;;;1083   		break;
;;;1084   		
;;;1085   	default:
;;;1086   		break;
;;;1087   	}
;;;1088   
;;;1089   	// 删除命令帧
;;;1090   	pCB->rx.head++;
;;;1091   	pCB->rx.head %= UART_PROTOCOL_RX_QUEUE_SIZE;
;;;1092   }
00000e  e8bd81fc          POP      {r2-r8,pc}
                  |L4.18|
000012  f8b513d0          LDRH     r1,[r5,#0x3d0]        ;638
000016  f8b503d2          LDRH     r0,[r5,#0x3d2]        ;638
00001a  4281              CMP      r1,r0                 ;638
00001c  d100              BNE      |L4.32|
00001e  e7f6              B        |L4.14|
                  |L4.32|
000020  f8b503d0          LDRH     r0,[r5,#0x3d0]        ;644
000024  214d              MOVS     r1,#0x4d              ;644
000026  4348              MULS     r0,r1,r0              ;644
000028  f10501ce          ADD      r1,r5,#0xce           ;644
00002c  eb010440          ADD      r4,r1,r0,LSL #1       ;644
000030  78a0              LDRB     r0,[r4,#2]            ;647
000032  2855              CMP      r0,#0x55              ;647
000034  d00e              BEQ      |L4.84|
000036  f8b503d0          LDRH     r0,[r5,#0x3d0]        ;650
00003a  1c40              ADDS     r0,r0,#1              ;650
00003c  f8a503d0          STRH     r0,[r5,#0x3d0]        ;650
000040  f8b503d0          LDRH     r0,[r5,#0x3d0]        ;651
000044  2105              MOVS     r1,#5                 ;651
000046  fb90f2f1          SDIV     r2,r0,r1              ;651
00004a  fb010012          MLS      r0,r1,r2,r0           ;651
00004e  f8a503d0          STRH     r0,[r5,#0x3d0]        ;651
000052  e7dc              B        |L4.14|
                  |L4.84|
000054  78e7              LDRB     r7,[r4,#3]            ;656
000056  48f8              LDR      r0,|L4.1080|
000058  7d80              LDRB     r0,[r0,#0x16]         ;657  ; dut_info
00005a  2806              CMP      r0,#6                 ;657
00005c  d272              BCS      |L4.324|
00005e  e8dff000          TBB      [pc,r0]               ;657
000062  0371              DCB      0x03,0x71
000064  0490f4f3          DCB      0x04,0x90,0xf4,0xf3
000068  e1fe              B        |L4.1128|
00006a  2f24              CMP      r7,#0x24              ;664
00006c  d05c              BEQ      |L4.296|
00006e  dc0b              BGT      |L4.136|
000070  2f03              CMP      r7,#3                 ;664
000072  d022              BEQ      |L4.186|
000074  dc03              BGT      |L4.126|
000076  b187              CBZ      r7,|L4.154|
000078  2f01              CMP      r7,#1                 ;664
00007a  d17f              BNE      |L4.380|
00007c  e00e              B        |L4.156|
                  |L4.126|
00007e  2f13              CMP      r7,#0x13              ;664
000080  d030              BEQ      |L4.228|
000082  2f15              CMP      r7,#0x15              ;664
000084  d17a              BNE      |L4.380|
000086  e03a              B        |L4.254|
                  |L4.136|
000088  2f25              CMP      r7,#0x25              ;664
00008a  d04e              BEQ      |L4.298|
00008c  2f26              CMP      r7,#0x26              ;664
00008e  d05a              BEQ      |L4.326|
000090  2f27              CMP      r7,#0x27              ;664
000092  d059              BEQ      |L4.328|
000094  2f2b              CMP      r7,#0x2b              ;664
000096  d171              BNE      |L4.380|
000098  e06c              B        |L4.372|
                  |L4.154|
00009a  e070              B        |L4.382|
                  |L4.156|
00009c  48e6              LDR      r0,|L4.1080|
00009e  7e80              LDRB     r0,[r0,#0x1a]         ;671  ; dut_info
0000a0  b118              CBZ      r0,|L4.170|
0000a2  20a1              MOVS     r0,#0xa1              ;673
0000a4  f7fffffe          BL       STATE_SwitchStep
0000a8  e006              B        |L4.184|
                  |L4.170|
0000aa  48e3              LDR      r0,|L4.1080|
0000ac  f890003c          LDRB     r0,[r0,#0x3c]         ;675  ; dut_info
0000b0  b910              CBNZ     r0,|L4.184|
0000b2  2058              MOVS     r0,#0x58              ;677
0000b4  f7fffffe          BL       STATE_SwitchStep
                  |L4.184|
0000b8  e061              B        |L4.382|
                  |L4.186|
0000ba  48df              LDR      r0,|L4.1080|
0000bc  7ec0              LDRB     r0,[r0,#0x1b]         ;691  ; dut_info
0000be  b118              CBZ      r0,|L4.200|
0000c0  2059              MOVS     r0,#0x59              ;693
0000c2  f7fffffe          BL       STATE_SwitchStep
0000c6  e00c              B        |L4.226|
                  |L4.200|
0000c8  48db              LDR      r0,|L4.1080|
0000ca  7f40              LDRB     r0,[r0,#0x1d]         ;695  ; dut_info
0000cc  b118              CBZ      r0,|L4.214|
0000ce  205d              MOVS     r0,#0x5d              ;697
0000d0  f7fffffe          BL       STATE_SwitchStep
0000d4  e005              B        |L4.226|
                  |L4.214|
0000d6  48d8              LDR      r0,|L4.1080|
0000d8  7f00              LDRB     r0,[r0,#0x1c]         ;699  ; dut_info
0000da  b110              CBZ      r0,|L4.226|
0000dc  209a              MOVS     r0,#0x9a              ;701
0000de  f7fffffe          BL       STATE_SwitchStep
                  |L4.226|
0000e2  e04c              B        |L4.382|
                  |L4.228|
0000e4  7966              LDRB     r6,[r4,#5]            ;707
0000e6  b91e              CBNZ     r6,|L4.240|
0000e8  205d              MOVS     r0,#0x5d              ;713
0000ea  f7fffffe          BL       STATE_SwitchStep
0000ee  e046              B        |L4.382|
                  |L4.240|
0000f0  2000              MOVS     r0,#0                 ;717
0000f2  49d1              LDR      r1,|L4.1080|
0000f4  6348              STR      r0,[r1,#0x34]         ;717  ; dut_info
0000f6  205f              MOVS     r0,#0x5f              ;718
0000f8  f7fffffe          BL       STATE_SwitchStep
0000fc  e03f              B        |L4.382|
                  |L4.254|
0000fe  7966              LDRB     r6,[r4,#5]            ;722
000100  b926              CBNZ     r6,|L4.268|
000102  48cd              LDR      r0,|L4.1080|
000104  6b40              LDR      r0,[r0,#0x34]         ;726  ; dut_info
000106  1e40              SUBS     r0,r0,#1              ;726
000108  49cb              LDR      r1,|L4.1080|
00010a  6348              STR      r0,[r1,#0x34]         ;726  ; dut_info
                  |L4.268|
00010c  48ca              LDR      r0,|L4.1080|
00010e  6b41              LDR      r1,[r0,#0x34]         ;729  ; dut_info
000110  6a80              LDR      r0,[r0,#0x28]         ;729  ; dut_info
000112  1c40              ADDS     r0,r0,#1              ;729
000114  4281              CMP      r1,r0                 ;729
000116  d203              BCS      |L4.288|
000118  205f              MOVS     r0,#0x5f              ;731
00011a  f7fffffe          BL       STATE_SwitchStep
00011e  e002              B        |L4.294|
                  |L4.288|
000120  2060              MOVS     r0,#0x60              ;735
000122  f7fffffe          BL       STATE_SwitchStep
                  |L4.294|
000126  e02a              B        |L4.382|
                  |L4.296|
000128  e029              B        |L4.382|
                  |L4.298|
00012a  7966              LDRB     r6,[r4,#5]            ;743
00012c  b91e              CBNZ     r6,|L4.310|
00012e  2059              MOVS     r0,#0x59              ;748
000130  f7fffffe          BL       STATE_SwitchStep
000134  e023              B        |L4.382|
                  |L4.310|
000136  2000              MOVS     r0,#0                 ;753
000138  49bf              LDR      r1,|L4.1080|
00013a  6308              STR      r0,[r1,#0x30]         ;753  ; dut_info
00013c  205b              MOVS     r0,#0x5b              ;754
00013e  f7fffffe          BL       STATE_SwitchStep
000142  e01c              B        |L4.382|
                  |L4.324|
000144  e18f              B        |L4.1126|
                  |L4.326|
000146  e01a              B        |L4.382|
                  |L4.328|
000148  7966              LDRB     r6,[r4,#5]            ;761
00014a  b926              CBNZ     r6,|L4.342|
00014c  48ba              LDR      r0,|L4.1080|
00014e  6b00              LDR      r0,[r0,#0x30]         ;765  ; dut_info
000150  1e40              SUBS     r0,r0,#1              ;765
000152  49b9              LDR      r1,|L4.1080|
000154  6308              STR      r0,[r1,#0x30]         ;765  ; dut_info
                  |L4.342|
000156  48b8              LDR      r0,|L4.1080|
000158  6b00              LDR      r0,[r0,#0x30]         ;767  ; dut_info
00015a  49b7              LDR      r1,|L4.1080|
00015c  6a49              LDR      r1,[r1,#0x24]         ;767  ; dut_info
00015e  4288              CMP      r0,r1                 ;767
000160  d204              BCS      |L4.364|
000162  205b              MOVS     r0,#0x5b              ;769
000164  f7fffffe          BL       STATE_SwitchStep
000168  e003              B        |L4.370|
00016a  e007              B        |L4.380|
                  |L4.364|
00016c  205c              MOVS     r0,#0x5c              ;773
00016e  f7fffffe          BL       STATE_SwitchStep
                  |L4.370|
000172  e004              B        |L4.382|
                  |L4.372|
000174  2064              MOVS     r0,#0x64              ;778
000176  f7fffffe          BL       STATE_SwitchStep
00017a  e000              B        |L4.382|
                  |L4.380|
00017c  bf00              NOP                            ;782
                  |L4.382|
00017e  bf00              NOP                            ;667
000180  e172              B        |L4.1128|
000182  2f07              CMP      r7,#7                 ;788
000184  d04e              BEQ      |L4.548|
000186  dc08              BGT      |L4.410|
000188  2f02              CMP      r7,#2                 ;788
00018a  d00f              BEQ      |L4.428|
00018c  2f03              CMP      r7,#3                 ;788
00018e  d015              BEQ      |L4.444|
000190  2f05              CMP      r7,#5                 ;788
000192  d028              BEQ      |L4.486|
000194  2f06              CMP      r7,#6                 ;788
000196  d170              BNE      |L4.634|
000198  e02f              B        |L4.506|
                  |L4.410|
00019a  2f12              CMP      r7,#0x12              ;788
00019c  d046              BEQ      |L4.556|
00019e  2f13              CMP      r7,#0x13              ;788
0001a0  d045              BEQ      |L4.558|
0001a2  2f14              CMP      r7,#0x14              ;788
0001a4  d052              BEQ      |L4.588|
0001a6  2f15              CMP      r7,#0x15              ;788
0001a8  d167              BNE      |L4.634|
0001aa  e050              B        |L4.590|
                  |L4.428|
0001ac  48a2              LDR      r0,|L4.1080|
0001ae  f890003c          LDRB     r0,[r0,#0x3c]         ;792  ; dut_info
0001b2  b910              CBNZ     r0,|L4.442|
0001b4  2067              MOVS     r0,#0x67              ;794
0001b6  f7fffffe          BL       STATE_SwitchStep
                  |L4.442|
0001ba  e05f              B        |L4.636|
                  |L4.444|
0001bc  489e              LDR      r0,|L4.1080|
0001be  7ec0              LDRB     r0,[r0,#0x1b]         ;802  ; dut_info
0001c0  b118              CBZ      r0,|L4.458|
0001c2  2068              MOVS     r0,#0x68              ;805
0001c4  f7fffffe          BL       STATE_SwitchStep
0001c8  e00c              B        |L4.484|
                  |L4.458|
0001ca  489b              LDR      r0,|L4.1080|
0001cc  7f40              LDRB     r0,[r0,#0x1d]         ;807  ; dut_info
0001ce  b118              CBZ      r0,|L4.472|
0001d0  206c              MOVS     r0,#0x6c              ;810
0001d2  f7fffffe          BL       STATE_SwitchStep
0001d6  e005              B        |L4.484|
                  |L4.472|
0001d8  4897              LDR      r0,|L4.1080|
0001da  7f00              LDRB     r0,[r0,#0x1c]         ;812  ; dut_info
0001dc  b110              CBZ      r0,|L4.484|
0001de  209a              MOVS     r0,#0x9a              ;814
0001e0  f7fffffe          BL       STATE_SwitchStep
                  |L4.484|
0001e4  e04a              B        |L4.636|
                  |L4.486|
0001e6  7966              LDRB     r6,[r4,#5]            ;820
0001e8  b91e              CBNZ     r6,|L4.498|
0001ea  2068              MOVS     r0,#0x68              ;826
0001ec  f7fffffe          BL       STATE_SwitchStep
0001f0  e044              B        |L4.636|
                  |L4.498|
0001f2  2069              MOVS     r0,#0x69              ;830
0001f4  f7fffffe          BL       STATE_SwitchStep
0001f8  e040              B        |L4.636|
                  |L4.506|
0001fa  7966              LDRB     r6,[r4,#5]            ;834
0001fc  b926              CBNZ     r6,|L4.520|
0001fe  488e              LDR      r0,|L4.1080|
000200  6b00              LDR      r0,[r0,#0x30]         ;837  ; dut_info
000202  1e40              SUBS     r0,r0,#1              ;837
000204  498c              LDR      r1,|L4.1080|
000206  6308              STR      r0,[r1,#0x30]         ;837  ; dut_info
                  |L4.520|
000208  488b              LDR      r0,|L4.1080|
00020a  6b00              LDR      r0,[r0,#0x30]         ;840  ; dut_info
00020c  498a              LDR      r1,|L4.1080|
00020e  6a49              LDR      r1,[r1,#0x24]         ;840  ; dut_info
000210  4288              CMP      r0,r1                 ;840
000212  d203              BCS      |L4.540|
000214  206a              MOVS     r0,#0x6a              ;842
000216  f7fffffe          BL       STATE_SwitchStep
00021a  e002              B        |L4.546|
                  |L4.540|
00021c  206b              MOVS     r0,#0x6b              ;846
00021e  f7fffffe          BL       STATE_SwitchStep
                  |L4.546|
000222  e02b              B        |L4.636|
                  |L4.548|
000224  2070              MOVS     r0,#0x70              ;852
000226  f7fffffe          BL       STATE_SwitchStep
00022a  e027              B        |L4.636|
                  |L4.556|
00022c  e026              B        |L4.636|
                  |L4.558|
00022e  7966              LDRB     r6,[r4,#5]            ;862
000230  b91e              CBNZ     r6,|L4.570|
000232  206c              MOVS     r0,#0x6c              ;868
000234  f7fffffe          BL       STATE_SwitchStep
000238  e020              B        |L4.636|
                  |L4.570|
00023a  2000              MOVS     r0,#0                 ;872
00023c  497e              LDR      r1,|L4.1080|
00023e  6348              STR      r0,[r1,#0x34]         ;872  ; dut_info
000240  206d              MOVS     r0,#0x6d              ;873
000242  f7fffffe          BL       STATE_SwitchStep
000246  e019              B        |L4.636|
000248  e056              B        |L4.760|
00024a  e019              B        |L4.640|
                  |L4.588|
00024c  e016              B        |L4.636|
                  |L4.590|
00024e  7966              LDRB     r6,[r4,#5]            ;880
000250  b926              CBNZ     r6,|L4.604|
000252  4879              LDR      r0,|L4.1080|
000254  6b40              LDR      r0,[r0,#0x34]         ;884  ; dut_info
000256  1e40              SUBS     r0,r0,#1              ;884
000258  4977              LDR      r1,|L4.1080|
00025a  6348              STR      r0,[r1,#0x34]         ;884  ; dut_info
                  |L4.604|
00025c  4876              LDR      r0,|L4.1080|
00025e  6b41              LDR      r1,[r0,#0x34]         ;887  ; dut_info
000260  6a80              LDR      r0,[r0,#0x28]         ;887  ; dut_info
000262  1c40              ADDS     r0,r0,#1              ;887
000264  4281              CMP      r1,r0                 ;887
000266  d203              BCS      |L4.624|
000268  206e              MOVS     r0,#0x6e              ;889
00026a  f7fffffe          BL       STATE_SwitchStep
00026e  e002              B        |L4.630|
                  |L4.624|
000270  206f              MOVS     r0,#0x6f              ;893
000272  f7fffffe          BL       STATE_SwitchStep
                  |L4.630|
000276  e001              B        |L4.636|
000278  e7ff              B        |L4.634|
                  |L4.634|
00027a  bf00              NOP                            ;897
                  |L4.636|
00027c  bf00              NOP                            ;796
00027e  e0f3              B        |L4.1128|
                  |L4.640|
000280  1eb8              SUBS     r0,r7,#2              ;904
000282  2806              CMP      r0,#6                 ;904
000284  d235              BCS      |L4.754|
000286  e8dff000          TBB      [pc,r0]               ;904
00028a  0307              DCB      0x03,0x07
00028c  34151f30          DCB      0x34,0x15,0x1f,0x30
000290  2074              MOVS     r0,#0x74              ;909
000292  f7fffffe          BL       STATE_SwitchStep
000296  e02d              B        |L4.756|
000298  4867              LDR      r0,|L4.1080|
00029a  7ec0              LDRB     r0,[r0,#0x1b]         ;913  ; dut_info
00029c  b118              CBZ      r0,|L4.678|
00029e  2075              MOVS     r0,#0x75              ;915
0002a0  f7fffffe          BL       STATE_SwitchStep
0002a4  e005              B        |L4.690|
                  |L4.678|
0002a6  4864              LDR      r0,|L4.1080|
0002a8  7f00              LDRB     r0,[r0,#0x1c]         ;917  ; dut_info
0002aa  b110              CBZ      r0,|L4.690|
0002ac  2079              MOVS     r0,#0x79              ;919
0002ae  f7fffffe          BL       STATE_SwitchStep
                  |L4.690|
0002b2  e01f              B        |L4.756|
0002b4  7966              LDRB     r6,[r4,#5]            ;926
0002b6  b91e              CBNZ     r6,|L4.704|
0002b8  2075              MOVS     r0,#0x75              ;932
0002ba  f7fffffe          BL       STATE_SwitchStep
0002be  e019              B        |L4.756|
                  |L4.704|
0002c0  2076              MOVS     r0,#0x76              ;937
0002c2  f7fffffe          BL       STATE_SwitchStep
0002c6  e015              B        |L4.756|
0002c8  7966              LDRB     r6,[r4,#5]            ;941
0002ca  b906              CBNZ     r6,|L4.718|
0002cc  e012              B        |L4.756|
                  |L4.718|
0002ce  485a              LDR      r0,|L4.1080|
0002d0  6b00              LDR      r0,[r0,#0x30]         ;949  ; dut_info
0002d2  4959              LDR      r1,|L4.1080|
0002d4  6a49              LDR      r1,[r1,#0x24]         ;949  ; dut_info
0002d6  4288              CMP      r0,r1                 ;949
0002d8  d203              BCS      |L4.738|
0002da  2077              MOVS     r0,#0x77              ;951
0002dc  f7fffffe          BL       STATE_SwitchStep
0002e0  e002              B        |L4.744|
                  |L4.738|
0002e2  2078              MOVS     r0,#0x78              ;955
0002e4  f7fffffe          BL       STATE_SwitchStep
                  |L4.744|
0002e8  e004              B        |L4.756|
0002ea  2079              MOVS     r0,#0x79              ;960
0002ec  f7fffffe          BL       STATE_SwitchStep
0002f0  e000              B        |L4.756|
                  |L4.754|
0002f2  bf00              NOP                            ;963
                  |L4.756|
0002f4  bf00              NOP                            ;910
0002f6  e0b7              B        |L4.1128|
                  |L4.760|
0002f8  2f01              CMP      r7,#1                 ;970
0002fa  d006              BEQ      |L4.778|
0002fc  2f02              CMP      r7,#2                 ;970
0002fe  d01d              BEQ      |L4.828|
000300  2f03              CMP      r7,#3                 ;970
000302  d045              BEQ      |L4.912|
000304  2f04              CMP      r7,#4                 ;970
000306  d172              BNE      |L4.1006|
000308  e076              B        |L4.1016|
                  |L4.778|
00030a  484b              LDR      r0,|L4.1080|
00030c  f890003c          LDRB     r0,[r0,#0x3c]         ;974  ; dut_info
000310  b998              CBNZ     r0,|L4.826|
000312  4849              LDR      r0,|L4.1080|
000314  7f40              LDRB     r0,[r0,#0x1d]         ;976  ; dut_info
000316  b910              CBNZ     r0,|L4.798|
000318  4847              LDR      r0,|L4.1080|
00031a  7ec0              LDRB     r0,[r0,#0x1b]         ;976  ; dut_info
00031c  b118              CBZ      r0,|L4.806|
                  |L4.798|
00031e  207d              MOVS     r0,#0x7d              ;978
000320  f7fffffe          BL       STATE_SwitchStep
000324  e005              B        |L4.818|
                  |L4.806|
000326  4844              LDR      r0,|L4.1080|
000328  7f00              LDRB     r0,[r0,#0x1c]         ;980  ; dut_info
00032a  b110              CBZ      r0,|L4.818|
00032c  209a              MOVS     r0,#0x9a              ;982
00032e  f7fffffe          BL       STATE_SwitchStep
                  |L4.818|
000332  2001              MOVS     r0,#1                 ;984
000334  4940              LDR      r1,|L4.1080|
000336  f881003c          STRB     r0,[r1,#0x3c]         ;984
                  |L4.826|
00033a  e092              B        |L4.1122|
                  |L4.828|
00033c  483e              LDR      r0,|L4.1080|
00033e  7ec0              LDRB     r0,[r0,#0x1b]         ;990  ; dut_info
000340  b188              CBZ      r0,|L4.870|
000342  2000              MOVS     r0,#0                 ;992
000344  493c              LDR      r1,|L4.1080|
000346  6308              STR      r0,[r1,#0x30]         ;992  ; dut_info
000348  207e              MOVS     r0,#0x7e              ;993
00034a  f7fffffe          BL       STATE_SwitchStep
00034e  2001              MOVS     r0,#1                 ;994
000350  1e81              SUBS     r1,r0,#2              ;994
000352  237f              MOVS     r3,#0x7f              ;994
000354  4a39              LDR      r2,|L4.1084|
000356  e9cd1000          STRD     r1,r0,[sp,#0]         ;994
00035a  f44f717a          MOV      r1,#0x3e8             ;994
00035e  200a              MOVS     r0,#0xa               ;994
000360  f7fffffe          BL       TIMER_AddTask
000364  e013              B        |L4.910|
                  |L4.870|
000366  4834              LDR      r0,|L4.1080|
000368  7f40              LDRB     r0,[r0,#0x1d]         ;1001  ; dut_info
00036a  b180              CBZ      r0,|L4.910|
00036c  2000              MOVS     r0,#0                 ;1003
00036e  4932              LDR      r1,|L4.1080|
000370  6348              STR      r0,[r1,#0x34]         ;1003  ; dut_info
000372  2081              MOVS     r0,#0x81              ;1004
000374  f7fffffe          BL       STATE_SwitchStep
000378  2001              MOVS     r0,#1                 ;1005
00037a  1e81              SUBS     r1,r0,#2              ;1005
00037c  2382              MOVS     r3,#0x82              ;1005
00037e  4a2f              LDR      r2,|L4.1084|
000380  e9cd1000          STRD     r1,r0,[sp,#0]         ;1005
000384  f44f717a          MOV      r1,#0x3e8             ;1005
000388  200a              MOVS     r0,#0xa               ;1005
00038a  f7fffffe          BL       TIMER_AddTask
                  |L4.910|
00038e  e068              B        |L4.1122|
                  |L4.912|
000390  2009              MOVS     r0,#9                 ;1015
000392  f7fffffe          BL       TIMER_ResetTimer
000396  4828              LDR      r0,|L4.1080|
000398  7ec0              LDRB     r0,[r0,#0x1b]         ;1016  ; dut_info
00039a  b1a0              CBZ      r0,|L4.966|
00039c  4826              LDR      r0,|L4.1080|
00039e  6b01              LDR      r1,[r0,#0x30]         ;1018  ; dut_info
0003a0  6a40              LDR      r0,[r0,#0x24]         ;1018  ; dut_info
0003a2  1e40              SUBS     r0,r0,#1              ;1018
0003a4  4281              CMP      r1,r0                 ;1018
0003a6  d20a              BCS      |L4.958|
0003a8  7960              LDRB     r0,[r4,#5]            ;1020
0003aa  b120              CBZ      r0,|L4.950|
0003ac  4822              LDR      r0,|L4.1080|
0003ae  6b00              LDR      r0,[r0,#0x30]         ;1022  ; dut_info
0003b0  1c40              ADDS     r0,r0,#1              ;1022
0003b2  4921              LDR      r1,|L4.1080|
0003b4  6308              STR      r0,[r1,#0x30]         ;1022  ; dut_info
                  |L4.950|
0003b6  207e              MOVS     r0,#0x7e              ;1024
0003b8  f7fffffe          BL       STATE_SwitchStep
0003bc  e01b              B        |L4.1014|
                  |L4.958|
0003be  2080              MOVS     r0,#0x80              ;1028
0003c0  f7fffffe          BL       STATE_SwitchStep
0003c4  e017              B        |L4.1014|
                  |L4.966|
0003c6  481c              LDR      r0,|L4.1080|
0003c8  7f40              LDRB     r0,[r0,#0x1d]         ;1031  ; dut_info
0003ca  b1a0              CBZ      r0,|L4.1014|
0003cc  481a              LDR      r0,|L4.1080|
0003ce  6b41              LDR      r1,[r0,#0x34]         ;1033  ; dut_info
0003d0  6a80              LDR      r0,[r0,#0x28]         ;1033  ; dut_info
0003d2  1e40              SUBS     r0,r0,#1              ;1033
0003d4  4281              CMP      r1,r0                 ;1033
0003d6  d20b              BCS      |L4.1008|
0003d8  7960              LDRB     r0,[r4,#5]            ;1035
0003da  b120              CBZ      r0,|L4.998|
0003dc  4816              LDR      r0,|L4.1080|
0003de  6b40              LDR      r0,[r0,#0x34]         ;1037  ; dut_info
0003e0  1c40              ADDS     r0,r0,#1              ;1037
0003e2  4915              LDR      r1,|L4.1080|
0003e4  6348              STR      r0,[r1,#0x34]         ;1037  ; dut_info
                  |L4.998|
0003e6  2081              MOVS     r0,#0x81              ;1039
0003e8  f7fffffe          BL       STATE_SwitchStep
0003ec  e003              B        |L4.1014|
                  |L4.1006|
0003ee  e037              B        |L4.1120|
                  |L4.1008|
0003f0  2080              MOVS     r0,#0x80              ;1043
0003f2  f7fffffe          BL       STATE_SwitchStep
                  |L4.1014|
0003f6  e034              B        |L4.1122|
                  |L4.1016|
0003f8  7960              LDRB     r0,[r4,#5]            ;1049
0003fa  b198              CBZ      r0,|L4.1060|
0003fc  480e              LDR      r0,|L4.1080|
0003fe  7ec0              LDRB     r0,[r0,#0x1b]         ;1052  ; dut_info
000400  b130              CBZ      r0,|L4.1040|
000402  2001              MOVS     r0,#1                 ;1054
000404  490c              LDR      r1,|L4.1080|
000406  f881003f          STRB     r0,[r1,#0x3f]         ;1054
00040a  2000              MOVS     r0,#0                 ;1055
00040c  76c8              STRB     r0,[r1,#0x1b]         ;1055
00040e  e020              B        |L4.1106|
                  |L4.1040|
000410  4809              LDR      r0,|L4.1080|
000412  7f40              LDRB     r0,[r0,#0x1d]         ;1057  ; dut_info
000414  b1e8              CBZ      r0,|L4.1106|
000416  2001              MOVS     r0,#1                 ;1059
000418  4907              LDR      r1,|L4.1080|
00041a  f881003e          STRB     r0,[r1,#0x3e]         ;1059
00041e  2000              MOVS     r0,#0                 ;1060
000420  7748              STRB     r0,[r1,#0x1d]         ;1060
000422  e016              B        |L4.1106|
                  |L4.1060|
000424  4804              LDR      r0,|L4.1080|
000426  7ec0              LDRB     r0,[r0,#0x1b]         ;1065  ; dut_info
000428  b150              CBZ      r0,|L4.1088|
00042a  2001              MOVS     r0,#1                 ;1067
00042c  4902              LDR      r1,|L4.1080|
00042e  f8810039          STRB     r0,[r1,#0x39]         ;1067
000432  2000              MOVS     r0,#0                 ;1068
000434  76c8              STRB     r0,[r1,#0x1b]         ;1068
000436  e00c              B        |L4.1106|
                  |L4.1080|
                          DCD      dut_info
                  |L4.1084|
                          DCD      STATE_SwitchStep
                  |L4.1088|
000440  4812              LDR      r0,|L4.1164|
000442  7f40              LDRB     r0,[r0,#0x1d]         ;1070  ; dut_info
000444  b128              CBZ      r0,|L4.1106|
000446  2001              MOVS     r0,#1                 ;1072
000448  4910              LDR      r1,|L4.1164|
00044a  f8810039          STRB     r0,[r1,#0x39]         ;1072
00044e  2000              MOVS     r0,#0                 ;1073
000450  7748              STRB     r0,[r1,#0x1d]         ;1073
                  |L4.1106|
000452  2009              MOVS     r0,#9                 ;1076
000454  f7fffffe          BL       TIMER_KillTask
000458  2084              MOVS     r0,#0x84              ;1077
00045a  f7fffffe          BL       STATE_SwitchStep
00045e  e000              B        |L4.1122|
                  |L4.1120|
000460  bf00              NOP                            ;1081
                  |L4.1122|
000462  bf00              NOP                            ;986
000464  e000              B        |L4.1128|
                  |L4.1126|
000466  bf00              NOP                            ;1086
                  |L4.1128|
000468  bf00              NOP                            ;660
00046a  f8b503d0          LDRH     r0,[r5,#0x3d0]        ;1090
00046e  1c40              ADDS     r0,r0,#1              ;1090
000470  f8a503d0          STRH     r0,[r5,#0x3d0]        ;1090
000474  f8b503d0          LDRH     r0,[r5,#0x3d0]        ;1091
000478  2105              MOVS     r1,#5                 ;1091
00047a  fb90f2f1          SDIV     r2,r0,r1              ;1091
00047e  fb010012          MLS      r0,r1,r2,r0           ;1091
000482  f8a503d0          STRH     r0,[r5,#0x3d0]        ;1091
000486  bf00              NOP      
000488  e5c1              B        |L4.14|
;;;1093   
                          ENDP

00048a  0000              DCW      0x0000
                  |L4.1164|
                          DCD      dut_info

                          AREA ||i.UART_PROTOCOL_ConfirmTempCmdFrameBuff||, CODE, READONLY, ALIGN=1

                  UART_PROTOCOL_ConfirmTempCmdFrameBuff PROC
;;;288    // 将临时缓冲区添加到命令帧缓冲区中，其本质操作是承认临时缓冲区数据有效
;;;289    BOOL UART_PROTOCOL_ConfirmTempCmdFrameBuff(UART_PROTOCOL_CB *pCB)
000000  b510              PUSH     {r4,lr}
;;;290    {
000002  4601              MOV      r1,r0
;;;291    	UART_PROTOCOL_RX_CMD_FRAME *pCmdFrame = NULL;
000004  2200              MOVS     r2,#0
;;;292    
;;;293    	// 参数合法性检验
;;;294    	if (NULL == pCB)
000006  b909              CBNZ     r1,|L5.12|
;;;295    	{
;;;296    		return FALSE;
000008  2000              MOVS     r0,#0
                  |L5.10|
;;;297    	}
;;;298    
;;;299    	// 临时缓冲区为空，不予添加
;;;300    	pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.end];
;;;301    	if (0 == pCmdFrame->length)
;;;302    	{
;;;303    		return FALSE;
;;;304    	}
;;;305    
;;;306    	// 添加
;;;307    	pCB->rx.end++;
;;;308    	pCB->rx.end %= UART_PROTOCOL_RX_QUEUE_SIZE;
;;;309    	pCB->rx.cmdQueue[pCB->rx.end].length = 0; // 该行的作用是将新的添加位置有效数据个数清零，以便将这个位置当做临时帧缓冲区
;;;310    
;;;311    	return TRUE;
;;;312    }
00000a  bd10              POP      {r4,pc}
                  |L5.12|
00000c  f8b103d2          LDRH     r0,[r1,#0x3d2]        ;300
000010  234d              MOVS     r3,#0x4d              ;300
000012  4358              MULS     r0,r3,r0              ;300
000014  f10103ce          ADD      r3,r1,#0xce           ;300
000018  eb030240          ADD      r2,r3,r0,LSL #1       ;300
00001c  f8b20098          LDRH     r0,[r2,#0x98]         ;301
000020  b908              CBNZ     r0,|L5.38|
000022  2000              MOVS     r0,#0                 ;303
000024  e7f1              B        |L5.10|
                  |L5.38|
000026  f8b103d2          LDRH     r0,[r1,#0x3d2]        ;307
00002a  1c40              ADDS     r0,r0,#1              ;307
00002c  f8a103d2          STRH     r0,[r1,#0x3d2]        ;307
000030  f8b103d2          LDRH     r0,[r1,#0x3d2]        ;308
000034  2305              MOVS     r3,#5                 ;308
000036  fb90f4f3          SDIV     r4,r0,r3              ;308
00003a  fb030014          MLS      r0,r3,r4,r0           ;308
00003e  f8a103d2          STRH     r0,[r1,#0x3d2]        ;308
000042  2400              MOVS     r4,#0                 ;309
000044  f8b103d2          LDRH     r0,[r1,#0x3d2]        ;309
000048  234d              MOVS     r3,#0x4d              ;309
00004a  4358              MULS     r0,r3,r0              ;309
00004c  f10103ce          ADD      r3,r1,#0xce           ;309
000050  eb030040          ADD      r0,r3,r0,LSL #1       ;309
000054  f8a04098          STRH     r4,[r0,#0x98]         ;309
000058  2001              MOVS     r0,#1                 ;311
00005a  e7d6              B        |L5.10|
;;;313    
                          ENDP


                          AREA ||i.UART_PROTOCOL_DataStructInit||, CODE, READONLY, ALIGN=1

                  UART_PROTOCOL_DataStructInit PROC
;;;225    // 数据结构初始化
;;;226    void UART_PROTOCOL_DataStructInit(UART_PROTOCOL_CB *pCB)
000000  b510              PUSH     {r4,lr}
;;;227    {
;;;228    	uint16 i;
;;;229    
;;;230    	// 参数合法性检验
;;;231    	if (NULL == pCB)
000002  b900              CBNZ     r0,|L6.6|
                  |L6.4|
;;;232    	{
;;;233    		return;
;;;234    	}
;;;235    
;;;236    	pCB->tx.txBusy = FALSE;
;;;237    	pCB->tx.index = 0;
;;;238    	pCB->tx.head = 0;
;;;239    	pCB->tx.end = 0;
;;;240    	for (i = 0; i < UART_PROTOCOL_TX_QUEUE_SIZE; i++)
;;;241    	{
;;;242    		pCB->tx.cmdQueue[i].length = 0;
;;;243    	}
;;;244    
;;;245    	pCB->rxFIFO.head = 0;
;;;246    	pCB->rxFIFO.end = 0;
;;;247    	pCB->rxFIFO.currentProcessIndex = 0;
;;;248    
;;;249    	pCB->rx.head = 0;
;;;250    	pCB->rx.end = 0;
;;;251    	for (i = 0; i < UART_PROTOCOL_RX_QUEUE_SIZE; i++)
;;;252    	{
;;;253    		pCB->rx.cmdQueue[i].length = 0;
;;;254    	}
;;;255    }
000004  bd10              POP      {r4,pc}
                  |L6.6|
000006  2300              MOVS     r3,#0                 ;236
000008  f88036dc          STRB     r3,[r0,#0x6dc]        ;236
00000c  f8a036da          STRH     r3,[r0,#0x6da]        ;237
000010  f8a036d6          STRH     r3,[r0,#0x6d6]        ;238
000014  f8a036d8          STRH     r3,[r0,#0x6d8]        ;239
000018  2100              MOVS     r1,#0                 ;240
00001a  e00a              B        |L6.50|
                  |L6.28|
00001c  2400              MOVS     r4,#0                 ;242
00001e  224d              MOVS     r2,#0x4d              ;242
000020  434a              MULS     r2,r1,r2              ;242
000022  f5007375          ADD      r3,r0,#0x3d4          ;242
000026  eb030242          ADD      r2,r3,r2,LSL #1       ;242
00002a  f8a24098          STRH     r4,[r2,#0x98]         ;242
00002e  1c4a              ADDS     r2,r1,#1              ;240
000030  b291              UXTH     r1,r2                 ;240
                  |L6.50|
000032  2905              CMP      r1,#5                 ;240
000034  dbf2              BLT      |L6.28|
000036  2200              MOVS     r2,#0                 ;245
000038  f8202fc8          STRH     r2,[r0,#0xc8]!        ;245
00003c  8042              STRH     r2,[r0,#2]            ;246
00003e  8082              STRH     r2,[r0,#4]            ;247
000040  38c8              SUBS     r0,r0,#0xc8           ;247
000042  2300              MOVS     r3,#0                 ;249
000044  f8a033d0          STRH     r3,[r0,#0x3d0]        ;249
000048  f8a033d2          STRH     r3,[r0,#0x3d2]        ;250
00004c  2100              MOVS     r1,#0                 ;251
00004e  e00a              B        |L6.102|
                  |L6.80|
000050  2400              MOVS     r4,#0                 ;253
000052  224d              MOVS     r2,#0x4d              ;253
000054  434a              MULS     r2,r1,r2              ;253
000056  f10003ce          ADD      r3,r0,#0xce           ;253
00005a  eb030242          ADD      r2,r3,r2,LSL #1       ;253
00005e  f8a24098          STRH     r4,[r2,#0x98]         ;253
000062  1c4a              ADDS     r2,r1,#1              ;251
000064  b291              UXTH     r1,r2                 ;251
                  |L6.102|
000066  2905              CMP      r1,#5                 ;251
000068  dbf2              BLT      |L6.80|
00006a  bf00              NOP      
00006c  e7ca              B        |L6.4|
;;;256    
                          ENDP


                          AREA ||i.UART_PROTOCOL_Init||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL_Init PROC
;;;56     // 协议初始化
;;;57     void UART_PROTOCOL_Init(void)
000000  b500              PUSH     {lr}
;;;58     {
;;;59     	// 协议层数据结构初始化
;;;60     	UART_PROTOCOL_DataStructInit(&uartProtocolCB);
000002  4803              LDR      r0,|L7.16|
000004  f7fffffe          BL       UART_PROTOCOL_DataStructInit
;;;61     
;;;62     	// 向驱动层注册数据接收接口
;;;63     	// UART_DRIVE_RegisterDataSendService(UART_PROTOCOL_MacProcess);
;;;64     
;;;65     	// 向驱动层注册数据发送接口
;;;66     	UART_PROTOCOL_RegisterDataSendService(UART_DRIVE_AddTxArray);
000008  4802              LDR      r0,|L7.20|
00000a  f7fffffe          BL       UART_PROTOCOL_RegisterDataSendService
;;;67     
;;;68     	// 注册间隔参数设置时间
;;;69     	//	TIMER_AddTask(TIMER_ID_PROTOCOL_55_PARAM_TX,
;;;70     	//					300,
;;;71     	//					UART_PROTOCOL_SendCmdAging,
;;;72     	//					TRUE,
;;;73     	//					TIMER_LOOP_FOREVER,
;;;74     	//					ACTION_MODE_ADD_TO_QUEUE);
;;;75     }
00000e  bd00              POP      {pc}
;;;76     
                          ENDP

                  |L7.16|
                          DCD      uartProtocolCB
                  |L7.20|
                          DCD      UART_DRIVE_AddTxArray

                          AREA ||i.UART_PROTOCOL_MacProcess||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL_MacProcess PROC
;;;257    // UART报文接收处理函数(注意根据具体模块修改)
;;;258    void UART_PROTOCOL_MacProcess(uint16 standarID, uint8 *pData, uint16 length)
000000  b5f0              PUSH     {r4-r7,lr}
;;;259    {
000002  4604              MOV      r4,r0
000004  4615              MOV      r5,r2
;;;260    	uint16 end = uartProtocolCB.rxFIFO.end;
000006  4e12              LDR      r6,|L8.80|
000008  f8b600ca          LDRH     r0,[r6,#0xca]  ; uartProtocolCB
;;;261    	uint16 head = uartProtocolCB.rxFIFO.head;
00000c  f8b620c8          LDRH     r2,[r6,#0xc8]  ; uartProtocolCB
;;;262    	uint8 rxdata = 0x00;
000010  2300              MOVS     r3,#0
;;;263    
;;;264    	// 接收数据
;;;265    	rxdata = *pData;
000012  780b              LDRB     r3,[r1,#0]
;;;266    
;;;267    	// 一级缓冲区已满，不予接收
;;;268    	if ((end + 1) % UART_PROTOCOL_RX_FIFO_SIZE == head)
000014  1c46              ADDS     r6,r0,#1
000016  27c8              MOVS     r7,#0xc8
000018  fb96fcf7          SDIV     r12,r6,r7
00001c  fb07661c          MLS      r6,r7,r12,r6
000020  4296              CMP      r6,r2
000022  d100              BNE      |L8.38|
                  |L8.36|
;;;269    	{
;;;270    		return;
;;;271    	}
;;;272    	// 一级缓冲区未满，接收
;;;273    	else
;;;274    	{
;;;275    		// 将接收到的数据放到临时缓冲区中
;;;276    		uartProtocolCB.rxFIFO.buff[end] = rxdata;
;;;277    		uartProtocolCB.rxFIFO.end++;
;;;278    		uartProtocolCB.rxFIFO.end %= UART_PROTOCOL_RX_FIFO_SIZE;
;;;279    	}
;;;280    }
000024  bdf0              POP      {r4-r7,pc}
                  |L8.38|
000026  4e0a              LDR      r6,|L8.80|
000028  5433              STRB     r3,[r6,r0]            ;276
00002a  f8b660ca          LDRH     r6,[r6,#0xca]         ;277  ; uartProtocolCB
00002e  1c76              ADDS     r6,r6,#1              ;277
000030  4f07              LDR      r7,|L8.80|
000032  f8a760ca          STRH     r6,[r7,#0xca]         ;277
000036  463e              MOV      r6,r7                 ;278
000038  f8b660ca          LDRH     r6,[r6,#0xca]         ;278  ; uartProtocolCB
00003c  27c8              MOVS     r7,#0xc8              ;278
00003e  fb96fcf7          SDIV     r12,r6,r7             ;278
000042  fb07661c          MLS      r6,r7,r12,r6          ;278
000046  4f02              LDR      r7,|L8.80|
000048  f8a760ca          STRH     r6,[r7,#0xca]         ;278
00004c  bf00              NOP      
00004e  e7e9              B        |L8.36|
;;;281    
                          ENDP

                  |L8.80|
                          DCD      uartProtocolCB

                          AREA ||i.UART_PROTOCOL_Process||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL_Process PROC
;;;77     // UART协议层过程处理
;;;78     void UART_PROTOCOL_Process(void)
000000  b510              PUSH     {r4,lr}
;;;79     {
;;;80     	// 55升级协议
;;;81     	//  UART接收FIFO缓冲区处理
;;;82     	UART_PROTOCOL_RxFIFOProcess(&uartProtocolCB);
000002  480c              LDR      r0,|L9.52|
000004  f7fffffe          BL       UART_PROTOCOL_RxFIFOProcess
;;;83     
;;;84     	// UART接收命令缓冲区处理
;;;85     	UART_PROTOCOL_CmdFrameProcess(&uartProtocolCB);
000008  480a              LDR      r0,|L9.52|
00000a  f7fffffe          BL       UART_PROTOCOL_CmdFrameProcess
;;;86     
;;;87     	// UART协议层发送处理过程
;;;88     	UART_PROTOCOL_TxStateProcess();
00000e  f7fffffe          BL       UART_PROTOCOL_TxStateProcess
;;;89     
;;;90     	// 3A配置协议
;;;91     	// UART接收FIFO缓冲区处理
;;;92     	UART_PROTOCOL3_RxFIFOProcess(&uartProtocolCB3);
000012  4809              LDR      r0,|L9.56|
000014  f7fffffe          BL       UART_PROTOCOL3_RxFIFOProcess
;;;93     
;;;94     	// UART接收命令缓冲区处理
;;;95     	UART_PROTOCOL3_CmdFrameProcess(&uartProtocolCB3); // km5s协议，在app中升级config
000018  4807              LDR      r0,|L9.56|
00001a  f7fffffe          BL       UART_PROTOCOL3_CmdFrameProcess
;;;96     
;;;97     	// UART协议层发送处理过程
;;;98     	UART_PROTOCOL3_TxStateProcess();
00001e  f7fffffe          BL       UART_PROTOCOL3_TxStateProcess
;;;99     
;;;100        // DTA测试协议
;;;101    	//  UART接收FIFO缓冲区处理
;;;102    	DTA_UART_PROTOCOL_RxFIFOProcess(&dtaUartProtocolCB);
000022  4806              LDR      r0,|L9.60|
000024  f7fffffe          BL       DTA_UART_PROTOCOL_RxFIFOProcess
;;;103    
;;;104    	// UART接收命令缓冲区处理
;;;105    	DTA_UART_PROTOCOL_CmdFrameProcess(&dtaUartProtocolCB);
000028  4804              LDR      r0,|L9.60|
00002a  f7fffffe          BL       DTA_UART_PROTOCOL_CmdFrameProcess
;;;106    
;;;107    	// UART协议层发送处理过程
;;;108    	DTA_UART_PROTOCOL_TxStateProcess();    
00002e  f7fffffe          BL       DTA_UART_PROTOCOL_TxStateProcess
;;;109    }
000032  bd10              POP      {r4,pc}
;;;110    
                          ENDP

                  |L9.52|
                          DCD      uartProtocolCB
                  |L9.56|
                          DCD      uartProtocolCB3
                  |L9.60|
                          DCD      dtaUartProtocolCB

                          AREA ||i.UART_PROTOCOL_RegisterDataSendService||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL_RegisterDataSendService PROC
;;;282    // UART协议层向驱动层注册数据发送接口
;;;283    void UART_PROTOCOL_RegisterDataSendService(BOOL (*service)(uint16 id, uint8 *pData, uint16 length))
000000  4901              LDR      r1,|L10.8|
;;;284    {
;;;285    	uartProtocolCB.sendDataThrowService = service;
000002  f8c106e0          STR      r0,[r1,#0x6e0]  ; uartProtocolCB
;;;286    }
000006  4770              BX       lr
;;;287    
                          ENDP

                  |L10.8|
                          DCD      uartProtocolCB

                          AREA ||i.UART_PROTOCOL_ReportWriteParamResult||, CODE, READONLY, ALIGN=1

                  UART_PROTOCOL_ReportWriteParamResult PROC
;;;1144   // 上报写配置参数结果
;;;1145   void UART_PROTOCOL_ReportWriteParamResult(uint32 param)
000000  b510              PUSH     {r4,lr}
;;;1146   {
000002  4604              MOV      r4,r0
;;;1147   	// 添加命令头
;;;1148   	UART_PROTOCOL_TxAddData(UART_PROTOCOL_CMD_HEAD);
000004  2055              MOVS     r0,#0x55
000006  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;1149   
;;;1150   	// 添加设备地址
;;;1151   	UART_PROTOCOL_TxAddData(UART_PROTOCOL_CMD_DEVICE_ADDR);
00000a  201a              MOVS     r0,#0x1a
00000c  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;1152   
;;;1153   	// 添加命令字
;;;1154   	UART_PROTOCOL_TxAddData(UART_PROTOCOL_CMD_WRITE_CONTROL_PARAM_RESULT);
000010  20c1              MOVS     r0,#0xc1
000012  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;1155   
;;;1156   	// 添加数据长度
;;;1157   	UART_PROTOCOL_TxAddData(1);
000016  2001              MOVS     r0,#1
000018  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;1158   
;;;1159   	// 写入结果
;;;1160   	UART_PROTOCOL_TxAddData(param);
00001c  b2e0              UXTB     r0,r4
00001e  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;1161   
;;;1162   	// 添加检验和与结束符，并添加至发送
;;;1163   	UART_PROTOCOL_TxAddFrame();
000022  f7fffffe          BL       UART_PROTOCOL_TxAddFrame
;;;1164   }
000026  bd10              POP      {r4,pc}
;;;1165   
                          ENDP


                          AREA ||i.UART_PROTOCOL_RxFIFOProcess||, CODE, READONLY, ALIGN=1

                  UART_PROTOCOL_RxFIFOProcess PROC
;;;347    // 一级接收缓冲区处理，从一级接收缓冲区中取出一个字节添加到命令帧缓冲区中
;;;348    void UART_PROTOCOL_RxFIFOProcess(UART_PROTOCOL_CB *pCB)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;349    {
000004  4604              MOV      r4,r0
;;;350    	uint16 end = pCB->rxFIFO.end;
000006  f8b470ca          LDRH     r7,[r4,#0xca]
;;;351    	uint16 head = pCB->rxFIFO.head;
00000a  f8b490c8          LDRH     r9,[r4,#0xc8]
;;;352    	UART_PROTOCOL_RX_CMD_FRAME *pCmdFrame = NULL;
00000e  2500              MOVS     r5,#0
;;;353    	uint16 length = 0;
000010  46a8              MOV      r8,r5
;;;354    	uint8 currentData = 0;
000012  2600              MOVS     r6,#0
;;;355    
;;;356    	// 参数合法性检验
;;;357    	if (NULL == pCB)
000014  b90c              CBNZ     r4,|L12.26|
                  |L12.22|
;;;358    	{
;;;359    		return;
;;;360    	}
;;;361    
;;;362    	// 一级缓冲区为空，退出
;;;363    	if (head == end)
;;;364    	{
;;;365    		return;
;;;366    	}
;;;367    
;;;368    	// 获取临时缓冲区指针
;;;369    	pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.end];
;;;370    	// 取出当前要处理的字节
;;;371    	currentData = pCB->rxFIFO.buff[pCB->rxFIFO.currentProcessIndex];
;;;372    
;;;373    	// 临时缓冲区长度为0时，搜索首字节
;;;374    	if (0 == pCmdFrame->length)
;;;375    	{
;;;376    		// 命令头错误，删除当前字节并退出
;;;377    		if (UART_PROTOCOL_CMD_HEAD != currentData)
;;;378    		{
;;;379    			pCB->rxFIFO.head++;
;;;380    			pCB->rxFIFO.head %= UART_PROTOCOL_RX_FIFO_SIZE;
;;;381    			pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;382    
;;;383    			return;
;;;384    		}
;;;385    
;;;386    		// 命令头正确，但无临时缓冲区可用，退出
;;;387    		if ((pCB->rx.end + 1) % UART_PROTOCOL_RX_QUEUE_SIZE == pCB->rx.head)
;;;388    		{
;;;389    			return;
;;;390    		}
;;;391    
;;;392    		// 添加UART通讯超时时间设置-2016.1.5增加
;;;393    #if UART_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;394    		TIMER_AddTask(TIMER_ID_UART_RX_TIME_OUT_CONTROL,
;;;395    					  UART_PROTOCOL_BUS_UNIDIRECTIONAL_TIME_OUT,
;;;396    					  UART_PROTOCOL_CALLBACK_RxTimeOut,
;;;397    					  0,
;;;398    					  1,
;;;399    					  ACTION_MODE_ADD_TO_QUEUE);
;;;400    #endif
;;;401    
;;;402    		// 命令头正确，有临时缓冲区可用，则将其添加到命令帧临时缓冲区中
;;;403    		pCmdFrame->buff[pCmdFrame->length++] = currentData;
;;;404    		pCB->rxFIFO.currentProcessIndex++;
;;;405    		pCB->rxFIFO.currentProcessIndex %= UART_PROTOCOL_RX_FIFO_SIZE;
;;;406    	}
;;;407    	// 非首字节，将数据添加到命令帧临时缓冲区中，但暂不删除当前数据
;;;408    	else
;;;409    	{
;;;410    		// 临时缓冲区溢出，说明当前正在接收的命令帧是错误的，正确的命令帧不会出现长度溢出的情况
;;;411    		if (pCmdFrame->length >= UART_PROTOCOL_RX_CMD_FRAME_LENGTH_MAX)
;;;412    		{
;;;413    #if UART_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;414    			// 停止RX通讯超时检测
;;;415    			UART_PROTOCOL_StopRxTimeOutCheck();
;;;416    #endif
;;;417    
;;;418    			// 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;419    			pCmdFrame->length = 0; // 2016.1.5增加
;;;420    			// 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;421    			pCB->rxFIFO.head++;
;;;422    			pCB->rxFIFO.head %= UART_PROTOCOL_RX_FIFO_SIZE;
;;;423    			pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;424    
;;;425    			return;
;;;426    		}
;;;427    
;;;428    		// 一直取到末尾
;;;429    		while (end != pCB->rxFIFO.currentProcessIndex)
;;;430    		{
;;;431    			// 取出当前要处理的字节
;;;432    			currentData = pCB->rxFIFO.buff[pCB->rxFIFO.currentProcessIndex];
;;;433    			// 缓冲区未溢出，正常接收，将数据添加到临时缓冲区中
;;;434    			pCmdFrame->buff[pCmdFrame->length++] = currentData;
;;;435    			pCB->rxFIFO.currentProcessIndex++;
;;;436    			pCB->rxFIFO.currentProcessIndex %= UART_PROTOCOL_RX_FIFO_SIZE;
;;;437    
;;;438    			// ■■接下来，需要检查命令帧是否完整，如果完整，则将命令帧临时缓冲区扶正■■
;;;439    
;;;440    			// 首先判断命令帧最小长度，一个完整的命令字至少包括8个字节: 命令头、设备地址、命令字、数据长度、校验和L、校验和H、结束标识0xD、结束标识OxA，因此不足8个字节的必定不完整
;;;441    			if (pCmdFrame->length < UART_PROTOCOL_CMD_FRAME_LENGTH_MIN)
;;;442    			{
;;;443    				// 继续接收
;;;444    				continue;
;;;445    			}
;;;446    
;;;447    			// 命令帧长度数值越界，说明当前命令帧错误，停止接收
;;;448    			if (pCmdFrame->buff[UART_PROTOCOL_CMD_LENGTH_INDEX] > UART_PROTOCOL_RX_CMD_FRAME_LENGTH_MAX - UART_PROTOCOL_CMD_FRAME_LENGTH_MIN)
;;;449    			{
;;;450    #if UART_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;451    				// 停止RX通讯超时检测
;;;452    				UART_PROTOCOL_StopRxTimeOutCheck();
;;;453    #endif
;;;454    
;;;455    				// 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;456    				pCmdFrame->length = 0;
;;;457    				// 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;458    				pCB->rxFIFO.head++;
;;;459    				pCB->rxFIFO.head %= UART_PROTOCOL_RX_FIFO_SIZE;
;;;460    				pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;461    
;;;462    				return;
;;;463    			}
;;;464    
;;;465    			// 命令帧长度校验，在命令长度描述字的数值上，增加命令头、设备地址、命令字、数据长度、校验和L、校验和H、结束标识0xD、结束标识OxA，即为命令帧实际长度
;;;466    			length = pCmdFrame->length;
;;;467    			if (length < pCmdFrame->buff[UART_PROTOCOL_CMD_LENGTH_INDEX] + UART_PROTOCOL_CMD_FRAME_LENGTH_MIN)
;;;468    			{
;;;469    				// 长度要求不一致，说明未接收完毕，退出继续
;;;470    				continue;
;;;471    			}
;;;472    
;;;473    			// 命令帧长度OK，则进行校验，失败时删除命令头
;;;474    			if (!UART_PROTOCOL_CheckSUM(pCmdFrame))
;;;475    			{
;;;476    #if UART_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;477    				// 停止RX通讯超时检测
;;;478    				UART_PROTOCOL_StopRxTimeOutCheck();
;;;479    #endif
;;;480    
;;;481    				// 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;482    				pCmdFrame->length = 0;
;;;483    				// 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;484    				pCB->rxFIFO.head++;
;;;485    				pCB->rxFIFO.head %= UART_PROTOCOL_RX_FIFO_SIZE;
;;;486    				pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;487    
;;;488    				return;
;;;489    			}
;;;490    
;;;491    #if UART_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;492    			// 停止RX通讯超时检测
;;;493    			UART_PROTOCOL_StopRxTimeOutCheck();
;;;494    #endif
;;;495    
;;;496    			// 执行到这里，即说明接收到了一个完整并且正确的命令帧，此时需将处理过的数据从一级缓冲区中删除，并将该命令帧扶正
;;;497    			pCB->rxFIFO.head += length;
;;;498    			pCB->rxFIFO.head %= UART_PROTOCOL_RX_FIFO_SIZE;
;;;499    			pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;500    			UART_PROTOCOL_ConfirmTempCmdFrameBuff(pCB);
;;;501    
;;;502    			return;
;;;503    		}
;;;504    	}
;;;505    }
000016  e8bd83f0          POP      {r4-r9,pc}
                  |L12.26|
00001a  45b9              CMP      r9,r7                 ;363
00001c  d100              BNE      |L12.32|
00001e  e7fa              B        |L12.22|
                  |L12.32|
000020  f8b403d2          LDRH     r0,[r4,#0x3d2]        ;369
000024  214d              MOVS     r1,#0x4d              ;369
000026  4348              MULS     r0,r1,r0              ;369
000028  f10401ce          ADD      r1,r4,#0xce           ;369
00002c  eb010540          ADD      r5,r1,r0,LSL #1       ;369
000030  f8b400cc          LDRH     r0,[r4,#0xcc]         ;371
000034  5c26              LDRB     r6,[r4,r0]            ;371
000036  f8b50098          LDRH     r0,[r5,#0x98]         ;374
00003a  bb90              CBNZ     r0,|L12.162|
00003c  2e55              CMP      r6,#0x55              ;377
00003e  d00e              BEQ      |L12.94|
000040  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;379
000044  1c40              ADDS     r0,r0,#1              ;379
000046  8020              STRH     r0,[r4,#0]            ;379
000048  8820              LDRH     r0,[r4,#0]            ;380
00004a  21c8              MOVS     r1,#0xc8              ;380
00004c  fb90f2f1          SDIV     r2,r0,r1              ;380
000050  fb010012          MLS      r0,r1,r2,r0           ;380
000054  8020              STRH     r0,[r4,#0]            ;380
000056  8820              LDRH     r0,[r4,#0]            ;381
000058  80a0              STRH     r0,[r4,#4]            ;381
00005a  3cc8              SUBS     r4,r4,#0xc8           ;381
00005c  e7db              B        |L12.22|
                  |L12.94|
00005e  f8b403d2          LDRH     r0,[r4,#0x3d2]        ;387
000062  1c40              ADDS     r0,r0,#1              ;387
000064  2105              MOVS     r1,#5                 ;387
000066  fb90f2f1          SDIV     r2,r0,r1              ;387
00006a  fb010112          MLS      r1,r1,r2,r0           ;387
00006e  f8b403d0          LDRH     r0,[r4,#0x3d0]        ;387
000072  4281              CMP      r1,r0                 ;387
000074  d100              BNE      |L12.120|
000076  e7ce              B        |L12.22|
                  |L12.120|
000078  f8351f98          LDRH     r1,[r5,#0x98]!        ;403
00007c  8828              LDRH     r0,[r5,#0]            ;403
00007e  1c40              ADDS     r0,r0,#1              ;403
000080  f8250998          STRH     r0,[r5],#-0x98        ;403
000084  1ca8              ADDS     r0,r5,#2              ;403
000086  5446              STRB     r6,[r0,r1]            ;403
000088  f8340fcc          LDRH     r0,[r4,#0xcc]!        ;404
00008c  1c40              ADDS     r0,r0,#1              ;404
00008e  8020              STRH     r0,[r4,#0]            ;404
000090  8820              LDRH     r0,[r4,#0]            ;405
000092  21c8              MOVS     r1,#0xc8              ;405
000094  fb90f2f1          SDIV     r2,r0,r1              ;405
000098  fb010012          MLS      r0,r1,r2,r0           ;405
00009c  f82409cc          STRH     r0,[r4],#-0xcc        ;405
0000a0  e07b              B        |L12.410|
                  |L12.162|
0000a2  e7ff              B        |L12.164|
                  |L12.164|
0000a4  f8b50098          LDRH     r0,[r5,#0x98]         ;411
0000a8  2896              CMP      r0,#0x96              ;411
0000aa  db11              BLT      |L12.208|
0000ac  2000              MOVS     r0,#0                 ;419
0000ae  f8a50098          STRH     r0,[r5,#0x98]         ;419
0000b2  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;421
0000b6  1c40              ADDS     r0,r0,#1              ;421
0000b8  8020              STRH     r0,[r4,#0]            ;421
0000ba  8820              LDRH     r0,[r4,#0]            ;422
0000bc  21c8              MOVS     r1,#0xc8              ;422
0000be  fb90f2f1          SDIV     r2,r0,r1              ;422
0000c2  fb010012          MLS      r0,r1,r2,r0           ;422
0000c6  8020              STRH     r0,[r4,#0]            ;422
0000c8  8820              LDRH     r0,[r4,#0]            ;423
0000ca  80a0              STRH     r0,[r4,#4]            ;423
0000cc  3cc8              SUBS     r4,r4,#0xc8           ;423
0000ce  e7a2              B        |L12.22|
                  |L12.208|
0000d0  e05f              B        |L12.402|
                  |L12.210|
0000d2  f8b400cc          LDRH     r0,[r4,#0xcc]         ;432
0000d6  5c26              LDRB     r6,[r4,r0]            ;432
0000d8  f8351f98          LDRH     r1,[r5,#0x98]!        ;434
0000dc  8828              LDRH     r0,[r5,#0]            ;434
0000de  1c40              ADDS     r0,r0,#1              ;434
0000e0  f8250998          STRH     r0,[r5],#-0x98        ;434
0000e4  1ca8              ADDS     r0,r5,#2              ;434
0000e6  5446              STRB     r6,[r0,r1]            ;434
0000e8  f8340fcc          LDRH     r0,[r4,#0xcc]!        ;435
0000ec  1c40              ADDS     r0,r0,#1              ;435
0000ee  8020              STRH     r0,[r4,#0]            ;435
0000f0  8820              LDRH     r0,[r4,#0]            ;436
0000f2  21c8              MOVS     r1,#0xc8              ;436
0000f4  fb90f2f1          SDIV     r2,r0,r1              ;436
0000f8  fb010012          MLS      r0,r1,r2,r0           ;436
0000fc  f82409cc          STRH     r0,[r4],#-0xcc        ;436
000100  f8b50098          LDRH     r0,[r5,#0x98]         ;441
000104  2804              CMP      r0,#4                 ;441
000106  da00              BGE      |L12.266|
000108  e043              B        |L12.402|
                  |L12.266|
00010a  7928              LDRB     r0,[r5,#4]            ;448
00010c  2892              CMP      r0,#0x92              ;448
00010e  dd11              BLE      |L12.308|
000110  2000              MOVS     r0,#0                 ;456
000112  f8a50098          STRH     r0,[r5,#0x98]         ;456
000116  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;458
00011a  1c40              ADDS     r0,r0,#1              ;458
00011c  8020              STRH     r0,[r4,#0]            ;458
00011e  8820              LDRH     r0,[r4,#0]            ;459
000120  21c8              MOVS     r1,#0xc8              ;459
000122  fb90f2f1          SDIV     r2,r0,r1              ;459
000126  fb010012          MLS      r0,r1,r2,r0           ;459
00012a  8020              STRH     r0,[r4,#0]            ;459
00012c  8820              LDRH     r0,[r4,#0]            ;460
00012e  80a0              STRH     r0,[r4,#4]            ;460
000130  3cc8              SUBS     r4,r4,#0xc8           ;460
000132  e770              B        |L12.22|
                  |L12.308|
000134  f8b58098          LDRH     r8,[r5,#0x98]         ;466
000138  7928              LDRB     r0,[r5,#4]            ;467
00013a  1d00              ADDS     r0,r0,#4              ;467
00013c  4540              CMP      r0,r8                 ;467
00013e  dd00              BLE      |L12.322|
000140  e027              B        |L12.402|
                  |L12.322|
000142  4628              MOV      r0,r5                 ;474
000144  f7fffffe          BL       UART_PROTOCOL_CheckSUM
000148  b988              CBNZ     r0,|L12.366|
00014a  2000              MOVS     r0,#0                 ;482
00014c  f8a50098          STRH     r0,[r5,#0x98]         ;482
000150  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;484
000154  1c40              ADDS     r0,r0,#1              ;484
000156  8020              STRH     r0,[r4,#0]            ;484
000158  8820              LDRH     r0,[r4,#0]            ;485
00015a  21c8              MOVS     r1,#0xc8              ;485
00015c  fb90f2f1          SDIV     r2,r0,r1              ;485
000160  fb010012          MLS      r0,r1,r2,r0           ;485
000164  8020              STRH     r0,[r4,#0]            ;485
000166  8820              LDRH     r0,[r4,#0]            ;486
000168  80a0              STRH     r0,[r4,#4]            ;486
00016a  3cc8              SUBS     r4,r4,#0xc8           ;486
00016c  e753              B        |L12.22|
                  |L12.366|
00016e  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;497
000172  4440              ADD      r0,r0,r8              ;497
000174  8020              STRH     r0,[r4,#0]            ;497
000176  8820              LDRH     r0,[r4,#0]            ;498
000178  21c8              MOVS     r1,#0xc8              ;498
00017a  fb90f2f1          SDIV     r2,r0,r1              ;498
00017e  fb010012          MLS      r0,r1,r2,r0           ;498
000182  8020              STRH     r0,[r4,#0]            ;498
000184  8820              LDRH     r0,[r4,#0]            ;499
000186  80a0              STRH     r0,[r4,#4]            ;499
000188  3cc8              SUBS     r4,r4,#0xc8           ;499
00018a  4620              MOV      r0,r4                 ;500
00018c  f7fffffe          BL       UART_PROTOCOL_ConfirmTempCmdFrameBuff
000190  e741              B        |L12.22|
                  |L12.402|
000192  f8b400cc          LDRH     r0,[r4,#0xcc]         ;429
000196  42b8              CMP      r0,r7                 ;429
000198  d19b              BNE      |L12.210|
                  |L12.410|
00019a  bf00              NOP      
00019c  e73b              B        |L12.22|
;;;506    
                          ENDP


                          AREA ||i.UART_PROTOCOL_SendCmdNoResult||, CODE, READONLY, ALIGN=1

                  UART_PROTOCOL_SendCmdNoResult PROC
;;;1209   // 发送命令无结果
;;;1210   void UART_PROTOCOL_SendCmdNoResult(uint8 cmdWord)
000000  b510              PUSH     {r4,lr}
;;;1211   {
000002  4604              MOV      r4,r0
;;;1212   	// 添加命令头
;;;1213   	UART_PROTOCOL_TxAddData(UART_PROTOCOL_CMD_HEAD);
000004  2055              MOVS     r0,#0x55
000006  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;1214   
;;;1215   	// 添加设备地址
;;;1216   	UART_PROTOCOL_TxAddData(UART_PROTOCOL_CMD_DEVICE_ADDR);
00000a  201a              MOVS     r0,#0x1a
00000c  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;1217   
;;;1218   	// 添加命令字
;;;1219   	UART_PROTOCOL_TxAddData(cmdWord);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;1220   
;;;1221   	UART_PROTOCOL_TxAddData(0); // 数据长度
000016  2000              MOVS     r0,#0
000018  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;1222   
;;;1223   	UART_PROTOCOL_TxAddFrame();
00001c  f7fffffe          BL       UART_PROTOCOL_TxAddFrame
;;;1224   }
000020  bd10              POP      {r4,pc}
                          ENDP


                          AREA ||i.UART_PROTOCOL_SendCmdParamAck||, CODE, READONLY, ALIGN=1

                  UART_PROTOCOL_SendCmdParamAck PROC
;;;1094   // 发送命令回复，带一个参数
;;;1095   void UART_PROTOCOL_SendCmdParamAck(uint8 ackCmd, uint8 ackParam)
000000  b530              PUSH     {r4,r5,lr}
;;;1096   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1097   	UART_PROTOCOL_TxAddData(0x55);
000006  2055              MOVS     r0,#0x55
000008  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;1098   	UART_PROTOCOL_TxAddData(ackCmd);
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;1099   	UART_PROTOCOL_TxAddData(0x01);
000012  2001              MOVS     r0,#1
000014  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;1100   	UART_PROTOCOL_TxAddData(ackParam);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;1101   	UART_PROTOCOL_TxAddFrame();
00001e  f7fffffe          BL       UART_PROTOCOL_TxAddFrame
;;;1102   }
000022  bd30              POP      {r4,r5,pc}
;;;1103   
                          ENDP


                          AREA ||i.UART_PROTOCOL_SendCmdWithResult||, CODE, READONLY, ALIGN=1

                  UART_PROTOCOL_SendCmdWithResult PROC
;;;1189   // 发送命令带结果
;;;1190   void UART_PROTOCOL_SendCmdWithResult(uint8 cmdWord, uint8 result)
000000  b530              PUSH     {r4,r5,lr}
;;;1191   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1192   	// 添加命令头
;;;1193   	UART_PROTOCOL_TxAddData(UART_PROTOCOL_CMD_HEAD);
000006  2055              MOVS     r0,#0x55
000008  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;1194   
;;;1195   	// 添加设备地址
;;;1196   	UART_PROTOCOL_TxAddData(UART_PROTOCOL_CMD_DEVICE_ADDR);
00000c  201a              MOVS     r0,#0x1a
00000e  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;1197   
;;;1198   	// 添加命令字
;;;1199   	UART_PROTOCOL_TxAddData(cmdWord);
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;1200   
;;;1201   	// 添加数据长度
;;;1202   	UART_PROTOCOL_TxAddData(1);
000018  2001              MOVS     r0,#1
00001a  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;1203   
;;;1204   	UART_PROTOCOL_TxAddData(result);
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;1205   
;;;1206   	UART_PROTOCOL_TxAddFrame();
000024  f7fffffe          BL       UART_PROTOCOL_TxAddFrame
;;;1207   }
000028  bd30              POP      {r4,r5,pc}
;;;1208   
                          ENDP


                          AREA ||i.UART_PROTOCOL_SendLdoV||, CODE, READONLY, ALIGN=1

                  UART_PROTOCOL_SendLdoV PROC
;;;1166   // 发送命令带结果
;;;1167   void UART_PROTOCOL_SendLdoV(uint8 cmdWord, uint32 result)
000000  b530              PUSH     {r4,r5,lr}
;;;1168   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1169   	// 添加命令头
;;;1170   	UART_PROTOCOL_TxAddData(UART_PROTOCOL_CMD_HEAD);
000006  2055              MOVS     r0,#0x55
000008  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;1171   
;;;1172   	// 添加设备地址
;;;1173   	UART_PROTOCOL_TxAddData(UART_PROTOCOL_CMD_DEVICE_ADDR);
00000c  201a              MOVS     r0,#0x1a
00000e  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;1174   
;;;1175   	// 添加命令字
;;;1176   	UART_PROTOCOL_TxAddData(cmdWord);
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;1177   
;;;1178   	// 添加数据长度
;;;1179   	UART_PROTOCOL_TxAddData(4);
000018  2004              MOVS     r0,#4
00001a  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;1180   
;;;1181   	UART_PROTOCOL_TxAddData((result >> 24) & 0xFF);
00001e  0e20              LSRS     r0,r4,#24
000020  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;1182   	UART_PROTOCOL_TxAddData((result >> 16) & 0xFF);
000024  f3c44007          UBFX     r0,r4,#16,#8
000028  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;1183   	UART_PROTOCOL_TxAddData((result >> 8) & 0xFF);
00002c  f3c42007          UBFX     r0,r4,#8,#8
000030  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;1184   	UART_PROTOCOL_TxAddData((result >> 0) & 0xFF);
000034  b2e0              UXTB     r0,r4
000036  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;1185   
;;;1186   	UART_PROTOCOL_TxAddFrame();
00003a  f7fffffe          BL       UART_PROTOCOL_TxAddFrame
;;;1187   }
00003e  bd30              POP      {r4,r5,pc}
;;;1188   
                          ENDP


                          AREA ||i.UART_PROTOCOL_SetTxAtOnceRequest||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL_SetTxAtOnceRequest PROC
;;;1127   // 码表设置立刻下发数据请求标志
;;;1128   void UART_PROTOCOL_SetTxAtOnceRequest(uint32 param)
000000  4a01              LDR      r2,|L17.8|
;;;1129   {
;;;1130   	uartProtocolCB.txAtOnceRequest = (BOOL)param;
000002  f88206e5          STRB     r0,[r2,#0x6e5]
;;;1131   }
000006  4770              BX       lr
;;;1132   
                          ENDP

                  |L17.8|
                          DCD      uartProtocolCB

                          AREA ||i.UART_PROTOCOL_TxAddData||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL_TxAddData PROC
;;;111    // 向发送命令帧队列中添加数据
;;;112    void UART_PROTOCOL_TxAddData(uint8 data)
000000  b570              PUSH     {r4-r6,lr}
;;;113    {
000002  4601              MOV      r1,r0
;;;114    	uint16 head = uartProtocolCB.tx.head;
000004  4c12              LDR      r4,|L18.80|
000006  f8b426d6          LDRH     r2,[r4,#0x6d6]
;;;115    	uint16 end = uartProtocolCB.tx.end;
00000a  f8b436d8          LDRH     r3,[r4,#0x6d8]
;;;116    	UART_PROTOCOL_TX_CMD_FRAME *pCmdFrame = &uartProtocolCB.tx.cmdQueue[uartProtocolCB.tx.end];
00000e  f8b446d8          LDRH     r4,[r4,#0x6d8]
000012  254d              MOVS     r5,#0x4d
000014  436c              MULS     r4,r5,r4
000016  4d0f              LDR      r5,|L18.84|
000018  eb050044          ADD      r0,r5,r4,LSL #1
;;;117    
;;;118    	// 发送缓冲区已满，不予接收
;;;119    	if ((end + 1) % UART_PROTOCOL_TX_QUEUE_SIZE == head)
00001c  1c5c              ADDS     r4,r3,#1
00001e  2505              MOVS     r5,#5
000020  fb94f6f5          SDIV     r6,r4,r5
000024  fb054416          MLS      r4,r5,r6,r4
000028  4294              CMP      r4,r2
00002a  d100              BNE      |L18.46|
                  |L18.44|
;;;120    	{
;;;121    		return;
;;;122    	}
;;;123    
;;;124    	// 队尾命令帧已满，退出
;;;125    	if (pCmdFrame->length >= UART_PROTOCOL_TX_CMD_FRAME_LENGTH_MAX)
;;;126    	{
;;;127    		return;
;;;128    	}
;;;129    	// 数据添加到帧末尾，并更新帧长度
;;;130    	pCmdFrame->buff[pCmdFrame->length] = data;
;;;131    	pCmdFrame->length++;
;;;132    }
00002c  bd70              POP      {r4-r6,pc}
                  |L18.46|
00002e  f8b04098          LDRH     r4,[r0,#0x98]         ;125
000032  2c96              CMP      r4,#0x96              ;125
000034  db00              BLT      |L18.56|
000036  e7f9              B        |L18.44|
                  |L18.56|
000038  f8b05098          LDRH     r5,[r0,#0x98]         ;130
00003c  1c84              ADDS     r4,r0,#2              ;130
00003e  5561              STRB     r1,[r4,r5]            ;130
000040  f8b04098          LDRH     r4,[r0,#0x98]         ;131
000044  1c64              ADDS     r4,r4,#1              ;131
000046  f8a04098          STRH     r4,[r0,#0x98]         ;131
00004a  bf00              NOP      
00004c  e7ee              B        |L18.44|
;;;133    
                          ENDP

00004e  0000              DCW      0x0000
                  |L18.80|
                          DCD      uartProtocolCB
                  |L18.84|
                          DCD      uartProtocolCB+0x3d4

                          AREA ||i.UART_PROTOCOL_TxAddFrame||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL_TxAddFrame PROC
;;;134    // 确认添加命令帧，即承认之前填充的数据为命令帧，将其添加到发送队列中，由main进行调度发送，本函数内会自动校正命令长度，并添加校验码
;;;135    void UART_PROTOCOL_TxAddFrame(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;136    {
;;;137    	uint16 cc = 0;
000002  2300              MOVS     r3,#0
;;;138    	uint16 i = 0;
000004  2200              MOVS     r2,#0
;;;139    	uint16 head = uartProtocolCB.tx.head;
000006  4e25              LDR      r6,|L19.156|
000008  f8b646d6          LDRH     r4,[r6,#0x6d6]
;;;140    	uint16 end = uartProtocolCB.tx.end;
00000c  f8b656d8          LDRH     r5,[r6,#0x6d8]
;;;141    	UART_PROTOCOL_TX_CMD_FRAME *pCmdFrame = &uartProtocolCB.tx.cmdQueue[uartProtocolCB.tx.end];
000010  f8b666d8          LDRH     r6,[r6,#0x6d8]
000014  274d              MOVS     r7,#0x4d
000016  437e              MULS     r6,r7,r6
000018  4f21              LDR      r7,|L19.160|
00001a  eb070046          ADD      r0,r7,r6,LSL #1
;;;142    	uint16 length = pCmdFrame->length;
00001e  f8b01098          LDRH     r1,[r0,#0x98]
;;;143    
;;;144    	// 发送缓冲区已满，不予接收
;;;145    	if ((end + 1) % UART_PROTOCOL_TX_QUEUE_SIZE == head)
000022  1c6e              ADDS     r6,r5,#1
000024  2705              MOVS     r7,#5
000026  fb96fcf7          SDIV     r12,r6,r7
00002a  fb07661c          MLS      r6,r7,r12,r6
00002e  42a6              CMP      r6,r4
000030  d100              BNE      |L19.52|
                  |L19.50|
;;;146    	{
;;;147    		return;
;;;148    	}
;;;149    
;;;150    	// 命令帧长度不足，清除已填充的数据，退出
;;;151    	if (UART_PROTOCOL_CMD_FRAME_LENGTH_MIN - 1 > length) // 减去"校验和"1个字节
;;;152    	{
;;;153    		pCmdFrame->length = 0;
;;;154    
;;;155    		return;
;;;156    	}
;;;157    
;;;158    	// 队尾命令帧已满，退出
;;;159    	if (length >= UART_PROTOCOL_TX_CMD_FRAME_LENGTH_MAX)
;;;160    	{
;;;161    		return;
;;;162    	}
;;;163    
;;;164    	// 重新设置数据长度，系统在准备数据时，填充的"数据长度"可以为任意值，并且不需要添加校验码，在这里重新设置为正确的值
;;;165    	pCmdFrame->buff[UART_PROTOCOL_CMD_LENGTH_INDEX] = length - 3; // 重设数据长度
;;;166    
;;;167    	for (i = 0; i < length; i++)
;;;168    	{
;;;169    		cc ^= pCmdFrame->buff[i];
;;;170    	}
;;;171    	pCmdFrame->buff[pCmdFrame->length++] = ~cc;
;;;172    
;;;173    	uartProtocolCB.tx.end++;
;;;174    	uartProtocolCB.tx.end %= UART_PROTOCOL_TX_QUEUE_SIZE;
;;;175    
;;;176    	// pCB->tx.cmdQueue[pCB->tx.end].length = 0;   //2015.12.2修改
;;;177    }
000032  bdf0              POP      {r4-r7,pc}
                  |L19.52|
000034  2903              CMP      r1,#3                 ;151
000036  da03              BGE      |L19.64|
000038  2600              MOVS     r6,#0                 ;153
00003a  f8a06098          STRH     r6,[r0,#0x98]         ;153
00003e  e7f8              B        |L19.50|
                  |L19.64|
000040  2996              CMP      r1,#0x96              ;159
000042  db00              BLT      |L19.70|
000044  e7f5              B        |L19.50|
                  |L19.70|
000046  1ece              SUBS     r6,r1,#3              ;165
000048  7106              STRB     r6,[r0,#4]            ;165
00004a  2200              MOVS     r2,#0                 ;167
00004c  e004              B        |L19.88|
                  |L19.78|
00004e  1c86              ADDS     r6,r0,#2              ;169
000050  5cb6              LDRB     r6,[r6,r2]            ;169
000052  4073              EORS     r3,r3,r6              ;169
000054  1c56              ADDS     r6,r2,#1              ;167
000056  b2b2              UXTH     r2,r6                 ;167
                  |L19.88|
000058  428a              CMP      r2,r1                 ;167
00005a  dbf8              BLT      |L19.78|
00005c  43de              MVNS     r6,r3                 ;171
00005e  b2f7              UXTB     r7,r6                 ;171
000060  f8b0c098          LDRH     r12,[r0,#0x98]        ;171
000064  f10c0601          ADD      r6,r12,#1             ;171
000068  f8a06098          STRH     r6,[r0,#0x98]         ;171
00006c  1c86              ADDS     r6,r0,#2              ;171
00006e  f806700c          STRB     r7,[r6,r12]           ;171
000072  4e0a              LDR      r6,|L19.156|
000074  f8b666d8          LDRH     r6,[r6,#0x6d8]        ;173
000078  1c76              ADDS     r6,r6,#1              ;173
00007a  b2b7              UXTH     r7,r6                 ;173
00007c  4e07              LDR      r6,|L19.156|
00007e  f8a676d8          STRH     r7,[r6,#0x6d8]        ;173
000082  f8b666d8          LDRH     r6,[r6,#0x6d8]        ;174
000086  2705              MOVS     r7,#5                 ;174
000088  fb96fcf7          SDIV     r12,r6,r7             ;174
00008c  fb07661c          MLS      r6,r7,r12,r6          ;174
000090  b2b7              UXTH     r7,r6                 ;174
000092  4e02              LDR      r6,|L19.156|
000094  f8a676d8          STRH     r7,[r6,#0x6d8]        ;174
000098  bf00              NOP      
00009a  e7ca              B        |L19.50|
;;;178    
                          ENDP

                  |L19.156|
                          DCD      uartProtocolCB
                  |L19.160|
                          DCD      uartProtocolCB+0x3d4

                          AREA ||i.UART_PROTOCOL_TxAddFrame_3A||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL_TxAddFrame_3A PROC
;;;178    
;;;179    void UART_PROTOCOL_TxAddFrame_3A(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;180    {
;;;181    	uint16 checkSum = 0;
000002  2200              MOVS     r2,#0
;;;182    	uint16 i = 0;
000004  2300              MOVS     r3,#0
;;;183    	uint16 head = uartProtocolCB3.tx.head;
000006  4e3a              LDR      r6,|L20.240|
000008  f8b643da          LDRH     r4,[r6,#0x3da]
;;;184    	uint16 end = uartProtocolCB3.tx.end;
00000c  f8b653dc          LDRH     r5,[r6,#0x3dc]
;;;185    	UART_PROTOCOL3_TX_CMD_FRAME *pCmdFrame = &uartProtocolCB3.tx.cmdQueue[uartProtocolCB.tx.end];
000010  4e38              LDR      r6,|L20.244|
000012  f8b666d8          LDRH     r6,[r6,#0x6d8]
000016  eb060786          ADD      r7,r6,r6,LSL #2
00001a  eb0707c6          ADD      r7,r7,r6,LSL #3
00001e  4e36              LDR      r6,|L20.248|
000020  eb0600c7          ADD      r0,r6,r7,LSL #3
;;;186    	uint16 length = pCmdFrame->length;
000024  f8b01066          LDRH     r1,[r0,#0x66]
;;;187    
;;;188    	// 发送缓冲区已满，不予接收
;;;189    	if ((end + 1) % UART_PROTOCOL3_TX_QUEUE_SIZE == head)
000028  1c6e              ADDS     r6,r5,#1
00002a  2703              MOVS     r7,#3
00002c  fb96fcf7          SDIV     r12,r6,r7
000030  fb07661c          MLS      r6,r7,r12,r6
000034  42a6              CMP      r6,r4
000036  d100              BNE      |L20.58|
                  |L20.56|
;;;190    	{
;;;191    		return;
;;;192    	}
;;;193    
;;;194    	// 命令帧长度不足，清除已填充的数据，退出
;;;195    	if (UART_PROTOCOL3_CMD_FRAME_LENGTH_MIN - 4 > length) // 减去"校验和L、校验和H、结束标识0xD、结束标识OxA"4个字节
;;;196    	{
;;;197    		pCmdFrame->length = 0;
;;;198    
;;;199    		return;
;;;200    	}
;;;201    
;;;202    	// 队尾命令帧已满，退出
;;;203    	if ((length >= UART_PROTOCOL3_TX_CMD_FRAME_LENGTH_MAX) || (length + 1 >= UART_PROTOCOL3_TX_CMD_FRAME_LENGTH_MAX) || (length + 2 >= UART_PROTOCOL3_TX_CMD_FRAME_LENGTH_MAX) || (length + 3 >= UART_PROTOCOL3_TX_CMD_FRAME_LENGTH_MAX))
;;;204    	{
;;;205    		return;
;;;206    	}
;;;207    
;;;208    	// 重新设置数据长度，系统在准备数据时，填充的"数据长度"可以为任意值，并且不需要添加校验码，在这里重新设置为正确的值
;;;209    	pCmdFrame->buff[UART_PROTOCOL3_CMD_LENGTH_INDEX] = length - 4; // 重设数据长度，减去"命令头、设备地址、命令字、数据长度"4个字节
;;;210    	for (i = 1; i < length; i++)
;;;211    	{
;;;212    		checkSum += pCmdFrame->buff[i];
;;;213    	}
;;;214    	pCmdFrame->buff[pCmdFrame->length++] = (checkSum & 0x00FF);		   // 低字节在前
;;;215    	pCmdFrame->buff[pCmdFrame->length++] = ((checkSum >> 8) & 0x00FF); // 高字节在后
;;;216    
;;;217    	// 结束标识
;;;218    	pCmdFrame->buff[pCmdFrame->length++] = 0x0D;
;;;219    	pCmdFrame->buff[pCmdFrame->length++] = 0x0A;
;;;220    
;;;221    	uartProtocolCB3.tx.end++;
;;;222    	uartProtocolCB3.tx.end %= UART_PROTOCOL3_TX_QUEUE_SIZE;
;;;223    }
000038  bdf0              POP      {r4-r7,pc}
                  |L20.58|
00003a  2904              CMP      r1,#4                 ;195
00003c  da03              BGE      |L20.70|
00003e  2600              MOVS     r6,#0                 ;197
000040  f8a06066          STRH     r6,[r0,#0x66]         ;197
000044  e7f8              B        |L20.56|
                  |L20.70|
000046  2964              CMP      r1,#0x64              ;203
000048  da08              BGE      |L20.92|
00004a  1c4e              ADDS     r6,r1,#1              ;203
00004c  2e64              CMP      r6,#0x64              ;203
00004e  da05              BGE      |L20.92|
000050  1c8e              ADDS     r6,r1,#2              ;203
000052  2e64              CMP      r6,#0x64              ;203
000054  da02              BGE      |L20.92|
000056  1cce              ADDS     r6,r1,#3              ;203
000058  2e64              CMP      r6,#0x64              ;203
00005a  db00              BLT      |L20.94|
                  |L20.92|
00005c  e7ec              B        |L20.56|
                  |L20.94|
00005e  1f0e              SUBS     r6,r1,#4              ;209
000060  7146              STRB     r6,[r0,#5]            ;209
000062  2301              MOVS     r3,#1                 ;210
000064  e005              B        |L20.114|
                  |L20.102|
000066  1c86              ADDS     r6,r0,#2              ;212
000068  5cf6              LDRB     r6,[r6,r3]            ;212
00006a  4416              ADD      r6,r6,r2              ;212
00006c  b2b2              UXTH     r2,r6                 ;212
00006e  1c5e              ADDS     r6,r3,#1              ;210
000070  b2b3              UXTH     r3,r6                 ;210
                  |L20.114|
000072  428b              CMP      r3,r1                 ;210
000074  dbf7              BLT      |L20.102|
000076  f8b0c066          LDRH     r12,[r0,#0x66]        ;214
00007a  f10c0601          ADD      r6,r12,#1             ;214
00007e  f8a06066          STRH     r6,[r0,#0x66]         ;214
000082  1c86              ADDS     r6,r0,#2              ;214
000084  f806200c          STRB     r2,[r6,r12]           ;214
000088  0a17              LSRS     r7,r2,#8              ;215
00008a  f8b0c066          LDRH     r12,[r0,#0x66]        ;215
00008e  f10c0601          ADD      r6,r12,#1             ;215
000092  f8a06066          STRH     r6,[r0,#0x66]         ;215
000096  1c86              ADDS     r6,r0,#2              ;215
000098  f806700c          STRB     r7,[r6,r12]           ;215
00009c  270d              MOVS     r7,#0xd               ;218
00009e  f8b0c066          LDRH     r12,[r0,#0x66]        ;218
0000a2  f10c0601          ADD      r6,r12,#1             ;218
0000a6  f8a06066          STRH     r6,[r0,#0x66]         ;218
0000aa  1c86              ADDS     r6,r0,#2              ;218
0000ac  f806700c          STRB     r7,[r6,r12]           ;218
0000b0  270a              MOVS     r7,#0xa               ;219
0000b2  f8b0c066          LDRH     r12,[r0,#0x66]        ;219
0000b6  f10c0601          ADD      r6,r12,#1             ;219
0000ba  f8a06066          STRH     r6,[r0,#0x66]         ;219
0000be  1c86              ADDS     r6,r0,#2              ;219
0000c0  f806700c          STRB     r7,[r6,r12]           ;219
0000c4  4e0a              LDR      r6,|L20.240|
0000c6  f8b663dc          LDRH     r6,[r6,#0x3dc]        ;221
0000ca  1c76              ADDS     r6,r6,#1              ;221
0000cc  b2b7              UXTH     r7,r6                 ;221
0000ce  4e08              LDR      r6,|L20.240|
0000d0  f8a673dc          STRH     r7,[r6,#0x3dc]        ;221
0000d4  f8b663dc          LDRH     r6,[r6,#0x3dc]        ;222
0000d8  2703              MOVS     r7,#3                 ;222
0000da  fb96fcf7          SDIV     r12,r6,r7             ;222
0000de  fb07661c          MLS      r6,r7,r12,r6          ;222
0000e2  b2b7              UXTH     r7,r6                 ;222
0000e4  4e02              LDR      r6,|L20.240|
0000e6  f8a673dc          STRH     r7,[r6,#0x3dc]        ;222
0000ea  bf00              NOP      
0000ec  e7a4              B        |L20.56|
;;;224    
                          ENDP

0000ee  0000              DCW      0x0000
                  |L20.240|
                          DCD      uartProtocolCB3
                  |L20.244|
                          DCD      uartProtocolCB
                  |L20.248|
                          DCD      uartProtocolCB3+0x2a2

                          AREA ||i.UART_PROTOCOL_TxStateProcess||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL_TxStateProcess PROC
;;;314    // 协议层发送处理过程
;;;315    void UART_PROTOCOL_TxStateProcess(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;316    {
;;;317    	uint16 head = uartProtocolCB.tx.head;
000004  4821              LDR      r0,|L21.140|
000006  f8b046d6          LDRH     r4,[r0,#0x6d6]
;;;318    	uint16 end = uartProtocolCB.tx.end;
00000a  f8b056d8          LDRH     r5,[r0,#0x6d8]
;;;319    	uint16 length = uartProtocolCB.tx.cmdQueue[head].length;
00000e  204d              MOVS     r0,#0x4d
000010  4360              MULS     r0,r4,r0
000012  491f              LDR      r1,|L21.144|
000014  eb010040          ADD      r0,r1,r0,LSL #1
000018  f8b06098          LDRH     r6,[r0,#0x98]
;;;320    	uint8 *pCmd = uartProtocolCB.tx.cmdQueue[head].buff;
00001c  204d              MOVS     r0,#0x4d
00001e  4360              MULS     r0,r4,r0
000020  eb010040          ADD      r0,r1,r0,LSL #1
000024  1c87              ADDS     r7,r0,#2
;;;321    	uint16 localDeviceID = uartProtocolCB.tx.cmdQueue[head].deviceID;
000026  204d              MOVS     r0,#0x4d
000028  4360              MULS     r0,r4,r0
00002a  f8318010          LDRH     r8,[r1,r0,LSL #1]
;;;322    
;;;323    	// 发送缓冲区为空，说明无数据
;;;324    	if (head == end)
00002e  42ac              CMP      r4,r5
000030  d101              BNE      |L21.54|
                  |L21.50|
;;;325    	{
;;;326    		return;
;;;327    	}
;;;328    
;;;329    	// 发送函数没有注册直接返回
;;;330    	if (NULL == uartProtocolCB.sendDataThrowService)
;;;331    	{
;;;332    		return;
;;;333    	}
;;;334    
;;;335    	// 协议层有数据需要发送到驱动层
;;;336    	if (!(*uartProtocolCB.sendDataThrowService)(localDeviceID, pCmd, length))
;;;337    	{
;;;338    		return;
;;;339    	}
;;;340    
;;;341    	// 发送环形队列更新位置
;;;342    	uartProtocolCB.tx.cmdQueue[head].length = 0;
;;;343    	uartProtocolCB.tx.head++;
;;;344    	uartProtocolCB.tx.head %= UART_PROTOCOL_TX_QUEUE_SIZE;
;;;345    }
000032  e8bd81f0          POP      {r4-r8,pc}
                  |L21.54|
000036  4815              LDR      r0,|L21.140|
000038  f8d006e0          LDR      r0,[r0,#0x6e0]        ;330  ; uartProtocolCB
00003c  b900              CBNZ     r0,|L21.64|
00003e  e7f8              B        |L21.50|
                  |L21.64|
000040  4812              LDR      r0,|L21.140|
000042  4632              MOV      r2,r6                 ;336
000044  4639              MOV      r1,r7                 ;336
000046  f8d036e0          LDR      r3,[r0,#0x6e0]        ;336  ; uartProtocolCB
00004a  4640              MOV      r0,r8                 ;336
00004c  4798              BLX      r3                    ;336
00004e  b900              CBNZ     r0,|L21.82|
000050  e7ef              B        |L21.50|
                  |L21.82|
000052  2200              MOVS     r2,#0                 ;342
000054  204d              MOVS     r0,#0x4d              ;342
000056  4360              MULS     r0,r4,r0              ;342
000058  490d              LDR      r1,|L21.144|
00005a  eb010040          ADD      r0,r1,r0,LSL #1       ;342
00005e  f8a02098          STRH     r2,[r0,#0x98]         ;342
000062  480a              LDR      r0,|L21.140|
000064  f8b006d6          LDRH     r0,[r0,#0x6d6]        ;343
000068  1c40              ADDS     r0,r0,#1              ;343
00006a  b281              UXTH     r1,r0                 ;343
00006c  4807              LDR      r0,|L21.140|
00006e  f8a016d6          STRH     r1,[r0,#0x6d6]        ;343
000072  f8b006d6          LDRH     r0,[r0,#0x6d6]        ;344
000076  2105              MOVS     r1,#5                 ;344
000078  fb90f2f1          SDIV     r2,r0,r1              ;344
00007c  fb010012          MLS      r0,r1,r2,r0           ;344
000080  b281              UXTH     r1,r0                 ;344
000082  4802              LDR      r0,|L21.140|
000084  f8a016d6          STRH     r1,[r0,#0x6d6]        ;344
000088  bf00              NOP      
00008a  e7d2              B        |L21.50|
;;;346    
                          ENDP

                  |L21.140|
                          DCD      uartProtocolCB
                  |L21.144|
                          DCD      uartProtocolCB+0x3d4

                          AREA ||i.setDutConfig||, CODE, READONLY, ALIGN=1

                  setDutConfig PROC
;;;534    
;;;535    void setDutConfig(uint32 temp)
000000  b530              PUSH     {r4,r5,lr}
;;;536    {
000002  b099              SUB      sp,sp,#0x64
000004  4605              MOV      r5,r0
;;;537    	/*发送dut配置信息*/
;;;538    	uint8 configs[100] = {0};
000006  2164              MOVS     r1,#0x64
000008  4668              MOV      r0,sp
00000a  f7fffffe          BL       __aeabi_memclr4
;;;539    	uint8 i;
;;;540    
;;;541    	SPI_FLASH_ReadArray(configs, SPI_FLASH_DUT_CONFIG_ADDEESS, 60); // 实际只有54个字节
00000e  223c              MOVS     r2,#0x3c
000010  f44f11b0          MOV      r1,#0x160000
000014  4668              MOV      r0,sp
000016  f7fffffe          BL       SPI_FLASH_ReadArray
;;;542    
;;;543    	// DUT上电
;;;544    	DUTCTRL_PowerOnOff(1);
00001a  2001              MOVS     r0,#1
00001c  f7fffffe          BL       DUTCTRL_PowerOnOff
;;;545    
;;;546    	// 添加命令头
;;;547    	UART_PROTOCOL3_TxAddData(UART_PROTOCOL3_CMD_HEAD);
000020  203a              MOVS     r0,#0x3a
000022  f7fffffe          BL       UART_PROTOCOL3_TxAddData
;;;548    
;;;549    	// 添加设备地址
;;;550    	UART_PROTOCOL3_TxAddData(UART_PROTOCOL_CMD_DEVICE_ADDR);
000026  201a              MOVS     r0,#0x1a
000028  f7fffffe          BL       UART_PROTOCOL3_TxAddData
;;;551    
;;;552    	// 添加命令字
;;;553    	UART_PROTOCOL3_TxAddData(UART_PROTOCOL_CMD_WRITE_CONTROL_PARAM); // 0xc0
00002c  20c0              MOVS     r0,#0xc0
00002e  f7fffffe          BL       UART_PROTOCOL3_TxAddData
;;;554    
;;;555    	// 添加数据长度
;;;556    	UART_PROTOCOL3_TxAddData(54);
000032  2036              MOVS     r0,#0x36
000034  f7fffffe          BL       UART_PROTOCOL3_TxAddData
;;;557    
;;;558    	// 写入结果
;;;559    	// UART_PROTOCOL3_TxAddData(1);//背光亮度1，看现象
;;;560    	for (i = 0; i < 54; i++)
000038  2400              MOVS     r4,#0
00003a  e005              B        |L22.72|
                  |L22.60|
;;;561    	{
;;;562    		UART_PROTOCOL3_TxAddData(configs[i]);
00003c  f81d0004          LDRB     r0,[sp,r4]
000040  f7fffffe          BL       UART_PROTOCOL3_TxAddData
000044  1c60              ADDS     r0,r4,#1              ;560
000046  b2c4              UXTB     r4,r0                 ;560
                  |L22.72|
000048  2c36              CMP      r4,#0x36              ;560
00004a  dbf7              BLT      |L22.60|
;;;563    	}
;;;564    	// 添加检验和与结束符，并添加至发送
;;;565    	UART_PROTOCOL3_TxAddFrame();
00004c  f7fffffe          BL       UART_PROTOCOL3_TxAddFrame
;;;566    }
000050  b019              ADD      sp,sp,#0x64
000052  bd30              POP      {r4,r5,pc}
;;;567    
                          ENDP


                          AREA ||i.uartProtocol_SendOnePacket||, CODE, READONLY, ALIGN=2

                  uartProtocol_SendOnePacket PROC
;;;567    
;;;568    void uartProtocol_SendOnePacket(uint32 flashAddr, uint32 addr)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;569    {
000004  b0a6              SUB      sp,sp,#0x98
000006  4606              MOV      r6,r0
000008  460c              MOV      r4,r1
;;;570    	uint8 addr1, addr2, addr3, addr4;
;;;571    	uint8 appUpdateOnePacket[150] = {0};
00000a  2198              MOVS     r1,#0x98
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       __aeabi_memclr4
;;;572    	uint8 appUpdateOnePacket_i = 0;
000012  2500              MOVS     r5,#0
;;;573    	addr1 = (addr & 0xFF000000) >> 24;
000014  0e27              LSRS     r7,r4,#24
;;;574    	addr2 = (addr & 0x00FF0000) >> 16;
000016  f3c44807          UBFX     r8,r4,#16,#8
;;;575    	addr3 = (addr & 0x0000FF00) >> 8;
00001a  f3c42907          UBFX     r9,r4,#8,#8
;;;576    	addr4 = (addr & 0x000000FF);
00001e  f0040aff          AND      r10,r4,#0xff
;;;577    	SPI_FLASH_ReadArray(appUpdateOnePacket, flashAddr + addr, 128); // 工具读取128字节
000022  1931              ADDS     r1,r6,r4
000024  2280              MOVS     r2,#0x80
000026  4668              MOV      r0,sp
000028  f7fffffe          BL       SPI_FLASH_ReadArray
;;;578    
;;;579    	UART_PROTOCOL_TxAddData(UART_PROTOCOL_CMD_HEAD); // 头
00002c  2055              MOVS     r0,#0x55
00002e  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;580    	if (dut_info.appUpFlag)
000032  4815              LDR      r0,|L23.136|
000034  7ec0              LDRB     r0,[r0,#0x1b]  ; dut_info
000036  b118              CBZ      r0,|L23.64|
;;;581    	{
;;;582    		UART_PROTOCOL_TxAddData(UART_CMD_UP_APP_UP); // 命令0x06
000038  2006              MOVS     r0,#6
00003a  f7fffffe          BL       UART_PROTOCOL_TxAddData
00003e  e005              B        |L23.76|
                  |L23.64|
;;;583    	}
;;;584    	else if (dut_info.uiUpFlag)
000040  4811              LDR      r0,|L23.136|
000042  7f40              LDRB     r0,[r0,#0x1d]  ; dut_info
000044  b110              CBZ      r0,|L23.76|
;;;585    	{
;;;586    		UART_PROTOCOL_TxAddData(UART_CMD_DUT_UI_DATA_WRITE); // 命令0x14
000046  2014              MOVS     r0,#0x14
000048  f7fffffe          BL       UART_PROTOCOL_TxAddData
                  |L23.76|
;;;587    	}
;;;588    	UART_PROTOCOL_TxAddData(0x00);													   // 长度暂时为0
00004c  2000              MOVS     r0,#0
00004e  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;589    	UART_PROTOCOL_TxAddData(addr1);													   // 添加地址
000052  4638              MOV      r0,r7
000054  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;590    	UART_PROTOCOL_TxAddData(addr2);													   // 添加地址
000058  4640              MOV      r0,r8
00005a  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;591    	UART_PROTOCOL_TxAddData(addr3);													   // 添加地址
00005e  4648              MOV      r0,r9
000060  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;592    	UART_PROTOCOL_TxAddData(addr4);													   // 添加地址
000064  4650              MOV      r0,r10
000066  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;593    	for (appUpdateOnePacket_i = 0; appUpdateOnePacket_i < 128; appUpdateOnePacket_i++) // 添加数据
00006a  2500              MOVS     r5,#0
00006c  e005              B        |L23.122|
                  |L23.110|
;;;594    	{
;;;595    		UART_PROTOCOL_TxAddData(appUpdateOnePacket[appUpdateOnePacket_i]);
00006e  f81d0005          LDRB     r0,[sp,r5]
000072  f7fffffe          BL       UART_PROTOCOL_TxAddData
000076  1c68              ADDS     r0,r5,#1              ;593
000078  b2c5              UXTB     r5,r0                 ;593
                  |L23.122|
00007a  2d80              CMP      r5,#0x80              ;593
00007c  dbf7              BLT      |L23.110|
;;;596    	}
;;;597    	UART_PROTOCOL_TxAddFrame(); // 调整帧格式,修改长度和添加校验
00007e  f7fffffe          BL       UART_PROTOCOL_TxAddFrame
;;;598    }
000082  b026              ADD      sp,sp,#0x98
000084  e8bd87f0          POP      {r4-r10,pc}
;;;599    
                          ENDP

                  |L23.136|
                          DCD      dut_info

                          AREA ||i.uartProtocol_SendOnePacket_Hex||, CODE, READONLY, ALIGN=2

                  uartProtocol_SendOnePacket_Hex PROC
;;;599    
;;;600    void uartProtocol_SendOnePacket_Hex(uint32 flashAddr)
000000  b530              PUSH     {r4,r5,lr}
;;;601    {
000002  b0a7              SUB      sp,sp,#0x9c
000004  4605              MOV      r5,r0
;;;602    	uint8 appUpdateOnePacket[150] = {0};
000006  2198              MOVS     r1,#0x98
000008  a801              ADD      r0,sp,#4
00000a  f7fffffe          BL       __aeabi_memclr4
;;;603    	uint8 appUpdateOnePacket_i = 0;															 // app起始地址
00000e  bf00              NOP      
;;;604    	SPI_FLASH_ReadArray(appUpdateOnePacket, flashAddr + dut_info.currentAppSize * 116, 116); // 工具读取 4+112 个字节
000010  481c              LDR      r0,|L24.132|
000012  6b00              LDR      r0,[r0,#0x30]  ; dut_info
000014  eb000240          ADD      r2,r0,r0,LSL #1
000018  ebc21040          RSB      r0,r2,r0,LSL #5
00001c  eb050180          ADD      r1,r5,r0,LSL #2
000020  2274              MOVS     r2,#0x74
000022  a801              ADD      r0,sp,#4
000024  f7fffffe          BL       SPI_FLASH_ReadArray
;;;605    	UART_PROTOCOL_TxAddData(UART_PROTOCOL_CMD_HEAD);										 // 添加命令头;//头
000028  2055              MOVS     r0,#0x55
00002a  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;606    	UART_PROTOCOL_TxAddData(UART_CMD_DUT_APP_WRITE_FLASH);									 // 命令
00002e  2026              MOVS     r0,#0x26
000030  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;607    	UART_PROTOCOL_TxAddData(0x00);															 // 添加临时数据长度
000034  2000              MOVS     r0,#0
000036  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;608    	UART_PROTOCOL_TxAddData(0);																 // 添加是否加密
00003a  2000              MOVS     r0,#0
00003c  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;609    	UART_PROTOCOL_TxAddData(0);																 // 添加密钥
000040  2000              MOVS     r0,#0
000042  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;610    	UART_PROTOCOL_TxAddData(appUpdateOnePacket[0]);											 // 添加地址
000046  f89d0004          LDRB     r0,[sp,#4]
00004a  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;611    	UART_PROTOCOL_TxAddData(appUpdateOnePacket[1]);											 // 添加地址
00004e  f89d0005          LDRB     r0,[sp,#5]
000052  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;612    	UART_PROTOCOL_TxAddData(appUpdateOnePacket[2]);											 // 添加地址
000056  f89d0006          LDRB     r0,[sp,#6]
00005a  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;613    	UART_PROTOCOL_TxAddData(appUpdateOnePacket[3]);											 // 添加地址
00005e  f89d0007          LDRB     r0,[sp,#7]
000062  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;614    
;;;615    	for (appUpdateOnePacket_i = 0; appUpdateOnePacket_i < 112; appUpdateOnePacket_i++) // 添加数据
000066  2400              MOVS     r4,#0
000068  e006              B        |L24.120|
                  |L24.106|
;;;616    	{
;;;617    		UART_PROTOCOL_TxAddData(appUpdateOnePacket[appUpdateOnePacket_i + 4]);
00006a  aa01              ADD      r2,sp,#4
00006c  1d21              ADDS     r1,r4,#4
00006e  5c50              LDRB     r0,[r2,r1]
000070  f7fffffe          BL       UART_PROTOCOL_TxAddData
000074  1c60              ADDS     r0,r4,#1              ;615
000076  b2c4              UXTB     r4,r0                 ;615
                  |L24.120|
000078  2c70              CMP      r4,#0x70              ;615
00007a  dbf6              BLT      |L24.106|
;;;618    	}
;;;619    	UART_PROTOCOL_TxAddFrame(); // 调整帧格式,修改长度和添加校验
00007c  f7fffffe          BL       UART_PROTOCOL_TxAddFrame
;;;620    }
000080  b027              ADD      sp,sp,#0x9c
000082  bd30              POP      {r4,r5,pc}
;;;621    
                          ENDP

                  |L24.132|
                          DCD      dut_info

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  uartProtocolCB
                          %        1768

;*** Start embedded assembler ***

#line 1 "User\\UartProtocol.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_UartProtocol_c_4a880db2____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___14_UartProtocol_c_4a880db2____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_UartProtocol_c_4a880db2____REVSH|
#line 128
|__asm___14_UartProtocol_c_4a880db2____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
