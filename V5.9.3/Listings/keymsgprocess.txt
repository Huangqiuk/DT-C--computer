; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\keymsgprocess.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\keymsgprocess.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -I.\User\qrencode -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.1\Device\Include -D__MICROLIB -D__UVISION_VERSION=534 -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\keymsgprocess.crf User\keyMsgProcess.c]
                          THUMB

                          AREA ||i.KEYMSG_CALLBACK_Scan||, CODE, READONLY, ALIGN=2

                  KEYMSG_CALLBACK_Scan PROC
;;;211    // 【接口功能】按键处理回调函数，在定时器控制下，被周期调用，实现按键扫描
;;;212    void KEYMSG_CALLBACK_Scan(uint32 param)
000000  4901              LDR      r1,|L1.8|
;;;213    {
;;;214    	keyMsgCB.scanRequest = TRUE;
000002  2001              MOVS     r0,#1
000004  7008              STRB     r0,[r1,#0]
;;;215    }
000006  4770              BX       lr
;;;216    
                          ENDP

                  |L1.8|
                          DCD      ||.bss||

                          AREA ||i.KEYMSG_ClearGlobalMaskRequest||, CODE, READONLY, ALIGN=2

                  KEYMSG_ClearGlobalMaskRequest PROC
;;;555    // 清除全局屏蔽请求
;;;556    void KEYMSG_ClearGlobalMaskRequest(void)
000000  4902              LDR      r1,|L2.12|
;;;557    {
;;;558    	keyMsgCB.globalMaskRequest = FALSE;
000002  2000              MOVS     r0,#0
000004  f88100fc          STRB     r0,[r1,#0xfc]
;;;559    }
000008  4770              BX       lr
;;;560    
                          ENDP

00000a  0000              DCW      0x0000
                  |L2.12|
                          DCD      ||.bss||

                          AREA ||i.KEYMSG_ClearMaskRequest||, CODE, READONLY, ALIGN=2

                  KEYMSG_ClearMaskRequest PROC
;;;543    // 清除指定按键的指定消息的屏蔽请求
;;;544    void KEYMSG_ClearMaskRequest(KEY_NAME_E keyName, KEY_MSG_E keyMsg)
000000  4b03              LDR      r3,|L3.16|
;;;545    {
;;;546    	keyMsgCB.msgMaskRequest[keyName][keyMsg] = FALSE;
000002  2200              MOVS     r2,#0
000004  eb030080          ADD      r0,r3,r0,LSL #2
000008  4408              ADD      r0,r0,r1
00000a  f88020e8          STRB     r2,[r0,#0xe8]
;;;547    }
00000e  4770              BX       lr
;;;548    
                          ENDP

                  |L3.16|
                          DCD      ||.bss||

                          AREA ||i.KEYMSG_GetAddDecKeyUpRecoveryRequest||, CODE, READONLY, ALIGN=2

                  KEYMSG_GetAddDecKeyUpRecoveryRequest PROC
;;;567    // 获取+-键弹起恢复请求
;;;568    BOOL KEYMSG_GetAddDecKeyUpRecoveryRequest(void)
000000  4801              LDR      r0,|L4.8|
;;;569    {
;;;570    	return keyMsgCB.addDecKeyUpRercoveryRequest;
000002  f89000fd          LDRB     r0,[r0,#0xfd]  ; keyMsgCB
;;;571    }
000006  4770              BX       lr
;;;572    
                          ENDP

                  |L4.8|
                          DCD      ||.bss||

                          AREA ||i.KEYMSG_GetAddInfoKeyUpRecoveryRequest||, CODE, READONLY, ALIGN=2

                  KEYMSG_GetAddInfoKeyUpRecoveryRequest PROC
;;;579    // 获取+ i键弹起恢复请求
;;;580    BOOL KEYMSG_GetAddInfoKeyUpRecoveryRequest(void)
000000  4801              LDR      r0,|L5.8|
;;;581    {
;;;582    	return keyMsgCB.addInfoKeyUpRercoveryRequest;
000002  f89000fe          LDRB     r0,[r0,#0xfe]  ; keyMsgCB
;;;583    }
000006  4770              BX       lr
;;;584    
                          ENDP

                  |L5.8|
                          DCD      ||.bss||

                          AREA ||i.KEYMSG_GetGroupKeyUpRecoveryRequest||, CODE, READONLY, ALIGN=2

                  KEYMSG_GetGroupKeyUpRecoveryRequest PROC
;;;592    // 获取组合键恢复请求
;;;593    BOOL KEYMSG_GetGroupKeyUpRecoveryRequest(void)
000000  4801              LDR      r0,|L6.8|
;;;594    {
;;;595    	return keyMsgCB.GroupKeyInvalidRequest;
000002  f8900100          LDRB     r0,[r0,#0x100]  ; keyMsgCB
;;;596    }
000006  4770              BX       lr
                          ENDP

                  |L6.8|
                          DCD      ||.bss||

                          AREA ||i.KEYMSG_Init||, CODE, READONLY, ALIGN=2

                  KEYMSG_Init PROC
;;;82     // 【使用方法】在 main 中大循环之前调用，注意，在调用本接口之前，必须完成定时器模块初始化
;;;83     void KEYMSG_Init(void)
000000  b570              PUSH     {r4-r6,lr}
;;;84     {
;;;85     	uint8 i,j;
;;;86     
;;;87     	// 数据结构初始化
;;;88     	for(i=0; i<KEY_NAME_MAX; i++)
000002  2100              MOVS     r1,#0
;;;89     	{
;;;90     		keyMsgCB.keyMsgInfo[i].end = 0;
000004  4d1f              LDR      r5,|L7.132|
;;;91     		for(j=0; j<KEY_INFO_SIZE; j++)
;;;92     		{
;;;93     			keyMsgCB.keyMsgInfo[i].stateCount[j] = KEY_STATE_MASK;
000006  f44f4300          MOV      r3,#0x8000
00000a  2400              MOVS     r4,#0
                  |L7.12|
00000c  eb010081          ADD      r0,r1,r1,LSL #2       ;90
000010  eb0502c0          ADD      r2,r5,r0,LSL #3       ;90
000014  7114              STRB     r4,[r2,#4]            ;90
000016  2000              MOVS     r0,#0                 ;91
                  |L7.24|
000018  eb020640          ADD      r6,r2,r0,LSL #1
00001c  80f3              STRH     r3,[r6,#6]
00001e  1c40              ADDS     r0,r0,#1              ;91
000020  b2c0              UXTB     r0,r0                 ;91
000022  2802              CMP      r0,#2                 ;91
000024  d3f8              BCC      |L7.24|
;;;94     		}
;;;95     
;;;96     		// 清除所有消息的屏蔽请求
;;;97     		for(j=0; j<KEY_MSG_MAX; j++)
000026  2000              MOVS     r0,#0
;;;98     		{
;;;99     			keyMsgCB.msgMaskRequest[i][j] = FALSE;
000028  eb050281          ADD      r2,r5,r1,LSL #2
                  |L7.44|
00002c  1816              ADDS     r6,r2,r0
00002e  f88640e8          STRB     r4,[r6,#0xe8]
000032  1c40              ADDS     r0,r0,#1              ;97
000034  b2c0              UXTB     r0,r0                 ;97
000036  2804              CMP      r0,#4                 ;97
000038  d3f8              BCC      |L7.44|
00003a  1c49              ADDS     r1,r1,#1              ;88
00003c  b2c9              UXTB     r1,r1                 ;88
00003e  2905              CMP      r1,#5                 ;88
000040  d3e4              BCC      |L7.12|
;;;100    		}
;;;101    	}
;;;102    	for(i=0; i<sizeof(keyMsgCB.keyValue); i++)
000042  2000              MOVS     r0,#0
;;;103    	{
;;;104    		keyMsgCB.keyValue[i] = 0xFF;
000044  21ff              MOVS     r1,#0xff
                  |L7.70|
000046  182a              ADDS     r2,r5,r0
000048  7051              STRB     r1,[r2,#1]
00004a  1c40              ADDS     r0,r0,#1              ;102
00004c  b2c0              UXTB     r0,r0                 ;102
00004e  2800              CMP      r0,#0                 ;102
000050  d0f9              BEQ      |L7.70|
;;;105    		#if 0==KEY_MSG_THROW_KEY_UP_AFTER_REPEAT
;;;106    		keyMsgCB.keyUpMsgMaskBit[i] = 0x00;
;;;107    		#endif
;;;108    	}
;;;109    	
;;;110    	// 消息环形队列初始化
;;;111    	keyMsgCB.msgQueue.head = 0;
000052  f88540cc          STRB     r4,[r5,#0xcc]
;;;112    	keyMsgCB.msgQueue.end  = 0;
000056  f88540cd          STRB     r4,[r5,#0xcd]
;;;113    	for(i=0; i<KEY_MSG_QUEUE_SIZE; i++)
00005a  2000              MOVS     r0,#0
;;;114    	{
;;;115    		keyMsgCB.msgQueue.node[i].keyName = KEY_NAME_NULL;
00005c  2206              MOVS     r2,#6
;;;116    		keyMsgCB.msgQueue.node[i].keyMsg = KEY_MSG_NULL;
00005e  2305              MOVS     r3,#5
                  |L7.96|
000060  eb050140          ADD      r1,r5,r0,LSL #1       ;115
000064  f8012fce          STRB     r2,[r1,#0xce]!        ;115
000068  704b              STRB     r3,[r1,#1]
00006a  1c40              ADDS     r0,r0,#1              ;113
00006c  b2c0              UXTB     r0,r0                 ;113
00006e  280a              CMP      r0,#0xa               ;113
000070  d3f6              BCC      |L7.96|
;;;117    	}
;;;118    	
;;;119    	keyMsgCB.GroupKeyInvalidRequest =  FALSE;
000072  f8854100          STRB     r4,[r5,#0x100]
;;;120    	keyMsgCB.scanRequest = FALSE;
000076  702c              STRB     r4,[r5,#0]
;;;121     
;;;122    	// 按键消息服务初始化
;;;123    	KEYMSG_StopAllService();
000078  f7fffffe          BL       KEYMSG_StopAllService
;;;124    	
;;;125    	// 按键刷新函数接口初始化
;;;126    	keyMsgCB.KeyUpdate = NULL;
00007c  f8c540e4          STR      r4,[r5,#0xe4]  ; keyMsgCB
;;;127    	
;;;128    	// 启动按键扫描
;;;129    //	TIMER_AddTask(TIMER_ID_KEY_SCAN,
;;;130    //					KEY_SCAN_TIME,
;;;131    //					KEYMSG_CALLBACK_Scan,
;;;132    //					0,
;;;133    //					TIMER_LOOP_FOREVER,
;;;134    //					ACTION_MODE_DO_AT_ONCE);
;;;135    }
000080  bd70              POP      {r4-r6,pc}
;;;136    
                          ENDP

000082  0000              DCW      0x0000
                  |L7.132|
                          DCD      ||.bss||

                          AREA ||i.KEYMSG_MsgProcess||, CODE, READONLY, ALIGN=2

                  KEYMSG_MsgProcess PROC
;;;294    // 【接口功能】按键消息处理
;;;295    void KEYMSG_MsgProcess(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;296    {
;;;297    	uint8 i;
;;;298    	KEYMSG_INFO_CB* pKeyInfo = NULL;
;;;299    	uint16 currentCount = 0;	// 当前按键状态计数值
;;;300    	uint16 currentState = 0;	// 当前按键状态
;;;301    	uint16* pStateCount = NULL;	// 当前操作中的状态计数值
;;;302    	
;;;303    	// 遍历当前的状态，根据需要抛出按键消息，添加到按键环形队列中
;;;304    	for(i=0; i<KEY_NAME_MAX; i++)
000002  2500              MOVS     r5,#0
;;;305    	{
;;;306    		// 获取当前按键信息结构体指针
;;;307    		pKeyInfo = &keyMsgCB.keyMsgInfo[i];
000004  4f2e              LDR      r7,|L8.192|
;;;308    		
;;;309    		// 获取当前操作中的按键状态计数值指针
;;;310    		pStateCount = &(pKeyInfo->stateCount[pKeyInfo->end]);
;;;311    		
;;;312    		// 获取当前按键状态
;;;313    		currentState = (*pStateCount) & KEY_STATE_MASK;
;;;314    		
;;;315    		// 获取当前按键状态计数值
;;;316    		currentCount = (*pStateCount) & (~KEY_STATE_MASK);
;;;317    		
;;;318    		// 最高位为0，说明当前状态为按键按下
;;;319    		if(0 == currentState)
;;;320    		{
;;;321    			// 当前状态计数值为1，说明当前状态为第一次出现，需要抛出按下消息
;;;322    			if(1 == currentCount)
;;;323    			{
;;;324    			#if 1==KEY_MSG_SWITCH_DOWN
;;;325    				// 抛出按键按下消息
;;;326    				KEYMSG_ThrowMsg((KEY_NAME_E)i, KEY_MSG_DOWN);
;;;327    			#endif
;;;328    			#if 0==KEY_MSG_THROW_KEY_UP_AFTER_REPEAT	// KEY_UP 屏蔽位置位时，不抛出 KEY_UP 消息
;;;329    				keyMsgCB.keyUpMsgMaskBit[i/8] &= (0x01<<(i%8));	// 按键按下时解除 KEY_UP 限制
;;;330    			#endif
;;;331    				// 计数值清零，即代表已抛出消息
;;;332    				(*pStateCount) &= KEY_STATE_MASK;
;;;333    			}
;;;334    			// 当前状态计数值大于1，则判断是否达到长按门限
;;;335    			else if(currentCount > 1)
;;;336    			{
;;;337    				// 达到长按门限，抛出长按消息，注意这里的判断条件，不能用>，否则将不断抛出长按消息
;;;338    			#if 0==KEY_MSG_USE_SAME_HOLD_THRESHOLD
;;;339    				if(currentCount*KEY_SCAN_TIME == keyHoldThreshHold[i])	// 每个按键使用单独的长按门限
000006  4e2f              LDR      r6,|L8.196|
                  |L8.8|
000008  eb050085          ADD      r0,r5,r5,LSL #2       ;307
00000c  eb0700c0          ADD      r0,r7,r0,LSL #3       ;307
000010  1d00              ADDS     r0,r0,#4              ;307
000012  7801              LDRB     r1,[r0,#0]            ;310
000014  eb000441          ADD      r4,r0,r1,LSL #1       ;310
000018  1ca4              ADDS     r4,r4,#2              ;310
00001a  8820              LDRH     r0,[r4,#0]            ;313
00001c  f4004100          AND      r1,r0,#0x8000         ;313
000020  f4204000          BIC      r0,r0,#0x8000         ;316
000024  b111              CBZ      r1,|L8.44|
;;;340    			#else
;;;341    				if(currentCount*KEY_SCAN_TIME == KEY_HOLD_TIME) // 所有按键使用统一的长按门限
;;;342    			#endif
;;;343    				{
;;;344    				#if 1==KEY_MSG_SWITCH_HOLD
;;;345    				
;;;346    					// 抛出按键长按消息
;;;347    					KEYMSG_ThrowMsg((KEY_NAME_E)i, KEY_MSG_HOLD);
;;;348    
;;;349    					// 当 + 键或 - 键长按时，屏蔽 UP 消息
;;;350    					if((KEY_NAME_ADD == i)||(KEY_NAME_DEC == i))
;;;351    					{
;;;352    						KEYMSG_SetMaskRequest((KEY_NAME_E)i, KEY_MSG_UP);
;;;353    					}
;;;354    				#endif
;;;355    				#if 0==KEY_MSG_THROW_KEY_UP_AFTER_REPEAT	// KEY_UP 屏蔽位置位时，不抛出 KEY_UP 消息
;;;356    					keyMsgCB.keyUpMsgMaskBit[i/8] |= (0x01<<(i%8));	// 按键长按时设置 KEY_UP 限制
;;;357    				#endif
;;;358    					// 计数值增加1，防止下一次重复抛出长按消息
;;;359    					(*pStateCount)++;
;;;360    				}
;;;361    				// 超出长按门限，判断是否达到重复抛出门限
;;;362    			#if 0==KEY_MSG_USE_SAME_HOLD_THRESHOLD
;;;363    				else if(currentCount*KEY_SCAN_TIME >= keyHoldThreshHold[i] + keyRepeatTime[i])	// 每个按键使用单独的长按门限
;;;364    			#else
;;;365    				else if(currentCount*KEY_SCAN_TIME >= KEY_HOLD_TIME + KEY_RETHROW_TIME) // 所有按键使用统一的长按门限
;;;366    			#endif
;;;367    				{
;;;368    				#if 1==KEY_MSG_SWITCH_REPEAT
;;;369    					// 抛出按键重复消息
;;;370    					KEYMSG_ThrowMsg((KEY_NAME_E)i, KEY_MSG_REPEAT);
;;;371    				#endif
;;;372    					
;;;373    					// 将计数值设置为长按门限+1，为下次抛出重复消息做准备
;;;374    					(*pStateCount) &= KEY_STATE_MASK;
;;;375    				#if 0==KEY_MSG_USE_SAME_HOLD_THRESHOLD
;;;376    					(*pStateCount) += (keyHoldThreshHold[i]/KEY_SCAN_TIME) + 1; // 每个按键使用单独的长按门限
;;;377    				#else
;;;378    					(*pStateCount) += (KEY_HOLD_TIME/KEY_SCAN_TIME) + 1;	// 所有按键使用统一的长按门限
;;;379    				#endif
;;;380    				}
;;;381    				// 未达到长按门限，不予处理
;;;382    				else
;;;383    				{}
;;;384    			}
;;;385    			// 当前状态计数值为0，说明已抛出边沿消息，不再予以处理
;;;386    			else
;;;387    			{}
;;;388    		}
;;;389    		// 最高位为1，说明当前状态为按键释放
;;;390    		else
;;;391    		{
;;;392    			// 当前状态计数值为1，说明当前状态为第一次出现，需要抛出释放消息
;;;393    			if(1 == currentCount)
000026  2801              CMP      r0,#1
000028  d03c              BEQ      |L8.164|
00002a  e043              B        |L8.180|
                  |L8.44|
00002c  2801              CMP      r0,#1                 ;322
00002e  d00f              BEQ      |L8.80|
000030  d940              BLS      |L8.180|
000032  f8361015          LDRH     r1,[r6,r5,LSL #1]     ;339
000036  eb000080          ADD      r0,r0,r0,LSL #2       ;339
00003a  ebb10f80          CMP      r1,r0,LSL #2          ;339
00003e  d118              BNE      |L8.114|
000040  2102              MOVS     r1,#2                 ;347
000042  4628              MOV      r0,r5                 ;347
000044  f7fffffe          BL       KEYMSG_ThrowMsg
000048  b15d              CBZ      r5,|L8.98|
00004a  2d02              CMP      r5,#2                 ;350
00004c  d009              BEQ      |L8.98|
00004e  e00c              B        |L8.106|
                  |L8.80|
000050  2100              MOVS     r1,#0                 ;326
000052  4628              MOV      r0,r5                 ;326
000054  f7fffffe          BL       KEYMSG_ThrowMsg
000058  8820              LDRH     r0,[r4,#0]            ;332
00005a  f4004000          AND      r0,r0,#0x8000         ;332
00005e  8020              STRH     r0,[r4,#0]            ;332
000060  e028              B        |L8.180|
                  |L8.98|
000062  2101              MOVS     r1,#1                 ;352
000064  4628              MOV      r0,r5                 ;352
000066  f7fffffe          BL       KEYMSG_SetMaskRequest
                  |L8.106|
00006a  8820              LDRH     r0,[r4,#0]            ;359
00006c  1c40              ADDS     r0,r0,#1              ;359
00006e  8020              STRH     r0,[r4,#0]            ;359
000070  e020              B        |L8.180|
                  |L8.114|
000072  4a14              LDR      r2,|L8.196|
000074  320a              ADDS     r2,r2,#0xa            ;363
000076  f8322015          LDRH     r2,[r2,r5,LSL #1]     ;363
00007a  4411              ADD      r1,r1,r2              ;363
00007c  ebb10f80          CMP      r1,r0,LSL #2          ;363
000080  d818              BHI      |L8.180|
000082  2103              MOVS     r1,#3                 ;370
000084  4628              MOV      r0,r5                 ;370
000086  f7fffffe          BL       KEYMSG_ThrowMsg
00008a  8820              LDRH     r0,[r4,#0]            ;374
00008c  f4004000          AND      r0,r0,#0x8000         ;374
000090  8020              STRH     r0,[r4,#0]            ;374
000092  f8361015          LDRH     r1,[r6,r5,LSL #1]     ;376
000096  2214              MOVS     r2,#0x14              ;376
000098  fbb1f1f2          UDIV     r1,r1,r2              ;376
00009c  1c49              ADDS     r1,r1,#1              ;376
00009e  4408              ADD      r0,r0,r1              ;376
0000a0  8020              STRH     r0,[r4,#0]            ;376
0000a2  e007              B        |L8.180|
                  |L8.164|
;;;394    			{
;;;395    			#if 1==KEY_MSG_SWITCH_UP
;;;396    				// 抛出按键释放消息
;;;397    				KEYMSG_ThrowMsg((KEY_NAME_E)i, KEY_MSG_UP);
0000a4  2101              MOVS     r1,#1
0000a6  4628              MOV      r0,r5
0000a8  f7fffffe          BL       KEYMSG_ThrowMsg
;;;398    			#endif
;;;399    				
;;;400    				// 计数值清零，即代表已抛出消息
;;;401    				(*pStateCount) &= KEY_STATE_MASK;
0000ac  8820              LDRH     r0,[r4,#0]
0000ae  f4004000          AND      r0,r0,#0x8000
0000b2  8020              STRH     r0,[r4,#0]
                  |L8.180|
0000b4  1c6d              ADDS     r5,r5,#1              ;304
0000b6  b2ed              UXTB     r5,r5                 ;304
0000b8  2d05              CMP      r5,#5                 ;304
0000ba  d3a5              BCC      |L8.8|
;;;402    			}
;;;403    			// 计数值为0时，说明已抛出边沿消息，不再予以处理
;;;404    			// 计数值>1时，为按键释放状态下计数，不予处理
;;;405    			else
;;;406    			{}
;;;407    		}
;;;408    	}
;;;409    }
0000bc  bdf0              POP      {r4-r7,pc}
;;;410    
                          ENDP

0000be  0000              DCW      0x0000
                  |L8.192|
                          DCD      ||.bss||
                  |L8.196|
                          DCD      ||.constdata||

                          AREA ||i.KEYMSG_Process||, CODE, READONLY, ALIGN=1

                  KEYMSG_Process PROC
;;;449    // 【使用方法】在 main 中大循环内调用
;;;450    void KEYMSG_Process(void)
000000  b510              PUSH     {r4,lr}
;;;451    {
;;;452    	// 按键扫描处理
;;;453    	KEYMSG_ScanProcess();
000002  f7fffffe          BL       KEYMSG_ScanProcess
;;;454    	
;;;455    	// 按键消息处理
;;;456    	KEYMSG_MsgProcess();
000006  f7fffffe          BL       KEYMSG_MsgProcess
;;;457    	
;;;458    	// 按键服务处理
;;;459    	KEYMSG_ServiceProcess();
00000a  e8bd4010          POP      {r4,lr}
00000e  f7ffbffe          B.W      KEYMSG_ServiceProcess
;;;460    }
;;;461    
                          ENDP


                          AREA ||i.KEYMSG_RegisterKeyScanCallback||, CODE, READONLY, ALIGN=2

                  KEYMSG_RegisterKeyScanCallback PROC
;;;141    //             并通过此接口向本模块注册，需要注意的是：按键按下为0，按键释放为1
;;;142    void KEYMSG_RegisterKeyScanCallback(void(*fun)(uint8* p8bitKeyValueArray))
000000  4901              LDR      r1,|L10.8|
;;;143    {
;;;144    	keyMsgCB.KeyUpdate = fun;
000002  f8c100e4          STR      r0,[r1,#0xe4]  ; keyMsgCB
;;;145    }
000006  4770              BX       lr
;;;146    
                          ENDP

                  |L10.8|
                          DCD      ||.bss||

                          AREA ||i.KEYMSG_RegisterMsgService||, CODE, READONLY, ALIGN=2

                  KEYMSG_RegisterMsgService PROC
;;;150    // 【使用方法】用于注册按键消息服务，执行之前无须先注销，可直接调用本接口改变消息服务，注册的服务函数的形式必须与本接口中形参一致
;;;151    void KEYMSG_RegisterMsgService(KEY_NAME_E keyName, KEY_MSG_E keyMsg, void(*service)(uint32 param), uint32 param)
000000  b510              PUSH     {r4,lr}
;;;152    {
;;;153    	// 参数合法性检验
;;;154    	if(keyName >= KEY_NAME_MAX)
000002  2805              CMP      r0,#5
000004  d20c              BCS      |L11.32|
;;;155    	{
;;;156    		return ;
;;;157    	}
;;;158    	if(keyMsg >= KEY_MSG_MAX)
000006  2904              CMP      r1,#4
000008  d20a              BCS      |L11.32|
;;;159    	{
;;;160    		return ;
;;;161    	}
;;;162    	if(!service)
00000a  2a00              CMP      r2,#0
00000c  d008              BEQ      |L11.32|
;;;163    	{
;;;164    		return ;
;;;165    	}
;;;166    	
;;;167    	// 配置按键服务
;;;168    	keyMsgCB.keyMsgInfo[keyName].service[keyMsg] = service;
00000e  eb000480          ADD      r4,r0,r0,LSL #2
000012  4804              LDR      r0,|L11.36|
000014  eb0000c4          ADD      r0,r0,r4,LSL #3
000018  eb000081          ADD      r0,r0,r1,LSL #2
00001c  60c2              STR      r2,[r0,#0xc]
;;;169    	keyMsgCB.keyMsgInfo[keyName].param[keyMsg] = param;
00001e  61c3              STR      r3,[r0,#0x1c]
                  |L11.32|
;;;170    }
000020  bd10              POP      {r4,pc}
;;;171    
                          ENDP

000022  0000              DCW      0x0000
                  |L11.36|
                          DCD      ||.bss||

                          AREA ||i.KEYMSG_ScanProcess||, CODE, READONLY, ALIGN=2

                  KEYMSG_ScanProcess PROC
;;;218    // 【接口功能】按键扫描处理
;;;219    void KEYMSG_ScanProcess(void)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;220    {
;;;221    	uint8 i;
;;;222    	KEYMSG_INFO_CB* pKeyInfo = NULL;
;;;223    	uint16 currentKeyBit = 0;	// 当前按键状态，无论哪个按键，都需要把按键值移动到最高位，以便与状态队列中的数值进行比较
;;;224    	
;;;225    	uint16 currentCount = 0;	// 当前按键状态计数值
;;;226    	uint16 currentState = 0;	// 当前按键状态
;;;227    	uint16* pStateCount = NULL;	// 当前操作中的状态计数值
;;;228    
;;;229    	if(!keyMsgCB.scanRequest)
000004  4f22              LDR      r7,|L12.144|
000006  7838              LDRB     r0,[r7,#0]  ; keyMsgCB
000008  2800              CMP      r0,#0
00000a  d03f              BEQ      |L12.140|
;;;230    	{
;;;231    		return ;
;;;232    	}
;;;233    	
;;;234    	keyMsgCB.scanRequest = FALSE;
00000c  2000              MOVS     r0,#0
00000e  7038              STRB     r0,[r7,#0]
;;;235    	
;;;236    	// 调用回调函数读取按键值，未注册回调函数时退出
;;;237    	if(NULL == keyMsgCB.KeyUpdate)
000010  f8d710e4          LDR      r1,[r7,#0xe4]  ; keyMsgCB
000014  2900              CMP      r1,#0
000016  d039              BEQ      |L12.140|
;;;238    	{
;;;239    		return ;
;;;240    	}
;;;241    	(*keyMsgCB.KeyUpdate)(keyMsgCB.keyValue);
000018  1c78              ADDS     r0,r7,#1
00001a  4788              BLX      r1
;;;242    	
;;;243    	// 对每个按键当前的状态进行处理，将按键状态放入各自的按键信息节点中
;;;244    	for(i=0; i<KEY_NAME_MAX; i++)
00001c  2100              MOVS     r1,#0
;;;245    	{
;;;246    		// 获取当前按键信息结构体指针
;;;247    		pKeyInfo = &keyMsgCB.keyMsgInfo[i];
;;;248    		
;;;249    		// 获取当前操作中的按键状态计数值指针
;;;250    		pStateCount = &(pKeyInfo->stateCount[pKeyInfo->end]);
;;;251    		
;;;252    		// 获取当前按键状态
;;;253    		currentState = (*pStateCount) & KEY_STATE_MASK;
;;;254    		
;;;255    		// 获取当前按键状态计数值
;;;256    		currentCount = (*pStateCount) & (~KEY_STATE_MASK);
;;;257    		
;;;258    		// 获取当前读取到的按键状态，并移位
;;;259    		currentKeyBit = keyMsgCB.keyValue[i/8]&(0x01<<(i%8));	// 屏蔽其它按键值，只保留当前按键值
00001e  f04f0801          MOV      r8,#1
                  |L12.34|
000022  eb010081          ADD      r0,r1,r1,LSL #2       ;247
000026  eb0702c0          ADD      r2,r7,r0,LSL #3       ;247
00002a  f812cf04          LDRB     r12,[r2,#4]!          ;250
00002e  eb02034c          ADD      r3,r2,r12,LSL #1      ;250
000032  1c9b              ADDS     r3,r3,#2              ;250
000034  881c              LDRH     r4,[r3,#0]            ;253
000036  f4044900          AND      r9,r4,#0x8000         ;253
00003a  f4244600          BIC      r6,r4,#0x8000         ;256
00003e  eb0700d1          ADD      r0,r7,r1,LSR #3
000042  7845              LDRB     r5,[r0,#1]
000044  f0010007          AND      r0,r1,#7
000048  fa08fa00          LSL      r10,r8,r0
00004c  ea05050a          AND      r5,r5,r10
;;;260    		currentKeyBit <<= 7 + 8 - (i%8);					// 将按键值移位到16bit的最高位
000050  f1c0000f          RSB      r0,r0,#0xf
000054  4085              LSLS     r5,r5,r0
000056  b2ad              UXTH     r5,r5
;;;261    
;;;262    		// 如果当前按键状态与上一次状态相同，则最后一个状态计数值递增
;;;263    		if(currentKeyBit == currentState)
000058  454d              CMP      r5,r9
00005a  d10a              BNE      |L12.114|
;;;264    		{
;;;265    			// 次数未溢出时，可以递增，否则不变
;;;266    			if(currentCount < (KEY_STATE_MASK-1))
00005c  f64770ff          MOV      r0,#0x7fff
000060  4286              CMP      r6,r0
000062  d20f              BCS      |L12.132|
;;;267    			{
;;;268    				// 【计数值处理方法说明】
;;;269    				// 计数值为0，说明当前计数值为1，并且已抛出边沿消息；
;;;270    				// 计数值为1，说明当前计数值为1，但未抛出边沿消息；
;;;271    				// 计数值 >1，代表实际的计数值
;;;272    				// 因此遇到计数值为0时，说明前面已经抛出了边沿消息，计数值需要增加2，以避免重复抛出边沿消息
;;;273    				if(0 == currentCount)
000064  b116              CBZ      r6,|L12.108|
;;;274    				{
;;;275    					(*pStateCount) += 2;
;;;276    				}
;;;277    				else
;;;278    				{
;;;279    					(*pStateCount) ++;
000066  1c64              ADDS     r4,r4,#1
000068  801c              STRH     r4,[r3,#0]
00006a  e00b              B        |L12.132|
                  |L12.108|
00006c  1ca4              ADDS     r4,r4,#2              ;275
00006e  801c              STRH     r4,[r3,#0]            ;275
000070  e008              B        |L12.132|
                  |L12.114|
;;;280    				}
;;;281    			}
;;;282    		}
;;;283    		// 当前按键状态与上一次状态不同，则新增状态，同时触发对应消息
;;;284    		else
;;;285    		{
;;;286    			pKeyInfo->end ++;
000072  f10c0c01          ADD      r12,r12,#1
;;;287    			pKeyInfo->end %= KEY_INFO_SIZE;
000076  f00c0001          AND      r0,r12,#1
00007a  7010              STRB     r0,[r2,#0]
;;;288    			pKeyInfo->stateCount[pKeyInfo->end] = currentKeyBit + 1;	// 当前状态添加到队列末尾，并且计数值赋1
00007c  eb020040          ADD      r0,r2,r0,LSL #1
000080  1c6d              ADDS     r5,r5,#1
000082  8045              STRH     r5,[r0,#2]
                  |L12.132|
000084  1c49              ADDS     r1,r1,#1              ;244
000086  b2c9              UXTB     r1,r1                 ;244
000088  2905              CMP      r1,#5                 ;244
00008a  d3ca              BCC      |L12.34|
                  |L12.140|
;;;289    		}
;;;290    	}
;;;291    }
00008c  e8bd87f0          POP      {r4-r10,pc}
;;;292    
                          ENDP

                  |L12.144|
                          DCD      ||.bss||

                          AREA ||i.KEYMSG_ServiceDoNothing||, CODE, READONLY, ALIGN=1

                  KEYMSG_ServiceDoNothing PROC
;;;73     // 【使用方法】空函数，什么也不做
;;;74     void KEYMSG_ServiceDoNothing(uint32 param)
000000  4770              BX       lr
;;;75     {
;;;76     	return ;
;;;77     }
;;;78     
                          ENDP


                          AREA ||i.KEYMSG_ServiceProcess||, CODE, READONLY, ALIGN=2

                  KEYMSG_ServiceProcess PROC
;;;412    // 【接口功能】按键服务处理
;;;413    void KEYMSG_ServiceProcess(void)
000000  b510              PUSH     {r4,lr}
;;;414    {
;;;415    	KEY_NAME_E keyName;
;;;416    	KEY_MSG_E keyMsg;
;;;417    	void (*service)(uint32 param) = 0;
;;;418    	
;;;419    	// 消息队列为空，退出
;;;420    	if(keyMsgCB.msgQueue.head == keyMsgCB.msgQueue.end)
000002  4c12              LDR      r4,|L14.76|
000004  f89400cc          LDRB     r0,[r4,#0xcc]  ; keyMsgCB
000008  f89410cd          LDRB     r1,[r4,#0xcd]  ; keyMsgCB
00000c  4288              CMP      r0,r1
00000e  d01b              BEQ      |L14.72|
;;;421    	{
;;;422    		return ;
;;;423    	}
;;;424    	
;;;425    	// 取出最早的消息执行
;;;426    	keyName  = keyMsgCB.msgQueue.node[keyMsgCB.msgQueue.head].keyName;
000010  eb040140          ADD      r1,r4,r0,LSL #1
000014  f8110fce          LDRB     r0,[r1,#0xce]!
;;;427    	keyMsg = keyMsgCB.msgQueue.node[keyMsgCB.msgQueue.head].keyMsg;
000018  7849              LDRB     r1,[r1,#1]
;;;428    	
;;;429    	if(keyName >= KEY_NAME_MAX)
00001a  2805              CMP      r0,#5
00001c  d214              BCS      |L14.72|
;;;430    	{
;;;431    		return ;
;;;432    	}
;;;433    	if(keyMsg >= KEY_MSG_MAX)
00001e  2904              CMP      r1,#4
000020  d212              BCS      |L14.72|
;;;434    	{
;;;435    		return ;
;;;436    	}
;;;437    	
;;;438    	// 执行已注册的按键消息服务
;;;439    	service = keyMsgCB.keyMsgInfo[keyName].service[keyMsg];
000022  eb000080          ADD      r0,r0,r0,LSL #2
000026  eb0400c0          ADD      r0,r4,r0,LSL #3
00002a  eb000081          ADD      r0,r0,r1,LSL #2
00002e  68c1              LDR      r1,[r0,#0xc]
;;;440    	(*service)(keyMsgCB.keyMsgInfo[keyName].param[keyMsg]);
000030  69c0              LDR      r0,[r0,#0x1c]
000032  4788              BLX      r1
;;;441    	
;;;442    	keyMsgCB.msgQueue.head ++;
000034  f8140fcc          LDRB     r0,[r4,#0xcc]!  ; keyMsgCB
000038  1c40              ADDS     r0,r0,#1
00003a  b2c0              UXTB     r0,r0
;;;443    	keyMsgCB.msgQueue.head %= KEY_MSG_QUEUE_SIZE;
00003c  210a              MOVS     r1,#0xa
00003e  fbb0f2f1          UDIV     r2,r0,r1
000042  fb010012          MLS      r0,r1,r2,r0
000046  7020              STRB     r0,[r4,#0]
                  |L14.72|
;;;444    }
000048  bd10              POP      {r4,pc}
;;;445    
                          ENDP

00004a  0000              DCW      0x0000
                  |L14.76|
                          DCD      ||.bss||

                          AREA ||i.KEYMSG_SetAddDecKeyUpRecoveryRequest||, CODE, READONLY, ALIGN=2

                  KEYMSG_SetAddDecKeyUpRecoveryRequest PROC
;;;561    // 设置+-键弹起恢复请求
;;;562    void KEYMSG_SetAddDecKeyUpRecoveryRequest(BOOL state)
000000  4901              LDR      r1,|L15.8|
;;;563    {
;;;564    	keyMsgCB.addDecKeyUpRercoveryRequest = state;
000002  f88100fd          STRB     r0,[r1,#0xfd]
;;;565    }
000006  4770              BX       lr
;;;566    
                          ENDP

                  |L15.8|
                          DCD      ||.bss||

                          AREA ||i.KEYMSG_SetAddInfoKeyUpRecoveryRequest||, CODE, READONLY, ALIGN=2

                  KEYMSG_SetAddInfoKeyUpRecoveryRequest PROC
;;;573    // 设置+ i键弹起恢复请求
;;;574    void KEYMSG_SetAddInfoKeyUpRecoveryRequest(BOOL state)
000000  4901              LDR      r1,|L16.8|
;;;575    {
;;;576    	keyMsgCB.addInfoKeyUpRercoveryRequest = state;
000002  f88100fe          STRB     r0,[r1,#0xfe]
;;;577    }
000006  4770              BX       lr
;;;578    
                          ENDP

                  |L16.8|
                          DCD      ||.bss||

                          AREA ||i.KEYMSG_SetGlobalMaskRequest||, CODE, READONLY, ALIGN=2

                  KEYMSG_SetGlobalMaskRequest PROC
;;;549    // 设置全局屏蔽请求
;;;550    void KEYMSG_SetGlobalMaskRequest(void)
000000  4902              LDR      r1,|L17.12|
;;;551    {
;;;552    	keyMsgCB.globalMaskRequest = TRUE;
000002  2001              MOVS     r0,#1
000004  f88100fc          STRB     r0,[r1,#0xfc]
;;;553    }
000008  4770              BX       lr
;;;554    
                          ENDP

00000a  0000              DCW      0x0000
                  |L17.12|
                          DCD      ||.bss||

                          AREA ||i.KEYMSG_SetGroupKeyRecoveryRequest||, CODE, READONLY, ALIGN=2

                  KEYMSG_SetGroupKeyRecoveryRequest PROC
;;;586    // 设置组合键恢复请求
;;;587    void KEYMSG_SetGroupKeyRecoveryRequest(BOOL state)
000000  4901              LDR      r1,|L18.8|
;;;588    {
;;;589    	keyMsgCB.GroupKeyInvalidRequest = state;
000002  f8810100          STRB     r0,[r1,#0x100]
;;;590    }
000006  4770              BX       lr
;;;591    
                          ENDP

                  |L18.8|
                          DCD      ||.bss||

                          AREA ||i.KEYMSG_SetMaskRequest||, CODE, READONLY, ALIGN=2

                  KEYMSG_SetMaskRequest PROC
;;;537    // 设置指定按键的指定消息的屏蔽请求
;;;538    void KEYMSG_SetMaskRequest(KEY_NAME_E keyName, KEY_MSG_E keyMsg)
000000  4b03              LDR      r3,|L19.16|
;;;539    {
;;;540    	keyMsgCB.msgMaskRequest[keyName][keyMsg] = TRUE;
000002  2201              MOVS     r2,#1
000004  eb030080          ADD      r0,r3,r0,LSL #2
000008  4408              ADD      r0,r0,r1
00000a  f88020e8          STRB     r2,[r0,#0xe8]
;;;541    }
00000e  4770              BX       lr
;;;542    
                          ENDP

                  |L19.16|
                          DCD      ||.bss||

                          AREA ||i.KEYMSG_StopAllService||, CODE, READONLY, ALIGN=2

                  KEYMSG_StopAllService PROC
;;;195    // 【使用方法】停止所有按键所有消息的响应
;;;196    void KEYMSG_StopAllService(void)
000000  b530              PUSH     {r4,r5,lr}
;;;197    {
;;;198    	uint8 i,j;
;;;199    	
;;;200    	// 按键消息服务初始化
;;;201    	for(i=0; i<KEY_NAME_MAX; i++)
000002  2100              MOVS     r1,#0
;;;202    	{
;;;203    		for(j=0; j<KEY_MSG_MAX; j++)
;;;204    		{
;;;205    			keyMsgCB.keyMsgInfo[i].service[j] = KEYMSG_ServiceDoNothing;
000004  4a09              LDR      r2,|L20.44|
000006  4d0a              LDR      r5,|L20.48|
                  |L20.8|
000008  2000              MOVS     r0,#0                 ;203
00000a  eb010381          ADD      r3,r1,r1,LSL #2
00000e  eb0503c3          ADD      r3,r5,r3,LSL #3
                  |L20.18|
000012  eb030480          ADD      r4,r3,r0,LSL #2
000016  60e2              STR      r2,[r4,#0xc]
000018  1c40              ADDS     r0,r0,#1              ;203
00001a  b2c0              UXTB     r0,r0                 ;203
00001c  2804              CMP      r0,#4                 ;203
00001e  d3f8              BCC      |L20.18|
000020  1c49              ADDS     r1,r1,#1              ;201
000022  b2c9              UXTB     r1,r1                 ;201
000024  2905              CMP      r1,#5                 ;201
000026  d3ef              BCC      |L20.8|
;;;206    		}
;;;207    	}
;;;208    }
000028  bd30              POP      {r4,r5,pc}
;;;209    
                          ENDP

00002a  0000              DCW      0x0000
                  |L20.44|
                          DCD      KEYMSG_ServiceDoNothing
                  |L20.48|
                          DCD      ||.bss||

                          AREA ||i.KEYMSG_StopService||, CODE, READONLY, ALIGN=2

                  KEYMSG_StopService PROC
;;;175    // 【使用方法】需要停止按键消息响应时，通过本接口停止对指定按键的指定消息的响应
;;;176    void KEYMSG_StopService(KEY_NAME_E keyName, KEY_MSG_E keyMsg)
000000  2805              CMP      r0,#5
;;;177    {
000002  d20a              BCS      |L21.26|
;;;178    	// 参数合法性检验
;;;179    	if(keyName >= KEY_NAME_MAX)
;;;180    	{
;;;181    		return ;
;;;182    	}
;;;183    	if(keyMsg >= KEY_MSG_MAX)
000004  2904              CMP      r1,#4
000006  d208              BCS      |L21.26|
;;;184    	{
;;;185    		return ;
;;;186    	}
;;;187    	
;;;188    	// 将对应按键的对应服务设置为空
;;;189    	keyMsgCB.keyMsgInfo[keyName].service[keyMsg] = KEYMSG_ServiceDoNothing;
000008  4b05              LDR      r3,|L21.32|
00000a  eb000080          ADD      r0,r0,r0,LSL #2
00000e  eb0300c0          ADD      r0,r3,r0,LSL #3
000012  eb000081          ADD      r0,r0,r1,LSL #2
000016  4a01              LDR      r2,|L21.28|
000018  60c2              STR      r2,[r0,#0xc]
                  |L21.26|
;;;190    }
00001a  4770              BX       lr
;;;191    
                          ENDP

                  |L21.28|
                          DCD      KEYMSG_ServiceDoNothing
                  |L21.32|
                          DCD      ||.bss||

                          AREA ||i.KEYMSG_ThrowMsg||, CODE, READONLY, ALIGN=2

                  KEYMSG_ThrowMsg PROC
;;;463    // 【接口功能】抛出按键消息，保存在消息环形队列中
;;;464    uint8 KEYMSG_ThrowMsg(KEY_NAME_E keyName, KEY_MSG_E keyMsg)
000000  b570              PUSH     {r4-r6,lr}
;;;465    {
;;;466    	// 当前按键的当前消息有屏蔽请求，则不添加，并清除屏蔽请求
;;;467    	if(keyMsgCB.msgMaskRequest[keyName][keyMsg])
000002  4a1d              LDR      r2,|L22.120|
000004  eb020380          ADD      r3,r2,r0,LSL #2
000008  440b              ADD      r3,r3,r1
00000a  f89340e8          LDRB     r4,[r3,#0xe8]
00000e  2c00              CMP      r4,#0
000010  d003              BEQ      |L22.26|
;;;468    	{
;;;469    		keyMsgCB.msgMaskRequest[keyName][keyMsg] = FALSE;
000012  2000              MOVS     r0,#0
000014  f88300e8          STRB     r0,[r3,#0xe8]
;;;470    
;;;471    		return 0;
;;;472    	}
;;;473    
;;;474    	// 有全局屏蔽请求，则退出
;;;475    	if(keyMsgCB.globalMaskRequest)
;;;476    	{
;;;477    		return 0;
;;;478    	}
;;;479    	
;;;480    	// 消息队列满，禁止添加
;;;481    	if(((keyMsgCB.msgQueue.end+1)%KEY_MSG_QUEUE_SIZE) == keyMsgCB.msgQueue.head)
;;;482    	{
;;;483    #if 0==KEY_MSG_PRIORITY	// 旧消息优先时，队列满禁止添加
;;;484    	  
;;;485    		return 0;
;;;486    		
;;;487    #else	// 新消息优先时，队列满，删除最早的消息
;;;488    		
;;;489    		keyMsgCB.msgQueue.head ++;
;;;490    		keyMsgCB.msgQueue.head %= KEY_MSG_QUEUE_SIZE;
;;;491    #endif
;;;492    	}
;;;493    	
;;;494    #if 0==KEY_MSG_THROW_KEY_UP_AFTER_REPEAT	// KEY_REPEAT 消息后禁止抛出 KEY_UP 消息
;;;495    	// KEY_UP 屏蔽位置位时，不抛出 KEY_UP 消息，并且清除屏蔽位
;;;496    	if((KEY_MSG_UP == keyMsg) && (keyMsgCB.keyUpMsgMaskBit[keyName/8] & (0x01<<(keyName%8))))
;;;497    	{
;;;498    		keyMsgCB.keyUpMsgMaskBit[keyName/8] &= (0x01<<(keyName%8));
;;;499    	}
;;;500    	else
;;;501    	{
;;;502    		// 添加到队列中
;;;503    		keyMsgCB.msgQueue.node[keyMsgCB.msgQueue.end].keyName  = keyName;
;;;504    		keyMsgCB.msgQueue.node[keyMsgCB.msgQueue.end].keyMsg = keyMsg;
;;;505    		// 队尾后移
;;;506    		keyMsgCB.msgQueue.end ++;
;;;507    		keyMsgCB.msgQueue.end %= KEY_MSG_QUEUE_SIZE;
;;;508    	}
;;;509    #else	// 无论何种情况，按键释放时均抛出 KEY_UP 消息
;;;510    	// 添加到队列中
;;;511    	keyMsgCB.msgQueue.node[keyMsgCB.msgQueue.end].keyName  = keyName;
;;;512    	keyMsgCB.msgQueue.node[keyMsgCB.msgQueue.end].keyMsg = keyMsg;
;;;513    	
;;;514    	// 队尾后移
;;;515    	keyMsgCB.msgQueue.end ++;
;;;516    	keyMsgCB.msgQueue.end %= KEY_MSG_QUEUE_SIZE;
;;;517    #endif
;;;518    
;;;519    	return 1;
;;;520    }
000018  bd70              POP      {r4-r6,pc}
                  |L22.26|
00001a  f89230fc          LDRB     r3,[r2,#0xfc]         ;475  ; keyMsgCB
00001e  b10b              CBZ      r3,|L22.36|
000020  2000              MOVS     r0,#0                 ;477
000022  bd70              POP      {r4-r6,pc}
                  |L22.36|
000024  f89240cd          LDRB     r4,[r2,#0xcd]         ;481  ; keyMsgCB
000028  230a              MOVS     r3,#0xa               ;481
00002a  4625              MOV      r5,r4                 ;481
00002c  1c64              ADDS     r4,r4,#1              ;481
00002e  fbb4f6f3          UDIV     r6,r4,r3              ;481
000032  fb034616          MLS      r6,r3,r6,r4           ;481
000036  f89240cc          LDRB     r4,[r2,#0xcc]         ;481  ; keyMsgCB
00003a  42a6              CMP      r6,r4                 ;481
00003c  d107              BNE      |L22.78|
00003e  1c64              ADDS     r4,r4,#1              ;489
000040  b2e4              UXTB     r4,r4                 ;489
000042  fbb4f6f3          UDIV     r6,r4,r3              ;490
000046  fb034416          MLS      r4,r3,r6,r4           ;490
00004a  f88240cc          STRB     r4,[r2,#0xcc]         ;490
                  |L22.78|
00004e  eb020445          ADD      r4,r2,r5,LSL #1       ;511
000052  f88400ce          STRB     r0,[r4,#0xce]         ;511
000056  f89200cd          LDRB     r0,[r2,#0xcd]         ;512  ; keyMsgCB
00005a  eb020040          ADD      r0,r2,r0,LSL #1       ;512
00005e  f88010cf          STRB     r1,[r0,#0xcf]         ;512
000062  f8120fcd          LDRB     r0,[r2,#0xcd]!        ;515  ; keyMsgCB
000066  1c40              ADDS     r0,r0,#1              ;515
000068  b2c0              UXTB     r0,r0                 ;515
00006a  fbb0f1f3          UDIV     r1,r0,r3              ;516
00006e  fb030011          MLS      r0,r3,r1,r0           ;516
000072  7010              STRB     r0,[r2,#0]            ;516
000074  2001              MOVS     r0,#1                 ;519
000076  bd70              POP      {r4-r6,pc}
;;;521    
                          ENDP

                  |L22.120|
                          DCD      ||.bss||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  keyMsgCB
                          %        260

                          AREA ||.constdata||, DATA, READONLY, ALIGN=1

                  keyHoldThreshHold
000000  03e803e8          DCW      0x03e8,0x03e8
000004  03e807d0          DCW      0x03e8,0x07d0
000008  07d0              DCW      0x07d0
                  keyRepeatTime
00000a  0064              DCW      0x0064
00000c  012c0064          DCW      0x012c,0x0064
000010  012c012c          DCW      0x012c,0x012c

;*** Start embedded assembler ***

#line 1 "User\\keyMsgProcess.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_keyMsgProcess_c_7077c383____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___15_keyMsgProcess_c_7077c383____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_keyMsgProcess_c_7077c383____REVSH|
#line 128
|__asm___15_keyMsgProcess_c_7077c383____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
