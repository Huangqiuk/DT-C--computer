; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\gd32f10x_i2c.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\gd32f10x_i2c.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -I.\User\qrencode -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.3\Device\Include -D__MICROLIB -D__UVISION_VERSION=539 -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\gd32f10x_i2c.crf Libraries\src\gd32f10x_i2c.c]
                          THUMB

                          AREA ||i.i2c_ack_config||, CODE, READONLY, ALIGN=1

                  i2c_ack_config PROC
;;;200    */
;;;201    void i2c_ack_config(uint32_t i2c_periph, uint32_t ack)
000000  2901              CMP      r1,#1
;;;202    {
;;;203        if(I2C_ACK_ENABLE == ack){
000002  d104              BNE      |L1.14|
;;;204            I2C_CTL0(i2c_periph) |= I2C_CTL0_ACKEN;
000004  6802              LDR      r2,[r0,#0]
000006  f4426280          ORR      r2,r2,#0x400
00000a  6002              STR      r2,[r0,#0]
00000c  e003              B        |L1.22|
                  |L1.14|
;;;205        }else{
;;;206            I2C_CTL0(i2c_periph) &= ~(I2C_CTL0_ACKEN);
00000e  6802              LDR      r2,[r0,#0]
000010  f4226280          BIC      r2,r2,#0x400
000014  6002              STR      r2,[r0,#0]
                  |L1.22|
;;;207        }
;;;208    }
000016  4770              BX       lr
;;;209    
                          ENDP


                          AREA ||i.i2c_ackpos_config||, CODE, READONLY, ALIGN=1

                  i2c_ackpos_config PROC
;;;219    */
;;;220    void i2c_ackpos_config(uint32_t i2c_periph, uint32_t pos)
000000  b921              CBNZ     r1,|L2.12|
;;;221    {
;;;222        /* configure I2C POAP position */
;;;223        if(I2C_ACKPOS_NEXT == pos){
;;;224            I2C_CTL0(i2c_periph) |= I2C_CTL0_POAP;
000002  6802              LDR      r2,[r0,#0]
000004  f4426200          ORR      r2,r2,#0x800
000008  6002              STR      r2,[r0,#0]
00000a  e003              B        |L2.20|
                  |L2.12|
;;;225        }else{
;;;226            I2C_CTL0(i2c_periph) &= ~(I2C_CTL0_POAP);
00000c  6802              LDR      r2,[r0,#0]
00000e  f4226200          BIC      r2,r2,#0x800
000012  6002              STR      r2,[r0,#0]
                  |L2.20|
;;;227        }
;;;228    }
000014  4770              BX       lr
;;;229    
                          ENDP


                          AREA ||i.i2c_clock_config||, CODE, READONLY, ALIGN=2

                  i2c_clock_config PROC
;;;86     */
;;;87     void i2c_clock_config(uint32_t i2c_periph, uint32_t clkspeed, uint32_t dutycyc)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;88     {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4693              MOV      r11,r2
;;;89         uint32_t pclk1, clkc, freq, risetime;
;;;90         uint32_t temp;
;;;91         
;;;92         pclk1 = rcu_clock_freq_get(CK_APB1);
00000a  2002              MOVS     r0,#2
00000c  f7fffffe          BL       rcu_clock_freq_get
000010  4607              MOV      r7,r0
;;;93         /* I2C peripheral clock frequency */
;;;94         freq = (uint32_t)(pclk1/1000000U);
000012  4831              LDR      r0,|L3.216|
000014  fbb7f9f0          UDIV     r9,r7,r0
;;;95         if(freq >= I2CCLK_MAX){
000018  f1b90f36          CMP      r9,#0x36
00001c  d301              BCC      |L3.34|
;;;96             freq = I2CCLK_MAX;
00001e  f04f0936          MOV      r9,#0x36
                  |L3.34|
;;;97         }
;;;98         temp = I2C_CTL1(i2c_periph);
000022  f8d4a004          LDR      r10,[r4,#4]
;;;99         temp &= ~I2C_CTL1_I2CCLK;
000026  f02a0a3f          BIC      r10,r10,#0x3f
;;;100        temp |= freq;
00002a  ea4a0a09          ORR      r10,r10,r9
;;;101        
;;;102        I2C_CTL1(i2c_periph) = temp;
00002e  f8c4a004          STR      r10,[r4,#4]
;;;103        
;;;104        if(100000U >= clkspeed){
000032  482a              LDR      r0,|L3.220|
000034  4286              CMP      r6,r0
000036  d81e              BHI      |L3.118|
;;;105            /* the maximum SCL rise time is 1000ns in standard mode */
;;;106            risetime = (uint32_t)((pclk1/1000000U)+1U);
000038  4827              LDR      r0,|L3.216|
00003a  fbb7f0f0          UDIV     r0,r7,r0
00003e  f1000801          ADD      r8,r0,#1
;;;107            if(risetime >= I2CCLK_MAX){
000042  f1b80f36          CMP      r8,#0x36
000046  d302              BCC      |L3.78|
;;;108                I2C_RT(i2c_periph) = I2CCLK_MAX;
000048  2036              MOVS     r0,#0x36
00004a  6220              STR      r0,[r4,#0x20]
00004c  e007              B        |L3.94|
                  |L3.78|
;;;109            }else if(risetime <= I2CCLK_MIN){
00004e  f1b80f02          CMP      r8,#2
000052  d802              BHI      |L3.90|
;;;110                I2C_RT(i2c_periph) = I2CCLK_MIN;
000054  2002              MOVS     r0,#2
000056  6220              STR      r0,[r4,#0x20]
000058  e001              B        |L3.94|
                  |L3.90|
;;;111            }else{
;;;112                I2C_RT(i2c_periph) = risetime;
00005a  f8c48020          STR      r8,[r4,#0x20]
                  |L3.94|
;;;113            }
;;;114            clkc = (uint32_t)(pclk1/(clkspeed*2U)); 
00005e  0070              LSLS     r0,r6,#1
000060  fbb7f5f0          UDIV     r5,r7,r0
;;;115            if(clkc < 0x04U){
000064  2d04              CMP      r5,#4
000066  d200              BCS      |L3.106|
;;;116                /* the CLKC in standard mode minmum value is 4 */
;;;117                clkc = 0x04U;
000068  2504              MOVS     r5,#4
                  |L3.106|
;;;118            }
;;;119            I2C_CKCFG(i2c_periph) |= (I2C_CKCFG_CLKC & clkc);
00006a  69e0              LDR      r0,[r4,#0x1c]
00006c  f3c5010b          UBFX     r1,r5,#0,#12
000070  4308              ORRS     r0,r0,r1
000072  61e0              STR      r0,[r4,#0x1c]
000074  e02e              B        |L3.212|
                  |L3.118|
;;;120    
;;;121        }else if(400000U >= clkspeed){
000076  481a              LDR      r0,|L3.224|
000078  4286              CMP      r6,r0
00007a  d82b              BHI      |L3.212|
;;;122            /* the maximum SCL rise time is 300ns in fast mode */
;;;123            I2C_RT(i2c_periph) = (uint32_t)(((freq*(uint32_t)300U)/(uint32_t)1000U)+(uint32_t)1U);
00007c  f44f7096          MOV      r0,#0x12c
000080  fb09f000          MUL      r0,r9,r0
000084  f44f717a          MOV      r1,#0x3e8
000088  fbb0f0f1          UDIV     r0,r0,r1
00008c  1c40              ADDS     r0,r0,#1
00008e  6220              STR      r0,[r4,#0x20]
;;;124            if(I2C_DTCY_2 == dutycyc){
000090  f1bb0f00          CMP      r11,#0
000094  d108              BNE      |L3.168|
;;;125                /* I2C duty cycle is 2 */
;;;126                clkc = (uint32_t)(pclk1/(clkspeed*3U));
000096  eb060046          ADD      r0,r6,r6,LSL #1
00009a  fbb7f5f0          UDIV     r5,r7,r0
;;;127                I2C_CKCFG(i2c_periph) &= ~I2C_CKCFG_DTCY;
00009e  69e0              LDR      r0,[r4,#0x1c]
0000a0  f4204080          BIC      r0,r0,#0x4000
0000a4  61e0              STR      r0,[r4,#0x1c]
0000a6  e009              B        |L3.188|
                  |L3.168|
;;;128            }else{
;;;129                /* I2C duty cycle is 16/9 */
;;;130                clkc = (uint32_t)(pclk1/(clkspeed*25U));
0000a8  eb0600c6          ADD      r0,r6,r6,LSL #3
0000ac  eb001006          ADD      r0,r0,r6,LSL #4
0000b0  fbb7f5f0          UDIV     r5,r7,r0
;;;131                I2C_CKCFG(i2c_periph) |= I2C_CKCFG_DTCY;
0000b4  69e0              LDR      r0,[r4,#0x1c]
0000b6  f4404080          ORR      r0,r0,#0x4000
0000ba  61e0              STR      r0,[r4,#0x1c]
                  |L3.188|
;;;132            }
;;;133            if(0U == (clkc & I2C_CKCFG_CLKC)){
0000bc  f3c5000b          UBFX     r0,r5,#0,#12
0000c0  b908              CBNZ     r0,|L3.198|
;;;134                /* the CLKC in fast mode minmum value is 1 */
;;;135                clkc |= 0x0001U;  
0000c2  f0450501          ORR      r5,r5,#1
                  |L3.198|
;;;136            }
;;;137            I2C_CKCFG(i2c_periph) |= I2C_CKCFG_FAST;
0000c6  69e0              LDR      r0,[r4,#0x1c]
0000c8  f4404000          ORR      r0,r0,#0x8000
0000cc  61e0              STR      r0,[r4,#0x1c]
;;;138            I2C_CKCFG(i2c_periph) |= clkc;
0000ce  69e0              LDR      r0,[r4,#0x1c]
0000d0  4328              ORRS     r0,r0,r5
0000d2  61e0              STR      r0,[r4,#0x1c]
                  |L3.212|
;;;139        }else{
;;;140        }
;;;141    }
0000d4  e8bd9ff0          POP      {r4-r12,pc}
;;;142    
                          ENDP

                  |L3.216|
                          DCD      0x000f4240
                  |L3.220|
                          DCD      0x000186a0
                  |L3.224|
                          DCD      0x00061a80

                          AREA ||i.i2c_data_receive||, CODE, READONLY, ALIGN=1

                  i2c_data_receive PROC
;;;339    */
;;;340    uint8_t i2c_data_receive(uint32_t i2c_periph)
000000  4601              MOV      r1,r0
;;;341    {
;;;342        return (uint8_t)DATA_RECV(I2C_DATA(i2c_periph));
000002  6908              LDR      r0,[r1,#0x10]
000004  b2c0              UXTB     r0,r0
;;;343    }
000006  4770              BX       lr
;;;344    
                          ENDP


                          AREA ||i.i2c_data_transmit||, CODE, READONLY, ALIGN=1

                  i2c_data_transmit PROC
;;;328    */
;;;329    void i2c_data_transmit(uint32_t i2c_periph, uint8_t data)
000000  b2ca              UXTB     r2,r1
;;;330    {
;;;331        I2C_DATA(i2c_periph) = DATA_TRANS(data);
000002  6102              STR      r2,[r0,#0x10]
;;;332    }
000004  4770              BX       lr
;;;333    
                          ENDP


                          AREA ||i.i2c_deinit||, CODE, READONLY, ALIGN=2

                  i2c_deinit PROC
;;;57     */
;;;58     void i2c_deinit(uint32_t i2c_periph)
000000  b510              PUSH     {r4,lr}
;;;59     {
000002  4604              MOV      r4,r0
;;;60         switch(i2c_periph){
000004  480d              LDR      r0,|L6.60|
000006  4420              ADD      r0,r0,r4
000008  b118              CBZ      r0,|L6.18|
00000a  f5b06f80          CMP      r0,#0x400
00000e  d112              BNE      |L6.54|
000010  e008              B        |L6.36|
                  |L6.18|
;;;61         case I2C0:
;;;62             /* reset I2C0 */
;;;63             rcu_periph_reset_enable(RCU_I2C0RST);
000012  f2404015          MOV      r0,#0x415
000016  f7fffffe          BL       rcu_periph_reset_enable
;;;64             rcu_periph_reset_disable(RCU_I2C0RST);
00001a  f2404015          MOV      r0,#0x415
00001e  f7fffffe          BL       rcu_periph_reset_disable
;;;65             break;
000022  e009              B        |L6.56|
                  |L6.36|
;;;66         case I2C1:
;;;67             /* reset I2C1 */
;;;68             rcu_periph_reset_enable(RCU_I2C1RST);
000024  f2404016          MOV      r0,#0x416
000028  f7fffffe          BL       rcu_periph_reset_enable
;;;69             rcu_periph_reset_disable(RCU_I2C1RST);
00002c  f2404016          MOV      r0,#0x416
000030  f7fffffe          BL       rcu_periph_reset_disable
;;;70             break;
000034  e000              B        |L6.56|
                  |L6.54|
;;;71         default:
;;;72             break;
000036  bf00              NOP      
                  |L6.56|
000038  bf00              NOP                            ;65
;;;73         }
;;;74     }
00003a  bd10              POP      {r4,pc}
;;;75     
                          ENDP

                  |L6.60|
                          DCD      0xbfffac00

                          AREA ||i.i2c_disable||, CODE, READONLY, ALIGN=1

                  i2c_disable PROC
;;;294    */
;;;295    void i2c_disable(uint32_t i2c_periph)
000000  6801              LDR      r1,[r0,#0]
;;;296    {
;;;297        I2C_CTL0(i2c_periph) &= ~(I2C_CTL0_I2CEN);
000002  f0210101          BIC      r1,r1,#1
000006  6001              STR      r1,[r0,#0]
;;;298    }
000008  4770              BX       lr
;;;299    
                          ENDP


                          AREA ||i.i2c_dma_enable||, CODE, READONLY, ALIGN=1

                  i2c_dma_enable PROC
;;;354    */
;;;355    void i2c_dma_enable(uint32_t i2c_periph, uint32_t dmastate)
000000  460a              MOV      r2,r1
;;;356    {
;;;357        /* configure I2C DMA function */
;;;358        uint32_t ctl = 0U;
000002  2100              MOVS     r1,#0
;;;359        
;;;360        ctl = I2C_CTL1(i2c_periph);
000004  6841              LDR      r1,[r0,#4]
;;;361        ctl &= ~(I2C_CTL1_DMAON); 
000006  f4216100          BIC      r1,r1,#0x800
;;;362        ctl |= dmastate;
00000a  4311              ORRS     r1,r1,r2
;;;363        I2C_CTL1(i2c_periph) = ctl;
00000c  6041              STR      r1,[r0,#4]
;;;364    }
00000e  4770              BX       lr
;;;365    
                          ENDP


                          AREA ||i.i2c_dma_last_transfer_config||, CODE, READONLY, ALIGN=1

                  i2c_dma_last_transfer_config PROC
;;;375    */
;;;376    void i2c_dma_last_transfer_config(uint32_t i2c_periph, uint32_t dmalast)
000000  460a              MOV      r2,r1
;;;377    {
;;;378        /* configure DMA last transfer */
;;;379        uint32_t ctl = 0U;
000002  2100              MOVS     r1,#0
;;;380        
;;;381        ctl = I2C_CTL1(i2c_periph);
000004  6841              LDR      r1,[r0,#4]
;;;382        ctl &= ~(I2C_CTL1_DMALST); 
000006  f4215180          BIC      r1,r1,#0x1000
;;;383        ctl |= dmalast;
00000a  4311              ORRS     r1,r1,r2
;;;384        I2C_CTL1(i2c_periph) = ctl;
00000c  6041              STR      r1,[r0,#4]
;;;385    }
00000e  4770              BX       lr
;;;386    
                          ENDP


                          AREA ||i.i2c_dualaddr_disable||, CODE, READONLY, ALIGN=1

                  i2c_dualaddr_disable PROC
;;;272    */
;;;273    void i2c_dualaddr_disable(uint32_t i2c_periph)
000000  68c1              LDR      r1,[r0,#0xc]
;;;274    {
;;;275        I2C_SADDR1(i2c_periph) &= ~(I2C_SADDR1_DUADEN);
000002  f0210101          BIC      r1,r1,#1
000006  60c1              STR      r1,[r0,#0xc]
;;;276    }
000008  4770              BX       lr
;;;277    
                          ENDP


                          AREA ||i.i2c_dualaddr_enable||, CODE, READONLY, ALIGN=1

                  i2c_dualaddr_enable PROC
;;;259    */
;;;260    void i2c_dualaddr_enable(uint32_t i2c_periph, uint32_t addr)
000000  f00101fe          AND      r1,r1,#0xfe
;;;261    {
;;;262        /* configure address */
;;;263        addr = addr & I2C_ADDRESS2_MASK;
;;;264        I2C_SADDR1(i2c_periph) = (I2C_SADDR1_DUADEN | addr);
000004  f0410201          ORR      r2,r1,#1
000008  60c2              STR      r2,[r0,#0xc]
;;;265    }
00000a  4770              BX       lr
;;;266    
                          ENDP


                          AREA ||i.i2c_enable||, CODE, READONLY, ALIGN=1

                  i2c_enable PROC
;;;283    */
;;;284    void i2c_enable(uint32_t i2c_periph)
000000  6801              LDR      r1,[r0,#0]
;;;285    {
;;;286        I2C_CTL0(i2c_periph) |= I2C_CTL0_I2CEN;
000002  f0410101          ORR      r1,r1,#1
000006  6001              STR      r1,[r0,#0]
;;;287    }
000008  4770              BX       lr
;;;288    
                          ENDP


                          AREA ||i.i2c_flag_clear||, CODE, READONLY, ALIGN=1

                  i2c_flag_clear PROC
;;;598    */
;;;599    void i2c_flag_clear(uint32_t i2c_periph, i2c_flag_enum flag)
000000  b510              PUSH     {r4,lr}
;;;600    {
;;;601        if(I2C_FLAG_ADDSEND == flag){
000002  f2405201          MOV      r2,#0x501
000006  4291              CMP      r1,r2
000008  d102              BNE      |L13.16|
;;;602            /* read I2C_STAT0 and then read I2C_STAT1 to clear ADDSEND */
;;;603            I2C_STAT0(i2c_periph);
00000a  6942              LDR      r2,[r0,#0x14]
;;;604            I2C_STAT1(i2c_periph);
00000c  6982              LDR      r2,[r0,#0x18]
00000e  e00a              B        |L13.38|
                  |L13.16|
;;;605        }else{
;;;606            I2C_REG_VAL(i2c_periph, flag) &= ~BIT(I2C_BIT_POS(flag));
000010  eb001291          ADD      r2,r0,r1,LSR #6
000014  6812              LDR      r2,[r2,#0]
000016  f001041f          AND      r4,r1,#0x1f
00001a  2301              MOVS     r3,#1
00001c  40a3              LSLS     r3,r3,r4
00001e  439a              BICS     r2,r2,r3
000020  eb001391          ADD      r3,r0,r1,LSR #6
000024  601a              STR      r2,[r3,#0]
                  |L13.38|
;;;607        }
;;;608    }
000026  bd10              POP      {r4,pc}
;;;609    
                          ENDP


                          AREA ||i.i2c_flag_get||, CODE, READONLY, ALIGN=1

                  i2c_flag_get PROC
;;;573    */
;;;574    FlagStatus i2c_flag_get(uint32_t i2c_periph, i2c_flag_enum flag)
000000  b510              PUSH     {r4,lr}
;;;575    {
000002  4602              MOV      r2,r0
;;;576        if(RESET != (I2C_REG_VAL(i2c_periph, flag) & BIT(I2C_BIT_POS(flag)))){
000004  eb021091          ADD      r0,r2,r1,LSR #6
000008  6800              LDR      r0,[r0,#0]
00000a  f001041f          AND      r4,r1,#0x1f
00000e  2301              MOVS     r3,#1
000010  40a3              LSLS     r3,r3,r4
000012  4018              ANDS     r0,r0,r3
000014  b108              CBZ      r0,|L14.26|
;;;577            return SET;
000016  2001              MOVS     r0,#1
                  |L14.24|
;;;578        }else{
;;;579            return RESET;
;;;580        }
;;;581    }
000018  bd10              POP      {r4,pc}
                  |L14.26|
00001a  2000              MOVS     r0,#0                 ;579
00001c  e7fc              B        |L14.24|
;;;582    
                          ENDP


                          AREA ||i.i2c_interrupt_disable||, CODE, READONLY, ALIGN=1

                  i2c_interrupt_disable PROC
;;;636    */
;;;637    void i2c_interrupt_disable(uint32_t i2c_periph, i2c_interrupt_enum interrupt)
000000  b510              PUSH     {r4,lr}
;;;638    {
;;;639        I2C_REG_VAL(i2c_periph, interrupt) &= ~BIT(I2C_BIT_POS(interrupt));
000002  eb001291          ADD      r2,r0,r1,LSR #6
000006  6812              LDR      r2,[r2,#0]
000008  f001041f          AND      r4,r1,#0x1f
00000c  2301              MOVS     r3,#1
00000e  40a3              LSLS     r3,r3,r4
000010  439a              BICS     r2,r2,r3
000012  eb001391          ADD      r3,r0,r1,LSR #6
000016  601a              STR      r2,[r3,#0]
;;;640    }
000018  bd10              POP      {r4,pc}
;;;641    
                          ENDP


                          AREA ||i.i2c_interrupt_enable||, CODE, READONLY, ALIGN=1

                  i2c_interrupt_enable PROC
;;;620    */
;;;621    void i2c_interrupt_enable(uint32_t i2c_periph, i2c_interrupt_enum interrupt)
000000  b510              PUSH     {r4,lr}
;;;622    {
;;;623        I2C_REG_VAL(i2c_periph, interrupt) |= BIT(I2C_BIT_POS(interrupt));
000002  eb001291          ADD      r2,r0,r1,LSR #6
000006  6812              LDR      r2,[r2,#0]
000008  f001041f          AND      r4,r1,#0x1f
00000c  2301              MOVS     r3,#1
00000e  40a3              LSLS     r3,r3,r4
000010  431a              ORRS     r2,r2,r3
000012  eb001391          ADD      r3,r0,r1,LSR #6
000016  601a              STR      r2,[r3,#0]
;;;624    }
000018  bd10              POP      {r4,pc}
;;;625    
                          ENDP


                          AREA ||i.i2c_interrupt_flag_clear||, CODE, READONLY, ALIGN=2

                  i2c_interrupt_flag_clear PROC
;;;705    */
;;;706    void i2c_interrupt_flag_clear(uint32_t i2c_periph, i2c_interrupt_flag_enum int_flag)
000000  b510              PUSH     {r4,lr}
;;;707    {
;;;708        if(I2C_INT_FLAG_ADDSEND == int_flag){
000002  4a09              LDR      r2,|L17.40|
000004  4291              CMP      r1,r2
000006  d102              BNE      |L17.14|
;;;709            /* read I2C_STAT0 and then read I2C_STAT1 to clear ADDSEND */
;;;710            I2C_STAT0(i2c_periph);
000008  6942              LDR      r2,[r0,#0x14]
;;;711            I2C_STAT1(i2c_periph);
00000a  6982              LDR      r2,[r0,#0x18]
00000c  e00a              B        |L17.36|
                  |L17.14|
;;;712        }else{
;;;713            I2C_REG_VAL2(i2c_periph, int_flag) &= ~BIT(I2C_BIT_POS2(int_flag));
00000e  eb005291          ADD      r2,r0,r1,LSR #22
000012  6812              LDR      r2,[r2,#0]
000014  f3c14404          UBFX     r4,r1,#16,#5
000018  2301              MOVS     r3,#1
00001a  40a3              LSLS     r3,r3,r4
00001c  439a              BICS     r2,r2,r3
00001e  eb005391          ADD      r3,r0,r1,LSR #22
000022  601a              STR      r2,[r3,#0]
                  |L17.36|
;;;714        }
;;;715    }
000024  bd10              POP      {r4,pc}
                          ENDP

000026  0000              DCW      0x0000
                  |L17.40|
                          DCD      0x05010109

                          AREA ||i.i2c_interrupt_flag_get||, CODE, READONLY, ALIGN=2

                  i2c_interrupt_flag_get PROC
;;;663    */
;;;664    FlagStatus i2c_interrupt_flag_get(uint32_t i2c_periph, i2c_interrupt_flag_enum int_flag)
000000  b5f0              PUSH     {r4-r7,lr}
;;;665    {
000002  4602              MOV      r2,r0
;;;666        uint32_t intenable = 0U, flagstatus = 0U, bufie;
000004  2300              MOVS     r3,#0
000006  2400              MOVS     r4,#0
;;;667        
;;;668        /* check BUFIE */
;;;669        bufie = I2C_CTL1(i2c_periph)&I2C_CTL1_BUFIE;
000008  6850              LDR      r0,[r2,#4]
00000a  f4006580          AND      r5,r0,#0x400
;;;670        
;;;671        /* get the interrupt enable bit status */
;;;672        intenable = (I2C_REG_VAL(i2c_periph, int_flag) & BIT(I2C_BIT_POS(int_flag)));
00000e  f3c11089          UBFX     r0,r1,#6,#10
000012  5810              LDR      r0,[r2,r0]
000014  f001071f          AND      r7,r1,#0x1f
000018  2601              MOVS     r6,#1
00001a  40be              LSLS     r6,r6,r7
00001c  ea000306          AND      r3,r0,r6
;;;673        /* get the corresponding flag bit status */
;;;674        flagstatus = (I2C_REG_VAL2(i2c_periph, int_flag) & BIT(I2C_BIT_POS2(int_flag)));
000020  eb025091          ADD      r0,r2,r1,LSR #22
000024  6800              LDR      r0,[r0,#0]
000026  f3c14704          UBFX     r7,r1,#16,#5
00002a  2601              MOVS     r6,#1
00002c  40be              LSLS     r6,r6,r7
00002e  ea000406          AND      r4,r0,r6
;;;675    
;;;676        if((I2C_INT_FLAG_RBNE == int_flag) || (I2C_INT_FLAG_TBE == int_flag)){
000032  4808              LDR      r0,|L18.84|
000034  4281              CMP      r1,r0
000036  d002              BEQ      |L18.62|
000038  4807              LDR      r0,|L18.88|
00003a  4281              CMP      r1,r0
00003c  d104              BNE      |L18.72|
                  |L18.62|
;;;677            if(intenable && bufie){
00003e  b113              CBZ      r3,|L18.70|
000040  b10d              CBZ      r5,|L18.70|
;;;678                intenable = 1U;                       
000042  2301              MOVS     r3,#1
000044  e000              B        |L18.72|
                  |L18.70|
;;;679            }else{
;;;680                intenable = 0U;
000046  2300              MOVS     r3,#0
                  |L18.72|
;;;681            }
;;;682        }
;;;683        if((0U != flagstatus) && (0U != intenable)){
000048  b114              CBZ      r4,|L18.80|
00004a  b10b              CBZ      r3,|L18.80|
;;;684            return SET;
00004c  2001              MOVS     r0,#1
                  |L18.78|
;;;685        }else{
;;;686            return RESET; 
;;;687        }
;;;688    }
00004e  bdf0              POP      {r4-r7,pc}
                  |L18.80|
000050  2000              MOVS     r0,#0                 ;686
000052  e7fc              B        |L18.78|
;;;689    
                          ENDP

                  |L18.84|
                          DCD      0x05060109
                  |L18.88|
                          DCD      0x05070109

                          AREA ||i.i2c_master_addressing||, CODE, READONLY, ALIGN=1

                  i2c_master_addressing PROC
;;;240    */
;;;241    void i2c_master_addressing(uint32_t i2c_periph, uint32_t addr, uint32_t trandirection)
000000  f1120f02          CMN      r2,#2
;;;242    {
;;;243        /* master is a transmitter or a receiver */
;;;244        if(I2C_TRANSMITTER == trandirection){
000004  d102              BNE      |L19.12|
;;;245            addr = addr & I2C_TRANSMITTER;
000006  f0210101          BIC      r1,r1,#1
00000a  e001              B        |L19.16|
                  |L19.12|
;;;246        }else{
;;;247            addr = addr | I2C_RECEIVER;
00000c  f0410101          ORR      r1,r1,#1
                  |L19.16|
;;;248        }
;;;249        /* send slave address */
;;;250        I2C_DATA(i2c_periph) = addr;
000010  6101              STR      r1,[r0,#0x10]
;;;251    }
000012  4770              BX       lr
;;;252    
                          ENDP


                          AREA ||i.i2c_mode_addr_config||, CODE, READONLY, ALIGN=1

                  i2c_mode_addr_config PROC
;;;157    */
;;;158    void i2c_mode_addr_config(uint32_t i2c_periph, uint32_t mode, uint32_t addformat, uint32_t addr)
000000  b530              PUSH     {r4,r5,lr}
;;;159    {
000002  460c              MOV      r4,r1
;;;160        /* SMBus/I2C mode selected */
;;;161        uint32_t ctl = 0U;
000004  2100              MOVS     r1,#0
;;;162        
;;;163        ctl = I2C_CTL0(i2c_periph);
000006  6801              LDR      r1,[r0,#0]
;;;164        ctl &= ~(I2C_CTL0_SMBEN); 
000008  f0210102          BIC      r1,r1,#2
;;;165        ctl |= mode;
00000c  4321              ORRS     r1,r1,r4
;;;166        I2C_CTL0(i2c_periph) = ctl;
00000e  6001              STR      r1,[r0,#0]
;;;167        /* configure address */
;;;168        addr = addr & I2C_ADDRESS_MASK;
000010  f3c30309          UBFX     r3,r3,#0,#10
;;;169        I2C_SADDR0(i2c_periph) = (addformat | addr);
000014  ea420503          ORR      r5,r2,r3
000018  6085              STR      r5,[r0,#8]
;;;170    }
00001a  bd30              POP      {r4,r5,pc}
;;;171    
                          ENDP


                          AREA ||i.i2c_pec_enable||, CODE, READONLY, ALIGN=1

                  i2c_pec_enable PROC
;;;459    */
;;;460    void i2c_pec_enable(uint32_t i2c_periph, uint32_t pecstate)
000000  460a              MOV      r2,r1
;;;461    {
;;;462        /* on/off PEC calculation */
;;;463        uint32_t ctl = 0U;
000002  2100              MOVS     r1,#0
;;;464        
;;;465        ctl = I2C_CTL0(i2c_periph);
000004  6801              LDR      r1,[r0,#0]
;;;466        ctl &= ~(I2C_CTL0_PECEN);
000006  f0210120          BIC      r1,r1,#0x20
;;;467        ctl |= pecstate;
00000a  4311              ORRS     r1,r1,r2
;;;468        I2C_CTL0(i2c_periph) = ctl;
00000c  6001              STR      r1,[r0,#0]
;;;469    }
00000e  4770              BX       lr
;;;470    
                          ENDP


                          AREA ||i.i2c_pec_transfer_enable||, CODE, READONLY, ALIGN=1

                  i2c_pec_transfer_enable PROC
;;;480    */
;;;481    void i2c_pec_transfer_enable(uint32_t i2c_periph, uint32_t pecpara)
000000  460a              MOV      r2,r1
;;;482    {
;;;483        /* whether to transfer PEC */
;;;484        uint32_t ctl = 0U;
000002  2100              MOVS     r1,#0
;;;485        
;;;486        ctl = I2C_CTL0(i2c_periph);
000004  6801              LDR      r1,[r0,#0]
;;;487        ctl &= ~(I2C_CTL0_PECTRANS);
000006  f4215180          BIC      r1,r1,#0x1000
;;;488        ctl |= pecpara;
00000a  4311              ORRS     r1,r1,r2
;;;489        I2C_CTL0(i2c_periph) = ctl;
00000c  6001              STR      r1,[r0,#0]
;;;490    }
00000e  4770              BX       lr
;;;491    
                          ENDP


                          AREA ||i.i2c_pec_value_get||, CODE, READONLY, ALIGN=1

                  i2c_pec_value_get PROC
;;;497    */
;;;498    uint8_t i2c_pec_value_get(uint32_t i2c_periph)
000000  4601              MOV      r1,r0
;;;499    {
;;;500        return (uint8_t)((I2C_STAT1(i2c_periph) & I2C_STAT1_PECV)>>STAT1_PECV_OFFSET);
000002  6988              LDR      r0,[r1,#0x18]
000004  f3c02007          UBFX     r0,r0,#8,#8
;;;501    }
000008  4770              BX       lr
;;;502    
                          ENDP


                          AREA ||i.i2c_slave_response_to_gcall_config||, CODE, READONLY, ALIGN=1

                  i2c_slave_response_to_gcall_config PROC
;;;417    */
;;;418    void i2c_slave_response_to_gcall_config(uint32_t i2c_periph, uint32_t gcallpara)
000000  460a              MOV      r2,r1
;;;419    {
;;;420        /* configure slave response to a general call enable or disable */
;;;421        uint32_t ctl = 0U;
000002  2100              MOVS     r1,#0
;;;422        
;;;423        ctl = I2C_CTL0(i2c_periph);
000004  6801              LDR      r1,[r0,#0]
;;;424        ctl &= ~(I2C_CTL0_GCEN); 
000006  f0210140          BIC      r1,r1,#0x40
;;;425        ctl |= gcallpara;
00000a  4311              ORRS     r1,r1,r2
;;;426        I2C_CTL0(i2c_periph) = ctl;
00000c  6001              STR      r1,[r0,#0]
;;;427    }
00000e  4770              BX       lr
;;;428    
                          ENDP


                          AREA ||i.i2c_smbus_arp_enable||, CODE, READONLY, ALIGN=1

                  i2c_smbus_arp_enable PROC
;;;533    */
;;;534    void i2c_smbus_arp_enable(uint32_t i2c_periph, uint32_t arpstate)
000000  460a              MOV      r2,r1
;;;535    {
;;;536        /* enable or disable I2C ARP protocol*/
;;;537        uint32_t ctl = 0U;
000002  2100              MOVS     r1,#0
;;;538        
;;;539        ctl = I2C_CTL0(i2c_periph);
000004  6801              LDR      r1,[r0,#0]
;;;540        ctl &= ~(I2C_CTL0_ARPEN);
000006  f0210110          BIC      r1,r1,#0x10
;;;541        ctl |= arpstate;
00000a  4311              ORRS     r1,r1,r2
;;;542        I2C_CTL0(i2c_periph) = ctl;
00000c  6001              STR      r1,[r0,#0]
;;;543    }
00000e  4770              BX       lr
;;;544    
                          ENDP


                          AREA ||i.i2c_smbus_issue_alert||, CODE, READONLY, ALIGN=1

                  i2c_smbus_issue_alert PROC
;;;512    */
;;;513    void i2c_smbus_issue_alert(uint32_t i2c_periph, uint32_t smbuspara)
000000  460a              MOV      r2,r1
;;;514    {
;;;515        /* issue alert through SMBA pin configure*/
;;;516        uint32_t ctl = 0U;
000002  2100              MOVS     r1,#0
;;;517        
;;;518        ctl = I2C_CTL0(i2c_periph);
000004  6801              LDR      r1,[r0,#0]
;;;519        ctl &= ~(I2C_CTL0_SALT);
000006  f4215100          BIC      r1,r1,#0x2000
;;;520        ctl |= smbuspara;
00000a  4311              ORRS     r1,r1,r2
;;;521        I2C_CTL0(i2c_periph) = ctl;
00000c  6001              STR      r1,[r0,#0]
;;;522    }
00000e  4770              BX       lr
;;;523    
                          ENDP


                          AREA ||i.i2c_smbus_type_config||, CODE, READONLY, ALIGN=1

                  i2c_smbus_type_config PROC
;;;181    */
;;;182    void i2c_smbus_type_config(uint32_t i2c_periph, uint32_t type)
000000  2908              CMP      r1,#8
;;;183    {
;;;184        if(I2C_SMBUS_HOST == type){
000002  d104              BNE      |L27.14|
;;;185            I2C_CTL0(i2c_periph) |= I2C_CTL0_SMBSEL;
000004  6802              LDR      r2,[r0,#0]
000006  f0420208          ORR      r2,r2,#8
00000a  6002              STR      r2,[r0,#0]
00000c  e003              B        |L27.22|
                  |L27.14|
;;;186        }else{
;;;187            I2C_CTL0(i2c_periph) &= ~(I2C_CTL0_SMBSEL);
00000e  6802              LDR      r2,[r0,#0]
000010  f0220208          BIC      r2,r2,#8
000014  6002              STR      r2,[r0,#0]
                  |L27.22|
;;;188        }
;;;189    }
000016  4770              BX       lr
;;;190    
                          ENDP


                          AREA ||i.i2c_software_reset_config||, CODE, READONLY, ALIGN=1

                  i2c_software_reset_config PROC
;;;438    */
;;;439    void i2c_software_reset_config(uint32_t i2c_periph, uint32_t sreset)
000000  460a              MOV      r2,r1
;;;440    {
;;;441        /* modify CTL0 and configure software reset I2C state */
;;;442        uint32_t ctl = 0U;
000002  2100              MOVS     r1,#0
;;;443        
;;;444        ctl = I2C_CTL0(i2c_periph);
000004  6801              LDR      r1,[r0,#0]
;;;445        ctl &= ~(I2C_CTL0_SRESET); 
000006  f4214100          BIC      r1,r1,#0x8000
;;;446        ctl |= sreset;
00000a  4311              ORRS     r1,r1,r2
;;;447        I2C_CTL0(i2c_periph) = ctl;
00000c  6001              STR      r1,[r0,#0]
;;;448    }
00000e  4770              BX       lr
;;;449    
                          ENDP


                          AREA ||i.i2c_start_on_bus||, CODE, READONLY, ALIGN=1

                  i2c_start_on_bus PROC
;;;305    */
;;;306    void i2c_start_on_bus(uint32_t i2c_periph)
000000  6801              LDR      r1,[r0,#0]
;;;307    {
;;;308        I2C_CTL0(i2c_periph) |= I2C_CTL0_START;
000002  f4417180          ORR      r1,r1,#0x100
000006  6001              STR      r1,[r0,#0]
;;;309    }
000008  4770              BX       lr
;;;310    
                          ENDP


                          AREA ||i.i2c_stop_on_bus||, CODE, READONLY, ALIGN=1

                  i2c_stop_on_bus PROC
;;;316    */
;;;317    void i2c_stop_on_bus(uint32_t i2c_periph)
000000  6801              LDR      r1,[r0,#0]
;;;318    {
;;;319        I2C_CTL0(i2c_periph) |= I2C_CTL0_STOP;
000002  f4417100          ORR      r1,r1,#0x200
000006  6001              STR      r1,[r0,#0]
;;;320    }
000008  4770              BX       lr
;;;321    
                          ENDP


                          AREA ||i.i2c_stretch_scl_low_config||, CODE, READONLY, ALIGN=1

                  i2c_stretch_scl_low_config PROC
;;;396    */
;;;397    void i2c_stretch_scl_low_config(uint32_t i2c_periph, uint32_t stretchpara)
000000  460a              MOV      r2,r1
;;;398    {
;;;399        /* configure I2C SCL strerching enable or disable */
;;;400        uint32_t ctl = 0U;
000002  2100              MOVS     r1,#0
;;;401        
;;;402        ctl = I2C_CTL0(i2c_periph);
000004  6801              LDR      r1,[r0,#0]
;;;403        ctl &= ~(I2C_CTL0_SS); 
000006  f0210180          BIC      r1,r1,#0x80
;;;404        ctl |= stretchpara;
00000a  4311              ORRS     r1,r1,r2
;;;405        I2C_CTL0(i2c_periph) = ctl;
00000c  6001              STR      r1,[r0,#0]
;;;406    }
00000e  4770              BX       lr
;;;407    
                          ENDP


;*** Start embedded assembler ***

#line 1 "Libraries\\src\\gd32f10x_i2c.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_gd32f10x_i2c_c_60c11f87____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___14_gd32f10x_i2c_c_60c11f87____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_gd32f10x_i2c_c_60c11f87____REVSH|
#line 128
|__asm___14_gd32f10x_i2c_c_60c11f87____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
