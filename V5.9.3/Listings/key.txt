; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\key.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\key.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -I.\User\qrencode -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.1\Device\Include -D__MICROLIB -D__UVISION_VERSION=534 -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\key.crf User\key.c]
                          THUMB

                          AREA ||i.KEY_CALLBACK_ClearAddDecKeyUpMaskRequest||, CODE, READONLY, ALIGN=2

                  KEY_CALLBACK_ClearAddDecKeyUpMaskRequest PROC
;;;27     // 定时器回调重新释放+、-键弹起请求
;;;28     void KEY_CALLBACK_ClearAddDecKeyUpMaskRequest(uint32 param)
000000  b510              PUSH     {r4,lr}
;;;29     {
;;;30     	// 屏蔽加键和减键的释放消息
;;;31     	KEYMSG_ClearMaskRequest(KEY_NAME_ADD, KEY_MSG_UP);
000002  2101              MOVS     r1,#1
000004  2000              MOVS     r0,#0
000006  f7fffffe          BL       KEYMSG_ClearMaskRequest
;;;32     	KEYMSG_ClearMaskRequest(KEY_NAME_DEC, KEY_MSG_UP);
00000a  2101              MOVS     r1,#1
00000c  2002              MOVS     r0,#2
00000e  f7fffffe          BL       KEYMSG_ClearMaskRequest
;;;33     
;;;34     	// +键重新开放
;;;35     	keyMsgCB.addKeyInvalidRequest = FALSE;
000012  4902              LDR      r1,|L1.28|
000014  2000              MOVS     r0,#0
000016  f88100ff          STRB     r0,[r1,#0xff]
;;;36     }
00001a  bd10              POP      {r4,pc}
;;;37     
                          ENDP

                  |L1.28|
                          DCD      keyMsgCB

                          AREA ||i.KEY_CALLBACK_ClearAddInfoKeyUpMaskRequest||, CODE, READONLY, ALIGN=2

                  KEY_CALLBACK_ClearAddInfoKeyUpMaskRequest PROC
;;;38     // 定时器回调重新释放+、i键弹起请求
;;;39     void KEY_CALLBACK_ClearAddInfoKeyUpMaskRequest(uint32 param)
000000  b510              PUSH     {r4,lr}
;;;40     {
;;;41     	// 清除+键和i键的释放屏蔽请求
;;;42     	KEYMSG_ClearMaskRequest(KEY_NAME_ADD, KEY_MSG_UP);
000002  2101              MOVS     r1,#1
000004  2000              MOVS     r0,#0
000006  f7fffffe          BL       KEYMSG_ClearMaskRequest
;;;43     	KEYMSG_ClearMaskRequest(KEY_NAME_KEYM_MCU, KEY_MSG_UP);
00000a  2101              MOVS     r1,#1
00000c  4608              MOV      r0,r1
00000e  f7fffffe          BL       KEYMSG_ClearMaskRequest
;;;44     
;;;45     	// +键重新开放
;;;46     	keyMsgCB.addKeyInvalidRequest = FALSE;
000012  4902              LDR      r1,|L2.28|
000014  2000              MOVS     r0,#0
000016  f88100ff          STRB     r0,[r1,#0xff]
;;;47     }
00001a  bd10              POP      {r4,pc}
;;;48     
                          ENDP

                  |L2.28|
                          DCD      keyMsgCB

                          AREA ||i.KEY_CALLBACK_Scan||, CODE, READONLY, ALIGN=2

                  KEY_CALLBACK_Scan PROC
;;;49     uint8 testkey = 0;
;;;50     void KEY_CALLBACK_Scan(uint8* p8bitKeyValueArray)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;51     {
000004  4681              MOV      r9,r0
;;;52     	uint8 keyMask = 0x07;			// 相当于无实体按键按下
000006  f04f0807          MOV      r8,#7
;;;53     	uint8 keyAddDecMask = 0x05;		// 加减同时按时
00000a  2605              MOVS     r6,#5
;;;54     	uint8 keyAddInfo = 0x03;		// +,i同时按下
00000c  2703              MOVS     r7,#3
;;;55     	uint8 mask = (0xFF>>(8-KEY_FILTER_LEVEL_N));
00000e  2507              MOVS     r5,#7
;;;56     	uint8 keyValue = 0;
000010  2400              MOVS     r4,#0
;;;57     	uint8 keyRead = 0;
;;;58     	uint8 i;
;;;59     	
;;;60     	keyRead = gpio_input_bit_get(GPIOC, GPIO_PIN_4);	// -
000012  f8dfb124          LDR      r11,|L3.312|
000016  2110              MOVS     r1,#0x10
000018  4658              MOV      r0,r11
00001a  f7fffffe          BL       gpio_input_bit_get
;;;61     	keyRead <<= 1;
00001e  ea4f0a40          LSL      r10,r0,#1
;;;62     	keyRead |= gpio_input_bit_get(GPIOC, GPIO_PIN_1);	// i
000022  2102              MOVS     r1,#2
000024  4658              MOV      r0,r11
000026  f7fffffe          BL       gpio_input_bit_get
00002a  ea40000a          ORR      r0,r0,r10
;;;63     	keyRead <<= 1;
00002e  0640              LSLS     r0,r0,#25
000030  ea4f6a10          LSR      r10,r0,#24
;;;64     	keyRead |= gpio_input_bit_get(GPIOC, GPIO_PIN_3);	// +
000034  2108              MOVS     r1,#8
000036  4658              MOV      r0,r11
000038  f7fffffe          BL       gpio_input_bit_get
00003c  ea40030a          ORR      r3,r0,r10
;;;65     
;;;66     	// ■■这里增加按键滤波措施■■
;;;67     	// 【第一步】将读取到的按键放入缓冲区
;;;68     	for(i=0; i<KEY_NAME_MAX-2; i++)		// 组合按键不需要在这里滤波，因此这里循环上限-1
000040  2100              MOVS     r1,#0
;;;69     	{
;;;70     		// 读取到的每个按键的信息添加到对应的缓冲区里
;;;71     		keyCB.buff[i] <<= 1;
000042  4a3e              LDR      r2,|L3.316|
                  |L3.68|
000044  5c50              LDRB     r0,[r2,r1]
000046  0040              LSLS     r0,r0,#1
;;;72     		keyCB.buff[i] |= (keyRead>>i)&0x01;
000048  fa23fc01          LSR      r12,r3,r1
00004c  f00c0c01          AND      r12,r12,#1
000050  ea40000c          ORR      r0,r0,r12
000054  5450              STRB     r0,[r2,r1]
000056  1c49              ADDS     r1,r1,#1              ;68
000058  b2c9              UXTB     r1,r1                 ;68
00005a  2903              CMP      r1,#3                 ;68
00005c  d3f2              BCC      |L3.68|
;;;73     	}
;;;74     
;;;75     	// 【第二步】缓冲区处理，连续N次读到同一个状态才确认，N可设定
;;;76     	for(i=0; i<KEY_NAME_MAX-2; i++)
00005e  2100              MOVS     r1,#0
;;;77     	{
;;;78     		// 当前按键缓冲区从低位开始连续N个均为1，判定为释放
;;;79     		if((keyCB.buff[i] & mask) == mask)
;;;80     		{
;;;81     			keyCB.lastValue[i] = 0x01<<i;
000060  f04f0c01          MOV      r12,#1
000064  468a              MOV      r10,r1
                  |L3.102|
000066  5c50              LDRB     r0,[r2,r1]            ;79
000068  ea350300          BICS     r3,r5,r0              ;79
00006c  d024              BEQ      |L3.184|
;;;82     		}
;;;83     		// 从低位开始连续N个均为0，则判定为按下
;;;84     		else if(0 == (keyCB.buff[i] & mask))
00006e  4228              TST      r0,r5
000070  d102              BNE      |L3.120|
;;;85     		{
;;;86     			keyCB.lastValue[i] = 0;
000072  1850              ADDS     r0,r2,r1
000074  f880a005          STRB     r10,[r0,#5]
                  |L3.120|
;;;87     		}
;;;88     		// 其余场景，为不稳定期，不处理
;;;89     		else
;;;90     		{}
;;;91     
;;;92     		keyValue |= keyCB.lastValue[i];
000078  1850              ADDS     r0,r2,r1
00007a  7940              LDRB     r0,[r0,#5]
00007c  4304              ORRS     r4,r4,r0
00007e  1c49              ADDS     r1,r1,#1              ;76
000080  b2c9              UXTB     r1,r1                 ;76
000082  2903              CMP      r1,#3                 ;76
000084  d3ef              BCC      |L3.102|
;;;93     	}
;;;94     
;;;95     	// 判断组合键是否开启
;;;96     	if (!KEYMSG_GetGroupKeyUpRecoveryRequest())
000086  f7fffffe          BL       KEYMSG_GetGroupKeyUpRecoveryRequest
00008a  b1d0              CBZ      r0,|L3.194|
;;;97     	{
;;;98     		// 复位虚拟键为抬起状态
;;;99     		keyValue |= 0x18;
;;;100    		
;;;101    		// 三个按键全部释放，清除按键消息全局屏蔽请求
;;;102    		if (keyMask == (keyValue & keyMask))
;;;103    		{
;;;104    			// 清除全局屏蔽请求
;;;105    			KEYMSG_ClearGlobalMaskRequest();
;;;106    
;;;107    			// 组合键引起的屏蔽+-键弹起功能，所以当按键释放后指定延时重新开启UP功能
;;;108    			if (KEYMSG_GetAddDecKeyUpRecoveryRequest())
;;;109    			{
;;;110    				KEYMSG_SetAddDecKeyUpRecoveryRequest(FALSE);
;;;111    				
;;;112    				// 开启一个+-键弹起后定时器，指定时间恢复弹起功能
;;;113    //				TIMER_AddTask(TIMER_ID_RECOVERY_KEY_UP_ADD_DEC,
;;;114    //								KEY_SCAN_TIME*2,
;;;115    //								KEY_CALLBACK_ClearAddDecKeyUpMaskRequest,
;;;116    //								TRUE,
;;;117    //								1,
;;;118    //								ACTION_MODE_ADD_TO_QUEUE);
;;;119    			}
;;;120    
;;;121    			// 组合键引起的屏蔽+ i键弹起功能，所以当按键释放后指定延时重新开启UP功能
;;;122    			if (KEYMSG_GetAddInfoKeyUpRecoveryRequest())
;;;123    			{
;;;124    				KEYMSG_SetAddInfoKeyUpRecoveryRequest(FALSE);
;;;125    
;;;126    				// 开启一个+i键弹起后定时器，指定时间恢复弹起功能
;;;127    //				TIMER_AddTask(TIMER_ID_RECOVERY_KEY_UP_ADD_INFO,
;;;128    //								KEY_SCAN_TIME*2,
;;;129    //								KEY_CALLBACK_ClearAddInfoKeyUpMaskRequest,
;;;130    //								TRUE,
;;;131    //								1,
;;;132    //								ACTION_MODE_ADD_TO_QUEUE);
;;;133    			}
;;;134    		}
;;;135    
;;;136    		// 检测到加减按键同时按下，根据原理图修改(bit0, +; bit1, -; bit2, i)
;;;137    		if (0 == (keyValue & keyAddDecMask))
;;;138    		{
;;;139    			// 只要是组合键按下立刻允许当全部按键释放后重新恢复+-键弹起功能
;;;140    			KEYMSG_SetAddDecKeyUpRecoveryRequest(TRUE);
;;;141    
;;;142    			// 推车助力使能后+键的任意消息都拦截
;;;143    			if (PARAM_IsPushAssistOn())
;;;144    			{
;;;145    				return;
;;;146    			}
;;;147    			
;;;148    			// 将虚拟的按键置位
;;;149    			keyValue &= ~KEY_MASK_ADD_DEC;
;;;150    
;;;151    			// 消除单独的按键
;;;152    			keyValue |= keyAddDecMask;
;;;153    		
;;;154    			// 屏蔽加键和减键的释放消息
;;;155    			KEYMSG_SetMaskRequest(KEY_NAME_ADD, KEY_MSG_UP);
;;;156    			KEYMSG_SetMaskRequest(KEY_NAME_DEC, KEY_MSG_UP);
;;;157    		}
;;;158    		
;;;159    		// 检测到+,i按键同时按下，根据原理图修改(bit0, +; bit1, -; bit2, i)
;;;160    		if (0 == (keyValue & keyAddInfo))
;;;161    		{
;;;162    			// 只要是组合键按下立刻允许当全部按键释放后重新恢复+-键弹起功能
;;;163    			KEYMSG_SetAddInfoKeyUpRecoveryRequest(TRUE);
;;;164    
;;;165    			// 将虚拟的按键置位
;;;166    			keyValue &= ~KEY_MASK_ADD_INFO;
;;;167    
;;;168    			// 消除单独的按键
;;;169    			keyValue |= keyAddInfo;
;;;170    
;;;171    			KEYMSG_SetMaskRequest(KEY_NAME_KEYM_MCU, KEY_MSG_UP);
;;;172    			KEYMSG_SetMaskRequest(KEY_NAME_ADD, KEY_MSG_UP);
;;;173    		}
;;;174    	}
;;;175    	else
;;;176    	{
;;;177    		KEYMSG_ClearMaskRequest(KEY_NAME_KEYM_MCU, KEY_MSG_UP);
00008c  2101              MOVS     r1,#1
00008e  4608              MOV      r0,r1
000090  f7fffffe          BL       KEYMSG_ClearMaskRequest
;;;178    		KEYMSG_ClearMaskRequest(KEY_NAME_ADD, KEY_MSG_UP);
000094  2101              MOVS     r1,#1
000096  2000              MOVS     r0,#0
000098  f7fffffe          BL       KEYMSG_ClearMaskRequest
;;;179    		KEYMSG_ClearMaskRequest(KEY_NAME_DEC, KEY_MSG_UP);
00009c  2101              MOVS     r1,#1
00009e  2002              MOVS     r0,#2
0000a0  f7fffffe          BL       KEYMSG_ClearMaskRequest
                  |L3.164|
;;;180    	}
;;;181    	
;;;182    	testkey = keyValue;
0000a4  4826              LDR      r0,|L3.320|
0000a6  7004              STRB     r4,[r0,#0]
;;;183    	*p8bitKeyValueArray = keyValue;
0000a8  f8894000          STRB     r4,[r9,#0]
;;;184    
;;;185    	// 只要有按键触发就立刻重设自动关机时间
;;;186    	if (keyValue != KEY_MASK_ALL)
0000ac  2c1f              CMP      r4,#0x1f
0000ae  d040              BEQ      |L3.306|
;;;187    	{
;;;188    		// 重置自动关机任务
;;;189    		STATE_ResetAutoPowerOffControl();
0000b0  e8bd5ff0          POP      {r4-r12,lr}
0000b4  f7ffbffe          B.W      STATE_ResetAutoPowerOffControl
                  |L3.184|
0000b8  fa0cf301          LSL      r3,r12,r1             ;81
0000bc  1850              ADDS     r0,r2,r1              ;81
0000be  7143              STRB     r3,[r0,#5]            ;81
0000c0  e7da              B        |L3.120|
                  |L3.194|
0000c2  f0440418          ORR      r4,r4,#0x18           ;99
0000c6  ea380804          BICS     r8,r8,r4              ;102
0000ca  d10d              BNE      |L3.232|
0000cc  f7fffffe          BL       KEYMSG_ClearGlobalMaskRequest
0000d0  f7fffffe          BL       KEYMSG_GetAddDecKeyUpRecoveryRequest
0000d4  b110              CBZ      r0,|L3.220|
0000d6  2000              MOVS     r0,#0                 ;110
0000d8  f7fffffe          BL       KEYMSG_SetAddDecKeyUpRecoveryRequest
                  |L3.220|
0000dc  f7fffffe          BL       KEYMSG_GetAddInfoKeyUpRecoveryRequest
0000e0  b110              CBZ      r0,|L3.232|
0000e2  2000              MOVS     r0,#0                 ;124
0000e4  f7fffffe          BL       KEYMSG_SetAddInfoKeyUpRecoveryRequest
                  |L3.232|
0000e8  4234              TST      r4,r6                 ;137
0000ea  d111              BNE      |L3.272|
0000ec  2001              MOVS     r0,#1                 ;140
0000ee  f7fffffe          BL       KEYMSG_SetAddDecKeyUpRecoveryRequest
0000f2  4814              LDR      r0,|L3.324|
0000f4  f89001ff          LDRB     r0,[r0,#0x1ff]        ;143  ; paramCB
0000f8  2800              CMP      r0,#0                 ;143
0000fa  d11a              BNE      |L3.306|
0000fc  f0240408          BIC      r4,r4,#8              ;149
000100  4334              ORRS     r4,r4,r6              ;152
000102  2101              MOVS     r1,#1                 ;155
000104  f7fffffe          BL       KEYMSG_SetMaskRequest
000108  2101              MOVS     r1,#1                 ;156
00010a  2002              MOVS     r0,#2                 ;156
00010c  f7fffffe          BL       KEYMSG_SetMaskRequest
                  |L3.272|
000110  423c              TST      r4,r7                 ;160
000112  d1c7              BNE      |L3.164|
000114  2001              MOVS     r0,#1                 ;163
000116  f7fffffe          BL       KEYMSG_SetAddInfoKeyUpRecoveryRequest
00011a  f0240410          BIC      r4,r4,#0x10           ;166
00011e  433c              ORRS     r4,r4,r7              ;169
000120  2101              MOVS     r1,#1                 ;171
000122  4608              MOV      r0,r1                 ;171
000124  f7fffffe          BL       KEYMSG_SetMaskRequest
000128  2101              MOVS     r1,#1                 ;172
00012a  2000              MOVS     r0,#0                 ;172
00012c  f7fffffe          BL       KEYMSG_SetMaskRequest
000130  e7b8              B        |L3.164|
                  |L3.306|
;;;190    
;;;191    		// 复位定时返回骑行界面的时间
;;;192    //		TIMER_ResetTimer(TIMER_ID_MENU_QUIT);
;;;193    	}
;;;194    }
000132  e8bd9ff0          POP      {r4-r12,pc}
;;;195    
                          ENDP

000136  0000              DCW      0x0000
                  |L3.312|
                          DCD      0x40011000
                  |L3.316|
                          DCD      ||.bss||
                  |L3.320|
                          DCD      ||.data||
                  |L3.324|
                          DCD      paramCB

                          AREA ||i.KEY_Init||, CODE, READONLY, ALIGN=2

                  KEY_Init PROC
;;;9      
;;;10     void KEY_Init(void)
000000  b510              PUSH     {r4,lr}
;;;11     {	 
;;;12     	// 打开时钟
;;;13     	rcu_periph_clock_enable(RCU_GPIOC);
000002  f2406004          MOV      r0,#0x604
000006  f7fffffe          BL       rcu_periph_clock_enable
;;;14     	gpio_init(GPIOC, GPIO_MODE_IPU, GPIO_OSPEED_2MHZ, GPIO_PIN_0);		// +			
00000a  4c13              LDR      r4,|L4.88|
00000c  2301              MOVS     r3,#1
00000e  2202              MOVS     r2,#2
000010  2148              MOVS     r1,#0x48
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       gpio_init
;;;15     	gpio_init(GPIOC, GPIO_MODE_IPU, GPIO_OSPEED_2MHZ, GPIO_PIN_1);		// 开关			i
000018  2302              MOVS     r3,#2
00001a  461a              MOV      r2,r3
00001c  2148              MOVS     r1,#0x48
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       gpio_init
;;;16     	gpio_init(GPIOC, GPIO_MODE_IPU, GPIO_OSPEED_2MHZ, GPIO_PIN_2);		// -
000024  2304              MOVS     r3,#4
000026  2202              MOVS     r2,#2
000028  2148              MOVS     r1,#0x48
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       gpio_init
;;;17     	gpio_init(GPIOC, GPIO_MODE_IPU, GPIO_OSPEED_2MHZ, GPIO_PIN_3);		// i				+
000030  2308              MOVS     r3,#8
000032  2202              MOVS     r2,#2
000034  2148              MOVS     r1,#0x48
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       gpio_init
;;;18     	gpio_init(GPIOC, GPIO_MODE_IPU, GPIO_OSPEED_2MHZ, GPIO_PIN_4);		// light		-
00003c  2310              MOVS     r3,#0x10
00003e  2202              MOVS     r2,#2
000040  2148              MOVS     r1,#0x48
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       gpio_init
;;;19     	
;;;20     	// 一定要在KEYMSG_RegisterKeyScanCallback()函数之前调用
;;;21     	KEYMSG_Init();
000048  f7fffffe          BL       KEYMSG_Init
;;;22     	
;;;23     	// 注册按键扫描接口
;;;24     	KEYMSG_RegisterKeyScanCallback(KEY_CALLBACK_Scan);
00004c  e8bd4010          POP      {r4,lr}
000050  4802              LDR      r0,|L4.92|
000052  f7ffbffe          B.W      KEYMSG_RegisterKeyScanCallback
;;;25     }
;;;26     
                          ENDP

000056  0000              DCW      0x0000
                  |L4.88|
                          DCD      0x40011000
                  |L4.92|
                          DCD      KEY_CALLBACK_Scan

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  keyCB
                          %        10

                          AREA ||.data||, DATA, ALIGN=0

                  testkey
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "User\\key.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_key_c_KEY_Init____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___5_key_c_KEY_Init____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_key_c_KEY_Init____REVSH|
#line 128
|__asm___5_key_c_KEY_Init____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
