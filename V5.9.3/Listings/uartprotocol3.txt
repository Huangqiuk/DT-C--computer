; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\uartprotocol3.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\uartprotocol3.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -I.\User\qrencode -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.3\Device\Include -D__MICROLIB -D__UVISION_VERSION=539 -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\uartprotocol3.crf User\UartProtocol3.c]
                          THUMB

                          AREA ||i.UART_PROTOCOL3_CheckSUM||, CODE, READONLY, ALIGN=1

                  UART_PROTOCOL3_CheckSUM PROC
;;;418    // 对传入的命令帧进行校验，返回校验结果
;;;419    BOOL UART_PROTOCOL3_CheckSUM(UART_PROTOCOL3_RX_CMD_FRAME *pCmdFrame)
000000  b530              PUSH     {r4,r5,lr}
;;;420    {
000002  4601              MOV      r1,r0
;;;421        uint16 checkSum = 0;
000004  2400              MOVS     r4,#0
;;;422        uint16 sumTemp;
;;;423        uint16 i = 0;
000006  2300              MOVS     r3,#0
;;;424    
;;;425        if (NULL == pCmdFrame)
000008  b909              CBNZ     r1,|L1.14|
;;;426        {
;;;427            return FALSE;
00000a  2000              MOVS     r0,#0
                  |L1.12|
;;;428        }
;;;429    
;;;430        // 从设备地址开始，到校验码之前的一个字节，依次进行累加运算
;;;431        for (i = 1; i < pCmdFrame->length - 4; i++)
;;;432        {
;;;433            checkSum += pCmdFrame->buff[i];
;;;434        }
;;;435    
;;;436        // 累加和，低字节在前，高字节在后
;;;437        sumTemp = pCmdFrame->buff[pCmdFrame->length - 3]; // 高字节
;;;438        sumTemp <<= 8;
;;;439        sumTemp += pCmdFrame->buff[pCmdFrame->length - 4]; // 低字节
;;;440    
;;;441        // 判断计算得到的校验码与命令帧中的校验码是否相同
;;;442        if (sumTemp != checkSum)
;;;443        {
;;;444            return FALSE;
;;;445        }
;;;446    
;;;447        return TRUE;
;;;448    }
00000c  bd30              POP      {r4,r5,pc}
                  |L1.14|
00000e  2301              MOVS     r3,#1                 ;431
000010  e005              B        |L1.30|
                  |L1.18|
000012  1c88              ADDS     r0,r1,#2              ;433
000014  5cc0              LDRB     r0,[r0,r3]            ;433
000016  4420              ADD      r0,r0,r4              ;433
000018  b284              UXTH     r4,r0                 ;433
00001a  1c58              ADDS     r0,r3,#1              ;431
00001c  b283              UXTH     r3,r0                 ;431
                  |L1.30|
00001e  f8b10098          LDRH     r0,[r1,#0x98]         ;431
000022  1f00              SUBS     r0,r0,#4              ;431
000024  4298              CMP      r0,r3                 ;431
000026  dcf4              BGT      |L1.18|
000028  f8b10098          LDRH     r0,[r1,#0x98]         ;437
00002c  1ec0              SUBS     r0,r0,#3              ;437
00002e  1c8d              ADDS     r5,r1,#2              ;437
000030  5c2a              LDRB     r2,[r5,r0]            ;437
000032  f64f70ff          MOV      r0,#0xffff            ;438
000036  ea002202          AND      r2,r0,r2,LSL #8       ;438
00003a  f8b10098          LDRH     r0,[r1,#0x98]         ;439
00003e  1f00              SUBS     r0,r0,#4              ;439
000040  5c28              LDRB     r0,[r5,r0]            ;439
000042  4410              ADD      r0,r0,r2              ;439
000044  b282              UXTH     r2,r0                 ;439
000046  42a2              CMP      r2,r4                 ;442
000048  d001              BEQ      |L1.78|
00004a  2000              MOVS     r0,#0                 ;444
00004c  e7de              B        |L1.12|
                  |L1.78|
00004e  2001              MOVS     r0,#1                 ;447
000050  e7dc              B        |L1.12|
;;;449    
                          ENDP


                          AREA ||i.UART_PROTOCOL3_CmdFrameProcess||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL3_CmdFrameProcess PROC
;;;450    // UART命令帧缓冲区处理
;;;451    void UART_PROTOCOL3_CmdFrameProcess(UART_PROTOCOL3_CB *pCB)
000000  e92d43fe          PUSH     {r1-r9,lr}
;;;452    {
000004  4605              MOV      r5,r0
;;;453        UART_PROTOCOL3_CMD cmd = UART_PROTOCOL3_CMD_NULL;
000006  f04f0800          MOV      r8,#0
;;;454        UART_PROTOCOL3_RX_CMD_FRAME *pCmdFrame = NULL;
00000a  2400              MOVS     r4,#0
;;;455    
;;;456        BOOL checkMark;
;;;457        uint8_t i = 0;
00000c  2600              MOVS     r6,#0
;;;458        uint8 buffFlag[4] = {0xFF};
00000e  48ab              LDR      r0,|L2.700|
000010  6800              LDR      r0,[r0,#0]  ; <Data2>
000012  9002              STR      r0,[sp,#8]
;;;459    
;;;460        // 参数合法性检验
;;;461        if (NULL == pCB)
000014  b90d              CBNZ     r5,|L2.26|
                  |L2.22|
;;;462        {
;;;463            return;
;;;464        }
;;;465    
;;;466        // 命令帧缓冲区为空，退出
;;;467        if (pCB->rx.head == pCB->rx.end)
;;;468        {
;;;469            return;
;;;470        }
;;;471    
;;;472        // 获取当前要处理的命令帧指针
;;;473        pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.head];
;;;474    
;;;475        // 命令头非法，退出
;;;476        if (UART_PROTOCOL3_CMD_HEAD != pCmdFrame->buff[UART_PROTOCOL3_CMD_HEAD_INDEX])
;;;477        {
;;;478            // 删除命令帧
;;;479            pCB->rx.head++;
;;;480            pCB->rx.head %= UART_PROTOCOL3_RX_QUEUE_SIZE;
;;;481            return;
;;;482        }
;;;483    
;;;484        // 命令头合法，则提取命令
;;;485        cmd = (UART_PROTOCOL3_CMD)pCmdFrame->buff[UART_PROTOCOL3_CMD_CMD_INDEX];
;;;486    
;;;487        // 若为IOT升级
;;;488        if(UART_PROTOCOL3_IOT_DEVICE_ADDR == pCmdFrame->buff[UART_PROTOCOL3_CMD_DEVICE_ADDR_INDEX])
;;;489        {
;;;490            // 执行命令帧
;;;491            switch (cmd)
;;;492            {
;;;493                // 空命令，不予执行
;;;494                case UART_PROTOCOL3_CMD_NULL: 
;;;495                    break;
;;;496    
;;;497                // 升级请求命令（0xF1）
;;;498                case UART_PROTOCOL3_CMD_UPDATE_REQUEST: 
;;;499                    TIMER_KillTask(TIMER_ID_SEND_UP_APP_REQUEST);
;;;500                
;;;501                    //   0：设备拒绝升级，1：设备同意升级。 
;;;502                    if(pCmdFrame->buff[UART_PROTOCOL3_CMD_DATA1_INDEX])
;;;503                    {
;;;504                        STATE_SwitchStep(STEP_IOT_UART_UPGRADE_SEND_APP_EAR);                    
;;;505                    }
;;;506                    else
;;;507                    {
;;;508                        // 跳到超时处理步骤代表升级失败
;;;509                        STATE_SwitchStep(STEP_IOT_UART_UPGRADE_COMMUNICATION_TIME_OUT);                 
;;;510                    }
;;;511                    break;
;;;512    
;;;513                // 升级固件命令（0xF2）
;;;514                case UART_PROTOCOL3_CMD_UPDATE_START: 
;;;515                
;;;516                    //   该命令用于应答升级命令结果，若超过存储空间，则返回0。
;;;517                    if(0 == pCmdFrame->buff[UART_PROTOCOL3_CMD_DATA1_INDEX])
;;;518                    {
;;;519                        // 跳到超时处理步骤代表升级失败                
;;;520                        STATE_SwitchStep(STEP_IOT_UART_UPGRADE_COMMUNICATION_TIME_OUT);                    
;;;521                    }
;;;522                    else
;;;523                    {
;;;524                        STATE_SwitchStep(STEP_IOT_UART_UPGRADE_SEND_FIRST_APP_PACKET);                 
;;;525                    }
;;;526                    break;
;;;527    
;;;528                // 数据包写入命令（0xF3）
;;;529                case UART_PROTOCOL3_CMD_WRITE_DATA: 
;;;530    
;;;531                    if (0 == pCmdFrame->buff[UART_PROTOCOL3_CMD_DATA1_INDEX])
;;;532                    {
;;;533                        if (0 < dut_info.currentAppSize)
;;;534                        {
;;;535                            dut_info.currentAppSize--;
;;;536                        }
;;;537                        break;
;;;538                    }
;;;539                    if (dut_info.currentAppSize < dut_info.appSize)
;;;540                    {
;;;541                        STATE_SwitchStep(STEP_IOT_UART_UPGRADE_SEND_APP_PACKET);
;;;542                    }
;;;543                    else
;;;544                    {
;;;545                        STATE_SwitchStep(STEP_IOT_UART_UPGRADE_APP_UP_SUCCESS);
;;;546                    }
;;;547                    break;
;;;548    
;;;549                // 数据包写入完成命令（0xF4）0：包传输完成，CRC未通过校验；1：包传输完成，CRC通过校验
;;;550                case UART_PROTOCOL3_CMD_WRITE_COMPLETE: 
;;;551                
;;;552                    if(0 == pCmdFrame->buff[UART_PROTOCOL3_CMD_DATA1_INDEX])
;;;553                    {
;;;554                        // 跳到超时处理步骤代表升级失败                
;;;555                        STATE_SwitchStep(STEP_IOT_UART_UPGRADE_COMMUNICATION_TIME_OUT);                    
;;;556                    }
;;;557                    else
;;;558                    {
;;;559                        STATE_SwitchStep(STEP_IOT_UART_UPGRADE_ITEM_FINISH);                 
;;;560                    }
;;;561                    break;
;;;562                    
;;;563                default:
;;;564                    break;
;;;565            }     
;;;566        }
;;;567        else
;;;568        {
;;;569            // 执行命令帧
;;;570            switch (cmd)
;;;571            {
;;;572                // 空命令，不予执行
;;;573                case UART_PROTOCOL3_CMD_CONFIG_SET: // 0x53
;;;574                    break;
;;;575    
;;;576                // 协议切换
;;;577                case UART_PROTOCOL3_CMD_PROTOCOL_SWITCCH:
;;;578        //            TIMER_KillTask(TIMER_ID_SET_DUT_UI_VER);
;;;579    
;;;580                    if (!writeUiFlag)
;;;581                    {
;;;582                        TIMER_KillTask(TIMER_ID_PROTOCOL_SWITCCH);
;;;583    
;;;584                        // 协议切换成功
;;;585                        if (pCmdFrame->buff[UART_PROTOCOL3_CMD_DATA1_INDEX])
;;;586                        {
;;;587                            STATE_SwitchStep(STEP_CM_UART_BC_UPGRADE_WAIT_FOR_ACK);
;;;588    
;;;589                            // 发送配置
;;;590                            TIMER_AddTask(TIMER_ID_SET_DUT_CONFIG,
;;;591                                          500,
;;;592                                          STATE_SwitchStep,
;;;593                                          STEP_UART_SEND_SET_CONFIG,
;;;594                                          TIMER_LOOP_FOREVER,
;;;595                                          ACTION_MODE_ADD_TO_QUEUE);
;;;596                        }
;;;597                    }
;;;598                    break;
;;;599    
;;;600                // 写入版本信息
;;;601                case UART_PROTOCOL3_CMD_VERSION_TYPE_WRITE:
;;;602                TIMER_KillTask(TIMER_ID_SET_DUT_UI_VER);
;;;603                    if ((8 ==  pCmdFrame->buff[UART_PROTOCOL3_CMD_DATA1_INDEX]) && (TRUE == pCmdFrame->buff[UART_PROTOCOL3_CMD_DATA2_INDEX]))
;;;604                    {
;;;605                        STATE_SwitchStep(STEP_CM_UART_BC_READ_UI_VER);
;;;606                    }
;;;607                    else
;;;608                    {
;;;609                        dut_info.uiUpFaile = TRUE; // ui升级失败
;;;610                        STATE_EnterState(STATE_STANDBY);
;;;611                    }
;;;612                    break;
;;;613    
;;;614                // 读取版本信息
;;;615                case UART_PROTOCOL3_CMD_VERSION_TYPE_READ:
;;;616                
;;;617                    if (8 ==  pCmdFrame->buff[UART_PROTOCOL3_CMD_DATA1_INDEX])
;;;618                    {
;;;619                        // 校验
;;;620                        for (i = 0; i < pCmdFrame->buff[UART_PROTOCOL3_CMD_DATA2_INDEX]; i++)
;;;621                        {
;;;622                            if (uiVerifiedBuff[i] != pCmdFrame->buff[UART_PROTOCOL3_CMD_DATA3_INDEX + i])
;;;623                            {
;;;624                                checkMark = FALSE;  // 发现不匹配，设置标志为假
;;;625                                break;              // 跳出循环
;;;626                            }
;;;627                            else
;;;628                            {
;;;629                                checkMark = TRUE;   // 所有元素都匹配，设置标志为真
;;;630                            }
;;;631                        }
;;;632    
;;;633                        if (checkMark)
;;;634                        {
;;;635                            STATE_SwitchStep(STEP_CM_UART_BC_WRITE_UI_VER_SUCCESS);
;;;636                        }
;;;637                        else
;;;638                        {
;;;639                            dut_info.uiUpFaile = TRUE; // ui升级失败
;;;640                            STATE_EnterState(STATE_STANDBY);
;;;641                        }
;;;642                    }
;;;643                    else
;;;644                    {
;;;645                        dut_info.uiUpFaile = TRUE; // ui升级失败
;;;646                        STATE_EnterState(STATE_STANDBY);
;;;647                    }
;;;648                    break;
;;;649    
;;;650                // dut_config写入成功
;;;651                case UART_PROTOCOL3_CMD_WRITE_CONFIG_RESULT: // 0xc1
;;;652                    TIMER_KillTask(TIMER_ID_SET_DUT_CONFIG);
;;;653                    STATE_SwitchStep(STEP_UART_READ_CONFIG);
;;;654                    break;
;;;655    
;;;656                // 校验配置参数
;;;657                case UART_PROTOCOL3_CMD_READ_CONTROL_PARAM_REPORT: // 0xc3
;;;658    
;;;659                    for (i = 0; i < pCmdFrame->buff[UART_PROTOCOL3_CMD_LENGTH_INDEX]; i++)
;;;660                    {
;;;661                        if (verifiedBuff[i] != pCmdFrame->buff[UART_PROTOCOL3_CMD_DATA1_INDEX + i])
;;;662                        {
;;;663                            checkMark = FALSE;  // 发现不匹配，设置标志为假
;;;664                            break;              // 跳出循环
;;;665                        }
;;;666                        else
;;;667                        {
;;;668                            checkMark = TRUE;   // 所有元素都匹配，设置标志为真
;;;669                        }
;;;670                    }
;;;671    
;;;672                    // 写入配置成功就写入标志位
;;;673                    if (checkMark)
;;;674                    {
;;;675                        STATE_SwitchStep(STEP_UART_DCD_FLAG_WRITE);
;;;676                    }
;;;677                    else
;;;678                    {
;;;679                        dut_info.configUpFaile = TRUE; // config升级失败
;;;680                        STATE_EnterState(STATE_STANDBY);
;;;681                    }
;;;682                    break;
;;;683    
;;;684                // 写入DCD工位标志位
;;;685                case UART_PROTOCOL3_CMD_DCD_FLAG_WRITE:   
;;;686                
;;;687                    // 校验标志区数据
;;;688                    if (pCmdFrame->buff[UART_PROTOCOL3_CMD_DATA1_INDEX])
;;;689                    {
;;;690                        STATE_SwitchStep(STEP_UART_DCD_FLAG_READ);
;;;691                    }
;;;692                    else
;;;693                    {
;;;694                        dut_info.configUpFaile = TRUE; // config升级失败
;;;695                        STATE_EnterState(STATE_STANDBY);
;;;696                    }         
;;;697                  break;
;;;698    
;;;699                // 读取DCD工位标志位
;;;700                case UART_PROTOCOL3_CMD_DCD_FLAG_READ:
;;;701                
;;;702                     // 起始符 + 设备地址 + 命令字 + 数据长度 + 标志区数据长度 + （数据 +）×N + 校验码 + 结束符
;;;703                     // 读取DCD标志区数据（站位编号 * （每个标志位四个数据） + （第一个标志位前的数据(即数据前有五个数据)） + 第几个标志位）
;;;704                    for (i = 0; i < 4; i++)
;;;705                    {
;;;706                        buffFlag[i] = pCmdFrame->buff[(5 * 4) + 5 + i];
;;;707                    }
;;;708    
;;;709                    // 校验标志区数据
;;;710                    if ((buffFlag[0] == 0x00) && (buffFlag[1] == 0x00) && (buffFlag[2] == 0x00) && (buffFlag[3] == 0x02))
;;;711                    {
;;;712                        STATE_SwitchStep(STEP_UART_SET_CONFIG_SUCCESS);
;;;713                    }
;;;714                    else
;;;715                    {
;;;716                        dut_info.configUpFaile = TRUE; // config升级失败
;;;717                        STATE_EnterState(STATE_STANDBY);
;;;718                    }              
;;;719                  break;
;;;720                  
;;;721                default:
;;;722                    break;
;;;723            }    
;;;724        }
;;;725        
;;;726        // 删除命令帧
;;;727        pCB->rx.head++;
;;;728        pCB->rx.head %= UART_PROTOCOL3_RX_QUEUE_SIZE;
;;;729    }
000016  e8bd83fe          POP      {r1-r9,pc}
                  |L2.26|
00001a  f8b5129e          LDRH     r1,[r5,#0x29e]        ;467
00001e  f8b502a0          LDRH     r0,[r5,#0x2a0]        ;467
000022  4281              CMP      r1,r0                 ;467
000024  d100              BNE      |L2.40|
000026  e7f6              B        |L2.22|
                  |L2.40|
000028  f8b5029e          LDRH     r0,[r5,#0x29e]        ;473
00002c  214d              MOVS     r1,#0x4d              ;473
00002e  4348              MULS     r0,r1,r0              ;473
000030  f10501d0          ADD      r1,r5,#0xd0           ;473
000034  eb010440          ADD      r4,r1,r0,LSL #1       ;473
000038  78a0              LDRB     r0,[r4,#2]            ;476
00003a  283a              CMP      r0,#0x3a              ;476
00003c  d00e              BEQ      |L2.92|
00003e  f8b5029e          LDRH     r0,[r5,#0x29e]        ;479
000042  1c40              ADDS     r0,r0,#1              ;479
000044  f8a5029e          STRH     r0,[r5,#0x29e]        ;479
000048  f8b5029e          LDRH     r0,[r5,#0x29e]        ;480
00004c  2103              MOVS     r1,#3                 ;480
00004e  fb90f2f1          SDIV     r2,r0,r1              ;480
000052  fb010012          MLS      r0,r1,r2,r0           ;480
000056  f8a5029e          STRH     r0,[r5,#0x29e]        ;480
00005a  e7dc              B        |L2.22|
                  |L2.92|
00005c  f8948004          LDRB     r8,[r4,#4]            ;485
000060  78e0              LDRB     r0,[r4,#3]            ;488
000062  282a              CMP      r0,#0x2a              ;488
000064  d14f              BNE      |L2.262|
000066  f1b80ff2          CMP      r8,#0xf2              ;491
00006a  d01c              BEQ      |L2.166|
00006c  dc06              BGT      |L2.124|
00006e  f1b80f00          CMP      r8,#0                 ;491
000072  d00a              BEQ      |L2.138|
000074  f1b80ff1          CMP      r8,#0xf1              ;491
000078  d143              BNE      |L2.258|
00007a  e007              B        |L2.140|
                  |L2.124|
00007c  f1b80ff3          CMP      r8,#0xf3              ;491
000080  d01b              BEQ      |L2.186|
000082  f1b80ff4          CMP      r8,#0xf4              ;491
000086  d13c              BNE      |L2.258|
000088  e031              B        |L2.238|
                  |L2.138|
00008a  e03b              B        |L2.260|
                  |L2.140|
00008c  2011              MOVS     r0,#0x11              ;499
00008e  f7fffffe          BL       TIMER_KillTask
000092  79a0              LDRB     r0,[r4,#6]            ;502
000094  b118              CBZ      r0,|L2.158|
000096  2094              MOVS     r0,#0x94              ;504
000098  f7fffffe          BL       STATE_SwitchStep
00009c  e002              B        |L2.164|
                  |L2.158|
00009e  2099              MOVS     r0,#0x99              ;509
0000a0  f7fffffe          BL       STATE_SwitchStep
                  |L2.164|
0000a4  e02e              B        |L2.260|
                  |L2.166|
0000a6  79a0              LDRB     r0,[r4,#6]            ;517
0000a8  b918              CBNZ     r0,|L2.178|
0000aa  2099              MOVS     r0,#0x99              ;520
0000ac  f7fffffe          BL       STATE_SwitchStep
0000b0  e002              B        |L2.184|
                  |L2.178|
0000b2  2095              MOVS     r0,#0x95              ;524
0000b4  f7fffffe          BL       STATE_SwitchStep
                  |L2.184|
0000b8  e024              B        |L2.260|
                  |L2.186|
0000ba  79a0              LDRB     r0,[r4,#6]            ;531
0000bc  b948              CBNZ     r0,|L2.210|
0000be  4880              LDR      r0,|L2.704|
0000c0  6b00              LDR      r0,[r0,#0x30]         ;533  ; dut_info
0000c2  2800              CMP      r0,#0                 ;533
0000c4  d904              BLS      |L2.208|
0000c6  487e              LDR      r0,|L2.704|
0000c8  6b00              LDR      r0,[r0,#0x30]         ;535  ; dut_info
0000ca  1e40              SUBS     r0,r0,#1              ;535
0000cc  497c              LDR      r1,|L2.704|
0000ce  6308              STR      r0,[r1,#0x30]         ;535  ; dut_info
                  |L2.208|
0000d0  e018              B        |L2.260|
                  |L2.210|
0000d2  487b              LDR      r0,|L2.704|
0000d4  6b00              LDR      r0,[r0,#0x30]         ;539  ; dut_info
0000d6  497a              LDR      r1,|L2.704|
0000d8  6a49              LDR      r1,[r1,#0x24]         ;539  ; dut_info
0000da  4288              CMP      r0,r1                 ;539
0000dc  d203              BCS      |L2.230|
0000de  2096              MOVS     r0,#0x96              ;541
0000e0  f7fffffe          BL       STATE_SwitchStep
0000e4  e002              B        |L2.236|
                  |L2.230|
0000e6  2097              MOVS     r0,#0x97              ;545
0000e8  f7fffffe          BL       STATE_SwitchStep
                  |L2.236|
0000ec  e00a              B        |L2.260|
                  |L2.238|
0000ee  79a0              LDRB     r0,[r4,#6]            ;552
0000f0  b918              CBNZ     r0,|L2.250|
0000f2  2099              MOVS     r0,#0x99              ;555
0000f4  f7fffffe          BL       STATE_SwitchStep
0000f8  e002              B        |L2.256|
                  |L2.250|
0000fa  2098              MOVS     r0,#0x98              ;559
0000fc  f7fffffe          BL       STATE_SwitchStep
                  |L2.256|
000100  e000              B        |L2.260|
                  |L2.258|
000102  bf00              NOP                            ;564
                  |L2.260|
000104  e0c9              B        |L2.666|
                  |L2.262|
000106  f1b80fa9          CMP      r8,#0xa9              ;570
00010a  d043              BEQ      |L2.404|
00010c  dc0c              BGT      |L2.296|
00010e  f1b80f53          CMP      r8,#0x53              ;570
000112  d013              BEQ      |L2.316|
000114  f1b80fa6          CMP      r8,#0xa6              ;570
000118  d076              BEQ      |L2.520|
00011a  f1b80fa7          CMP      r8,#0xa7              ;570
00011e  d074              BEQ      |L2.522|
000120  f1b80fa8          CMP      r8,#0xa8              ;570
                  |L2.292|
000124  d172              BNE      |L2.524|
000126  e021              B        |L2.364|
                  |L2.296|
000128  f1b80fab          CMP      r8,#0xab              ;570
00012c  d007              BEQ      |L2.318|
00012e  f1b80fc1          CMP      r8,#0xc1              ;570
000132  d057              BEQ      |L2.484|
000134  f1b80fc3          CMP      r8,#0xc3              ;570
000138  d1f4              BNE      |L2.292|
00013a  e05a              B        |L2.498|
                  |L2.316|
00013c  e0ac              B        |L2.664|
                  |L2.318|
00013e  4861              LDR      r0,|L2.708|
000140  7800              LDRB     r0,[r0,#0]            ;580  ; writeUiFlag
000142  b990              CBNZ     r0,|L2.362|
000144  200e              MOVS     r0,#0xe               ;582
000146  f7fffffe          BL       TIMER_KillTask
00014a  79a0              LDRB     r0,[r4,#6]            ;585
00014c  b168              CBZ      r0,|L2.362|
00014e  2057              MOVS     r0,#0x57              ;587
000150  f7fffffe          BL       STATE_SwitchStep
000154  2001              MOVS     r0,#1                 ;590
000156  1e81              SUBS     r1,r0,#2              ;590
000158  239c              MOVS     r3,#0x9c              ;590
00015a  4a5b              LDR      r2,|L2.712|
00015c  e9cd1000          STRD     r1,r0,[sp,#0]         ;590
000160  f44f71fa          MOV      r1,#0x1f4             ;590
000164  2002              MOVS     r0,#2                 ;590
000166  f7fffffe          BL       TIMER_AddTask
                  |L2.362|
00016a  e095              B        |L2.664|
                  |L2.364|
00016c  2010              MOVS     r0,#0x10              ;602
00016e  f7fffffe          BL       TIMER_KillTask
000172  79a0              LDRB     r0,[r4,#6]            ;603
000174  2808              CMP      r0,#8                 ;603
000176  d106              BNE      |L2.390|
000178  79e0              LDRB     r0,[r4,#7]            ;603
00017a  2801              CMP      r0,#1                 ;603
00017c  d103              BNE      |L2.390|
00017e  2062              MOVS     r0,#0x62              ;605
000180  f7fffffe          BL       STATE_SwitchStep
000184  e005              B        |L2.402|
                  |L2.390|
000186  2001              MOVS     r0,#1                 ;609
000188  494d              LDR      r1,|L2.704|
00018a  f881003a          STRB     r0,[r1,#0x3a]         ;609
00018e  f7fffffe          BL       STATE_EnterState
                  |L2.402|
000192  e081              B        |L2.664|
                  |L2.404|
000194  79a0              LDRB     r0,[r4,#6]            ;617
000196  2808              CMP      r0,#8                 ;617
000198  d11d              BNE      |L2.470|
00019a  2600              MOVS     r6,#0                 ;620
00019c  e00b              B        |L2.438|
                  |L2.414|
00019e  484b              LDR      r0,|L2.716|
0001a0  5d82              LDRB     r2,[r0,r6]            ;622
0001a2  1db0              ADDS     r0,r6,#6              ;622
0001a4  1ca1              ADDS     r1,r4,#2              ;622
0001a6  5c08              LDRB     r0,[r1,r0]            ;622
0001a8  4282              CMP      r2,r0                 ;622
0001aa  d001              BEQ      |L2.432|
0001ac  2700              MOVS     r7,#0                 ;624
0001ae  e005              B        |L2.444|
                  |L2.432|
0001b0  2701              MOVS     r7,#1                 ;629
0001b2  1c70              ADDS     r0,r6,#1              ;620
0001b4  b2c6              UXTB     r6,r0                 ;620
                  |L2.438|
0001b6  79e0              LDRB     r0,[r4,#7]            ;620
0001b8  42b0              CMP      r0,r6                 ;620
0001ba  dcf0              BGT      |L2.414|
                  |L2.444|
0001bc  bf00              NOP                            ;625
0001be  b11f              CBZ      r7,|L2.456|
0001c0  2063              MOVS     r0,#0x63              ;635
0001c2  f7fffffe          BL       STATE_SwitchStep
0001c6  e00c              B        |L2.482|
                  |L2.456|
0001c8  2001              MOVS     r0,#1                 ;639
0001ca  493d              LDR      r1,|L2.704|
0001cc  f881003a          STRB     r0,[r1,#0x3a]         ;639
0001d0  f7fffffe          BL       STATE_EnterState
0001d4  e005              B        |L2.482|
                  |L2.470|
0001d6  2001              MOVS     r0,#1                 ;645
0001d8  4939              LDR      r1,|L2.704|
0001da  f881003a          STRB     r0,[r1,#0x3a]         ;645
0001de  f7fffffe          BL       STATE_EnterState
                  |L2.482|
0001e2  e059              B        |L2.664|
                  |L2.484|
0001e4  2002              MOVS     r0,#2                 ;652
0001e6  f7fffffe          BL       TIMER_KillTask
0001ea  209d              MOVS     r0,#0x9d              ;653
0001ec  f7fffffe          BL       STATE_SwitchStep
0001f0  e052              B        |L2.664|
                  |L2.498|
0001f2  2600              MOVS     r6,#0                 ;659
0001f4  e00e              B        |L2.532|
                  |L2.502|
0001f6  4836              LDR      r0,|L2.720|
0001f8  5d82              LDRB     r2,[r0,r6]            ;661
0001fa  1d30              ADDS     r0,r6,#4              ;661
0001fc  1ca1              ADDS     r1,r4,#2              ;661
0001fe  5c08              LDRB     r0,[r1,r0]            ;661
000200  4282              CMP      r2,r0                 ;661
000202  d004              BEQ      |L2.526|
000204  2700              MOVS     r7,#0                 ;663
000206  e008              B        |L2.538|
                  |L2.520|
000208  e021              B        |L2.590|
                  |L2.522|
00020a  e013              B        |L2.564|
                  |L2.524|
00020c  e043              B        |L2.662|
                  |L2.526|
00020e  2701              MOVS     r7,#1                 ;668
000210  1c70              ADDS     r0,r6,#1              ;659
000212  b2c6              UXTB     r6,r0                 ;659
                  |L2.532|
000214  7960              LDRB     r0,[r4,#5]            ;659
000216  42b0              CMP      r0,r6                 ;659
000218  dced              BGT      |L2.502|
                  |L2.538|
00021a  bf00              NOP                            ;664
00021c  b11f              CBZ      r7,|L2.550|
00021e  209f              MOVS     r0,#0x9f              ;675
000220  f7fffffe          BL       STATE_SwitchStep
000224  e005              B        |L2.562|
                  |L2.550|
000226  2001              MOVS     r0,#1                 ;679
000228  4925              LDR      r1,|L2.704|
00022a  f881003b          STRB     r0,[r1,#0x3b]         ;679
00022e  f7fffffe          BL       STATE_EnterState
                  |L2.562|
000232  e031              B        |L2.664|
                  |L2.564|
000234  79a0              LDRB     r0,[r4,#6]            ;688
000236  b118              CBZ      r0,|L2.576|
000238  20a0              MOVS     r0,#0xa0              ;690
00023a  f7fffffe          BL       STATE_SwitchStep
00023e  e005              B        |L2.588|
                  |L2.576|
000240  2001              MOVS     r0,#1                 ;694
000242  491f              LDR      r1,|L2.704|
000244  f881003b          STRB     r0,[r1,#0x3b]         ;694
000248  f7fffffe          BL       STATE_EnterState
                  |L2.588|
00024c  e024              B        |L2.664|
                  |L2.590|
00024e  2600              MOVS     r6,#0                 ;704
000250  e007              B        |L2.610|
                  |L2.594|
000252  f1060019          ADD      r0,r6,#0x19           ;706
000256  1ca1              ADDS     r1,r4,#2              ;706
000258  5c08              LDRB     r0,[r1,r0]            ;706
00025a  a902              ADD      r1,sp,#8              ;706
00025c  5588              STRB     r0,[r1,r6]            ;706
00025e  1c70              ADDS     r0,r6,#1              ;704
000260  b2c6              UXTB     r6,r0                 ;704
                  |L2.610|
000262  2e04              CMP      r6,#4                 ;704
000264  dbf5              BLT      |L2.594|
000266  f89d0008          LDRB     r0,[sp,#8]            ;710
00026a  b968              CBNZ     r0,|L2.648|
00026c  f89d0009          LDRB     r0,[sp,#9]            ;710
000270  b950              CBNZ     r0,|L2.648|
000272  f89d000a          LDRB     r0,[sp,#0xa]          ;710
000276  b938              CBNZ     r0,|L2.648|
000278  f89d000b          LDRB     r0,[sp,#0xb]          ;710
00027c  2802              CMP      r0,#2                 ;710
00027e  d103              BNE      |L2.648|
000280  209e              MOVS     r0,#0x9e              ;712
000282  f7fffffe          BL       STATE_SwitchStep
000286  e005              B        |L2.660|
                  |L2.648|
000288  2001              MOVS     r0,#1                 ;716
00028a  490d              LDR      r1,|L2.704|
00028c  f881003b          STRB     r0,[r1,#0x3b]         ;716
000290  f7fffffe          BL       STATE_EnterState
                  |L2.660|
000294  e000              B        |L2.664|
                  |L2.662|
000296  bf00              NOP                            ;722
                  |L2.664|
000298  bf00              NOP                            ;574
                  |L2.666|
00029a  f8b5029e          LDRH     r0,[r5,#0x29e]        ;727
00029e  1c40              ADDS     r0,r0,#1              ;727
0002a0  f8a5029e          STRH     r0,[r5,#0x29e]        ;727
0002a4  f8b5029e          LDRH     r0,[r5,#0x29e]        ;728
0002a8  2103              MOVS     r1,#3                 ;728
0002aa  fb90f2f1          SDIV     r2,r0,r1              ;728
0002ae  fb010012          MLS      r0,r1,r2,r0           ;728
0002b2  f8a5029e          STRH     r0,[r5,#0x29e]        ;728
0002b6  bf00              NOP      
0002b8  e6ad              B        |L2.22|
;;;730    
                          ENDP

0002ba  0000              DCW      0x0000
                  |L2.700|
                          DCD      ||.constdata||
                  |L2.704|
                          DCD      dut_info
                  |L2.708|
                          DCD      writeUiFlag
                  |L2.712|
                          DCD      STATE_SwitchStep
                  |L2.716|
                          DCD      uiVerifiedBuff
                  |L2.720|
                          DCD      verifiedBuff

                          AREA ||i.UART_PROTOCOL3_ConfirmTempCmdFrameBuff||, CODE, READONLY, ALIGN=1

                  UART_PROTOCOL3_ConfirmTempCmdFrameBuff PROC
;;;199    // 将临时缓冲区添加到命令帧缓冲区中，其本质操作是承认临时缓冲区数据有效
;;;200    BOOL UART_PROTOCOL3_ConfirmTempCmdFrameBuff(UART_PROTOCOL3_CB *pCB)
000000  b510              PUSH     {r4,lr}
;;;201    {
000002  4601              MOV      r1,r0
;;;202        UART_PROTOCOL3_RX_CMD_FRAME *pCmdFrame = NULL;
000004  2200              MOVS     r2,#0
;;;203    
;;;204        // 参数合法性检验
;;;205        if (NULL == pCB)
000006  b909              CBNZ     r1,|L3.12|
;;;206        {
;;;207            return FALSE;
000008  2000              MOVS     r0,#0
                  |L3.10|
;;;208        }
;;;209    
;;;210        // 临时缓冲区为空，不予添加
;;;211        pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.end];
;;;212        if (0 == pCmdFrame->length)
;;;213        {
;;;214            return FALSE;
;;;215        }
;;;216    
;;;217        // 添加
;;;218        pCB->rx.end++;
;;;219        pCB->rx.end %= UART_PROTOCOL3_RX_QUEUE_SIZE;
;;;220        pCB->rx.cmdQueue[pCB->rx.end].length = 0; // 该行的作用是将新的添加位置有效数据个数清零，以便将这个位置当做临时帧缓冲区
;;;221    
;;;222        return TRUE;
;;;223    }
00000a  bd10              POP      {r4,pc}
                  |L3.12|
00000c  f8b102a0          LDRH     r0,[r1,#0x2a0]        ;211
000010  234d              MOVS     r3,#0x4d              ;211
000012  4358              MULS     r0,r3,r0              ;211
000014  f10103d0          ADD      r3,r1,#0xd0           ;211
000018  eb030240          ADD      r2,r3,r0,LSL #1       ;211
00001c  f8b20098          LDRH     r0,[r2,#0x98]         ;212
000020  b908              CBNZ     r0,|L3.38|
000022  2000              MOVS     r0,#0                 ;214
000024  e7f1              B        |L3.10|
                  |L3.38|
000026  f8b102a0          LDRH     r0,[r1,#0x2a0]        ;218
00002a  1c40              ADDS     r0,r0,#1              ;218
00002c  f8a102a0          STRH     r0,[r1,#0x2a0]        ;218
000030  f8b102a0          LDRH     r0,[r1,#0x2a0]        ;219
000034  2303              MOVS     r3,#3                 ;219
000036  fb90f4f3          SDIV     r4,r0,r3              ;219
00003a  fb030014          MLS      r0,r3,r4,r0           ;219
00003e  f8a102a0          STRH     r0,[r1,#0x2a0]        ;219
000042  2400              MOVS     r4,#0                 ;220
000044  f8b102a0          LDRH     r0,[r1,#0x2a0]        ;220
000048  234d              MOVS     r3,#0x4d              ;220
00004a  4358              MULS     r0,r3,r0              ;220
00004c  f10103d0          ADD      r3,r1,#0xd0           ;220
000050  eb030040          ADD      r0,r3,r0,LSL #1       ;220
000054  f8a04098          STRH     r4,[r0,#0x98]         ;220
000058  2001              MOVS     r0,#1                 ;222
00005a  e7d6              B        |L3.10|
;;;224    
                          ENDP


                          AREA ||i.UART_PROTOCOL3_DataStructInit||, CODE, READONLY, ALIGN=1

                  UART_PROTOCOL3_DataStructInit PROC
;;;132    // 数据结构初始化
;;;133    void UART_PROTOCOL3_DataStructInit(UART_PROTOCOL3_CB *pCB)
000000  b510              PUSH     {r4,lr}
;;;134    {
;;;135        uint16 i;
;;;136    
;;;137        // 参数合法性检验
;;;138        if (NULL == pCB)
000002  b900              CBNZ     r0,|L4.6|
                  |L4.4|
;;;139        {
;;;140            return;
;;;141        }
;;;142    
;;;143        pCB->tx.txBusy = FALSE;
;;;144        pCB->tx.index = 0;
;;;145        pCB->tx.head = 0;
;;;146        pCB->tx.end = 0;
;;;147        for (i = 0; i < UART_PROTOCOL3_TX_QUEUE_SIZE; i++)
;;;148        {
;;;149            pCB->tx.cmdQueue[i].length = 0;
;;;150        }
;;;151    
;;;152        pCB->rxFIFO.head = 0;
;;;153        pCB->rxFIFO.end = 0;
;;;154        pCB->rxFIFO.currentProcessIndex = 0;
;;;155    
;;;156        pCB->rx.head = 0;
;;;157        pCB->rx.end = 0;
;;;158        for (i = 0; i < UART_PROTOCOL3_RX_QUEUE_SIZE; i++)
;;;159        {
;;;160            pCB->rx.cmdQueue[i].length = 0;
;;;161        }
;;;162    }
000004  bd10              POP      {r4,pc}
                  |L4.6|
000006  2300              MOVS     r3,#0                 ;143
000008  f88033e0          STRB     r3,[r0,#0x3e0]        ;143
00000c  f8a033de          STRH     r3,[r0,#0x3de]        ;144
000010  f8a033da          STRH     r3,[r0,#0x3da]        ;145
000014  f8a033dc          STRH     r3,[r0,#0x3dc]        ;146
000018  2100              MOVS     r1,#0                 ;147
00001a  e00c              B        |L4.54|
                  |L4.28|
00001c  2300              MOVS     r3,#0                 ;149
00001e  eb010281          ADD      r2,r1,r1,LSL #2       ;149
000022  eb0204c1          ADD      r4,r2,r1,LSL #3       ;149
000026  f20022a2          ADD      r2,r0,#0x2a2          ;149
00002a  eb0202c4          ADD      r2,r2,r4,LSL #3       ;149
00002e  f8a23066          STRH     r3,[r2,#0x66]         ;149
000032  1c4a              ADDS     r2,r1,#1              ;147
000034  b291              UXTH     r1,r2                 ;147
                  |L4.54|
000036  2903              CMP      r1,#3                 ;147
000038  dbf0              BLT      |L4.28|
00003a  2200              MOVS     r2,#0                 ;152
00003c  f8202fc8          STRH     r2,[r0,#0xc8]!        ;152
000040  8042              STRH     r2,[r0,#2]            ;153
000042  8082              STRH     r2,[r0,#4]            ;154
000044  38c8              SUBS     r0,r0,#0xc8           ;154
000046  2300              MOVS     r3,#0                 ;156
000048  f8a0329e          STRH     r3,[r0,#0x29e]        ;156
00004c  f8a032a0          STRH     r3,[r0,#0x2a0]        ;157
000050  2100              MOVS     r1,#0                 ;158
000052  e00a              B        |L4.106|
                  |L4.84|
000054  2400              MOVS     r4,#0                 ;160
000056  224d              MOVS     r2,#0x4d              ;160
000058  434a              MULS     r2,r1,r2              ;160
00005a  f10003d0          ADD      r3,r0,#0xd0           ;160
00005e  eb030242          ADD      r2,r3,r2,LSL #1       ;160
000062  f8a24098          STRH     r4,[r2,#0x98]         ;160
000066  1c4a              ADDS     r2,r1,#1              ;158
000068  b291              UXTH     r1,r2                 ;158
                  |L4.106|
00006a  2903              CMP      r1,#3                 ;158
00006c  dbf2              BLT      |L4.84|
00006e  bf00              NOP      
000070  e7c8              B        |L4.4|
;;;163    
                          ENDP


                          AREA ||i.UART_PROTOCOL3_Init||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL3_Init PROC
;;;41     // 协议初始化
;;;42     void UART_PROTOCOL3_Init(void)
000000  b510              PUSH     {r4,lr}
;;;43     {
;;;44         // 协议层数据结构初始化
;;;45         UART_PROTOCOL3_DataStructInit(&uartProtocolCB3);
000002  4805              LDR      r0,|L5.24|
000004  f7fffffe          BL       UART_PROTOCOL3_DataStructInit
;;;46     
;;;47         // 向驱动层注册数据接收接口
;;;48         UART_DRIVE_RegisterDataSendService(UART_PROTOCOL3_MacProcess);
000008  4804              LDR      r0,|L5.28|
00000a  f7fffffe          BL       UART_DRIVE_RegisterDataSendService
;;;49     
;;;50         // 向驱动层注册数据发送接口
;;;51         UART_PROTOCOL3_RegisterDataSendService(UART_DRIVE_AddTxArray);
00000e  4804              LDR      r0,|L5.32|
000010  f7fffffe          BL       UART_PROTOCOL3_RegisterDataSendService
;;;52     
;;;53         //  TIMER_AddTask(TIMER_ID_PROTOCOL_3A_PARAM_TX,
;;;54         //                  200,
;;;55         //                  UART_PROTOCOL3_22,
;;;56         //                  TRUE,
;;;57         //                  TIMER_LOOP_FOREVER,
;;;58         //                  ACTION_MODE_ADD_TO_QUEUE);
;;;59     }
000014  bd10              POP      {r4,pc}
;;;60     
                          ENDP

000016  0000              DCW      0x0000
                  |L5.24|
                          DCD      uartProtocolCB3
                  |L5.28|
                          DCD      UART_PROTOCOL3_MacProcess
                  |L5.32|
                          DCD      UART_DRIVE_AddTxArray

                          AREA ||i.UART_PROTOCOL3_MacProcess||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL3_MacProcess PROC
;;;164    // UART报文接收处理函数(注意根据具体模块修改)
;;;165    void UART_PROTOCOL3_MacProcess(uint16 standarID, uint8 *pData, uint16 length)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;166    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4617              MOV      r7,r2
;;;167        uint16 end = uartProtocolCB3.rxFIFO.end;
00000a  4819              LDR      r0,|L6.112|
00000c  f8b050ca          LDRH     r5,[r0,#0xca]  ; uartProtocolCB3
;;;168        uint16 head = uartProtocolCB3.rxFIFO.head;
000010  f8b080c8          LDRH     r8,[r0,#0xc8]  ; uartProtocolCB3
;;;169        uint8 rxdata = 0x00;
000014  f04f0900          MOV      r9,#0
;;;170    
;;;171        // 接收数据
;;;172        rxdata = *pData;
000018  f8949000          LDRB     r9,[r4,#0]
;;;173    
;;;174        // 一级缓冲区已满，不予接收
;;;175        if ((end + 1) % UART_PROTOCOL3_RX_FIFO_SIZE == head)
00001c  1c68              ADDS     r0,r5,#1
00001e  21c8              MOVS     r1,#0xc8
000020  fb90f2f1          SDIV     r2,r0,r1
000024  fb010012          MLS      r0,r1,r2,r0
000028  4540              CMP      r0,r8
00002a  d101              BNE      |L6.48|
                  |L6.44|
;;;176        {
;;;177            return;
;;;178        }
;;;179        // 一级缓冲区未满，接收
;;;180        else
;;;181        {
;;;182            // 将接收到的数据放到临时缓冲区中
;;;183            uartProtocolCB3.rxFIFO.buff[end] = rxdata;
;;;184            uartProtocolCB3.rxFIFO.end++;
;;;185            uartProtocolCB3.rxFIFO.end %= UART_PROTOCOL3_RX_FIFO_SIZE;
;;;186        }
;;;187    
;;;188        // 借用KM5S协议解析
;;;189        UART_PROTOCOL_MacProcess(standarID, pData, length);
;;;190        DTA_UART_PROTOCOL_MacProcess(standarID, pData, length);
;;;191    }
00002c  e8bd87f0          POP      {r4-r10,pc}
                  |L6.48|
000030  480f              LDR      r0,|L6.112|
000032  f8009005          STRB     r9,[r0,r5]            ;183
000036  f8b000ca          LDRH     r0,[r0,#0xca]         ;184  ; uartProtocolCB3
00003a  1c40              ADDS     r0,r0,#1              ;184
00003c  490c              LDR      r1,|L6.112|
00003e  f8a100ca          STRH     r0,[r1,#0xca]         ;184
000042  4608              MOV      r0,r1                 ;185
000044  f8b000ca          LDRH     r0,[r0,#0xca]         ;185  ; uartProtocolCB3
000048  21c8              MOVS     r1,#0xc8              ;185
00004a  fb90f2f1          SDIV     r2,r0,r1              ;185
00004e  fb010012          MLS      r0,r1,r2,r0           ;185
000052  4907              LDR      r1,|L6.112|
000054  f8a100ca          STRH     r0,[r1,#0xca]         ;185
000058  463a              MOV      r2,r7                 ;189
00005a  4621              MOV      r1,r4                 ;189
00005c  4630              MOV      r0,r6                 ;189
00005e  f7fffffe          BL       UART_PROTOCOL_MacProcess
000062  463a              MOV      r2,r7                 ;190
000064  4621              MOV      r1,r4                 ;190
000066  4630              MOV      r0,r6                 ;190
000068  f7fffffe          BL       DTA_UART_PROTOCOL_MacProcess
00006c  bf00              NOP      
00006e  e7dd              B        |L6.44|
;;;192    
                          ENDP

                  |L6.112|
                          DCD      uartProtocolCB3

                          AREA ||i.UART_PROTOCOL3_RegisterDataSendService||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL3_RegisterDataSendService PROC
;;;193    // UART协议层向驱动层注册数据发送接口
;;;194    void UART_PROTOCOL3_RegisterDataSendService(BOOL (*service)(uint16 id, uint8 *pData, uint16 length))
000000  4901              LDR      r1,|L7.8|
;;;195    {
;;;196        uartProtocolCB3.sendDataThrowService = service;
000002  f8c103e4          STR      r0,[r1,#0x3e4]  ; uartProtocolCB3
;;;197    }
000006  4770              BX       lr
;;;198    
                          ENDP

                  |L7.8|
                          DCD      uartProtocolCB3

                          AREA ||i.UART_PROTOCOL3_RxFIFOProcess||, CODE, READONLY, ALIGN=1

                  UART_PROTOCOL3_RxFIFOProcess PROC
;;;258    // 一级接收缓冲区处理，从一级接收缓冲区中取出一个字节添加到命令帧缓冲区中
;;;259    void UART_PROTOCOL3_RxFIFOProcess(UART_PROTOCOL3_CB *pCB)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;260    {
000004  4604              MOV      r4,r0
;;;261        uint16 end = pCB->rxFIFO.end;
000006  f8b470ca          LDRH     r7,[r4,#0xca]
;;;262        uint16 head = pCB->rxFIFO.head;
00000a  f8b490c8          LDRH     r9,[r4,#0xc8]
;;;263        UART_PROTOCOL3_RX_CMD_FRAME *pCmdFrame = NULL;
00000e  2500              MOVS     r5,#0
;;;264        uint16 length = 0;
000010  46a8              MOV      r8,r5
;;;265        uint8 currentData = 0;
000012  2600              MOVS     r6,#0
;;;266    
;;;267        // 参数合法性检验
;;;268        if (NULL == pCB)
000014  b90c              CBNZ     r4,|L8.26|
                  |L8.22|
;;;269        {
;;;270            return;
;;;271        }
;;;272    
;;;273        // 一级缓冲区为空，退出
;;;274        if (head == end)
;;;275        {
;;;276            return;
;;;277        }
;;;278    
;;;279        // 获取临时缓冲区指针
;;;280        pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.end];
;;;281        // 取出当前要处理的字节
;;;282        currentData = pCB->rxFIFO.buff[pCB->rxFIFO.currentProcessIndex];
;;;283    
;;;284        // 临时缓冲区长度为0时，搜索首字节
;;;285        if (0 == pCmdFrame->length)
;;;286        {
;;;287            // 命令头错误，删除当前字节并退出
;;;288            if (UART_PROTOCOL3_CMD_HEAD != currentData)
;;;289            {
;;;290                pCB->rxFIFO.head++;
;;;291                pCB->rxFIFO.head %= UART_PROTOCOL3_RX_FIFO_SIZE;
;;;292                pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;293    
;;;294                return;
;;;295            }
;;;296    
;;;297            // 命令头正确，但无临时缓冲区可用，退出
;;;298            if ((pCB->rx.end + 1) % UART_PROTOCOL3_RX_QUEUE_SIZE == pCB->rx.head)
;;;299            {
;;;300                return;
;;;301            }
;;;302    
;;;303            // 添加UART通讯超时时间设置-2016.1.5增加
;;;304    #if UART_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;305            TIMER_AddTask(TIMER_ID_UART_RX_TIME_OUT_CONTROL,
;;;306                          UART_PROTOCOL_BUS_UNIDIRECTIONAL_TIME_OUT,
;;;307                          UART_PROTOCOL_CALLBACK_RxTimeOut,
;;;308                          0,
;;;309                          1,
;;;310                          ACTION_MODE_ADD_TO_QUEUE);
;;;311    #endif
;;;312    
;;;313            // 命令头正确，有临时缓冲区可用，则将其添加到命令帧临时缓冲区中
;;;314            pCmdFrame->buff[pCmdFrame->length++] = currentData;
;;;315            pCB->rxFIFO.currentProcessIndex++;
;;;316            pCB->rxFIFO.currentProcessIndex %= UART_PROTOCOL3_RX_FIFO_SIZE;
;;;317        }
;;;318        // 非首字节，将数据添加到命令帧临时缓冲区中，但暂不删除当前数据
;;;319        else
;;;320        {
;;;321            // 临时缓冲区溢出，说明当前正在接收的命令帧是错误的，正确的命令帧不会出现长度溢出的情况
;;;322            if (pCmdFrame->length >= UART_PROTOCOL3_RX_CMD_FRAME_LENGTH_MAX)
;;;323            {
;;;324    #if UART_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;325                // 停止RX通讯超时检测
;;;326                UART_PROTOCOL_StopRxTimeOutCheck();
;;;327    #endif
;;;328    
;;;329                // 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;330                pCmdFrame->length = 0; // 2016.1.5增加
;;;331                // 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;332                pCB->rxFIFO.head++;
;;;333                pCB->rxFIFO.head %= UART_PROTOCOL3_RX_FIFO_SIZE;
;;;334                pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;335    
;;;336                return;
;;;337            }
;;;338    
;;;339            // 一直取到末尾
;;;340            while (end != pCB->rxFIFO.currentProcessIndex)
;;;341            {
;;;342                // 取出当前要处理的字节
;;;343                currentData = pCB->rxFIFO.buff[pCB->rxFIFO.currentProcessIndex];
;;;344                // 缓冲区未溢出，正常接收，将数据添加到临时缓冲区中
;;;345                pCmdFrame->buff[pCmdFrame->length++] = currentData;
;;;346                pCB->rxFIFO.currentProcessIndex++;
;;;347                pCB->rxFIFO.currentProcessIndex %= UART_PROTOCOL_RX_FIFO_SIZE;
;;;348    
;;;349                // ■■接下来，需要检查命令帧是否完整，如果完整，则将命令帧临时缓冲区扶正■■
;;;350    
;;;351                // 首先判断命令帧最小长度，一个完整的命令字至少包括8个字节: 命令头、设备地址、命令字、数据长度、校验和L、校验和H、结束标识0xD、结束标识OxA，因此不足8个字节的必定不完整
;;;352                if (pCmdFrame->length < UART_PROTOCOL3_CMD_FRAME_LENGTH_MIN)
;;;353                {
;;;354                    // 继续接收
;;;355                    continue;
;;;356                }
;;;357    
;;;358                // 命令帧长度数值越界，说明当前命令帧错误，停止接收
;;;359                if (pCmdFrame->buff[UART_PROTOCOL3_CMD_LENGTH_INDEX] > UART_PROTOCOL3_RX_CMD_FRAME_LENGTH_MAX - UART_PROTOCOL3_CMD_FRAME_LENGTH_MIN)
;;;360                {
;;;361    #if UART_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;362                    // 停止RX通讯超时检测
;;;363                    UART_PROTOCOL_StopRxTimeOutCheck();
;;;364    #endif
;;;365    
;;;366                    // 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;367                    pCmdFrame->length = 0;
;;;368                    // 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;369                    pCB->rxFIFO.head++;
;;;370                    pCB->rxFIFO.head %= UART_PROTOCOL3_RX_FIFO_SIZE;
;;;371                    pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;372    
;;;373                    return;
;;;374                }
;;;375    
;;;376                // 命令帧长度校验，在命令长度描述字的数值上，增加命令头、设备地址、命令字、数据长度、校验和L、校验和H、结束标识0xD、结束标识OxA，即为命令帧实际长度
;;;377                length = pCmdFrame->length;
;;;378                if (length < pCmdFrame->buff[UART_PROTOCOL3_CMD_LENGTH_INDEX] + UART_PROTOCOL3_CMD_FRAME_LENGTH_MIN)
;;;379                {
;;;380                    // 长度要求不一致，说明未接收完毕，退出继续
;;;381                    continue;
;;;382                }
;;;383    
;;;384                // 命令帧长度OK，则进行校验，失败时删除命令头
;;;385                if (!UART_PROTOCOL3_CheckSUM(pCmdFrame))
;;;386                {
;;;387    #if UART_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;388                    // 停止RX通讯超时检测
;;;389                    UART_PROTOCOL_StopRxTimeOutCheck();
;;;390    #endif
;;;391    
;;;392                    // 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;393                    pCmdFrame->length = 0;
;;;394                    // 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;395                    pCB->rxFIFO.head++;
;;;396                    pCB->rxFIFO.head %= UART_PROTOCOL3_RX_FIFO_SIZE;
;;;397                    pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;398    
;;;399                    return;
;;;400                }
;;;401    
;;;402    #if UART_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;403                // 停止RX通讯超时检测
;;;404                UART_PROTOCOL_StopRxTimeOutCheck();
;;;405    #endif
;;;406    
;;;407                // 执行到这里，即说明接收到了一个完整并且正确的命令帧，此时需将处理过的数据从一级缓冲区中删除，并将该命令帧扶正
;;;408                pCB->rxFIFO.head += length;
;;;409                pCB->rxFIFO.head %= UART_PROTOCOL_RX_FIFO_SIZE;
;;;410                pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;411                UART_PROTOCOL3_ConfirmTempCmdFrameBuff(pCB);
;;;412    
;;;413                return;
;;;414            }
;;;415        }
;;;416    }
000016  e8bd83f0          POP      {r4-r9,pc}
                  |L8.26|
00001a  45b9              CMP      r9,r7                 ;274
00001c  d100              BNE      |L8.32|
00001e  e7fa              B        |L8.22|
                  |L8.32|
000020  f8b402a0          LDRH     r0,[r4,#0x2a0]        ;280
000024  214d              MOVS     r1,#0x4d              ;280
000026  4348              MULS     r0,r1,r0              ;280
000028  f10401d0          ADD      r1,r4,#0xd0           ;280
00002c  eb010540          ADD      r5,r1,r0,LSL #1       ;280
000030  f8b400cc          LDRH     r0,[r4,#0xcc]         ;282
000034  5c26              LDRB     r6,[r4,r0]            ;282
000036  f8b50098          LDRH     r0,[r5,#0x98]         ;285
00003a  bb90              CBNZ     r0,|L8.162|
00003c  2e3a              CMP      r6,#0x3a              ;288
00003e  d00e              BEQ      |L8.94|
000040  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;290
000044  1c40              ADDS     r0,r0,#1              ;290
000046  8020              STRH     r0,[r4,#0]            ;290
000048  8820              LDRH     r0,[r4,#0]            ;291
00004a  21c8              MOVS     r1,#0xc8              ;291
00004c  fb90f2f1          SDIV     r2,r0,r1              ;291
000050  fb010012          MLS      r0,r1,r2,r0           ;291
000054  8020              STRH     r0,[r4,#0]            ;291
000056  8820              LDRH     r0,[r4,#0]            ;292
000058  80a0              STRH     r0,[r4,#4]            ;292
00005a  3cc8              SUBS     r4,r4,#0xc8           ;292
00005c  e7db              B        |L8.22|
                  |L8.94|
00005e  f8b402a0          LDRH     r0,[r4,#0x2a0]        ;298
000062  1c40              ADDS     r0,r0,#1              ;298
000064  2103              MOVS     r1,#3                 ;298
000066  fb90f2f1          SDIV     r2,r0,r1              ;298
00006a  fb010112          MLS      r1,r1,r2,r0           ;298
00006e  f8b4029e          LDRH     r0,[r4,#0x29e]        ;298
000072  4281              CMP      r1,r0                 ;298
000074  d100              BNE      |L8.120|
000076  e7ce              B        |L8.22|
                  |L8.120|
000078  f8351f98          LDRH     r1,[r5,#0x98]!        ;314
00007c  8828              LDRH     r0,[r5,#0]            ;314
00007e  1c40              ADDS     r0,r0,#1              ;314
000080  f8250998          STRH     r0,[r5],#-0x98        ;314
000084  1ca8              ADDS     r0,r5,#2              ;314
000086  5446              STRB     r6,[r0,r1]            ;314
000088  f8340fcc          LDRH     r0,[r4,#0xcc]!        ;315
00008c  1c40              ADDS     r0,r0,#1              ;315
00008e  8020              STRH     r0,[r4,#0]            ;315
000090  8820              LDRH     r0,[r4,#0]            ;316
000092  21c8              MOVS     r1,#0xc8              ;316
000094  fb90f2f1          SDIV     r2,r0,r1              ;316
000098  fb010012          MLS      r0,r1,r2,r0           ;316
00009c  f82409cc          STRH     r0,[r4],#-0xcc        ;316
0000a0  e07b              B        |L8.410|
                  |L8.162|
0000a2  e7ff              B        |L8.164|
                  |L8.164|
0000a4  f8b50098          LDRH     r0,[r5,#0x98]         ;322
0000a8  2896              CMP      r0,#0x96              ;322
0000aa  db11              BLT      |L8.208|
0000ac  2000              MOVS     r0,#0                 ;330
0000ae  f8a50098          STRH     r0,[r5,#0x98]         ;330
0000b2  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;332
0000b6  1c40              ADDS     r0,r0,#1              ;332
0000b8  8020              STRH     r0,[r4,#0]            ;332
0000ba  8820              LDRH     r0,[r4,#0]            ;333
0000bc  21c8              MOVS     r1,#0xc8              ;333
0000be  fb90f2f1          SDIV     r2,r0,r1              ;333
0000c2  fb010012          MLS      r0,r1,r2,r0           ;333
0000c6  8020              STRH     r0,[r4,#0]            ;333
0000c8  8820              LDRH     r0,[r4,#0]            ;334
0000ca  80a0              STRH     r0,[r4,#4]            ;334
0000cc  3cc8              SUBS     r4,r4,#0xc8           ;334
0000ce  e7a2              B        |L8.22|
                  |L8.208|
0000d0  e05f              B        |L8.402|
                  |L8.210|
0000d2  f8b400cc          LDRH     r0,[r4,#0xcc]         ;343
0000d6  5c26              LDRB     r6,[r4,r0]            ;343
0000d8  f8351f98          LDRH     r1,[r5,#0x98]!        ;345
0000dc  8828              LDRH     r0,[r5,#0]            ;345
0000de  1c40              ADDS     r0,r0,#1              ;345
0000e0  f8250998          STRH     r0,[r5],#-0x98        ;345
0000e4  1ca8              ADDS     r0,r5,#2              ;345
0000e6  5446              STRB     r6,[r0,r1]            ;345
0000e8  f8340fcc          LDRH     r0,[r4,#0xcc]!        ;346
0000ec  1c40              ADDS     r0,r0,#1              ;346
0000ee  8020              STRH     r0,[r4,#0]            ;346
0000f0  8820              LDRH     r0,[r4,#0]            ;347
0000f2  21c8              MOVS     r1,#0xc8              ;347
0000f4  fb90f2f1          SDIV     r2,r0,r1              ;347
0000f8  fb010012          MLS      r0,r1,r2,r0           ;347
0000fc  f82409cc          STRH     r0,[r4],#-0xcc        ;347
000100  f8b50098          LDRH     r0,[r5,#0x98]         ;352
000104  2808              CMP      r0,#8                 ;352
000106  da00              BGE      |L8.266|
000108  e043              B        |L8.402|
                  |L8.266|
00010a  7968              LDRB     r0,[r5,#5]            ;359
00010c  288e              CMP      r0,#0x8e              ;359
00010e  dd11              BLE      |L8.308|
000110  2000              MOVS     r0,#0                 ;367
000112  f8a50098          STRH     r0,[r5,#0x98]         ;367
000116  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;369
00011a  1c40              ADDS     r0,r0,#1              ;369
00011c  8020              STRH     r0,[r4,#0]            ;369
00011e  8820              LDRH     r0,[r4,#0]            ;370
000120  21c8              MOVS     r1,#0xc8              ;370
000122  fb90f2f1          SDIV     r2,r0,r1              ;370
000126  fb010012          MLS      r0,r1,r2,r0           ;370
00012a  8020              STRH     r0,[r4,#0]            ;370
00012c  8820              LDRH     r0,[r4,#0]            ;371
00012e  80a0              STRH     r0,[r4,#4]            ;371
000130  3cc8              SUBS     r4,r4,#0xc8           ;371
000132  e770              B        |L8.22|
                  |L8.308|
000134  f8b58098          LDRH     r8,[r5,#0x98]         ;377
000138  7968              LDRB     r0,[r5,#5]            ;378
00013a  3008              ADDS     r0,r0,#8              ;378
00013c  4540              CMP      r0,r8                 ;378
00013e  dd00              BLE      |L8.322|
000140  e027              B        |L8.402|
                  |L8.322|
000142  4628              MOV      r0,r5                 ;385
000144  f7fffffe          BL       UART_PROTOCOL3_CheckSUM
000148  b988              CBNZ     r0,|L8.366|
00014a  2000              MOVS     r0,#0                 ;393
00014c  f8a50098          STRH     r0,[r5,#0x98]         ;393
000150  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;395
000154  1c40              ADDS     r0,r0,#1              ;395
000156  8020              STRH     r0,[r4,#0]            ;395
000158  8820              LDRH     r0,[r4,#0]            ;396
00015a  21c8              MOVS     r1,#0xc8              ;396
00015c  fb90f2f1          SDIV     r2,r0,r1              ;396
000160  fb010012          MLS      r0,r1,r2,r0           ;396
000164  8020              STRH     r0,[r4,#0]            ;396
000166  8820              LDRH     r0,[r4,#0]            ;397
000168  80a0              STRH     r0,[r4,#4]            ;397
00016a  3cc8              SUBS     r4,r4,#0xc8           ;397
00016c  e753              B        |L8.22|
                  |L8.366|
00016e  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;408
000172  4440              ADD      r0,r0,r8              ;408
000174  8020              STRH     r0,[r4,#0]            ;408
000176  8820              LDRH     r0,[r4,#0]            ;409
000178  21c8              MOVS     r1,#0xc8              ;409
00017a  fb90f2f1          SDIV     r2,r0,r1              ;409
00017e  fb010012          MLS      r0,r1,r2,r0           ;409
000182  8020              STRH     r0,[r4,#0]            ;409
000184  8820              LDRH     r0,[r4,#0]            ;410
000186  80a0              STRH     r0,[r4,#4]            ;410
000188  3cc8              SUBS     r4,r4,#0xc8           ;410
00018a  4620              MOV      r0,r4                 ;411
00018c  f7fffffe          BL       UART_PROTOCOL3_ConfirmTempCmdFrameBuff
000190  e741              B        |L8.22|
                  |L8.402|
000192  f8b400cc          LDRH     r0,[r4,#0xcc]         ;340
000196  42b8              CMP      r0,r7                 ;340
000198  d19b              BNE      |L8.210|
                  |L8.410|
00019a  bf00              NOP      
00019c  e73b              B        |L8.22|
;;;417    
                          ENDP


                          AREA ||i.UART_PROTOCOL3_SendCmdNoResult||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL3_SendCmdNoResult PROC
;;;765    // 发送命令无结果
;;;766    void UART_PROTOCOL3_SendCmdNoResult(uint8 cmdWord)
000000  b510              PUSH     {r4,lr}
;;;767    {
000002  4604              MOV      r4,r0
;;;768    	// 添加命令头
;;;769    	UART_PROTOCOL3_TxAddData(UART_PROTOCOL3_CMD_HEAD);
000004  203a              MOVS     r0,#0x3a
000006  f7fffffe          BL       UART_PROTOCOL3_TxAddData
;;;770        
;;;771        if(DUT_TYPE_IOT == dut_info.ID)
00000a  480a              LDR      r0,|L9.52|
00000c  7d80              LDRB     r0,[r0,#0x16]  ; dut_info
00000e  2809              CMP      r0,#9
000010  d103              BNE      |L9.26|
;;;772        {
;;;773            // 添加设备地址
;;;774            UART_PROTOCOL3_TxAddData(UART_PROTOCOL3_IOT_DEVICE_ADDR);    
000012  202a              MOVS     r0,#0x2a
000014  f7fffffe          BL       UART_PROTOCOL3_TxAddData
000018  e002              B        |L9.32|
                  |L9.26|
;;;775        }
;;;776        else
;;;777        {
;;;778            // 添加设备地址
;;;779            UART_PROTOCOL3_TxAddData(UART_PROTOCOL_CMD_DEVICE_ADDR);    
00001a  201a              MOVS     r0,#0x1a
00001c  f7fffffe          BL       UART_PROTOCOL3_TxAddData
                  |L9.32|
;;;780        }
;;;781    
;;;782    	// 添加命令字
;;;783    	UART_PROTOCOL3_TxAddData(cmdWord);
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       UART_PROTOCOL3_TxAddData
;;;784    
;;;785    	UART_PROTOCOL3_TxAddData(0); // 数据长度
000026  2000              MOVS     r0,#0
000028  f7fffffe          BL       UART_PROTOCOL3_TxAddData
;;;786    
;;;787    	UART_PROTOCOL3_TxAddFrame();
00002c  f7fffffe          BL       UART_PROTOCOL3_TxAddFrame
;;;788    }
000030  bd10              POP      {r4,pc}
;;;789    
                          ENDP

000032  0000              DCW      0x0000
                  |L9.52|
                          DCD      dut_info

                          AREA ||i.UART_PROTOCOL3_SendCmdUpApp||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL3_SendCmdUpApp PROC
;;;790    // 发送升级固件命令
;;;791    void UART_PROTOCOL3_SendCmdUpApp(void)
000000  b500              PUSH     {lr}
;;;792    {
;;;793    	// 添加命令头
;;;794    	UART_PROTOCOL3_TxAddData(UART_PROTOCOL3_CMD_HEAD);
000002  203a              MOVS     r0,#0x3a
000004  f7fffffe          BL       UART_PROTOCOL3_TxAddData
;;;795        
;;;796        // 添加设备地址
;;;797        UART_PROTOCOL3_TxAddData(UART_PROTOCOL3_IOT_DEVICE_ADDR);    
000008  202a              MOVS     r0,#0x2a
00000a  f7fffffe          BL       UART_PROTOCOL3_TxAddData
;;;798    
;;;799    	// 添加命令字
;;;800    	UART_PROTOCOL3_TxAddData(UART_PROTOCOL3_CMD_UPDATE_START); // F2
00000e  20f2              MOVS     r0,#0xf2
000010  f7fffffe          BL       UART_PROTOCOL3_TxAddData
;;;801    	UART_PROTOCOL3_TxAddData(0); // 数据长度 
000014  2000              MOVS     r0,#0
000016  f7fffffe          BL       UART_PROTOCOL3_TxAddData
;;;802    	UART_PROTOCOL3_TxAddData(9); // 设备类型 IOT-9
00001a  2009              MOVS     r0,#9
00001c  f7fffffe          BL       UART_PROTOCOL3_TxAddData
;;;803    	UART_PROTOCOL3_TxAddData(dut_info.iotCrc8); // CRC8校验码
000020  4911              LDR      r1,|L10.104|
000022  f89100e4          LDRB     r0,[r1,#0xe4]  ; dut_info
000026  f7fffffe          BL       UART_PROTOCOL3_TxAddData
;;;804    	UART_PROTOCOL3_TxAddData(((dut_info.iotAppUpDataLen) & 0xFF000000) >> 24); // 文件长度
00002a  490f              LDR      r1,|L10.104|
00002c  f8d110e8          LDR      r1,[r1,#0xe8]  ; dut_info
000030  0e08              LSRS     r0,r1,#24
000032  f7fffffe          BL       UART_PROTOCOL3_TxAddData
;;;805    	UART_PROTOCOL3_TxAddData(((dut_info.iotAppUpDataLen) & 0xFF000000) >> 16); // 文件长度
000036  490c              LDR      r1,|L10.104|
000038  f89110e8          LDRB     r1,[r1,#0xe8]  ; dut_info
00003c  2100              MOVS     r1,#0
00003e  f3c14007          UBFX     r0,r1,#16,#8
000042  f7fffffe          BL       UART_PROTOCOL3_TxAddData
;;;806    	UART_PROTOCOL3_TxAddData(((dut_info.iotAppUpDataLen) & 0xFF000000) >> 8); // 文件长度
000046  4908              LDR      r1,|L10.104|
000048  f89110e8          LDRB     r1,[r1,#0xe8]  ; dut_info
00004c  2100              MOVS     r1,#0
00004e  f3c12007          UBFX     r0,r1,#8,#8
000052  f7fffffe          BL       UART_PROTOCOL3_TxAddData
;;;807    	UART_PROTOCOL3_TxAddData((dut_info.iotAppUpDataLen) & 0xFF000000); // 文件长度    
000056  4904              LDR      r1,|L10.104|
000058  f89110e8          LDRB     r1,[r1,#0xe8]  ; dut_info
00005c  2000              MOVS     r0,#0
00005e  f7fffffe          BL       UART_PROTOCOL3_TxAddData
;;;808    	UART_PROTOCOL3_TxAddFrame();
000062  f7fffffe          BL       UART_PROTOCOL3_TxAddFrame
;;;809    }
000066  bd00              POP      {pc}
;;;810    
                          ENDP

                  |L10.104|
                          DCD      dut_info

                          AREA ||i.UART_PROTOCOL3_SendCmdWithResult||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL3_SendCmdWithResult PROC
;;;737    // 发送命令带结果
;;;738    void UART_PROTOCOL3_SendCmdWithResult(uint8 cmdWord, uint8 result)
000000  b530              PUSH     {r4,r5,lr}
;;;739    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;740    	// 添加命令头
;;;741    	UART_PROTOCOL3_TxAddData(UART_PROTOCOL3_CMD_HEAD);
000006  203a              MOVS     r0,#0x3a
000008  f7fffffe          BL       UART_PROTOCOL3_TxAddData
;;;742    
;;;743        if(DUT_TYPE_IOT == dut_info.ID)
00000c  480b              LDR      r0,|L11.60|
00000e  7d80              LDRB     r0,[r0,#0x16]  ; dut_info
000010  2809              CMP      r0,#9
000012  d103              BNE      |L11.28|
;;;744        {
;;;745            // 添加设备地址
;;;746            UART_PROTOCOL3_TxAddData(UART_PROTOCOL3_IOT_DEVICE_ADDR);    
000014  202a              MOVS     r0,#0x2a
000016  f7fffffe          BL       UART_PROTOCOL3_TxAddData
00001a  e002              B        |L11.34|
                  |L11.28|
;;;747        }
;;;748        else
;;;749        {
;;;750            // 添加设备地址
;;;751            UART_PROTOCOL3_TxAddData(UART_PROTOCOL_CMD_DEVICE_ADDR);    
00001c  201a              MOVS     r0,#0x1a
00001e  f7fffffe          BL       UART_PROTOCOL3_TxAddData
                  |L11.34|
;;;752        }
;;;753    
;;;754    	// 添加命令字
;;;755    	UART_PROTOCOL3_TxAddData(cmdWord);
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       UART_PROTOCOL3_TxAddData
;;;756    
;;;757    	// 添加数据长度
;;;758    	UART_PROTOCOL3_TxAddData(1);
000028  2001              MOVS     r0,#1
00002a  f7fffffe          BL       UART_PROTOCOL3_TxAddData
;;;759    
;;;760    	UART_PROTOCOL3_TxAddData(result);
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       UART_PROTOCOL3_TxAddData
;;;761    
;;;762    	UART_PROTOCOL3_TxAddFrame();
000034  f7fffffe          BL       UART_PROTOCOL3_TxAddFrame
;;;763    }
000038  bd30              POP      {r4,r5,pc}
;;;764    
                          ENDP

00003a  0000              DCW      0x0000
                  |L11.60|
                          DCD      dut_info

                          AREA ||i.UART_PROTOCOL3_SendOnePacket_Bin||, CODE, READONLY, ALIGN=1

                  UART_PROTOCOL3_SendOnePacket_Bin PROC
;;;811    // 写入IOT APP数据
;;;812    void UART_PROTOCOL3_SendOnePacket_Bin(uint32 flashAddr, uint32 addr)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;813    {
000004  b0a6              SUB      sp,sp,#0x98
000006  4606              MOV      r6,r0
000008  460c              MOV      r4,r1
;;;814    	uint8 addr1, addr2, addr3, addr4;
;;;815    	uint8 appUpdateOnePacket[150] = {0};
00000a  2198              MOVS     r1,#0x98
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       __aeabi_memclr4
;;;816    	uint8 appUpdateOnePacket_i = 0;
000012  2500              MOVS     r5,#0
;;;817    	addr1 = (addr & 0xFF000000) >> 24;
000014  0e27              LSRS     r7,r4,#24
;;;818    	addr2 = (addr & 0x00FF0000) >> 16;
000016  f3c44807          UBFX     r8,r4,#16,#8
;;;819    	addr3 = (addr & 0x0000FF00) >> 8;
00001a  f3c42907          UBFX     r9,r4,#8,#8
;;;820    	addr4 = (addr & 0x000000FF);
00001e  f0040aff          AND      r10,r4,#0xff
;;;821    	SPI_FLASH_ReadArray(appUpdateOnePacket, flashAddr + addr, 128); // 工具读取128字节
000022  1931              ADDS     r1,r6,r4
000024  2280              MOVS     r2,#0x80
000026  4668              MOV      r0,sp
000028  f7fffffe          BL       SPI_FLASH_ReadArray
;;;822    
;;;823    	UART_PROTOCOL3_TxAddData(UART_PROTOCOL3_CMD_HEAD);                                     // 头
00002c  203a              MOVS     r0,#0x3a
00002e  f7fffffe          BL       UART_PROTOCOL3_TxAddData
;;;824    	UART_PROTOCOL3_TxAddData(UART_PROTOCOL3_IOT_DEVICE_ADDR);                              // 设备号
000032  202a              MOVS     r0,#0x2a
000034  f7fffffe          BL       UART_PROTOCOL3_TxAddData
;;;825        UART_PROTOCOL3_TxAddData(UART_PROTOCOL3_CMD_WRITE_DATA);                               // 命令字
000038  20f3              MOVS     r0,#0xf3
00003a  f7fffffe          BL       UART_PROTOCOL3_TxAddData
;;;826    	UART_PROTOCOL3_TxAddData(0x00);													       // 长度暂时为0
00003e  2000              MOVS     r0,#0
000040  f7fffffe          BL       UART_PROTOCOL3_TxAddData
;;;827    	UART_PROTOCOL3_TxAddData(addr1);													   // 添加地址
000044  4638              MOV      r0,r7
000046  f7fffffe          BL       UART_PROTOCOL3_TxAddData
;;;828    	UART_PROTOCOL3_TxAddData(addr2);													   // 添加地址
00004a  4640              MOV      r0,r8
00004c  f7fffffe          BL       UART_PROTOCOL3_TxAddData
;;;829    	UART_PROTOCOL3_TxAddData(addr3);													   // 添加地址
000050  4648              MOV      r0,r9
000052  f7fffffe          BL       UART_PROTOCOL3_TxAddData
;;;830    	UART_PROTOCOL3_TxAddData(addr4);													   // 添加地址
000056  4650              MOV      r0,r10
000058  f7fffffe          BL       UART_PROTOCOL3_TxAddData
;;;831    	UART_PROTOCOL3_TxAddData(128);													       // 数据包长度
00005c  2080              MOVS     r0,#0x80
00005e  f7fffffe          BL       UART_PROTOCOL3_TxAddData
;;;832        
;;;833    	for (appUpdateOnePacket_i = 0; appUpdateOnePacket_i < 128; appUpdateOnePacket_i++) // 添加数据
000062  bf00              NOP      
000064  e005              B        |L12.114|
                  |L12.102|
;;;834    	{
;;;835    		UART_PROTOCOL3_TxAddData(appUpdateOnePacket[appUpdateOnePacket_i]);
000066  f81d0005          LDRB     r0,[sp,r5]
00006a  f7fffffe          BL       UART_PROTOCOL3_TxAddData
00006e  1c68              ADDS     r0,r5,#1              ;833
000070  b2c5              UXTB     r5,r0                 ;833
                  |L12.114|
000072  2d80              CMP      r5,#0x80              ;833
000074  dbf7              BLT      |L12.102|
;;;836    	}
;;;837    	UART_PROTOCOL3_TxAddFrame(); // 调整帧格式,修改长度和添加校验
000076  f7fffffe          BL       UART_PROTOCOL3_TxAddFrame
;;;838    }
00007a  b026              ADD      sp,sp,#0x98
00007c  e8bd87f0          POP      {r4-r10,pc}
                          ENDP


                          AREA ||i.UART_PROTOCOL3_SendUpAppReuqest||, CODE, READONLY, ALIGN=1

                  UART_PROTOCOL3_SendUpAppReuqest PROC
;;;731    // 发送升级固件请求
;;;732    void UART_PROTOCOL3_SendUpAppReuqest(uint32 param)
000000  b510              PUSH     {r4,lr}
;;;733    {
000002  4604              MOV      r4,r0
;;;734        UART_PROTOCOL3_SendCmdWithResult(UART_PROTOCOL3_CMD_UPDATE_REQUEST, 9); 
000004  2109              MOVS     r1,#9
000006  20f1              MOVS     r0,#0xf1
000008  f7fffffe          BL       UART_PROTOCOL3_SendCmdWithResult
;;;735    }
00000c  bd10              POP      {r4,pc}
;;;736    
                          ENDP


                          AREA ||i.UART_PROTOCOL3_TxAddData||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL3_TxAddData PROC
;;;61     // 向发送命令帧队列中添加数据
;;;62     void UART_PROTOCOL3_TxAddData(uint8 data)
000000  b570              PUSH     {r4-r6,lr}
;;;63     {
000002  4601              MOV      r1,r0
;;;64         uint16 head = uartProtocolCB3.tx.head;
000004  4c13              LDR      r4,|L14.84|
000006  f8b423da          LDRH     r2,[r4,#0x3da]
;;;65         uint16 end = uartProtocolCB3.tx.end;
00000a  f8b433dc          LDRH     r3,[r4,#0x3dc]
;;;66         UART_PROTOCOL3_TX_CMD_FRAME *pCmdFrame = &uartProtocolCB3.tx.cmdQueue[uartProtocolCB3.tx.end];
00000e  f8b443dc          LDRH     r4,[r4,#0x3dc]
000012  eb040584          ADD      r5,r4,r4,LSL #2
000016  eb0505c4          ADD      r5,r5,r4,LSL #3
00001a  4c0f              LDR      r4,|L14.88|
00001c  eb0400c5          ADD      r0,r4,r5,LSL #3
;;;67     
;;;68         // 发送缓冲区已满，不予接收
;;;69         if ((end + 1) % UART_PROTOCOL3_TX_QUEUE_SIZE == head)
000020  1c5c              ADDS     r4,r3,#1
000022  2503              MOVS     r5,#3
000024  fb94f6f5          SDIV     r6,r4,r5
000028  fb054416          MLS      r4,r5,r6,r4
00002c  4294              CMP      r4,r2
00002e  d100              BNE      |L14.50|
                  |L14.48|
;;;70         {
;;;71             return;
;;;72         }
;;;73     
;;;74         // 队尾命令帧已满，退出
;;;75         if (pCmdFrame->length >= UART_PROTOCOL3_TX_CMD_FRAME_LENGTH_MAX)
;;;76         {
;;;77             return;
;;;78         }
;;;79     
;;;80         // 数据添加到帧末尾，并更新帧长度
;;;81         pCmdFrame->buff[pCmdFrame->length] = data;
;;;82         pCmdFrame->length++;
;;;83     }
000030  bd70              POP      {r4-r6,pc}
                  |L14.50|
000032  f8b04066          LDRH     r4,[r0,#0x66]         ;75
000036  2c64              CMP      r4,#0x64              ;75
000038  db00              BLT      |L14.60|
00003a  e7f9              B        |L14.48|
                  |L14.60|
00003c  f8b05066          LDRH     r5,[r0,#0x66]         ;81
000040  1c84              ADDS     r4,r0,#2              ;81
000042  5561              STRB     r1,[r4,r5]            ;81
000044  f8b04066          LDRH     r4,[r0,#0x66]         ;82
000048  1c64              ADDS     r4,r4,#1              ;82
00004a  f8a04066          STRH     r4,[r0,#0x66]         ;82
00004e  bf00              NOP      
000050  e7ee              B        |L14.48|
;;;84     
                          ENDP

000052  0000              DCW      0x0000
                  |L14.84|
                          DCD      uartProtocolCB3
                  |L14.88|
                          DCD      uartProtocolCB3+0x2a2

                          AREA ||i.UART_PROTOCOL3_TxAddFrame||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL3_TxAddFrame PROC
;;;85     // 确认添加命令帧，即承认之前填充的数据为命令帧，将其添加到发送队列中，由main进行调度发送，本函数内会自动校正命令长度，并添加校验码
;;;86     void UART_PROTOCOL3_TxAddFrame(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;87     {
;;;88         uint16 checkSum = 0;
000002  2200              MOVS     r2,#0
;;;89         uint16 i = 0;
000004  2300              MOVS     r3,#0
;;;90         uint16 head = uartProtocolCB3.tx.head;
000006  4e39              LDR      r6,|L15.236|
000008  f8b643da          LDRH     r4,[r6,#0x3da]
;;;91         uint16 end = uartProtocolCB3.tx.end;
00000c  f8b653dc          LDRH     r5,[r6,#0x3dc]
;;;92         UART_PROTOCOL3_TX_CMD_FRAME *pCmdFrame = &uartProtocolCB3.tx.cmdQueue[uartProtocolCB3.tx.end];
000010  f8b663dc          LDRH     r6,[r6,#0x3dc]
000014  eb060786          ADD      r7,r6,r6,LSL #2
000018  eb0707c6          ADD      r7,r7,r6,LSL #3
00001c  4e34              LDR      r6,|L15.240|
00001e  eb0600c7          ADD      r0,r6,r7,LSL #3
;;;93         uint16 length = pCmdFrame->length;
000022  f8b01066          LDRH     r1,[r0,#0x66]
;;;94     
;;;95         // 发送缓冲区已满，不予接收
;;;96         if ((end + 1) % UART_PROTOCOL3_TX_QUEUE_SIZE == head)
000026  1c6e              ADDS     r6,r5,#1
000028  2703              MOVS     r7,#3
00002a  fb96fcf7          SDIV     r12,r6,r7
00002e  fb07661c          MLS      r6,r7,r12,r6
000032  42a6              CMP      r6,r4
000034  d100              BNE      |L15.56|
                  |L15.54|
;;;97         {
;;;98             return;
;;;99         }
;;;100    
;;;101        // 命令帧长度不足，清除已填充的数据，退出
;;;102        if (UART_PROTOCOL3_CMD_FRAME_LENGTH_MIN - 4 > length) // 减去"校验和L、校验和H、结束标识0xD、结束标识OxA"4个字节
;;;103        {
;;;104            pCmdFrame->length = 0;
;;;105    
;;;106            return;
;;;107        }
;;;108    
;;;109        // 队尾命令帧已满，退出
;;;110        if ((length >= UART_PROTOCOL3_TX_CMD_FRAME_LENGTH_MAX) || (length + 1 >= UART_PROTOCOL3_TX_CMD_FRAME_LENGTH_MAX) || (length + 2 >= UART_PROTOCOL3_TX_CMD_FRAME_LENGTH_MAX) || (length + 3 >= UART_PROTOCOL3_TX_CMD_FRAME_LENGTH_MAX))
;;;111        {
;;;112            return;
;;;113        }
;;;114    
;;;115        // 重新设置数据长度，系统在准备数据时，填充的"数据长度"可以为任意值，并且不需要添加校验码，在这里重新设置为正确的值
;;;116        pCmdFrame->buff[UART_PROTOCOL3_CMD_LENGTH_INDEX] = length - 4; // 重设数据长度，减去"命令头、设备地址、命令字、数据长度"4个字节
;;;117        for (i = 1; i < length; i++)
;;;118        {
;;;119            checkSum += pCmdFrame->buff[i];
;;;120        }
;;;121        pCmdFrame->buff[pCmdFrame->length++] = (checkSum & 0x00FF);        // 低字节在前
;;;122        pCmdFrame->buff[pCmdFrame->length++] = ((checkSum >> 8) & 0x00FF); // 高字节在后
;;;123    
;;;124        // 结束标识
;;;125        pCmdFrame->buff[pCmdFrame->length++] = 0x0D;
;;;126        pCmdFrame->buff[pCmdFrame->length++] = 0x0A;
;;;127    
;;;128        uartProtocolCB3.tx.end++;
;;;129        uartProtocolCB3.tx.end %= UART_PROTOCOL3_TX_QUEUE_SIZE;
;;;130    }
000036  bdf0              POP      {r4-r7,pc}
                  |L15.56|
000038  2904              CMP      r1,#4                 ;102
00003a  da03              BGE      |L15.68|
00003c  2600              MOVS     r6,#0                 ;104
00003e  f8a06066          STRH     r6,[r0,#0x66]         ;104
000042  e7f8              B        |L15.54|
                  |L15.68|
000044  2964              CMP      r1,#0x64              ;110
000046  da08              BGE      |L15.90|
000048  1c4e              ADDS     r6,r1,#1              ;110
00004a  2e64              CMP      r6,#0x64              ;110
00004c  da05              BGE      |L15.90|
00004e  1c8e              ADDS     r6,r1,#2              ;110
000050  2e64              CMP      r6,#0x64              ;110
000052  da02              BGE      |L15.90|
000054  1cce              ADDS     r6,r1,#3              ;110
000056  2e64              CMP      r6,#0x64              ;110
000058  db00              BLT      |L15.92|
                  |L15.90|
00005a  e7ec              B        |L15.54|
                  |L15.92|
00005c  1f0e              SUBS     r6,r1,#4              ;116
00005e  7146              STRB     r6,[r0,#5]            ;116
000060  2301              MOVS     r3,#1                 ;117
000062  e005              B        |L15.112|
                  |L15.100|
000064  1c86              ADDS     r6,r0,#2              ;119
000066  5cf6              LDRB     r6,[r6,r3]            ;119
000068  4416              ADD      r6,r6,r2              ;119
00006a  b2b2              UXTH     r2,r6                 ;119
00006c  1c5e              ADDS     r6,r3,#1              ;117
00006e  b2b3              UXTH     r3,r6                 ;117
                  |L15.112|
000070  428b              CMP      r3,r1                 ;117
000072  dbf7              BLT      |L15.100|
000074  f8b0c066          LDRH     r12,[r0,#0x66]        ;121
000078  f10c0601          ADD      r6,r12,#1             ;121
00007c  f8a06066          STRH     r6,[r0,#0x66]         ;121
000080  1c86              ADDS     r6,r0,#2              ;121
000082  f806200c          STRB     r2,[r6,r12]           ;121
000086  0a17              LSRS     r7,r2,#8              ;122
000088  f8b0c066          LDRH     r12,[r0,#0x66]        ;122
00008c  f10c0601          ADD      r6,r12,#1             ;122
000090  f8a06066          STRH     r6,[r0,#0x66]         ;122
000094  1c86              ADDS     r6,r0,#2              ;122
000096  f806700c          STRB     r7,[r6,r12]           ;122
00009a  270d              MOVS     r7,#0xd               ;125
00009c  f8b0c066          LDRH     r12,[r0,#0x66]        ;125
0000a0  f10c0601          ADD      r6,r12,#1             ;125
0000a4  f8a06066          STRH     r6,[r0,#0x66]         ;125
0000a8  1c86              ADDS     r6,r0,#2              ;125
0000aa  f806700c          STRB     r7,[r6,r12]           ;125
0000ae  270a              MOVS     r7,#0xa               ;126
0000b0  f8b0c066          LDRH     r12,[r0,#0x66]        ;126
0000b4  f10c0601          ADD      r6,r12,#1             ;126
0000b8  f8a06066          STRH     r6,[r0,#0x66]         ;126
0000bc  1c86              ADDS     r6,r0,#2              ;126
0000be  f806700c          STRB     r7,[r6,r12]           ;126
0000c2  4e0a              LDR      r6,|L15.236|
0000c4  f8b663dc          LDRH     r6,[r6,#0x3dc]        ;128
0000c8  1c76              ADDS     r6,r6,#1              ;128
0000ca  b2b7              UXTH     r7,r6                 ;128
0000cc  4e07              LDR      r6,|L15.236|
0000ce  f8a673dc          STRH     r7,[r6,#0x3dc]        ;128
0000d2  f8b663dc          LDRH     r6,[r6,#0x3dc]        ;129
0000d6  2703              MOVS     r7,#3                 ;129
0000d8  fb96fcf7          SDIV     r12,r6,r7             ;129
0000dc  fb07661c          MLS      r6,r7,r12,r6          ;129
0000e0  b2b7              UXTH     r7,r6                 ;129
0000e2  4e02              LDR      r6,|L15.236|
0000e4  f8a673dc          STRH     r7,[r6,#0x3dc]        ;129
0000e8  bf00              NOP      
0000ea  e7a4              B        |L15.54|
;;;131    
                          ENDP

                  |L15.236|
                          DCD      uartProtocolCB3
                  |L15.240|
                          DCD      uartProtocolCB3+0x2a2

                          AREA ||i.UART_PROTOCOL3_TxStateProcess||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL3_TxStateProcess PROC
;;;225    // 协议层发送处理过程
;;;226    void UART_PROTOCOL3_TxStateProcess(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;227    {
;;;228        uint16 head = uartProtocolCB3.tx.head;
000004  4826              LDR      r0,|L16.160|
000006  f8b043da          LDRH     r4,[r0,#0x3da]
;;;229        uint16 end = uartProtocolCB3.tx.end;
00000a  f8b053dc          LDRH     r5,[r0,#0x3dc]
;;;230        uint16 length = uartProtocolCB3.tx.cmdQueue[head].length;
00000e  eb040084          ADD      r0,r4,r4,LSL #2
000012  eb0001c4          ADD      r1,r0,r4,LSL #3
000016  4823              LDR      r0,|L16.164|
000018  eb0000c1          ADD      r0,r0,r1,LSL #3
00001c  f8b06066          LDRH     r6,[r0,#0x66]
;;;231        uint8 *pCmd = uartProtocolCB3.tx.cmdQueue[head].buff;
000020  eb040084          ADD      r0,r4,r4,LSL #2
000024  eb0001c4          ADD      r1,r0,r4,LSL #3
000028  481e              LDR      r0,|L16.164|
00002a  eb0000c1          ADD      r0,r0,r1,LSL #3
00002e  1c87              ADDS     r7,r0,#2
;;;232        uint16 localDeviceID = uartProtocolCB3.tx.cmdQueue[head].deviceID;
000030  eb040084          ADD      r0,r4,r4,LSL #2
000034  eb0001c4          ADD      r1,r0,r4,LSL #3
000038  481a              LDR      r0,|L16.164|
00003a  f8308031          LDRH     r8,[r0,r1,LSL #3]
;;;233    
;;;234        // 发送缓冲区为空，说明无数据
;;;235        if (head == end)
00003e  42ac              CMP      r4,r5
000040  d101              BNE      |L16.70|
                  |L16.66|
;;;236        {
;;;237            return;
;;;238        }
;;;239    
;;;240        // 发送函数没有注册直接返回
;;;241        if (NULL == uartProtocolCB3.sendDataThrowService)
;;;242        {
;;;243            return;
;;;244        }
;;;245    
;;;246        // 协议层有数据需要发送到驱动层
;;;247        if (!(*uartProtocolCB3.sendDataThrowService)(localDeviceID, pCmd, length))
;;;248        {
;;;249            return;
;;;250        }
;;;251    
;;;252        // 发送环形队列更新位置
;;;253        uartProtocolCB3.tx.cmdQueue[head].length = 0;
;;;254        uartProtocolCB3.tx.head++;
;;;255        uartProtocolCB3.tx.head %= UART_PROTOCOL3_TX_QUEUE_SIZE;
;;;256    }
000042  e8bd81f0          POP      {r4-r8,pc}
                  |L16.70|
000046  4816              LDR      r0,|L16.160|
000048  f8d003e4          LDR      r0,[r0,#0x3e4]        ;241  ; uartProtocolCB3
00004c  b900              CBNZ     r0,|L16.80|
00004e  e7f8              B        |L16.66|
                  |L16.80|
000050  4813              LDR      r0,|L16.160|
000052  4632              MOV      r2,r6                 ;247
000054  4639              MOV      r1,r7                 ;247
000056  f8d033e4          LDR      r3,[r0,#0x3e4]        ;247  ; uartProtocolCB3
00005a  4640              MOV      r0,r8                 ;247
00005c  4798              BLX      r3                    ;247
00005e  b900              CBNZ     r0,|L16.98|
000060  e7ef              B        |L16.66|
                  |L16.98|
000062  2100              MOVS     r1,#0                 ;253
000064  eb040084          ADD      r0,r4,r4,LSL #2       ;253
000068  eb0002c4          ADD      r2,r0,r4,LSL #3       ;253
00006c  480d              LDR      r0,|L16.164|
00006e  eb0000c2          ADD      r0,r0,r2,LSL #3       ;253
000072  f8a01066          STRH     r1,[r0,#0x66]         ;253
000076  480a              LDR      r0,|L16.160|
000078  f8b003da          LDRH     r0,[r0,#0x3da]        ;254
00007c  1c40              ADDS     r0,r0,#1              ;254
00007e  b281              UXTH     r1,r0                 ;254
000080  4807              LDR      r0,|L16.160|
000082  f8a013da          STRH     r1,[r0,#0x3da]        ;254
000086  f8b003da          LDRH     r0,[r0,#0x3da]        ;255
00008a  2103              MOVS     r1,#3                 ;255
00008c  fb90f2f1          SDIV     r2,r0,r1              ;255
000090  fb010012          MLS      r0,r1,r2,r0           ;255
000094  b281              UXTH     r1,r0                 ;255
000096  4802              LDR      r0,|L16.160|
000098  f8a013da          STRH     r1,[r0,#0x3da]        ;255
00009c  bf00              NOP      
00009e  e7d0              B        |L16.66|
;;;257    
                          ENDP

                  |L16.160|
                          DCD      uartProtocolCB3
                  |L16.164|
                          DCD      uartProtocolCB3+0x2a2

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  uartProtocolCB3
                          %        1012

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

000000  ff000000          DCB      0xff,0x00,0x00,0x00

;*** Start embedded assembler ***

#line 1 "User\\UartProtocol3.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_UartProtocol3_c_f71f4018____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___15_UartProtocol3_c_f71f4018____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_UartProtocol3_c_f71f4018____REVSH|
#line 128
|__asm___15_UartProtocol3_c_f71f4018____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
