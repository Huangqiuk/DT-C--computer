; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\gd32f10x_fmc.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\gd32f10x_fmc.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -I.\User\qrencode -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.3\Device\Include -D__MICROLIB -D__UVISION_VERSION=539 -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\gd32f10x_fmc.crf Libraries\src\gd32f10x_fmc.c]
                          THUMB

                          AREA ||i.fmc_bank0_erase||, CODE, READONLY, ALIGN=2

                  fmc_bank0_erase PROC
;;;272    */
;;;273    fmc_state_enum fmc_bank0_erase(void)
000000  b510              PUSH     {r4,lr}
;;;274    {
;;;275        fmc_state_enum fmc_state = FMC_READY;
000002  2400              MOVS     r4,#0
;;;276        /* wait for the FMC ready */
;;;277        fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT);
000004  f44f2070          MOV      r0,#0xf0000
000008  f7fffffe          BL       fmc_bank0_ready_wait
00000c  4604              MOV      r4,r0
;;;278    
;;;279        if(FMC_READY == fmc_state){
00000e  b9ac              CBNZ     r4,|L1.60|
;;;280            /* start FMC bank0 erase */
;;;281            FMC_CTL0 |= FMC_CTL0_MER;
000010  480b              LDR      r0,|L1.64|
000012  6900              LDR      r0,[r0,#0x10]
000014  f0400004          ORR      r0,r0,#4
000018  4909              LDR      r1,|L1.64|
00001a  6108              STR      r0,[r1,#0x10]
;;;282            FMC_CTL0 |= FMC_CTL0_START;
00001c  4608              MOV      r0,r1
00001e  6900              LDR      r0,[r0,#0x10]
000020  f0400040          ORR      r0,r0,#0x40
000024  6108              STR      r0,[r1,#0x10]
;;;283            /* wait for the FMC ready */
;;;284            fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT);
000026  f44f2070          MOV      r0,#0xf0000
00002a  f7fffffe          BL       fmc_bank0_ready_wait
00002e  4604              MOV      r4,r0
;;;285            /* reset the MER bit */
;;;286            FMC_CTL0 &= ~FMC_CTL0_MER;
000030  4803              LDR      r0,|L1.64|
000032  6900              LDR      r0,[r0,#0x10]
000034  f0200004          BIC      r0,r0,#4
000038  4901              LDR      r1,|L1.64|
00003a  6108              STR      r0,[r1,#0x10]
                  |L1.60|
;;;287        }
;;;288        /* return the fmc state */
;;;289        return fmc_state;
00003c  4620              MOV      r0,r4
;;;290    }
00003e  bd10              POP      {r4,pc}
;;;291    
                          ENDP

                  |L1.64|
                          DCD      0x40022000

                          AREA ||i.fmc_bank0_lock||, CODE, READONLY, ALIGN=2

                  fmc_bank0_lock PROC
;;;142    */
;;;143    void fmc_bank0_lock(void)
000000  4803              LDR      r0,|L2.16|
;;;144    {
;;;145        /* set the LK bit*/
;;;146        FMC_CTL0 |= FMC_CTL0_LK;
000002  6900              LDR      r0,[r0,#0x10]
000004  f0400080          ORR      r0,r0,#0x80
000008  4901              LDR      r1,|L2.16|
00000a  6108              STR      r0,[r1,#0x10]
;;;147    }
00000c  4770              BX       lr
;;;148    
                          ENDP

00000e  0000              DCW      0x0000
                  |L2.16|
                          DCD      0x40022000

                          AREA ||i.fmc_bank0_ready_wait||, CODE, READONLY, ALIGN=1

                  fmc_bank0_ready_wait PROC
;;;924    */
;;;925    fmc_state_enum fmc_bank0_ready_wait(uint32_t timeout)
000000  b500              PUSH     {lr}
;;;926    {
000002  4603              MOV      r3,r0
;;;927        fmc_state_enum fmc_state = FMC_BUSY;
000004  2201              MOVS     r2,#1
;;;928      
;;;929        /* wait for FMC ready */
;;;930        do{
000006  bf00              NOP      
                  |L3.8|
;;;931            /* get FMC state */
;;;932            fmc_state = fmc_bank0_state_get();
000008  f7fffffe          BL       fmc_bank0_state_get
00000c  4602              MOV      r2,r0
;;;933            timeout--;
00000e  1e5b              SUBS     r3,r3,#1
;;;934        }while((FMC_BUSY == fmc_state) && (0x00U != timeout));
000010  2a01              CMP      r2,#1
000012  d101              BNE      |L3.24|
000014  2b00              CMP      r3,#0
000016  d1f7              BNE      |L3.8|
                  |L3.24|
;;;935        
;;;936        if(FMC_BUSY == fmc_state){
000018  2a01              CMP      r2,#1
00001a  d100              BNE      |L3.30|
;;;937            fmc_state = FMC_TOERR;
00001c  2204              MOVS     r2,#4
                  |L3.30|
;;;938        }
;;;939        /* return the FMC state */
;;;940        return fmc_state;
00001e  4610              MOV      r0,r2
;;;941    }
000020  bd00              POP      {pc}
;;;942    
                          ENDP


                          AREA ||i.fmc_bank0_state_get||, CODE, READONLY, ALIGN=2

                  fmc_bank0_state_get PROC
;;;873    */
;;;874    fmc_state_enum fmc_bank0_state_get(void)
000000  2000              MOVS     r0,#0
;;;875    {
;;;876        fmc_state_enum fmc_state = FMC_READY;
;;;877      
;;;878        if((uint32_t)0x00U != (FMC_STAT0 & FMC_STAT0_BUSY)){
000002  490a              LDR      r1,|L4.44|
000004  68c9              LDR      r1,[r1,#0xc]
000006  f0010101          AND      r1,r1,#1
00000a  b109              CBZ      r1,|L4.16|
;;;879            fmc_state = FMC_BUSY;
00000c  2001              MOVS     r0,#1
00000e  e00c              B        |L4.42|
                  |L4.16|
;;;880        }else{
;;;881            if((uint32_t)0x00U != (FMC_STAT0 & FMC_STAT0_WPERR)){
000010  4906              LDR      r1,|L4.44|
000012  68c9              LDR      r1,[r1,#0xc]
000014  f0010110          AND      r1,r1,#0x10
000018  b109              CBZ      r1,|L4.30|
;;;882                fmc_state = FMC_WPERR;
00001a  2003              MOVS     r0,#3
00001c  e005              B        |L4.42|
                  |L4.30|
;;;883            }else{
;;;884                if((uint32_t)0x00U != (FMC_STAT0 & (FMC_STAT0_PGERR))){
00001e  4903              LDR      r1,|L4.44|
000020  68c9              LDR      r1,[r1,#0xc]
000022  f0010104          AND      r1,r1,#4
000026  b101              CBZ      r1,|L4.42|
;;;885                    fmc_state = FMC_PGERR; 
000028  2002              MOVS     r0,#2
                  |L4.42|
;;;886                }
;;;887            }
;;;888        }
;;;889        /* return the FMC state */
;;;890        return fmc_state;
;;;891    }
00002a  4770              BX       lr
;;;892    
                          ENDP

                  |L4.44|
                          DCD      0x40022000

                          AREA ||i.fmc_bank0_unlock||, CODE, READONLY, ALIGN=2

                  fmc_bank0_unlock PROC
;;;91     */
;;;92     void fmc_bank0_unlock(void)
000000  4805              LDR      r0,|L5.24|
;;;93     {
;;;94         if((RESET != (FMC_CTL0 & FMC_CTL0_LK))){
000002  6900              LDR      r0,[r0,#0x10]
000004  f0000080          AND      r0,r0,#0x80
000008  b120              CBZ      r0,|L5.20|
;;;95             /* write the FMC unlock key */
;;;96             FMC_KEY0 = UNLOCK_KEY0;
00000a  4804              LDR      r0,|L5.28|
00000c  4902              LDR      r1,|L5.24|
00000e  6048              STR      r0,[r1,#4]
;;;97             FMC_KEY0 = UNLOCK_KEY1;
000010  4803              LDR      r0,|L5.32|
000012  6048              STR      r0,[r1,#4]
                  |L5.20|
;;;98         }
;;;99     }
000014  4770              BX       lr
;;;100    
                          ENDP

000016  0000              DCW      0x0000
                  |L5.24|
                          DCD      0x40022000
                  |L5.28|
                          DCD      0x45670123
                  |L5.32|
                          DCD      0xcdef89ab

                          AREA ||i.fmc_bank1_erase||, CODE, READONLY, ALIGN=2

                  fmc_bank1_erase PROC
;;;297    */
;;;298    fmc_state_enum fmc_bank1_erase(void)
000000  b510              PUSH     {r4,lr}
;;;299    {
;;;300        fmc_state_enum fmc_state = FMC_READY;
000002  2400              MOVS     r4,#0
;;;301        /* wait for the FMC ready */
;;;302        fmc_state = fmc_bank1_ready_wait(FMC_TIMEOUT_COUNT);
000004  f44f2070          MOV      r0,#0xf0000
000008  f7fffffe          BL       fmc_bank1_ready_wait
00000c  4604              MOV      r4,r0
;;;303      
;;;304       if(FMC_READY == fmc_state){
00000e  b9ac              CBNZ     r4,|L6.60|
;;;305            /* start FMC bank1 erase */
;;;306            FMC_CTL1 |= FMC_CTL1_MER;
000010  480b              LDR      r0,|L6.64|
000012  6d00              LDR      r0,[r0,#0x50]
000014  f0400004          ORR      r0,r0,#4
000018  4909              LDR      r1,|L6.64|
00001a  6508              STR      r0,[r1,#0x50]
;;;307            FMC_CTL1 |= FMC_CTL1_START;
00001c  4608              MOV      r0,r1
00001e  6d00              LDR      r0,[r0,#0x50]
000020  f0400040          ORR      r0,r0,#0x40
000024  6508              STR      r0,[r1,#0x50]
;;;308            /* wait for the FMC ready */
;;;309            fmc_state = fmc_bank1_ready_wait(FMC_TIMEOUT_COUNT);
000026  f44f2070          MOV      r0,#0xf0000
00002a  f7fffffe          BL       fmc_bank1_ready_wait
00002e  4604              MOV      r4,r0
;;;310            /* reset the MER bit */
;;;311            FMC_CTL1 &= ~FMC_CTL1_MER;
000030  4803              LDR      r0,|L6.64|
000032  6d00              LDR      r0,[r0,#0x50]
000034  f0200004          BIC      r0,r0,#4
000038  4901              LDR      r1,|L6.64|
00003a  6508              STR      r0,[r1,#0x50]
                  |L6.60|
;;;312        }
;;;313        /* return the fmc state */
;;;314        return fmc_state;
00003c  4620              MOV      r0,r4
;;;315    }
00003e  bd10              POP      {r4,pc}
;;;316    
                          ENDP

                  |L6.64|
                          DCD      0x40022000

                          AREA ||i.fmc_bank1_lock||, CODE, READONLY, ALIGN=2

                  fmc_bank1_lock PROC
;;;155    */
;;;156    void fmc_bank1_lock(void)
000000  4803              LDR      r0,|L7.16|
;;;157    {
;;;158        /* set the LK bit*/
;;;159        FMC_CTL1 |= FMC_CTL1_LK;
000002  6d00              LDR      r0,[r0,#0x50]
000004  f0400080          ORR      r0,r0,#0x80
000008  4901              LDR      r1,|L7.16|
00000a  6508              STR      r0,[r1,#0x50]
;;;160    }
00000c  4770              BX       lr
;;;161    
                          ENDP

00000e  0000              DCW      0x0000
                  |L7.16|
                          DCD      0x40022000

                          AREA ||i.fmc_bank1_ready_wait||, CODE, READONLY, ALIGN=1

                  fmc_bank1_ready_wait PROC
;;;948    */
;;;949    fmc_state_enum fmc_bank1_ready_wait(uint32_t timeout)
000000  b500              PUSH     {lr}
;;;950    {
000002  4603              MOV      r3,r0
;;;951        fmc_state_enum fmc_state = FMC_BUSY;
000004  2201              MOVS     r2,#1
;;;952      
;;;953        /* wait for FMC ready */
;;;954        do{
000006  bf00              NOP      
                  |L8.8|
;;;955            /* get FMC state */
;;;956            fmc_state = fmc_bank1_state_get();
000008  f7fffffe          BL       fmc_bank1_state_get
00000c  4602              MOV      r2,r0
;;;957            timeout--;
00000e  1e5b              SUBS     r3,r3,#1
;;;958        }while((FMC_BUSY == fmc_state) && (0x00U != timeout));
000010  2a01              CMP      r2,#1
000012  d101              BNE      |L8.24|
000014  2b00              CMP      r3,#0
000016  d1f7              BNE      |L8.8|
                  |L8.24|
;;;959        
;;;960        if(FMC_BUSY == fmc_state){
000018  2a01              CMP      r2,#1
00001a  d100              BNE      |L8.30|
;;;961            fmc_state = FMC_TOERR;
00001c  2204              MOVS     r2,#4
                  |L8.30|
;;;962        }
;;;963        /* return the FMC state */
;;;964        return fmc_state;
00001e  4610              MOV      r0,r2
;;;965    }
000020  bd00              POP      {pc}
                          ENDP


                          AREA ||i.fmc_bank1_state_get||, CODE, READONLY, ALIGN=2

                  fmc_bank1_state_get PROC
;;;898    */
;;;899    fmc_state_enum fmc_bank1_state_get(void)
000000  2000              MOVS     r0,#0
;;;900    {
;;;901        fmc_state_enum fmc_state = FMC_READY;
;;;902    
;;;903        if((uint32_t)0x00U != (FMC_STAT1 & FMC_STAT1_BUSY)){
000002  490a              LDR      r1,|L9.44|
000004  6cc9              LDR      r1,[r1,#0x4c]
000006  f0010101          AND      r1,r1,#1
00000a  b109              CBZ      r1,|L9.16|
;;;904            fmc_state = FMC_BUSY;
00000c  2001              MOVS     r0,#1
00000e  e00c              B        |L9.42|
                  |L9.16|
;;;905        }else{
;;;906            if((uint32_t)0x00U != (FMC_STAT1 & FMC_STAT1_WPERR)){
000010  4906              LDR      r1,|L9.44|
000012  6cc9              LDR      r1,[r1,#0x4c]
000014  f0010110          AND      r1,r1,#0x10
000018  b109              CBZ      r1,|L9.30|
;;;907                fmc_state = FMC_WPERR;
00001a  2003              MOVS     r0,#3
00001c  e005              B        |L9.42|
                  |L9.30|
;;;908            }else{
;;;909                if((uint32_t)0x00U != (FMC_STAT1 & FMC_STAT1_PGERR)){
00001e  4903              LDR      r1,|L9.44|
000020  6cc9              LDR      r1,[r1,#0x4c]
000022  f0010104          AND      r1,r1,#4
000026  b101              CBZ      r1,|L9.42|
;;;910                    fmc_state = FMC_PGERR; 
000028  2002              MOVS     r0,#2
                  |L9.42|
;;;911                }
;;;912            }
;;;913        }
;;;914    
;;;915        /* return the FMC state */
;;;916        return fmc_state;
;;;917    }
00002a  4770              BX       lr
;;;918    
                          ENDP

                  |L9.44|
                          DCD      0x40022000

                          AREA ||i.fmc_bank1_unlock||, CODE, READONLY, ALIGN=2

                  fmc_bank1_unlock PROC
;;;107    */
;;;108    void fmc_bank1_unlock(void)
000000  4805              LDR      r0,|L10.24|
;;;109    {
;;;110        if((RESET != (FMC_CTL1 & FMC_CTL1_LK))){
000002  6d00              LDR      r0,[r0,#0x50]
000004  f0000080          AND      r0,r0,#0x80
000008  b120              CBZ      r0,|L10.20|
;;;111            /* write the FMC unlock key */
;;;112            FMC_KEY1 = UNLOCK_KEY0;
00000a  4804              LDR      r0,|L10.28|
00000c  4902              LDR      r1,|L10.24|
00000e  6448              STR      r0,[r1,#0x44]
;;;113            FMC_KEY1 = UNLOCK_KEY1;
000010  4803              LDR      r0,|L10.32|
000012  6448              STR      r0,[r1,#0x44]
                  |L10.20|
;;;114        }
;;;115    }
000014  4770              BX       lr
;;;116    
                          ENDP

000016  0000              DCW      0x0000
                  |L10.24|
                          DCD      0x40022000
                  |L10.28|
                          DCD      0x45670123
                  |L10.32|
                          DCD      0xcdef89ab

                          AREA ||i.fmc_flag_clear||, CODE, READONLY, ALIGN=2

                  fmc_flag_clear PROC
;;;807    */
;;;808    void fmc_flag_clear(uint32_t flag)
000000  4a06              LDR      r2,|L11.28|
;;;809    {
;;;810        FMC_REG_VAL(flag) |= BIT(FMC_BIT_POS(flag));
000002  eb021190          ADD      r1,r2,r0,LSR #6
000006  6809              LDR      r1,[r1,#0]
000008  f000031f          AND      r3,r0,#0x1f
00000c  2201              MOVS     r2,#1
00000e  409a              LSLS     r2,r2,r3
000010  4311              ORRS     r1,r1,r2
000012  4b02              LDR      r3,|L11.28|
000014  eb031290          ADD      r2,r3,r0,LSR #6
000018  6011              STR      r1,[r2,#0]
;;;811    }
00001a  4770              BX       lr
;;;812    
                          ENDP

                  |L11.28|
                          DCD      0x40022000

                          AREA ||i.fmc_flag_get||, CODE, READONLY, ALIGN=2

                  fmc_flag_get PROC
;;;785    */
;;;786    FlagStatus fmc_flag_get(uint32_t flag)
000000  4601              MOV      r1,r0
;;;787    {
;;;788        if(RESET != (FMC_REG_VAL(flag) & BIT(FMC_BIT_POS(flag)))){
000002  4a07              LDR      r2,|L12.32|
000004  eb021091          ADD      r0,r2,r1,LSR #6
000008  6800              LDR      r0,[r0,#0]
00000a  f001031f          AND      r3,r1,#0x1f
00000e  2201              MOVS     r2,#1
000010  409a              LSLS     r2,r2,r3
000012  4010              ANDS     r0,r0,r2
000014  b108              CBZ      r0,|L12.26|
;;;789            return SET;
000016  2001              MOVS     r0,#1
                  |L12.24|
;;;790        }else{
;;;791            return RESET;
;;;792        }
;;;793    }
000018  4770              BX       lr
                  |L12.26|
00001a  2000              MOVS     r0,#0                 ;791
00001c  e7fc              B        |L12.24|
;;;794    
                          ENDP

00001e  0000              DCW      0x0000
                  |L12.32|
                          DCD      0x40022000

                          AREA ||i.fmc_halfword_program||, CODE, READONLY, ALIGN=2

                  fmc_halfword_program PROC
;;;376    */
;;;377    fmc_state_enum fmc_halfword_program(uint32_t address, uint16_t data)
000000  b570              PUSH     {r4-r6,lr}
;;;378    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;379        fmc_state_enum fmc_state = FMC_READY;
000006  2600              MOVS     r6,#0
;;;380        if(FMC_BANK0_SIZE > FMC_SIZE){
000008  482a              LDR      r0,|L13.180|
00000a  8800              LDRH     r0,[r0,#0]
00000c  f5b07f00          CMP      r0,#0x200
000010  d235              BCS      |L13.126|
;;;381            if(FMC_BANK0_END_ADDRESS > address){
000012  4829              LDR      r0,|L13.184|
000014  4284              CMP      r4,r0
000016  d219              BCS      |L13.76|
;;;382                fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT); 
000018  f44f2070          MOV      r0,#0xf0000
00001c  f7fffffe          BL       fmc_bank0_ready_wait
000020  4606              MOV      r6,r0
;;;383      
;;;384                if(FMC_READY == fmc_state){
000022  2e00              CMP      r6,#0
000024  d143              BNE      |L13.174|
;;;385                    /* set the PG bit to start program */
;;;386                    FMC_CTL0 |= FMC_CTL0_PG;
000026  4825              LDR      r0,|L13.188|
000028  6900              LDR      r0,[r0,#0x10]
00002a  f0400001          ORR      r0,r0,#1
00002e  4923              LDR      r1,|L13.188|
000030  6108              STR      r0,[r1,#0x10]
;;;387                    REG16(address) = data;
000032  8025              STRH     r5,[r4,#0]
;;;388                    /* wait for the FMC ready */
;;;389                    fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT);
000034  f44f2070          MOV      r0,#0xf0000
000038  f7fffffe          BL       fmc_bank0_ready_wait
00003c  4606              MOV      r6,r0
;;;390                    /* reset the PG bit */
;;;391                    FMC_CTL0 &= ~FMC_CTL0_PG;
00003e  481f              LDR      r0,|L13.188|
000040  6900              LDR      r0,[r0,#0x10]
000042  f0200001          BIC      r0,r0,#1
000046  491d              LDR      r1,|L13.188|
000048  6108              STR      r0,[r1,#0x10]
00004a  e030              B        |L13.174|
                  |L13.76|
;;;392                }
;;;393            }else{
;;;394                fmc_state = fmc_bank1_ready_wait(FMC_TIMEOUT_COUNT); 
00004c  f44f2070          MOV      r0,#0xf0000
000050  f7fffffe          BL       fmc_bank1_ready_wait
000054  4606              MOV      r6,r0
;;;395      
;;;396                if(FMC_READY == fmc_state){
000056  bb56              CBNZ     r6,|L13.174|
;;;397                    /* set the PG bit to start program */
;;;398                    FMC_CTL1 |= FMC_CTL1_PG;
000058  4818              LDR      r0,|L13.188|
00005a  6d00              LDR      r0,[r0,#0x50]
00005c  f0400001          ORR      r0,r0,#1
000060  4916              LDR      r1,|L13.188|
000062  6508              STR      r0,[r1,#0x50]
;;;399                    REG16(address) = data;
000064  8025              STRH     r5,[r4,#0]
;;;400                    /* wait for the FMC ready */
;;;401                    fmc_state = fmc_bank1_ready_wait(FMC_TIMEOUT_COUNT);
000066  f44f2070          MOV      r0,#0xf0000
00006a  f7fffffe          BL       fmc_bank1_ready_wait
00006e  4606              MOV      r6,r0
;;;402                    /* reset the PG bit */
;;;403                    FMC_CTL1 &= ~FMC_CTL1_PG;
000070  4812              LDR      r0,|L13.188|
000072  6d00              LDR      r0,[r0,#0x50]
000074  f0200001          BIC      r0,r0,#1
000078  4910              LDR      r1,|L13.188|
00007a  6508              STR      r0,[r1,#0x50]
00007c  e017              B        |L13.174|
                  |L13.126|
;;;404                }
;;;405            }
;;;406        }else{
;;;407            fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT);
00007e  f44f2070          MOV      r0,#0xf0000
000082  f7fffffe          BL       fmc_bank0_ready_wait
000086  4606              MOV      r6,r0
;;;408      
;;;409            if(FMC_READY == fmc_state){
000088  b98e              CBNZ     r6,|L13.174|
;;;410                /* set the PG bit to start program */
;;;411                FMC_CTL0 |= FMC_CTL0_PG;
00008a  480c              LDR      r0,|L13.188|
00008c  6900              LDR      r0,[r0,#0x10]
00008e  f0400001          ORR      r0,r0,#1
000092  490a              LDR      r1,|L13.188|
000094  6108              STR      r0,[r1,#0x10]
;;;412                REG16(address) = data;
000096  8025              STRH     r5,[r4,#0]
;;;413                /* wait for the FMC ready */
;;;414                fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT);
000098  f44f2070          MOV      r0,#0xf0000
00009c  f7fffffe          BL       fmc_bank0_ready_wait
0000a0  4606              MOV      r6,r0
;;;415                /* reset the PG bit */
;;;416                FMC_CTL0 &= ~FMC_CTL0_PG;
0000a2  4806              LDR      r0,|L13.188|
0000a4  6900              LDR      r0,[r0,#0x10]
0000a6  f0200001          BIC      r0,r0,#1
0000aa  4904              LDR      r1,|L13.188|
0000ac  6108              STR      r0,[r1,#0x10]
                  |L13.174|
;;;417            } 
;;;418        }
;;;419        /* return the FMC state */
;;;420        return fmc_state;
0000ae  4630              MOV      r0,r6
;;;421    }
0000b0  bd70              POP      {r4-r6,pc}
;;;422    
                          ENDP

0000b2  0000              DCW      0x0000
                  |L13.180|
                          DCD      0x1ffff7e0
                  |L13.184|
                          DCD      0x0807ffff
                  |L13.188|
                          DCD      0x40022000

                          AREA ||i.fmc_interrupt_disable||, CODE, READONLY, ALIGN=2

                  fmc_interrupt_disable PROC
;;;764    */
;;;765    void fmc_interrupt_disable(uint32_t interrupt)
000000  4a06              LDR      r2,|L14.28|
;;;766    {
;;;767        FMC_REG_VAL(interrupt) &= ~BIT(FMC_BIT_POS(interrupt));
000002  eb021190          ADD      r1,r2,r0,LSR #6
000006  6809              LDR      r1,[r1,#0]
000008  f000031f          AND      r3,r0,#0x1f
00000c  2201              MOVS     r2,#1
00000e  409a              LSLS     r2,r2,r3
000010  4391              BICS     r1,r1,r2
000012  4b02              LDR      r3,|L14.28|
000014  eb031290          ADD      r2,r3,r0,LSR #6
000018  6011              STR      r1,[r2,#0]
;;;768    }
00001a  4770              BX       lr
;;;769    
                          ENDP

                  |L14.28|
                          DCD      0x40022000

                          AREA ||i.fmc_interrupt_enable||, CODE, READONLY, ALIGN=2

                  fmc_interrupt_enable PROC
;;;748    */
;;;749    void fmc_interrupt_enable(uint32_t interrupt)
000000  4a06              LDR      r2,|L15.28|
;;;750    {
;;;751        FMC_REG_VAL(interrupt) |= BIT(FMC_BIT_POS(interrupt));
000002  eb021190          ADD      r1,r2,r0,LSR #6
000006  6809              LDR      r1,[r1,#0]
000008  f000031f          AND      r3,r0,#0x1f
00000c  2201              MOVS     r2,#1
00000e  409a              LSLS     r2,r2,r3
000010  4311              ORRS     r1,r1,r2
000012  4b02              LDR      r3,|L15.28|
000014  eb031290          ADD      r2,r3,r0,LSR #6
000018  6011              STR      r1,[r2,#0]
;;;752    }
00001a  4770              BX       lr
;;;753    
                          ENDP

                  |L15.28|
                          DCD      0x40022000

                          AREA ||i.fmc_interrupt_flag_clear||, CODE, READONLY, ALIGN=2

                  fmc_interrupt_flag_clear PROC
;;;862    */
;;;863    void fmc_interrupt_flag_clear(fmc_interrupt_flag_enum flag)
000000  4a06              LDR      r2,|L16.28|
;;;864    {
;;;865        FMC_REG_VALS(flag) |= BIT(FMC_BIT_POS0(flag));
000002  eb023110          ADD      r1,r2,r0,LSR #12
000006  6809              LDR      r1,[r1,#0]
000008  f3c01384          UBFX     r3,r0,#6,#5
00000c  2201              MOVS     r2,#1
00000e  409a              LSLS     r2,r2,r3
000010  4311              ORRS     r1,r1,r2
000012  4b02              LDR      r3,|L16.28|
000014  eb033210          ADD      r2,r3,r0,LSR #12
000018  6011              STR      r1,[r2,#0]
;;;866    }
00001a  4770              BX       lr
;;;867    
                          ENDP

                  |L16.28|
                          DCD      0x40022000

                          AREA ||i.fmc_interrupt_flag_get||, CODE, READONLY, ALIGN=2

                  fmc_interrupt_flag_get PROC
;;;825    */
;;;826    FlagStatus fmc_interrupt_flag_get(fmc_interrupt_flag_enum flag)
000000  b530              PUSH     {r4,r5,lr}
;;;827    {
000002  4601              MOV      r1,r0
;;;828        uint32_t ret1 = RESET;
000004  2200              MOVS     r2,#0
;;;829        uint32_t ret2 = RESET;
000006  2300              MOVS     r3,#0
;;;830        
;;;831        if(FMC_STAT0_REG_OFFSET == FMC_REG_OFFSET_GET(flag)){
000008  200c              MOVS     r0,#0xc
00000a  ebb03f11          CMP      r0,r1,LSR #12
00000e  d112              BNE      |L17.54|
;;;832            /* get the staus of interrupt flag */
;;;833            ret1 = (uint32_t)(FMC_REG_VALS(flag) & BIT(FMC_BIT_POS0(flag)));
000010  4c15              LDR      r4,|L17.104|
000012  eb043011          ADD      r0,r4,r1,LSR #12
000016  6800              LDR      r0,[r0,#0]
000018  f3c11584          UBFX     r5,r1,#6,#5
00001c  2401              MOVS     r4,#1
00001e  40ac              LSLS     r4,r4,r5
000020  ea000204          AND      r2,r0,r4
;;;834            /* get the staus of interrupt enale bit */
;;;835            ret2 = (uint32_t)(FMC_CTL0 & BIT(FMC_BIT_POS1(flag)));
000024  4810              LDR      r0,|L17.104|
000026  6900              LDR      r0,[r0,#0x10]
000028  f001051f          AND      r5,r1,#0x1f
00002c  2401              MOVS     r4,#1
00002e  40ac              LSLS     r4,r4,r5
000030  ea000304          AND      r3,r0,r4
000034  e011              B        |L17.90|
                  |L17.54|
;;;836        }else{
;;;837            /* get the staus of interrupt flag */
;;;838            ret1 = (uint32_t)(FMC_REG_VALS(flag) & BIT(FMC_BIT_POS0(flag)));
000036  4c0c              LDR      r4,|L17.104|
000038  eb043011          ADD      r0,r4,r1,LSR #12
00003c  6800              LDR      r0,[r0,#0]
00003e  f3c11584          UBFX     r5,r1,#6,#5
000042  2401              MOVS     r4,#1
000044  40ac              LSLS     r4,r4,r5
000046  ea000204          AND      r2,r0,r4
;;;839            /* get the staus of interrupt enale bit */
;;;840            ret2 = (uint32_t)(FMC_CTL1 & BIT(FMC_BIT_POS1(flag)));
00004a  4807              LDR      r0,|L17.104|
00004c  6d00              LDR      r0,[r0,#0x50]
00004e  f001051f          AND      r5,r1,#0x1f
000052  2401              MOVS     r4,#1
000054  40ac              LSLS     r4,r4,r5
000056  ea000304          AND      r3,r0,r4
                  |L17.90|
;;;841        }
;;;842    
;;;843        if(ret1 && ret2){
00005a  b112              CBZ      r2,|L17.98|
00005c  b10b              CBZ      r3,|L17.98|
;;;844            return SET;
00005e  2001              MOVS     r0,#1
                  |L17.96|
;;;845        }else{
;;;846            return RESET;
;;;847        }
;;;848    }
000060  bd30              POP      {r4,r5,pc}
                  |L17.98|
000062  2000              MOVS     r0,#0                 ;846
000064  e7fc              B        |L17.96|
;;;849    
                          ENDP

000066  0000              DCW      0x0000
                  |L17.104|
                          DCD      0x40022000

                          AREA ||i.fmc_lock||, CODE, READONLY, ALIGN=2

                  fmc_lock PROC
;;;122    */
;;;123    void fmc_lock(void)
000000  4808              LDR      r0,|L18.36|
;;;124    {
;;;125        /* set the LK bit */
;;;126        FMC_CTL0 |= FMC_CTL0_LK;
000002  6900              LDR      r0,[r0,#0x10]
000004  f0400080          ORR      r0,r0,#0x80
000008  4906              LDR      r1,|L18.36|
00000a  6108              STR      r0,[r1,#0x10]
;;;127        
;;;128        if(FMC_BANK0_SIZE < FMC_SIZE){
00000c  4806              LDR      r0,|L18.40|
00000e  8800              LDRH     r0,[r0,#0]
000010  f5b07f00          CMP      r0,#0x200
000014  d904              BLS      |L18.32|
;;;129            /* set the LK bit */
;;;130            FMC_CTL1 |= FMC_CTL1_LK;
000016  4608              MOV      r0,r1
000018  6d00              LDR      r0,[r0,#0x50]
00001a  f0400080          ORR      r0,r0,#0x80
00001e  6508              STR      r0,[r1,#0x50]
                  |L18.32|
;;;131        }
;;;132    }
000020  4770              BX       lr
;;;133    
                          ENDP

000022  0000              DCW      0x0000
                  |L18.36|
                          DCD      0x40022000
                  |L18.40|
                          DCD      0x1ffff7e0

                          AREA ||i.fmc_mass_erase||, CODE, READONLY, ALIGN=2

                  fmc_mass_erase PROC
;;;224    */
;;;225    fmc_state_enum fmc_mass_erase(void)
000000  b510              PUSH     {r4,lr}
;;;226    {
;;;227        fmc_state_enum fmc_state;
;;;228        if(FMC_BANK0_SIZE < FMC_SIZE){
000002  482e              LDR      r0,|L19.188|
000004  8800              LDRH     r0,[r0,#0]
000006  f5b07f00          CMP      r0,#0x200
00000a  d938              BLS      |L19.126|
;;;229            /* wait for the FMC ready */
;;;230            fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT);
00000c  f44f2070          MOV      r0,#0xf0000
000010  f7fffffe          BL       fmc_bank0_ready_wait
000014  4604              MOV      r4,r0
;;;231            if(FMC_READY == fmc_state){
000016  b9ac              CBNZ     r4,|L19.68|
;;;232                /* start whole chip erase */
;;;233                FMC_CTL0 |= FMC_CTL0_MER;
000018  4829              LDR      r0,|L19.192|
00001a  6900              LDR      r0,[r0,#0x10]
00001c  f0400004          ORR      r0,r0,#4
000020  4927              LDR      r1,|L19.192|
000022  6108              STR      r0,[r1,#0x10]
;;;234                FMC_CTL0 |= FMC_CTL0_START;
000024  4608              MOV      r0,r1
000026  6900              LDR      r0,[r0,#0x10]
000028  f0400040          ORR      r0,r0,#0x40
00002c  6108              STR      r0,[r1,#0x10]
;;;235                /* wait for the FMC ready */
;;;236                fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT);
00002e  f44f2070          MOV      r0,#0xf0000
000032  f7fffffe          BL       fmc_bank0_ready_wait
000036  4604              MOV      r4,r0
;;;237                /* reset the MER bit */
;;;238                FMC_CTL0 &= ~FMC_CTL0_MER;
000038  4821              LDR      r0,|L19.192|
00003a  6900              LDR      r0,[r0,#0x10]
00003c  f0200004          BIC      r0,r0,#4
000040  491f              LDR      r1,|L19.192|
000042  6108              STR      r0,[r1,#0x10]
                  |L19.68|
;;;239            }
;;;240            fmc_state = fmc_bank1_ready_wait(FMC_TIMEOUT_COUNT);
000044  f44f2070          MOV      r0,#0xf0000
000048  f7fffffe          BL       fmc_bank1_ready_wait
00004c  4604              MOV      r4,r0
;;;241            if(FMC_READY == fmc_state){
00004e  bb94              CBNZ     r4,|L19.182|
;;;242                /* start whole chip erase */
;;;243                FMC_CTL1 |= FMC_CTL1_MER;
000050  481b              LDR      r0,|L19.192|
000052  6d00              LDR      r0,[r0,#0x50]
000054  f0400004          ORR      r0,r0,#4
000058  4919              LDR      r1,|L19.192|
00005a  6508              STR      r0,[r1,#0x50]
;;;244                FMC_CTL1 |= FMC_CTL1_START;
00005c  4608              MOV      r0,r1
00005e  6d00              LDR      r0,[r0,#0x50]
000060  f0400040          ORR      r0,r0,#0x40
000064  6508              STR      r0,[r1,#0x50]
;;;245                /* wait for the FMC ready */
;;;246                fmc_state = fmc_bank1_ready_wait(FMC_TIMEOUT_COUNT);
000066  f44f2070          MOV      r0,#0xf0000
00006a  f7fffffe          BL       fmc_bank1_ready_wait
00006e  4604              MOV      r4,r0
;;;247                /* reset the MER bit */
;;;248                FMC_CTL1 &= ~FMC_CTL1_MER;
000070  4813              LDR      r0,|L19.192|
000072  6d00              LDR      r0,[r0,#0x50]
000074  f0200004          BIC      r0,r0,#4
000078  4911              LDR      r1,|L19.192|
00007a  6508              STR      r0,[r1,#0x50]
00007c  e01b              B        |L19.182|
                  |L19.126|
;;;249            }
;;;250        }else{
;;;251            fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT);
00007e  f44f2070          MOV      r0,#0xf0000
000082  f7fffffe          BL       fmc_bank0_ready_wait
000086  4604              MOV      r4,r0
;;;252      
;;;253            if(FMC_READY == fmc_state){
000088  b9ac              CBNZ     r4,|L19.182|
;;;254                /* start whole chip erase */
;;;255                FMC_CTL0 |= FMC_CTL0_MER;
00008a  480d              LDR      r0,|L19.192|
00008c  6900              LDR      r0,[r0,#0x10]
00008e  f0400004          ORR      r0,r0,#4
000092  490b              LDR      r1,|L19.192|
000094  6108              STR      r0,[r1,#0x10]
;;;256                FMC_CTL0 |= FMC_CTL0_START;    
000096  4608              MOV      r0,r1
000098  6900              LDR      r0,[r0,#0x10]
00009a  f0400040          ORR      r0,r0,#0x40
00009e  6108              STR      r0,[r1,#0x10]
;;;257                /* wait for the FMC ready */
;;;258                fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT);
0000a0  f44f2070          MOV      r0,#0xf0000
0000a4  f7fffffe          BL       fmc_bank0_ready_wait
0000a8  4604              MOV      r4,r0
;;;259                /* reset the MER bit */
;;;260                FMC_CTL0 &= ~FMC_CTL0_MER;
0000aa  4805              LDR      r0,|L19.192|
0000ac  6900              LDR      r0,[r0,#0x10]
0000ae  f0200004          BIC      r0,r0,#4
0000b2  4903              LDR      r1,|L19.192|
0000b4  6108              STR      r0,[r1,#0x10]
                  |L19.182|
;;;261            }
;;;262        }
;;;263        /* return the FMC state  */
;;;264        return fmc_state;
0000b6  4620              MOV      r0,r4
;;;265    }
0000b8  bd10              POP      {r4,pc}
;;;266    
                          ENDP

0000ba  0000              DCW      0x0000
                  |L19.188|
                          DCD      0x1ffff7e0
                  |L19.192|
                          DCD      0x40022000

                          AREA ||i.fmc_page_erase||, CODE, READONLY, ALIGN=2

                  fmc_page_erase PROC
;;;167    */
;;;168    fmc_state_enum fmc_page_erase(uint32_t page_address)
000000  b530              PUSH     {r4,r5,lr}
;;;169    {
000002  4605              MOV      r5,r0
;;;170        fmc_state_enum fmc_state;
;;;171        
;;;172        if(FMC_BANK0_SIZE < FMC_SIZE){
000004  4836              LDR      r0,|L20.224|
000006  8800              LDRH     r0,[r0,#0]
000008  f5b07f00          CMP      r0,#0x200
00000c  d948              BLS      |L20.160|
;;;173            if(FMC_BANK0_END_ADDRESS > page_address){
00000e  4835              LDR      r0,|L20.228|
000010  4285              CMP      r5,r0
000012  d21e              BCS      |L20.82|
;;;174                fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT);
000014  f44f2070          MOV      r0,#0xf0000
000018  f7fffffe          BL       fmc_bank0_ready_wait
00001c  4604              MOV      r4,r0
;;;175                /* if the last operation is completed, start page erase */
;;;176                if(FMC_READY == fmc_state){
00001e  2c00              CMP      r4,#0
000020  d15b              BNE      |L20.218|
;;;177                    FMC_CTL0 |= FMC_CTL0_PER;
000022  4831              LDR      r0,|L20.232|
000024  6900              LDR      r0,[r0,#0x10]
000026  f0400002          ORR      r0,r0,#2
00002a  492f              LDR      r1,|L20.232|
00002c  6108              STR      r0,[r1,#0x10]
;;;178                    FMC_ADDR0 = page_address;
00002e  4608              MOV      r0,r1
000030  6145              STR      r5,[r0,#0x14]
;;;179                    FMC_CTL0 |= FMC_CTL0_START;
000032  6900              LDR      r0,[r0,#0x10]
000034  f0400040          ORR      r0,r0,#0x40
000038  6108              STR      r0,[r1,#0x10]
;;;180                    /* wait for the FMC ready */
;;;181                    fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT);
00003a  f44f2070          MOV      r0,#0xf0000
00003e  f7fffffe          BL       fmc_bank0_ready_wait
000042  4604              MOV      r4,r0
;;;182                    /* reset the PER bit */
;;;183                    FMC_CTL0 &= ~FMC_CTL0_PER;
000044  4828              LDR      r0,|L20.232|
000046  6900              LDR      r0,[r0,#0x10]
000048  f0200002          BIC      r0,r0,#2
00004c  4926              LDR      r1,|L20.232|
00004e  6108              STR      r0,[r1,#0x10]
000050  e043              B        |L20.218|
                  |L20.82|
;;;184                }
;;;185            }else{
;;;186                /* wait for the FMC ready */
;;;187                fmc_state = fmc_bank1_ready_wait(FMC_TIMEOUT_COUNT);
000052  f44f2070          MOV      r0,#0xf0000
000056  f7fffffe          BL       fmc_bank1_ready_wait
00005a  4604              MOV      r4,r0
;;;188                /* if the last operation is completed, start page erase */
;;;189                if(FMC_READY == fmc_state){
00005c  2c00              CMP      r4,#0
00005e  d13c              BNE      |L20.218|
;;;190                    FMC_CTL1 |= FMC_CTL1_PER;
000060  4821              LDR      r0,|L20.232|
000062  6d00              LDR      r0,[r0,#0x50]
000064  f0400002          ORR      r0,r0,#2
000068  491f              LDR      r1,|L20.232|
00006a  6508              STR      r0,[r1,#0x50]
;;;191                    FMC_ADDR1 = page_address;
00006c  4608              MOV      r0,r1
00006e  6545              STR      r5,[r0,#0x54]
;;;192                    if(FMC_OBSTAT & FMC_OBSTAT_SPC){
000070  69c0              LDR      r0,[r0,#0x1c]
000072  f0000002          AND      r0,r0,#2
000076  b108              CBZ      r0,|L20.124|
;;;193                        FMC_ADDR0 = page_address;
000078  4608              MOV      r0,r1
00007a  6145              STR      r5,[r0,#0x14]
                  |L20.124|
;;;194                    }
;;;195                    FMC_CTL1 |= FMC_CTL1_START;
00007c  481a              LDR      r0,|L20.232|
00007e  6d00              LDR      r0,[r0,#0x50]
000080  f0400040          ORR      r0,r0,#0x40
000084  4918              LDR      r1,|L20.232|
000086  6508              STR      r0,[r1,#0x50]
;;;196                    /* wait for the FMC ready */
;;;197                    fmc_state = fmc_bank1_ready_wait(FMC_TIMEOUT_COUNT);
000088  f44f2070          MOV      r0,#0xf0000
00008c  f7fffffe          BL       fmc_bank1_ready_wait
000090  4604              MOV      r4,r0
;;;198                    /* reset the PER bit */
;;;199                    FMC_CTL1 &= ~FMC_CTL1_PER;
000092  4815              LDR      r0,|L20.232|
000094  6d00              LDR      r0,[r0,#0x50]
000096  f0200002          BIC      r0,r0,#2
00009a  4913              LDR      r1,|L20.232|
00009c  6508              STR      r0,[r1,#0x50]
00009e  e01c              B        |L20.218|
                  |L20.160|
;;;200                }
;;;201            }
;;;202        }else{
;;;203            fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT);
0000a0  f44f2070          MOV      r0,#0xf0000
0000a4  f7fffffe          BL       fmc_bank0_ready_wait
0000a8  4604              MOV      r4,r0
;;;204            /* if the last operation is completed, start page erase */
;;;205            if(FMC_READY == fmc_state){
0000aa  b9b4              CBNZ     r4,|L20.218|
;;;206                FMC_CTL0 |= FMC_CTL0_PER;
0000ac  480e              LDR      r0,|L20.232|
0000ae  6900              LDR      r0,[r0,#0x10]
0000b0  f0400002          ORR      r0,r0,#2
0000b4  490c              LDR      r1,|L20.232|
0000b6  6108              STR      r0,[r1,#0x10]
;;;207                FMC_ADDR0 = page_address;
0000b8  4608              MOV      r0,r1
0000ba  6145              STR      r5,[r0,#0x14]
;;;208                FMC_CTL0 |= FMC_CTL0_START;
0000bc  6900              LDR      r0,[r0,#0x10]
0000be  f0400040          ORR      r0,r0,#0x40
0000c2  6108              STR      r0,[r1,#0x10]
;;;209                /* wait for the FMC ready */
;;;210                fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT);
0000c4  f44f2070          MOV      r0,#0xf0000
0000c8  f7fffffe          BL       fmc_bank0_ready_wait
0000cc  4604              MOV      r4,r0
;;;211                /* reset the PER bit */
;;;212                FMC_CTL0 &= ~FMC_CTL0_PER;
0000ce  4806              LDR      r0,|L20.232|
0000d0  6900              LDR      r0,[r0,#0x10]
0000d2  f0200002          BIC      r0,r0,#2
0000d6  4904              LDR      r1,|L20.232|
0000d8  6108              STR      r0,[r1,#0x10]
                  |L20.218|
;;;213            }
;;;214        }
;;;215        /* return the FMC state */
;;;216        return fmc_state;
0000da  4620              MOV      r0,r4
;;;217    }
0000dc  bd30              POP      {r4,r5,pc}
;;;218    
                          ENDP

0000de  0000              DCW      0x0000
                  |L20.224|
                          DCD      0x1ffff7e0
                  |L20.228|
                          DCD      0x0807ffff
                  |L20.232|
                          DCD      0x40022000

                          AREA ||i.fmc_unlock||, CODE, READONLY, ALIGN=2

                  fmc_unlock PROC
;;;65     */
;;;66     void fmc_unlock(void)
000000  480c              LDR      r0,|L21.52|
;;;67     {
;;;68         if((RESET != (FMC_CTL0 & FMC_CTL0_LK))){
000002  6900              LDR      r0,[r0,#0x10]
000004  f0000080          AND      r0,r0,#0x80
000008  b120              CBZ      r0,|L21.20|
;;;69             /* write the FMC unlock key */
;;;70             FMC_KEY0 = UNLOCK_KEY0;
00000a  480b              LDR      r0,|L21.56|
00000c  4909              LDR      r1,|L21.52|
00000e  6048              STR      r0,[r1,#4]
;;;71             FMC_KEY0 = UNLOCK_KEY1;
000010  480a              LDR      r0,|L21.60|
000012  6048              STR      r0,[r1,#4]
                  |L21.20|
;;;72         }
;;;73     
;;;74         if(FMC_BANK0_SIZE < FMC_SIZE){
000014  480a              LDR      r0,|L21.64|
000016  8800              LDRH     r0,[r0,#0]
000018  f5b07f00          CMP      r0,#0x200
00001c  d909              BLS      |L21.50|
;;;75             /* write the FMC unlock key */
;;;76             if(RESET != (FMC_CTL1 & FMC_CTL1_LK)){
00001e  4805              LDR      r0,|L21.52|
000020  6d00              LDR      r0,[r0,#0x50]
000022  f0000080          AND      r0,r0,#0x80
000026  b120              CBZ      r0,|L21.50|
;;;77                 FMC_KEY1 = UNLOCK_KEY0;
000028  4803              LDR      r0,|L21.56|
00002a  4902              LDR      r1,|L21.52|
00002c  6448              STR      r0,[r1,#0x44]
;;;78                 FMC_KEY1 = UNLOCK_KEY1;
00002e  4803              LDR      r0,|L21.60|
000030  6448              STR      r0,[r1,#0x44]
                  |L21.50|
;;;79             }
;;;80         }
;;;81     }
000032  4770              BX       lr
;;;82     
                          ENDP

                  |L21.52|
                          DCD      0x40022000
                  |L21.56|
                          DCD      0x45670123
                  |L21.60|
                          DCD      0xcdef89ab
                  |L21.64|
                          DCD      0x1ffff7e0

                          AREA ||i.fmc_word_program||, CODE, READONLY, ALIGN=2

                  fmc_word_program PROC
;;;323    */
;;;324    fmc_state_enum fmc_word_program(uint32_t address, uint32_t data)
000000  b570              PUSH     {r4-r6,lr}
;;;325    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;326        fmc_state_enum fmc_state = FMC_READY;
000006  2600              MOVS     r6,#0
;;;327        if(FMC_BANK0_SIZE < FMC_SIZE){
000008  482a              LDR      r0,|L22.180|
00000a  8800              LDRH     r0,[r0,#0]
00000c  f5b07f00          CMP      r0,#0x200
000010  d935              BLS      |L22.126|
;;;328            if(FMC_BANK0_END_ADDRESS > address){
000012  4829              LDR      r0,|L22.184|
000014  4284              CMP      r4,r0
000016  d219              BCS      |L22.76|
;;;329                fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT); 
000018  f44f2070          MOV      r0,#0xf0000
00001c  f7fffffe          BL       fmc_bank0_ready_wait
000020  4606              MOV      r6,r0
;;;330      
;;;331                if(FMC_READY == fmc_state){
000022  2e00              CMP      r6,#0
000024  d143              BNE      |L22.174|
;;;332                    /* set the PG bit to start program */
;;;333                    FMC_CTL0 |= FMC_CTL0_PG;
000026  4825              LDR      r0,|L22.188|
000028  6900              LDR      r0,[r0,#0x10]
00002a  f0400001          ORR      r0,r0,#1
00002e  4923              LDR      r1,|L22.188|
000030  6108              STR      r0,[r1,#0x10]
;;;334                    REG32(address) = data;
000032  6025              STR      r5,[r4,#0]
;;;335                    /* wait for the FMC ready */
;;;336                    fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT);
000034  f44f2070          MOV      r0,#0xf0000
000038  f7fffffe          BL       fmc_bank0_ready_wait
00003c  4606              MOV      r6,r0
;;;337                    /* reset the PG bit */
;;;338                    FMC_CTL0 &= ~FMC_CTL0_PG;
00003e  481f              LDR      r0,|L22.188|
000040  6900              LDR      r0,[r0,#0x10]
000042  f0200001          BIC      r0,r0,#1
000046  491d              LDR      r1,|L22.188|
000048  6108              STR      r0,[r1,#0x10]
00004a  e030              B        |L22.174|
                  |L22.76|
;;;339                }
;;;340            }else{
;;;341                fmc_state = fmc_bank1_ready_wait(FMC_TIMEOUT_COUNT); 
00004c  f44f2070          MOV      r0,#0xf0000
000050  f7fffffe          BL       fmc_bank1_ready_wait
000054  4606              MOV      r6,r0
;;;342      
;;;343                if(FMC_READY == fmc_state){
000056  bb56              CBNZ     r6,|L22.174|
;;;344                    /* set the PG bit to start program */
;;;345                    FMC_CTL1 |= FMC_CTL1_PG;
000058  4818              LDR      r0,|L22.188|
00005a  6d00              LDR      r0,[r0,#0x50]
00005c  f0400001          ORR      r0,r0,#1
000060  4916              LDR      r1,|L22.188|
000062  6508              STR      r0,[r1,#0x50]
;;;346                    REG32(address) = data;
000064  6025              STR      r5,[r4,#0]
;;;347                    /* wait for the FMC ready */
;;;348                    fmc_state = fmc_bank1_ready_wait(FMC_TIMEOUT_COUNT);
000066  f44f2070          MOV      r0,#0xf0000
00006a  f7fffffe          BL       fmc_bank1_ready_wait
00006e  4606              MOV      r6,r0
;;;349                    /* reset the PG bit */
;;;350                    FMC_CTL1 &= ~FMC_CTL1_PG;
000070  4812              LDR      r0,|L22.188|
000072  6d00              LDR      r0,[r0,#0x50]
000074  f0200001          BIC      r0,r0,#1
000078  4910              LDR      r1,|L22.188|
00007a  6508              STR      r0,[r1,#0x50]
00007c  e017              B        |L22.174|
                  |L22.126|
;;;351                }
;;;352            }
;;;353        }else{
;;;354            fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT);
00007e  f44f2070          MOV      r0,#0xf0000
000082  f7fffffe          BL       fmc_bank0_ready_wait
000086  4606              MOV      r6,r0
;;;355      
;;;356            if(FMC_READY == fmc_state){
000088  b98e              CBNZ     r6,|L22.174|
;;;357                /* set the PG bit to start program */
;;;358                FMC_CTL0 |= FMC_CTL0_PG;
00008a  480c              LDR      r0,|L22.188|
00008c  6900              LDR      r0,[r0,#0x10]
00008e  f0400001          ORR      r0,r0,#1
000092  490a              LDR      r1,|L22.188|
000094  6108              STR      r0,[r1,#0x10]
;;;359                REG32(address) = data;
000096  6025              STR      r5,[r4,#0]
;;;360                /* wait for the FMC ready */
;;;361                fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT);
000098  f44f2070          MOV      r0,#0xf0000
00009c  f7fffffe          BL       fmc_bank0_ready_wait
0000a0  4606              MOV      r6,r0
;;;362                /* reset the PG bit */
;;;363                FMC_CTL0 &= ~FMC_CTL0_PG;
0000a2  4806              LDR      r0,|L22.188|
0000a4  6900              LDR      r0,[r0,#0x10]
0000a6  f0200001          BIC      r0,r0,#1
0000aa  4904              LDR      r1,|L22.188|
0000ac  6108              STR      r0,[r1,#0x10]
                  |L22.174|
;;;364            } 
;;;365        }
;;;366        /* return the FMC state */
;;;367        return fmc_state;
0000ae  4630              MOV      r0,r6
;;;368    }
0000b0  bd70              POP      {r4-r6,pc}
;;;369    
                          ENDP

0000b2  0000              DCW      0x0000
                  |L22.180|
                          DCD      0x1ffff7e0
                  |L22.184|
                          DCD      0x0807ffff
                  |L22.188|
                          DCD      0x40022000

                          AREA ||i.fmc_wscnt_set||, CODE, READONLY, ALIGN=2

                  fmc_wscnt_set PROC
;;;49     */
;;;50     void fmc_wscnt_set(uint32_t wscnt)
000000  4a04              LDR      r2,|L23.20|
;;;51     {
;;;52         uint32_t reg;
;;;53         
;;;54         reg = FMC_WS;
000002  6811              LDR      r1,[r2,#0]
;;;55         /* set the wait state counter value */
;;;56         reg &= ~FMC_WS_WSCNT;
000004  f0210107          BIC      r1,r1,#7
;;;57         FMC_WS = (reg | wscnt);
000008  ea410200          ORR      r2,r1,r0
00000c  4b01              LDR      r3,|L23.20|
00000e  601a              STR      r2,[r3,#0]
;;;58     }
000010  4770              BX       lr
;;;59     
                          ENDP

000012  0000              DCW      0x0000
                  |L23.20|
                          DCD      0x40022000

                          AREA ||i.ob_data_get||, CODE, READONLY, ALIGN=2

                  ob_data_get PROC
;;;702    */
;;;703    uint16_t ob_data_get(void)
000000  4802              LDR      r0,|L24.12|
;;;704    {
;;;705        return (uint16_t)(FMC_OBSTAT >> 10U);
000002  69c0              LDR      r0,[r0,#0x1c]
000004  f3c0208f          UBFX     r0,r0,#10,#16
;;;706    }
000008  4770              BX       lr
;;;707    
                          ENDP

00000a  0000              DCW      0x0000
                  |L24.12|
                          DCD      0x40022000

                          AREA ||i.ob_data_program||, CODE, READONLY, ALIGN=2

                  ob_data_program PROC
;;;663    */
;;;664    fmc_state_enum ob_data_program(uint32_t address, uint8_t data)
000000  b570              PUSH     {r4-r6,lr}
;;;665    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;666        fmc_state_enum fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT);
000006  f44f2070          MOV      r0,#0xf0000
00000a  f7fffffe          BL       fmc_bank0_ready_wait
00000e  4604              MOV      r4,r0
;;;667    
;;;668        if(FMC_READY == fmc_state){
000010  b99c              CBNZ     r4,|L25.58|
;;;669            /* set the OBPG bit */
;;;670            FMC_CTL0 |= FMC_CTL0_OBPG; 
000012  480b              LDR      r0,|L25.64|
000014  6900              LDR      r0,[r0,#0x10]
000016  f0400010          ORR      r0,r0,#0x10
00001a  4909              LDR      r1,|L25.64|
00001c  6108              STR      r0,[r1,#0x10]
;;;671            REG16(address) = data;
00001e  802e              STRH     r6,[r5,#0]
;;;672        
;;;673            /* wait for the FMC ready */
;;;674            fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT);
000020  f44f2070          MOV      r0,#0xf0000
000024  f7fffffe          BL       fmc_bank0_ready_wait
000028  4604              MOV      r4,r0
;;;675        
;;;676            if(FMC_TOERR != fmc_state){
00002a  2c04              CMP      r4,#4
00002c  d005              BEQ      |L25.58|
;;;677                /* reset the OBPG bit */
;;;678                FMC_CTL0 &= ~FMC_CTL0_OBPG;
00002e  4804              LDR      r0,|L25.64|
000030  6900              LDR      r0,[r0,#0x10]
000032  f0200010          BIC      r0,r0,#0x10
000036  4902              LDR      r1,|L25.64|
000038  6108              STR      r0,[r1,#0x10]
                  |L25.58|
;;;679            }
;;;680        }
;;;681        /* return the FMC state */
;;;682        return fmc_state;
00003a  4620              MOV      r0,r4
;;;683    }
00003c  bd70              POP      {r4-r6,pc}
;;;684    
                          ENDP

00003e  0000              DCW      0x0000
                  |L25.64|
                          DCD      0x40022000

                          AREA ||i.ob_erase||, CODE, READONLY, ALIGN=2

                  ob_erase PROC
;;;460    */
;;;461    fmc_state_enum ob_erase(void)
000000  b530              PUSH     {r4,r5,lr}
;;;462    {
;;;463        uint16_t temp_spc = FMC_NSPC;
000002  25a5              MOVS     r5,#0xa5
;;;464    
;;;465        fmc_state_enum fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT);
000004  f44f2070          MOV      r0,#0xf0000
000008  f7fffffe          BL       fmc_bank0_ready_wait
00000c  4604              MOV      r4,r0
;;;466    
;;;467        /* check the option byte security protection value */
;;;468        if(RESET != ob_spc_get()){
00000e  f7fffffe          BL       ob_spc_get
000012  b100              CBZ      r0,|L26.22|
;;;469            temp_spc = FMC_USPC;  
000014  25bb              MOVS     r5,#0xbb
                  |L26.22|
;;;470        }
;;;471    
;;;472        if(FMC_READY == fmc_state){
000016  bb54              CBNZ     r4,|L26.110|
;;;473    
;;;474            /* start erase the option byte */
;;;475            FMC_CTL0 |= FMC_CTL0_OBER;
000018  481a              LDR      r0,|L26.132|
00001a  6900              LDR      r0,[r0,#0x10]
00001c  f0400020          ORR      r0,r0,#0x20
000020  4918              LDR      r1,|L26.132|
000022  6108              STR      r0,[r1,#0x10]
;;;476            FMC_CTL0 |= FMC_CTL0_START;
000024  4608              MOV      r0,r1
000026  6900              LDR      r0,[r0,#0x10]
000028  f0400040          ORR      r0,r0,#0x40
00002c  6108              STR      r0,[r1,#0x10]
;;;477    
;;;478            /* wait for the FMC ready */
;;;479            fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT);
00002e  f44f2070          MOV      r0,#0xf0000
000032  f7fffffe          BL       fmc_bank0_ready_wait
000036  4604              MOV      r4,r0
;;;480        
;;;481            if(FMC_READY == fmc_state){
000038  b9d4              CBNZ     r4,|L26.112|
;;;482                /* reset the OBER bit */
;;;483                FMC_CTL0 &= ~FMC_CTL0_OBER;
00003a  4812              LDR      r0,|L26.132|
00003c  6900              LDR      r0,[r0,#0x10]
00003e  f0200020          BIC      r0,r0,#0x20
000042  4910              LDR      r1,|L26.132|
000044  6108              STR      r0,[r1,#0x10]
;;;484                /* set the OBPG bit */
;;;485                FMC_CTL0 |= FMC_CTL0_OBPG;
000046  4608              MOV      r0,r1
000048  6900              LDR      r0,[r0,#0x10]
00004a  f0400010          ORR      r0,r0,#0x10
00004e  6108              STR      r0,[r1,#0x10]
;;;486                /* no security protection */
;;;487                OB_SPC = (uint16_t)temp_spc; 
000050  480d              LDR      r0,|L26.136|
000052  8005              STRH     r5,[r0,#0]
;;;488                /* wait for the FMC ready */
;;;489                fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT); 
000054  f44f2070          MOV      r0,#0xf0000
000058  f7fffffe          BL       fmc_bank0_ready_wait
00005c  4604              MOV      r4,r0
;;;490                if(FMC_TOERR != fmc_state){
00005e  2c04              CMP      r4,#4
000060  d00e              BEQ      |L26.128|
;;;491                    /* reset the OBPG bit */
;;;492                    FMC_CTL0 &= ~FMC_CTL0_OBPG;
000062  4808              LDR      r0,|L26.132|
000064  6900              LDR      r0,[r0,#0x10]
000066  f0200010          BIC      r0,r0,#0x10
00006a  4906              LDR      r1,|L26.132|
00006c  6108              STR      r0,[r1,#0x10]
                  |L26.110|
00006e  e007              B        |L26.128|
                  |L26.112|
;;;493                }
;;;494            }else{
;;;495                if(FMC_TOERR != fmc_state){
000070  2c04              CMP      r4,#4
000072  d005              BEQ      |L26.128|
;;;496                    /* reset the OBPG bit */
;;;497                    FMC_CTL0 &= ~FMC_CTL0_OBPG;
000074  4803              LDR      r0,|L26.132|
000076  6900              LDR      r0,[r0,#0x10]
000078  f0200010          BIC      r0,r0,#0x10
00007c  4901              LDR      r1,|L26.132|
00007e  6108              STR      r0,[r1,#0x10]
                  |L26.128|
;;;498                }
;;;499            }
;;;500        }
;;;501        /* return the FMC state */
;;;502        return fmc_state;
000080  4620              MOV      r0,r4
;;;503    }
000082  bd30              POP      {r4,r5,pc}
;;;504    
                          ENDP

                  |L26.132|
                          DCD      0x40022000
                  |L26.136|
                          DCD      0x1ffff800

                          AREA ||i.ob_lock||, CODE, READONLY, ALIGN=2

                  ob_lock PROC
;;;447    */
;;;448    void ob_lock(void)
000000  4803              LDR      r0,|L27.16|
;;;449    {
;;;450        /* reset the OBWEN bit */
;;;451        FMC_CTL0 &= ~FMC_CTL0_OBWEN;
000002  6900              LDR      r0,[r0,#0x10]
000004  f4207000          BIC      r0,r0,#0x200
000008  4901              LDR      r1,|L27.16|
00000a  6108              STR      r0,[r1,#0x10]
;;;452    }
00000c  4770              BX       lr
;;;453    
                          ENDP

00000e  0000              DCW      0x0000
                  |L27.16|
                          DCD      0x40022000

                          AREA ||i.ob_security_protection_config||, CODE, READONLY, ALIGN=2

                  ob_security_protection_config PROC
;;;574    */
;;;575    fmc_state_enum ob_security_protection_config(uint8_t ob_spc)
000000  b530              PUSH     {r4,r5,lr}
;;;576    {
000002  4605              MOV      r5,r0
;;;577        fmc_state_enum fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT);
000004  f44f2070          MOV      r0,#0xf0000
000008  f7fffffe          BL       fmc_bank0_ready_wait
00000c  4604              MOV      r4,r0
;;;578    
;;;579        if(FMC_READY == fmc_state){
00000e  bb54              CBNZ     r4,|L28.102|
;;;580            FMC_CTL0 |= FMC_CTL0_OBER;
000010  481a              LDR      r0,|L28.124|
000012  6900              LDR      r0,[r0,#0x10]
000014  f0400020          ORR      r0,r0,#0x20
000018  4918              LDR      r1,|L28.124|
00001a  6108              STR      r0,[r1,#0x10]
;;;581            FMC_CTL0 |= FMC_CTL0_START;
00001c  4608              MOV      r0,r1
00001e  6900              LDR      r0,[r0,#0x10]
000020  f0400040          ORR      r0,r0,#0x40
000024  6108              STR      r0,[r1,#0x10]
;;;582        
;;;583            /* wait for the FMC ready */
;;;584            fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT);
000026  f44f2070          MOV      r0,#0xf0000
00002a  f7fffffe          BL       fmc_bank0_ready_wait
00002e  4604              MOV      r4,r0
;;;585        
;;;586            if(FMC_READY == fmc_state){
000030  b9d4              CBNZ     r4,|L28.104|
;;;587                /* reset the OBER bit */
;;;588                FMC_CTL0 &= ~FMC_CTL0_OBER;
000032  4812              LDR      r0,|L28.124|
000034  6900              LDR      r0,[r0,#0x10]
000036  f0200020          BIC      r0,r0,#0x20
00003a  4910              LDR      r1,|L28.124|
00003c  6108              STR      r0,[r1,#0x10]
;;;589          
;;;590                /* start the option byte program */
;;;591                FMC_CTL0 |= FMC_CTL0_OBPG;
00003e  4608              MOV      r0,r1
000040  6900              LDR      r0,[r0,#0x10]
000042  f0400010          ORR      r0,r0,#0x10
000046  6108              STR      r0,[r1,#0x10]
;;;592           
;;;593                OB_SPC = (uint16_t)ob_spc;
000048  480d              LDR      r0,|L28.128|
00004a  8005              STRH     r5,[r0,#0]
;;;594    
;;;595                /* wait for the FMC ready */
;;;596                fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT); 
00004c  f44f2070          MOV      r0,#0xf0000
000050  f7fffffe          BL       fmc_bank0_ready_wait
000054  4604              MOV      r4,r0
;;;597        
;;;598                if(FMC_TOERR != fmc_state){
000056  2c04              CMP      r4,#4
000058  d00e              BEQ      |L28.120|
;;;599                    /* reset the OBPG bit */
;;;600                    FMC_CTL0 &= ~FMC_CTL0_OBPG;
00005a  4808              LDR      r0,|L28.124|
00005c  6900              LDR      r0,[r0,#0x10]
00005e  f0200010          BIC      r0,r0,#0x10
000062  4906              LDR      r1,|L28.124|
000064  6108              STR      r0,[r1,#0x10]
                  |L28.102|
000066  e007              B        |L28.120|
                  |L28.104|
;;;601                }
;;;602            }else{
;;;603                if(FMC_TOERR != fmc_state){
000068  2c04              CMP      r4,#4
00006a  d005              BEQ      |L28.120|
;;;604                    /* reset the OBER bit */
;;;605                    FMC_CTL0 &= ~FMC_CTL0_OBER;
00006c  4803              LDR      r0,|L28.124|
00006e  6900              LDR      r0,[r0,#0x10]
000070  f0200020          BIC      r0,r0,#0x20
000074  4901              LDR      r1,|L28.124|
000076  6108              STR      r0,[r1,#0x10]
                  |L28.120|
;;;606                }
;;;607            }
;;;608        }
;;;609        /* return the FMC state */
;;;610        return fmc_state;
000078  4620              MOV      r0,r4
;;;611    }
00007a  bd30              POP      {r4,r5,pc}
;;;612    
                          ENDP

                  |L28.124|
                          DCD      0x40022000
                  |L28.128|
                          DCD      0x1ffff800

                          AREA ||i.ob_spc_get||, CODE, READONLY, ALIGN=2

                  ob_spc_get PROC
;;;725    */
;;;726    FlagStatus ob_spc_get(void)
000000  2000              MOVS     r0,#0
;;;727    {
;;;728        FlagStatus spc_state = RESET;
;;;729    
;;;730        if(RESET != (FMC_OBSTAT & FMC_OBSTAT_SPC)){
000002  4904              LDR      r1,|L29.20|
000004  69c9              LDR      r1,[r1,#0x1c]
000006  f0010102          AND      r1,r1,#2
00000a  b109              CBZ      r1,|L29.16|
;;;731            spc_state = SET;
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L29.18|
                  |L29.16|
;;;732        }else{
;;;733            spc_state = RESET;
000010  2000              MOVS     r0,#0
                  |L29.18|
;;;734        }
;;;735        return spc_state;
;;;736    }
000012  4770              BX       lr
;;;737    
                          ENDP

                  |L29.20|
                          DCD      0x40022000

                          AREA ||i.ob_unlock||, CODE, READONLY, ALIGN=2

                  ob_unlock PROC
;;;428    */
;;;429    void ob_unlock(void)
000000  4808              LDR      r0,|L30.36|
;;;430    {
;;;431        if(RESET == (FMC_CTL0 & FMC_CTL0_OBWEN)){
000002  6900              LDR      r0,[r0,#0x10]
000004  f4007000          AND      r0,r0,#0x200
000008  b920              CBNZ     r0,|L30.20|
;;;432            /* write the FMC key */
;;;433            FMC_OBKEY = UNLOCK_KEY0;
00000a  4807              LDR      r0,|L30.40|
00000c  4905              LDR      r1,|L30.36|
00000e  6088              STR      r0,[r1,#8]
;;;434            FMC_OBKEY = UNLOCK_KEY1;
000010  4806              LDR      r0,|L30.44|
000012  6088              STR      r0,[r1,#8]
                  |L30.20|
;;;435        }
;;;436    
;;;437        /* wait until OBWEN bit is set by hardware */
;;;438        while(RESET == (FMC_CTL0 & FMC_CTL0_OBWEN)){
000014  bf00              NOP      
                  |L30.22|
000016  4803              LDR      r0,|L30.36|
000018  6900              LDR      r0,[r0,#0x10]
00001a  f4007000          AND      r0,r0,#0x200
00001e  2800              CMP      r0,#0
000020  d0f9              BEQ      |L30.22|
;;;439        }
;;;440    }
000022  4770              BX       lr
;;;441    
                          ENDP

                  |L30.36|
                          DCD      0x40022000
                  |L30.40|
                          DCD      0x45670123
                  |L30.44|
                          DCD      0xcdef89ab

                          AREA ||i.ob_user_get||, CODE, READONLY, ALIGN=2

                  ob_user_get PROC
;;;690    */
;;;691    uint8_t ob_user_get(void)
000000  4802              LDR      r0,|L31.12|
;;;692    {
;;;693        /* return the FMC user option byte value */
;;;694        return (uint8_t)(FMC_OBSTAT >> 2U);
000002  69c0              LDR      r0,[r0,#0x1c]
000004  f3c00087          UBFX     r0,r0,#2,#8
;;;695    }
000008  4770              BX       lr
;;;696    
                          ENDP

00000a  0000              DCW      0x0000
                  |L31.12|
                          DCD      0x40022000

                          AREA ||i.ob_user_write||, CODE, READONLY, ALIGN=2

                  ob_user_write PROC
;;;629    */
;;;630    fmc_state_enum ob_user_write(uint8_t ob_fwdgt, uint8_t ob_deepsleep, uint8_t ob_stdby, uint8_t ob_boot)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;631    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;632        fmc_state_enum fmc_state = FMC_READY;
00000c  2400              MOVS     r4,#0
;;;633        uint8_t temp;
;;;634    
;;;635        /* wait for the FMC ready */
;;;636        fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT);
00000e  f44f2070          MOV      r0,#0xf0000
000012  f7fffffe          BL       fmc_bank0_ready_wait
000016  4604              MOV      r4,r0
;;;637      
;;;638        if(FMC_READY == fmc_state){
000018  b9dc              CBNZ     r4,|L32.82|
;;;639            /* set the OBPG bit*/
;;;640            FMC_CTL0 |= FMC_CTL0_OBPG; 
00001a  480f              LDR      r0,|L32.88|
00001c  6900              LDR      r0,[r0,#0x10]
00001e  f0400010          ORR      r0,r0,#0x10
000022  490d              LDR      r1,|L32.88|
000024  6108              STR      r0,[r1,#0x10]
;;;641    
;;;642            temp = ((uint8_t)((uint8_t)((uint8_t)(ob_boot | ob_fwdgt) | ob_deepsleep) | ob_stdby) | OB_USER_MASK);
000026  ea480005          ORR      r0,r8,r5
00002a  4330              ORRS     r0,r0,r6
00002c  4338              ORRS     r0,r0,r7
00002e  f04009f0          ORR      r9,r0,#0xf0
;;;643            OB_USER = (uint16_t)temp;
000032  480a              LDR      r0,|L32.92|
000034  f8a09000          STRH     r9,[r0,#0]
;;;644        
;;;645            /* wait for the FMC ready */
;;;646            fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT);
000038  f44f2070          MOV      r0,#0xf0000
00003c  f7fffffe          BL       fmc_bank0_ready_wait
000040  4604              MOV      r4,r0
;;;647    
;;;648            if(FMC_TOERR != fmc_state){
000042  2c04              CMP      r4,#4
000044  d005              BEQ      |L32.82|
;;;649                /* reset the OBPG bit */
;;;650                FMC_CTL0 &= ~FMC_CTL0_OBPG;
000046  4804              LDR      r0,|L32.88|
000048  6900              LDR      r0,[r0,#0x10]
00004a  f0200010          BIC      r0,r0,#0x10
00004e  4902              LDR      r1,|L32.88|
000050  6108              STR      r0,[r1,#0x10]
                  |L32.82|
;;;651            }
;;;652        }
;;;653        /* return the FMC state */
;;;654        return fmc_state;
000052  4620              MOV      r0,r4
;;;655    }
000054  e8bd83f0          POP      {r4-r9,pc}
;;;656    
                          ENDP

                  |L32.88|
                          DCD      0x40022000
                  |L32.92|
                          DCD      0x1ffff802

                          AREA ||i.ob_write_protection_enable||, CODE, READONLY, ALIGN=2

                  ob_write_protection_enable PROC
;;;515    */
;;;516    fmc_state_enum ob_write_protection_enable(uint32_t ob_wp)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;517    {
000004  4604              MOV      r4,r0
;;;518        uint16_t temp_wp0, temp_wp1, temp_wp2, temp_wp3;
;;;519    
;;;520        fmc_state_enum fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT);
000006  f44f2070          MOV      r0,#0xf0000
00000a  f7fffffe          BL       fmc_bank0_ready_wait
00000e  4605              MOV      r5,r0
;;;521    
;;;522        ob_wp = (uint32_t)(~ob_wp);
000010  43e4              MVNS     r4,r4
;;;523        temp_wp0 = (uint16_t)(ob_wp & OB_WP0_WP0);
000012  b2e6              UXTB     r6,r4
;;;524        temp_wp1 = (uint16_t)((ob_wp & OB_WP1_WP1) >> 8U);
000014  f3c42707          UBFX     r7,r4,#8,#8
;;;525        temp_wp2 = (uint16_t)((ob_wp & OB_WP2_WP2) >> 16U);
000018  f3c44807          UBFX     r8,r4,#16,#8
;;;526        temp_wp3 = (uint16_t)((ob_wp & OB_WP3_WP3) >> 24U);
00001c  ea4f6914          LSR      r9,r4,#24
;;;527    
;;;528        if(FMC_READY == fmc_state){
000020  bbdd              CBNZ     r5,|L33.154|
;;;529        
;;;530            /* set the OBPG bit*/
;;;531            FMC_CTL0 |= FMC_CTL0_OBPG;
000022  481f              LDR      r0,|L33.160|
000024  6900              LDR      r0,[r0,#0x10]
000026  f0400010          ORR      r0,r0,#0x10
00002a  491d              LDR      r1,|L33.160|
00002c  6108              STR      r0,[r1,#0x10]
;;;532    
;;;533            if(0xFFU != temp_wp0){
00002e  2eff              CMP      r6,#0xff
000030  d006              BEQ      |L33.64|
;;;534                OB_WP0 = temp_wp0;
000032  481c              LDR      r0,|L33.164|
000034  8006              STRH     r6,[r0,#0]
;;;535          
;;;536                /* wait for the FMC ready */
;;;537                fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT);
000036  f44f2070          MOV      r0,#0xf0000
00003a  f7fffffe          BL       fmc_bank0_ready_wait
00003e  4605              MOV      r5,r0
                  |L33.64|
;;;538            }
;;;539            if((FMC_READY == fmc_state) && (0xFFU != temp_wp1)){
000040  b94d              CBNZ     r5,|L33.86|
000042  2fff              CMP      r7,#0xff
000044  d007              BEQ      |L33.86|
;;;540                OB_WP1 = temp_wp1;
000046  4817              LDR      r0,|L33.164|
000048  1c80              ADDS     r0,r0,#2
00004a  8007              STRH     r7,[r0,#0]
;;;541          
;;;542                /* wait for the FMC ready */
;;;543                fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT);
00004c  f44f2070          MOV      r0,#0xf0000
000050  f7fffffe          BL       fmc_bank0_ready_wait
000054  4605              MOV      r5,r0
                  |L33.86|
;;;544            }
;;;545            if((FMC_READY == fmc_state) && (0xFFU != temp_wp2)){
000056  b95d              CBNZ     r5,|L33.112|
000058  f1b80fff          CMP      r8,#0xff
00005c  d008              BEQ      |L33.112|
;;;546                OB_WP2 = temp_wp2;
00005e  4811              LDR      r0,|L33.164|
000060  1d00              ADDS     r0,r0,#4
000062  f8a08000          STRH     r8,[r0,#0]
;;;547          
;;;548                /* wait for the FMC ready */
;;;549                fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT);
000066  f44f2070          MOV      r0,#0xf0000
00006a  f7fffffe          BL       fmc_bank0_ready_wait
00006e  4605              MOV      r5,r0
                  |L33.112|
;;;550            }
;;;551            if((FMC_READY == fmc_state) && (0xFFU != temp_wp3)){
000070  b95d              CBNZ     r5,|L33.138|
000072  f1b90fff          CMP      r9,#0xff
000076  d008              BEQ      |L33.138|
;;;552                OB_WP3 = temp_wp3;
000078  480a              LDR      r0,|L33.164|
00007a  1d80              ADDS     r0,r0,#6
00007c  f8a09000          STRH     r9,[r0,#0]
;;;553          
;;;554                /* wait for the FMC ready */
;;;555                fmc_state = fmc_bank0_ready_wait(FMC_TIMEOUT_COUNT);
000080  f44f2070          MOV      r0,#0xf0000
000084  f7fffffe          BL       fmc_bank0_ready_wait
000088  4605              MOV      r5,r0
                  |L33.138|
;;;556            }
;;;557            if(FMC_TOERR != fmc_state){
00008a  2d04              CMP      r5,#4
00008c  d005              BEQ      |L33.154|
;;;558                /* reset the OBPG bit */
;;;559                FMC_CTL0 &= ~FMC_CTL0_OBPG;
00008e  4804              LDR      r0,|L33.160|
000090  6900              LDR      r0,[r0,#0x10]
000092  f0200010          BIC      r0,r0,#0x10
000096  4902              LDR      r1,|L33.160|
000098  6108              STR      r0,[r1,#0x10]
                  |L33.154|
;;;560            }
;;;561        } 
;;;562        /* return the FMC state */
;;;563        return fmc_state;
00009a  4628              MOV      r0,r5
;;;564    }
00009c  e8bd83f0          POP      {r4-r9,pc}
;;;565    
                          ENDP

                  |L33.160|
                          DCD      0x40022000
                  |L33.164|
                          DCD      0x1ffff808

                          AREA ||i.ob_write_protection_get||, CODE, READONLY, ALIGN=2

                  ob_write_protection_get PROC
;;;713    */
;;;714    uint32_t ob_write_protection_get(void)
000000  4801              LDR      r0,|L34.8|
;;;715    {
;;;716        /* return the FMC write protection option byte value */
;;;717        return FMC_WP;
000002  6a00              LDR      r0,[r0,#0x20]
;;;718    }
000004  4770              BX       lr
;;;719    
                          ENDP

000006  0000              DCW      0x0000
                  |L34.8|
                          DCD      0x40022000

;*** Start embedded assembler ***

#line 1 "Libraries\\src\\gd32f10x_fmc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_gd32f10x_fmc_c_2e62a613____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___14_gd32f10x_fmc_c_2e62a613____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_gd32f10x_fmc_c_2e62a613____REVSH|
#line 128
|__asm___14_gd32f10x_fmc_c_2e62a613____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
