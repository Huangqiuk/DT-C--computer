; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\adc.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\adc.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -I.\User\qrencode -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.1\Device\Include -D__MICROLIB -D__UVISION_VERSION=534 -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\adc.crf User\adc.c]
                          THUMB

                          AREA ||i.ADC_AddDataToBuff||, CODE, READONLY, ALIGN=2

                  ADC_AddDataToBuff PROC
;;;581    // 向缓冲区中添加一个数据
;;;582    void ADC_AddDataToBuff(ADC_CHANNEL_E channel, uint16 data)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;583    {
;;;584    	uint8 i;
;;;585    	uint32 total;
;;;586    	uint16 min = 0xFFFF, max = 0;
000004  f64f72ff          MOV      r2,#0xffff
000008  2300              MOVS     r3,#0
;;;587    
;;;588    	// 用来切换有电流和无电流数据填充的标志
;;;589    	static BOOL noCurrentActionFlag = TRUE;
;;;590    	static BOOL currentActionFlag = TRUE;
;;;591    	
;;;592    	switch(channel)
;;;593    	{
;;;594    		// 电池通道
;;;595    		case ADC_CHANNEL_BATTERY:
;;;596    			if(500 <= PARAM_GetBatteryCurrent())// 有电流状态
;;;597    			{
;;;598    				if(currentActionFlag)
;;;599    				{
;;;600    					currentActionFlag = FALSE;
;;;601    					noCurrentActionFlag = TRUE;
;;;602    					PARAM_SetBatteryAdcBuffClearFlag(1);
;;;603    					PARAM_SetBatteryCurrentToNoneFlag(0);
;;;604    					adcCB.battery.index = 0;
;;;605    				}
;;;606    			}
;;;607    			else// 无电流状态
;;;608    			{
;;;609    				if(noCurrentActionFlag)
;;;610    				{
;;;611    					currentActionFlag = TRUE;
;;;612    					noCurrentActionFlag = FALSE;
;;;613    					PARAM_SetBatteryAdcBuffClearFlag(1);
;;;614    					PARAM_SetBatteryCurrentToNoneFlag(1);
;;;615    					adcCB.battery.index = 0;
;;;616    				}		
;;;617    			}
;;;618    			adcCB.battery.adcBuff[adcCB.battery.index++] = data;
;;;619    			adcCB.battery.index %= ADC_BATTERY_DETECTOR_BUFF_SIZE;
00000a  240a              MOVS     r4,#0xa
00000c  4d3d              LDR      r5,|L1.260|
00000e  2800              CMP      r0,#0                 ;592
000010  d027              BEQ      |L1.98|
000012  2801              CMP      r0,#1                 ;592
000014  d123              BNE      |L1.94|
;;;620    
;;;621    			// 有无电流的情况下，adcBuff填充满了才往下执行
;;;622    			if(PARAM_GetBatteryAdcBuffClearFlag())
;;;623    			{
;;;624    				if(adcCB.battery.index)
;;;625    				{
;;;626    					return;
;;;627    				}
;;;628    				else
;;;629    				{
;;;630    					PARAM_SetBatteryAdcBuffClearFlag(0);
;;;631    				}
;;;632    			}
;;;633    			
;;;634    			// 计算缓冲区的平均值
;;;635    			total = 0;
;;;636    			for(i=0; i<ADC_BATTERY_DETECTOR_BUFF_SIZE; i++)
;;;637    			{
;;;638    				// 更新最小值
;;;639    				if(adcCB.battery.adcBuff[i] < min)
;;;640    				{
;;;641    					min = adcCB.battery.adcBuff[i];
;;;642    				}
;;;643    
;;;644    				// 更新最大值
;;;645    				if(adcCB.battery.adcBuff[i] > max)
;;;646    				{
;;;647    					max = adcCB.battery.adcBuff[i];
;;;648    				}
;;;649    				
;;;650    				total += adcCB.battery.adcBuff[i];
;;;651    			}
;;;652    
;;;653    			// 去掉最大最小值
;;;654    			total -= min;
;;;655    			total -= max;
;;;656    
;;;657    			// 计算ADC平均值
;;;658    			adcCB.battery.adcAverage = total / (ADC_BATTERY_DETECTOR_BUFF_SIZE-2);
;;;659    
;;;660    			break;
;;;661    			
;;;662    		// 光敏通道
;;;663    		case ADC_CHANNEL_LIGHTSENSOR:
;;;664    			adcCB.photoSensor.adcBuff[adcCB.photoSensor.index++] = data;
000016  f8950038          LDRB     r0,[r5,#0x38]  ; adcCB
00001a  1c46              ADDS     r6,r0,#1
00001c  eb050040          ADD      r0,r5,r0,LSL #1
000020  f8856038          STRB     r6,[r5,#0x38]
000024  8481              STRH     r1,[r0,#0x24]
;;;665    			adcCB.photoSensor.index %= ADC_PHOTOSENSOR_DETECTOR_BUFF_SIZE;
000026  f8950038          LDRB     r0,[r5,#0x38]  ; adcCB
00002a  fbb0f1f4          UDIV     r1,r0,r4
00002e  fb040011          MLS      r0,r4,r1,r0
000032  f8850038          STRB     r0,[r5,#0x38]
;;;666    
;;;667    			// 计算缓冲区的平均值
;;;668    			total = 0;
000036  2400              MOVS     r4,#0
;;;669    			for(i=0; i<ADC_PHOTOSENSOR_DETECTOR_BUFF_SIZE; i++)
000038  2100              MOVS     r1,#0
                  |L1.58|
;;;670    			{
;;;671    				// 更新最小值
;;;672    				if(adcCB.photoSensor.adcBuff[i] < min)
00003a  eb050041          ADD      r0,r5,r1,LSL #1
00003e  8c80              LDRH     r0,[r0,#0x24]
000040  4290              CMP      r0,r2
000042  d200              BCS      |L1.70|
;;;673    				{
;;;674    					min = adcCB.photoSensor.adcBuff[i];
000044  4602              MOV      r2,r0
                  |L1.70|
;;;675    				}
;;;676    
;;;677    				// 更新最大值
;;;678    				if(adcCB.photoSensor.adcBuff[i] > max)
000046  4298              CMP      r0,r3
000048  d900              BLS      |L1.76|
;;;679    				{
;;;680    					max = adcCB.photoSensor.adcBuff[i];
00004a  4603              MOV      r3,r0
                  |L1.76|
;;;681    				}
;;;682    				
;;;683    				total += adcCB.photoSensor.adcBuff[i];
00004c  4404              ADD      r4,r4,r0
00004e  1c49              ADDS     r1,r1,#1              ;669
000050  b2c9              UXTB     r1,r1                 ;669
000052  290a              CMP      r1,#0xa               ;669
000054  d3f1              BCC      |L1.58|
;;;684    			}
;;;685    
;;;686    			// 去掉最大最小值
;;;687    			total -= min;
000056  1aa0              SUBS     r0,r4,r2
;;;688    			total -= max;
000058  1ac0              SUBS     r0,r0,r3
;;;689    
;;;690    			// 计算ADC平均值
;;;691    			adcCB.photoSensor.adcAverage = total / (ADC_PHOTOSENSOR_DETECTOR_BUFF_SIZE-2);
00005a  08c0              LSRS     r0,r0,#3
00005c  8768              STRH     r0,[r5,#0x3a]
                  |L1.94|
;;;692    			break;
;;;693    
;;;694    		// 非法通道
;;;695    		default:
;;;696    			break;
;;;697    	}
;;;698    }
00005e  e8bd81f0          POP      {r4-r8,pc}
                  |L1.98|
000062  4e29              LDR      r6,|L1.264|
000064  2001              MOVS     r0,#1                 ;583
000066  f8dfc0a4          LDR      r12,|L1.268|
00006a  f8b6816c          LDRH     r8,[r6,#0x16c]        ;596  ; paramCB
00006e  2700              MOVS     r7,#0                 ;598
000070  f5b87ffa          CMP      r8,#0x1f4             ;596
000074  d30e              BCC      |L1.148|
000076  f89c8001          LDRB     r8,[r12,#1]           ;598  ; currentActionFlag
00007a  f1b80f00          CMP      r8,#0                 ;598
00007e  d017              BEQ      |L1.176|
000080  f88c7001          STRB     r7,[r12,#1]           ;600
000084  f88c0000          STRB     r0,[r12,#0]           ;601
000088  f886016f          STRB     r0,[r6,#0x16f]        ;602
00008c  f8867170          STRB     r7,[r6,#0x170]        ;603
000090  762f              STRB     r7,[r5,#0x18]         ;604
000092  e00d              B        |L1.176|
                  |L1.148|
000094  f89c8000          LDRB     r8,[r12,#0]           ;609  ; noCurrentActionFlag
000098  f1b80f00          CMP      r8,#0                 ;609
00009c  d008              BEQ      |L1.176|
00009e  f88c0001          STRB     r0,[r12,#1]           ;611
0000a2  f88c7000          STRB     r7,[r12,#0]           ;612
0000a6  f886016f          STRB     r0,[r6,#0x16f]        ;613
0000aa  f8860170          STRB     r0,[r6,#0x170]        ;614
0000ae  762f              STRB     r7,[r5,#0x18]         ;615
                  |L1.176|
0000b0  7e28              LDRB     r0,[r5,#0x18]         ;618  ; adcCB
0000b2  f1000c01          ADD      r12,r0,#1             ;618
0000b6  eb050040          ADD      r0,r5,r0,LSL #1       ;618
0000ba  f885c018          STRB     r12,[r5,#0x18]        ;618
0000be  8081              STRH     r1,[r0,#4]            ;618
0000c0  7e28              LDRB     r0,[r5,#0x18]         ;619  ; adcCB
0000c2  fbb0f1f4          UDIV     r1,r0,r4              ;619
0000c6  fb040011          MLS      r0,r4,r1,r0           ;619
0000ca  7628              STRB     r0,[r5,#0x18]         ;619
0000cc  f896116f          LDRB     r1,[r6,#0x16f]        ;622  ; paramCB
0000d0  b119              CBZ      r1,|L1.218|
0000d2  2800              CMP      r0,#0                 ;624
0000d4  d1c3              BNE      |L1.94|
0000d6  f886716f          STRB     r7,[r6,#0x16f]        ;630
                  |L1.218|
0000da  2400              MOVS     r4,#0                 ;635
0000dc  2100              MOVS     r1,#0                 ;636
                  |L1.222|
0000de  eb050041          ADD      r0,r5,r1,LSL #1       ;639
0000e2  8880              LDRH     r0,[r0,#4]            ;639
0000e4  4290              CMP      r0,r2                 ;639
0000e6  d200              BCS      |L1.234|
0000e8  4602              MOV      r2,r0                 ;641
                  |L1.234|
0000ea  4298              CMP      r0,r3                 ;645
0000ec  d900              BLS      |L1.240|
0000ee  4603              MOV      r3,r0                 ;647
                  |L1.240|
0000f0  4404              ADD      r4,r4,r0              ;650
0000f2  1c49              ADDS     r1,r1,#1              ;636
0000f4  b2c9              UXTB     r1,r1                 ;636
0000f6  290a              CMP      r1,#0xa               ;636
0000f8  d3f1              BCC      |L1.222|
0000fa  1aa0              SUBS     r0,r4,r2              ;654
0000fc  1ac0              SUBS     r0,r0,r3              ;655
0000fe  08c0              LSRS     r0,r0,#3              ;658
000100  8368              STRH     r0,[r5,#0x1a]         ;658
000102  e7ac              B        |L1.94|
;;;699    
                          ENDP

                  |L1.260|
                          DCD      ||.bss||
                  |L1.264|
                          DCD      paramCB
                  |L1.268|
                          DCD      ||.data||

                          AREA ||i.ADC_BaseInit||, CODE, READONLY, ALIGN=1

                  ADC_BaseInit PROC
;;;269    // 初始化
;;;270    void ADC_BaseInit(void)
000000  b510              PUSH     {r4,lr}
;;;271    {
;;;272    	// ADC硬件初始化
;;;273    	ADC_HwInit();
000002  f7fffffe          BL       ADC_HwInit
;;;274    
;;;275    	// 初始化结构体
;;;276    	ADC_InitStruct();
000006  f7fffffe          BL       ADC_InitStruct
;;;277    
;;;278    	// 开始扫描
;;;279    	ADC_Start();
00000a  e8bd4010          POP      {r4,lr}
00000e  f7ffbffe          B.W      ADC_Start
;;;280    }
;;;281    
                          ENDP


                          AREA ||i.ADC_CALLBACK_SetScanRequest||, CODE, READONLY, ALIGN=2

                  ADC_CALLBACK_SetScanRequest PROC
;;;495    // 设置读取请求回调函数，由定时器调用
;;;496    void ADC_CALLBACK_SetScanRequest(uint32 param)
000000  4901              LDR      r1,|L3.8|
;;;497    {
;;;498    	adcCB.scanRequest = TRUE;
000002  2001              MOVS     r0,#1
000004  7008              STRB     r0,[r1,#0]
;;;499    }
000006  4770              BX       lr
;;;500    
                          ENDP

                  |L3.8|
                          DCD      ||.bss||

                          AREA ||i.ADC_DebounceTortoiseProcess||, CODE, READONLY, ALIGN=2

                  ADC_DebounceTortoiseProcess PROC
;;;746    
;;;747    BOOL ADC_DebounceTortoiseProcess(void)
000000  b530              PUSH     {r4,r5,lr}
;;;748    {
;;;749    	static uint16 tempDisplayCount = 0;
;;;750    	static uint8 countTemp;
;;;751    
;;;752    	// 有电流和无电流状态切换时，电量显示不更新
;;;753    	if(1 == PARAM_GetBatteryAdcBuffClearFlag())
000002  491e              LDR      r1,|L4.124|
000004  f891016f          LDRB     r0,[r1,#0x16f]  ; paramCB
000008  2801              CMP      r0,#1
00000a  d020              BEQ      |L4.78|
;;;754    	{
;;;755    		return FALSE;
;;;756    	}
;;;757    
;;;758    	// 有电流变为无电流时延时10s更新显示
;;;759    	if(1 == PARAM_GetBatteryCurrentToNoneFlag())
00000c  f8910170          LDRB     r0,[r1,#0x170]  ; paramCB
000010  2400              MOVS     r4,#0
;;;760    	{
;;;761    		countTemp++;
000012  4b1b              LDR      r3,|L4.128|
000014  2801              CMP      r0,#1                 ;759
000016  d01c              BEQ      |L4.82|
;;;762    		if(countTemp > ADC_ZERO_ELECTRIC_CONTINUED_TIME)
;;;763    		{
;;;764    			PARAM_SetBatteryCurrentToNoneFlag(0);
;;;765    		}
;;;766    		else
;;;767    		{
;;;768    			return FALSE;
;;;769    		}
;;;770    	}
;;;771    	else
;;;772    	{
;;;773    		countTemp = 0;
000018  70dc              STRB     r4,[r3,#3]
                  |L4.26|
;;;774    	}
;;;775    	
;;;776    	// 当显示值与实际值不相等的时候才进行处理
;;;777    	if(adcCB.battery.displayPercent != adcCB.battery.realtimePercent)
00001a  4d1a              LDR      r5,|L4.132|
00001c  f8950021          LDRB     r0,[r5,#0x21]  ; adcCB
000020  f8951020          LDRB     r1,[r5,#0x20]  ; adcCB
000024  4288              CMP      r0,r1
000026  d025              BEQ      |L4.116|
;;;778    	{
;;;779    		tempDisplayCount++;
000028  891a              LDRH     r2,[r3,#8]  ; tempDisplayCount
00002a  1c52              ADDS     r2,r2,#1
00002c  b292              UXTH     r2,r2
00002e  811a              STRH     r2,[r3,#8]
;;;780    		if(tempDisplayCount > 2)
000030  2a02              CMP      r2,#2
000032  d91d              BLS      |L4.112|
;;;781    		{
;;;782    			tempDisplayCount = 0;
000034  811c              STRH     r4,[r3,#8]
;;;783    			if(adcCB.battery.displayPercent < adcCB.battery.realtimePercent)
000036  4288              CMP      r0,r1
000038  d216              BCS      |L4.104|
;;;784    			{
;;;785    				adcCB.battery.displayPercent++;
00003a  1c40              ADDS     r0,r0,#1
00003c  b2c0              UXTB     r0,r0
00003e  f8850021          STRB     r0,[r5,#0x21]
;;;786    				if(adcCB.battery.displayPercent > 100)
000042  2864              CMP      r0,#0x64
000044  d914              BLS      |L4.112|
;;;787    				{
;;;788    					adcCB.battery.displayPercent = 100;
000046  2064              MOVS     r0,#0x64
000048  f8850021          STRB     r0,[r5,#0x21]
00004c  e010              B        |L4.112|
                  |L4.78|
00004e  2000              MOVS     r0,#0                 ;755
;;;789    				}
;;;790    			}
;;;791    			// 显示百分比 ＞ 实时百分比，则显示百分比降低一个百分点
;;;792    			else if(adcCB.battery.displayPercent > adcCB.battery.realtimePercent)
;;;793    			{
;;;794    				if(adcCB.battery.displayPercent > 0)
;;;795    				{
;;;796    					adcCB.battery.displayPercent--;
;;;797    				}
;;;798    			}
;;;799    		}
;;;800    	}
;;;801    	else
;;;802    	{
;;;803    		tempDisplayCount = 0;
;;;804    		return FALSE;
;;;805    	}
;;;806    	
;;;807    	return TRUE;
;;;808    
;;;809    }
000050  bd30              POP      {r4,r5,pc}
                  |L4.82|
000052  78d8              LDRB     r0,[r3,#3]            ;761  ; countTemp
000054  1c40              ADDS     r0,r0,#1              ;761
000056  b2c0              UXTB     r0,r0                 ;761
000058  70d8              STRB     r0,[r3,#3]            ;761
00005a  2803              CMP      r0,#3                 ;762
00005c  d902              BLS      |L4.100|
00005e  f8814170          STRB     r4,[r1,#0x170]        ;764
000062  e7da              B        |L4.26|
                  |L4.100|
000064  2000              MOVS     r0,#0                 ;768
000066  bd30              POP      {r4,r5,pc}
                  |L4.104|
000068  b110              CBZ      r0,|L4.112|
00006a  1e40              SUBS     r0,r0,#1              ;796
00006c  f8850021          STRB     r0,[r5,#0x21]         ;796
                  |L4.112|
000070  2001              MOVS     r0,#1                 ;807
000072  bd30              POP      {r4,r5,pc}
                  |L4.116|
000074  811c              STRH     r4,[r3,#8]            ;803
000076  2000              MOVS     r0,#0                 ;804
000078  bd30              POP      {r4,r5,pc}
;;;810    
                          ENDP

00007a  0000              DCW      0x0000
                  |L4.124|
                          DCD      paramCB
                  |L4.128|
                          DCD      ||.data||
                  |L4.132|
                          DCD      ||.bss||

                          AREA ||i.ADC_GetBatteryPercent||, CODE, READONLY, ALIGN=2

                  ADC_GetBatteryPercent PROC
;;;501    // 获取电池百分比
;;;502    uint8 ADC_GetBatteryPercent(uint32 param)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;503    {
000004  4605              MOV      r5,r0
;;;504    	uint8 i;
;;;505    	uint8 vLevel = 1;
000006  2001              MOVS     r0,#1
;;;506    //	uint16 spanVal;
;;;507    	uint8 percent;
;;;508    	float k = 0.0f, b = 0.0f;
;;;509    	float fPercent;
;;;510    
;;;511    	switch (PARAM_GetBatteryVoltageLevel())
000008  4936              LDR      r1,|L5.228|
00000a  f8911338          LDRB     r1,[r1,#0x338]  ; paramCB
00000e  2934              CMP      r1,#0x34
000010  d010              BEQ      |L5.52|
000012  dc06              BGT      |L5.34|
000014  2918              CMP      r1,#0x18
000016  d009              BEQ      |L5.44|
000018  2924              CMP      r1,#0x24
00001a  d010              BEQ      |L5.62|
00001c  2930              CMP      r1,#0x30
00001e  d10e              BNE      |L5.62|
000020  e006              B        |L5.48|
                  |L5.34|
000022  293c              CMP      r1,#0x3c
000024  d008              BEQ      |L5.56|
000026  2948              CMP      r1,#0x48
000028  d109              BNE      |L5.62|
00002a  e007              B        |L5.60|
                  |L5.44|
;;;512    	{
;;;513    		case 24:
;;;514    			vLevel = 0;
00002c  2000              MOVS     r0,#0
;;;515    			break;
00002e  e006              B        |L5.62|
                  |L5.48|
;;;516    
;;;517    		case 36:
;;;518    			vLevel = 1;
;;;519    			break;
;;;520    
;;;521    		case 48:
;;;522    			vLevel = 2;
000030  2002              MOVS     r0,#2
;;;523    			break;
000032  e004              B        |L5.62|
                  |L5.52|
;;;524    
;;;525    		case 52:
;;;526    			vLevel = 3;
000034  2003              MOVS     r0,#3
;;;527    			break;
000036  e002              B        |L5.62|
                  |L5.56|
;;;528    
;;;529    		case 60:
;;;530    			vLevel = 4;
000038  2004              MOVS     r0,#4
;;;531    			break;
00003a  e000              B        |L5.62|
                  |L5.60|
;;;532    
;;;533    		case 72:
;;;534    			vLevel = 5;
00003c  2005              MOVS     r0,#5
                  |L5.62|
;;;535    			break;
;;;536    			
;;;537    		default:
;;;538    			vLevel = 1;
;;;539    			break;
;;;540    	}
;;;541    
;;;542    	// 在对应电压的电量里程碑中搜索，计算电池百分比
;;;543    	for (i = 0; i < BATTERY_PERCENT_GATE_SIZE; i++)
00003e  2400              MOVS     r4,#0
;;;544    	{
;;;545    		// 计算得到的百分比应能覆盖0%-100%
;;;546    		// 从100%开始搜索
;;;547    		if (param >= batteryPercentTable[vLevel][i])
000040  4929              LDR      r1,|L5.232|
000042  eb000040          ADD      r0,r0,r0,LSL #1
000046  eb011000          ADD      r0,r1,r0,LSL #4
                  |L5.74|
00004a  f8501024          LDR      r1,[r0,r4,LSL #2]
00004e  42a9              CMP      r1,r5
000050  d841              BHI      |L5.214|
;;;548    		{
;;;549    			if (0 == i)
000052  b3ec              CBZ      r4,|L5.208|
;;;550    			{
;;;551    				return 100;
;;;552    			}
;;;553    
;;;554    			// y = kx+b，首先计算k
;;;555    			k = (float)((batteryPercent[i-1] - batteryPercent[i])/100.0f) / (float)(batteryPercentTable[vLevel][i-1] - batteryPercentTable[vLevel][i]);
000054  1e61              SUBS     r1,r4,#1
000056  460f              MOV      r7,r1
000058  f8501021          LDR      r1,[r0,r1,LSL #2]
00005c  f8506024          LDR      r6,[r0,r4,LSL #2]
000060  1b88              SUBS     r0,r1,r6
000062  f7fffffe          BL       __aeabi_ui2f
000066  4681              MOV      r9,r0
000068  4820              LDR      r0,|L5.236|
00006a  f8301017          LDRH     r1,[r0,r7,LSL #1]
00006e  f8304014          LDRH     r4,[r0,r4,LSL #1]
000072  1b08              SUBS     r0,r1,r4
000074  f7fffffe          BL       __aeabi_i2f
000078  f8df8074          LDR      r8,|L5.240|
00007c  4641              MOV      r1,r8
00007e  f7fffffe          BL       __aeabi_fdiv
000082  4649              MOV      r1,r9
000084  f7fffffe          BL       __aeabi_fdiv
000088  4607              MOV      r7,r0
;;;556    			b = batteryPercent[i]/100.0f - k * batteryPercentTable[vLevel][i];
00008a  4630              MOV      r0,r6
00008c  f7fffffe          BL       __aeabi_ui2f
000090  4639              MOV      r1,r7
000092  f7fffffe          BL       __aeabi_fmul
000096  4606              MOV      r6,r0
000098  4620              MOV      r0,r4
00009a  f7fffffe          BL       __aeabi_ui2f
00009e  4641              MOV      r1,r8
0000a0  f7fffffe          BL       __aeabi_fdiv
0000a4  4631              MOV      r1,r6
0000a6  f7fffffe          BL       __aeabi_fsub
0000aa  4604              MOV      r4,r0
;;;557    			
;;;558    			// 两个级别之间的跨度
;;;559    			//spanVal = batteryPercentTable[vLevel][i-1] - batteryPercentTable[vLevel][i];
;;;560    
;;;561    			// 计算实际的百分点
;;;562    			//percent = (100 - i*10) + ((param - batteryPercentTable[vLevel][i])*10 / spanVal);
;;;563    
;;;564    			fPercent = k * param + b;
0000ac  4628              MOV      r0,r5
0000ae  f7fffffe          BL       __aeabi_ui2f
0000b2  4639              MOV      r1,r7
0000b4  f7fffffe          BL       __aeabi_fmul
0000b8  4621              MOV      r1,r4
0000ba  f7fffffe          BL       __aeabi_fadd
;;;565    
;;;566    		//	if (fPercent >= 99.5f)	// 浮点数不允许判断==或>=或<=
;;;567    			if(fPercent > 99.4999f)
0000be  490d              LDR      r1,|L5.244|
0000c0  4288              CMP      r0,r1
0000c2  dd00              BLE      |L5.198|
;;;568    			{
;;;569    				fPercent = 100;
0000c4  4640              MOV      r0,r8
                  |L5.198|
;;;570    			}
;;;571    
;;;572    			percent = (uint8)fPercent;
0000c6  f7fffffe          BL       __aeabi_f2uiz
0000ca  b2c0              UXTB     r0,r0
                  |L5.204|
;;;573    			
;;;574    			return percent;
;;;575    		}
;;;576    	}
;;;577    	
;;;578    	return 0;
;;;579    }
0000cc  e8bd87f0          POP      {r4-r10,pc}
                  |L5.208|
0000d0  e7ff              B        |L5.210|
                  |L5.210|
0000d2  2064              MOVS     r0,#0x64              ;551
0000d4  e7fa              B        |L5.204|
                  |L5.214|
0000d6  1c64              ADDS     r4,r4,#1              ;543
0000d8  b2e4              UXTB     r4,r4                 ;543
0000da  2c0c              CMP      r4,#0xc               ;543
0000dc  d3b5              BCC      |L5.74|
0000de  2000              MOVS     r0,#0                 ;578
0000e0  e7f4              B        |L5.204|
;;;580    
                          ENDP

0000e2  0000              DCW      0x0000
                  |L5.228|
                          DCD      paramCB
                  |L5.232|
                          DCD      ||.constdata||+0x4
                  |L5.236|
                          DCD      ||.constdata||+0x124
                  |L5.240|
                          DCD      0x42c80000
                  |L5.244|
                          DCD      0x42c6fff3

                          AREA ||i.ADC_HwInit||, CODE, READONLY, ALIGN=2

                  ADC_HwInit PROC
;;;444    // 硬件ADC0初始化
;;;445    void ADC_HwInit(void)
000000  b510              PUSH     {r4,lr}
;;;446    {
;;;447     	rcu_periph_clock_enable(RCU_GPIOA);									// 时能GPIOC时钟
000002  f2406002          MOV      r0,#0x602
000006  f7fffffe          BL       rcu_periph_clock_enable
;;;448    	rcu_periph_clock_enable(RCU_ADC0);									// 时能ADC0时钟
00000a  f2406009          MOV      r0,#0x609
00000e  f7fffffe          BL       rcu_periph_clock_enable
;;;449    
;;;450    	adc_deinit(ADC0);													// 复位ADC
000012  4c21              LDR      r4,|L6.152|
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       adc_deinit
;;;451    	rcu_adc_clock_config(RCU_CKADC_CKAPB2_DIV6);						// 72/6 = 12 Mhz(最大频率不能超过40M) 
00001a  2002              MOVS     r0,#2
00001c  f7fffffe          BL       rcu_adc_clock_config
;;;452    		
;;;453    	gpio_init(GPIOA, GPIO_MODE_AIN, GPIO_OSPEED_50MHZ, GPIO_PIN_0 | GPIO_PIN_1);		// PA0 - 模拟输入
000020  2303              MOVS     r3,#3
000022  461a              MOV      r2,r3
000024  2100              MOVS     r1,#0
000026  481d              LDR      r0,|L6.156|
000028  f7fffffe          BL       gpio_init
;;;454    
;;;455    	// ADC0 配置
;;;456    	adc_mode_config(ADC_MODE_FREE); 									// 独立模式
00002c  2000              MOVS     r0,#0
00002e  f7fffffe          BL       adc_mode_config
;;;457    	adc_special_function_config(ADC0, ADC_SCAN_MODE, DISABLE);			// 扫描模式关闭
000032  2200              MOVS     r2,#0
000034  15a1              ASRS     r1,r4,#22
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       adc_special_function_config
;;;458    	adc_special_function_config(ADC0, ADC_CONTINUOUS_MODE, DISABLE);	// 连续转换模式关闭
00003c  2200              MOVS     r2,#0
00003e  2102              MOVS     r1,#2
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       adc_special_function_config
;;;459    	adc_external_trigger_source_config(ADC0, ADC_REGULAR_CHANNEL, ADC0_1_2_EXTTRIG_REGULAR_NONE);  // 常规通道，软件触发
000046  f44f2260          MOV      r2,#0xe0000
00004a  2101              MOVS     r1,#1
00004c  4620              MOV      r0,r4
00004e  f7fffffe          BL       adc_external_trigger_source_config
;;;460    	adc_data_alignment_config(ADC0, ADC_DATAALIGN_RIGHT);				// 数据右对齐
000052  2100              MOVS     r1,#0
000054  4620              MOV      r0,r4
000056  f7fffffe          BL       adc_data_alignment_config
;;;461    	adc_channel_length_config(ADC0, ADC_REGULAR_CHANNEL, 1);			// 常规通道数量1
00005a  2201              MOVS     r2,#1
00005c  4611              MOV      r1,r2
00005e  4620              MOV      r0,r4
000060  f7fffffe          BL       adc_channel_length_config
;;;462    
;;;463    	// 设置ADC
;;;464        adc_regular_channel_config(ADC0, 0, ADC_CHANNEL_0, ADC_SAMPLETIME_55POINT5);	
000064  2200              MOVS     r2,#0
000066  2305              MOVS     r3,#5
000068  4611              MOV      r1,r2
00006a  4620              MOV      r0,r4
00006c  f7fffffe          BL       adc_regular_channel_config
;;;465    	adc_enable(ADC0);													// 时能ADC0
000070  4620              MOV      r0,r4
000072  f7fffffe          BL       adc_enable
;;;466    	Delayms(10);
000076  200a              MOVS     r0,#0xa
000078  f7fffffe          BL       Delayms
;;;467    	adc_calibration_enable(ADC0);										// ADC校准和复位校准
00007c  4620              MOV      r0,r4
00007e  f7fffffe          BL       adc_calibration_enable
;;;468    	
;;;469    	adc_external_trigger_config(ADC0, ADC_REGULAR_CHANNEL, ENABLE);		// 启动ADC0转换
000082  2201              MOVS     r2,#1
000084  4611              MOV      r1,r2
000086  4620              MOV      r0,r4
000088  f7fffffe          BL       adc_external_trigger_config
;;;470    	adc_software_trigger_enable(ADC0, ADC_REGULAR_CHANNEL);
00008c  4620              MOV      r0,r4
00008e  e8bd4010          POP      {r4,lr}
000092  2101              MOVS     r1,#1
000094  f7ffbffe          B.W      adc_software_trigger_enable
;;;471    }
;;;472    
                          ENDP

                  |L6.152|
                          DCD      0x40012400
                  |L6.156|
                          DCD      0x40010800

                          AREA ||i.ADC_InitStruct||, CODE, READONLY, ALIGN=2

                  ADC_InitStruct PROC
;;;473    // 初始化结构体
;;;474    void ADC_InitStruct(void)
000000  4a0a              LDR      r2,|L7.44|
;;;475    {
;;;476    	uint8 i;
;;;477    	
;;;478    	adcCB.scanRequest = FALSE;
000002  2100              MOVS     r1,#0
000004  7011              STRB     r1,[r2,#0]
;;;479    	adcCB.currentChannel = (ADC_CHANNEL_E)0;
000006  7051              STRB     r1,[r2,#1]
;;;480    
;;;481    	// 电池相关数据结构初始化
;;;482    	for(i=0; i<ADC_BATTERY_DETECTOR_BUFF_SIZE; i++)
000008  2000              MOVS     r0,#0
                  |L7.10|
;;;483    	{
;;;484    		adcCB.battery.adcBuff[i] = 0;
00000a  eb020340          ADD      r3,r2,r0,LSL #1
00000e  8099              STRH     r1,[r3,#4]
000010  1c40              ADDS     r0,r0,#1              ;482
000012  b2c0              UXTB     r0,r0                 ;482
000014  280a              CMP      r0,#0xa               ;482
000016  d3f8              BCC      |L7.10|
;;;485    	}
;;;486    	adcCB.battery.index = 0;
000018  7611              STRB     r1,[r2,#0x18]
;;;487    	adcCB.battery.adcAverage = 0;
00001a  8351              STRH     r1,[r2,#0x1a]
;;;488    	adcCB.battery.voltage = 0;
00001c  61d1              STR      r1,[r2,#0x1c]  ; adcCB
;;;489    	adcCB.battery.realtimePercent = 0;
00001e  f8821020          STRB     r1,[r2,#0x20]
;;;490    
;;;491    	// 设置电池延时采样计数值为0
;;;492    	PARAM_SetBatteryCapVaryTimeCount(0);
000022  4803              LDR      r0,|L7.48|
000024  f8a01176          STRH     r1,[r0,#0x176]
;;;493    }
000028  4770              BX       lr
;;;494    
                          ENDP

00002a  0000              DCW      0x0000
                  |L7.44|
                          DCD      ||.bss||
                  |L7.48|
                          DCD      paramCB

                          AREA ||i.ADC_PhotoSensorSlowlyProcess||, CODE, READONLY, ALIGN=2

                  ADC_PhotoSensorSlowlyProcess PROC
;;;811    // 光电传感器缓慢变化
;;;812    void ADC_PhotoSensorSlowlyProcess(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;813    {
;;;814    	static uint16 adcScanCount = 0;		// 这里的处理与ADC扫描控制使用同一个定时器，这里使用该参数对定时器进行分频
;;;815    
;;;816    	// 对ADC扫描定时器作分频处理
;;;817    	if (++adcScanCount < (PHOTOSENSOR_SAMPLE_TIME/(ADC_SCAN_TIME*ADC_CHANNEL_MAX)))
000002  4929              LDR      r1,|L8.168|
000004  8948              LDRH     r0,[r1,#0xa]  ; adcScanCount
000006  1c40              ADDS     r0,r0,#1
000008  b280              UXTH     r0,r0
00000a  8148              STRH     r0,[r1,#0xa]
00000c  281e              CMP      r0,#0x1e
00000e  d326              BCC      |L8.94|
;;;818    	{
;;;819    		return;
;;;820    	}
;;;821    	adcScanCount = 0;
000010  2000              MOVS     r0,#0
000012  8148              STRH     r0,[r1,#0xa]
;;;822    
;;;823    	// 将当前光电传感器ADC放入参数层
;;;824    	PARAM_SetPhotoSensorADCValue(adcCB.photoSensor.adcAverage);
000014  4c25              LDR      r4,|L8.172|
000016  4a26              LDR      r2,|L8.176|
000018  8f60              LDRH     r0,[r4,#0x3a]  ; adcCB
00001a  f8a201a0          STRH     r0,[r2,#0x1a0]
;;;825    
;;;826    	// 亮度变化方向
;;;827    	if (adcCB.photoSensor.adcAverage < adcCB.photoSensor.preAdcAverage)
00001e  8fa1              LDRH     r1,[r4,#0x3c]  ; adcCB
;;;828    	{
;;;829    		if (adcCB.photoSensor.adcAverage > PHOTOSENSOR_THRESHOLD_5)
;;;830    		{
;;;831    			adcCB.photoSensor.preAdcAverage = PHOTOSENSOR_THRESHOLD_5;
;;;832    		}
;;;833    		else if (adcCB.photoSensor.adcAverage > PHOTOSENSOR_THRESHOLD_4)
;;;834    		{
;;;835    			adcCB.photoSensor.preAdcAverage = PHOTOSENSOR_THRESHOLD_4;
;;;836    		}
;;;837    		else if (adcCB.photoSensor.adcAverage > PHOTOSENSOR_THRESHOLD_3)
;;;838    		{
;;;839    			adcCB.photoSensor.preAdcAverage = PHOTOSENSOR_THRESHOLD_3;
;;;840    		}
;;;841    		else if (adcCB.photoSensor.adcAverage > PHOTOSENSOR_THRESHOLD_2)
000020  f240654d          MOV      r5,#0x64d
;;;842    		{
;;;843    			adcCB.photoSensor.preAdcAverage = PHOTOSENSOR_THRESHOLD_2;
;;;844    		}
;;;845    		else
;;;846    		{
;;;847    			adcCB.photoSensor.preAdcAverage = PHOTOSENSOR_THRESHOLD_1;
000024  106b              ASRS     r3,r5,#1
000026  f640471c          MOV      r7,#0xc1c             ;833
00002a  f6401674          MOV      r6,#0x974             ;837
00002e  4288              CMP      r0,r1                 ;827
000030  d216              BCS      |L8.96|
000032  f64061d8          MOV      r1,#0xed8             ;829
000036  4288              CMP      r0,r1                 ;829
000038  d901              BLS      |L8.62|
00003a  87a1              STRH     r1,[r4,#0x3c]         ;831
00003c  e00c              B        |L8.88|
                  |L8.62|
00003e  42b8              CMP      r0,r7                 ;833
000040  d901              BLS      |L8.70|
000042  87a7              STRH     r7,[r4,#0x3c]         ;835
000044  e008              B        |L8.88|
                  |L8.70|
000046  42b0              CMP      r0,r6                 ;837
000048  d901              BLS      |L8.78|
00004a  87a6              STRH     r6,[r4,#0x3c]         ;839
00004c  e004              B        |L8.88|
                  |L8.78|
00004e  42a8              CMP      r0,r5                 ;841
000050  d901              BLS      |L8.86|
000052  87a5              STRH     r5,[r4,#0x3c]         ;843
000054  e000              B        |L8.88|
                  |L8.86|
000056  87a3              STRH     r3,[r4,#0x3c]
                  |L8.88|
;;;848    		}
;;;849    
;;;850    		PARAM_SetPhotoSensorVaryDirection(TRUE);
000058  2001              MOVS     r0,#1
00005a  f88201a2          STRB     r0,[r2,#0x1a2]
                  |L8.94|
;;;851    	}
;;;852    	else
;;;853    	{
;;;854    		if (PHOTOSENSOR_THRESHOLD_1 == adcCB.photoSensor.preAdcAverage)
;;;855    		{
;;;856    		}
;;;857    		else if (PHOTOSENSOR_THRESHOLD_2 == adcCB.photoSensor.preAdcAverage)
;;;858    		{
;;;859    			if (adcCB.photoSensor.adcAverage < PHOTOSENSOR_THRESHOLD_1)
;;;860    			{
;;;861    				adcCB.photoSensor.preAdcAverage = PHOTOSENSOR_THRESHOLD_1;
;;;862    			}
;;;863    		}
;;;864    		else if (PHOTOSENSOR_THRESHOLD_3 == adcCB.photoSensor.preAdcAverage)
;;;865    		{
;;;866    			if ((adcCB.photoSensor.adcAverage >= PHOTOSENSOR_THRESHOLD_1)
;;;867    				&& (adcCB.photoSensor.adcAverage < PHOTOSENSOR_THRESHOLD_2))
;;;868    			{
;;;869    				adcCB.photoSensor.preAdcAverage = PHOTOSENSOR_THRESHOLD_2;
;;;870    			}
;;;871    			else
;;;872    			{
;;;873    				adcCB.photoSensor.preAdcAverage = PHOTOSENSOR_THRESHOLD_1;
;;;874    			}
;;;875    		}
;;;876    		else if (PHOTOSENSOR_THRESHOLD_4 == adcCB.photoSensor.preAdcAverage)
;;;877    		{
;;;878    			if ((adcCB.photoSensor.adcAverage >= PHOTOSENSOR_THRESHOLD_2)
;;;879    				&& (adcCB.photoSensor.adcAverage < PHOTOSENSOR_THRESHOLD_3))
;;;880    			{
;;;881    				adcCB.photoSensor.preAdcAverage = PHOTOSENSOR_THRESHOLD_3;
;;;882    			}
;;;883    			else if ((adcCB.photoSensor.adcAverage >= PHOTOSENSOR_THRESHOLD_1)
;;;884    				&& (adcCB.photoSensor.adcAverage < PHOTOSENSOR_THRESHOLD_2))
;;;885    			{
;;;886    				adcCB.photoSensor.preAdcAverage = PHOTOSENSOR_THRESHOLD_2;
;;;887    			}
;;;888    			else
;;;889    			{
;;;890    				adcCB.photoSensor.preAdcAverage = PHOTOSENSOR_THRESHOLD_1;
;;;891    			}
;;;892    		}		
;;;893    	}
;;;894    }
00005e  bdf0              POP      {r4-r7,pc}
                  |L8.96|
000060  4299              CMP      r1,r3                 ;854
000062  d0fc              BEQ      |L8.94|
000064  42a9              CMP      r1,r5                 ;857
000066  d103              BNE      |L8.112|
000068  4298              CMP      r0,r3                 ;859
00006a  d2f8              BCS      |L8.94|
00006c  87a3              STRH     r3,[r4,#0x3c]         ;861
00006e  bdf0              POP      {r4-r7,pc}
                  |L8.112|
000070  4a0e              LDR      r2,|L8.172|
000072  f2403c27          MOV      r12,#0x327            ;866
000076  42b1              CMP      r1,r6                 ;864
000078  8f52              LDRH     r2,[r2,#0x3a]         ;824
00007a  f2a23226          SUB      r2,r2,#0x326          ;866
00007e  d105              BNE      |L8.140|
000080  4562              CMP      r2,r12                ;866
000082  d201              BCS      |L8.136|
000084  87a5              STRH     r5,[r4,#0x3c]         ;869
000086  bdf0              POP      {r4-r7,pc}
                  |L8.136|
000088  87a3              STRH     r3,[r4,#0x3c]         ;873
                  |L8.138|
00008a  bdf0              POP      {r4-r7,pc}
                  |L8.140|
00008c  42b9              CMP      r1,r7                 ;876
00008e  d1fc              BNE      |L8.138|
000090  f2a0604d          SUB      r0,r0,#0x64d          ;878
000094  4560              CMP      r0,r12                ;878
000096  d201              BCS      |L8.156|
000098  87a6              STRH     r6,[r4,#0x3c]         ;881
00009a  bdf0              POP      {r4-r7,pc}
                  |L8.156|
00009c  4562              CMP      r2,r12                ;883
00009e  d201              BCS      |L8.164|
0000a0  87a5              STRH     r5,[r4,#0x3c]         ;886
0000a2  bdf0              POP      {r4-r7,pc}
                  |L8.164|
0000a4  87a3              STRH     r3,[r4,#0x3c]         ;890
0000a6  bdf0              POP      {r4-r7,pc}
;;;895    
                          ENDP

                  |L8.168|
                          DCD      ||.data||
                  |L8.172|
                          DCD      ||.bss||
                  |L8.176|
                          DCD      paramCB

                          AREA ||i.ADC_Process||, CODE, READONLY, ALIGN=2

                  ADC_Process PROC
;;;282    // 传感器处理，在main中调用
;;;283    void ADC_Process(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;284    {
;;;285    	uint16 adcData;
;;;286    	uint8 i;
;;;287    	uint8 vLevel = 1;
000004  2401              MOVS     r4,#1
;;;288    	uint16 value;
;;;289    	
;;;290    	// 有检测请求时，执行一次转换
;;;291    	if(adcCB.scanRequest)
000006  4e47              LDR      r6,|L9.292|
000008  7830              LDRB     r0,[r6,#0]  ; adcCB
00000a  2800              CMP      r0,#0
00000c  d07e              BEQ      |L9.268|
;;;292    	{
;;;293    		// 上次转换未完成，退出，等待转换完成
;;;294    		if(!ADC_CONVERT_IS_BUSY())
00000e  f8df8118          LDR      r8,|L9.296|
000012  2102              MOVS     r1,#2
000014  4640              MOV      r0,r8
000016  f7fffffe          BL       adc_flag_get
00001a  2800              CMP      r0,#0
00001c  d076              BEQ      |L9.268|
;;;295    		{
;;;296    			return;
;;;297    		}
;;;298    		
;;;299    		// 上次转换结束，清除转换请求
;;;300    		adcCB.scanRequest = FALSE;
00001e  2700              MOVS     r7,#0
000020  7037              STRB     r7,[r6,#0]
;;;301    
;;;302    		// 将数据添加到对应的缓冲区中
;;;303    		switch(adcCB.currentChannel)
000022  7870              LDRB     r0,[r6,#1]  ; adcCB
000024  b110              CBZ      r0,|L9.44|
000026  2801              CMP      r0,#1
000028  d165              BNE      |L9.246|
00002a  e05b              B        |L9.228|
                  |L9.44|
;;;304    		{
;;;305    			// 电池通道
;;;306    			case ADC_CHANNEL_BATTERY:				
;;;307    				adcData = ADC_CONVERT_RESULT();
00002c  4640              MOV      r0,r8
00002e  f7fffffe          BL       adc_regular_data_read
000032  4601              MOV      r1,r0
;;;308    				ADC_AddDataToBuff(ADC_CHANNEL_BATTERY, adcData);
000034  2000              MOVS     r0,#0
000036  f7fffffe          BL       ADC_AddDataToBuff
;;;309    
;;;310    				// 将初值电池ADC传入参数层进行ldo校准
;;;311    				paramCB.runtime.battery.batteryADC = adcCB.battery.adcAverage;
00003a  4d3c              LDR      r5,|L9.300|
00003c  8b70              LDRH     r0,[r6,#0x1a]  ; adcCB
00003e  f8a50178          STRH     r0,[r5,#0x178]
;;;312    				adcCB.battery.voltage = adcCB.battery.adcAverage;
;;;313    				
;;;314    				adcCB.battery.voltage *= paramCB.nvm.param.common.adRatioRef;
000042  f8d5132c          LDR      r1,[r5,#0x32c]  ; paramCB
000046  4348              MULS     r0,r1,r0
;;;315    				adcCB.battery.voltage /= 4096;
000048  0b00              LSRS     r0,r0,#12
00004a  61f0              STR      r0,[r6,#0x1c]  ; adcCB
;;;316    
;;;317    				// 将当前电压放入参数层
;;;318    				PARAM_SetBatteryVoltage(adcCB.battery.voltage);
00004c  f8c50168          STR      r0,[r5,#0x168]  ; paramCB
;;;319    
;;;320    				// ADC不作为电量数据源时，不进行计算
;;;321    				if (BATTERY_DATA_SRC_ADC != PARAM_GetBatteryDataSrc())
000050  f8951173          LDRB     r1,[r5,#0x173]  ; paramCB
000054  2902              CMP      r1,#2
000056  d14e              BNE      |L9.246|
;;;322    				{
;;;323    					break;
;;;324    				}
;;;325    
;;;326    				
;;;327    				// 根据电压放电曲线设置百分比步进时间
;;;328    				switch (PARAM_GetBatteryVoltageLevel())
000058  f8951338          LDRB     r1,[r5,#0x338]  ; paramCB
00005c  2934              CMP      r1,#0x34
00005e  d010              BEQ      |L9.130|
000060  dc06              BGT      |L9.112|
000062  2918              CMP      r1,#0x18
000064  d009              BEQ      |L9.122|
000066  2924              CMP      r1,#0x24
000068  d010              BEQ      |L9.140|
00006a  2930              CMP      r1,#0x30
00006c  d10e              BNE      |L9.140|
00006e  e006              B        |L9.126|
                  |L9.112|
000070  293c              CMP      r1,#0x3c
000072  d008              BEQ      |L9.134|
000074  2948              CMP      r1,#0x48
000076  d109              BNE      |L9.140|
000078  e007              B        |L9.138|
                  |L9.122|
;;;329    				{
;;;330    					case 24:
;;;331    						vLevel = 0;
00007a  2400              MOVS     r4,#0
;;;332    						break;
00007c  e006              B        |L9.140|
                  |L9.126|
;;;333    				
;;;334    					case 36:
;;;335    						vLevel = 1;
;;;336    						break;
;;;337    				
;;;338    					case 48:
;;;339    						vLevel = 2;
00007e  2402              MOVS     r4,#2
;;;340    						break;
000080  e004              B        |L9.140|
                  |L9.130|
;;;341    						
;;;342    					case 52:
;;;343    						vLevel = 3;
000082  2403              MOVS     r4,#3
;;;344    						break;
000084  e002              B        |L9.140|
                  |L9.134|
;;;345    
;;;346    					case 60:
;;;347    						vLevel = 4;
000086  2404              MOVS     r4,#4
;;;348    						break;
000088  e000              B        |L9.140|
                  |L9.138|
;;;349    						
;;;350    					case 72:
;;;351    						vLevel = 5;
00008a  2405              MOVS     r4,#5
                  |L9.140|
;;;352    						break;
;;;353    						
;;;354    					default:
;;;355    						vLevel = 1;
;;;356    						break;
;;;357    				}
;;;358    
;;;359    				// 有电流时，根据电压电量消耗表来延长掉电时间
;;;360    				if (500 <= PARAM_GetBatteryCurrent())
00008c  f8b5116c          LDRH     r1,[r5,#0x16c]  ; paramCB
000090  f5b17ffa          CMP      r1,#0x1f4
000094  d316              BCC      |L9.196|
;;;361    				{
;;;362    					for(i = 1; i < 12; i++)
000096  2101              MOVS     r1,#1
;;;363    					{
;;;364    						if(adcCB.battery.voltage > batteryPercentTable[vLevel][i])
000098  4a25              LDR      r2,|L9.304|
00009a  eb040344          ADD      r3,r4,r4,LSL #1
00009e  eb021203          ADD      r2,r2,r3,LSL #4
                  |L9.162|
0000a2  f8524021          LDR      r4,[r2,r1,LSL #2]
0000a6  4284              CMP      r4,r0
0000a8  d303              BCC      |L9.178|
0000aa  1c49              ADDS     r1,r1,#1              ;362
0000ac  b2c9              UXTB     r1,r1                 ;362
0000ae  290c              CMP      r1,#0xc               ;362
0000b0  d3f7              BCC      |L9.162|
                  |L9.178|
;;;365    						{
;;;366    							break;
;;;367    						}
;;;368    					}
;;;369    					PARAM_SetBatteryCapVaryTimeCount(batteryPercentTimeTable[vLevel][i-1]);
0000b2  4a20              LDR      r2,|L9.308|
0000b4  1e49              SUBS     r1,r1,#1
0000b6  eb0202c3          ADD      r2,r2,r3,LSL #3
0000ba  f8321011          LDRH     r1,[r2,r1,LSL #1]
0000be  f8a51176          STRH     r1,[r5,#0x176]
0000c2  e001              B        |L9.200|
                  |L9.196|
;;;370    				}
;;;371    				else
;;;372    				{
;;;373    					PARAM_SetBatteryCapVaryTimeCount(0);
0000c4  f8a57176          STRH     r7,[r5,#0x176]
                  |L9.200|
;;;374    				}
;;;375    				// 计算实时百分比
;;;376    				adcCB.battery.realtimePercent = ADC_GetBatteryPercent(adcCB.battery.voltage);
0000c8  f7fffffe          BL       ADC_GetBatteryPercent
0000cc  f8860020          STRB     r0,[r6,#0x20]
;;;377    				
;;;378    				// 实时百分比为0，设置电池欠压
;;;379    				if (adcCB.battery.realtimePercent)
0000d0  b110              CBZ      r0,|L9.216|
;;;380    				{
;;;381    					PARAM_SetBatteryLowAlarm(0);
0000d2  f8857171          STRB     r7,[r5,#0x171]
0000d6  e002              B        |L9.222|
                  |L9.216|
;;;382    				}
;;;383    				else
;;;384    				{
;;;385    					PARAM_SetBatteryLowAlarm(1);
0000d8  2001              MOVS     r0,#1
0000da  f8850171          STRB     r0,[r5,#0x171]
                  |L9.222|
;;;386    				}
;;;387    				
;;;388    				// 显示平滑处理
;;;389    				ADC_TortoiseProcess();
0000de  f7fffffe          BL       ADC_TortoiseProcess
;;;390    
;;;391    				break;
0000e2  e008              B        |L9.246|
                  |L9.228|
;;;392    				
;;;393    			// 光敏通道
;;;394    			case ADC_CHANNEL_LIGHTSENSOR:
;;;395    				adcData = ADC_CONVERT_RESULT();
0000e4  4640              MOV      r0,r8
0000e6  f7fffffe          BL       adc_regular_data_read
0000ea  4601              MOV      r1,r0
;;;396    				ADC_AddDataToBuff(ADC_CHANNEL_LIGHTSENSOR, adcData);
0000ec  2001              MOVS     r0,#1
0000ee  f7fffffe          BL       ADC_AddDataToBuff
;;;397    			
;;;398    				// 平缓处理
;;;399    				ADC_PhotoSensorSlowlyProcess();
0000f2  f7fffffe          BL       ADC_PhotoSensorSlowlyProcess
                  |L9.246|
;;;400    				break;
;;;401    
;;;402    			// 非法通道
;;;403    			default:
;;;404    				break;
;;;405    		}
;;;406    
;;;407    		// 切换至下一个通道
;;;408    		adcCB.currentChannel ++;
0000f6  7870              LDRB     r0,[r6,#1]  ; adcCB
0000f8  1c40              ADDS     r0,r0,#1
;;;409    		adcCB.currentChannel %= ADC_CHANNEL_MAX;
0000fa  f0000001          AND      r0,r0,#1
0000fe  7070              STRB     r0,[r6,#1]
;;;410    
;;;411    		// 选定下一个通道
;;;412    		ADC_CONVERT_CHANNEL(adcChannelMapping[adcCB.currentChannel]);
000100  490b              LDR      r1,|L9.304|
000102  2305              MOVS     r3,#5
000104  1f09              SUBS     r1,r1,#4
000106  5c0a              LDRB     r2,[r1,r0]
000108  2100              MOVS     r1,#0
00010a  e000              B        |L9.270|
                  |L9.268|
00010c  e008              B        |L9.288|
                  |L9.270|
00010e  4640              MOV      r0,r8
000110  f7fffffe          BL       adc_regular_channel_config
;;;413    		
;;;414    		// 启动下一次转换
;;;415    		ADC_CONVERT_START();
000114  4640              MOV      r0,r8
000116  e8bd41f0          POP      {r4-r8,lr}
00011a  2101              MOVS     r1,#1
00011c  f7ffbffe          B.W      adc_software_trigger_enable
                  |L9.288|
;;;416    	}
;;;417    }
000120  e8bd81f0          POP      {r4-r8,pc}
;;;418    
                          ENDP

                  |L9.292|
                          DCD      ||.bss||
                  |L9.296|
                          DCD      0x40012400
                  |L9.300|
                          DCD      paramCB
                  |L9.304|
                          DCD      ||.constdata||+0x4
                  |L9.308|
                          DCD      ||.constdata||+0x13c

                          AREA ||i.ADC_Start||, CODE, READONLY, ALIGN=2

                  ADC_Start PROC
;;;419    // 启动NTC，即启动定时器任务，周期性地读取温度
;;;420    void ADC_Start(void)
000000  4903              LDR      r1,|L10.16|
;;;421    {
;;;422    //	TIMER_KillTask(TIMER_ID_ADC_SCAN);
;;;423    
;;;424    	adcCB.currentChannel = ADC_CHANNEL_BATTERY;
000002  2000              MOVS     r0,#0
000004  7048              STRB     r0,[r1,#1]
;;;425    
;;;426    	// 注册定时器任务，周期性采样
;;;427    //	TIMER_AddTask(TIMER_ID_ADC_SCAN,
;;;428    //				ADC_SCAN_TIME,
;;;429    //				ADC_CALLBACK_SetScanRequest,
;;;430    //				0,
;;;431    //				TIMER_LOOP_FOREVER,
;;;432    //				ACTION_MODE_DO_AT_ONCE);
;;;433    					
;;;434    	// 启动下一次转换
;;;435    	ADC_CONVERT_START();
000006  2101              MOVS     r1,#1
000008  4802              LDR      r0,|L10.20|
00000a  f7ffbffe          B.W      adc_software_trigger_enable
;;;436    }
;;;437    
                          ENDP

00000e  0000              DCW      0x0000
                  |L10.16|
                          DCD      ||.bss||
                  |L10.20|
                          DCD      0x40012400

                          AREA ||i.ADC_Stop||, CODE, READONLY, ALIGN=1

                  ADC_Stop PROC
;;;438    // 停止检测
;;;439    void ADC_Stop(void)
000000  4770              BX       lr
;;;440    {
;;;441    //	TIMER_KillTask(TIMER_ID_ADC_SCAN);
;;;442    }
;;;443    
                          ENDP


                          AREA ||i.ADC_TortoiseProcess||, CODE, READONLY, ALIGN=2

                  ADC_TortoiseProcess PROC
;;;700    // 设置电池百分比连续显示变化值
;;;701    void ADC_TortoiseProcess(void)
000000  b570              PUSH     {r4-r6,lr}
;;;702    {
;;;703    	static uint16 adcScanCount = 0;		// 这里的处理与ADC扫描控制使用同一个定时器，这里使用该参数对定时器进行分频，分频数与设定的滤波等级有关
;;;704    	static uint16 keynoteTimeCnt = 0;
;;;705    	static BOOL keynoteFlag = FALSE;	
;;;706    	static uint32 tempBatteryCapVaryTimeCount = 0;
;;;707    
;;;708    	// 在开机后的2秒内定下电池百分比基调
;;;709    	if (!keynoteFlag)
000002  491c              LDR      r1,|L12.116|
;;;710    	{
;;;711    		if (++keynoteTimeCnt < (2*1000UL/(ADC_SCAN_TIME*ADC_CHANNEL_MAX)))
;;;712    		{
;;;713    			adcCB.battery.displayPercent = ADC_GetBatteryPercent(adcCB.battery.voltage);
000004  4d1c              LDR      r5,|L12.120|
;;;714    			
;;;715    			// 将实时的电池百分比放入参数层
;;;716    			PARAM_SetBatteryPercent(adcCB.battery.displayPercent);
000006  4c1d              LDR      r4,|L12.124|
000008  7888              LDRB     r0,[r1,#2]            ;709  ; keynoteFlag
00000a  2800              CMP      r0,#0                 ;709
00000c  d10f              BNE      |L12.46|
00000e  88c8              LDRH     r0,[r1,#6]            ;711  ; keynoteTimeCnt
000010  1c40              ADDS     r0,r0,#1              ;711
000012  b280              UXTH     r0,r0                 ;711
000014  80c8              STRH     r0,[r1,#6]            ;711
000016  2814              CMP      r0,#0x14              ;711
000018  d207              BCS      |L12.42|
00001a  69e8              LDR      r0,[r5,#0x1c]         ;713  ; adcCB
00001c  f7fffffe          BL       ADC_GetBatteryPercent
000020  f8850021          STRB     r0,[r5,#0x21]         ;713
000024  f8840172          STRB     r0,[r4,#0x172]
                  |L12.40|
;;;717    			
;;;718    			return;
;;;719    		}
;;;720    		keynoteFlag = TRUE;
;;;721    	}
;;;722    	
;;;723    	// 对ADC扫描定时器作分频处理
;;;724    	if(++adcScanCount < ((uint32)PARAM_GetBatteryCapVaryTime()*1000UL/(ADC_SCAN_TIME*ADC_CHANNEL_MAX)))
;;;725    	{
;;;726    		return;
;;;727    	}
;;;728    	adcScanCount = 0;
;;;729    
;;;730    	if(tempBatteryCapVaryTimeCount < PARAM_GetBatteryCapVaryTimeCount())
;;;731    	{
;;;732    		tempBatteryCapVaryTimeCount++;
;;;733    		return;
;;;734    	}
;;;735    	tempBatteryCapVaryTimeCount = 0;
;;;736    
;;;737    	// 显示百分比 ＜ 实时百分比，则显示百分比增大一个百分点
;;;738    #warning "实际上，为了让显示的电量百分比更人性化地朝目标值迈进，这里可以增加一个弹性算法，即每次步进增加的数值=([目标值]-[当前值])/2，这样，差距越大步进越大"
;;;739    
;;;740    	if(ADC_DebounceTortoiseProcess())
;;;741    	{
;;;742    		// 将处理后的百分比放入参数层
;;;743    		PARAM_SetBatteryPercent(adcCB.battery.displayPercent);
;;;744    	}
;;;745    }
000028  bd70              POP      {r4-r6,pc}
                  |L12.42|
00002a  2001              MOVS     r0,#1                 ;720
00002c  7088              STRB     r0,[r1,#2]            ;720
                  |L12.46|
00002e  f8940339          LDRB     r0,[r4,#0x339]        ;724  ; paramCB
000032  f44f727a          MOV      r2,#0x3e8             ;724
000036  4350              MULS     r0,r2,r0              ;724
000038  2264              MOVS     r2,#0x64              ;724
00003a  fbb0f2f2          UDIV     r2,r0,r2              ;724
00003e  8888              LDRH     r0,[r1,#4]            ;724  ; adcScanCount
000040  1c40              ADDS     r0,r0,#1              ;724
000042  b280              UXTH     r0,r0                 ;724
000044  8088              STRH     r0,[r1,#4]            ;724
000046  4282              CMP      r2,r0                 ;724
000048  d8ee              BHI      |L12.40|
00004a  2200              MOVS     r2,#0                 ;728
00004c  808a              STRH     r2,[r1,#4]            ;728
00004e  f8b43176          LDRH     r3,[r4,#0x176]        ;730  ; paramCB
000052  68c8              LDR      r0,[r1,#0xc]          ;730  ; tempBatteryCapVaryTimeCount
000054  4283              CMP      r3,r0                 ;730
000056  d902              BLS      |L12.94|
000058  1c40              ADDS     r0,r0,#1              ;732
00005a  60c8              STR      r0,[r1,#0xc]          ;732  ; tempBatteryCapVaryTimeCount
                  |L12.92|
00005c  bd70              POP      {r4-r6,pc}
                  |L12.94|
00005e  60ca              STR      r2,[r1,#0xc]          ;735  ; tempBatteryCapVaryTimeCount
000060  f7fffffe          BL       ADC_DebounceTortoiseProcess
000064  2800              CMP      r0,#0                 ;740
000066  d0f9              BEQ      |L12.92|
000068  f8950021          LDRB     r0,[r5,#0x21]         ;743  ; adcCB
00006c  f8840172          STRB     r0,[r4,#0x172]        ;743
000070  bd70              POP      {r4-r6,pc}
;;;746    
                          ENDP

000072  0000              DCW      0x0000
                  |L12.116|
                          DCD      ||.data||
                  |L12.120|
                          DCD      ||.bss||
                  |L12.124|
                          DCD      paramCB

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  adcCB
                          %        64

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  adcChannelMapping
000000  00010000          DCB      0x00,0x01,0x00,0x00
                  batteryPercentTable
                          DCD      0x00006f54
                          DCD      0x00006c34
                          DCD      0x00006978
                          DCD      0x000066bc
                          DCD      0x00006400
                          DCD      0x00006270
                          DCD      0x000061a8
                          DCD      0x00005fb4
                          DCD      0x00005e88
                          DCD      0x00005cf8
                          DCD      0x00005a3c
                          DCD      0x00005208
                          DCD      0x00009f60
                          DCD      0x00009a4c
                          DCD      0x00009664
                          DCD      0x0000927c
                          DCD      0x00008e94
                          DCD      0x00008ca0
                          DCD      0x00008b10
                          DCD      0x000088b8
                          DCD      0x000086c4
                          DCD      0x000084d0
                          DCD      0x000080e8
                          DCD      0x00007d00
                          DCD      0x0000cf08
                          DCD      0x0000c8c8
                          DCD      0x0000c3b4
                          DCD      0x0000bea0
                          DCD      0x0000b98c
                          DCD      0x0000b6d0
                          DCD      0x0000b4dc
                          DCD      0x0000b1bc
                          DCD      0x0000af64
                          DCD      0x0000aca8
                          DCD      0x0000a794
                          DCD      0x0000a410
                          DCD      0x0000dac0
                          DCD      0x0000d6d8
                          DCD      0x0000d228
                          DCD      0x0000cc4c
                          DCD      0x0000c670
                          DCD      0x0000c350
                          DCD      0x0000c15c
                          DCD      0x0000bea0
                          DCD      0x0000bb80
                          DCD      0x0000b798
                          DCD      0x0000b5a4
                          DCD      0x0000b1bc
                          DCD      0x0000f8d4
                          DCD      0x0000f58c
                          DCD      0x0000f0a0
                          DCD      0x0000ecf4
                          DCD      0x0000e434
                          DCD      0x0000e1d2
                          DCD      0x0000dfc0
                          DCD      0x0000dca0
                          DCD      0x0000d980
                          DCD      0x0000d2f0
                          DCD      0x0000ce40
                          DCD      0x0000cb20
                          DCD      0x00013880
                          DCD      0x00013308
                          DCD      0x00012688
                          DCD      0x00011b34
                          DCD      0x00010f18
                          DCD      0x00010a04
                          DCD      0x000105b8
                          DCD      0x0000fd84
                          DCD      0x0000f618
                          DCD      0x0000f488
                          DCD      0x0000f230
                          DCD      0x0000ea60
                  batteryPercent
000124  27102328          DCW      0x2710,0x2328
000128  1d4c1770          DCW      0x1d4c,0x1770
00012c  11940e6c          DCW      0x1194,0x0e6c
000130  0c2b07d0          DCW      0x0c2b,0x07d0
000134  03e80320          DCW      0x03e8,0x0320
000138  01f40000          DCW      0x01f4,0x0000
                  batteryPercentTimeTable
00013c  000a000e          DCW      0x000a,0x000e
000140  0009000e          DCW      0x0009,0x000e
000144  000a000a          DCW      0x000a,0x000a
000148  000c000a          DCW      0x000c,0x000a
00014c  00320035          DCW      0x0032,0x0035
000150  00180001          DCW      0x0018,0x0001
000154  000a000e          DCW      0x000a,0x000e
000158  0009000e          DCW      0x0009,0x000e
00015c  000a000a          DCW      0x000a,0x000a
000160  000c000a          DCW      0x000c,0x000a
000164  00320035          DCW      0x0032,0x0035
000168  00180001          DCW      0x0018,0x0001
00016c  000f0015          DCW      0x000f,0x0015
000170  000e0015          DCW      0x000e,0x0015
000174  000f000f          DCW      0x000f,0x000f
000178  0012000f          DCW      0x0012,0x000f
00017c  004b004e          DCW      0x004b,0x004e
000180  00240001          DCW      0x0024,0x0001
000184  000f0015          DCW      0x000f,0x0015
000188  000e0015          DCW      0x000e,0x0015
00018c  000f000f          DCW      0x000f,0x000f
000190  0012000f          DCW      0x0012,0x000f
000194  004b004e          DCW      0x004b,0x004e
000198  00240001          DCW      0x0024,0x0001
00019c  000f0015          DCW      0x000f,0x0015
0001a0  000e0015          DCW      0x000e,0x0015
0001a4  000f000f          DCW      0x000f,0x000f
0001a8  0012000f          DCW      0x0012,0x000f
0001ac  004b004e          DCW      0x004b,0x004e
0001b0  00240001          DCW      0x0024,0x0001
0001b4  000f0015          DCW      0x000f,0x0015
0001b8  000e0015          DCW      0x000e,0x0015
0001bc  000f000f          DCW      0x000f,0x000f
0001c0  0012000f          DCW      0x0012,0x000f
0001c4  004b004e          DCW      0x004b,0x004e
0001c8  00240001          DCW      0x0024,0x0001

                          AREA ||.data||, DATA, ALIGN=2

                  noCurrentActionFlag
000000  01                DCB      0x01
                  currentActionFlag
000001  01                DCB      0x01
                  keynoteFlag
000002  00                DCB      0x00
                  countTemp
000003  00                DCB      0x00
                  adcScanCount
000004  0000              DCW      0x0000
                  keynoteTimeCnt
000006  0000              DCW      0x0000
                  tempDisplayCount
000008  0000              DCW      0x0000
                  |symbol_number.47|
00000a  0000              DCW      0x0000
                  tempBatteryCapVaryTimeCount
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "User\\adc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_adc_c_1e4b4a9e____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___5_adc_c_1e4b4a9e____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_adc_c_1e4b4a9e____REVSH|
#line 128
|__asm___5_adc_c_1e4b4a9e____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
