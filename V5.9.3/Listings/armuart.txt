; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\armuart.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\armuart.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -I.\User\qrencode -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.3\Device\Include -D__MICROLIB -D__UVISION_VERSION=539 -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\armuart.crf User\ArmUart.c]
                          THUMB

                          AREA ||i.ARM_MODULE_Reset||, CODE, READONLY, ALIGN=2

                  ARM_MODULE_Reset PROC
;;;363    // ARM复位
;;;364    void ARM_MODULE_Reset(uint32 param)
000000  b510              PUSH     {r4,lr}
;;;365    {
000002  4604              MOV      r4,r0
;;;366    	// ARM复位
;;;367    	ARM_RST_RESET();
000004  f44f5180          MOV      r1,#0x1000
000008  4806              LDR      r0,|L1.36|
00000a  f7fffffe          BL       gpio_bit_reset
;;;368    
;;;369    	// 释放复位
;;;370    	ARM_RST_RELEASE();
00000e  f44f5180          MOV      r1,#0x1000
000012  4804              LDR      r0,|L1.36|
000014  f7fffffe          BL       gpio_bit_set
;;;371    
;;;372    	ARM_EN_ENABLE();
000018  f44f6100          MOV      r1,#0x800
00001c  4801              LDR      r0,|L1.36|
00001e  f7fffffe          BL       gpio_bit_reset
;;;373    }
000022  bd10              POP      {r4,pc}
                          ENDP

                  |L1.36|
                          DCD      0x40010800

                          AREA ||i.ARM_UART_AddTxArray||, CODE, READONLY, ALIGN=2

                  ARM_UART_AddTxArray PROC
;;;329    // 向发送缓冲区中添加一条待发送序列
;;;330    BOOL ARM_UART_AddTxArray(uint16 id, uint8 *pArray, uint16 length)
000000  b5f0              PUSH     {r4-r7,lr}
;;;331    {
000002  4605              MOV      r5,r0
;;;332    	uint16 i;
;;;333    	uint16 head = armUartCB.tx.head;
000004  482b              LDR      r0,|L2.180|
000006  f8b064d4          LDRH     r6,[r0,#0x4d4]
;;;334    	uint16 end = armUartCB.tx.end;
00000a  f8b044d6          LDRH     r4,[r0,#0x4d6]
;;;335    
;;;336    	// 参数检验
;;;337    	if ((NULL == pArray) || (0 == length))
00000e  b101              CBZ      r1,|L2.18|
000010  b90a              CBNZ     r2,|L2.22|
                  |L2.18|
;;;338    	{
;;;339    		return FALSE;
000012  2000              MOVS     r0,#0
                  |L2.20|
;;;340    	}
;;;341    
;;;342    	// 发送缓冲区已满，不予接收
;;;343    	if ((end + 1) % ARM_UART_DRIVE_TX_QUEUE_SIZE == head)
;;;344    	{
;;;345    		return FALSE;
;;;346    	}
;;;347    
;;;348    	armUartCB.tx.cmdQueue[end].deviceID = id;
;;;349    	for (i = 0; i < length; i++)
;;;350    	{
;;;351    		armUartCB.tx.cmdQueue[end].buff[i] = *pArray++;
;;;352    	}
;;;353    	armUartCB.tx.cmdQueue[end].length = length;
;;;354    
;;;355    	// 发送环形队列更新位置
;;;356    	armUartCB.tx.end++;
;;;357    	armUartCB.tx.end %= ARM_UART_DRIVE_TX_QUEUE_SIZE;
;;;358    	armUartCB.tx.cmdQueue[armUartCB.tx.end].length = 0;
;;;359    
;;;360    	return TRUE;
;;;361    }
000014  bdf0              POP      {r4-r7,pc}
                  |L2.22|
000016  1c60              ADDS     r0,r4,#1              ;343
000018  17c7              ASRS     r7,r0,#31             ;343
00001a  eb007757          ADD      r7,r0,r7,LSR #29      ;343
00001e  10ff              ASRS     r7,r7,#3              ;343
000020  eba007c7          SUB      r7,r0,r7,LSL #3       ;343
000024  42b7              CMP      r7,r6                 ;343
000026  d101              BNE      |L2.44|
000028  2000              MOVS     r0,#0                 ;345
00002a  e7f3              B        |L2.20|
                  |L2.44|
00002c  204d              MOVS     r0,#0x4d              ;348
00002e  4360              MULS     r0,r4,r0              ;348
000030  4f20              LDR      r7,|L2.180|
000032  1d3f              ADDS     r7,r7,#4              ;348
000034  f8275010          STRH     r5,[r7,r0,LSL #1]     ;348
000038  2300              MOVS     r3,#0                 ;349
00003a  e00c              B        |L2.86|
                  |L2.60|
00003c  f811cb01          LDRB     r12,[r1],#1           ;351
000040  204d              MOVS     r0,#0x4d              ;351
000042  4360              MULS     r0,r4,r0              ;351
000044  4f1b              LDR      r7,|L2.180|
000046  1d3f              ADDS     r7,r7,#4              ;351
000048  eb070040          ADD      r0,r7,r0,LSL #1       ;351
00004c  1c80              ADDS     r0,r0,#2              ;351
00004e  f800c003          STRB     r12,[r0,r3]           ;351
000052  1c58              ADDS     r0,r3,#1              ;349
000054  b283              UXTH     r3,r0                 ;349
                  |L2.86|
000056  4293              CMP      r3,r2                 ;349
000058  dbf0              BLT      |L2.60|
00005a  204d              MOVS     r0,#0x4d              ;353
00005c  4360              MULS     r0,r4,r0              ;353
00005e  4f15              LDR      r7,|L2.180|
000060  1d3f              ADDS     r7,r7,#4              ;353
000062  eb070040          ADD      r0,r7,r0,LSL #1       ;353
000066  f8a02098          STRH     r2,[r0,#0x98]         ;353
00006a  1f38              SUBS     r0,r7,#4              ;356
00006c  f8b004d6          LDRH     r0,[r0,#0x4d6]        ;356
000070  1c40              ADDS     r0,r0,#1              ;356
000072  b287              UXTH     r7,r0                 ;356
000074  480f              LDR      r0,|L2.180|
000076  f8a074d6          STRH     r7,[r0,#0x4d6]        ;356
00007a  4607              MOV      r7,r0                 ;357
00007c  f8b704d6          LDRH     r0,[r7,#0x4d6]        ;357
000080  17c7              ASRS     r7,r0,#31             ;357
000082  eb007757          ADD      r7,r0,r7,LSR #29      ;357
000086  10ff              ASRS     r7,r7,#3              ;357
000088  eba007c7          SUB      r7,r0,r7,LSL #3       ;357
00008c  fa1ffc87          UXTH     r12,r7                ;357
000090  4f08              LDR      r7,|L2.180|
000092  f8a7c4d6          STRH     r12,[r7,#0x4d6]       ;357
000096  f04f0c00          MOV      r12,#0                ;358
00009a  4638              MOV      r0,r7                 ;358
00009c  f8b004d6          LDRH     r0,[r0,#0x4d6]        ;358
0000a0  274d              MOVS     r7,#0x4d              ;358
0000a2  4378              MULS     r0,r7,r0              ;358
0000a4  4f03              LDR      r7,|L2.180|
0000a6  1d3f              ADDS     r7,r7,#4              ;358
0000a8  eb070040          ADD      r0,r7,r0,LSL #1       ;358
0000ac  f8a0c098          STRH     r12,[r0,#0x98]        ;358
0000b0  2001              MOVS     r0,#1                 ;360
0000b2  e7af              B        |L2.20|
;;;362    
                          ENDP

                  |L2.180|
                          DCD      armUartCB

                          AREA ||i.ARM_UART_BC_SendData||, CODE, READONLY, ALIGN=2

                  ARM_UART_BC_SendData PROC
;;;176    // 阻塞发送一个字节数据
;;;177    void ARM_UART_BC_SendData(uint8 data)
000000  b510              PUSH     {r4,lr}
;;;178    {
000002  4604              MOV      r4,r0
;;;179    	// 防止丢失第一个字节(清除空标志位,务必加)
;;;180    	usart_flag_get(ARM_UART_TYPE_DEF, USART_FLAG_TC);
000004  2106              MOVS     r1,#6
000006  4807              LDR      r0,|L3.36|
000008  f7fffffe          BL       usart_flag_get
;;;181    
;;;182    	// 填充数据
;;;183    	usart_data_transmit(ARM_UART_TYPE_DEF, data);
00000c  4621              MOV      r1,r4
00000e  4805              LDR      r0,|L3.36|
000010  f7fffffe          BL       usart_data_transmit
;;;184    
;;;185    	// 未发送完，持续等待
;;;186    	while (usart_flag_get(ARM_UART_TYPE_DEF, USART_FLAG_TC) != SET)
000014  bf00              NOP      
                  |L3.22|
000016  2106              MOVS     r1,#6
000018  4802              LDR      r0,|L3.36|
00001a  f7fffffe          BL       usart_flag_get
00001e  2801              CMP      r0,#1
000020  d1f9              BNE      |L3.22|
;;;187    		;
;;;188    }
000022  bd10              POP      {r4,pc}
;;;189    
                          ENDP

                  |L3.36|
                          DCD      0x40004400

                          AREA ||i.ARM_UART_DataStructureInit||, CODE, READONLY, ALIGN=2

                  ARM_UART_DataStructureInit PROC
;;;66     // 数据结构初始化
;;;67     void ARM_UART_DataStructureInit(ARM_UART_CB *pCB)
000000  b510              PUSH     {r4,lr}
;;;68     {
;;;69     	uint16 i;
;;;70     
;;;71     	// 参数合法性检验
;;;72     	if (NULL == pCB)
000002  b900              CBNZ     r0,|L4.6|
                  |L4.4|
;;;73     	{
;;;74     		return;
;;;75     	}
;;;76     
;;;77     	pCB->tx.txBusy = FALSE;
;;;78     	pCB->tx.index = 0;
;;;79     	pCB->tx.head = 0;
;;;80     	pCB->tx.end = 0;
;;;81     	for (i = 0; i < ARM_UART_DRIVE_TX_QUEUE_SIZE; i++)
;;;82     	{
;;;83     		pCB->tx.cmdQueue[i].length = 0;
;;;84     	}
;;;85     
;;;86     	armUartCB.rcvBleMacOK = FALSE;
;;;87     }
000004  bd10              POP      {r4,pc}
                  |L4.6|
000006  2300              MOVS     r3,#0                 ;77
000008  f88034da          STRB     r3,[r0,#0x4da]        ;77
00000c  f8a034d8          STRH     r3,[r0,#0x4d8]        ;78
000010  f8a034d4          STRH     r3,[r0,#0x4d4]        ;79
000014  f8a034d6          STRH     r3,[r0,#0x4d6]        ;80
000018  2100              MOVS     r1,#0                 ;81
00001a  e009              B        |L4.48|
                  |L4.28|
00001c  2400              MOVS     r4,#0                 ;83
00001e  224d              MOVS     r2,#0x4d              ;83
000020  434a              MULS     r2,r1,r2              ;83
000022  1d03              ADDS     r3,r0,#4              ;83
000024  eb030242          ADD      r2,r3,r2,LSL #1       ;83
000028  f8a24098          STRH     r4,[r2,#0x98]         ;83
00002c  1c4a              ADDS     r2,r1,#1              ;81
00002e  b291              UXTH     r1,r2                 ;81
                  |L4.48|
000030  2908              CMP      r1,#8                 ;81
000032  dbf3              BLT      |L4.28|
000034  2200              MOVS     r2,#0                 ;86
000036  4b02              LDR      r3,|L4.64|
000038  f8832524          STRB     r2,[r3,#0x524]        ;86
00003c  bf00              NOP      
00003e  e7e1              B        |L4.4|
;;;88     
                          ENDP

                  |L4.64|
                          DCD      armUartCB

                          AREA ||i.ARM_UART_HwInit||, CODE, READONLY, ALIGN=2

                  ARM_UART_HwInit PROC
;;;35     // UART初始化
;;;36     void ARM_UART_HwInit(uint32 baud)
000000  b510              PUSH     {r4,lr}
;;;37     {
000002  4604              MOV      r4,r0
;;;38     	// 打开时钟
;;;39     	rcu_periph_clock_enable(RCU_GPIOA);
000004  f2406002          MOV      r0,#0x602
000008  f7fffffe          BL       rcu_periph_clock_enable
;;;40     	gpio_init(GPIOA, GPIO_MODE_AF_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_2);
00000c  2304              MOVS     r3,#4
00000e  2203              MOVS     r2,#3
000010  2118              MOVS     r1,#0x18
000012  481f              LDR      r0,|L5.144|
000014  f7fffffe          BL       gpio_init
;;;41     
;;;42     	gpio_init(GPIOA, GPIO_MODE_IPU, GPIO_OSPEED_50MHZ, GPIO_PIN_3);
000018  2308              MOVS     r3,#8
00001a  2203              MOVS     r2,#3
00001c  2148              MOVS     r1,#0x48
00001e  481c              LDR      r0,|L5.144|
000020  f7fffffe          BL       gpio_init
;;;43     
;;;44     	// UART时钟配置
;;;45     	rcu_periph_clock_enable(RCU_USART1);
000024  f2407011          MOV      r0,#0x711
000028  f7fffffe          BL       rcu_periph_clock_enable
;;;46     	usart_deinit(ARM_UART_TYPE_DEF); // 复位串口
00002c  4819              LDR      r0,|L5.148|
00002e  f7fffffe          BL       usart_deinit
;;;47     
;;;48     	// 串口配置
;;;49     	usart_baudrate_set(ARM_UART_TYPE_DEF, baud);						  // 波特率
000032  4621              MOV      r1,r4
000034  4817              LDR      r0,|L5.148|
000036  f7fffffe          BL       usart_baudrate_set
;;;50     	usart_word_length_set(ARM_UART_TYPE_DEF, USART_WL_8BIT);			  // 8位数据位
00003a  2100              MOVS     r1,#0
00003c  4815              LDR      r0,|L5.148|
00003e  f7fffffe          BL       usart_word_length_set
;;;51     	usart_stop_bit_set(ARM_UART_TYPE_DEF, USART_STB_1BIT);				  // 一个停止位
000042  2100              MOVS     r1,#0
000044  4813              LDR      r0,|L5.148|
000046  f7fffffe          BL       usart_stop_bit_set
;;;52     	usart_parity_config(ARM_UART_TYPE_DEF, USART_PM_NONE);				  // 无奇偶校验
00004a  2100              MOVS     r1,#0
00004c  4811              LDR      r0,|L5.148|
00004e  f7fffffe          BL       usart_parity_config
;;;53     	usart_hardware_flow_rts_config(ARM_UART_TYPE_DEF, USART_RTS_DISABLE); // 无硬件数据流控制
000052  2100              MOVS     r1,#0
000054  480f              LDR      r0,|L5.148|
000056  f7fffffe          BL       usart_hardware_flow_rts_config
;;;54     	usart_hardware_flow_cts_config(ARM_UART_TYPE_DEF, USART_CTS_DISABLE);
00005a  2100              MOVS     r1,#0
00005c  480d              LDR      r0,|L5.148|
00005e  f7fffffe          BL       usart_hardware_flow_cts_config
;;;55     	usart_transmit_config(ARM_UART_TYPE_DEF, USART_TRANSMIT_ENABLE); // 使能发射
000062  2108              MOVS     r1,#8
000064  480b              LDR      r0,|L5.148|
000066  f7fffffe          BL       usart_transmit_config
;;;56     	usart_receive_config(ARM_UART_TYPE_DEF, USART_RECEIVE_ENABLE);	 // 使能接收
00006a  2104              MOVS     r1,#4
00006c  4809              LDR      r0,|L5.148|
00006e  f7fffffe          BL       usart_receive_config
;;;57     
;;;58     	// 中断配置
;;;59     	nvic_irq_enable(ARM_UART_IRQn_DEF, 2, 1);
000072  2201              MOVS     r2,#1
000074  2102              MOVS     r1,#2
000076  2026              MOVS     r0,#0x26
000078  f7fffffe          BL       nvic_irq_enable
;;;60     
;;;61     	usart_interrupt_enable(ARM_UART_TYPE_DEF, USART_INT_RBNE); // 开启中断
00007c  f2403105          MOV      r1,#0x305
000080  4804              LDR      r0,|L5.148|
000082  f7fffffe          BL       usart_interrupt_enable
;;;62     
;;;63     	usart_enable(ARM_UART_TYPE_DEF); // 使能串口
000086  4803              LDR      r0,|L5.148|
000088  f7fffffe          BL       usart_enable
;;;64     }
00008c  bd10              POP      {r4,pc}
;;;65     
                          ENDP

00008e  0000              DCW      0x0000
                  |L5.144|
                          DCD      0x40010800
                  |L5.148|
                          DCD      0x40004400

                          AREA ||i.ARM_UART_IR_StartSendData||, CODE, READONLY, ALIGN=2

                  ARM_UART_IR_StartSendData PROC
;;;163    // 启动中断字节发送
;;;164    void ARM_UART_IR_StartSendData(uint8 data)
000000  b510              PUSH     {r4,lr}
;;;165    {
000002  4604              MOV      r4,r0
;;;166    	// 先读SR，再填充DR会把TC标志清掉
;;;167    	usart_flag_get(ARM_UART_TYPE_DEF, USART_FLAG_TC);
000004  2106              MOVS     r1,#6
000006  4806              LDR      r0,|L6.32|
000008  f7fffffe          BL       usart_flag_get
;;;168    
;;;169    	// 发送一个字节
;;;170    	usart_data_transmit(ARM_UART_TYPE_DEF, data);
00000c  4621              MOV      r1,r4
00000e  4804              LDR      r0,|L6.32|
000010  f7fffffe          BL       usart_data_transmit
;;;171    
;;;172    	// 打开发送完成中断
;;;173    	usart_interrupt_enable(ARM_UART_TYPE_DEF, USART_INT_TC);
000014  f2403106          MOV      r1,#0x306
000018  4801              LDR      r0,|L6.32|
00001a  f7fffffe          BL       usart_interrupt_enable
;;;174    }
00001e  bd10              POP      {r4,pc}
;;;175    
                          ENDP

                  |L6.32|
                          DCD      0x40004400

                          AREA ||i.ARM_UART_Init||, CODE, READONLY, ALIGN=2

                  ARM_UART_Init PROC
;;;306    // UART初始化
;;;307    void ARM_UART_Init(void)
000000  b510              PUSH     {r4,lr}
;;;308    {
;;;309    	// ARM串口初始化
;;;310    	ARM_UART_HwInit(ARM_UART_BAUD_RATE);
000002  f44f30e1          MOV      r0,#0x1c200
000006  f7fffffe          BL       ARM_UART_HwInit
;;;311    
;;;312    	// ARM数据结构初始化
;;;313    	ARM_UART_DataStructureInit(&armUartCB);
00000a  4802              LDR      r0,|L7.20|
00000c  f7fffffe          BL       ARM_UART_DataStructureInit
;;;314    }
000010  bd10              POP      {r4,pc}
;;;315    
                          ENDP

000012  0000              DCW      0x0000
                  |L7.20|
                          DCD      armUartCB

                          AREA ||i.ARM_UART_Process||, CODE, READONLY, ALIGN=2

                  ARM_UART_Process PROC
;;;316    // UART模块处理入口
;;;317    void ARM_UART_Process(void)
000000  b510              PUSH     {r4,lr}
;;;318    {
;;;319    	// 发送处理
;;;320    	ARM_UART_TxProcess(&armUartCB);
000002  4802              LDR      r0,|L8.12|
000004  f7fffffe          BL       ARM_UART_TxProcess
;;;321    }
000008  bd10              POP      {r4,pc}
;;;322    
                          ENDP

00000a  0000              DCW      0x0000
                  |L8.12|
                          DCD      armUartCB

                          AREA ||i.ARM_UART_RegisterDataSendService||, CODE, READONLY, ALIGN=2

                  ARM_UART_RegisterDataSendService PROC
;;;323    // 注册数据抛出接口服务
;;;324    void ARM_UART_RegisterDataSendService(void (*service)(uint16 id, uint8 *pData, uint16 length))
000000  4901              LDR      r1,|L9.8|
;;;325    {
;;;326    	armUartCB.receiveDataThrowService = service;
000002  6008              STR      r0,[r1,#0]  ; armUartCB
;;;327    }
000004  4770              BX       lr
;;;328    
                          ENDP

000006  0000              DCW      0x0000
                  |L9.8|
                          DCD      armUartCB

                          AREA ||i.ARM_UART_TxProcess||, CODE, READONLY, ALIGN=1

                  ARM_UART_TxProcess PROC
;;;89     // 发送处理
;;;90     void ARM_UART_TxProcess(ARM_UART_CB *pCB)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;91     {
000004  4604              MOV      r4,r0
;;;92     // 中断方式
;;;93     #if (ARM_UART_TX_MODE == ARM_UART_INTERRUPT_TX_MODE)
;;;94     	uint16 index = pCB->tx.index;						   // 当前发送数据的索引号
000006  f8b474d8          LDRH     r7,[r4,#0x4d8]
;;;95     	uint16 length = pCB->tx.cmdQueue[pCB->tx.head].length; // 当前发送的命令帧的长度
00000a  f8b404d4          LDRH     r0,[r4,#0x4d4]
00000e  214d              MOVS     r1,#0x4d
000010  4348              MULS     r0,r1,r0
000012  1d21              ADDS     r1,r4,#4
000014  eb010040          ADD      r0,r1,r0,LSL #1
000018  f8b08098          LDRH     r8,[r0,#0x98]
;;;96     	uint16 head = pCB->tx.head;							   // 发送命令帧队列头索引号
00001c  f8b454d4          LDRH     r5,[r4,#0x4d4]
;;;97     	uint16 end = pCB->tx.end;							   // 发送命令帧队列尾索引号
000020  f8b494d6          LDRH     r9,[r4,#0x4d6]
;;;98     
;;;99     	// 参数合法性检验
;;;100    	if (NULL == pCB)
000024  b90c              CBNZ     r4,|L10.42|
                  |L10.38|
;;;101    	{
;;;102    		return;
;;;103    	}
;;;104    
;;;105    	// 队列为空，不处理
;;;106    	if (head == end)
;;;107    	{
;;;108    		return;
;;;109    	}
;;;110    
;;;111    	// 发送忙，退出
;;;112    	if (pCB->tx.txBusy)
;;;113    	{
;;;114    		return;
;;;115    	}
;;;116    
;;;117    	// ■■执行到这里，说明队列非空■■
;;;118    
;;;119    	// 当前命令帧未发送完时，取出一个字节放到发送寄存器中
;;;120    	if (index < length)
;;;121    	{
;;;122    		ARM_UART_IR_StartSendData(pCB->tx.cmdQueue[head].buff[pCB->tx.index++]);
;;;123    
;;;124    		// 设置发送忙状态
;;;125    		pCB->tx.txBusy = TRUE;
;;;126    	}
;;;127    
;;;128    // 阻塞方式时启动发送
;;;129    #else
;;;130    	uint16 index = pCB->tx.index;
;;;131    	uint16 head = pCB->tx.head;
;;;132    	uint16 end = pCB->tx.end;
;;;133    
;;;134    	// 参数合法性检验
;;;135    	if (NULL == pCB)
;;;136    	{
;;;137    		return;
;;;138    	}
;;;139    
;;;140    	// 队列为空，不处理
;;;141    	if (head == end)
;;;142    	{
;;;143    		return;
;;;144    	}
;;;145    
;;;146    	// 当前命令帧未发送完时，持续发送
;;;147    	while (index < pCB->tx.cmdQueue[head].length)
;;;148    	{
;;;149    		// 一直填充发送
;;;150    		ARM_UART_BC_SendData(pCB->tx.cmdQueue[head].buff[pCB->tx.index++]);
;;;151    
;;;152    		index = pCB->tx.index;
;;;153    	}
;;;154    
;;;155    	// 当前命令帧发送完时，删除之
;;;156    	pCB->tx.cmdQueue[head].length = 0;
;;;157    	pCB->tx.head++;
;;;158    	pCB->tx.head %= ARM_UART_DRIVE_TX_QUEUE_SIZE;
;;;159    	pCB->tx.index = 0;
;;;160    #endif
;;;161    }
000026  e8bd87f0          POP      {r4-r10,pc}
                  |L10.42|
00002a  454d              CMP      r5,r9                 ;106
00002c  d100              BNE      |L10.48|
00002e  e7fa              B        |L10.38|
                  |L10.48|
000030  f89404da          LDRB     r0,[r4,#0x4da]        ;112
000034  b100              CBZ      r0,|L10.56|
000036  e7f6              B        |L10.38|
                  |L10.56|
000038  4547              CMP      r7,r8                 ;120
00003a  da10              BGE      |L10.94|
00003c  f8b464d8          LDRH     r6,[r4,#0x4d8]        ;122
000040  1c71              ADDS     r1,r6,#1              ;122
000042  f8a414d8          STRH     r1,[r4,#0x4d8]        ;122
000046  214d              MOVS     r1,#0x4d              ;122
000048  4369              MULS     r1,r5,r1              ;122
00004a  1d22              ADDS     r2,r4,#4              ;122
00004c  eb020141          ADD      r1,r2,r1,LSL #1       ;122
000050  1c89              ADDS     r1,r1,#2              ;122
000052  5d88              LDRB     r0,[r1,r6]            ;122
000054  f7fffffe          BL       ARM_UART_IR_StartSendData
000058  2101              MOVS     r1,#1                 ;125
00005a  f88414da          STRB     r1,[r4,#0x4da]        ;125
                  |L10.94|
00005e  bf00              NOP      
000060  e7e1              B        |L10.38|
;;;162    
                          ENDP


                          AREA ||i.BLE_PROTOCOL_SendLockOk||, CODE, READONLY, ALIGN=2

                  BLE_PROTOCOL_SendLockOk PROC
;;;190    // 发送lock 应答
;;;191    void BLE_PROTOCOL_SendLockOk(uint32 param)
000000  b51e              PUSH     {r1-r4,lr}
;;;192    {
000002  4604              MOV      r4,r0
;;;193    	uint8 bleMacStr[] = "TTM:LOCK-OK";
000004  a205              ADR      r2,|L11.28|
000006  ca07              LDM      r2,{r0-r2}
000008  e88d0007          STM      sp,{r0-r2}
;;;194    
;;;195    	// 使能BLE发送
;;;196    	ARM_BRTS_TX_REQUEST();
;;;197    
;;;198    	// 将待发送命令添加到物理层缓冲区
;;;199    	ARM_UART_AddTxArray(0xFFFF, bleMacStr, sizeof(bleMacStr));
00000c  220c              MOVS     r2,#0xc
00000e  4669              MOV      r1,sp
000010  f64f70ff          MOV      r0,#0xffff
000014  f7fffffe          BL       ARM_UART_AddTxArray
;;;200    }
000018  bd1e              POP      {r1-r4,pc}
;;;201    
                          ENDP

00001a  0000              DCW      0x0000
                  |L11.28|
00001c  54544d3a          DCB      "TTM:LOCK-OK",0
000020  4c4f434b
000024  2d4f4b00

                          AREA ||i.USART1_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART1_IRQHandler PROC
;;;219     *************************************************************/
;;;220    void USART1_IRQHandler(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;221    {
;;;222    	// 判断DR是否有数据，中断接收
;;;223    	if (usart_interrupt_flag_get(ARM_UART_TYPE_DEF, USART_INT_FLAG_RBNE) != RESET)
000002  4955              LDR      r1,|L12.344|
000004  4855              LDR      r0,|L12.348|
000006  f7fffffe          BL       usart_interrupt_flag_get
00000a  b328              CBZ      r0,|L12.88|
;;;224    	{
;;;225    		uint8 rxdata = 0x00;
00000c  2000              MOVS     r0,#0
00000e  9000              STR      r0,[sp,#0]
;;;226    
;;;227    		// 接收数据
;;;228    		rxdata = (uint8)usart_data_receive(ARM_UART_TYPE_DEF);
000010  4852              LDR      r0,|L12.348|
000012  f7fffffe          BL       usart_data_receive
000016  b2c0              UXTB     r0,r0
000018  9000              STR      r0,[sp,#0]
;;;229    
;;;230    		if (NULL != armUartCB.receiveDataThrowService)
00001a  4851              LDR      r0,|L12.352|
00001c  6800              LDR      r0,[r0,#0]  ; armUartCB
00001e  b130              CBZ      r0,|L12.46|
;;;231    		{
;;;232    			(*armUartCB.receiveDataThrowService)(0xFFF, &rxdata, 1);
000020  484f              LDR      r0,|L12.352|
000022  2201              MOVS     r2,#1
000024  4669              MOV      r1,sp
000026  6803              LDR      r3,[r0,#0]  ; armUartCB
000028  f64070ff          MOV      r0,#0xfff
00002c  4798              BLX      r3
                  |L12.46|
;;;233    		}
;;;234    
;;;235    		if (!armUartCB.rcvBleMacOK)
;;;236    		{
;;;237    			//			BLE_UART_AtChannelDataProcess(rxdata);
;;;238    		}
;;;239    
;;;240    		//=================================================================
;;;241    		// 蓝牙连接判断
;;;242    		if ((bleIndex + 1) < sizeof(armRxBuff) / sizeof(armRxBuff[0]))
00002e  484d              LDR      r0,|L12.356|
000030  7800              LDRB     r0,[r0,#0]  ; bleIndex
000032  1c40              ADDS     r0,r0,#1
000034  28c8              CMP      r0,#0xc8
000036  d20e              BCS      |L12.86|
;;;243    		{
;;;244    			armRxBuff[bleIndex++] = rxdata;
000038  f89d1000          LDRB     r1,[sp,#0]
00003c  4849              LDR      r0,|L12.356|
00003e  7802              LDRB     r2,[r0,#0]  ; bleIndex
000040  7800              LDRB     r0,[r0,#0]  ; bleIndex
000042  1c40              ADDS     r0,r0,#1
000044  4b47              LDR      r3,|L12.356|
000046  7018              STRB     r0,[r3,#0]
000048  4847              LDR      r0,|L12.360|
00004a  5481              STRB     r1,[r0,r2]
;;;245    			armRxBuff[bleIndex] = '\0';
00004c  2000              MOVS     r0,#0
00004e  4946              LDR      r1,|L12.360|
000050  461a              MOV      r2,r3
000052  7812              LDRB     r2,[r2,#0]  ; bleIndex
000054  5488              STRB     r0,[r1,r2]
                  |L12.86|
;;;246    		}
;;;247    	}
000056  bf00              NOP      
                  |L12.88|
;;;248    
;;;249    // 中断模式发送
;;;250    #if (ARM_UART_TX_MODE == ARM_UART_INTERRUPT_TX_MODE)
;;;251    	// 判断DR是否有数据，中断发送
;;;252    	if (usart_interrupt_flag_get(ARM_UART_TYPE_DEF, USART_INT_FLAG_TC) != RESET)
000058  4944              LDR      r1,|L12.364|
00005a  4840              LDR      r0,|L12.348|
00005c  f7fffffe          BL       usart_interrupt_flag_get
000060  2800              CMP      r0,#0
000062  d06b              BEQ      |L12.316|
;;;253    	{
;;;254    		uint16 head = armUartCB.tx.head;
000064  483e              LDR      r0,|L12.352|
000066  f8b044d4          LDRH     r4,[r0,#0x4d4]
;;;255    		uint16 end;
;;;256    		uint16 index = armUartCB.tx.index;
00006a  f8b074d8          LDRH     r7,[r0,#0x4d8]
;;;257    		uint8 txdata = 0x00;
00006e  2500              MOVS     r5,#0
;;;258    
;;;259    		// 执行到这里，说明上一个数据已经发送完毕，当前命令帧未发送完时，取出一个字节放到发送寄存器中
;;;260    		if (index < armUartCB.tx.cmdQueue[head].length)
000070  204d              MOVS     r0,#0x4d
000072  4360              MULS     r0,r4,r0
000074  493a              LDR      r1,|L12.352|
000076  1d09              ADDS     r1,r1,#4
000078  eb010040          ADD      r0,r1,r0,LSL #1
00007c  f8b00098          LDRH     r0,[r0,#0x98]
000080  42b8              CMP      r0,r7
000082  dd14              BLE      |L12.174|
;;;261    		{
;;;262    			txdata = armUartCB.tx.cmdQueue[head].buff[armUartCB.tx.index++];
000084  1f09              SUBS     r1,r1,#4
000086  f8b104d8          LDRH     r0,[r1,#0x4d8]
00008a  1c41              ADDS     r1,r0,#1
00008c  b28a              UXTH     r2,r1
00008e  4934              LDR      r1,|L12.352|
000090  f8a124d8          STRH     r2,[r1,#0x4d8]
000094  214d              MOVS     r1,#0x4d
000096  4361              MULS     r1,r4,r1
000098  4a31              LDR      r2,|L12.352|
00009a  1d12              ADDS     r2,r2,#4
00009c  eb020141          ADD      r1,r2,r1,LSL #1
0000a0  1c89              ADDS     r1,r1,#2
0000a2  5c0d              LDRB     r5,[r1,r0]
;;;263    
;;;264    			// 填充数据
;;;265    			usart_data_transmit(ARM_UART_TYPE_DEF, txdata);
0000a4  4629              MOV      r1,r5
0000a6  482d              LDR      r0,|L12.348|
0000a8  f7fffffe          BL       usart_data_transmit
0000ac  e045              B        |L12.314|
                  |L12.174|
;;;266    		}
;;;267    		// 当前命令帧发送完时，删除之
;;;268    		else
;;;269    		{
;;;270    			armUartCB.tx.cmdQueue[head].length = 0;
0000ae  2200              MOVS     r2,#0
0000b0  204d              MOVS     r0,#0x4d
0000b2  4360              MULS     r0,r4,r0
0000b4  492a              LDR      r1,|L12.352|
0000b6  1d09              ADDS     r1,r1,#4
0000b8  eb010040          ADD      r0,r1,r0,LSL #1
0000bc  f8a02098          STRH     r2,[r0,#0x98]
;;;271    			armUartCB.tx.head++;
0000c0  1f08              SUBS     r0,r1,#4
0000c2  f8b004d4          LDRH     r0,[r0,#0x4d4]
0000c6  1c40              ADDS     r0,r0,#1
0000c8  b281              UXTH     r1,r0
0000ca  4825              LDR      r0,|L12.352|
0000cc  f8a014d4          STRH     r1,[r0,#0x4d4]
;;;272    			armUartCB.tx.head %= ARM_UART_DRIVE_TX_QUEUE_SIZE;
0000d0  4601              MOV      r1,r0
0000d2  f8b104d4          LDRH     r0,[r1,#0x4d4]
0000d6  17c1              ASRS     r1,r0,#31
0000d8  eb007151          ADD      r1,r0,r1,LSR #29
0000dc  10c9              ASRS     r1,r1,#3
0000de  eba001c1          SUB      r1,r0,r1,LSL #3
0000e2  b28a              UXTH     r2,r1
0000e4  491e              LDR      r1,|L12.352|
0000e6  f8a124d4          STRH     r2,[r1,#0x4d4]
;;;273    			armUartCB.tx.index = 0;
0000ea  2100              MOVS     r1,#0
0000ec  481c              LDR      r0,|L12.352|
0000ee  f8a014d8          STRH     r1,[r0,#0x4d8]
;;;274    
;;;275    			head = armUartCB.tx.head;
0000f2  f8b044d4          LDRH     r4,[r0,#0x4d4]
;;;276    			end = armUartCB.tx.end;
0000f6  f8b064d6          LDRH     r6,[r0,#0x4d6]
;;;277    
;;;278    			// 命令帧队列非空，继续发送下一个命令帧
;;;279    			if (head != end)
0000fa  42b4              CMP      r4,r6
0000fc  d014              BEQ      |L12.296|
;;;280    			{
;;;281    				txdata = armUartCB.tx.cmdQueue[head].buff[armUartCB.tx.index++];
0000fe  4601              MOV      r1,r0
000100  f8b104d8          LDRH     r0,[r1,#0x4d8]
000104  1c41              ADDS     r1,r0,#1
000106  b28a              UXTH     r2,r1
000108  4915              LDR      r1,|L12.352|
00010a  f8a124d8          STRH     r2,[r1,#0x4d8]
00010e  214d              MOVS     r1,#0x4d
000110  4361              MULS     r1,r4,r1
000112  4a13              LDR      r2,|L12.352|
000114  1d12              ADDS     r2,r2,#4
000116  eb020141          ADD      r1,r2,r1,LSL #1
00011a  1c89              ADDS     r1,r1,#2
00011c  5c0d              LDRB     r5,[r1,r0]
;;;282    
;;;283    				// 填充数据
;;;284    				usart_data_transmit(ARM_UART_TYPE_DEF, txdata);
00011e  4629              MOV      r1,r5
000120  480e              LDR      r0,|L12.348|
000122  f7fffffe          BL       usart_data_transmit
000126  e008              B        |L12.314|
                  |L12.296|
;;;285    			}
;;;286    			// 命令帧队列为空停止发送，设置空闲
;;;287    			else
;;;288    			{
;;;289    				// 关闭发送完成中断
;;;290    				usart_interrupt_disable(ARM_UART_TYPE_DEF, USART_INT_TC);
000128  f2403106          MOV      r1,#0x306
00012c  480b              LDR      r0,|L12.348|
00012e  f7fffffe          BL       usart_interrupt_disable
;;;291    
;;;292    				armUartCB.tx.txBusy = FALSE;
000132  2100              MOVS     r1,#0
000134  480a              LDR      r0,|L12.352|
000136  f88014da          STRB     r1,[r0,#0x4da]
                  |L12.314|
;;;293    			}
;;;294    		}
;;;295    	}
00013a  bf00              NOP      
                  |L12.316|
;;;296    #endif
;;;297    
;;;298    	// Other USARTx interrupts handler can go here ...
;;;299    	if (usart_interrupt_flag_get(ARM_UART_TYPE_DEF, USART_INT_FLAG_ERR_ORERR) != RESET) //----------------------- 接收溢出中断
00013c  490c              LDR      r1,|L12.368|
00013e  4807              LDR      r0,|L12.348|
000140  f7fffffe          BL       usart_interrupt_flag_get
000144  b130              CBZ      r0,|L12.340|
;;;300    	{
;;;301    		usart_flag_get(ARM_UART_TYPE_DEF, USART_FLAG_ORERR); 							//----------------------- 清除接收溢出中断标志位
000146  2103              MOVS     r1,#3
000148  4804              LDR      r0,|L12.348|
00014a  f7fffffe          BL       usart_flag_get
;;;302    		usart_data_receive(ARM_UART_TYPE_DEF);				 							//----------------------- 清空寄存器
00014e  4803              LDR      r0,|L12.348|
000150  f7fffffe          BL       usart_data_receive
                  |L12.340|
;;;303    	}
;;;304    }
000154  bdf8              POP      {r3-r7,pc}
;;;305    
                          ENDP

000156  0000              DCW      0x0000
                  |L12.344|
                          DCD      0x00050305
                  |L12.348|
                          DCD      0x40004400
                  |L12.352|
                          DCD      armUartCB
                  |L12.356|
                          DCD      bleIndex
                  |L12.360|
                          DCD      armRxBuff
                  |L12.364|
                          DCD      0x00060306
                  |L12.368|
                          DCD      0x00030500

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  armUartCB
                          %        1320
                  armRxBuff
                          %        200
                  callringBuff
                          %        20

                          AREA ||.data||, DATA, ALIGN=0

                  bleIndex
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "User\\ArmUart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_ArmUart_c_19c7a808____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___9_ArmUart_c_19c7a808____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_ArmUart_c_19c7a808____REVSH|
#line 128
|__asm___9_ArmUart_c_19c7a808____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
