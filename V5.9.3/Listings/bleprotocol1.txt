; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\bleprotocol1.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\bleprotocol1.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -I.\User\qrencode -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.1\Device\Include -D__MICROLIB -D__UVISION_VERSION=534 -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\bleprotocol1.crf User\BleProtocol1.c]
                          THUMB

                          AREA ||i.BLE_PROTOCOL1_CheckSUM||, CODE, READONLY, ALIGN=1

                  BLE_PROTOCOL1_CheckSUM PROC
;;;416    // 对传入的命令帧进行校验，返回校验结果
;;;417    BOOL BLE_PROTOCOL1_CheckSUM(BLE_PROTOCOL1_RX_CMD_FRAME* pCmdFrame)
000000  b510              PUSH     {r4,lr}
;;;418    {
000002  4604              MOV      r4,r0
;;;419    	uint8 cc = 0;
;;;420    
;;;421    	if (NULL == pCmdFrame)
000004  2c00              CMP      r4,#0
000006  d00e              BEQ      |L1.38|
;;;422    	{
;;;423    		return FALSE;
;;;424    	}
;;;425    
;;;426    	// CRC8校验
;;;427    	cc = CRC8_Table(pCmdFrame->buff, pCmdFrame->length-1);
000008  f8940098          LDRB     r0,[r4,#0x98]
00000c  1e40              SUBS     r0,r0,#1
00000e  b2c1              UXTB     r1,r0
000010  1ca0              ADDS     r0,r4,#2
000012  f7fffffe          BL       CRC8_Table
;;;428    
;;;429    	// 判断计算得到的校验码与命令帧中的校验码是否相同
;;;430    	if (pCmdFrame->buff[pCmdFrame->length-1] != cc)
000016  f8b41098          LDRH     r1,[r4,#0x98]
00001a  1c64              ADDS     r4,r4,#1
00001c  5d09              LDRB     r1,[r1,r4]
00001e  4281              CMP      r1,r0
000020  d003              BEQ      |L1.42|
;;;431    	{
;;;432    		return FALSE;
000022  2000              MOVS     r0,#0
;;;433    	}
;;;434    	
;;;435    	return TRUE;
;;;436    }
000024  bd10              POP      {r4,pc}
                  |L1.38|
000026  2000              MOVS     r0,#0                 ;423
000028  bd10              POP      {r4,pc}
                  |L1.42|
00002a  2001              MOVS     r0,#1                 ;435
00002c  bd10              POP      {r4,pc}
;;;437    
                          ENDP


                          AREA ||i.BLE_PROTOCOL1_CmdFrameProcess||, CODE, READONLY, ALIGN=2

                  BLE_PROTOCOL1_CmdFrameProcess PROC
;;;438    // BLE命令帧缓冲区处理
;;;439    void BLE_PROTOCOL1_CmdFrameProcess(BLE_PROTOCOL1_CB* pCB)
000000  b570              PUSH     {r4-r6,lr}
;;;440    {
;;;441    	BLE_PROTOCOL1_CMD cmd = BLE_PROTOCOL1_CMD_MAX;
;;;442    	BLE_PROTOCOL1_RX_CMD_FRAME* pCmdFrame = NULL;
;;;443    	uint8 rand = 0x00;
;;;444    	uint8 i = 0;
000002  2200              MOVS     r2,#0
;;;445    	
;;;446    	// 参数合法性检验
;;;447    	if(NULL == pCB)
000004  2800              CMP      r0,#0
000006  d017              BEQ      |L2.56|
;;;448    	{
;;;449    		return;
;;;450    	}
;;;451    
;;;452    	// 命令帧缓冲区为空，退出
;;;453    	if(pCB->rx.head == pCB->rx.end)
000008  f8b03434          LDRH     r3,[r0,#0x434]
00000c  f8b01436          LDRH     r1,[r0,#0x436]
000010  428b              CMP      r3,r1
000012  d011              BEQ      |L2.56|
;;;454    	{
;;;455    		return;
;;;456    	}
;;;457    
;;;458    	// 获取当前要处理的命令帧指针
;;;459    	pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.head];
000014  214d              MOVS     r1,#0x4d
000016  4359              MULS     r1,r3,r1
000018  eb000141          ADD      r1,r0,r1,LSL #1
00001c  f5017199          ADD      r1,r1,#0x132
;;;460    	
;;;461    	// 命令头非法，退出
;;;462    	if(BLE_PROTOCOL1_CMD_HEAD != pCmdFrame->buff[BLE_PROTOCOL1_CMD_HEAD_INDEX])
;;;463    	{
;;;464    		// 删除命令帧
;;;465    		pCB->rx.head ++;
;;;466    		pCB->rx.head %= BLE_PROTOCOL1_RX_QUEUE_SIZE;
000020  2605              MOVS     r6,#5
000022  788c              LDRB     r4,[r1,#2]            ;462
000024  2ca3              CMP      r4,#0xa3              ;462
000026  d008              BEQ      |L2.58|
000028  1c5b              ADDS     r3,r3,#1              ;465
00002a  b299              UXTH     r1,r3                 ;465
00002c  fbb1f2f6          UDIV     r2,r1,r6
000030  fb061112          MLS      r1,r6,r2,r1
000034  f8a01434          STRH     r1,[r0,#0x434]
                  |L2.56|
;;;467    		return;
;;;468    	}
;;;469    
;;;470    	// 还原加密数据
;;;471    	pCmdFrame->buff[BLE_PROTOCOL1_CMD_RAND_INDEX] = pCmdFrame->buff[BLE_PROTOCOL1_CMD_RAND_INDEX] - 0x32;
;;;472    	rand = pCmdFrame->buff[BLE_PROTOCOL1_CMD_RAND_INDEX];
;;;473    	
;;;474    	for (i = 0; i < pCmdFrame->buff[BLE_PROTOCOL1_CMD_LENGTH_INDEX]+2; i++)
;;;475    	{
;;;476    		pCmdFrame->buff[BLE_PROTOCOL1_CMD_KEY_INDEX+i] ^= rand;
;;;477    	}
;;;478    
;;;479    	// 命令头合法，则提取命令
;;;480    	cmd = (BLE_PROTOCOL1_CMD)pCmdFrame->buff[BLE_PROTOCOL1_CMD_CMD_INDEX];
;;;481    	
;;;482    	// 执行命令帧
;;;483    	switch (cmd)
;;;484    	{
;;;485    		// 获取通信 KEY指令
;;;486    		case BLE_PROTOCOL1_KEY_CMD:
;;;487    
;;;488    //			TIMER_KillTask(TIMER_ID_BLE_LOCK_PAIR);
;;;489    			PARAM_SetLockKey(pCmdFrame->buff[BLE_PROTOCOL1_CMD_KEY_INDEX]);
;;;490    			PARAM_SetLockKeyFlag(TRUE);
;;;491    			break;
;;;492    
;;;493    		// 指令错误提示指令
;;;494    		case BLE_PROTOCOL1_HINT_CMD:
;;;495    			break;
;;;496    
;;;497    		// 开锁指令
;;;498    		case BLE_PROTOCOL1_OPEN_LOCK_CMD:
;;;499    			break;
;;;500    		
;;;501    		default:
;;;502    			break;
;;;503    	}
;;;504    
;;;505    	// 启动UART总线通讯超时判断
;;;506    	BLE_PROTOCOL1_StartTimeoutCheckTask();
;;;507    	
;;;508    	// 删除命令帧
;;;509    	pCB->rx.head ++;
;;;510    	pCB->rx.head %= BLE_PROTOCOL1_RX_QUEUE_SIZE;
;;;511    }
000038  bd70              POP      {r4-r6,pc}
                  |L2.58|
00003a  794b              LDRB     r3,[r1,#5]            ;471
00003c  3b32              SUBS     r3,r3,#0x32           ;471
00003e  b2dc              UXTB     r4,r3                 ;471
000040  714c              STRB     r4,[r1,#5]            ;471
000042  e005              B        |L2.80|
                  |L2.68|
000044  188b              ADDS     r3,r1,r2              ;476
000046  799d              LDRB     r5,[r3,#6]            ;476
000048  4065              EORS     r5,r5,r4              ;476
00004a  719d              STRB     r5,[r3,#6]            ;476
00004c  1c52              ADDS     r2,r2,#1              ;474
00004e  b2d2              UXTB     r2,r2                 ;474
                  |L2.80|
000050  790b              LDRB     r3,[r1,#4]            ;474
000052  1c9b              ADDS     r3,r3,#2              ;474
000054  4293              CMP      r3,r2                 ;474
000056  d8f5              BHI      |L2.68|
000058  79ca              LDRB     r2,[r1,#7]            ;480
00005a  2a01              CMP      r2,#1                 ;483
00005c  d106              BNE      |L2.108|
00005e  798a              LDRB     r2,[r1,#6]            ;489
000060  4909              LDR      r1,|L2.136|
000062  f8812211          STRB     r2,[r1,#0x211]        ;489
000066  2201              MOVS     r2,#1                 ;490
000068  f8812212          STRB     r2,[r1,#0x212]        ;490
                  |L2.108|
00006c  f7fffffe          BL       BLE_PROTOCOL1_StartTimeoutCheckTask
000070  f8b01434          LDRH     r1,[r0,#0x434]        ;509
000074  1c49              ADDS     r1,r1,#1              ;509
000076  b289              UXTH     r1,r1                 ;509
000078  fbb1f2f6          UDIV     r2,r1,r6              ;510
00007c  fb061112          MLS      r1,r6,r2,r1           ;510
000080  f8a01434          STRH     r1,[r0,#0x434]        ;510
000084  bd70              POP      {r4-r6,pc}
;;;512    
                          ENDP

000086  0000              DCW      0x0000
                  |L2.136|
                          DCD      paramCB

                          AREA ||i.BLE_PROTOCOL1_ConfirmTempCmdFrameBuff||, CODE, READONLY, ALIGN=1

                  BLE_PROTOCOL1_ConfirmTempCmdFrameBuff PROC
;;;225    // 将临时缓冲区添加到命令帧缓冲区中，其本质操作是承认临时缓冲区数据有效
;;;226    BOOL BLE_PROTOCOL1_ConfirmTempCmdFrameBuff(BLE_PROTOCOL1_CB* pCB)
000000  2800              CMP      r0,#0
;;;227    {
000002  d01a              BEQ      |L3.58|
;;;228    	BLE_PROTOCOL1_RX_CMD_FRAME* pCmdFrame = NULL;
;;;229    	
;;;230    	// 参数合法性检验
;;;231    	if(NULL == pCB)
;;;232    	{
;;;233    		return FALSE;
;;;234    	}
;;;235    
;;;236    	// 临时缓冲区为空，不予添加
;;;237    	pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.end];
000004  f8b01436          LDRH     r1,[r0,#0x436]
000008  224d              MOVS     r2,#0x4d
00000a  434a              MULS     r2,r1,r2
00000c  eb000242          ADD      r2,r0,r2,LSL #1
;;;238    	if(0 == pCmdFrame->length)
000010  f8b221ca          LDRH     r2,[r2,#0x1ca]
000014  b19a              CBZ      r2,|L3.62|
;;;239    	{
;;;240    		return FALSE;
;;;241    	}
;;;242    
;;;243    	// 添加
;;;244    	pCB->rx.end ++;
000016  1c49              ADDS     r1,r1,#1
000018  b289              UXTH     r1,r1
;;;245    	pCB->rx.end %= BLE_PROTOCOL1_RX_QUEUE_SIZE;
00001a  2205              MOVS     r2,#5
00001c  fbb1f3f2          UDIV     r3,r1,r2
000020  fb021113          MLS      r1,r2,r3,r1
000024  f8a01436          STRH     r1,[r0,#0x436]
;;;246    	pCB->rx.cmdQueue[pCB->rx.end].length = 0;	// 该行的作用是将新的添加位置有效数据个数清零，以便将这个位置当做临时帧缓冲区
000028  2200              MOVS     r2,#0
00002a  234d              MOVS     r3,#0x4d
00002c  4359              MULS     r1,r3,r1
00002e  eb000041          ADD      r0,r0,r1,LSL #1
000032  f8a021ca          STRH     r2,[r0,#0x1ca]
;;;247    	
;;;248    	return TRUE;
000036  2001              MOVS     r0,#1
;;;249    }
000038  4770              BX       lr
                  |L3.58|
00003a  2000              MOVS     r0,#0                 ;233
00003c  4770              BX       lr
                  |L3.62|
00003e  2000              MOVS     r0,#0                 ;240
000040  4770              BX       lr
;;;250    
                          ENDP


                          AREA ||i.BLE_PROTOCOL1_DataStructInit||, CODE, READONLY, ALIGN=1

                  BLE_PROTOCOL1_DataStructInit PROC
;;;167    // 数据结构初始化
;;;168    void BLE_PROTOCOL1_DataStructInit(BLE_PROTOCOL1_CB* pCB)
000000  2800              CMP      r0,#0
;;;169    {
000002  d019              BEQ      |L4.56|
;;;170    	uint16 i;
;;;171    	
;;;172    	// 参数合法性检验
;;;173    	if (NULL == pCB)
;;;174    	{
;;;175    		return;
;;;176    	}
;;;177    
;;;178    	pCB->tx.length = 0;
000004  2200              MOVS     r2,#0
000006  f8a024d0          STRH     r2,[r0,#0x4d0]
;;;179    
;;;180    	pCB->rxFIFO.head = 0;
00000a  f8a0212c          STRH     r2,[r0,#0x12c]
;;;181    	pCB->rxFIFO.end = 0;
00000e  f8a0212e          STRH     r2,[r0,#0x12e]
;;;182    	pCB->rxFIFO.currentProcessIndex = 0;
000012  f8a02130          STRH     r2,[r0,#0x130]
;;;183    
;;;184    	pCB->rx.head = 0;
000016  f8a02434          STRH     r2,[r0,#0x434]
;;;185    	pCB->rx.end  = 0;
00001a  f8a02436          STRH     r2,[r0,#0x436]
;;;186    	for(i=0; i<BLE_PROTOCOL1_RX_QUEUE_SIZE; i++)
00001e  2100              MOVS     r1,#0
                  |L4.32|
;;;187    	{
;;;188    		pCB->rx.cmdQueue[i].length = 0;
000020  234d              MOVS     r3,#0x4d
000022  434b              MULS     r3,r1,r3
000024  eb000343          ADD      r3,r0,r3,LSL #1
000028  f8a321ca          STRH     r2,[r3,#0x1ca]
00002c  1c49              ADDS     r1,r1,#1              ;186
00002e  b289              UXTH     r1,r1                 ;186
000030  2905              CMP      r1,#5                 ;186
000032  d3f5              BCC      |L4.32|
;;;189    	}
;;;190    
;;;191    	pCB->isTimeCheck = FALSE;
000034  f88024dc          STRB     r2,[r0,#0x4dc]
                  |L4.56|
;;;192    }
000038  4770              BX       lr
;;;193    
                          ENDP


                          AREA ||i.BLE_PROTOCOL1_Init||, CODE, READONLY, ALIGN=2

                  BLE_PROTOCOL1_Init PROC
;;;89     // 协议初始化
;;;90     void BLE_PROTOCOL1_Init(void)
000000  4801              LDR      r0,|L5.8|
;;;91     {
;;;92     	// 协议层数据结构初始化
;;;93     	BLE_PROTOCOL1_DataStructInit(&bleProtocolCB1);
000002  f7ffbffe          B.W      BLE_PROTOCOL1_DataStructInit
;;;94     }
;;;95     
                          ENDP

000006  0000              DCW      0x0000
                  |L5.8|
                          DCD      ||.bss||

                          AREA ||i.BLE_PROTOCOL1_MacProcess||, CODE, READONLY, ALIGN=2

                  BLE_PROTOCOL1_MacProcess PROC
;;;194    // UART报文接收处理函数(注意根据具体模块修改)
;;;195    void BLE_PROTOCOL1_MacProcess(uint16 standarID, uint8* pData, uint16 length)
000000  b570              PUSH     {r4-r6,lr}
;;;196    {
;;;197    	uint16 end = bleProtocolCB1.rxFIFO.end;
000002  480e              LDR      r0,|L6.60|
000004  f8b0212e          LDRH     r2,[r0,#0x12e]  ; bleProtocolCB1
;;;198    	uint16 head = bleProtocolCB1.rxFIFO.head;
000008  f8b0412c          LDRH     r4,[r0,#0x12c]  ; bleProtocolCB1
;;;199    	uint8 rxdata = 0x00;
;;;200    	
;;;201    	// 接收数据
;;;202    	rxdata = *pData;
00000c  780d              LDRB     r5,[r1,#0]
;;;203    
;;;204    	// 一级缓冲区已满，不予接收
;;;205    	if((end + 1)%BLE_PROTOCOL1_RX_FIFO_SIZE == head)
00000e  1c53              ADDS     r3,r2,#1
000010  f44f7196          MOV      r1,#0x12c
000014  fbb3f6f1          UDIV     r6,r3,r1
000018  fb013316          MLS      r3,r1,r6,r3
00001c  42a3              CMP      r3,r4
00001e  d00b              BEQ      |L6.56|
;;;206    	{
;;;207    		return;
;;;208    	}
;;;209    	// 一级缓冲区未满，接收 
;;;210    	else
;;;211    	{
;;;212    		// 将接收到的数据放到临时缓冲区中
;;;213    		bleProtocolCB1.rxFIFO.buff[end] = rxdata;
000020  5485              STRB     r5,[r0,r2]
;;;214    		bleProtocolCB1.rxFIFO.end ++;
000022  f5007097          ADD      r0,r0,#0x12e
000026  8802              LDRH     r2,[r0,#0]  ; bleProtocolCB1
000028  1c52              ADDS     r2,r2,#1
00002a  8002              STRH     r2,[r0,#0]
;;;215    		bleProtocolCB1.rxFIFO.end %= BLE_PROTOCOL1_RX_FIFO_SIZE;
00002c  8802              LDRH     r2,[r0,#0]  ; bleProtocolCB1
00002e  fbb2f3f1          UDIV     r3,r2,r1
000032  fb012113          MLS      r1,r1,r3,r2
000036  8001              STRH     r1,[r0,#0]
                  |L6.56|
;;;216    	}	
;;;217    }
000038  bd70              POP      {r4-r6,pc}
;;;218    
                          ENDP

00003a  0000              DCW      0x0000
                  |L6.60|
                          DCD      ||.bss||

                          AREA ||i.BLE_PROTOCOL1_Process||, CODE, READONLY, ALIGN=2

                  BLE_PROTOCOL1_Process PROC
;;;96     // BLE协议层过程处理
;;;97     void BLE_PROTOCOL1_Process(void)
000000  b500              PUSH     {lr}
;;;98     {
;;;99     	// BLE接收FIFO缓冲区处理
;;;100    	BLE_PROTOCOL1_RxFIFOProcess(&bleProtocolCB1);
000002  4804              LDR      r0,|L7.20|
000004  f7fffffe          BL       BLE_PROTOCOL1_RxFIFOProcess
;;;101    
;;;102    	// BLE接收命令缓冲区处理
;;;103    	BLE_PROTOCOL1_CmdFrameProcess(&bleProtocolCB1);	
000008  4802              LDR      r0,|L7.20|
00000a  f85deb04          POP      {lr}
00000e  f7ffbffe          B.W      BLE_PROTOCOL1_CmdFrameProcess
;;;104    }
;;;105    
                          ENDP

000012  0000              DCW      0x0000
                  |L7.20|
                          DCD      ||.bss||

                          AREA ||i.BLE_PROTOCOL1_RegisterDataSendService||, CODE, READONLY, ALIGN=2

                  BLE_PROTOCOL1_RegisterDataSendService PROC
;;;219    // UART协议层向驱动层注册数据发送接口
;;;220    void BLE_PROTOCOL1_RegisterDataSendService(BOOL (*service)(uint16 id, uint8 *pData, uint16 length))
000000  4901              LDR      r1,|L8.8|
;;;221    {		
;;;222    	bleProtocolCB1.sendDataThrowService = service;
000002  f8c104d4          STR      r0,[r1,#0x4d4]  ; bleProtocolCB1
;;;223    }
000006  4770              BX       lr
;;;224    
                          ENDP

                  |L8.8|
                          DCD      ||.bss||

                          AREA ||i.BLE_PROTOCOL1_RxFIFOProcess||, CODE, READONLY, ALIGN=1

                  BLE_PROTOCOL1_RxFIFOProcess PROC
;;;257    // 一级接收缓冲区处理，从一级接收缓冲区中取出一个字节添加到命令帧缓冲区中
;;;258    void BLE_PROTOCOL1_RxFIFOProcess(BLE_PROTOCOL1_CB* pCB)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;259    {
000004  4604              MOV      r4,r0
;;;260    	uint16 end = pCB->rxFIFO.end;
000006  f8b4112e          LDRH     r1,[r4,#0x12e]
;;;261    	uint16 head = pCB->rxFIFO.head;
00000a  f8b4012c          LDRH     r0,[r4,#0x12c]
;;;262    	BLE_PROTOCOL1_RX_CMD_FRAME* pCmdFrame = NULL;
;;;263    	uint16 length = 0;
;;;264    	uint8 currentData = 0;
;;;265    	
;;;266    	// 参数合法性检验
;;;267    	if(NULL == pCB)
00000e  2c00              CMP      r4,#0
000010  d024              BEQ      |L9.92|
;;;268    	{
;;;269    		return;
;;;270    	}
;;;271    	
;;;272    	// 一级缓冲区为空，退出
;;;273    	if(head == end)
000012  4288              CMP      r0,r1
000014  d022              BEQ      |L9.92|
;;;274    	{
;;;275    		return;
;;;276    	}
;;;277    
;;;278    	// 获取临时缓冲区指针
;;;279    	pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.end];
000016  f8b42436          LDRH     r2,[r4,#0x436]
00001a  204d              MOVS     r0,#0x4d
00001c  4350              MULS     r0,r2,r0
00001e  eb040540          ADD      r5,r4,r0,LSL #1
000022  f5057599          ADD      r5,r5,#0x132
;;;280    	// 取出当前要处理的字节
;;;281    	currentData = pCB->rxFIFO.buff[pCB->rxFIFO.currentProcessIndex];
000026  f8b40130          LDRH     r0,[r4,#0x130]
00002a  5c20              LDRB     r0,[r4,r0]
;;;282    	
;;;283    	// 临时缓冲区长度为0时，搜索首字节
;;;284    	if (0 == pCmdFrame->length)
00002c  f8b53098          LDRH     r3,[r5,#0x98]
;;;285    	{
;;;286    		// 命令头错误，删除当前字节并退出
;;;287    		if(BLE_PROTOCOL1_CMD_HEAD != currentData)
;;;288    		{
;;;289    			pCB->rxFIFO.head ++;
;;;290    			pCB->rxFIFO.head %= BLE_PROTOCOL1_RX_FIFO_SIZE;
000030  f44f7796          MOV      r7,#0x12c
000034  b1a3              CBZ      r3,|L9.96|
;;;291    			pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;292    
;;;293    			return;
;;;294    		}
;;;295    		
;;;296    		// 命令头正确，但无临时缓冲区可用，退出
;;;297    		if ((pCB->rx.end + 1)%BLE_PROTOCOL1_RX_QUEUE_SIZE == pCB->rx.head)
;;;298    		{
;;;299    			return;
;;;300    		}
;;;301    
;;;302    		// 添加UART通讯超时时间设置-2016.1.5增加
;;;303    #if BLE_PROTOCOL1_RX_TIME_OUT_CHECK_ENABLE
;;;304    		TIMER_AddTask(TIMER_ID_UART_RX_TIME_OUT_CONTROL,
;;;305    						BLE_PROTOCOL1_BUS_UNIDIRECTIONAL_TIME_OUT,
;;;306    						BLE_PROTOCOL1_CALLBACK_RxTimeOut,
;;;307    						0,
;;;308    						1,
;;;309    						ACTION_MODE_ADD_TO_QUEUE);
;;;310    #endif
;;;311    		
;;;312    		// 命令头正确，有临时缓冲区可用，则将其添加到命令帧临时缓冲区中
;;;313    		pCmdFrame->buff[pCmdFrame->length++]= currentData;
;;;314    		pCB->rxFIFO.currentProcessIndex ++;
;;;315    		pCB->rxFIFO.currentProcessIndex %= BLE_PROTOCOL1_RX_FIFO_SIZE;
;;;316    	}
;;;317    	// 非首字节，将数据添加到命令帧临时缓冲区中，但暂不删除当前数据
;;;318    	else
;;;319    	{
;;;320    		// 临时缓冲区溢出，说明当前正在接收的命令帧是错误的，正确的命令帧不会出现长度溢出的情况
;;;321    		if (pCmdFrame->length >= BLE_PROTOCOL1_RX_CMD_FRAME_LENGTH_MAX)
000036  f04f0800          MOV      r8,#0
00003a  2b96              CMP      r3,#0x96
00003c  d37e              BCC      |L9.316|
;;;322    		{
;;;323    #if BLE_PROTOCOL1_RX_TIME_OUT_CHECK_ENABLE
;;;324    			// 停止RX通讯超时检测
;;;325    			BLE_PROTOCOL1_StopRxTimeOutCheck();
;;;326    #endif
;;;327    
;;;328    			// 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;329    			pCmdFrame->length = 0;	// 2016.1.5增加
00003e  f8a58098          STRH     r8,[r5,#0x98]
;;;330    			// 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;331    			pCB->rxFIFO.head ++;
000042  f5047496          ADD      r4,r4,#0x12c
000046  8820              LDRH     r0,[r4,#0]
000048  1c40              ADDS     r0,r0,#1
00004a  8020              STRH     r0,[r4,#0]
;;;332    			pCB->rxFIFO.head %= BLE_PROTOCOL1_RX_FIFO_SIZE;
00004c  8820              LDRH     r0,[r4,#0]
00004e  fbb0f1f7          UDIV     r1,r0,r7
000052  fb070011          MLS      r0,r7,r1,r0
000056  8020              STRH     r0,[r4,#0]
;;;333    			pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
000058  8820              LDRH     r0,[r4,#0]
00005a  80a0              STRH     r0,[r4,#4]
                  |L9.92|
;;;334    
;;;335    			return;
;;;336    		}
;;;337    
;;;338    		// 一直取到末尾
;;;339    		while (end != pCB->rxFIFO.currentProcessIndex)
;;;340    		{
;;;341    			// 取出当前要处理的字节
;;;342    			currentData = pCB->rxFIFO.buff[pCB->rxFIFO.currentProcessIndex];
;;;343    			// 缓冲区未溢出，正常接收，将数据添加到临时缓冲区中
;;;344    			pCmdFrame->buff[pCmdFrame->length++] = currentData;
;;;345    			pCB->rxFIFO.currentProcessIndex ++;
;;;346    			pCB->rxFIFO.currentProcessIndex %= BLE_PROTOCOL1_RX_FIFO_SIZE;
;;;347    
;;;348    			// ■■接下来，需要检查命令帧是否完整，如果完整，则将命令帧临时缓冲区扶正 ■■
;;;349    						
;;;350    			// 首先判断命令帧最小长度，一个完整的命令字至少包括4个字节: 命令帧最小长度，包含:命令头、命令字、数据长度、校验和，因此不足4个字节的必定不完整
;;;351    			if(pCmdFrame->length < BLE_PROTOCOL1_CMD_FRAME_LENGTH_MIN)
;;;352    			{
;;;353    				// 继续接收
;;;354    				continue;
;;;355    			}
;;;356    
;;;357    			// 命令帧长度数值越界，说明当前命令帧错误，停止接收
;;;358    			if (pCmdFrame->buff[BLE_PROTOCOL1_CMD_LENGTH_INDEX] > (BLE_PROTOCOL1_RX_CMD_FRAME_LENGTH_MAX - BLE_PROTOCOL1_CMD_FRAME_LENGTH_MIN))
;;;359    			{
;;;360    #if BLE_PROTOCOL1_RX_TIME_OUT_CHECK_ENABLE
;;;361    				// 停止RX通讯超时检测
;;;362    				BLE_PROTOCOL1_StopRxTimeOutCheck();
;;;363    #endif
;;;364    			
;;;365    				// 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;366    				pCmdFrame->length = 0;
;;;367    				// 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;368    				pCB->rxFIFO.head ++;
;;;369    				pCB->rxFIFO.head %= BLE_PROTOCOL1_RX_FIFO_SIZE;
;;;370    				pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;371    
;;;372    				return;
;;;373    			}
;;;374    
;;;375    			// 命令帧长度校验
;;;376    			length = pCmdFrame->length;
;;;377    			if(length < pCmdFrame->buff[BLE_PROTOCOL1_CMD_LENGTH_INDEX] + BLE_PROTOCOL1_CMD_FRAME_LENGTH_MIN)
;;;378    			{
;;;379    				// 长度要求不一致，说明未接收完毕，退出继续
;;;380    				continue;
;;;381    			}
;;;382    
;;;383    			// 命令帧长度OK，则进行校验，失败时删除命令头
;;;384    			if (!BLE_PROTOCOL1_CheckSUM(pCmdFrame))
;;;385    			{
;;;386    #if BLE_PROTOCOL1_RX_TIME_OUT_CHECK_ENABLE
;;;387    				// 停止RX通讯超时检测
;;;388    				BLE_PROTOCOL1_StopRxTimeOutCheck();
;;;389    #endif
;;;390    				
;;;391    				// 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;392    				pCmdFrame->length = 0;
;;;393    				// 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;394    				pCB->rxFIFO.head ++;
;;;395    				pCB->rxFIFO.head %= BLE_PROTOCOL1_RX_FIFO_SIZE;
;;;396    				pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;397    				
;;;398    				return;
;;;399    			}
;;;400    
;;;401    #if BLE_PROTOCOL1_RX_TIME_OUT_CHECK_ENABLE
;;;402    			// 停止RX通讯超时检测
;;;403    			BLE_PROTOCOL1_StopRxTimeOutCheck();
;;;404    #endif
;;;405    			
;;;406    			// 执行到这里，即说明接收到了一个完整并且正确的命令帧，此时需将处理过的数据从一级缓冲区中删除，并将该命令帧扶正
;;;407    			pCB->rxFIFO.head += length;
;;;408    			pCB->rxFIFO.head %= BLE_PROTOCOL1_RX_FIFO_SIZE;
;;;409    			pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;410    			BLE_PROTOCOL1_ConfirmTempCmdFrameBuff(pCB);
;;;411    			return;
;;;412    		}
;;;413    	}
;;;414    }
00005c  e8bd81f0          POP      {r4-r8,pc}
                  |L9.96|
000060  28a3              CMP      r0,#0xa3              ;287
000062  d00d              BEQ      |L9.128|
000064  f5047496          ADD      r4,r4,#0x12c          ;289
000068  8820              LDRH     r0,[r4,#0]            ;289
00006a  1c40              ADDS     r0,r0,#1              ;289
00006c  8020              STRH     r0,[r4,#0]            ;289
00006e  8820              LDRH     r0,[r4,#0]            ;290
000070  fbb0f1f7          UDIV     r1,r0,r7              ;290
000074  fb070011          MLS      r0,r7,r1,r0           ;290
000078  8020              STRH     r0,[r4,#0]            ;290
00007a  8820              LDRH     r0,[r4,#0]            ;291
00007c  80a0              STRH     r0,[r4,#4]            ;291
00007e  e7ed              B        |L9.92|
                  |L9.128|
000080  1c52              ADDS     r2,r2,#1              ;297
000082  2105              MOVS     r1,#5                 ;297
000084  fbb2f3f1          UDIV     r3,r2,r1              ;297
000088  fb012113          MLS      r1,r1,r3,r2           ;297
00008c  f8b42434          LDRH     r2,[r4,#0x434]        ;297
000090  4291              CMP      r1,r2                 ;297
000092  d0e3              BEQ      |L9.92|
000094  2101              MOVS     r1,#1                 ;313
000096  f8a51098          STRH     r1,[r5,#0x98]         ;313
00009a  70a8              STRB     r0,[r5,#2]            ;313
00009c  f8b40130          LDRH     r0,[r4,#0x130]        ;314
0000a0  1c40              ADDS     r0,r0,#1              ;314
0000a2  b280              UXTH     r0,r0                 ;314
0000a4  fbb0f1f7          UDIV     r1,r0,r7              ;315
0000a8  fb070011          MLS      r0,r7,r1,r0           ;315
0000ac  f8a40130          STRH     r0,[r4,#0x130]        ;315
0000b0  e7d4              B        |L9.92|
                  |L9.178|
0000b2  5c22              LDRB     r2,[r4,r0]            ;342
0000b4  f8b50098          LDRH     r0,[r5,#0x98]         ;344
0000b8  1c43              ADDS     r3,r0,#1              ;344
0000ba  4428              ADD      r0,r0,r5              ;344
0000bc  f8a53098          STRH     r3,[r5,#0x98]         ;344
0000c0  7082              STRB     r2,[r0,#2]            ;344
0000c2  f8b40130          LDRH     r0,[r4,#0x130]        ;345
0000c6  1c40              ADDS     r0,r0,#1              ;345
0000c8  b280              UXTH     r0,r0                 ;345
0000ca  fbb0f2f7          UDIV     r2,r0,r7              ;346
0000ce  fb070012          MLS      r0,r7,r2,r0           ;346
0000d2  f8a40130          STRH     r0,[r4,#0x130]        ;346
0000d6  f8b56098          LDRH     r6,[r5,#0x98]         ;351
0000da  2e07              CMP      r6,#7                 ;351
0000dc  d33f              BCC      |L9.350|
0000de  7928              LDRB     r0,[r5,#4]            ;358
0000e0  288f              CMP      r0,#0x8f              ;358
0000e2  d90f              BLS      |L9.260|
0000e4  f8a58098          STRH     r8,[r5,#0x98]         ;366
0000e8  f5047496          ADD      r4,r4,#0x12c          ;368
0000ec  8820              LDRH     r0,[r4,#0]            ;368
0000ee  1c40              ADDS     r0,r0,#1              ;368
0000f0  8020              STRH     r0,[r4,#0]            ;368
0000f2  8820              LDRH     r0,[r4,#0]            ;369
0000f4  fbb0f1f7          UDIV     r1,r0,r7              ;369
0000f8  fb070011          MLS      r0,r7,r1,r0           ;369
0000fc  8020              STRH     r0,[r4,#0]            ;369
0000fe  8820              LDRH     r0,[r4,#0]            ;370
000100  80a0              STRH     r0,[r4,#4]            ;370
000102  e7ab              B        |L9.92|
                  |L9.260|
000104  1dc0              ADDS     r0,r0,#7              ;377
000106  42b0              CMP      r0,r6                 ;377
000108  d829              BHI      |L9.350|
00010a  4628              MOV      r0,r5                 ;384
00010c  f7fffffe          BL       BLE_PROTOCOL1_CheckSUM
000110  b198              CBZ      r0,|L9.314|
000112  f5047496          ADD      r4,r4,#0x12c          ;407
000116  8820              LDRH     r0,[r4,#0]            ;407
000118  4430              ADD      r0,r0,r6              ;407
00011a  8020              STRH     r0,[r4,#0]            ;407
00011c  8820              LDRH     r0,[r4,#0]            ;408
00011e  fbb0f1f7          UDIV     r1,r0,r7              ;408
000122  fb070011          MLS      r0,r7,r1,r0           ;408
000126  8020              STRH     r0,[r4,#0]            ;408
000128  8820              LDRH     r0,[r4,#0]            ;409
00012a  80a0              STRH     r0,[r4,#4]            ;409
00012c  f5a47496          SUB      r4,r4,#0x12c          ;409
000130  4620              MOV      r0,r4                 ;410
000132  e8bd41f0          POP      {r4-r8,lr}            ;410
000136  f7ffbffe          B.W      BLE_PROTOCOL1_ConfirmTempCmdFrameBuff
                  |L9.314|
00013a  e000              B        |L9.318|
                  |L9.316|
00013c  e00f              B        |L9.350|
                  |L9.318|
00013e  f8a58098          STRH     r8,[r5,#0x98]         ;392
000142  f5047496          ADD      r4,r4,#0x12c          ;394
000146  8820              LDRH     r0,[r4,#0]            ;394
000148  1c40              ADDS     r0,r0,#1              ;394
00014a  8020              STRH     r0,[r4,#0]            ;394
00014c  8820              LDRH     r0,[r4,#0]            ;395
00014e  fbb0f1f7          UDIV     r1,r0,r7              ;395
000152  fb070011          MLS      r0,r7,r1,r0           ;395
000156  8020              STRH     r0,[r4,#0]            ;395
000158  8820              LDRH     r0,[r4,#0]            ;396
00015a  80a0              STRH     r0,[r4,#4]            ;396
00015c  e77e              B        |L9.92|
                  |L9.350|
00015e  f8b40130          LDRH     r0,[r4,#0x130]        ;339
000162  4288              CMP      r0,r1                 ;339
000164  d1a5              BNE      |L9.178|
000166  e779              B        |L9.92|
;;;415    
                          ENDP


                          AREA ||i.BLE_PROTOCOL1_StartTimeoutCheckTask||, CODE, READONLY, ALIGN=1

                  BLE_PROTOCOL1_StartTimeoutCheckTask PROC
;;;84     // 启动通讯超时判断任务
;;;85     void BLE_PROTOCOL1_StartTimeoutCheckTask(void)
000000  4770              BX       lr
;;;86     {
;;;87     }
;;;88     
                          ENDP


                          AREA ||i.BLE_PROTOCOL1_TxAddData||, CODE, READONLY, ALIGN=2

                  BLE_PROTOCOL1_TxAddData PROC
;;;106    // 向发送命令帧队列中添加数据
;;;107    void BLE_PROTOCOL1_TxAddData(uint8 data)
000000  4905              LDR      r1,|L11.24|
;;;108    {
;;;109    	BLE_PROTOCOL1_TX_CMD_FRAME* pCmdFrame = &bleProtocolCB1.tx;
;;;110    
;;;111    	// 队尾命令帧已满，退出
;;;112    	if(pCmdFrame->length >= BLE_PROTOCOL1_TX_CMD_FRAME_LENGTH_MAX)
000002  f8b12098          LDRH     r2,[r1,#0x98]
000006  2a96              CMP      r2,#0x96
000008  d205              BCS      |L11.22|
;;;113    	{
;;;114    		return;
;;;115    	}
;;;116    
;;;117    	// 数据添加到帧末尾，并更新帧长度
;;;118    	pCmdFrame->buff[pCmdFrame->length] = data;
00000a  1c8b              ADDS     r3,r1,#2
00000c  54d0              STRB     r0,[r2,r3]
;;;119    	pCmdFrame->length ++;
00000e  f8310f98          LDRH     r0,[r1,#0x98]!
000012  1c40              ADDS     r0,r0,#1
000014  8008              STRH     r0,[r1,#0]
                  |L11.22|
;;;120    }
000016  4770              BX       lr
;;;121    
                          ENDP

                  |L11.24|
                          DCD      ||.bss||+0x438

                          AREA ||i.BLE_PROTOCOL1_TxAddFrame||, CODE, READONLY, ALIGN=2

                  BLE_PROTOCOL1_TxAddFrame PROC
;;;122    // 确认添加命令帧，即承认之前填充的数据为命令帧，将其添加到发送队列中，由main进行调度发送，本函数内会自动校正命令长度，并添加校验码
;;;123    uint8 BLE_PROTOCOL1_TxAddFrame(uint8 data[])
000000  b5f0              PUSH     {r4-r7,lr}
;;;124    {
000002  4606              MOV      r6,r0
;;;125    	uint8 rand = 0x00;
;;;126    	uint16 i = 0;
000004  2000              MOVS     r0,#0
;;;127    	BLE_PROTOCOL1_TX_CMD_FRAME* pCmdFrame = &bleProtocolCB1.tx;
000006  4c1e              LDR      r4,|L12.128|
;;;128    	uint16 length = pCmdFrame->length;
000008  f8b45098          LDRH     r5,[r4,#0x98]
;;;129    
;;;130    	// 命令帧长度不足，清除已填充的数据，退出
;;;131    	if (BLE_PROTOCOL1_CMD_FRAME_LENGTH_MIN-1 > length)	// 减去"校验和"1个字节
00000c  2700              MOVS     r7,#0
00000e  2d06              CMP      r5,#6
000010  d202              BCS      |L12.24|
;;;132    	{
;;;133    		pCmdFrame->length = 0;
000012  f8a47098          STRH     r7,[r4,#0x98]
;;;134    		
;;;135    		return 0;
;;;136    	}
;;;137    
;;;138    	// 队尾命令帧已满，退出
;;;139    	if (length >= BLE_PROTOCOL1_TX_CMD_FRAME_LENGTH_MAX)
;;;140    	{
;;;141    		return 0;
;;;142    	}
;;;143    
;;;144    	// 重新设置数据长度，系统在准备数据时，填充的"数据长度"可以为任意值，并且不需要添加校验码，在这里重新设置为正确的值
;;;145    	pCmdFrame->buff[BLE_PROTOCOL1_CMD_LENGTH_INDEX] = length - (BLE_PROTOCOL1_CMD_FRAME_LENGTH_MIN-1);	// 重设数据长度
;;;146    	rand = pCmdFrame->buff[BLE_PROTOCOL1_CMD_RAND_INDEX];
;;;147    	pCmdFrame->buff[BLE_PROTOCOL1_CMD_RAND_INDEX] =  pCmdFrame->buff[BLE_PROTOCOL1_CMD_RAND_INDEX] + 0x32;
;;;148    
;;;149    	for (i = 0; i < pCmdFrame->buff[BLE_PROTOCOL1_CMD_LENGTH_INDEX] + 2; i++)
;;;150    	{
;;;151    		pCmdFrame->buff[BLE_PROTOCOL1_CMD_KEY_INDEX + i] ^= rand;
;;;152    	}
;;;153    	
;;;154    	pCmdFrame->buff[pCmdFrame->length++] = CRC8_Table(pCmdFrame->buff, pCmdFrame->length);
;;;155    	length++;
;;;156    
;;;157    	for (i = 0; i < pCmdFrame->length; i++)
;;;158    	{
;;;159    		data[i] = pCmdFrame->buff[i];
;;;160    	}
;;;161    	
;;;162    	pCmdFrame->length = 0;
;;;163    
;;;164    	return length;
;;;165    }
000016  bdf0              POP      {r4-r7,pc}
                  |L12.24|
000018  2d96              CMP      r5,#0x96              ;139
00001a  d301              BCC      |L12.32|
00001c  2000              MOVS     r0,#0                 ;141
00001e  bdf0              POP      {r4-r7,pc}
                  |L12.32|
000020  1fa9              SUBS     r1,r5,#6              ;145
000022  7121              STRB     r1,[r4,#4]            ;145
000024  7963              LDRB     r3,[r4,#5]            ;146
000026  f1030132          ADD      r1,r3,#0x32           ;147
00002a  7161              STRB     r1,[r4,#5]            ;147
00002c  e005              B        |L12.58|
                  |L12.46|
00002e  1821              ADDS     r1,r4,r0              ;151
000030  798a              LDRB     r2,[r1,#6]            ;151
000032  405a              EORS     r2,r2,r3              ;151
000034  718a              STRB     r2,[r1,#6]            ;151
000036  1c40              ADDS     r0,r0,#1              ;149
000038  b280              UXTH     r0,r0                 ;149
                  |L12.58|
00003a  7921              LDRB     r1,[r4,#4]            ;149
00003c  1c89              ADDS     r1,r1,#2              ;149
00003e  4281              CMP      r1,r0                 ;149
000040  d8f5              BHI      |L12.46|
000042  f8941098          LDRB     r1,[r4,#0x98]         ;154
000046  1ca0              ADDS     r0,r4,#2              ;154
000048  f7fffffe          BL       CRC8_Table
00004c  4602              MOV      r2,r0                 ;154
00004e  f8b40098          LDRH     r0,[r4,#0x98]         ;154
000052  1c41              ADDS     r1,r0,#1              ;154
000054  4420              ADD      r0,r0,r4              ;154
000056  f8a41098          STRH     r1,[r4,#0x98]         ;154
00005a  7082              STRB     r2,[r0,#2]            ;154
00005c  1c6d              ADDS     r5,r5,#1              ;155
00005e  b2a9              UXTH     r1,r5                 ;155
000060  2000              MOVS     r0,#0                 ;157
000062  e004              B        |L12.110|
                  |L12.100|
000064  1822              ADDS     r2,r4,r0              ;159
000066  7892              LDRB     r2,[r2,#2]            ;159
000068  5432              STRB     r2,[r6,r0]            ;159
00006a  1c40              ADDS     r0,r0,#1              ;157
00006c  b280              UXTH     r0,r0                 ;157
                  |L12.110|
00006e  f8b42098          LDRH     r2,[r4,#0x98]         ;157
000072  4282              CMP      r2,r0                 ;157
000074  d8f6              BHI      |L12.100|
000076  f8a47098          STRH     r7,[r4,#0x98]         ;162
00007a  b2c8              UXTB     r0,r1                 ;164
00007c  bdf0              POP      {r4-r7,pc}
;;;166    
                          ENDP

00007e  0000              DCW      0x0000
                  |L12.128|
                          DCD      ||.bss||+0x438

                          AREA ||i.BLE_PROTOCOL1_TxStateProcess||, CODE, READONLY, ALIGN=1

                  BLE_PROTOCOL1_TxStateProcess PROC
;;;251    // 协议层发送处理过程
;;;252    void BLE_PROTOCOL1_TxStateProcess(void)
000000  4770              BX       lr
;;;253    {
;;;254    	
;;;255    }
;;;256    
                          ENDP


                          AREA ||i.CRC8_Table||, CODE, READONLY, ALIGN=2

                  CRC8_Table PROC
;;;74     
;;;75     unsigned char CRC8_Table(unsigned char *pucFrame, char usLen)
000000  b510              PUSH     {r4,lr}
;;;76     {
;;;77     	unsigned char crc8 = 0;
000002  2200              MOVS     r2,#0
;;;78     	while(usLen--)
;;;79     	crc8 = CRC8Table[crc8^*(pucFrame++)];
000004  4c05              LDR      r4,|L14.28|
000006  e003              B        |L14.16|
                  |L14.8|
000008  f8103b01          LDRB     r3,[r0],#1
00000c  4053              EORS     r3,r3,r2
00000e  5ce2              LDRB     r2,[r4,r3]
                  |L14.16|
000010  1e49              SUBS     r1,r1,#1              ;78
000012  b2c9              UXTB     r1,r1                 ;78
000014  d2f8              BCS      |L14.8|
;;;80     	return(crc8);
000016  4610              MOV      r0,r2
;;;81     }
000018  bd10              POP      {r4,pc}
;;;82     
                          ENDP

00001a  0000              DCW      0x0000
                  |L14.28|
                          DCD      ||.data||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  bleProtocolCB1
                          %        1248

                          AREA ||.data||, DATA, ALIGN=0

                  CRC8Table
000000  005ebce2          DCB      0x00,0x5e,0xbc,0xe2
000004  613fdd83          DCB      0x61,0x3f,0xdd,0x83
000008  c29c7e20          DCB      0xc2,0x9c,0x7e,0x20
00000c  a3fd1f41          DCB      0xa3,0xfd,0x1f,0x41
000010  9dc3217f          DCB      0x9d,0xc3,0x21,0x7f
000014  fca2401e          DCB      0xfc,0xa2,0x40,0x1e
000018  5f01e3bd          DCB      0x5f,0x01,0xe3,0xbd
00001c  3e6082dc          DCB      0x3e,0x60,0x82,0xdc
000020  237d9fc1          DCB      0x23,0x7d,0x9f,0xc1
000024  421cfea0          DCB      0x42,0x1c,0xfe,0xa0
000028  e1bf5d03          DCB      0xe1,0xbf,0x5d,0x03
00002c  80de3c62          DCB      0x80,0xde,0x3c,0x62
000030  bee0025c          DCB      0xbe,0xe0,0x02,0x5c
000034  df81633d          DCB      0xdf,0x81,0x63,0x3d
000038  7c22c09e          DCB      0x7c,0x22,0xc0,0x9e
00003c  1d43a1ff          DCB      0x1d,0x43,0xa1,0xff
000040  4618faa4          DCB      0x46,0x18,0xfa,0xa4
000044  27799bc5          DCB      0x27,0x79,0x9b,0xc5
000048  84da3866          DCB      0x84,0xda,0x38,0x66
00004c  e5bb5907          DCB      0xe5,0xbb,0x59,0x07
000050  db856739          DCB      0xdb,0x85,0x67,0x39
000054  bae40658          DCB      0xba,0xe4,0x06,0x58
000058  1947a5fb          DCB      0x19,0x47,0xa5,0xfb
00005c  7826c49a          DCB      0x78,0x26,0xc4,0x9a
000060  653bd987          DCB      0x65,0x3b,0xd9,0x87
000064  045ab8e6          DCB      0x04,0x5a,0xb8,0xe6
000068  a7f91b45          DCB      0xa7,0xf9,0x1b,0x45
00006c  c6987a24          DCB      0xc6,0x98,0x7a,0x24
000070  f8a6441a          DCB      0xf8,0xa6,0x44,0x1a
000074  99c7257b          DCB      0x99,0xc7,0x25,0x7b
000078  3a6486d8          DCB      0x3a,0x64,0x86,0xd8
00007c  5b05e7b9          DCB      0x5b,0x05,0xe7,0xb9
000080  8cd2306e          DCB      0x8c,0xd2,0x30,0x6e
000084  edb3510f          DCB      0xed,0xb3,0x51,0x0f
000088  4e10f2ac          DCB      0x4e,0x10,0xf2,0xac
00008c  2f7193cd          DCB      0x2f,0x71,0x93,0xcd
000090  114fadf3          DCB      0x11,0x4f,0xad,0xf3
000094  702ecc92          DCB      0x70,0x2e,0xcc,0x92
000098  d38d6f31          DCB      0xd3,0x8d,0x6f,0x31
00009c  b2ec0e50          DCB      0xb2,0xec,0x0e,0x50
0000a0  aff1134d          DCB      0xaf,0xf1,0x13,0x4d
0000a4  ce90722c          DCB      0xce,0x90,0x72,0x2c
0000a8  6d33d18f          DCB      0x6d,0x33,0xd1,0x8f
0000ac  0c52b0ee          DCB      0x0c,0x52,0xb0,0xee
0000b0  326c8ed0          DCB      0x32,0x6c,0x8e,0xd0
0000b4  530defb1          DCB      0x53,0x0d,0xef,0xb1
0000b8  f0ae4c12          DCB      0xf0,0xae,0x4c,0x12
0000bc  91cf2d73          DCB      0x91,0xcf,0x2d,0x73
0000c0  ca947628          DCB      0xca,0x94,0x76,0x28
0000c4  abf51749          DCB      0xab,0xf5,0x17,0x49
0000c8  0856b4ea          DCB      0x08,0x56,0xb4,0xea
0000cc  6937d58b          DCB      0x69,0x37,0xd5,0x8b
0000d0  5709ebb5          DCB      0x57,0x09,0xeb,0xb5
0000d4  36688ad4          DCB      0x36,0x68,0x8a,0xd4
0000d8  95cb2977          DCB      0x95,0xcb,0x29,0x77
0000dc  f4aa4816          DCB      0xf4,0xaa,0x48,0x16
0000e0  e9b7550b          DCB      0xe9,0xb7,0x55,0x0b
0000e4  88d6346a          DCB      0x88,0xd6,0x34,0x6a
0000e8  2b7597c9          DCB      0x2b,0x75,0x97,0xc9
0000ec  4a14f6a8          DCB      0x4a,0x14,0xf6,0xa8
0000f0  742ac896          DCB      0x74,0x2a,0xc8,0x96
0000f4  154ba9f7          DCB      0x15,0x4b,0xa9,0xf7
0000f8  b6e80a54          DCB      0xb6,0xe8,0x0a,0x54
0000fc  d7896b35          DCB      0xd7,0x89,0x6b,0x35

;*** Start embedded assembler ***

#line 1 "User\\BleProtocol1.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_BleProtocol1_c_7a1562ac____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___14_BleProtocol1_c_7a1562ac____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_BleProtocol1_c_7a1562ac____REVSH|
#line 128
|__asm___14_BleProtocol1_c_7a1562ac____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
