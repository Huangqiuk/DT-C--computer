; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\iap.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\iap.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -I.\User\qrencode -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.3\Device\Include -D__MICROLIB -D__UVISION_VERSION=539 -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\iap.crf User\iap.c]
                          THUMB

                          AREA ||i.IAP_BleWriteAppBin||, CODE, READONLY, ALIGN=2

                  IAP_BleWriteAppBin PROC
;;;174    *******************************************************************************/
;;;175    BOOL IAP_BleWriteAppBin(uint32 appAddr, uint8 *appBuf, uint32 appSize)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;176    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
;;;177    	uint16 i = 0;
00000a  f04f0900          MOV      r9,#0
;;;178    	uint16 j = 0;
00000e  46c8              MOV      r8,r9
;;;179    	uint32 curAppAddr = appAddr; 	// 当前写入的地址
000010  46aa              MOV      r10,r5
;;;180    	uint32 *iapBuf = NULL;
000012  2700              MOVS     r7,#0
;;;181    	BOOL writeStatus;
;;;182    	
;;;183    	// 参数判断
;;;184    	if (NULL == appBuf)
000014  b914              CBNZ     r4,|L1.28|
;;;185    	{
;;;186    		return FALSE;
000016  2000              MOVS     r0,#0
                  |L1.24|
;;;187    	}
;;;188    
;;;189    	// 参数检验是否非法，地址不能是IAP本身代码地址，绝对不能自己把自己擦掉
;;;190    	if ((appAddr < IAP_FLASH_APP1_ADDR) || ((appAddr + appSize) > (IAP_GD32_FLASH_BASE+IAP_GD32_FLASH_SIZE)))
;;;191    	{
;;;192    		return FALSE;		// 非法地址
;;;193    	}
;;;194    
;;;195    	// 开辟临时内存
;;;196    	iapBuf = (uint32 *)malloc(1024);
;;;197    	if (NULL == iapBuf)
;;;198    	{
;;;199    		return FALSE;
;;;200    	}
;;;201    	
;;;202    	// 循环写入
;;;203    	for (i = 0, j = 0; j < appSize; j += 4)
;;;204    	{
;;;205    		// 字节整合
;;;206    		iapBuf[i++] = (uint32)(*appBuf) + ((uint32)(*(appBuf+1)) << 8) + ((uint32)(*(appBuf+2)) << 16) + ((uint32)(*(appBuf+3)) << 24);
;;;207    		// 偏移4个字节
;;;208    		appBuf += 4;
;;;209    	}      
;;;210    	
;;;211    	// 直接写入FLASH
;;;212    	writeStatus = IAP_FlashWriteWordArray(curAppAddr, iapBuf, appSize/4);	
;;;213    	
;;;214    	// 释放内存
;;;215    	free(iapBuf);
;;;216    	
;;;217    	return writeStatus;
;;;218    }
000018  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.28|
00001c  481b              LDR      r0,|L1.140|
00001e  4285              CMP      r5,r0                 ;190
000020  d303              BCC      |L1.42|
000022  19a8              ADDS     r0,r5,r6              ;190
000024  491a              LDR      r1,|L1.144|
000026  4288              CMP      r0,r1                 ;190
000028  d901              BLS      |L1.46|
                  |L1.42|
00002a  2000              MOVS     r0,#0                 ;192
00002c  e7f4              B        |L1.24|
                  |L1.46|
00002e  f44f6080          MOV      r0,#0x400             ;196
000032  f7fffffe          BL       malloc
000036  4607              MOV      r7,r0                 ;196
000038  b90f              CBNZ     r7,|L1.62|
00003a  2000              MOVS     r0,#0                 ;199
00003c  e7ec              B        |L1.24|
                  |L1.62|
00003e  f04f0900          MOV      r9,#0                 ;203
000042  46c8              MOV      r8,r9                 ;203
000044  e014              B        |L1.112|
                  |L1.70|
000046  7820              LDRB     r0,[r4,#0]            ;206
000048  7861              LDRB     r1,[r4,#1]            ;206
00004a  eb002001          ADD      r0,r0,r1,LSL #8       ;206
00004e  78a1              LDRB     r1,[r4,#2]            ;206
000050  eb004001          ADD      r0,r0,r1,LSL #16      ;206
000054  78e1              LDRB     r1,[r4,#3]            ;206
000056  eb006201          ADD      r2,r0,r1,LSL #24      ;206
00005a  4648              MOV      r0,r9                 ;206
00005c  1c41              ADDS     r1,r0,#1              ;206
00005e  fa1ff981          UXTH     r9,r1                 ;206
000062  f8472020          STR      r2,[r7,r0,LSL #2]     ;206
000066  1d24              ADDS     r4,r4,#4              ;208
000068  f1080004          ADD      r0,r8,#4              ;203
00006c  fa1ff880          UXTH     r8,r0                 ;203
                  |L1.112|
000070  45b0              CMP      r8,r6                 ;203
000072  d3e8              BCC      |L1.70|
000074  f3c6028f          UBFX     r2,r6,#2,#16          ;212
000078  4639              MOV      r1,r7                 ;212
00007a  4650              MOV      r0,r10                ;212
00007c  f7fffffe          BL       IAP_FlashWriteWordArray
000080  4683              MOV      r11,r0                ;212
000082  4638              MOV      r0,r7                 ;215
000084  f7fffffe          BL       free
000088  4658              MOV      r0,r11                ;217
00008a  e7c5              B        |L1.24|
;;;219    
                          ENDP

                  |L1.140|
                          DCD      0x08008000
                  |L1.144|
                          DCD      0x08040000

                          AREA ||i.IAP_CheckApp1FlashIsBlank||, CODE, READONLY, ALIGN=1

                  IAP_CheckApp1FlashIsBlank PROC
;;;254    // 查询Flash是否为空
;;;255    BOOL IAP_CheckApp1FlashIsBlank(void)
000000  b530              PUSH     {r4,r5,lr}
;;;256    {
;;;257    	uint16 i;
;;;258    	uint16 j;
;;;259    	uint16 readHalfWord;
;;;260    	uint32 readAddr;
;;;261    	
;;;262    	for (i = (IAP_FLASH_ADRESS_APP1_OFFSET/IAP_STM32_PAGE_SIZE); i < ((IAP_FLASH_ADRESS_APP1_OFFSET + IAP_GD32_APP1_SIZE)/IAP_STM32_PAGE_SIZE); i++)
000002  2210              MOVS     r2,#0x10
000004  e018              B        |L2.56|
                  |L2.6|
;;;263    	{
;;;264    		// 页地址
;;;265    		readAddr = i*IAP_STM32_PAGE_SIZE + IAP_GD32_FLASH_BASE;
000006  f04f6000          MOV      r0,#0x8000000
00000a  eb0025c2          ADD      r5,r0,r2,LSL #11
;;;266    
;;;267    		for (j = 0; j < IAP_STM32_PAGE_SIZE; j += 2)
00000e  2400              MOVS     r4,#0
000010  e00d              B        |L2.46|
                  |L2.18|
;;;268    		{
;;;269    			readHalfWord = IAP_FlashReadHalfWord(readAddr);	// 读
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       IAP_FlashReadHalfWord
000018  4603              MOV      r3,r0
;;;270    		  	readAddr += 2;
00001a  1cad              ADDS     r5,r5,#2
;;;271    
;;;272    			// 全为0xFFFF说明为空
;;;273    			if (readHalfWord == 0xFFFF)
00001c  f64f70ff          MOV      r0,#0xffff
000020  4283              CMP      r3,r0
000022  d100              BNE      |L2.38|
;;;274    			{
;;;275    				continue;
000024  e001              B        |L2.42|
                  |L2.38|
;;;276    			}
;;;277    			else
;;;278    			{
;;;279    				return FALSE;
000026  2000              MOVS     r0,#0
                  |L2.40|
;;;280    			}
;;;281    		}  
;;;282    		
;;;283    	}
;;;284    
;;;285    	return TRUE;
;;;286    }
000028  bd30              POP      {r4,r5,pc}
                  |L2.42|
00002a  1ca0              ADDS     r0,r4,#2              ;267
00002c  b284              UXTH     r4,r0                 ;267
                  |L2.46|
00002e  f5b46f00          CMP      r4,#0x800             ;267
000032  d3ee              BCC      |L2.18|
000034  1c50              ADDS     r0,r2,#1              ;262
000036  b282              UXTH     r2,r0                 ;262
                  |L2.56|
000038  2a80              CMP      r2,#0x80              ;262
00003a  d3e4              BCC      |L2.6|
00003c  2001              MOVS     r0,#1                 ;285
00003e  e7f3              B        |L2.40|
;;;287    
                          ENDP


                          AREA ||i.IAP_CheckApp2FlashIsBlank||, CODE, READONLY, ALIGN=1

                  IAP_CheckApp2FlashIsBlank PROC
;;;288    // 查询Flash是否为空
;;;289    BOOL IAP_CheckApp2FlashIsBlank(void)
000000  b530              PUSH     {r4,r5,lr}
;;;290    {
;;;291    	uint16 i;
;;;292    	uint16 j;
;;;293    	uint16 readHalfWord;
;;;294    	uint32 readAddr;
;;;295    	
;;;296    	for (i = (IAP_FLASH_ADRESS_APP2_OFFSET/IAP_STM32_PAGE_SIZE); i < ((IAP_FLASH_ADRESS_APP2_OFFSET + IAP_GD32_APP2_SIZE)/IAP_STM32_PAGE_SIZE); i++)
000002  2220              MOVS     r2,#0x20
000004  e018              B        |L3.56|
                  |L3.6|
;;;297    	{
;;;298    		// 页地址
;;;299    		readAddr = i*IAP_STM32_PAGE_SIZE + IAP_GD32_FLASH_BASE;
000006  f04f6000          MOV      r0,#0x8000000
00000a  eb0025c2          ADD      r5,r0,r2,LSL #11
;;;300    
;;;301    		for (j = 0; j < IAP_STM32_PAGE_SIZE; j += 2)
00000e  2400              MOVS     r4,#0
000010  e00d              B        |L3.46|
                  |L3.18|
;;;302    		{
;;;303    			readHalfWord = IAP_FlashReadHalfWord(readAddr);	// 读
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       IAP_FlashReadHalfWord
000018  4603              MOV      r3,r0
;;;304    		  	readAddr += 2;
00001a  1cad              ADDS     r5,r5,#2
;;;305    
;;;306    			// 全为0xFFFF说明为空
;;;307    			if (readHalfWord == 0xFFFF)
00001c  f64f70ff          MOV      r0,#0xffff
000020  4283              CMP      r3,r0
000022  d100              BNE      |L3.38|
;;;308    			{
;;;309    				continue;
000024  e001              B        |L3.42|
                  |L3.38|
;;;310    			}
;;;311    			else
;;;312    			{
;;;313    				return FALSE;
000026  2000              MOVS     r0,#0
                  |L3.40|
;;;314    			}
;;;315    		}
;;;316    		
;;;317    	}
;;;318    
;;;319    	return TRUE;
;;;320    }
000028  bd30              POP      {r4,r5,pc}
                  |L3.42|
00002a  1ca0              ADDS     r0,r4,#2              ;301
00002c  b284              UXTH     r4,r0                 ;301
                  |L3.46|
00002e  f5b46f00          CMP      r4,#0x800             ;301
000032  d3ee              BCC      |L3.18|
000034  1c50              ADDS     r0,r2,#1              ;296
000036  b282              UXTH     r2,r0                 ;296
                  |L3.56|
000038  2a80              CMP      r2,#0x80              ;296
00003a  d3e4              BCC      |L3.6|
00003c  2001              MOVS     r0,#1                 ;319
00003e  e7f3              B        |L3.40|
;;;321    
                          ENDP


                          AREA ||i.IAP_CheckAppRightful||, CODE, READONLY, ALIGN=2

                  IAP_CheckAppRightful PROC
;;;110    // 判断指定地址APP是否合法
;;;111    uint8 IAP_CheckAppRightful(uint32 addr)
000000  4601              MOV      r1,r0
;;;112    {
;;;113    	// 检查栈顶地址是否合法.
;;;114    	if(((*(uint32*)addr) & 0x2FFE0000) != 0x20000000)	
000002  4a09              LDR      r2,|L4.40|
000004  6808              LDR      r0,[r1,#0]
000006  4010              ANDS     r0,r0,r2
000008  f1b05f00          CMP      r0,#0x20000000
00000c  d001              BEQ      |L4.18|
;;;115    	{
;;;116    		return 0;
00000e  2000              MOVS     r0,#0
                  |L4.16|
;;;117    	}
;;;118    
;;;119    	// APP无效
;;;120    	if (((*(uint32*)(addr+4)) & 0xFFF80000) != 0x08000000)
;;;121    	{
;;;122    		return 0;
;;;123    	}
;;;124    
;;;125    	return 1;
;;;126    }
000010  4770              BX       lr
                  |L4.18|
000012  6848              LDR      r0,[r1,#4]            ;120
000014  f36f0012          BFC      r0,#0,#19             ;120
000018  f1b06f00          CMP      r0,#0x8000000         ;120
00001c  d001              BEQ      |L4.34|
00001e  2000              MOVS     r0,#0                 ;122
000020  e7f6              B        |L4.16|
                  |L4.34|
000022  2001              MOVS     r0,#1                 ;125
000024  e7f4              B        |L4.16|
;;;127    
                          ENDP

000026  0000              DCW      0x0000
                  |L4.40|
                          DCD      0x2ffe0000

                          AREA ||i.IAP_CheckFlashIsBlank||, CODE, READONLY, ALIGN=1

                  IAP_CheckFlashIsBlank PROC
;;;221    // 查询Flash是否为空
;;;222    BOOL IAP_CheckFlashIsBlank(void)
000000  b530              PUSH     {r4,r5,lr}
;;;223    {
;;;224    	uint16 i;
;;;225    	uint16 j;
;;;226    	uint16 readHalfWord;
;;;227    	uint32 readAddr;
;;;228    	
;;;229    	for (i = (IAP_FLASH_ADRESS_APP1_OFFSET/IAP_STM32_PAGE_SIZE); i < (IAP_GD32_FLASH_SIZE/IAP_STM32_PAGE_SIZE); i++)
000002  2210              MOVS     r2,#0x10
000004  e018              B        |L5.56|
                  |L5.6|
;;;230    	{
;;;231    		// 页地址
;;;232    		readAddr = i*IAP_STM32_PAGE_SIZE + IAP_GD32_FLASH_BASE;
000006  f04f6000          MOV      r0,#0x8000000
00000a  eb0025c2          ADD      r5,r0,r2,LSL #11
;;;233    
;;;234    		for (j = 0; j < IAP_STM32_PAGE_SIZE; j += 2)
00000e  2400              MOVS     r4,#0
000010  e00d              B        |L5.46|
                  |L5.18|
;;;235    		{
;;;236    			readHalfWord = IAP_FlashReadHalfWord(readAddr);	// 读
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       IAP_FlashReadHalfWord
000018  4603              MOV      r3,r0
;;;237    		  	readAddr += 2;
00001a  1cad              ADDS     r5,r5,#2
;;;238    
;;;239    			// 全为0xFFFF说明为空
;;;240    			if (readHalfWord == 0xFFFF)
00001c  f64f70ff          MOV      r0,#0xffff
000020  4283              CMP      r3,r0
000022  d100              BNE      |L5.38|
;;;241    			{
;;;242    				continue;
000024  e001              B        |L5.42|
                  |L5.38|
;;;243    			}
;;;244    			else
;;;245    			{
;;;246    				return FALSE;
000026  2000              MOVS     r0,#0
                  |L5.40|
;;;247    			}
;;;248    		}  
;;;249    		
;;;250    	}
;;;251    	return TRUE;
;;;252    }
000028  bd30              POP      {r4,r5,pc}
                  |L5.42|
00002a  1ca0              ADDS     r0,r4,#2              ;234
00002c  b284              UXTH     r4,r0                 ;234
                  |L5.46|
00002e  f5b46f00          CMP      r4,#0x800             ;234
000032  d3ee              BCC      |L5.18|
000034  1c50              ADDS     r0,r2,#1              ;229
000036  b282              UXTH     r2,r0                 ;229
                  |L5.56|
000038  2a80              CMP      r2,#0x80              ;229
00003a  d3e4              BCC      |L5.6|
00003c  2001              MOVS     r0,#1                 ;251
00003e  e7f3              B        |L5.40|
;;;253    
                          ENDP


                          AREA ||i.IAP_EraseAPP1Area||, CODE, READONLY, ALIGN=1

                  IAP_EraseAPP1Area PROC
;;;361    // 擦除APP1所有页
;;;362    BOOL IAP_EraseAPP1Area(void)
000000  b570              PUSH     {r4-r6,lr}
;;;363    {
;;;364    	uint16 i;
;;;365    	fmc_state_enum status = FMC_READY;
000002  2500              MOVS     r5,#0
;;;366    	BOOL eraseStatus = TRUE;
000004  2601              MOVS     r6,#1
;;;367    
;;;368    	DI();				// 关闭总中断
000006  b672              CPSID    i
;;;369    	fmc_unlock();		// 解锁
000008  f7fffffe          BL       fmc_unlock
;;;370    
;;;371    	// 清除所有挂起标志位
;;;372        fmc_flag_clear(FMC_FLAG_BANK0_END);
00000c  f2403005          MOV      r0,#0x305
000010  f7fffffe          BL       fmc_flag_clear
;;;373        fmc_flag_clear(FMC_FLAG_BANK0_WPERR);
000014  f44f7041          MOV      r0,#0x304
000018  f7fffffe          BL       fmc_flag_clear
;;;374        fmc_flag_clear(FMC_FLAG_BANK0_PGERR);
00001c  f2403002          MOV      r0,#0x302
000020  f7fffffe          BL       fmc_flag_clear
;;;375    	
;;;376    	// 擦除APP所有页
;;;377    	for (i = (IAP_FLASH_ADRESS_APP1_OFFSET/IAP_STM32_PAGE_SIZE); i < ((IAP_FLASH_ADRESS_APP1_OFFSET + IAP_GD32_APP1_SIZE)/IAP_STM32_PAGE_SIZE); i++)
000024  2410              MOVS     r4,#0x10
000026  e017              B        |L6.88|
                  |L6.40|
;;;378    	{
;;;379    		status = fmc_page_erase(i*IAP_STM32_PAGE_SIZE + IAP_GD32_FLASH_BASE);
000028  f04f6100          MOV      r1,#0x8000000
00002c  eb0120c4          ADD      r0,r1,r4,LSL #11
000030  f7fffffe          BL       fmc_page_erase
000034  4605              MOV      r5,r0
;;;380    
;;;381    		fmc_flag_clear(FMC_FLAG_BANK0_END);
000036  f2403005          MOV      r0,#0x305
00003a  f7fffffe          BL       fmc_flag_clear
;;;382            fmc_flag_clear(FMC_FLAG_BANK0_WPERR);
00003e  f44f7041          MOV      r0,#0x304
000042  f7fffffe          BL       fmc_flag_clear
;;;383            fmc_flag_clear(FMC_FLAG_BANK0_PGERR);
000046  f2403002          MOV      r0,#0x302
00004a  f7fffffe          BL       fmc_flag_clear
;;;384    		
;;;385    		if (FMC_READY != status)
00004e  b10d              CBZ      r5,|L6.84|
;;;386    		{
;;;387    			eraseStatus = FALSE;
000050  2600              MOVS     r6,#0
;;;388    
;;;389    			break;
000052  e003              B        |L6.92|
                  |L6.84|
000054  1c60              ADDS     r0,r4,#1              ;377
000056  b284              UXTH     r4,r0                 ;377
                  |L6.88|
000058  2c80              CMP      r4,#0x80              ;377
00005a  d3e5              BCC      |L6.40|
                  |L6.92|
00005c  bf00              NOP      
;;;390    		}
;;;391    	}
;;;392    
;;;393    	fmc_lock();			// 上锁
00005e  f7fffffe          BL       fmc_lock
;;;394    	EI(); 				// 开启总中断
000062  b662              CPSIE    i
;;;395    
;;;396    	return eraseStatus;
000064  4630              MOV      r0,r6
;;;397    }
000066  bd70              POP      {r4-r6,pc}
;;;398    
                          ENDP


                          AREA ||i.IAP_EraseAPP2Area||, CODE, READONLY, ALIGN=1

                  IAP_EraseAPP2Area PROC
;;;399    // 擦除APP2所有页
;;;400    BOOL IAP_EraseAPP2Area(void)
000000  b570              PUSH     {r4-r6,lr}
;;;401    {
;;;402    	uint16 i;
;;;403    	fmc_state_enum status = FMC_READY;
000002  2500              MOVS     r5,#0
;;;404    	BOOL eraseStatus = TRUE;
000004  2601              MOVS     r6,#1
;;;405    
;;;406    	DI();				// 关闭总中断
000006  b672              CPSID    i
;;;407    	fmc_unlock();		// 解锁
000008  f7fffffe          BL       fmc_unlock
;;;408    
;;;409    	// 清除所有挂起标志位
;;;410        fmc_flag_clear(FMC_FLAG_BANK0_END);
00000c  f2403005          MOV      r0,#0x305
000010  f7fffffe          BL       fmc_flag_clear
;;;411        fmc_flag_clear(FMC_FLAG_BANK0_WPERR);
000014  f44f7041          MOV      r0,#0x304
000018  f7fffffe          BL       fmc_flag_clear
;;;412        fmc_flag_clear(FMC_FLAG_BANK0_PGERR);
00001c  f2403002          MOV      r0,#0x302
000020  f7fffffe          BL       fmc_flag_clear
;;;413    	
;;;414    	// 擦除APP所有页
;;;415    	for (i = (IAP_FLASH_ADRESS_APP2_OFFSET/IAP_STM32_PAGE_SIZE); i < ((IAP_FLASH_ADRESS_APP2_OFFSET + IAP_GD32_APP2_SIZE)/IAP_STM32_PAGE_SIZE); i++)
000024  2420              MOVS     r4,#0x20
000026  e017              B        |L7.88|
                  |L7.40|
;;;416    	{
;;;417    		status = fmc_page_erase(i*IAP_STM32_PAGE_SIZE + IAP_GD32_FLASH_BASE);
000028  f04f6100          MOV      r1,#0x8000000
00002c  eb0120c4          ADD      r0,r1,r4,LSL #11
000030  f7fffffe          BL       fmc_page_erase
000034  4605              MOV      r5,r0
;;;418    
;;;419    		fmc_flag_clear(FMC_FLAG_BANK0_END);
000036  f2403005          MOV      r0,#0x305
00003a  f7fffffe          BL       fmc_flag_clear
;;;420            fmc_flag_clear(FMC_FLAG_BANK0_WPERR);
00003e  f44f7041          MOV      r0,#0x304
000042  f7fffffe          BL       fmc_flag_clear
;;;421            fmc_flag_clear(FMC_FLAG_BANK0_PGERR);
000046  f2403002          MOV      r0,#0x302
00004a  f7fffffe          BL       fmc_flag_clear
;;;422    
;;;423    		if (FMC_READY != status)
00004e  b10d              CBZ      r5,|L7.84|
;;;424    		{
;;;425    			eraseStatus = FALSE;
000050  2600              MOVS     r6,#0
;;;426    
;;;427    			break;
000052  e003              B        |L7.92|
                  |L7.84|
000054  1c60              ADDS     r0,r4,#1              ;415
000056  b284              UXTH     r4,r0                 ;415
                  |L7.88|
000058  2c80              CMP      r4,#0x80              ;415
00005a  d3e5              BCC      |L7.40|
                  |L7.92|
00005c  bf00              NOP      
;;;428    		}
;;;429    	}
;;;430    
;;;431    	fmc_lock();			// 上锁
00005e  f7fffffe          BL       fmc_lock
;;;432    	EI(); 				// 开启总中断
000062  b662              CPSIE    i
;;;433    
;;;434    	return eraseStatus;
000064  4630              MOV      r0,r6
;;;435    }
000066  bd70              POP      {r4-r6,pc}
;;;436    
                          ENDP


                          AREA ||i.IAP_EraseAPPArea||, CODE, READONLY, ALIGN=1

                  IAP_EraseAPPArea PROC
;;;323    // 擦除APP所有页
;;;324    BOOL IAP_EraseAPPArea(void)
000000  b570              PUSH     {r4-r6,lr}
;;;325    {
;;;326    	uint16 i;
;;;327    	fmc_state_enum status = FMC_READY;
000002  2500              MOVS     r5,#0
;;;328    	BOOL eraseStatus = TRUE;
000004  2601              MOVS     r6,#1
;;;329    
;;;330    	DI();				// 关闭总中断
000006  b672              CPSID    i
;;;331    	fmc_unlock();		// 解锁
000008  f7fffffe          BL       fmc_unlock
;;;332    
;;;333    	// 清除所有挂起标志位
;;;334        fmc_flag_clear(FMC_FLAG_BANK0_END);
00000c  f2403005          MOV      r0,#0x305
000010  f7fffffe          BL       fmc_flag_clear
;;;335        fmc_flag_clear(FMC_FLAG_BANK0_WPERR);
000014  f44f7041          MOV      r0,#0x304
000018  f7fffffe          BL       fmc_flag_clear
;;;336        fmc_flag_clear(FMC_FLAG_BANK0_PGERR);
00001c  f2403002          MOV      r0,#0x302
000020  f7fffffe          BL       fmc_flag_clear
;;;337    	
;;;338    	// 擦除APP所有页
;;;339    	for (i = (IAP_FLASH_ADRESS_APP1_OFFSET/IAP_STM32_PAGE_SIZE); i < (IAP_GD32_FLASH_SIZE/IAP_STM32_PAGE_SIZE); i++)
000024  2410              MOVS     r4,#0x10
000026  e017              B        |L8.88|
                  |L8.40|
;;;340    	{
;;;341    		status = fmc_page_erase(i*IAP_STM32_PAGE_SIZE + IAP_GD32_FLASH_BASE);
000028  f04f6100          MOV      r1,#0x8000000
00002c  eb0120c4          ADD      r0,r1,r4,LSL #11
000030  f7fffffe          BL       fmc_page_erase
000034  4605              MOV      r5,r0
;;;342    
;;;343    		fmc_flag_clear(FMC_FLAG_BANK0_END);
000036  f2403005          MOV      r0,#0x305
00003a  f7fffffe          BL       fmc_flag_clear
;;;344            fmc_flag_clear(FMC_FLAG_BANK0_WPERR);
00003e  f44f7041          MOV      r0,#0x304
000042  f7fffffe          BL       fmc_flag_clear
;;;345            fmc_flag_clear(FMC_FLAG_BANK0_PGERR);
000046  f2403002          MOV      r0,#0x302
00004a  f7fffffe          BL       fmc_flag_clear
;;;346    		
;;;347    		if (FMC_READY != status)
00004e  b10d              CBZ      r5,|L8.84|
;;;348    		{
;;;349    			eraseStatus = FALSE;
000050  2600              MOVS     r6,#0
;;;350    
;;;351    			break;
000052  e003              B        |L8.92|
                  |L8.84|
000054  1c60              ADDS     r0,r4,#1              ;339
000056  b284              UXTH     r4,r0                 ;339
                  |L8.88|
000058  2c80              CMP      r4,#0x80              ;339
00005a  d3e5              BCC      |L8.40|
                  |L8.92|
00005c  bf00              NOP      
;;;352    		}
;;;353    	}
;;;354    
;;;355    	fmc_lock();		// 上锁
00005e  f7fffffe          BL       fmc_lock
;;;356    	EI(); 				// 开启总中断
000062  b662              CPSIE    i
;;;357    
;;;358    	return eraseStatus;
000064  4630              MOV      r0,r6
;;;359    }
000066  bd70              POP      {r4-r6,pc}
;;;360    
                          ENDP


                          AREA ||i.IAP_FlashReadForCrc8||, CODE, READONLY, ALIGN=2

                  IAP_FlashReadForCrc8 PROC
;;;960    *******************************************************************************/
;;;961    uint8 IAP_FlashReadForCrc8(uint32 datalen)
000000  b5f8              PUSH     {r3-r7,lr}
;;;962    {
000002  4603              MOV      r3,r0
;;;963    	uint8 crc = 0;
000004  2000              MOVS     r0,#0
;;;964    	uint8 i,j;
;;;965    	uint8 buf[4] = {0};
000006  2700              MOVS     r7,#0
000008  9700              STR      r7,[sp,#0]
;;;966    	uint32 addrIndex = 0;
00000a  2500              MOVS     r5,#0
;;;967    	uint32 dataTemp;
;;;968    	uint32 len = datalen/4;
00000c  089e              LSRS     r6,r3,#2
;;;969    
;;;970    	while (len--)
00000e  e025              B        |L9.92|
                  |L9.16|
;;;971    	{
;;;972    		dataTemp = *(volatile uint32*)(addrIndex + IAP_FLASH_APP2_ADDR);
000010  4f15              LDR      r7,|L9.104|
000012  59e9              LDR      r1,[r5,r7]
;;;973    		addrIndex += 4;
000014  1d2d              ADDS     r5,r5,#4
;;;974    		// 小端模式
;;;975    		buf[3] = (uint8)(dataTemp >> 24);
000016  0e0f              LSRS     r7,r1,#24
000018  f88d7003          STRB     r7,[sp,#3]
;;;976    		buf[2] = (uint8)(dataTemp >> 16);
00001c  0c0f              LSRS     r7,r1,#16
00001e  f88d7002          STRB     r7,[sp,#2]
;;;977    		buf[1] = (uint8)(dataTemp >> 8);
000022  0a0f              LSRS     r7,r1,#8
000024  f88d7001          STRB     r7,[sp,#1]
;;;978    		buf[0] = (uint8)dataTemp;
000028  b2cf              UXTB     r7,r1
00002a  f88d7000          STRB     r7,[sp,#0]
;;;979    		
;;;980    		for(j = 0; j < 4; j++)
00002e  2200              MOVS     r2,#0
000030  e012              B        |L9.88|
                  |L9.50|
;;;981    		{
;;;982    			crc ^= buf[j];
000032  f81d7002          LDRB     r7,[sp,r2]
000036  4078              EORS     r0,r0,r7
;;;983    			
;;;984    			for (i = 0; i < 8; i++)
000038  2400              MOVS     r4,#0
00003a  e009              B        |L9.80|
                  |L9.60|
;;;985    			{
;;;986    				if (crc & 0x01)
00003c  f0000701          AND      r7,r0,#1
000040  b11f              CBZ      r7,|L9.74|
;;;987    				{
;;;988    					crc = (crc >> 1) ^ 0x8C;
000042  278c              MOVS     r7,#0x8c
000044  ea870060          EOR      r0,r7,r0,ASR #1
000048  e000              B        |L9.76|
                  |L9.74|
;;;989    				}
;;;990    				else
;;;991    				{
;;;992    					crc >>= 1;
00004a  1040              ASRS     r0,r0,#1
                  |L9.76|
00004c  1c67              ADDS     r7,r4,#1              ;984
00004e  b2fc              UXTB     r4,r7                 ;984
                  |L9.80|
000050  2c08              CMP      r4,#8                 ;984
000052  dbf3              BLT      |L9.60|
000054  1c57              ADDS     r7,r2,#1              ;980
000056  b2fa              UXTB     r2,r7                 ;980
                  |L9.88|
000058  2a04              CMP      r2,#4                 ;980
00005a  dbea              BLT      |L9.50|
                  |L9.92|
00005c  1e37              SUBS     r7,r6,#0              ;970
00005e  f1a60601          SUB      r6,r6,#1              ;970
000062  d1d5              BNE      |L9.16|
;;;993    				}
;;;994    			}
;;;995    		}
;;;996    	}
;;;997    	return crc;
;;;998    }
000064  bdf8              POP      {r3-r7,pc}
;;;999    
                          ENDP

000066  0000              DCW      0x0000
                  |L9.104|
                          DCD      0x08010000

                          AREA ||i.IAP_FlashReadHalfWord||, CODE, READONLY, ALIGN=1

                  IAP_FlashReadHalfWord PROC
;;;442    *******************************************************************************/
;;;443    uint16 IAP_FlashReadHalfWord(uint32 flashAddr)
000000  4601              MOV      r1,r0
;;;444    {
;;;445    	return *(volatile uint16*)flashAddr; 
000002  8808              LDRH     r0,[r1,#0]
;;;446    }
000004  4770              BX       lr
;;;447    
                          ENDP


                          AREA ||i.IAP_FlashReadHalfWordArray||, CODE, READONLY, ALIGN=2

                  IAP_FlashReadHalfWordArray PROC
;;;660    *******************************************************************************/
;;;661    void IAP_FlashReadHalfWordArray(uint32 readAddr, uint16 *pBuffer, uint16 numToRead)   	
000000  b530              PUSH     {r4,r5,lr}
;;;662    {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;663    	uint16 i;
;;;664    
;;;665    	// 参数判断
;;;666    	if (NULL == pBuffer)
000008  b904              CBNZ     r4,|L11.12|
                  |L11.10|
;;;667    	{
;;;668    		return;
;;;669    	}
;;;670    
;;;671    	// 参数检验是否非法
;;;672    	if ((readAddr < IAP_GD32_FLASH_BASE) || (readAddr >= (IAP_GD32_FLASH_BASE+IAP_GD32_FLASH_SIZE)))
;;;673    	{
;;;674    		return;	// 非法地址
;;;675    	}
;;;676    	
;;;677    	for (i = 0; i < numToRead; i++)
;;;678    	{
;;;679    		pBuffer[i] = IAP_FlashReadHalfWord(readAddr);	// 读取2个字节.
;;;680    		readAddr += 2; 									// 偏移2个字节.	
;;;681    	}
;;;682    }
00000a  bd30              POP      {r4,r5,pc}
                  |L11.12|
00000c  f1b36f00          CMP      r3,#0x8000000         ;672
000010  d302              BCC      |L11.24|
000012  4809              LDR      r0,|L11.56|
000014  4283              CMP      r3,r0                 ;672
000016  d300              BCC      |L11.26|
                  |L11.24|
000018  e7f7              B        |L11.10|
                  |L11.26|
00001a  2200              MOVS     r2,#0                 ;677
00001c  e007              B        |L11.46|
                  |L11.30|
00001e  4618              MOV      r0,r3                 ;679
000020  f7fffffe          BL       IAP_FlashReadHalfWord
000024  f8240012          STRH     r0,[r4,r2,LSL #1]     ;679
000028  1c9b              ADDS     r3,r3,#2              ;680
00002a  1c50              ADDS     r0,r2,#1              ;677
00002c  b282              UXTH     r2,r0                 ;677
                  |L11.46|
00002e  42aa              CMP      r2,r5                 ;677
000030  dbf5              BLT      |L11.30|
000032  bf00              NOP      
000034  e7e9              B        |L11.10|
;;;683    
                          ENDP

000036  0000              DCW      0x0000
                  |L11.56|
                          DCD      0x08040000

                          AREA ||i.IAP_FlashReadWord||, CODE, READONLY, ALIGN=1

                  IAP_FlashReadWord PROC
;;;809    *******************************************************************************/
;;;810    uint32 IAP_FlashReadWord(uint32 flashAddr)
000000  4601              MOV      r1,r0
;;;811    {
;;;812    	return *(volatile uint32*)flashAddr; 
000002  6808              LDR      r0,[r1,#0]
;;;813    }
000004  4770              BX       lr
;;;814    
                          ENDP


                          AREA ||i.IAP_FlashReadWordArray||, CODE, READONLY, ALIGN=2

                  IAP_FlashReadWordArray PROC
;;;780    *******************************************************************************/
;;;781    void IAP_FlashReadWordArray(uint32 readAddr, uint32 *pBuffer, uint16 numToRead)   	
000000  b530              PUSH     {r4,r5,lr}
;;;782    {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;783    	uint16 i;
;;;784    
;;;785    	// 参数判断
;;;786    	if (NULL == pBuffer)
000008  b904              CBNZ     r4,|L13.12|
                  |L13.10|
;;;787    	{
;;;788    		return;
;;;789    	}
;;;790    
;;;791    	// 参数检验是否非法
;;;792    	if ((readAddr < IAP_GD32_FLASH_BASE) || ((readAddr + numToRead) > (IAP_GD32_FLASH_BASE+IAP_GD32_FLASH_SIZE+1024UL)))
;;;793    	{
;;;794    		return;	// 非法地址
;;;795    	}
;;;796    	
;;;797    	for (i = 0; i < numToRead; i++)
;;;798    	{
;;;799    		pBuffer[i] = IAP_FlashReadWord(readAddr);	// 读取4个字节.
;;;800    		readAddr += 4;								// 偏移4个字节.	
;;;801    	}
;;;802    }
00000a  bd30              POP      {r4,r5,pc}
                  |L13.12|
00000c  f1b36f00          CMP      r3,#0x8000000         ;792
000010  d303              BCC      |L13.26|
000012  1958              ADDS     r0,r3,r5              ;792
000014  4908              LDR      r1,|L13.56|
000016  4288              CMP      r0,r1                 ;792
000018  d900              BLS      |L13.28|
                  |L13.26|
00001a  e7f6              B        |L13.10|
                  |L13.28|
00001c  2200              MOVS     r2,#0                 ;797
00001e  e007              B        |L13.48|
                  |L13.32|
000020  4618              MOV      r0,r3                 ;799
000022  f7fffffe          BL       IAP_FlashReadWord
000026  f8440022          STR      r0,[r4,r2,LSL #2]     ;799
00002a  1d1b              ADDS     r3,r3,#4              ;800
00002c  1c50              ADDS     r0,r2,#1              ;797
00002e  b282              UXTH     r2,r0                 ;797
                  |L13.48|
000030  42aa              CMP      r2,r5                 ;797
000032  dbf5              BLT      |L13.32|
000034  bf00              NOP      
000036  e7e8              B        |L13.10|
;;;803    
                          ENDP

                  |L13.56|
                          DCD      0x08040400

                          AREA ||i.IAP_FlashWriteHalfWordArray||, CODE, READONLY, ALIGN=2

                  IAP_FlashWriteHalfWordArray PROC
;;;500    *******************************************************************************/
;;;501    BOOL IAP_FlashWriteHalfWordArray(uint32 writeAddr, uint16 *pBuffer, uint16 numToWrite)	
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;502    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;503    #if 0
;;;504    
;;;505    	uint32 secpos;	    // 扇区地址
;;;506    	uint16 secoff;	    // 扇区内偏移地址(16位字计算)
;;;507    	uint16 secremain;  	// 扇区内剩余地址(16位字计算)	   
;;;508     	uint16 i;    
;;;509    	uint32 offaddr;    	// 去掉0X08000000后的地址
;;;510    	BOOL writeStatus = FALSE;
;;;511    	FLASH_Status status = FLASH_COMPLETE;
;;;512    	static uint16 iapFlashBuf[IAP_STM32_PAGE_SIZE/2];	// 最多是2K字节
;;;513    
;;;514    	// 参数检验是否非法
;;;515    	if ((writeAddr < IAP_GD32_FLASH_BASE) || (writeAddr >= (IAP_GD32_FLASH_BASE+IAP_GD32_FLASH_SIZE)))
;;;516    	{
;;;517    		return FALSE;	// 非法地址
;;;518    	}
;;;519    	
;;;520    	DI();			// 关闭总中断
;;;521    	FLASH_Unlock();	// 解锁
;;;522    
;;;523    	// 清除所有挂起标志位
;;;524    	FLASH_ClearFlag(FLASH_FLAG_EOP | FLASH_FLAG_PGERR | FLASH_FLAG_WRPRTERR);
;;;525    	
;;;526    	offaddr = writeAddr-IAP_GD32_FLASH_BASE;			// 实际偏移地址.
;;;527    	secpos = offaddr/IAP_STM32_PAGE_SIZE;				// 扇区地址  0~127 for STM32F103RBT6
;;;528    	secoff = (offaddr%IAP_STM32_PAGE_SIZE)/2;			// 在扇区内的偏移(2个字节为基本单位.)
;;;529    	secremain = IAP_STM32_PAGE_SIZE/2 - secoff;			// 扇区剩余空间大小 
;;;530    
;;;531    	// 不大于该扇区范围
;;;532    	if (numToWrite <= secremain) 
;;;533    	{
;;;534    		secremain = numToWrite;
;;;535    	}
;;;536    	
;;;537    	while (1)
;;;538    	{
;;;539    		// 读出整个扇区的内容
;;;540    		IAP_FlashReadHalfWordArray((secpos*IAP_STM32_PAGE_SIZE+IAP_GD32_FLASH_BASE),
;;;541    									iapFlashBuf,
;;;542    									IAP_STM32_PAGE_SIZE/2);
;;;543    
;;;544    		// 校验数据
;;;545    		for (i = 0; i < secremain; i++)
;;;546    		{
;;;547    			if (iapFlashBuf[secoff + i] != 0xFFFF)
;;;548    			{
;;;549    				// 里面的数据不全是0xFFFF，说明需要擦除
;;;550    				break;
;;;551    			}
;;;552    		}
;;;553    
;;;554    		// 需要擦除
;;;555    		if (i < secremain)
;;;556    		{
;;;557    			// 擦除这个扇区
;;;558    			status = FLASH_ErasePage(secpos*IAP_STM32_PAGE_SIZE+IAP_STM32_FLASH_BASE);
;;;559    
;;;560    			if (FLASH_COMPLETE != status)
;;;561    			{
;;;562    				return FALSE;
;;;563    			}
;;;564    			
;;;565    			for (i = 0; i < secremain; i++) // 复制
;;;566    			{
;;;567    				iapFlashBuf[i + secoff] = pBuffer[i];	  
;;;568    			}
;;;569    
;;;570    			// 写入整个扇区
;;;571    			writeStatus = IAP_FlashWriteHalfWordArrayAndCheck((secpos*IAP_STM32_PAGE_SIZE+IAP_GD32_FLASH_BASE), 
;;;572    																iapFlashBuf, 
;;;573    																IAP_STM32_PAGE_SIZE/2);
;;;574    		}
;;;575    		// 不需要擦除
;;;576    		else
;;;577    		{
;;;578    			writeStatus = IAP_FlashWriteHalfWordArrayAndCheck(writeAddr,pBuffer,secremain); //写已经擦除了的,直接写入扇区剩余区间. 
;;;579    		}
;;;580    		
;;;581    		if (!writeStatus)
;;;582    		{
;;;583    			break;
;;;584    		}
;;;585    		
;;;586    		// 写入结束了
;;;587    		if (numToWrite == secremain)
;;;588    		{
;;;589    			break;
;;;590    		}
;;;591    		// 写入未结束
;;;592    		else 
;;;593    		{
;;;594    			secpos++;							// 扇区地址增1
;;;595    			secoff = 0;							// 偏移位置为0 	 
;;;596    		 	pBuffer += secremain;  	     		// 指针偏移
;;;597    			writeAddr += secremain;				// 写地址偏移	   
;;;598    		  	numToWrite -= secremain;			// 字节(16位)数递减
;;;599    
;;;600    		  	// 下一个扇区还是写不完
;;;601    			if (numToWrite > (IAP_STM32_PAGE_SIZE/2))
;;;602    			{
;;;603    				secremain = IAP_STM32_PAGE_SIZE/2;	
;;;604    			}
;;;605    			// 下一个扇区可以写完了
;;;606    			else 
;;;607    			{
;;;608    				secremain = numToWrite;
;;;609    			}
;;;610    		}	 
;;;611    	}
;;;612    	
;;;613    	FLASH_Lock();		// 上锁
;;;614    	EI(); 				// 开启总中断
;;;615    	
;;;616    	return writeStatus;
;;;617    
;;;618    #else
;;;619    	BOOL writeStatus = TRUE;
00000a  2701              MOVS     r7,#1
;;;620    	
;;;621    	// 参数判断
;;;622    	if (NULL == pBuffer)
00000c  b915              CBNZ     r5,|L14.20|
;;;623    	{
;;;624    		return FALSE;
00000e  2000              MOVS     r0,#0
                  |L14.16|
;;;625    	}
;;;626    
;;;627    	// 参数检验是否非法
;;;628    	if ((writeAddr < IAP_GD32_FLASH_BASE) || (writeAddr >= (IAP_GD32_FLASH_BASE+IAP_GD32_FLASH_SIZE)))
;;;629    	{
;;;630    		return FALSE;	// 非法地址
;;;631    	}
;;;632    	
;;;633    	DI();				// 关闭总中断
;;;634    	fmc_unlock();		// 解锁
;;;635    
;;;636    	// 清除所有挂起标志位
;;;637    	fmc_flag_clear(FMC_FLAG_BANK0_END);
;;;638        fmc_flag_clear(FMC_FLAG_BANK0_WPERR);
;;;639        fmc_flag_clear(FMC_FLAG_BANK0_PGERR);
;;;640    	
;;;641    	// 写入页
;;;642    	if (!IAP_FlashWriteHalfWordArrayAndCheck(writeAddr, pBuffer, numToWrite))	
;;;643    	{
;;;644    		writeStatus = FALSE;
;;;645    	}
;;;646    
;;;647    	fmc_lock();		// 上锁
;;;648    	EI(); 			// 开启总中断
;;;649    	
;;;650    	return writeStatus;
;;;651    
;;;652    #endif
;;;653    }
000010  e8bd81f0          POP      {r4-r8,pc}
                  |L14.20|
000014  f1b46f00          CMP      r4,#0x8000000         ;628
000018  d302              BCC      |L14.32|
00001a  4810              LDR      r0,|L14.92|
00001c  4284              CMP      r4,r0                 ;628
00001e  d301              BCC      |L14.36|
                  |L14.32|
000020  2000              MOVS     r0,#0                 ;630
000022  e7f5              B        |L14.16|
                  |L14.36|
000024  b672              CPSID    i                     ;633
000026  f7fffffe          BL       fmc_unlock
00002a  f2403005          MOV      r0,#0x305             ;637
00002e  f7fffffe          BL       fmc_flag_clear
000032  f44f7041          MOV      r0,#0x304             ;638
000036  f7fffffe          BL       fmc_flag_clear
00003a  f2403002          MOV      r0,#0x302             ;639
00003e  f7fffffe          BL       fmc_flag_clear
000042  4632              MOV      r2,r6                 ;642
000044  4629              MOV      r1,r5                 ;642
000046  4620              MOV      r0,r4                 ;642
000048  f7fffffe          BL       IAP_FlashWriteHalfWordArrayAndCheck
00004c  b900              CBNZ     r0,|L14.80|
00004e  2700              MOVS     r7,#0                 ;644
                  |L14.80|
000050  f7fffffe          BL       fmc_lock
000054  b662              CPSIE    i                     ;648
000056  4638              MOV      r0,r7                 ;650
000058  e7da              B        |L14.16|
;;;654    
                          ENDP

00005a  0000              DCW      0x0000
                  |L14.92|
                          DCD      0x08040000

                          AREA ||i.IAP_FlashWriteHalfWordArrayAndCheck||, CODE, READONLY, ALIGN=2

                  IAP_FlashWriteHalfWordArrayAndCheck PROC
;;;454    *******************************************************************************/
;;;455    BOOL IAP_FlashWriteHalfWordArrayAndCheck(uint32 writeAddr, uint16 *pBuffer, uint16 numToWrite)   
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;456    { 			 		 
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;457    	uint16 i;
;;;458    	uint16 readHalfWord;
;;;459    
;;;460    	// 参数判断
;;;461    	if (NULL == pBuffer)
00000a  b916              CBNZ     r6,|L15.18|
;;;462    	{
;;;463    		return FALSE;
00000c  2000              MOVS     r0,#0
                  |L15.14|
;;;464    	}
;;;465    
;;;466    	// 参数检验是否非法
;;;467    	if ((writeAddr < IAP_GD32_FLASH_BASE) || (writeAddr >= (IAP_GD32_FLASH_BASE+IAP_GD32_FLASH_SIZE)))
;;;468    	{
;;;469    		return FALSE;	// 非法地址
;;;470    	}
;;;471    	
;;;472    	for (i = 0; i < numToWrite; i++)
;;;473    	{
;;;474    		fmc_halfword_program(writeAddr, pBuffer[i]);		// 写
;;;475    		readHalfWord = IAP_FlashReadHalfWord(writeAddr);	// 读
;;;476    	  	writeAddr += 2;
;;;477    
;;;478    		fmc_flag_clear(FMC_FLAG_BANK0_END);
;;;479            fmc_flag_clear(FMC_FLAG_BANK0_WPERR);
;;;480            fmc_flag_clear(FMC_FLAG_BANK0_PGERR); 
;;;481    		
;;;482    	  	// 写入FLASH中的缓冲区数据与读取的数据是否匹配
;;;483    		if (readHalfWord == pBuffer[i])
;;;484    		{
;;;485    			continue;
;;;486    		}
;;;487    		else
;;;488    		{
;;;489    			return FALSE;
;;;490    		}
;;;491    	}  
;;;492    	return TRUE;
;;;493    } 
00000e  e8bd81f0          POP      {r4-r8,pc}
                  |L15.18|
000012  f1b56f00          CMP      r5,#0x8000000         ;467
000016  d302              BCC      |L15.30|
000018  4814              LDR      r0,|L15.108|
00001a  4285              CMP      r5,r0                 ;467
00001c  d301              BCC      |L15.34|
                  |L15.30|
00001e  2000              MOVS     r0,#0                 ;469
000020  e7f5              B        |L15.14|
                  |L15.34|
000022  2400              MOVS     r4,#0                 ;472
000024  e01e              B        |L15.100|
                  |L15.38|
000026  f8361014          LDRH     r1,[r6,r4,LSL #1]     ;474
00002a  4628              MOV      r0,r5                 ;474
00002c  f7fffffe          BL       fmc_halfword_program
000030  4628              MOV      r0,r5                 ;475
000032  f7fffffe          BL       IAP_FlashReadHalfWord
000036  4680              MOV      r8,r0                 ;475
000038  1cad              ADDS     r5,r5,#2              ;476
00003a  f2403005          MOV      r0,#0x305             ;478
00003e  f7fffffe          BL       fmc_flag_clear
000042  f44f7041          MOV      r0,#0x304             ;479
000046  f7fffffe          BL       fmc_flag_clear
00004a  f2403002          MOV      r0,#0x302             ;480
00004e  f7fffffe          BL       fmc_flag_clear
000052  f8360014          LDRH     r0,[r6,r4,LSL #1]     ;483
000056  4540              CMP      r0,r8                 ;483
000058  d100              BNE      |L15.92|
00005a  e001              B        |L15.96|
                  |L15.92|
00005c  2000              MOVS     r0,#0                 ;489
00005e  e7d6              B        |L15.14|
                  |L15.96|
000060  1c60              ADDS     r0,r4,#1              ;472
000062  b284              UXTH     r4,r0                 ;472
                  |L15.100|
000064  42bc              CMP      r4,r7                 ;472
000066  dbde              BLT      |L15.38|
000068  2001              MOVS     r0,#1                 ;492
00006a  e7d0              B        |L15.14|
;;;494    
                          ENDP

                  |L15.108|
                          DCD      0x08040000

                          AREA ||i.IAP_FlashWriteWordArray||, CODE, READONLY, ALIGN=2

                  IAP_FlashWriteWordArray PROC
;;;690    *******************************************************************************/
;;;691    BOOL IAP_FlashWriteWordArray(uint32 writeAddr, uint32 *pBuffer, uint16 numToWrite)	
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;692    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;693    	BOOL writeStatus = TRUE;
00000a  2701              MOVS     r7,#1
;;;694    	
;;;695    	// 参数判断
;;;696    	if (NULL == pBuffer)
00000c  b915              CBNZ     r5,|L16.20|
;;;697    	{
;;;698    		return FALSE;
00000e  2000              MOVS     r0,#0
                  |L16.16|
;;;699    	}
;;;700    
;;;701    	// 参数检验是否非法
;;;702    	if ((writeAddr < IAP_GD32_FLASH_BASE) || ((writeAddr + numToWrite) > (IAP_GD32_FLASH_BASE+IAP_GD32_FLASH_SIZE)))
;;;703    	{
;;;704    		return FALSE;	// 非法地址
;;;705    	}
;;;706    	
;;;707    	DI();				// 关闭总中断
;;;708    	fmc_unlock();		// 解锁
;;;709    
;;;710    	// 清除所有挂起标志位
;;;711    	fmc_flag_clear(FMC_FLAG_BANK0_END);
;;;712        fmc_flag_clear(FMC_FLAG_BANK0_WPERR);
;;;713        fmc_flag_clear(FMC_FLAG_BANK0_PGERR);
;;;714    
;;;715    
;;;716    	// 写入页
;;;717    	if (!IAP_FlashWriteWordArrayAndCheck(writeAddr, pBuffer, numToWrite))	
;;;718    	{
;;;719    		writeStatus = FALSE;
;;;720    	}
;;;721    
;;;722    	fmc_lock();			// 上锁
;;;723    	EI(); 				// 开启总中断
;;;724    	
;;;725    	return writeStatus;
;;;726    }
000010  e8bd81f0          POP      {r4-r8,pc}
                  |L16.20|
000014  f1b46f00          CMP      r4,#0x8000000         ;702
000018  d303              BCC      |L16.34|
00001a  19a0              ADDS     r0,r4,r6              ;702
00001c  490f              LDR      r1,|L16.92|
00001e  4288              CMP      r0,r1                 ;702
000020  d901              BLS      |L16.38|
                  |L16.34|
000022  2000              MOVS     r0,#0                 ;704
000024  e7f4              B        |L16.16|
                  |L16.38|
000026  b672              CPSID    i                     ;707
000028  f7fffffe          BL       fmc_unlock
00002c  f2403005          MOV      r0,#0x305             ;711
000030  f7fffffe          BL       fmc_flag_clear
000034  f44f7041          MOV      r0,#0x304             ;712
000038  f7fffffe          BL       fmc_flag_clear
00003c  f2403002          MOV      r0,#0x302             ;713
000040  f7fffffe          BL       fmc_flag_clear
000044  4632              MOV      r2,r6                 ;717
000046  4629              MOV      r1,r5                 ;717
000048  4620              MOV      r0,r4                 ;717
00004a  f7fffffe          BL       IAP_FlashWriteWordArrayAndCheck
00004e  b900              CBNZ     r0,|L16.82|
000050  2700              MOVS     r7,#0                 ;719
                  |L16.82|
000052  f7fffffe          BL       fmc_lock
000056  b662              CPSIE    i                     ;723
000058  4638              MOV      r0,r7                 ;725
00005a  e7d9              B        |L16.16|
;;;727    
                          ENDP

                  |L16.92|
                          DCD      0x08040000

                          AREA ||i.IAP_FlashWriteWordArrayAndCheck||, CODE, READONLY, ALIGN=2

                  IAP_FlashWriteWordArrayAndCheck PROC
;;;734    *******************************************************************************/
;;;735    BOOL IAP_FlashWriteWordArrayAndCheck(uint32 writeAddr, uint32 *pBuffer, uint16 numToWrite)   
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;736    { 			 		 
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;737    	uint16 i;
;;;738    	uint32 readWord;
;;;739    
;;;740    	// 参数判断
;;;741    	if (NULL == pBuffer)
00000a  b916              CBNZ     r6,|L17.18|
;;;742    	{
;;;743    		return FALSE;
00000c  2000              MOVS     r0,#0
                  |L17.14|
;;;744    	}
;;;745    
;;;746    	// 参数检验是否非法
;;;747    	if ((writeAddr < IAP_GD32_FLASH_BASE) || ((writeAddr + numToWrite) > (IAP_GD32_FLASH_BASE+IAP_GD32_FLASH_SIZE+1024UL)))
;;;748    	{
;;;749    		return FALSE;	// 非法地址
;;;750    	}
;;;751    	
;;;752    	for (i = 0; i < numToWrite; i++)
;;;753    	{
;;;754    		fmc_word_program(writeAddr, pBuffer[i]);		// 写
;;;755    		readWord = IAP_FlashReadWord(writeAddr);		// 读
;;;756    	  	writeAddr += 4;
;;;757    
;;;758    		fmc_flag_clear(FMC_FLAG_BANK0_END);
;;;759            fmc_flag_clear(FMC_FLAG_BANK0_WPERR);
;;;760            fmc_flag_clear(FMC_FLAG_BANK0_PGERR); 
;;;761    
;;;762    	  	// 写入FLASH中的缓冲区数据与读取的数据是否匹配
;;;763    		if (readWord == pBuffer[i])
;;;764    		{
;;;765    			continue;
;;;766    		}
;;;767    		else
;;;768    		{
;;;769    			return FALSE;
;;;770    		}
;;;771    	}  
;;;772    	return TRUE;
;;;773    } 
00000e  e8bd81f0          POP      {r4-r8,pc}
                  |L17.18|
000012  f1b56f00          CMP      r5,#0x8000000         ;747
000016  d303              BCC      |L17.32|
000018  19e8              ADDS     r0,r5,r7              ;747
00001a  4915              LDR      r1,|L17.112|
00001c  4288              CMP      r0,r1                 ;747
00001e  d901              BLS      |L17.36|
                  |L17.32|
000020  2000              MOVS     r0,#0                 ;749
000022  e7f4              B        |L17.14|
                  |L17.36|
000024  2400              MOVS     r4,#0                 ;752
000026  e01e              B        |L17.102|
                  |L17.40|
000028  f8561024          LDR      r1,[r6,r4,LSL #2]     ;754
00002c  4628              MOV      r0,r5                 ;754
00002e  f7fffffe          BL       fmc_word_program
000032  4628              MOV      r0,r5                 ;755
000034  f7fffffe          BL       IAP_FlashReadWord
000038  4680              MOV      r8,r0                 ;755
00003a  1d2d              ADDS     r5,r5,#4              ;756
00003c  f2403005          MOV      r0,#0x305             ;758
000040  f7fffffe          BL       fmc_flag_clear
000044  f44f7041          MOV      r0,#0x304             ;759
000048  f7fffffe          BL       fmc_flag_clear
00004c  f2403002          MOV      r0,#0x302             ;760
000050  f7fffffe          BL       fmc_flag_clear
000054  f8560024          LDR      r0,[r6,r4,LSL #2]     ;763
000058  4540              CMP      r0,r8                 ;763
00005a  d100              BNE      |L17.94|
00005c  e001              B        |L17.98|
                  |L17.94|
00005e  2000              MOVS     r0,#0                 ;769
000060  e7d5              B        |L17.14|
                  |L17.98|
000062  1c60              ADDS     r0,r4,#1              ;752
000064  b284              UXTH     r4,r0                 ;752
                  |L17.102|
000066  42bc              CMP      r4,r7                 ;752
000068  dbde              BLT      |L17.40|
00006a  2001              MOVS     r0,#1                 ;772
00006c  e7cf              B        |L17.14|
;;;774    
                          ENDP

00006e  0000              DCW      0x0000
                  |L17.112|
                          DCD      0x08040400

                          AREA ||i.IAP_FlashWriteWordArrayWithErase||, CODE, READONLY, ALIGN=2

                  IAP_FlashWriteWordArrayWithErase PROC
;;;820    *******************************************************************************/
;;;821    BOOL IAP_FlashWriteWordArrayWithErase(uint32 writeAddr, uint32 *pBuffer, uint16 NumWordToWrite)	
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;822    {
000004  b084              SUB      sp,sp,#0x10
000006  4681              MOV      r9,r0
000008  468b              MOV      r11,r1
;;;823    	BOOL writeStatus = TRUE;
00000a  2001              MOVS     r0,#1
00000c  9003              STR      r0,[sp,#0xc]
;;;824    	uint32 pagePos = 0;						// 扇区地址
00000e  2700              MOVS     r7,#0
;;;825    	uint16 pageOffsent = 0;					// 在扇区内的偏移
000010  f04f0800          MOV      r8,#0
;;;826    	uint16 pageRemain = 0;  				// 扇区剩余空间大小 
000014  2400              MOVS     r4,#0
;;;827    	uint32 offaddr;    						// 去掉0X08000000后的地址
;;;828     	uint16 i = 0;
000016  2500              MOVS     r5,#0
;;;829     	uint32 * pFlashBuff = NULL;				// 保存读取扇区的数据
000018  f04f0a00          MOV      r10,#0
;;;830     	uint16 numByteToWrite = NumWordToWrite * 4;
00001c  f64f71ff          MOV      r1,#0xffff
000020  9806              LDR      r0,[sp,#0x18]
000022  ea010680          AND      r6,r1,r0,LSL #2
;;;831    	
;;;832    	// 参数判断
;;;833    	if (NULL == pBuffer|| (NULL == numByteToWrite))
000026  f1bb0f00          CMP      r11,#0
00002a  d000              BEQ      |L18.46|
00002c  b91e              CBNZ     r6,|L18.54|
                  |L18.46|
;;;834    	{
;;;835    		return FALSE;
00002e  2000              MOVS     r0,#0
                  |L18.48|
;;;836    	}
;;;837    
;;;838    	// 参数检验是否非法
;;;839    	if ((writeAddr < IAP_GD32_FLASH_BASE) || ((writeAddr + numByteToWrite) > (IAP_GD32_FLASH_BASE+IAP_GD32_FLASH_SIZE + 1024UL)))
;;;840    	{
;;;841    		return FALSE;	// 非法地址
;;;842    	}
;;;843    
;;;844    	// 申请1024Byte空间保存页数据
;;;845    	pFlashBuff = (uint32 *)malloc(IAP_STM32_PAGE_SIZE);
;;;846    	if (NULL == pFlashBuff)
;;;847    	{
;;;848    		return FALSE;
;;;849    	}
;;;850    
;;;851    	offaddr = writeAddr - IAP_GD32_FLASH_BASE;		// 实际偏移地址
;;;852    	pagePos = offaddr / IAP_STM32_PAGE_SIZE;		// 页地址
;;;853    	pageOffsent = offaddr % IAP_STM32_PAGE_SIZE;	// 在页内偏移
;;;854    	pageRemain = IAP_STM32_PAGE_SIZE - pageOffsent;	// 页剩余空间大小
;;;855    
;;;856    	if (numByteToWrite <= pageRemain)
;;;857    	{
;;;858    		pageRemain = numByteToWrite;				// 不大于该页范围
;;;859    	}
;;;860    	
;;;861    	DI();				// 关闭总中断
;;;862    	fmc_unlock();		// 解锁
;;;863    
;;;864    	// 清除所有挂起标志位
;;;865    	fmc_flag_clear(FMC_FLAG_BANK0_END);
;;;866        fmc_flag_clear(FMC_FLAG_BANK0_WPERR);
;;;867        fmc_flag_clear(FMC_FLAG_BANK0_PGERR);
;;;868    
;;;869    	
;;;870    	while(1)
;;;871    	{
;;;872    		// 读出整个页的内容
;;;873    		IAP_FlashReadWordArray(pagePos*IAP_STM32_PAGE_SIZE+IAP_STM32_PAGE_SIZE, pFlashBuff, IAP_STM32_PAGE_SIZE/4);
;;;874    
;;;875    		for (i = 0; i < pageRemain/4; i++)	// 校验数据
;;;876    		{
;;;877    			if (pFlashBuff[pageOffsent/4 + i] != 0xFFFFFFFF)
;;;878    			{
;;;879    				// 里面的数据不全是0xFFFFFFFF，说明需要擦除
;;;880    				break;
;;;881    			}
;;;882    		}
;;;883    
;;;884    		if (i < pageRemain/4)					// 需要擦除
;;;885    		{
;;;886    			// 擦除这个页
;;;887    			//IAP_PageErase(pagePos * IAP_STM32_PAGE_SIZE + IAP_GD32_FLASH_BASE);
;;;888    			fmc_page_erase(pagePos * IAP_STM32_PAGE_SIZE + IAP_GD32_FLASH_BASE);
;;;889    
;;;890    			// 复制
;;;891    			for (i = 0; i < pageRemain/4; i++)
;;;892    			{
;;;893    				pFlashBuff[i + pageOffsent/4] = pBuffer[i]; 
;;;894    			}
;;;895    
;;;896    			// 写入整页
;;;897    			if (!IAP_FlashWriteWordArrayAndCheck(pagePos * IAP_STM32_PAGE_SIZE + IAP_GD32_FLASH_BASE, pFlashBuff, IAP_STM32_PAGE_SIZE/4))	
;;;898    			{
;;;899    				// 释放数据缓存区
;;;900    				free(pFlashBuff);
;;;901    
;;;902    				fmc_lock();			// 上锁
;;;903    				EI();				// 开启总中断
;;;904    				writeStatus = FALSE;
;;;905    				return writeStatus;
;;;906    			}
;;;907    		}
;;;908    		else 
;;;909    		{
;;;910    			// 写已经擦除了的,直接写入扇区剩余区间.
;;;911    			if (!IAP_FlashWriteWordArrayAndCheck(writeAddr, pBuffer, pageRemain/4))	
;;;912    			{
;;;913    				// 释放数据缓存区
;;;914    				free(pFlashBuff);
;;;915    
;;;916    				fmc_lock();			// 上锁
;;;917    				EI(); 				// 开启总中断
;;;918    				writeStatus = FALSE;
;;;919    				return writeStatus;
;;;920    			}
;;;921    		}
;;;922    		
;;;923    		if (numByteToWrite == pageRemain)
;;;924    		{
;;;925    			break;									// 写入结束了
;;;926    		}
;;;927    		else										// 写入未结束
;;;928    		{
;;;929    			pagePos++;								// 扇区地址增1
;;;930    			pageOffsent = 0;						// 偏移位置为0 	 
;;;931    
;;;932    		   	pBuffer += (pageRemain/4);  			// 指针偏移
;;;933    			writeAddr += pageRemain;				// 写地址偏移	   
;;;934    		   	numByteToWrite -= pageRemain;			// 字节数递减
;;;935    		   	
;;;936    			if (numByteToWrite > IAP_STM32_PAGE_SIZE)
;;;937    			{
;;;938    				pageRemain = IAP_STM32_PAGE_SIZE;	// 下一个扇区还是写不完
;;;939    			}
;;;940    			else
;;;941    			{
;;;942    				pageRemain = numByteToWrite;		// 下一个扇区可以写完了	
;;;943    			}
;;;944    		}	
;;;945    		
;;;946    	}
;;;947    
;;;948    	// 释放数据缓存区
;;;949    	free(pFlashBuff);	
;;;950    	fmc_lock();			// 上锁
;;;951    	EI(); 				// 开启总中断
;;;952    	return writeStatus;
;;;953    }
000030  b007              ADD      sp,sp,#0x1c
000032  e8bd8ff0          POP      {r4-r11,pc}
                  |L18.54|
000036  f1b96f00          CMP      r9,#0x8000000         ;839
00003a  d304              BCC      |L18.70|
00003c  eb090006          ADD      r0,r9,r6              ;839
000040  4959              LDR      r1,|L18.424|
000042  4288              CMP      r0,r1                 ;839
000044  d901              BLS      |L18.74|
                  |L18.70|
000046  2000              MOVS     r0,#0                 ;841
000048  e7f2              B        |L18.48|
                  |L18.74|
00004a  f44f6000          MOV      r0,#0x800             ;845
00004e  f7fffffe          BL       malloc
000052  4682              MOV      r10,r0                ;845
000054  f1ba0f00          CMP      r10,#0                ;846
000058  d101              BNE      |L18.94|
00005a  2000              MOVS     r0,#0                 ;848
00005c  e7e8              B        |L18.48|
                  |L18.94|
00005e  f1a96000          SUB      r0,r9,#0x8000000      ;851
000062  9002              STR      r0,[sp,#8]            ;851
000064  9802              LDR      r0,[sp,#8]            ;852
000066  0ac7              LSRS     r7,r0,#11             ;852
000068  9802              LDR      r0,[sp,#8]            ;853
00006a  f3c0080a          UBFX     r8,r0,#0,#11          ;853
00006e  f5c86400          RSB      r4,r8,#0x800          ;854
000072  42a6              CMP      r6,r4                 ;856
000074  dc00              BGT      |L18.120|
000076  4634              MOV      r4,r6                 ;858
                  |L18.120|
000078  b672              CPSID    i                     ;861
00007a  f7fffffe          BL       fmc_unlock
00007e  f2403005          MOV      r0,#0x305             ;865
000082  f7fffffe          BL       fmc_flag_clear
000086  f44f7041          MOV      r0,#0x304             ;866
00008a  f7fffffe          BL       fmc_flag_clear
00008e  f2403002          MOV      r0,#0x302             ;867
000092  f7fffffe          BL       fmc_flag_clear
000096  e07d              B        |L18.404|
                  |L18.152|
000098  f44f6100          MOV      r1,#0x800             ;873
00009c  eb0120c7          ADD      r0,r1,r7,LSL #11      ;873
0000a0  108a              ASRS     r2,r1,#2              ;873
0000a2  4651              MOV      r1,r10                ;873
0000a4  f7fffffe          BL       IAP_FlashReadWordArray
0000a8  2500              MOVS     r5,#0                 ;875
0000aa  e00c              B        |L18.198|
                  |L18.172|
0000ac  ea4f71e8          ASR      r1,r8,#31             ;877
0000b0  eb087191          ADD      r1,r8,r1,LSR #30      ;877
0000b4  eb0501a1          ADD      r1,r5,r1,ASR #2       ;877
0000b8  f85a1021          LDR      r1,[r10,r1,LSL #2]    ;877
0000bc  1c49              ADDS     r1,r1,#1              ;877
0000be  b101              CBZ      r1,|L18.194|
0000c0  e007              B        |L18.210|
                  |L18.194|
0000c2  1c68              ADDS     r0,r5,#1              ;875
0000c4  b285              UXTH     r5,r0                 ;875
                  |L18.198|
0000c6  17e1              ASRS     r1,r4,#31             ;875
0000c8  eb047191          ADD      r1,r4,r1,LSR #30      ;875
0000cc  ebb50fa1          CMP      r5,r1,ASR #2          ;875
0000d0  dbec              BLT      |L18.172|
                  |L18.210|
0000d2  bf00              NOP                            ;880
0000d4  17e1              ASRS     r1,r4,#31             ;884
0000d6  eb047191          ADD      r1,r4,r1,LSR #30      ;884
0000da  ebb50fa1          CMP      r5,r1,ASR #2          ;884
0000de  da2d              BGE      |L18.316|
0000e0  f04f6100          MOV      r1,#0x8000000         ;888
0000e4  eb0120c7          ADD      r0,r1,r7,LSL #11      ;888
0000e8  f7fffffe          BL       fmc_page_erase
0000ec  2500              MOVS     r5,#0                 ;891
0000ee  e00c              B        |L18.266|
                  |L18.240|
0000f0  f85b1025          LDR      r1,[r11,r5,LSL #2]    ;893
0000f4  4640              MOV      r0,r8                 ;893
0000f6  ea4f72e8          ASR      r2,r8,#31             ;893
0000fa  eb087292          ADD      r2,r8,r2,LSR #30      ;893
0000fe  eb0502a2          ADD      r2,r5,r2,ASR #2       ;893
000102  f84a1022          STR      r1,[r10,r2,LSL #2]    ;893
000106  1c68              ADDS     r0,r5,#1              ;891
000108  b285              UXTH     r5,r0                 ;891
                  |L18.266|
00010a  17e1              ASRS     r1,r4,#31             ;891
00010c  eb047191          ADD      r1,r4,r1,LSR #30      ;891
000110  ebb50fa1          CMP      r5,r1,ASR #2          ;891
000114  dbec              BLT      |L18.240|
000116  f04f6100          MOV      r1,#0x8000000         ;897
00011a  eb0120c7          ADD      r0,r1,r7,LSL #11      ;897
00011e  148a              ASRS     r2,r1,#18             ;897
000120  4651              MOV      r1,r10                ;897
000122  f7fffffe          BL       IAP_FlashWriteWordArrayAndCheck
000126  b9f0              CBNZ     r0,|L18.358|
000128  4650              MOV      r0,r10                ;900
00012a  f7fffffe          BL       free
00012e  f7fffffe          BL       fmc_lock
000132  b662              CPSIE    i                     ;903
000134  2000              MOVS     r0,#0                 ;904
000136  9003              STR      r0,[sp,#0xc]          ;904
000138  9803              LDR      r0,[sp,#0xc]          ;905
00013a  e779              B        |L18.48|
                  |L18.316|
00013c  17e0              ASRS     r0,r4,#31             ;911
00013e  eb047090          ADD      r0,r4,r0,LSR #30      ;911
000142  f3c0028f          UBFX     r2,r0,#2,#16          ;911
000146  4659              MOV      r1,r11                ;911
000148  4648              MOV      r0,r9                 ;911
00014a  9401              STR      r4,[sp,#4]            ;911
00014c  f7fffffe          BL       IAP_FlashWriteWordArrayAndCheck
000150  b948              CBNZ     r0,|L18.358|
000152  4650              MOV      r0,r10                ;914
000154  f7fffffe          BL       free
000158  f7fffffe          BL       fmc_lock
00015c  b662              CPSIE    i                     ;917
00015e  2000              MOVS     r0,#0                 ;918
000160  9003              STR      r0,[sp,#0xc]          ;918
000162  9803              LDR      r0,[sp,#0xc]          ;919
000164  e764              B        |L18.48|
                  |L18.358|
000166  42a6              CMP      r6,r4                 ;923
000168  d100              BNE      |L18.364|
00016a  e014              B        |L18.406|
                  |L18.364|
00016c  1c7f              ADDS     r7,r7,#1              ;929
00016e  f04f0800          MOV      r8,#0                 ;930
000172  4620              MOV      r0,r4                 ;932
000174  17e1              ASRS     r1,r4,#31             ;932
000176  eb047191          ADD      r1,r4,r1,LSR #30      ;932
00017a  1089              ASRS     r1,r1,#2              ;932
00017c  eb0b0b81          ADD      r11,r11,r1,LSL #2     ;932
000180  44a1              ADD      r9,r9,r4              ;933
000182  1b30              SUBS     r0,r6,r4              ;934
000184  b286              UXTH     r6,r0                 ;934
000186  f5b66f00          CMP      r6,#0x800             ;936
00018a  d902              BLS      |L18.402|
00018c  f44f6400          MOV      r4,#0x800             ;938
000190  e000              B        |L18.404|
                  |L18.402|
000192  4634              MOV      r4,r6                 ;942
                  |L18.404|
000194  e780              B        |L18.152|
                  |L18.406|
000196  bf00              NOP                            ;925
000198  4650              MOV      r0,r10                ;949
00019a  f7fffffe          BL       free
00019e  f7fffffe          BL       fmc_lock
0001a2  b662              CPSIE    i                     ;951
0001a4  9803              LDR      r0,[sp,#0xc]          ;952
0001a6  e743              B        |L18.48|
;;;954    
                          ENDP

                  |L18.424|
                          DCD      0x08040400

                          AREA ||i.IAP_JumpToAppFun||, CODE, READONLY, ALIGN=2

                  IAP_JumpToAppFun PROC
;;;91     // 窗口时间到跳转到APP代码区运行
;;;92     void IAP_JumpToAppFun(uint32 param)
000000  b510              PUSH     {r4,lr}
;;;93     {
000002  4604              MOV      r4,r0
;;;94     	// 检查栈顶地址是否合法.
;;;95     	if(((*(uint32*)param) & 0x2FFE0000) != 0x20000000)	
000004  4909              LDR      r1,|L19.44|
000006  6820              LDR      r0,[r4,#0]
000008  4008              ANDS     r0,r0,r1
00000a  f1b05f00          CMP      r0,#0x20000000
00000e  d000              BEQ      |L19.18|
                  |L19.16|
;;;96     	{
;;;97     		return;
;;;98     	}
;;;99     
;;;100    	// APP无效
;;;101    	if (((*(uint32*)(param+4)) & 0xFFF80000) != 0x08000000)
;;;102    	{
;;;103    		return;
;;;104    	}
;;;105    	
;;;106    	// 执行APP程序
;;;107    	IAP_RunAPP(param);
;;;108    }
000010  bd10              POP      {r4,pc}
                  |L19.18|
000012  6860              LDR      r0,[r4,#4]            ;101
000014  f36f0012          BFC      r0,#0,#19             ;101
000018  f1b06f00          CMP      r0,#0x8000000         ;101
00001c  d000              BEQ      |L19.32|
00001e  e7f7              B        |L19.16|
                  |L19.32|
000020  4620              MOV      r0,r4                 ;107
000022  f7fffffe          BL       IAP_RunAPP
000026  bf00              NOP      
000028  e7f2              B        |L19.16|
;;;109    
                          ENDP

00002a  0000              DCW      0x0000
                  |L19.44|
                          DCD      0x2ffe0000

                          AREA ||i.IAP_RunAPP||, CODE, READONLY, ALIGN=2

                  IAP_RunAPP PROC
;;;60     *******************************************************************************/
;;;61     void IAP_RunAPP(uint32 appAddr)
000000  b570              PUSH     {r4-r6,lr}
;;;62     {
000002  4604              MOV      r4,r0
;;;63         // appAddr存放的是用户程序Flash的首地址，(*(vu32*)appAddr的意思是取用户程序首地址里面的数据，该数据是用户程序的堆栈地址
;;;64         // 堆栈地址指向RAM,而RAM的起始地址是0x20000000,因此上面的判断语句执行:判断用户代码的堆栈地址是否落在:0x20000000~0x2001ffff区间中，
;;;65         // 这个区间的大小较多落在<128K RAM的区间，因此需要进行下面的判断
;;;66     
;;;67     	//定义一个函数类型的参数	
;;;68     	typedef void (*IAP_Func)(void);
;;;69     	IAP_Func jumpToApp;
;;;70     
;;;71     	if(((*(uint32*)appAddr) & 0x2FFE0000) == 0x20000000)	// 检查栈顶地址是否合法.
000004  490a              LDR      r1,|L20.48|
000006  6820              LDR      r0,[r4,#0]
000008  4008              ANDS     r0,r0,r1
00000a  f1b05f00          CMP      r0,#0x20000000
00000e  d10d              BNE      |L20.44|
;;;72     	{ 
;;;73     		if (((*(uint32*)(appAddr+4)) & 0xFFF80000) != 0x08000000)   // APP无效
000010  6860              LDR      r0,[r4,#4]
000012  f36f0012          BFC      r0,#0,#19
000016  f1b06f00          CMP      r0,#0x8000000
00001a  d000              BEQ      |L20.30|
                  |L20.28|
;;;74     		{
;;;75     			return;
;;;76     		}
;;;77     
;;;78     		// 跳转之前关总中断，复位外设为默认值
;;;79     		DI();
;;;80     //		RCC_APB2PeriphResetCmd(0xFFFFFFFF, ENABLE);
;;;81     //		RCC_APB2PeriphResetCmd(0xFFFFFFFF, DISABLE);
;;;82     //		RCC_APB1PeriphResetCmd(0xFFFFFFFF, ENABLE);
;;;83     //		RCC_APB1PeriphResetCmd(0xFFFFFFFF, DISABLE);
;;;84     		
;;;85     		jumpToApp = (IAP_Func)*(uint32*)(appAddr+4);		// 用户代码区第二个字为程序开始地址(复位地址)		
;;;86     	  	__set_MSP(*(uint32*)appAddr);						// 初始化用户程序的堆栈指针
;;;87     		jumpToApp();									// 跳转到用户程序APP
;;;88     	}
;;;89     }
00001c  bd70              POP      {r4-r6,pc}
                  |L20.30|
00001e  b672              CPSID    i                     ;79
000020  6865              LDR      r5,[r4,#4]            ;85
000022  6820              LDR      r0,[r4,#0]            ;86
000024  f3808808          MSR      MSP,r0                ;86
000028  bf00              NOP                            ;86
00002a  47a8              BLX      r5                    ;87
                  |L20.44|
00002c  bf00              NOP      
00002e  e7f5              B        |L20.28|
;;;90     
                          ENDP

                  |L20.48|
                          DCD      0x2ffe0000

                          AREA ||i.IAP_WriteAppBin||, CODE, READONLY, ALIGN=2

                  IAP_WriteAppBin PROC
;;;133    *******************************************************************************/
;;;134    BOOL IAP_WriteAppBin(uint32 appAddr, uint8 *appBuf, uint32 appSize)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;135    {
000004  b0c0              SUB      sp,sp,#0x100
000006  4605              MOV      r5,r0
000008  460c              MOV      r4,r1
00000a  4616              MOV      r6,r2
;;;136    	uint16 i = 0;
00000c  f04f0800          MOV      r8,#0
;;;137    	uint16 j = 0;
000010  2700              MOVS     r7,#0
;;;138    	uint32 curAppAddr = appAddr; 	// 当前写入的地址
000012  46a9              MOV      r9,r5
;;;139    	uint16 iapBuf[125+1];			// 此16位数据需要和串口通讯协议一帧最长字节有关126*2=252个字节
;;;140    	BOOL writeStatus;
;;;141    	
;;;142    	// 参数判断
;;;143    	if (NULL == appBuf)
000014  b91c              CBNZ     r4,|L21.30|
;;;144    	{
;;;145    		return FALSE;
000016  2000              MOVS     r0,#0
                  |L21.24|
;;;146    	}
;;;147    
;;;148    	// 参数检验是否非法，地址不能是IAP本身代码地址，绝对不能自己把自己擦掉
;;;149    	if ((appAddr < IAP_FLASH_APP1_ADDR) || (appAddr >= (IAP_GD32_FLASH_BASE+IAP_GD32_FLASH_SIZE)))
;;;150    	{
;;;151    		return FALSE;	// 非法地址
;;;152    	}
;;;153    	
;;;154    	// 循环写入
;;;155    	for (j = 0; j < appSize; j += 2)
;;;156    	{
;;;157    		// 字节整合
;;;158    		iapBuf[i++] = (uint16)(*appBuf) + ((uint16)(*(appBuf+1)) << 8);
;;;159    		// 偏移2个字节
;;;160    		appBuf += 2;
;;;161    	}
;;;162    
;;;163    	// 直接写入FLASH
;;;164    	writeStatus = IAP_FlashWriteHalfWordArray(curAppAddr, iapBuf, appSize/2);	
;;;165    
;;;166    	return writeStatus;
;;;167    }
000018  b040              ADD      sp,sp,#0x100
00001a  e8bd87f0          POP      {r4-r10,pc}
                  |L21.30|
00001e  4812              LDR      r0,|L21.104|
000020  4285              CMP      r5,r0                 ;149
000022  d302              BCC      |L21.42|
000024  4811              LDR      r0,|L21.108|
000026  4285              CMP      r5,r0                 ;149
000028  d301              BCC      |L21.46|
                  |L21.42|
00002a  2000              MOVS     r0,#0                 ;151
00002c  e7f4              B        |L21.24|
                  |L21.46|
00002e  2700              MOVS     r7,#0                 ;155
000030  e00e              B        |L21.80|
                  |L21.50|
000032  7820              LDRB     r0,[r4,#0]            ;158
000034  7861              LDRB     r1,[r4,#1]            ;158
000036  eb002001          ADD      r0,r0,r1,LSL #8       ;158
00003a  b282              UXTH     r2,r0                 ;158
00003c  4640              MOV      r0,r8                 ;158
00003e  1c41              ADDS     r1,r0,#1              ;158
000040  fa1ff881          UXTH     r8,r1                 ;158
000044  a901              ADD      r1,sp,#4              ;158
000046  f8212010          STRH     r2,[r1,r0,LSL #1]     ;158
00004a  1ca4              ADDS     r4,r4,#2              ;160
00004c  1cb8              ADDS     r0,r7,#2              ;155
00004e  b287              UXTH     r7,r0                 ;155
                  |L21.80|
000050  42b7              CMP      r7,r6                 ;155
000052  d3ee              BCC      |L21.50|
000054  f3c6024f          UBFX     r2,r6,#1,#16          ;164
000058  a901              ADD      r1,sp,#4              ;164
00005a  4648              MOV      r0,r9                 ;164
00005c  f7fffffe          BL       IAP_FlashWriteHalfWordArray
000060  4682              MOV      r10,r0                ;164
000062  4650              MOV      r0,r10                ;166
000064  e7d8              B        |L21.24|
;;;168    
                          ENDP

000066  0000              DCW      0x0000
                  |L21.104|
                          DCD      0x08008000
                  |L21.108|
                          DCD      0x08040000

                          AREA ||.data||, DATA, ALIGN=0

                  iapCB
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "User\\iap.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_iap_c_c37294e4____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___5_iap_c_c37294e4____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_iap_c_c37294e4____REVSH|
#line 128
|__asm___5_iap_c_c37294e4____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
