; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\canprotocol_3a.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\canprotocol_3a.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -I.\User\qrencode -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.3\Device\Include -D__MICROLIB -D__UVISION_VERSION=539 -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\canprotocol_3a.crf User\CanProtocol_3A.c]
                          THUMB

                          AREA ||i.CAN_PROTOCOL1_CALLBACK_UartBusError||, CODE, READONLY, ALIGN=1

                  CAN_PROTOCOL1_CALLBACK_UartBusError PROC
;;;768    //  UART总线超时错误处理
;;;769    void CAN_PROTOCOL1_CALLBACK_UartBusError(uint32 param)
000000  4770              BX       lr
;;;770    {
;;;771    }
;;;772    
                          ENDP


                          AREA ||i.CAN_PROTOCOL1_CheckSUM||, CODE, READONLY, ALIGN=1

                  CAN_PROTOCOL1_CheckSUM PROC
;;;476    // 对传入的命令帧进行校验，返回校验结果
;;;477    BOOL CAN_PROTOCOL1_CheckSUM(CAN_PROTOCOL1_RX_CMD_FRAME *pCmdFrame)
000000  b530              PUSH     {r4,r5,lr}
;;;478    {
000002  4601              MOV      r1,r0
;;;479        uint16 checkSum = 0;
000004  2400              MOVS     r4,#0
;;;480        uint16 sumTemp;
;;;481        uint16 i = 0;
000006  2300              MOVS     r3,#0
;;;482    
;;;483        if (NULL == pCmdFrame)
000008  b909              CBNZ     r1,|L2.14|
;;;484        {
;;;485            return FALSE;
00000a  2000              MOVS     r0,#0
                  |L2.12|
;;;486        }
;;;487    
;;;488        // 从设备地址开始，到校验码之前的一个字节，依次进行累加运算
;;;489        for (i = 1; i < pCmdFrame->length - 4; i++)
;;;490        {
;;;491            checkSum += pCmdFrame->buff[i];
;;;492        }
;;;493    
;;;494        // 累加和，低字节在前，高字节在后
;;;495        sumTemp = pCmdFrame->buff[pCmdFrame->length - 3]; // 高字节
;;;496        sumTemp <<= 8;
;;;497        sumTemp += pCmdFrame->buff[pCmdFrame->length - 4]; // 低字节
;;;498    
;;;499        // 判断计算得到的校验码与命令帧中的校验码是否相同
;;;500        if (sumTemp != checkSum)
;;;501        {
;;;502            return FALSE;
;;;503        }
;;;504    
;;;505        return TRUE;
;;;506    }
00000c  bd30              POP      {r4,r5,pc}
                  |L2.14|
00000e  2301              MOVS     r3,#1                 ;489
000010  e005              B        |L2.30|
                  |L2.18|
000012  1c88              ADDS     r0,r1,#2              ;491
000014  5cc0              LDRB     r0,[r0,r3]            ;491
000016  4420              ADD      r0,r0,r4              ;491
000018  b284              UXTH     r4,r0                 ;491
00001a  1c58              ADDS     r0,r3,#1              ;489
00001c  b283              UXTH     r3,r0                 ;489
                  |L2.30|
00001e  f8b10098          LDRH     r0,[r1,#0x98]         ;489
000022  1f00              SUBS     r0,r0,#4              ;489
000024  4298              CMP      r0,r3                 ;489
000026  dcf4              BGT      |L2.18|
000028  f8b10098          LDRH     r0,[r1,#0x98]         ;495
00002c  1ec0              SUBS     r0,r0,#3              ;495
00002e  1c8d              ADDS     r5,r1,#2              ;495
000030  5c2a              LDRB     r2,[r5,r0]            ;495
000032  f64f70ff          MOV      r0,#0xffff            ;496
000036  ea002202          AND      r2,r0,r2,LSL #8       ;496
00003a  f8b10098          LDRH     r0,[r1,#0x98]         ;497
00003e  1f00              SUBS     r0,r0,#4              ;497
000040  5c28              LDRB     r0,[r5,r0]            ;497
000042  4410              ADD      r0,r0,r2              ;497
000044  b282              UXTH     r2,r0                 ;497
000046  42a2              CMP      r2,r4                 ;500
000048  d001              BEQ      |L2.78|
00004a  2000              MOVS     r0,#0                 ;502
00004c  e7de              B        |L2.12|
                  |L2.78|
00004e  2001              MOVS     r0,#1                 ;505
000050  e7dc              B        |L2.12|
;;;507    
                          ENDP


                          AREA ||i.CAN_PROTOCOL1_CmdFrameProcess||, CODE, READONLY, ALIGN=2

                  CAN_PROTOCOL1_CmdFrameProcess PROC
;;;509    // UART命令帧缓冲区处理
;;;510    void CAN_PROTOCOL1_CmdFrameProcess(CAN_PROTOCOL1_CB *pCB)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;511    {
000004  4605              MOV      r5,r0
;;;512        CAN_PROTOCOL1_CMD cmd = CAN_PROTOCOL1_CMD_NULL;
000006  f04f0800          MOV      r8,#0
;;;513        CAN_PROTOCOL1_RX_CMD_FRAME *pCmdFrame = NULL;
00000a  2400              MOVS     r4,#0
;;;514    
;;;515        BOOL checkMark;
;;;516        uint8_t i = 0;
00000c  2600              MOVS     r6,#0
;;;517        uint8 buffFlag[4] = {0xFF};
00000e  489f              LDR      r0,|L3.652|
000010  6800              LDR      r0,[r0,#0]  ; <Data3>
000012  9000              STR      r0,[sp,#0]
;;;518    
;;;519        // 参数合法性检验
;;;520        if (NULL == pCB)
000014  b90d              CBNZ     r5,|L3.26|
                  |L3.22|
;;;521        {
;;;522            return;
;;;523        }
;;;524    
;;;525        // 命令帧缓冲区为空，退出
;;;526        if (pCB->rx.head == pCB->rx.end)
;;;527        {
;;;528            return;
;;;529        }
;;;530    
;;;531        // 获取当前要处理的命令帧指针
;;;532        pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.head];
;;;533    
;;;534        // 命令头非法，退出
;;;535        if (CAN_PROTOCOL1_CMD_HEAD != pCmdFrame->buff[CAN_PROTOCOL1_CMD_HEAD_INDEX])
;;;536        {
;;;537            // 删除命令帧
;;;538            pCB->rx.head++;
;;;539            pCB->rx.head %= CAN_PROTOCOL1_RX_QUEUE_SIZE;
;;;540            return;
;;;541        }
;;;542    
;;;543        // 命令头合法，则提取命令
;;;544        cmd = (CAN_PROTOCOL1_CMD)pCmdFrame->buff[CAN_PROTOCOL1_CMD_CMD_INDEX];
;;;545        
;;;546        if(CAN_PROTOCOL1_IOT_DEVICE_ADDR == pCmdFrame->buff[CAN_PROTOCOL1_CMD_DEVICE_ADDR_INDEX])
;;;547        {
;;;548            // 执行命令帧
;;;549            switch (cmd)
;;;550            {
;;;551                // 空命令，不予执行
;;;552                case CAN_PROTOCOL1_CMD_NULL: 
;;;553                    break;
;;;554    
;;;555                // 升级请求命令（0xF1）
;;;556                case CAN_PROTOCOL1_CMD_UPDATE_REQUEST: 
;;;557                    TIMER_KillTask(TIMER_ID_SEND_UP_APP_REQUEST);
;;;558                
;;;559                    //   0：设备拒绝升级，1：设备同意升级。 
;;;560                    if(pCmdFrame->buff[CAN_PROTOCOL1_CMD_DATA1_INDEX])
;;;561                    {
;;;562                        STATE_SwitchStep(STEP_IOT_CAN_UPGRADE_SEND_APP_EAR);                    
;;;563                    }
;;;564                    else
;;;565                    {
;;;566                        // 跳到超时处理步骤代表升级失败
;;;567                        STATE_SwitchStep(STEP_IOT_CAN_UPGRADE_COMMUNICATION_TIME_OUT);                 
;;;568                    }
;;;569                    break;
;;;570    
;;;571                // 升级固件命令（0xF2）
;;;572                case CAN_PROTOCOL1_CMD_UPDATE_START: 
;;;573                
;;;574                    //   该命令用于应答升级命令结果，若超过存储空间，则返回0。
;;;575                    if(0 == pCmdFrame->buff[CAN_PROTOCOL1_CMD_DATA1_INDEX])
;;;576                    {
;;;577                        // 跳到超时处理步骤代表升级失败                
;;;578                        STATE_SwitchStep(STEP_IOT_CAN_UPGRADE_COMMUNICATION_TIME_OUT);                    
;;;579                    }
;;;580                    else
;;;581                    {
;;;582                        STATE_SwitchStep(STEP_IOT_CAN_UPGRADE_SEND_FIRST_APP_PACKET);                 
;;;583                    }
;;;584                    break;
;;;585    
;;;586                // 数据包写入命令（0xF3）
;;;587                case CAN_PROTOCOL1_CMD_WRITE_DATA: 
;;;588    
;;;589                    if (1 == pCmdFrame->buff[CAN_PROTOCOL1_CMD_DATA1_INDEX])
;;;590                    {
;;;591                        if (0 < dut_info.currentAppSize)
;;;592                        {
;;;593                            dut_info.currentAppSize--;
;;;594                        }
;;;595                        break;
;;;596                    }
;;;597                    if (dut_info.currentAppSize < dut_info.appSize)
;;;598                    {
;;;599                        STATE_SwitchStep(STEP_IOT_CAN_UPGRADE_SEND_APP_PACKET);
;;;600                    }
;;;601                    else
;;;602                    {
;;;603                        STATE_SwitchStep(STEP_IOT_CAN_UPGRADE_APP_UP_SUCCESS);
;;;604                    }
;;;605                    break;
;;;606    
;;;607                // 数据包写入完成命令（0xF4）0：包传输完成，CRC未通过校验；1：包传输完成，CRC通过校验
;;;608                case CAN_PROTOCOL1_CMD_WRITE_COMPLETE: 
;;;609                
;;;610                    if(0 == pCmdFrame->buff[CAN_PROTOCOL1_CMD_DATA1_INDEX])
;;;611                    {
;;;612                        // 跳到超时处理步骤代表升级失败                
;;;613                        STATE_SwitchStep(STEP_IOT_CAN_UPGRADE_COMMUNICATION_TIME_OUT);                    
;;;614                    }
;;;615                    else
;;;616                    {
;;;617                        STATE_SwitchStep(STEP_IOT_CAN_UPGRADE_ITEM_FINISH);                 
;;;618                    }
;;;619                    break;
;;;620                    
;;;621                default:
;;;622                    break;
;;;623            }         
;;;624        }
;;;625        else
;;;626        {
;;;627            // 执行命令帧
;;;628            switch (cmd)
;;;629            {
;;;630                // 空命令，不予执行
;;;631                case CAN_PROTOCOL1_CMD_NULL:
;;;632                    break;
;;;633    
;;;634                // 写入版本信息
;;;635                case CAN_PROTOCOL1_CMD_VERSION_TYPE_WRITE:
;;;636                    TIMER_KillTask(TIMER_ID_SET_DUT_UI_VER);
;;;637                    writeUiVerFlag = FALSE;
;;;638                    if ((8 ==  pCmdFrame->buff[CAN_PROTOCOL1_CMD_DATA1_INDEX]) && (TRUE == pCmdFrame->buff[CAN_PROTOCOL1_CMD_DATA2_INDEX]))
;;;639                    {
;;;640                        TIMER_KillTask(TIMER_ID_SET_DUT_UI_VER);
;;;641                        STATE_SwitchStep(STEP_CM_CAN_READ_UI_VER);
;;;642                    }
;;;643                    else
;;;644                    {
;;;645                        dut_info.uiUpFaile = TRUE; // ui升级失败
;;;646                        STATE_EnterState(STATE_STANDBY);
;;;647                    }
;;;648                    break;
;;;649    
;;;650                // 读取版本信息
;;;651                case CAN_PROTOCOL1_CMD_VERSION_TYPE_READ:
;;;652                    if (8 ==  pCmdFrame->buff[CAN_PROTOCOL1_CMD_DATA1_INDEX])
;;;653                    {
;;;654                        // 校验
;;;655                        for (i = 0; i < pCmdFrame->buff[CAN_PROTOCOL1_CMD_DATA2_INDEX]; i++)
;;;656                        {
;;;657                            if (uiVerifiedBuff[i] != pCmdFrame->buff[CAN_PROTOCOL1_CMD_DATA3_INDEX + i])
;;;658                            {
;;;659                                checkMark = FALSE;  // 发现不匹配，设置标志为假
;;;660                                break;              // 跳出循环
;;;661                            }
;;;662                            else
;;;663                            {
;;;664                                checkMark = TRUE;   // 所有元素都匹配，设置标志为真
;;;665                            }
;;;666                        }
;;;667    
;;;668                        if (checkMark)
;;;669                        {
;;;670                            STATE_SwitchStep(STEP_CM_CAN_WRITE_UI_VER_SUCCESS);
;;;671                        }
;;;672                        else
;;;673                        {
;;;674                            dut_info.uiUpFaile = TRUE; // ui升级失败
;;;675                            STATE_EnterState(STATE_STANDBY);
;;;676                        }
;;;677                    }
;;;678                    else
;;;679                    {
;;;680                        dut_info.uiUpFaile = TRUE; // ui升级失败
;;;681                        STATE_EnterState(STATE_STANDBY);
;;;682                    }
;;;683                    break;
;;;684    
;;;685                // 0xC1,写配置信息应答
;;;686                case CAN_PROTOCOL1_CMD_WRITE_CONTROL_PARAM_RESULT:
;;;687                    // 有应答代表配置信息升级成功
;;;688                    STATE_SwitchStep(STEP_CAN_READ_CONFIG);
;;;689                    break;
;;;690    
;;;691                // 0xc3,读取配置参数，配置参数校验
;;;692                case CAN_PROTOCOL1_CMD_READ_CONTROL_PARAM_REPORT:
;;;693    
;;;694                    // 校验
;;;695                    for (i = 0; i < pCmdFrame->buff[CAN_PROTOCOL1_CMD_LENGTH_INDEX]; i++)
;;;696                    {
;;;697                        if (verifiedBuff[i] != pCmdFrame->buff[CAN_PROTOCOL1_CMD_DATA1_INDEX + i])
;;;698                        {
;;;699                            checkMark = FALSE;  // 发现不匹配，设置标志为假
;;;700                            break;              // 跳出循环
;;;701                        }
;;;702                        else
;;;703                        {
;;;704                            checkMark = TRUE;   // 所有元素都匹配，设置标志为真
;;;705                        }
;;;706                    }
;;;707    
;;;708                    if (checkMark)
;;;709                    {
;;;710        //                STATE_SwitchStep(STEP_CAN_SET_CONFIG_SUCCESS);
;;;711                        STATE_SwitchStep(STEP_CAN_DCD_FLAG_WRITE);
;;;712                    }
;;;713                    else
;;;714                    {
;;;715                        dut_info.configUpFaile = TRUE; // config升级失败
;;;716                        STATE_EnterState(STATE_STANDBY);
;;;717                    }
;;;718                    break;
;;;719    
;;;720                // 写入DCD工位标志位
;;;721                case CAN_PROTOCOL1_CMD_DCD_FLAG_WRITE:   
;;;722                
;;;723                    // 校验标志区数据
;;;724                    if (pCmdFrame->buff[CAN_PROTOCOL1_CMD_DATA1_INDEX])
;;;725                    {
;;;726                        STATE_SwitchStep(STEP_CAN_DCD_FLAG_READ);
;;;727                    }
;;;728                    else
;;;729                    {
;;;730                        dut_info.configUpFaile = TRUE; // config升级失败
;;;731                        STATE_EnterState(STATE_STANDBY);
;;;732                    }         
;;;733                  break;
;;;734    
;;;735                // 读取DCD工位标志位
;;;736                case CAN_PROTOCOL1_CMD_DCD_FLAG_READ:
;;;737                
;;;738                     // 起始符 + 设备地址 + 命令字 + 数据长度 + 标志区数据长度 + （数据 +）×N + 校验码 + 结束符
;;;739                     // 读取DCD标志区数据（站位编号 * （每个标志位四个数据） + （第一个标志位前的数据(即数据前有五个数据)） + 第几个标志位）
;;;740                    for (i = 0; i < 4; i++)
;;;741                    {
;;;742                        buffFlag[i] = pCmdFrame->buff[(5 * 4) + 5 + i];
;;;743                    }
;;;744    
;;;745                    // 校验标志区数据
;;;746                    if ((buffFlag[0] == 0x00) && (buffFlag[1] == 0x00) && (buffFlag[2] == 0x00) && (buffFlag[3] == 0x02))
;;;747                    {
;;;748                        STATE_SwitchStep(STEP_CAN_SET_CONFIG_SUCCESS);
;;;749                    }
;;;750                    else
;;;751                    {
;;;752                        dut_info.configUpFaile = TRUE; // config升级失败
;;;753                        STATE_EnterState(STATE_STANDBY);
;;;754                    }              
;;;755                  break;
;;;756    
;;;757                default:
;;;758                    break;
;;;759            }    
;;;760        }
;;;761        
;;;762    
;;;763        // 删除命令帧
;;;764        pCB->rx.head++;
;;;765        pCB->rx.head %= CAN_PROTOCOL1_RX_QUEUE_SIZE;
;;;766    }
000016  e8bd83f8          POP      {r3-r9,pc}
                  |L3.26|
00001a  f8b5129c          LDRH     r1,[r5,#0x29c]        ;526
00001e  f8b5029e          LDRH     r0,[r5,#0x29e]        ;526
000022  4281              CMP      r1,r0                 ;526
000024  d100              BNE      |L3.40|
000026  e7f6              B        |L3.22|
                  |L3.40|
000028  f8b5029c          LDRH     r0,[r5,#0x29c]        ;532
00002c  214d              MOVS     r1,#0x4d              ;532
00002e  4348              MULS     r0,r1,r0              ;532
000030  f10501ce          ADD      r1,r5,#0xce           ;532
000034  eb010440          ADD      r4,r1,r0,LSL #1       ;532
000038  78a0              LDRB     r0,[r4,#2]            ;535
00003a  283a              CMP      r0,#0x3a              ;535
00003c  d00e              BEQ      |L3.92|
00003e  f8b5029c          LDRH     r0,[r5,#0x29c]        ;538
000042  1c40              ADDS     r0,r0,#1              ;538
000044  f8a5029c          STRH     r0,[r5,#0x29c]        ;538
000048  f8b5029c          LDRH     r0,[r5,#0x29c]        ;539
00004c  2103              MOVS     r1,#3                 ;539
00004e  fb90f2f1          SDIV     r2,r0,r1              ;539
000052  fb010012          MLS      r0,r1,r2,r0           ;539
000056  f8a5029c          STRH     r0,[r5,#0x29c]        ;539
00005a  e7dc              B        |L3.22|
                  |L3.92|
00005c  f8948004          LDRB     r8,[r4,#4]            ;544
000060  78e0              LDRB     r0,[r4,#3]            ;546
000062  282a              CMP      r0,#0x2a              ;546
000064  d150              BNE      |L3.264|
000066  f1b80ff2          CMP      r8,#0xf2              ;549
00006a  d01c              BEQ      |L3.166|
00006c  dc06              BGT      |L3.124|
00006e  f1b80f00          CMP      r8,#0                 ;549
000072  d00a              BEQ      |L3.138|
000074  f1b80ff1          CMP      r8,#0xf1              ;549
000078  d144              BNE      |L3.260|
00007a  e007              B        |L3.140|
                  |L3.124|
00007c  f1b80ff3          CMP      r8,#0xf3              ;549
000080  d01b              BEQ      |L3.186|
000082  f1b80ff4          CMP      r8,#0xf4              ;549
000086  d13d              BNE      |L3.260|
000088  e032              B        |L3.240|
                  |L3.138|
00008a  e03c              B        |L3.262|
                  |L3.140|
00008c  2011              MOVS     r0,#0x11              ;557
00008e  f7fffffe          BL       TIMER_KillTask
000092  79a0              LDRB     r0,[r4,#6]            ;560
000094  b118              CBZ      r0,|L3.158|
000096  2049              MOVS     r0,#0x49              ;562
000098  f7fffffe          BL       STATE_SwitchStep
00009c  e002              B        |L3.164|
                  |L3.158|
00009e  204e              MOVS     r0,#0x4e              ;567
0000a0  f7fffffe          BL       STATE_SwitchStep
                  |L3.164|
0000a4  e02f              B        |L3.262|
                  |L3.166|
0000a6  79a0              LDRB     r0,[r4,#6]            ;575
0000a8  b918              CBNZ     r0,|L3.178|
0000aa  204e              MOVS     r0,#0x4e              ;578
0000ac  f7fffffe          BL       STATE_SwitchStep
0000b0  e002              B        |L3.184|
                  |L3.178|
0000b2  204a              MOVS     r0,#0x4a              ;582
0000b4  f7fffffe          BL       STATE_SwitchStep
                  |L3.184|
0000b8  e025              B        |L3.262|
                  |L3.186|
0000ba  79a0              LDRB     r0,[r4,#6]            ;589
0000bc  2801              CMP      r0,#1                 ;589
0000be  d109              BNE      |L3.212|
0000c0  4873              LDR      r0,|L3.656|
0000c2  6b00              LDR      r0,[r0,#0x30]         ;591  ; dut_info
0000c4  2800              CMP      r0,#0                 ;591
0000c6  d904              BLS      |L3.210|
0000c8  4871              LDR      r0,|L3.656|
0000ca  6b00              LDR      r0,[r0,#0x30]         ;593  ; dut_info
0000cc  1e40              SUBS     r0,r0,#1              ;593
0000ce  4970              LDR      r1,|L3.656|
0000d0  6308              STR      r0,[r1,#0x30]         ;593  ; dut_info
                  |L3.210|
0000d2  e018              B        |L3.262|
                  |L3.212|
0000d4  486e              LDR      r0,|L3.656|
0000d6  6b00              LDR      r0,[r0,#0x30]         ;597  ; dut_info
0000d8  496d              LDR      r1,|L3.656|
0000da  6a49              LDR      r1,[r1,#0x24]         ;597  ; dut_info
0000dc  4288              CMP      r0,r1                 ;597
0000de  d203              BCS      |L3.232|
0000e0  204b              MOVS     r0,#0x4b              ;599
0000e2  f7fffffe          BL       STATE_SwitchStep
0000e6  e002              B        |L3.238|
                  |L3.232|
0000e8  204c              MOVS     r0,#0x4c              ;603
0000ea  f7fffffe          BL       STATE_SwitchStep
                  |L3.238|
0000ee  e00a              B        |L3.262|
                  |L3.240|
0000f0  79a0              LDRB     r0,[r4,#6]            ;610
0000f2  b918              CBNZ     r0,|L3.252|
0000f4  204e              MOVS     r0,#0x4e              ;613
0000f6  f7fffffe          BL       STATE_SwitchStep
0000fa  e002              B        |L3.258|
                  |L3.252|
0000fc  204d              MOVS     r0,#0x4d              ;617
0000fe  f7fffffe          BL       STATE_SwitchStep
                  |L3.258|
000102  e000              B        |L3.262|
                  |L3.260|
000104  bf00              NOP                            ;622
                  |L3.262|
000106  e0b1              B        |L3.620|
                  |L3.264|
000108  f1b80fa8          CMP      r8,#0xa8              ;628
00010c  d015              BEQ      |L3.314|
00010e  dc09              BGT      |L3.292|
000110  f1b80f00          CMP      r8,#0                 ;628
000114  d010              BEQ      |L3.312|
000116  f1b80fa6          CMP      r8,#0xa6              ;628
00011a  d072              BEQ      |L3.514|
00011c  f1b80fa7          CMP      r8,#0xa7              ;628
                  |L3.288|
000120  d170              BNE      |L3.516|
000122  e070              B        |L3.518|
                  |L3.292|
000124  f1b80fa9          CMP      r8,#0xa9              ;628
000128  d021              BEQ      |L3.366|
00012a  f1b80fc1          CMP      r8,#0xc1              ;628
00012e  d046              BEQ      |L3.446|
000130  f1b80fc3          CMP      r8,#0xc3              ;628
000134  d1f4              BNE      |L3.288|
000136  e046              B        |L3.454|
                  |L3.312|
000138  e097              B        |L3.618|
                  |L3.314|
00013a  2010              MOVS     r0,#0x10              ;636
00013c  f7fffffe          BL       TIMER_KillTask
000140  2000              MOVS     r0,#0                 ;637
000142  4954              LDR      r1,|L3.660|
000144  7008              STRB     r0,[r1,#0]            ;637
000146  79a0              LDRB     r0,[r4,#6]            ;638
000148  2808              CMP      r0,#8                 ;638
00014a  d109              BNE      |L3.352|
00014c  79e0              LDRB     r0,[r4,#7]            ;638
00014e  2801              CMP      r0,#1                 ;638
000150  d106              BNE      |L3.352|
000152  2010              MOVS     r0,#0x10              ;640
000154  f7fffffe          BL       TIMER_KillTask
000158  2018              MOVS     r0,#0x18              ;641
00015a  f7fffffe          BL       STATE_SwitchStep
00015e  e005              B        |L3.364|
                  |L3.352|
000160  2001              MOVS     r0,#1                 ;645
000162  494b              LDR      r1,|L3.656|
000164  f881003a          STRB     r0,[r1,#0x3a]         ;645
000168  f7fffffe          BL       STATE_EnterState
                  |L3.364|
00016c  e07d              B        |L3.618|
                  |L3.366|
00016e  79a0              LDRB     r0,[r4,#6]            ;652
000170  2808              CMP      r0,#8                 ;652
000172  d11d              BNE      |L3.432|
000174  2600              MOVS     r6,#0                 ;655
000176  e00b              B        |L3.400|
                  |L3.376|
000178  4847              LDR      r0,|L3.664|
00017a  5d82              LDRB     r2,[r0,r6]            ;657
00017c  1db0              ADDS     r0,r6,#6              ;657
00017e  1ca1              ADDS     r1,r4,#2              ;657
000180  5c08              LDRB     r0,[r1,r0]            ;657
000182  4282              CMP      r2,r0                 ;657
000184  d001              BEQ      |L3.394|
000186  2700              MOVS     r7,#0                 ;659
000188  e005              B        |L3.406|
                  |L3.394|
00018a  2701              MOVS     r7,#1                 ;664
00018c  1c70              ADDS     r0,r6,#1              ;655
00018e  b2c6              UXTB     r6,r0                 ;655
                  |L3.400|
000190  79e0              LDRB     r0,[r4,#7]            ;655
000192  42b0              CMP      r0,r6                 ;655
000194  dcf0              BGT      |L3.376|
                  |L3.406|
000196  bf00              NOP                            ;660
000198  b11f              CBZ      r7,|L3.418|
00019a  2019              MOVS     r0,#0x19              ;670
00019c  f7fffffe          BL       STATE_SwitchStep
0001a0  e00c              B        |L3.444|
                  |L3.418|
0001a2  2001              MOVS     r0,#1                 ;674
0001a4  493a              LDR      r1,|L3.656|
0001a6  f881003a          STRB     r0,[r1,#0x3a]         ;674
0001aa  f7fffffe          BL       STATE_EnterState
0001ae  e005              B        |L3.444|
                  |L3.432|
0001b0  2001              MOVS     r0,#1                 ;680
0001b2  4937              LDR      r1,|L3.656|
0001b4  f881003a          STRB     r0,[r1,#0x3a]         ;680
0001b8  f7fffffe          BL       STATE_EnterState
                  |L3.444|
0001bc  e055              B        |L3.618|
                  |L3.446|
0001be  2052              MOVS     r0,#0x52              ;688
0001c0  f7fffffe          BL       STATE_SwitchStep
0001c4  e051              B        |L3.618|
                  |L3.454|
0001c6  2600              MOVS     r6,#0                 ;695
0001c8  e00b              B        |L3.482|
                  |L3.458|
0001ca  4834              LDR      r0,|L3.668|
0001cc  5d82              LDRB     r2,[r0,r6]            ;697
0001ce  1d30              ADDS     r0,r6,#4              ;697
0001d0  1ca1              ADDS     r1,r4,#2              ;697
0001d2  5c08              LDRB     r0,[r1,r0]            ;697
0001d4  4282              CMP      r2,r0                 ;697
0001d6  d001              BEQ      |L3.476|
0001d8  2700              MOVS     r7,#0                 ;699
0001da  e005              B        |L3.488|
                  |L3.476|
0001dc  2701              MOVS     r7,#1                 ;704
0001de  1c70              ADDS     r0,r6,#1              ;695
0001e0  b2c6              UXTB     r6,r0                 ;695
                  |L3.482|
0001e2  7960              LDRB     r0,[r4,#5]            ;695
0001e4  42b0              CMP      r0,r6                 ;695
0001e6  dcf0              BGT      |L3.458|
                  |L3.488|
0001e8  bf00              NOP                            ;700
0001ea  b11f              CBZ      r7,|L3.500|
0001ec  2053              MOVS     r0,#0x53              ;711
0001ee  f7fffffe          BL       STATE_SwitchStep
0001f2  e005              B        |L3.512|
                  |L3.500|
0001f4  2001              MOVS     r0,#1                 ;715
0001f6  4926              LDR      r1,|L3.656|
0001f8  f881003b          STRB     r0,[r1,#0x3b]         ;715
0001fc  f7fffffe          BL       STATE_EnterState
                  |L3.512|
000200  e033              B        |L3.618|
                  |L3.514|
000202  e00d              B        |L3.544|
                  |L3.516|
000204  e030              B        |L3.616|
                  |L3.518|
000206  79a0              LDRB     r0,[r4,#6]            ;724
000208  b118              CBZ      r0,|L3.530|
00020a  2054              MOVS     r0,#0x54              ;726
00020c  f7fffffe          BL       STATE_SwitchStep
000210  e005              B        |L3.542|
                  |L3.530|
000212  2001              MOVS     r0,#1                 ;730
000214  491e              LDR      r1,|L3.656|
000216  f881003b          STRB     r0,[r1,#0x3b]         ;730
00021a  f7fffffe          BL       STATE_EnterState
                  |L3.542|
00021e  e024              B        |L3.618|
                  |L3.544|
000220  2600              MOVS     r6,#0                 ;740
000222  e007              B        |L3.564|
                  |L3.548|
000224  f1060019          ADD      r0,r6,#0x19           ;742
000228  1ca1              ADDS     r1,r4,#2              ;742
00022a  5c08              LDRB     r0,[r1,r0]            ;742
00022c  f80d0006          STRB     r0,[sp,r6]            ;742
000230  1c70              ADDS     r0,r6,#1              ;740
000232  b2c6              UXTB     r6,r0                 ;740
                  |L3.564|
000234  2e04              CMP      r6,#4                 ;740
000236  dbf5              BLT      |L3.548|
000238  f89d0000          LDRB     r0,[sp,#0]            ;746
00023c  b968              CBNZ     r0,|L3.602|
00023e  f89d0001          LDRB     r0,[sp,#1]            ;746
000242  b950              CBNZ     r0,|L3.602|
000244  f89d0002          LDRB     r0,[sp,#2]            ;746
000248  b938              CBNZ     r0,|L3.602|
00024a  f89d0003          LDRB     r0,[sp,#3]            ;746
00024e  2802              CMP      r0,#2                 ;746
000250  d103              BNE      |L3.602|
000252  2051              MOVS     r0,#0x51              ;748
000254  f7fffffe          BL       STATE_SwitchStep
000258  e005              B        |L3.614|
                  |L3.602|
00025a  2001              MOVS     r0,#1                 ;752
00025c  490c              LDR      r1,|L3.656|
00025e  f881003b          STRB     r0,[r1,#0x3b]         ;752
000262  f7fffffe          BL       STATE_EnterState
                  |L3.614|
000266  e000              B        |L3.618|
                  |L3.616|
000268  bf00              NOP                            ;758
                  |L3.618|
00026a  bf00              NOP                            ;632
                  |L3.620|
00026c  f8b5029c          LDRH     r0,[r5,#0x29c]        ;764
000270  1c40              ADDS     r0,r0,#1              ;764
000272  f8a5029c          STRH     r0,[r5,#0x29c]        ;764
000276  f8b5029c          LDRH     r0,[r5,#0x29c]        ;765
00027a  2103              MOVS     r1,#3                 ;765
00027c  fb90f2f1          SDIV     r2,r0,r1              ;765
000280  fb010012          MLS      r0,r1,r2,r0           ;765
000284  f8a5029c          STRH     r0,[r5,#0x29c]        ;765
000288  bf00              NOP      
00028a  e6c4              B        |L3.22|
;;;767    
                          ENDP

                  |L3.652|
                          DCD      ||.constdata||
                  |L3.656|
                          DCD      dut_info
                  |L3.660|
                          DCD      writeUiVerFlag
                  |L3.664|
                          DCD      uiVerifiedBuff
                  |L3.668|
                          DCD      verifiedBuff

                          AREA ||i.CAN_PROTOCOL1_ConfirmTempCmdFrameBuff||, CODE, READONLY, ALIGN=1

                  CAN_PROTOCOL1_ConfirmTempCmdFrameBuff PROC
;;;257    // 将临时缓冲区添加到命令帧缓冲区中，其本质操作是承认临时缓冲区数据有效
;;;258    BOOL CAN_PROTOCOL1_ConfirmTempCmdFrameBuff(CAN_PROTOCOL1_CB *pCB)
000000  b510              PUSH     {r4,lr}
;;;259    {
000002  4601              MOV      r1,r0
;;;260        CAN_PROTOCOL1_RX_CMD_FRAME *pCmdFrame = NULL;
000004  2200              MOVS     r2,#0
;;;261    
;;;262        // 参数合法性检验
;;;263        if (NULL == pCB)
000006  b909              CBNZ     r1,|L4.12|
;;;264        {
;;;265            return FALSE;
000008  2000              MOVS     r0,#0
                  |L4.10|
;;;266        }
;;;267    
;;;268        // 临时缓冲区为空，不予添加
;;;269        pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.end];
;;;270        if (0 == pCmdFrame->length)
;;;271        {
;;;272            return FALSE;
;;;273        }
;;;274    
;;;275        // 添加
;;;276        pCB->rx.end++;
;;;277        pCB->rx.end %= CAN_PROTOCOL1_RX_QUEUE_SIZE;
;;;278        pCB->rx.cmdQueue[pCB->rx.end].length = 0; // 该行的作用是将新的添加位置有效数据个数清零，以便将这个位置当做临时帧缓冲区
;;;279    
;;;280        return TRUE;
;;;281    }
00000a  bd10              POP      {r4,pc}
                  |L4.12|
00000c  f8b1029e          LDRH     r0,[r1,#0x29e]        ;269
000010  234d              MOVS     r3,#0x4d              ;269
000012  4358              MULS     r0,r3,r0              ;269
000014  f10103ce          ADD      r3,r1,#0xce           ;269
000018  eb030240          ADD      r2,r3,r0,LSL #1       ;269
00001c  f8b20098          LDRH     r0,[r2,#0x98]         ;270
000020  b908              CBNZ     r0,|L4.38|
000022  2000              MOVS     r0,#0                 ;272
000024  e7f1              B        |L4.10|
                  |L4.38|
000026  f8b1029e          LDRH     r0,[r1,#0x29e]        ;276
00002a  1c40              ADDS     r0,r0,#1              ;276
00002c  f8a1029e          STRH     r0,[r1,#0x29e]        ;276
000030  f8b1029e          LDRH     r0,[r1,#0x29e]        ;277
000034  2303              MOVS     r3,#3                 ;277
000036  fb90f4f3          SDIV     r4,r0,r3              ;277
00003a  fb030014          MLS      r0,r3,r4,r0           ;277
00003e  f8a1029e          STRH     r0,[r1,#0x29e]        ;277
000042  2400              MOVS     r4,#0                 ;278
000044  f8b1029e          LDRH     r0,[r1,#0x29e]        ;278
000048  234d              MOVS     r3,#0x4d              ;278
00004a  4358              MULS     r0,r3,r0              ;278
00004c  f10103ce          ADD      r3,r1,#0xce           ;278
000050  eb030040          ADD      r0,r3,r0,LSL #1       ;278
000054  f8a04098          STRH     r4,[r0,#0x98]         ;278
000058  2001              MOVS     r0,#1                 ;280
00005a  e7d6              B        |L4.10|
;;;282    
                          ENDP


                          AREA ||i.CAN_PROTOCOL1_DataStructInit||, CODE, READONLY, ALIGN=1

                  CAN_PROTOCOL1_DataStructInit PROC
;;;187    // 数据结构初始化
;;;188    void CAN_PROTOCOL1_DataStructInit(CAN_PROTOCOL1_CB *pCB)
000000  b510              PUSH     {r4,lr}
;;;189    {
;;;190        uint16 i;
;;;191    
;;;192        // 参数合法性检验
;;;193        if (NULL == pCB)
000002  b900              CBNZ     r0,|L5.6|
                  |L5.4|
;;;194        {
;;;195            return;
;;;196        }
;;;197    
;;;198        pCB->tx.txBusy = FALSE;
;;;199        pCB->tx.index = 0;
;;;200        pCB->tx.head = 0;
;;;201        pCB->tx.end = 0;
;;;202        for (i = 0; i < CAN_PROTOCOL1_TX_QUEUE_SIZE; i++)
;;;203        {
;;;204            pCB->tx.cmdQueue[i].length = 0;
;;;205        }
;;;206    
;;;207        pCB->rxFIFO.head = 0;
;;;208        pCB->rxFIFO.end = 0;
;;;209        pCB->rxFIFO.currentProcessIndex = 0;
;;;210    
;;;211        pCB->rx.head = 0;
;;;212        pCB->rx.end = 0;
;;;213        for (i = 0; i < CAN_PROTOCOL1_RX_QUEUE_SIZE; i++)
;;;214        {
;;;215            pCB->rx.cmdQueue[i].length = 0;
;;;216        }
;;;217    }
000004  bd10              POP      {r4,pc}
                  |L5.6|
000006  2300              MOVS     r3,#0                 ;198
000008  f8803474          STRB     r3,[r0,#0x474]        ;198
00000c  f8a03472          STRH     r3,[r0,#0x472]        ;199
000010  f8a0346e          STRH     r3,[r0,#0x46e]        ;200
000014  f8a03470          STRH     r3,[r0,#0x470]        ;201
000018  2100              MOVS     r1,#0                 ;202
00001a  e00a              B        |L5.50|
                  |L5.28|
00001c  2400              MOVS     r4,#0                 ;204
00001e  224d              MOVS     r2,#0x4d              ;204
000020  434a              MULS     r2,r1,r2              ;204
000022  f5007328          ADD      r3,r0,#0x2a0          ;204
000026  eb030242          ADD      r2,r3,r2,LSL #1       ;204
00002a  f8a24098          STRH     r4,[r2,#0x98]         ;204
00002e  1c4a              ADDS     r2,r1,#1              ;202
000030  b291              UXTH     r1,r2                 ;202
                  |L5.50|
000032  2903              CMP      r1,#3                 ;202
000034  dbf2              BLT      |L5.28|
000036  2200              MOVS     r2,#0                 ;207
000038  f8202fc8          STRH     r2,[r0,#0xc8]!        ;207
00003c  8042              STRH     r2,[r0,#2]            ;208
00003e  8082              STRH     r2,[r0,#4]            ;209
000040  38c8              SUBS     r0,r0,#0xc8           ;209
000042  2300              MOVS     r3,#0                 ;211
000044  f8a0329c          STRH     r3,[r0,#0x29c]        ;211
000048  f8a0329e          STRH     r3,[r0,#0x29e]        ;212
00004c  2100              MOVS     r1,#0                 ;213
00004e  e00a              B        |L5.102|
                  |L5.80|
000050  2400              MOVS     r4,#0                 ;215
000052  224d              MOVS     r2,#0x4d              ;215
000054  434a              MULS     r2,r1,r2              ;215
000056  f10003ce          ADD      r3,r0,#0xce           ;215
00005a  eb030242          ADD      r2,r3,r2,LSL #1       ;215
00005e  f8a24098          STRH     r4,[r2,#0x98]         ;215
000062  1c4a              ADDS     r2,r1,#1              ;213
000064  b291              UXTH     r1,r2                 ;213
                  |L5.102|
000066  2903              CMP      r1,#3                 ;213
000068  dbf2              BLT      |L5.80|
00006a  bf00              NOP      
00006c  e7ca              B        |L5.4|
;;;218    
                          ENDP


                          AREA ||i.CAN_PROTOCOL1_Init||, CODE, READONLY, ALIGN=2

                  CAN_PROTOCOL1_Init PROC
;;;82     // 协议初始化
;;;83     void CAN_PROTOCOL1_Init(void)
000000  b500              PUSH     {lr}
;;;84     {
;;;85         // 协议层数据结构初始化
;;;86         CAN_PROTOCOL1_DataStructInit(&canProtocol1CB);
000002  4803              LDR      r0,|L6.16|
000004  f7fffffe          BL       CAN_PROTOCOL1_DataStructInit
;;;87     
;;;88         // 向驱动层注册数据接收接口
;;;89         // CAN_DRIVE_RegisterDataSendService(CAN_PROTOCOL1_MacProcess);
;;;90     
;;;91         // 向驱动层注册数据发送接口
;;;92         CAN_PROTOCOL1_RegisterDataSendService(CAN_DRIVE_AddTxArray);
000008  4802              LDR      r0,|L6.20|
00000a  f7fffffe          BL       CAN_PROTOCOL1_RegisterDataSendService
;;;93         //
;;;94         //  TIMER_AddTask(TIMER_ID_CAN_TEST,
;;;95         //              1500,
;;;96         //              can_test,
;;;97         //              TRUE,
;;;98         //              4,
;;;99         //              ACTION_MODE_ADD_TO_QUEUE);
;;;100    }
00000e  bd00              POP      {pc}
;;;101    
                          ENDP

                  |L6.16|
                          DCD      canProtocol1CB
                  |L6.20|
                          DCD      CAN_DRIVE_AddTxArray

                          AREA ||i.CAN_PROTOCOL1_MacProcess||, CODE, READONLY, ALIGN=2

                  CAN_PROTOCOL1_MacProcess PROC
;;;219    // UART报文接收处理函数(注意根据具体模块修改)
;;;220    void CAN_PROTOCOL1_MacProcess(uint32 standarID, uint8 *pData, uint16 length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;221    {
000004  4606              MOV      r6,r0
;;;222        uint16 end = canProtocol1CB.rxFIFO.end;
000006  4f23              LDR      r7,|L7.148|
000008  f8b750ca          LDRH     r5,[r7,#0xca]  ; canProtocol1CB
;;;223        uint16 head = canProtocol1CB.rxFIFO.head;
00000c  f8b700c8          LDRH     r0,[r7,#0xc8]  ; canProtocol1CB
;;;224        uint16 i = 0;
000010  2300              MOVS     r3,#0
;;;225        uint8 *rxdata = pData;
000012  460c              MOV      r4,r1
;;;226    
;;;227        // ■■环形列队，入队■■
;;;228        //  一级缓冲区已满，不予接收
;;;229        if ((end + 1) % CAN_PROTOCOL1_RX_FIFO_SIZE == head)
000014  1c6f              ADDS     r7,r5,#1
000016  f04f0cc8          MOV      r12,#0xc8
00001a  fb97f8fc          SDIV     r8,r7,r12
00001e  fb0c7718          MLS      r7,r12,r8,r7
000022  4287              CMP      r7,r0
000024  d101              BNE      |L7.42|
                  |L7.38|
;;;230        {
;;;231            return;
;;;232        }
;;;233    
;;;234        for (i = 0; i < length; i++)
;;;235        {
;;;236            // 单个字节读取，并放入FIFO中
;;;237            canProtocol1CB.rxFIFO.buff[canProtocol1CB.rxFIFO.end] = *rxdata++;
;;;238    
;;;239            canProtocol1CB.rxFIFO.end++;
;;;240    
;;;241            // 一级缓冲区已满，不予接收
;;;242            if ((canProtocol1CB.rxFIFO.end + 1) % CAN_PROTOCOL1_RX_FIFO_SIZE == head)
;;;243            {
;;;244                break;
;;;245            }
;;;246    
;;;247            canProtocol1CB.rxFIFO.end %= CAN_PROTOCOL1_RX_FIFO_SIZE;
;;;248        }
;;;249    }
000026  e8bd81f0          POP      {r4-r8,pc}
                  |L7.42|
00002a  2300              MOVS     r3,#0                 ;234
00002c  e02c              B        |L7.136|
                  |L7.46|
00002e  f8147b01          LDRB     r7,[r4],#1            ;237
000032  f8dfc060          LDR      r12,|L7.148|
000036  f8bcc0ca          LDRH     r12,[r12,#0xca]       ;237  ; canProtocol1CB
00003a  f8df8058          LDR      r8,|L7.148|
00003e  f808700c          STRB     r7,[r8,r12]           ;237
000042  4647              MOV      r7,r8                 ;239
000044  f8b770ca          LDRH     r7,[r7,#0xca]         ;239  ; canProtocol1CB
000048  1c7f              ADDS     r7,r7,#1              ;239
00004a  46c4              MOV      r12,r8                ;239
00004c  f8ac70ca          STRH     r7,[r12,#0xca]        ;239
000050  4647              MOV      r7,r8                 ;242
000052  f8b770ca          LDRH     r7,[r7,#0xca]         ;242  ; canProtocol1CB
000056  1c7f              ADDS     r7,r7,#1              ;242
000058  f04f0cc8          MOV      r12,#0xc8             ;242
00005c  fb97f8fc          SDIV     r8,r7,r12             ;242
000060  fb0c7718          MLS      r7,r12,r8,r7          ;242
000064  4287              CMP      r7,r0                 ;242
000066  d100              BNE      |L7.106|
000068  e010              B        |L7.140|
                  |L7.106|
00006a  4f0a              LDR      r7,|L7.148|
00006c  f8b770ca          LDRH     r7,[r7,#0xca]         ;247  ; canProtocol1CB
000070  f04f0cc8          MOV      r12,#0xc8             ;247
000074  fb97f8fc          SDIV     r8,r7,r12             ;247
000078  fb0c7718          MLS      r7,r12,r8,r7          ;247
00007c  f8dfc014          LDR      r12,|L7.148|
000080  f8ac70ca          STRH     r7,[r12,#0xca]        ;247
000084  1c5f              ADDS     r7,r3,#1              ;234
000086  b2bb              UXTH     r3,r7                 ;234
                  |L7.136|
000088  4293              CMP      r3,r2                 ;234
00008a  dbd0              BLT      |L7.46|
                  |L7.140|
00008c  bf00              NOP                            ;244
00008e  bf00              NOP      
000090  e7c9              B        |L7.38|
;;;250    
                          ENDP

000092  0000              DCW      0x0000
                  |L7.148|
                          DCD      canProtocol1CB

                          AREA ||i.CAN_PROTOCOL1_RegisterDataSendService||, CODE, READONLY, ALIGN=2

                  CAN_PROTOCOL1_RegisterDataSendService PROC
;;;251    // UART协议层向驱动层注册数据发送接口
;;;252    void CAN_PROTOCOL1_RegisterDataSendService(BOOL (*service)(uint32 id, uint8 *pData, uint8 length))
000000  4901              LDR      r1,|L8.8|
;;;253    {
;;;254        canProtocol1CB.sendDataThrowService = service;
000002  f8c10478          STR      r0,[r1,#0x478]  ; canProtocol1CB
;;;255    }
000006  4770              BX       lr
;;;256    
                          ENDP

                  |L8.8|
                          DCD      canProtocol1CB

                          AREA ||i.CAN_PROTOCOL1_ReportWriteParamResult||, CODE, READONLY, ALIGN=1

                  CAN_PROTOCOL1_ReportWriteParamResult PROC
;;;773    // 上报写配置参数结果
;;;774    void CAN_PROTOCOL1_ReportWriteParamResult(uint32 param)
000000  b510              PUSH     {r4,lr}
;;;775    {
000002  4604              MOV      r4,r0
;;;776        // 添加命令头
;;;777        CAN_PROTOCOL1_TxAddData(CAN_PROTOCOL1_CMD_HEAD);
000004  203a              MOVS     r0,#0x3a
000006  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;778    
;;;779        // 添加设备地址
;;;780        CAN_PROTOCOL1_TxAddData(CAN_PROTOCOL1_CMD_DEVICE_ADDR);
00000a  201a              MOVS     r0,#0x1a
00000c  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;781    
;;;782        // 添加命令字
;;;783        CAN_PROTOCOL1_TxAddData(CAN_PROTOCOL1_CMD_WRITE_CONTROL_PARAM_RESULT);
000010  20c1              MOVS     r0,#0xc1
000012  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;784    
;;;785        // 添加数据长度
;;;786        CAN_PROTOCOL1_TxAddData(1);
000016  2001              MOVS     r0,#1
000018  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;787    
;;;788        // 写入结果
;;;789        CAN_PROTOCOL1_TxAddData(param);
00001c  b2e0              UXTB     r0,r4
00001e  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;790    
;;;791        // 添加检验和与结束符，并添加至发送
;;;792        CAN_PROTOCOL1_TxAddFrame();
000022  f7fffffe          BL       CAN_PROTOCOL1_TxAddFrame
;;;793    }
000026  bd10              POP      {r4,pc}
;;;794    
                          ENDP


                          AREA ||i.CAN_PROTOCOL1_RxFIFOProcess||, CODE, READONLY, ALIGN=1

                  CAN_PROTOCOL1_RxFIFOProcess PROC
;;;316    // 一级接收缓冲区处理，从一级接收缓冲区中取出一个字节添加到命令帧缓冲区中
;;;317    void CAN_PROTOCOL1_RxFIFOProcess(CAN_PROTOCOL1_CB *pCB)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;318    {
000004  4604              MOV      r4,r0
;;;319        uint16 end = pCB->rxFIFO.end;
000006  f8b470ca          LDRH     r7,[r4,#0xca]
;;;320        uint16 head = pCB->rxFIFO.head;
00000a  f8b490c8          LDRH     r9,[r4,#0xc8]
;;;321        CAN_PROTOCOL1_RX_CMD_FRAME *pCmdFrame = NULL;
00000e  2500              MOVS     r5,#0
;;;322        uint16 length = 0;
000010  46a8              MOV      r8,r5
;;;323        uint8 currentData = 0;
000012  2600              MOVS     r6,#0
;;;324    
;;;325        // 参数合法性检验
;;;326        if (NULL == pCB)
000014  b90c              CBNZ     r4,|L10.26|
                  |L10.22|
;;;327        {
;;;328            return;
;;;329        }
;;;330    
;;;331        // 一级缓冲区为空，退出
;;;332        if (head == end)
;;;333        {
;;;334            return;
;;;335        }
;;;336    
;;;337        // 获取临时缓冲区指针
;;;338        pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.end];
;;;339        // 取出当前要处理的字节
;;;340        currentData = pCB->rxFIFO.buff[pCB->rxFIFO.currentProcessIndex];
;;;341    
;;;342        // 临时缓冲区长度为0时，搜索首字节
;;;343        if (0 == pCmdFrame->length)
;;;344        {
;;;345            // 命令头错误，删除当前字节并退出
;;;346            if (CAN_PROTOCOL1_CMD_HEAD != currentData)
;;;347            {
;;;348                pCB->rxFIFO.head++;
;;;349                pCB->rxFIFO.head %= CAN_PROTOCOL1_RX_FIFO_SIZE;
;;;350                pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;351    
;;;352                return;
;;;353            }
;;;354    
;;;355            // 命令头正确，但无临时缓冲区可用，退出
;;;356            if ((pCB->rx.end + 1) % CAN_PROTOCOL1_RX_QUEUE_SIZE == pCB->rx.head)
;;;357            {
;;;358                return;
;;;359            }
;;;360    
;;;361            // 添加UART通讯超时时间设置-2016.1.5增加
;;;362    #if CAN_PROTOCOL1_RX_TIME_OUT_CHECK_ENABLE
;;;363            TIMER_AddTask(TIMER_ID_UART_RX_TIME_OUT_CONTROL,
;;;364                          CAN_PROTOCOL1_BUS_UNIDIRECTIONAL_TIME_OUT,
;;;365                          CAN_PROTOCOL1_CALLBACK_RxTimeOut,
;;;366                          0,
;;;367                          1,
;;;368                          ACTION_MODE_ADD_TO_QUEUE);
;;;369    #endif
;;;370    
;;;371            // 命令头正确，有临时缓冲区可用，则将其添加到命令帧临时缓冲区中
;;;372            pCmdFrame->buff[pCmdFrame->length++] = currentData;
;;;373            pCB->rxFIFO.currentProcessIndex++;
;;;374            pCB->rxFIFO.currentProcessIndex %= CAN_PROTOCOL1_RX_FIFO_SIZE;
;;;375        }
;;;376        // 非首字节，将数据添加到命令帧临时缓冲区中，但暂不删除当前数据
;;;377        else
;;;378        {
;;;379            // 临时缓冲区溢出，说明当前正在接收的命令帧是错误的，正确的命令帧不会出现长度溢出的情况
;;;380            if (pCmdFrame->length >= CAN_PROTOCOL1_RX_CMD_FRAME_LENGTH_MAX)
;;;381            {
;;;382    #if CAN_PROTOCOL1_RX_TIME_OUT_CHECK_ENABLE
;;;383                // 停止RX通讯超时检测
;;;384                CAN_PROTOCOL1_StopRxTimeOutCheck();
;;;385    #endif
;;;386    
;;;387                // 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;388                pCmdFrame->length = 0; // 2016.1.5增加
;;;389                // 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;390                pCB->rxFIFO.head++;
;;;391                pCB->rxFIFO.head %= CAN_PROTOCOL1_RX_FIFO_SIZE;
;;;392                pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;393    
;;;394                return;
;;;395            }
;;;396    
;;;397            // 一直取到末尾
;;;398            while (end != pCB->rxFIFO.currentProcessIndex)
;;;399            {
;;;400                // 取出当前要处理的字节
;;;401                currentData = pCB->rxFIFO.buff[pCB->rxFIFO.currentProcessIndex];
;;;402                // 缓冲区未溢出，正常接收，将数据添加到临时缓冲区中
;;;403                pCmdFrame->buff[pCmdFrame->length++] = currentData;
;;;404                pCB->rxFIFO.currentProcessIndex++;
;;;405                pCB->rxFIFO.currentProcessIndex %= CAN_PROTOCOL1_RX_FIFO_SIZE;
;;;406    
;;;407                // ■■接下来，需要检查命令帧是否完整，如果完整，则将命令帧临时缓冲区扶正■■
;;;408    
;;;409                // 首先判断命令帧最小长度，一个完整的命令字至少包括8个字节: 命令头、设备地址、命令字、数据长度、校验和L、校验和H、结束标识0xD、结束标识OxA，因此不足8个字节的必定不完整
;;;410                if (pCmdFrame->length < CAN_PROTOCOL1_CMD_FRAME_LENGTH_MIN)
;;;411                {
;;;412                    // 继续接收
;;;413                    continue;
;;;414                }
;;;415    
;;;416                // 命令帧长度数值越界，说明当前命令帧错误，停止接收
;;;417                if (pCmdFrame->buff[CAN_PROTOCOL1_CMD_LENGTH_INDEX] > CAN_PROTOCOL1_RX_CMD_FRAME_LENGTH_MAX - CAN_PROTOCOL1_CMD_FRAME_LENGTH_MIN)
;;;418                {
;;;419    #if CAN_PROTOCOL1_RX_TIME_OUT_CHECK_ENABLE
;;;420                    // 停止RX通讯超时检测
;;;421                    CAN_PROTOCOL1_StopRxTimeOutCheck();
;;;422    #endif
;;;423    
;;;424                    // 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;425                    pCmdFrame->length = 0;
;;;426                    // 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;427                    pCB->rxFIFO.head++;
;;;428                    pCB->rxFIFO.head %= CAN_PROTOCOL1_RX_FIFO_SIZE;
;;;429                    pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;430    
;;;431                    return;
;;;432                }
;;;433    
;;;434                // 命令帧长度校验，在命令长度描述字的数值上，增加命令头、设备地址、命令字、数据长度、校验和L、校验和H、结束标识0xD、结束标识OxA，即为命令帧实际长度
;;;435                length = pCmdFrame->length;
;;;436                if (length < pCmdFrame->buff[CAN_PROTOCOL1_CMD_LENGTH_INDEX] + CAN_PROTOCOL1_CMD_FRAME_LENGTH_MIN)
;;;437                {
;;;438                    // 长度要求不一致，说明未接收完毕，退出继续
;;;439                    continue;
;;;440                }
;;;441    
;;;442                // 命令帧长度OK，则进行校验，失败时删除命令头
;;;443                if (!CAN_PROTOCOL1_CheckSUM(pCmdFrame))
;;;444                {
;;;445    #if CAN_PROTOCOL1_RX_TIME_OUT_CHECK_ENABLE
;;;446                    // 停止RX通讯超时检测
;;;447                    CAN_PROTOCOL1_StopRxTimeOutCheck();
;;;448    #endif
;;;449    
;;;450                    // 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;451                    pCmdFrame->length = 0;
;;;452                    // 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;453                    pCB->rxFIFO.head++;
;;;454                    pCB->rxFIFO.head %= CAN_PROTOCOL1_RX_FIFO_SIZE;
;;;455                    pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;456    
;;;457                    return;
;;;458                }
;;;459    
;;;460    #if CAN_PROTOCOL1_RX_TIME_OUT_CHECK_ENABLE
;;;461                // 停止RX通讯超时检测
;;;462                CAN_PROTOCOL1_StopRxTimeOutCheck();
;;;463    #endif
;;;464    
;;;465                // 执行到这里，即说明接收到了一个完整并且正确的命令帧，此时需将处理过的数据从一级缓冲区中删除，并将该命令帧扶正
;;;466                pCB->rxFIFO.head += length;
;;;467                pCB->rxFIFO.head %= CAN_PROTOCOL1_RX_FIFO_SIZE;
;;;468                pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;469                CAN_PROTOCOL1_ConfirmTempCmdFrameBuff(pCB);
;;;470    
;;;471                return;
;;;472            }
;;;473        }
;;;474    }
000016  e8bd83f0          POP      {r4-r9,pc}
                  |L10.26|
00001a  45b9              CMP      r9,r7                 ;332
00001c  d100              BNE      |L10.32|
00001e  e7fa              B        |L10.22|
                  |L10.32|
000020  f8b4029e          LDRH     r0,[r4,#0x29e]        ;338
000024  214d              MOVS     r1,#0x4d              ;338
000026  4348              MULS     r0,r1,r0              ;338
000028  f10401ce          ADD      r1,r4,#0xce           ;338
00002c  eb010540          ADD      r5,r1,r0,LSL #1       ;338
000030  f8b400cc          LDRH     r0,[r4,#0xcc]         ;340
000034  5c26              LDRB     r6,[r4,r0]            ;340
000036  f8b50098          LDRH     r0,[r5,#0x98]         ;343
00003a  bb90              CBNZ     r0,|L10.162|
00003c  2e3a              CMP      r6,#0x3a              ;346
00003e  d00e              BEQ      |L10.94|
000040  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;348
000044  1c40              ADDS     r0,r0,#1              ;348
000046  8020              STRH     r0,[r4,#0]            ;348
000048  8820              LDRH     r0,[r4,#0]            ;349
00004a  21c8              MOVS     r1,#0xc8              ;349
00004c  fb90f2f1          SDIV     r2,r0,r1              ;349
000050  fb010012          MLS      r0,r1,r2,r0           ;349
000054  8020              STRH     r0,[r4,#0]            ;349
000056  8820              LDRH     r0,[r4,#0]            ;350
000058  80a0              STRH     r0,[r4,#4]            ;350
00005a  3cc8              SUBS     r4,r4,#0xc8           ;350
00005c  e7db              B        |L10.22|
                  |L10.94|
00005e  f8b4029e          LDRH     r0,[r4,#0x29e]        ;356
000062  1c40              ADDS     r0,r0,#1              ;356
000064  2103              MOVS     r1,#3                 ;356
000066  fb90f2f1          SDIV     r2,r0,r1              ;356
00006a  fb010112          MLS      r1,r1,r2,r0           ;356
00006e  f8b4029c          LDRH     r0,[r4,#0x29c]        ;356
000072  4281              CMP      r1,r0                 ;356
000074  d100              BNE      |L10.120|
000076  e7ce              B        |L10.22|
                  |L10.120|
000078  f8351f98          LDRH     r1,[r5,#0x98]!        ;372
00007c  8828              LDRH     r0,[r5,#0]            ;372
00007e  1c40              ADDS     r0,r0,#1              ;372
000080  f8250998          STRH     r0,[r5],#-0x98        ;372
000084  1ca8              ADDS     r0,r5,#2              ;372
000086  5446              STRB     r6,[r0,r1]            ;372
000088  f8340fcc          LDRH     r0,[r4,#0xcc]!        ;373
00008c  1c40              ADDS     r0,r0,#1              ;373
00008e  8020              STRH     r0,[r4,#0]            ;373
000090  8820              LDRH     r0,[r4,#0]            ;374
000092  21c8              MOVS     r1,#0xc8              ;374
000094  fb90f2f1          SDIV     r2,r0,r1              ;374
000098  fb010012          MLS      r0,r1,r2,r0           ;374
00009c  f82409cc          STRH     r0,[r4],#-0xcc        ;374
0000a0  e07b              B        |L10.410|
                  |L10.162|
0000a2  e7ff              B        |L10.164|
                  |L10.164|
0000a4  f8b50098          LDRH     r0,[r5,#0x98]         ;380
0000a8  2896              CMP      r0,#0x96              ;380
0000aa  db11              BLT      |L10.208|
0000ac  2000              MOVS     r0,#0                 ;388
0000ae  f8a50098          STRH     r0,[r5,#0x98]         ;388
0000b2  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;390
0000b6  1c40              ADDS     r0,r0,#1              ;390
0000b8  8020              STRH     r0,[r4,#0]            ;390
0000ba  8820              LDRH     r0,[r4,#0]            ;391
0000bc  21c8              MOVS     r1,#0xc8              ;391
0000be  fb90f2f1          SDIV     r2,r0,r1              ;391
0000c2  fb010012          MLS      r0,r1,r2,r0           ;391
0000c6  8020              STRH     r0,[r4,#0]            ;391
0000c8  8820              LDRH     r0,[r4,#0]            ;392
0000ca  80a0              STRH     r0,[r4,#4]            ;392
0000cc  3cc8              SUBS     r4,r4,#0xc8           ;392
0000ce  e7a2              B        |L10.22|
                  |L10.208|
0000d0  e05f              B        |L10.402|
                  |L10.210|
0000d2  f8b400cc          LDRH     r0,[r4,#0xcc]         ;401
0000d6  5c26              LDRB     r6,[r4,r0]            ;401
0000d8  f8351f98          LDRH     r1,[r5,#0x98]!        ;403
0000dc  8828              LDRH     r0,[r5,#0]            ;403
0000de  1c40              ADDS     r0,r0,#1              ;403
0000e0  f8250998          STRH     r0,[r5],#-0x98        ;403
0000e4  1ca8              ADDS     r0,r5,#2              ;403
0000e6  5446              STRB     r6,[r0,r1]            ;403
0000e8  f8340fcc          LDRH     r0,[r4,#0xcc]!        ;404
0000ec  1c40              ADDS     r0,r0,#1              ;404
0000ee  8020              STRH     r0,[r4,#0]            ;404
0000f0  8820              LDRH     r0,[r4,#0]            ;405
0000f2  21c8              MOVS     r1,#0xc8              ;405
0000f4  fb90f2f1          SDIV     r2,r0,r1              ;405
0000f8  fb010012          MLS      r0,r1,r2,r0           ;405
0000fc  f82409cc          STRH     r0,[r4],#-0xcc        ;405
000100  f8b50098          LDRH     r0,[r5,#0x98]         ;410
000104  2808              CMP      r0,#8                 ;410
000106  da00              BGE      |L10.266|
000108  e043              B        |L10.402|
                  |L10.266|
00010a  7968              LDRB     r0,[r5,#5]            ;417
00010c  288e              CMP      r0,#0x8e              ;417
00010e  dd11              BLE      |L10.308|
000110  2000              MOVS     r0,#0                 ;425
000112  f8a50098          STRH     r0,[r5,#0x98]         ;425
000116  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;427
00011a  1c40              ADDS     r0,r0,#1              ;427
00011c  8020              STRH     r0,[r4,#0]            ;427
00011e  8820              LDRH     r0,[r4,#0]            ;428
000120  21c8              MOVS     r1,#0xc8              ;428
000122  fb90f2f1          SDIV     r2,r0,r1              ;428
000126  fb010012          MLS      r0,r1,r2,r0           ;428
00012a  8020              STRH     r0,[r4,#0]            ;428
00012c  8820              LDRH     r0,[r4,#0]            ;429
00012e  80a0              STRH     r0,[r4,#4]            ;429
000130  3cc8              SUBS     r4,r4,#0xc8           ;429
000132  e770              B        |L10.22|
                  |L10.308|
000134  f8b58098          LDRH     r8,[r5,#0x98]         ;435
000138  7968              LDRB     r0,[r5,#5]            ;436
00013a  3008              ADDS     r0,r0,#8              ;436
00013c  4540              CMP      r0,r8                 ;436
00013e  dd00              BLE      |L10.322|
000140  e027              B        |L10.402|
                  |L10.322|
000142  4628              MOV      r0,r5                 ;443
000144  f7fffffe          BL       CAN_PROTOCOL1_CheckSUM
000148  b988              CBNZ     r0,|L10.366|
00014a  2000              MOVS     r0,#0                 ;451
00014c  f8a50098          STRH     r0,[r5,#0x98]         ;451
000150  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;453
000154  1c40              ADDS     r0,r0,#1              ;453
000156  8020              STRH     r0,[r4,#0]            ;453
000158  8820              LDRH     r0,[r4,#0]            ;454
00015a  21c8              MOVS     r1,#0xc8              ;454
00015c  fb90f2f1          SDIV     r2,r0,r1              ;454
000160  fb010012          MLS      r0,r1,r2,r0           ;454
000164  8020              STRH     r0,[r4,#0]            ;454
000166  8820              LDRH     r0,[r4,#0]            ;455
000168  80a0              STRH     r0,[r4,#4]            ;455
00016a  3cc8              SUBS     r4,r4,#0xc8           ;455
00016c  e753              B        |L10.22|
                  |L10.366|
00016e  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;466
000172  4440              ADD      r0,r0,r8              ;466
000174  8020              STRH     r0,[r4,#0]            ;466
000176  8820              LDRH     r0,[r4,#0]            ;467
000178  21c8              MOVS     r1,#0xc8              ;467
00017a  fb90f2f1          SDIV     r2,r0,r1              ;467
00017e  fb010012          MLS      r0,r1,r2,r0           ;467
000182  8020              STRH     r0,[r4,#0]            ;467
000184  8820              LDRH     r0,[r4,#0]            ;468
000186  80a0              STRH     r0,[r4,#4]            ;468
000188  3cc8              SUBS     r4,r4,#0xc8           ;468
00018a  4620              MOV      r0,r4                 ;469
00018c  f7fffffe          BL       CAN_PROTOCOL1_ConfirmTempCmdFrameBuff
000190  e741              B        |L10.22|
                  |L10.402|
000192  f8b400cc          LDRH     r0,[r4,#0xcc]         ;398
000196  42b8              CMP      r0,r7                 ;398
000198  d19b              BNE      |L10.210|
                  |L10.410|
00019a  bf00              NOP      
00019c  e73b              B        |L10.22|
;;;475    
                          ENDP


                          AREA ||i.CAN_PROTOCOL1_SendCmdNoResult||, CODE, READONLY, ALIGN=2

                  CAN_PROTOCOL1_SendCmdNoResult PROC
;;;854    // 发送命令无结果
;;;855    void CAN_PROTOCOL1_SendCmdNoResult(uint8 cmdWord)
000000  b510              PUSH     {r4,lr}
;;;856    {
000002  4604              MOV      r4,r0
;;;857        // 添加命令头
;;;858        CAN_PROTOCOL1_TxAddData(CAN_PROTOCOL1_CMD_HEAD);
000004  203a              MOVS     r0,#0x3a
000006  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;859    
;;;860        if(DUT_TYPE_IOT == dut_info.ID)
00000a  480a              LDR      r0,|L11.52|
00000c  7d80              LDRB     r0,[r0,#0x16]  ; dut_info
00000e  2809              CMP      r0,#9
000010  d103              BNE      |L11.26|
;;;861        {
;;;862            // 添加设备地址
;;;863            CAN_PROTOCOL1_TxAddData(CAN_PROTOCOL1_IOT_DEVICE_ADDR);    
000012  202a              MOVS     r0,#0x2a
000014  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
000018  e002              B        |L11.32|
                  |L11.26|
;;;864        }
;;;865        else
;;;866        {
;;;867            // 添加设备地址
;;;868            CAN_PROTOCOL1_TxAddData(CAN_PROTOCOL1_CMD_DEVICE_ADDR);    
00001a  201a              MOVS     r0,#0x1a
00001c  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
                  |L11.32|
;;;869        }
;;;870        
;;;871        // 添加命令字
;;;872        CAN_PROTOCOL1_TxAddData(cmdWord);
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;873    
;;;874        CAN_PROTOCOL1_TxAddData(0); // 数据长度
000026  2000              MOVS     r0,#0
000028  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;875    
;;;876        CAN_PROTOCOL1_TxAddFrame();
00002c  f7fffffe          BL       CAN_PROTOCOL1_TxAddFrame
;;;877    }
000030  bd10              POP      {r4,pc}
;;;878    
                          ENDP

000032  0000              DCW      0x0000
                  |L11.52|
                          DCD      dut_info

                          AREA ||i.CAN_PROTOCOL1_SendCmdUpApp||, CODE, READONLY, ALIGN=2

                  CAN_PROTOCOL1_SendCmdUpApp PROC
;;;885    // 发送升级固件命令
;;;886    void CAN_PROTOCOL1_SendCmdUpApp(void)
000000  b500              PUSH     {lr}
;;;887    {
;;;888    	// 添加命令头
;;;889    	CAN_PROTOCOL1_TxAddData(CAN_PROTOCOL1_CMD_HEAD);
000002  203a              MOVS     r0,#0x3a
000004  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;890        
;;;891        // 添加设备地址
;;;892        CAN_PROTOCOL1_TxAddData(CAN_PROTOCOL1_IOT_DEVICE_ADDR);    
000008  202a              MOVS     r0,#0x2a
00000a  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;893    
;;;894    	// 添加命令字
;;;895    	CAN_PROTOCOL1_TxAddData(CAN_PROTOCOL1_CMD_UPDATE_START); // F2
00000e  20f2              MOVS     r0,#0xf2
000010  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;896    	CAN_PROTOCOL1_TxAddData(0); // 数据长度 
000014  2000              MOVS     r0,#0
000016  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;897    	CAN_PROTOCOL1_TxAddData(9); // 设备类型 IOT-9
00001a  2009              MOVS     r0,#9
00001c  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;898    	CAN_PROTOCOL1_TxAddData(dut_info.iotCrc8); // CRC8校验码
000020  4910              LDR      r1,|L12.100|
000022  f89100e4          LDRB     r0,[r1,#0xe4]  ; dut_info
000026  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;899    	CAN_PROTOCOL1_TxAddData(((dut_info.iotAppUpDataLen) & 0xFF000000) >> 24); // 文件长度
00002a  490e              LDR      r1,|L12.100|
00002c  f8d110e8          LDR      r1,[r1,#0xe8]  ; dut_info
000030  0e08              LSRS     r0,r1,#24
000032  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;900    	CAN_PROTOCOL1_TxAddData(((dut_info.iotAppUpDataLen) & 0x00FF0000) >> 16); // 文件长度
000036  490b              LDR      r1,|L12.100|
000038  f8d110e8          LDR      r1,[r1,#0xe8]  ; dut_info
00003c  f3c14007          UBFX     r0,r1,#16,#8
000040  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;901    	CAN_PROTOCOL1_TxAddData(((dut_info.iotAppUpDataLen) & 0x0000FF00) >> 8); // 文件长度
000044  4907              LDR      r1,|L12.100|
000046  f8b110e8          LDRH     r1,[r1,#0xe8]  ; dut_info
00004a  f3c12007          UBFX     r0,r1,#8,#8
00004e  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;902    	CAN_PROTOCOL1_TxAddData((dut_info.iotAppUpDataLen) & 0x000000FF); // 文件长度    
000052  4904              LDR      r1,|L12.100|
000054  f89100e8          LDRB     r0,[r1,#0xe8]  ; dut_info
000058  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;903    	CAN_PROTOCOL1_TxAddFrame();
00005c  f7fffffe          BL       CAN_PROTOCOL1_TxAddFrame
;;;904    }
000060  bd00              POP      {pc}
;;;905    
                          ENDP

000062  0000              DCW      0x0000
                  |L12.100|
                          DCD      dut_info

                          AREA ||i.CAN_PROTOCOL1_SendCmdWithResult||, CODE, READONLY, ALIGN=2

                  CAN_PROTOCOL1_SendCmdWithResult PROC
;;;826    // 发送命令带结果
;;;827    void CAN_PROTOCOL1_SendCmdWithResult(uint8 cmdWord, uint8 result)
000000  b530              PUSH     {r4,r5,lr}
;;;828    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;829        // 添加命令头
;;;830        CAN_PROTOCOL1_TxAddData(CAN_PROTOCOL1_CMD_HEAD);
000006  203a              MOVS     r0,#0x3a
000008  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;831    
;;;832        if(DUT_TYPE_IOT == dut_info.ID)
00000c  480b              LDR      r0,|L13.60|
00000e  7d80              LDRB     r0,[r0,#0x16]  ; dut_info
000010  2809              CMP      r0,#9
000012  d103              BNE      |L13.28|
;;;833        {
;;;834            // 添加设备地址
;;;835            CAN_PROTOCOL1_TxAddData(CAN_PROTOCOL1_IOT_DEVICE_ADDR);    
000014  202a              MOVS     r0,#0x2a
000016  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
00001a  e002              B        |L13.34|
                  |L13.28|
;;;836        }
;;;837        else
;;;838        {
;;;839            // 添加设备地址
;;;840            CAN_PROTOCOL1_TxAddData(CAN_PROTOCOL1_CMD_DEVICE_ADDR);    
00001c  201a              MOVS     r0,#0x1a
00001e  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
                  |L13.34|
;;;841        }
;;;842    
;;;843        // 添加命令字
;;;844        CAN_PROTOCOL1_TxAddData(cmdWord);
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;845    
;;;846        // 添加数据长度
;;;847        CAN_PROTOCOL1_TxAddData(1);
000028  2001              MOVS     r0,#1
00002a  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;848    
;;;849        CAN_PROTOCOL1_TxAddData(result);
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;850    
;;;851        CAN_PROTOCOL1_TxAddFrame();
000034  f7fffffe          BL       CAN_PROTOCOL1_TxAddFrame
;;;852    }
000038  bd30              POP      {r4,r5,pc}
;;;853    
                          ENDP

00003a  0000              DCW      0x0000
                  |L13.60|
                          DCD      dut_info

                          AREA ||i.CAN_PROTOCOL1_SendLdoV||, CODE, READONLY, ALIGN=2

                  CAN_PROTOCOL1_SendLdoV PROC
;;;795    // 发送命令带结果
;;;796    void CAN_PROTOCOL1_SendLdoV(uint8 cmdWord, uint32 result)
000000  b530              PUSH     {r4,r5,lr}
;;;797    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;798        // 添加命令头
;;;799        CAN_PROTOCOL1_TxAddData(CAN_PROTOCOL1_CMD_HEAD);
000006  203a              MOVS     r0,#0x3a
000008  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;800    
;;;801        if(DUT_TYPE_IOT == dut_info.ID)
00000c  4810              LDR      r0,|L14.80|
00000e  7d80              LDRB     r0,[r0,#0x16]  ; dut_info
000010  2809              CMP      r0,#9
000012  d103              BNE      |L14.28|
;;;802        {
;;;803            // 添加设备地址
;;;804            CAN_PROTOCOL1_TxAddData(CAN_PROTOCOL1_IOT_DEVICE_ADDR);    
000014  202a              MOVS     r0,#0x2a
000016  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
00001a  e002              B        |L14.34|
                  |L14.28|
;;;805        }
;;;806        else
;;;807        {
;;;808            // 添加设备地址
;;;809            CAN_PROTOCOL1_TxAddData(CAN_PROTOCOL1_CMD_DEVICE_ADDR);    
00001c  201a              MOVS     r0,#0x1a
00001e  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
                  |L14.34|
;;;810        }
;;;811    
;;;812        // 添加命令字
;;;813        CAN_PROTOCOL1_TxAddData(cmdWord);
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;814    
;;;815        // 添加数据长度
;;;816        CAN_PROTOCOL1_TxAddData(4);
000028  2004              MOVS     r0,#4
00002a  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;817    
;;;818        CAN_PROTOCOL1_TxAddData((result >> 24) & 0xFF);
00002e  0e20              LSRS     r0,r4,#24
000030  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;819        CAN_PROTOCOL1_TxAddData((result >> 16) & 0xFF);
000034  f3c44007          UBFX     r0,r4,#16,#8
000038  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;820        CAN_PROTOCOL1_TxAddData((result >> 8) & 0xFF);
00003c  f3c42007          UBFX     r0,r4,#8,#8
000040  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;821        CAN_PROTOCOL1_TxAddData((result >> 0) & 0xFF);
000044  b2e0              UXTB     r0,r4
000046  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;822    
;;;823        CAN_PROTOCOL1_TxAddFrame();
00004a  f7fffffe          BL       CAN_PROTOCOL1_TxAddFrame
;;;824    }
00004e  bd30              POP      {r4,r5,pc}
;;;825    
                          ENDP

                  |L14.80|
                          DCD      dut_info

                          AREA ||i.CAN_PROTOCOL1_SendOnePacket_Bin||, CODE, READONLY, ALIGN=1

                  CAN_PROTOCOL1_SendOnePacket_Bin PROC
;;;906    // 写入IOT APP数据
;;;907    void CAN_PROTOCOL1_SendOnePacket_Bin(uint32 flashAddr, uint32 addr)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;908    {
000004  b0a6              SUB      sp,sp,#0x98
000006  4606              MOV      r6,r0
000008  460c              MOV      r4,r1
;;;909    	uint8 addr1, addr2, addr3, addr4;
;;;910    	uint8 appUpdateOnePacket[150] = {0};
00000a  2198              MOVS     r1,#0x98
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       __aeabi_memclr4
;;;911    	uint8 appUpdateOnePacket_i = 0;
000012  2500              MOVS     r5,#0
;;;912    	addr1 = (addr & 0xFF000000) >> 24;
000014  0e27              LSRS     r7,r4,#24
;;;913    	addr2 = (addr & 0x00FF0000) >> 16;
000016  f3c44807          UBFX     r8,r4,#16,#8
;;;914    	addr3 = (addr & 0x0000FF00) >> 8;
00001a  f3c42907          UBFX     r9,r4,#8,#8
;;;915    	addr4 = (addr & 0x000000FF);
00001e  f0040aff          AND      r10,r4,#0xff
;;;916    	SPI_FLASH_ReadArray(appUpdateOnePacket, flashAddr + addr, 128); // 工具读取128字节
000022  1931              ADDS     r1,r6,r4
000024  2280              MOVS     r2,#0x80
000026  4668              MOV      r0,sp
000028  f7fffffe          BL       SPI_FLASH_ReadArray
;;;917    
;;;918    	CAN_PROTOCOL1_TxAddData(CAN_PROTOCOL1_CMD_HEAD);                                     // 头
00002c  203a              MOVS     r0,#0x3a
00002e  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;919    	CAN_PROTOCOL1_TxAddData(CAN_PROTOCOL1_IOT_DEVICE_ADDR);                              // 设备号
000032  202a              MOVS     r0,#0x2a
000034  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;920        CAN_PROTOCOL1_TxAddData(CAN_PROTOCOL1_CMD_WRITE_DATA);                               // 命令字
000038  20f3              MOVS     r0,#0xf3
00003a  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;921    	CAN_PROTOCOL1_TxAddData(0x00);													       // 长度暂时为0
00003e  2000              MOVS     r0,#0
000040  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;922    	CAN_PROTOCOL1_TxAddData(addr1);													   // 添加地址
000044  4638              MOV      r0,r7
000046  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;923    	CAN_PROTOCOL1_TxAddData(addr2);													   // 添加地址
00004a  4640              MOV      r0,r8
00004c  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;924    	CAN_PROTOCOL1_TxAddData(addr3);													   // 添加地址
000050  4648              MOV      r0,r9
000052  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;925    	CAN_PROTOCOL1_TxAddData(addr4);													   // 添加地址
000056  4650              MOV      r0,r10
000058  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;926    	CAN_PROTOCOL1_TxAddData(128);													       // 数据包长度
00005c  2080              MOVS     r0,#0x80
00005e  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;927        
;;;928    	for (appUpdateOnePacket_i = 0; appUpdateOnePacket_i < 128; appUpdateOnePacket_i++) // 添加数据
000062  bf00              NOP      
000064  e005              B        |L15.114|
                  |L15.102|
;;;929    	{
;;;930    		CAN_PROTOCOL1_TxAddData(appUpdateOnePacket[appUpdateOnePacket_i]);
000066  f81d0005          LDRB     r0,[sp,r5]
00006a  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
00006e  1c68              ADDS     r0,r5,#1              ;928
000070  b2c5              UXTB     r5,r0                 ;928
                  |L15.114|
000072  2d80              CMP      r5,#0x80              ;928
000074  dbf7              BLT      |L15.102|
;;;931    	}
;;;932    	CAN_PROTOCOL1_TxAddFrame(); // 调整帧格式,修改长度和添加校验
000076  f7fffffe          BL       CAN_PROTOCOL1_TxAddFrame
;;;933    }
00007a  b026              ADD      sp,sp,#0x98
00007c  e8bd87f0          POP      {r4-r10,pc}
;;;934    
                          ENDP


                          AREA ||i.CAN_PROTOCOL1_SendUpAppReuqest||, CODE, READONLY, ALIGN=1

                  CAN_PROTOCOL1_SendUpAppReuqest PROC
;;;879    // 发送升级固件请求
;;;880    void CAN_PROTOCOL1_SendUpAppReuqest(uint32 param)
000000  b510              PUSH     {r4,lr}
;;;881    {
000002  4604              MOV      r4,r0
;;;882        CAN_PROTOCOL1_SendCmdWithResult(CAN_PROTOCOL1_CMD_UPDATE_REQUEST, 9); 
000004  2109              MOVS     r1,#9
000006  20f1              MOVS     r0,#0xf1
000008  f7fffffe          BL       CAN_PROTOCOL1_SendCmdWithResult
;;;883    }
00000c  bd10              POP      {r4,pc}
;;;884    
                          ENDP


                          AREA ||i.CAN_PROTOCOL1_StartTimeoutCheckTask||, CODE, READONLY, ALIGN=1

                  CAN_PROTOCOL1_StartTimeoutCheckTask PROC
;;;72     // 启动通讯超时判断任务
;;;73     void CAN_PROTOCOL1_StartTimeoutCheckTask(void)
000000  4770              BX       lr
;;;74     {
;;;75     }
;;;76     
                          ENDP


                          AREA ||i.CAN_PROTOCOL1_TxAddData||, CODE, READONLY, ALIGN=2

                  CAN_PROTOCOL1_TxAddData PROC
;;;115    // 向发送命令帧队列中添加数据
;;;116    void CAN_PROTOCOL1_TxAddData(uint8 data)
000000  b570              PUSH     {r4-r6,lr}
;;;117    {
000002  4601              MOV      r1,r0
;;;118        uint16 head = canProtocol1CB.tx.head;
000004  4c12              LDR      r4,|L18.80|
000006  f8b4246e          LDRH     r2,[r4,#0x46e]
;;;119        uint16 end = canProtocol1CB.tx.end;
00000a  f8b43470          LDRH     r3,[r4,#0x470]
;;;120        CAN_PROTOCOL1_TX_CMD_FRAME *pCmdFrame = &canProtocol1CB.tx.cmdQueue[canProtocol1CB.tx.end];
00000e  f8b44470          LDRH     r4,[r4,#0x470]
000012  254d              MOVS     r5,#0x4d
000014  436c              MULS     r4,r5,r4
000016  4d0f              LDR      r5,|L18.84|
000018  eb050044          ADD      r0,r5,r4,LSL #1
;;;121    
;;;122        // 发送缓冲区已满，不予接收
;;;123        if ((end + 1) % CAN_PROTOCOL1_TX_QUEUE_SIZE == head)
00001c  1c5c              ADDS     r4,r3,#1
00001e  2503              MOVS     r5,#3
000020  fb94f6f5          SDIV     r6,r4,r5
000024  fb054416          MLS      r4,r5,r6,r4
000028  4294              CMP      r4,r2
00002a  d100              BNE      |L18.46|
                  |L18.44|
;;;124        {
;;;125            return;
;;;126        }
;;;127    
;;;128        // 队尾命令帧已满，退出
;;;129        if (pCmdFrame->length >= CAN_PROTOCOL1_TX_CMD_FRAME_LENGTH_MAX)
;;;130        {
;;;131            return;
;;;132        }
;;;133    
;;;134        // 数据添加到帧末尾，并更新帧长度
;;;135        pCmdFrame->buff[pCmdFrame->length] = data;
;;;136        pCmdFrame->length++;
;;;137    }
00002c  bd70              POP      {r4-r6,pc}
                  |L18.46|
00002e  f8b04098          LDRH     r4,[r0,#0x98]         ;129
000032  2c96              CMP      r4,#0x96              ;129
000034  db00              BLT      |L18.56|
000036  e7f9              B        |L18.44|
                  |L18.56|
000038  f8b05098          LDRH     r5,[r0,#0x98]         ;135
00003c  1c84              ADDS     r4,r0,#2              ;135
00003e  5561              STRB     r1,[r4,r5]            ;135
000040  f8b04098          LDRH     r4,[r0,#0x98]         ;136
000044  1c64              ADDS     r4,r4,#1              ;136
000046  f8a04098          STRH     r4,[r0,#0x98]         ;136
00004a  bf00              NOP      
00004c  e7ee              B        |L18.44|
;;;138    
                          ENDP

00004e  0000              DCW      0x0000
                  |L18.80|
                          DCD      canProtocol1CB
                  |L18.84|
                          DCD      canProtocol1CB+0x2a0

                          AREA ||i.CAN_PROTOCOL1_TxAddFrame||, CODE, READONLY, ALIGN=2

                  CAN_PROTOCOL1_TxAddFrame PROC
;;;139    // 确认添加命令帧，即承认之前填充的数据为命令帧，将其添加到发送队列中，由main进行调度发送，本函数内会自动校正命令长度，并添加校验码
;;;140    void CAN_PROTOCOL1_TxAddFrame(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;141    {
;;;142        uint16 checkSum = 0;
000002  2200              MOVS     r2,#0
;;;143        uint16 i = 0;
000004  2300              MOVS     r3,#0
;;;144        uint16 head = canProtocol1CB.tx.head;
000006  4e38              LDR      r6,|L19.232|
000008  f8b6446e          LDRH     r4,[r6,#0x46e]
;;;145        uint16 end = canProtocol1CB.tx.end;
00000c  f8b65470          LDRH     r5,[r6,#0x470]
;;;146        CAN_PROTOCOL1_TX_CMD_FRAME *pCmdFrame = &canProtocol1CB.tx.cmdQueue[canProtocol1CB.tx.end];
000010  f8b66470          LDRH     r6,[r6,#0x470]
000014  274d              MOVS     r7,#0x4d
000016  437e              MULS     r6,r7,r6
000018  4f34              LDR      r7,|L19.236|
00001a  eb070046          ADD      r0,r7,r6,LSL #1
;;;147        uint16 length = pCmdFrame->length;
00001e  f8b01098          LDRH     r1,[r0,#0x98]
;;;148    
;;;149        // 发送缓冲区已满，不予接收
;;;150        if ((end + 1) % CAN_PROTOCOL1_TX_QUEUE_SIZE == head)
000022  1c6e              ADDS     r6,r5,#1
000024  2703              MOVS     r7,#3
000026  fb96fcf7          SDIV     r12,r6,r7
00002a  fb07661c          MLS      r6,r7,r12,r6
00002e  42a6              CMP      r6,r4
000030  d100              BNE      |L19.52|
                  |L19.50|
;;;151        {
;;;152            return;
;;;153        }
;;;154    
;;;155        // 命令帧长度不足，清除已填充的数据，退出
;;;156        if (CAN_PROTOCOL1_CMD_FRAME_LENGTH_MIN - 4 > length) // 减去"校验和L、校验和H、结束标识0xD、结束标识OxA"4个字节
;;;157        {
;;;158            pCmdFrame->length = 0;
;;;159    
;;;160            return;
;;;161        }
;;;162    
;;;163        // 队尾命令帧已满，退出
;;;164        if ((length >= CAN_PROTOCOL1_TX_CMD_FRAME_LENGTH_MAX) || (length + 1 >= CAN_PROTOCOL1_TX_CMD_FRAME_LENGTH_MAX) || (length + 2 >= CAN_PROTOCOL1_TX_CMD_FRAME_LENGTH_MAX) || (length + 3 >= CAN_PROTOCOL1_TX_CMD_FRAME_LENGTH_MAX))
;;;165        {
;;;166            return;
;;;167        }
;;;168    
;;;169        // 重新设置数据长度，系统在准备数据时，填充的"数据长度"可以为任意值，并且不需要添加校验码，在这里重新设置为正确的值
;;;170        pCmdFrame->buff[CAN_PROTOCOL1_CMD_LENGTH_INDEX] = length - 4; // 重设数据长度，减去"命令头、设备地址、命令字、数据长度"4个字节
;;;171        for (i = 1; i < length; i++)
;;;172        {
;;;173            checkSum += pCmdFrame->buff[i];
;;;174        }
;;;175        pCmdFrame->buff[pCmdFrame->length++] = (checkSum & 0x00FF);        // 低字节在前
;;;176        pCmdFrame->buff[pCmdFrame->length++] = ((checkSum >> 8) & 0x00FF); // 高字节在后
;;;177    
;;;178        // 结束标识
;;;179        pCmdFrame->buff[pCmdFrame->length++] = 0x0D;
;;;180        pCmdFrame->buff[pCmdFrame->length++] = 0x0A;
;;;181    
;;;182        canProtocol1CB.tx.end++;
;;;183        canProtocol1CB.tx.end %= CAN_PROTOCOL1_TX_QUEUE_SIZE;
;;;184        // pCB->tx.cmdQueue[pCB->tx.end].length = 0;   //2015.12.2修改
;;;185    }
000032  bdf0              POP      {r4-r7,pc}
                  |L19.52|
000034  2904              CMP      r1,#4                 ;156
000036  da03              BGE      |L19.64|
000038  2600              MOVS     r6,#0                 ;158
00003a  f8a06098          STRH     r6,[r0,#0x98]         ;158
00003e  e7f8              B        |L19.50|
                  |L19.64|
000040  2996              CMP      r1,#0x96              ;164
000042  da08              BGE      |L19.86|
000044  1c4e              ADDS     r6,r1,#1              ;164
000046  2e96              CMP      r6,#0x96              ;164
000048  da05              BGE      |L19.86|
00004a  1c8e              ADDS     r6,r1,#2              ;164
00004c  2e96              CMP      r6,#0x96              ;164
00004e  da02              BGE      |L19.86|
000050  1cce              ADDS     r6,r1,#3              ;164
000052  2e96              CMP      r6,#0x96              ;164
000054  db00              BLT      |L19.88|
                  |L19.86|
000056  e7ec              B        |L19.50|
                  |L19.88|
000058  1f0e              SUBS     r6,r1,#4              ;170
00005a  7146              STRB     r6,[r0,#5]            ;170
00005c  2301              MOVS     r3,#1                 ;171
00005e  e005              B        |L19.108|
                  |L19.96|
000060  1c86              ADDS     r6,r0,#2              ;173
000062  5cf6              LDRB     r6,[r6,r3]            ;173
000064  4416              ADD      r6,r6,r2              ;173
000066  b2b2              UXTH     r2,r6                 ;173
000068  1c5e              ADDS     r6,r3,#1              ;171
00006a  b2b3              UXTH     r3,r6                 ;171
                  |L19.108|
00006c  428b              CMP      r3,r1                 ;171
00006e  dbf7              BLT      |L19.96|
000070  f8b0c098          LDRH     r12,[r0,#0x98]        ;175
000074  f10c0601          ADD      r6,r12,#1             ;175
000078  f8a06098          STRH     r6,[r0,#0x98]         ;175
00007c  1c86              ADDS     r6,r0,#2              ;175
00007e  f806200c          STRB     r2,[r6,r12]           ;175
000082  0a17              LSRS     r7,r2,#8              ;176
000084  f8b0c098          LDRH     r12,[r0,#0x98]        ;176
000088  f10c0601          ADD      r6,r12,#1             ;176
00008c  f8a06098          STRH     r6,[r0,#0x98]         ;176
000090  1c86              ADDS     r6,r0,#2              ;176
000092  f806700c          STRB     r7,[r6,r12]           ;176
000096  270d              MOVS     r7,#0xd               ;179
000098  f8b0c098          LDRH     r12,[r0,#0x98]        ;179
00009c  f10c0601          ADD      r6,r12,#1             ;179
0000a0  f8a06098          STRH     r6,[r0,#0x98]         ;179
0000a4  1c86              ADDS     r6,r0,#2              ;179
0000a6  f806700c          STRB     r7,[r6,r12]           ;179
0000aa  270a              MOVS     r7,#0xa               ;180
0000ac  f8b0c098          LDRH     r12,[r0,#0x98]        ;180
0000b0  f10c0601          ADD      r6,r12,#1             ;180
0000b4  f8a06098          STRH     r6,[r0,#0x98]         ;180
0000b8  1c86              ADDS     r6,r0,#2              ;180
0000ba  f806700c          STRB     r7,[r6,r12]           ;180
0000be  4e0a              LDR      r6,|L19.232|
0000c0  f8b66470          LDRH     r6,[r6,#0x470]        ;182
0000c4  1c76              ADDS     r6,r6,#1              ;182
0000c6  b2b7              UXTH     r7,r6                 ;182
0000c8  4e07              LDR      r6,|L19.232|
0000ca  f8a67470          STRH     r7,[r6,#0x470]        ;182
0000ce  f8b66470          LDRH     r6,[r6,#0x470]        ;183
0000d2  2703              MOVS     r7,#3                 ;183
0000d4  fb96fcf7          SDIV     r12,r6,r7             ;183
0000d8  fb07661c          MLS      r6,r7,r12,r6          ;183
0000dc  b2b7              UXTH     r7,r6                 ;183
0000de  4e02              LDR      r6,|L19.232|
0000e0  f8a67470          STRH     r7,[r6,#0x470]        ;183
0000e4  bf00              NOP      
0000e6  e7a4              B        |L19.50|
;;;186    
                          ENDP

                  |L19.232|
                          DCD      canProtocol1CB
                  |L19.236|
                          DCD      canProtocol1CB+0x2a0

                          AREA ||i.CAN_PROTOCOL1_TxStateProcess||, CODE, READONLY, ALIGN=2

                  CAN_PROTOCOL1_TxStateProcess PROC
;;;283    // 协议层发送处理过程
;;;284    void CAN_PROTOCOL1_TxStateProcess(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;285    {
;;;286        uint16 head = canProtocol1CB.tx.head;
000004  4821              LDR      r0,|L20.140|
000006  f8b0446e          LDRH     r4,[r0,#0x46e]
;;;287        uint16 end = canProtocol1CB.tx.end;
00000a  f8b05470          LDRH     r5,[r0,#0x470]
;;;288        uint16 length = canProtocol1CB.tx.cmdQueue[head].length;
00000e  204d              MOVS     r0,#0x4d
000010  4360              MULS     r0,r4,r0
000012  491f              LDR      r1,|L20.144|
000014  eb010040          ADD      r0,r1,r0,LSL #1
000018  f8b06098          LDRH     r6,[r0,#0x98]
;;;289        uint8 *pCmd = canProtocol1CB.tx.cmdQueue[head].buff;
00001c  204d              MOVS     r0,#0x4d
00001e  4360              MULS     r0,r4,r0
000020  eb010040          ADD      r0,r1,r0,LSL #1
000024  1c87              ADDS     r7,r0,#2
;;;290        uint16 localDeviceID = canProtocol1CB.tx.cmdQueue[head].deviceID;
000026  204d              MOVS     r0,#0x4d
000028  4360              MULS     r0,r4,r0
00002a  f8318010          LDRH     r8,[r1,r0,LSL #1]
;;;291    
;;;292        // 发送缓冲区为空，说明无数据
;;;293        if (head == end)
00002e  42ac              CMP      r4,r5
000030  d101              BNE      |L20.54|
                  |L20.50|
;;;294        {
;;;295            return;
;;;296        }
;;;297    
;;;298        // 发送函数没有注册直接返回
;;;299        if (NULL == canProtocol1CB.sendDataThrowService)
;;;300        {
;;;301            return;
;;;302        }
;;;303    
;;;304        // 协议层有数据需要发送到驱动层
;;;305        if (!(*canProtocol1CB.sendDataThrowService)(localDeviceID, pCmd, length))
;;;306        {
;;;307            return;
;;;308        }
;;;309    
;;;310        // 发送环形队列更新位置
;;;311        canProtocol1CB.tx.cmdQueue[head].length = 0;
;;;312        canProtocol1CB.tx.head++;
;;;313        canProtocol1CB.tx.head %= CAN_PROTOCOL1_TX_QUEUE_SIZE;
;;;314    }
000032  e8bd81f0          POP      {r4-r8,pc}
                  |L20.54|
000036  4815              LDR      r0,|L20.140|
000038  f8d00478          LDR      r0,[r0,#0x478]        ;299  ; canProtocol1CB
00003c  b900              CBNZ     r0,|L20.64|
00003e  e7f8              B        |L20.50|
                  |L20.64|
000040  b2f2              UXTB     r2,r6                 ;305
000042  4812              LDR      r0,|L20.140|
000044  4639              MOV      r1,r7                 ;305
000046  f8d03478          LDR      r3,[r0,#0x478]        ;305  ; canProtocol1CB
00004a  4640              MOV      r0,r8                 ;305
00004c  4798              BLX      r3                    ;305
00004e  b900              CBNZ     r0,|L20.82|
000050  e7ef              B        |L20.50|
                  |L20.82|
000052  2200              MOVS     r2,#0                 ;311
000054  204d              MOVS     r0,#0x4d              ;311
000056  4360              MULS     r0,r4,r0              ;311
000058  490d              LDR      r1,|L20.144|
00005a  eb010040          ADD      r0,r1,r0,LSL #1       ;311
00005e  f8a02098          STRH     r2,[r0,#0x98]         ;311
000062  480a              LDR      r0,|L20.140|
000064  f8b0046e          LDRH     r0,[r0,#0x46e]        ;312
000068  1c40              ADDS     r0,r0,#1              ;312
00006a  b281              UXTH     r1,r0                 ;312
00006c  4807              LDR      r0,|L20.140|
00006e  f8a0146e          STRH     r1,[r0,#0x46e]        ;312
000072  f8b0046e          LDRH     r0,[r0,#0x46e]        ;313
000076  2103              MOVS     r1,#3                 ;313
000078  fb90f2f1          SDIV     r2,r0,r1              ;313
00007c  fb010012          MLS      r0,r1,r2,r0           ;313
000080  b281              UXTH     r1,r0                 ;313
000082  4802              LDR      r0,|L20.140|
000084  f8a0146e          STRH     r1,[r0,#0x46e]        ;313
000088  bf00              NOP      
00008a  e7d2              B        |L20.50|
;;;315    
                          ENDP

                  |L20.140|
                          DCD      canProtocol1CB
                  |L20.144|
                          DCD      canProtocol1CB+0x2a0

                          AREA ||i.CAN_PROTOCOL_Process_3A||, CODE, READONLY, ALIGN=2

                  CAN_PROTOCOL_Process_3A PROC
;;;102    // UART协议层过程处理
;;;103    void CAN_PROTOCOL_Process_3A(void)
000000  b510              PUSH     {r4,lr}
;;;104    {
;;;105        // UART接收FIFO缓冲区处理
;;;106        CAN_PROTOCOL1_RxFIFOProcess(&canProtocol1CB);
000002  4804              LDR      r0,|L21.20|
000004  f7fffffe          BL       CAN_PROTOCOL1_RxFIFOProcess
;;;107    
;;;108        // UART接收命令缓冲区处理
;;;109        CAN_PROTOCOL1_CmdFrameProcess(&canProtocol1CB);
000008  4802              LDR      r0,|L21.20|
00000a  f7fffffe          BL       CAN_PROTOCOL1_CmdFrameProcess
;;;110    
;;;111        // UART协议层发送处理过程
;;;112        CAN_PROTOCOL1_TxStateProcess();
00000e  f7fffffe          BL       CAN_PROTOCOL1_TxStateProcess
;;;113    }
000012  bd10              POP      {r4,pc}
;;;114    
                          ENDP

                  |L21.20|
                          DCD      canProtocol1CB

                          AREA ||i.can_test||, CODE, READONLY, ALIGN=1

                  can_test PROC
;;;76     
;;;77     void can_test(uint32 temp)
000000  b510              PUSH     {r4,lr}
;;;78     {
000002  4604              MOV      r4,r0
;;;79         CAN_PROTOCOL1_SendCmdWithResult(0x88, FALSE);
000004  2100              MOVS     r1,#0
000006  2088              MOVS     r0,#0x88
000008  f7fffffe          BL       CAN_PROTOCOL1_SendCmdWithResult
;;;80     }
00000c  bd10              POP      {r4,pc}
;;;81     
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  canProtocol1CB
                          %        1148

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

000000  ff000000          DCB      0xff,0x00,0x00,0x00

;*** Start embedded assembler ***

#line 1 "User\\CanProtocol_3A.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_CanProtocol_3A_c_a6b80008____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___16_CanProtocol_3A_c_a6b80008____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_CanProtocol_3A_c_a6b80008____REVSH|
#line 128
|__asm___16_CanProtocol_3A_c_a6b80008____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
