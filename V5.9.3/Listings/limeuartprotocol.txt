; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\limeuartprotocol.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\limeuartprotocol.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -I.\User\qrencode -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.3\Device\Include -D__MICROLIB -D__UVISION_VERSION=539 -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\limeuartprotocol.crf User\LimeUartProtocol.c]
                          THUMB

                          AREA ||i.LIME_Protocol_SendOnePacket||, CODE, READONLY, ALIGN=1

                  LIME_Protocol_SendOnePacket PROC
;;;785    
;;;786    void LIME_Protocol_SendOnePacket(uint32 flashAddr, uint32 addr)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;787    {
000004  b0a6              SUB      sp,sp,#0x98
000006  4606              MOV      r6,r0
000008  460c              MOV      r4,r1
;;;788        uint8 addr1, addr2, addr3, addr4;
;;;789        uint8 appUpdateOnePacket[150] = {0};
00000a  2198              MOVS     r1,#0x98
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       __aeabi_memclr4
;;;790        uint8 appUpdateOnePacket_i = 0;
000012  2500              MOVS     r5,#0
;;;791        addr1 = (addr & 0xFF000000) >> 24;
000014  0e27              LSRS     r7,r4,#24
;;;792        addr2 = (addr & 0x00FF0000) >> 16;
000016  f3c44807          UBFX     r8,r4,#16,#8
;;;793        addr3 = (addr & 0x0000FF00) >> 8;
00001a  f3c42907          UBFX     r9,r4,#8,#8
;;;794        addr4 = (addr & 0x000000FF);
00001e  f0040aff          AND      r10,r4,#0xff
;;;795        SPI_FLASH_ReadArray(appUpdateOnePacket, flashAddr + addr, 128); // 工具读取128字节
000022  1931              ADDS     r1,r6,r4
000024  2280              MOVS     r2,#0x80
000026  4668              MOV      r0,sp
000028  f7fffffe          BL       SPI_FLASH_ReadArray
;;;796    
;;;797        LIME_UART_PROTOCOL_TxAddData(LIME_UART_PROTOCOL_CMD_HEAD1);
00002c  204c              MOVS     r0,#0x4c
00002e  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;798        LIME_UART_PROTOCOL_TxAddData(LIME_UART_PROTOCOL_CMD_HEAD2);
000032  2042              MOVS     r0,#0x42
000034  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;799        LIME_UART_PROTOCOL_TxAddData(LIME_UART_PROTOCOL_CMD_HEAD3);
000038  2044              MOVS     r0,#0x44
00003a  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;800        LIME_UART_PROTOCOL_TxAddData(LIME_UART_PROTOCOL_CMD_HEAD4);
00003e  2043              MOVS     r0,#0x43
000040  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;801        LIME_UART_PROTOCOL_TxAddData(LIME_UART_PROTOCOL_CMD_HEAD5);
000044  2050              MOVS     r0,#0x50
000046  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;802        LIME_UART_PROTOCOL_TxAddData(LIME_UART_PROTOCOL_CMD_PROTOCOL_VERSION);
00004a  2001              MOVS     r0,#1
00004c  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;803        LIME_UART_PROTOCOL_TxAddData(LIME_UART_PROTOCOL_CMD_DEVICE_ADDR);
000050  2010              MOVS     r0,#0x10
000052  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;804        LIME_UART_PROTOCOL_TxAddData(LIME_UART_PROTOCOL_ECO_CMD_APP_WRITE);
000056  2005              MOVS     r0,#5
000058  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;805    
;;;806        LIME_UART_PROTOCOL_TxAddData(0x00);                                                    // 长度暂时为0
00005c  2000              MOVS     r0,#0
00005e  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;807    		LIME_UART_PROTOCOL_TxAddData(0x87);                                                    // 长度暂时为0
000062  2087              MOVS     r0,#0x87
000064  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;808    
;;;809     		LIME_UART_PROTOCOL_TxAddData(0x04);                                                    // 4个地址数据   
000068  2004              MOVS     r0,#4
00006a  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;810        LIME_UART_PROTOCOL_TxAddData(addr1);                                                       // 添加地址
00006e  4638              MOV      r0,r7
000070  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;811        LIME_UART_PROTOCOL_TxAddData(addr2);                                                       // 添加地址
000074  4640              MOV      r0,r8
000076  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;812        LIME_UART_PROTOCOL_TxAddData(addr3);                                                       // 添加地址
00007a  4648              MOV      r0,r9
00007c  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;813        LIME_UART_PROTOCOL_TxAddData(addr4);                                                       // 添加地址
000080  4650              MOV      r0,r10
000082  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;814    		
;;;815     		LIME_UART_PROTOCOL_TxAddData(0x00);                                                    // 一个字节数据   
000086  2000              MOVS     r0,#0
000088  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;816      	LIME_UART_PROTOCOL_TxAddData(0x80);                                                    // 一个字节数据      		
00008c  2080              MOVS     r0,#0x80
00008e  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;817        for (appUpdateOnePacket_i = 0; appUpdateOnePacket_i < 128; appUpdateOnePacket_i++) // 添加数据
000092  bf00              NOP      
000094  e005              B        |L1.162|
                  |L1.150|
;;;818        {
;;;819            LIME_UART_PROTOCOL_TxAddData(appUpdateOnePacket[appUpdateOnePacket_i]);
000096  f81d0005          LDRB     r0,[sp,r5]
00009a  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
00009e  1c68              ADDS     r0,r5,#1              ;817
0000a0  b2c5              UXTB     r5,r0                 ;817
                  |L1.162|
0000a2  2d80              CMP      r5,#0x80              ;817
0000a4  dbf7              BLT      |L1.150|
;;;820        }
;;;821        LIME_UART_PROTOCOL_TxAddFrame(); // 调整帧格式,修改长度和添加校验
0000a6  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddFrame
;;;822    }
0000aa  b026              ADD      sp,sp,#0x98
0000ac  e8bd87f0          POP      {r4-r10,pc}
                          ENDP


                          AREA ||i.LIME_UART_PROTOCOL_CALLBACK_SetTxPeriodRequest||, CODE, READONLY, ALIGN=2

                  LIME_UART_PROTOCOL_CALLBACK_SetTxPeriodRequest PROC
;;;745    // 码表设置周期下发数据请求标志
;;;746    void LIME_UART_PROTOCOL_CALLBACK_SetTxPeriodRequest(uint32 param)
000000  4a01              LDR      r2,|L2.8|
;;;747    {
;;;748        uartProtocolCB4.txPeriodRequest = (BOOL)param;
000002  f8820600          STRB     r0,[r2,#0x600]
;;;749    }
000006  4770              BX       lr
;;;750    
                          ENDP

                  |L2.8|
                          DCD      uartProtocolCB4

                          AREA ||i.LIME_UART_PROTOCOL_CheckSUM||, CODE, READONLY, ALIGN=1

                  LIME_UART_PROTOCOL_CheckSUM PROC
;;;485    // 对传入的命令帧进行校验，返回校验结果
;;;486    BOOL LIME_UART_PROTOCOL_CheckSUM(LIME_UART_PROTOCOL_RX_CMD_FRAME *pCmdFrame)
000000  b530              PUSH     {r4,r5,lr}
;;;487    {
000002  4604              MOV      r4,r0
;;;488        uint8 cc = 0;
000004  2500              MOVS     r5,#0
;;;489    
;;;490        if (NULL == pCmdFrame)
000006  b90c              CBNZ     r4,|L3.12|
;;;491        {
;;;492            return FALSE;
000008  2000              MOVS     r0,#0
                  |L3.10|
;;;493        }
;;;494    
;;;495        // 从协议版本开始，到校验码之前的一个字节，依次进行CRC8运算
;;;496        cc = UART_GetCRCValue(&pCmdFrame->buff[LIME_UART_PROTOCOL_CMD_VERSION_INDEX], (pCmdFrame->length - (LIME_UART_PROTOCOL_HEAD_BYTE + LIME_UART_PROTOCOL_CHECK_BYTE)));
;;;497    
;;;498        // 判断计算得到的校验码与命令帧中的校验码是否相同
;;;499        if (pCmdFrame->buff[pCmdFrame->length - 1] != cc)
;;;500        {
;;;501            return FALSE;
;;;502        }
;;;503    
;;;504        return TRUE;
;;;505    
;;;506    }
00000a  bd30              POP      {r4,r5,pc}
                  |L3.12|
00000c  f8b400a2          LDRH     r0,[r4,#0xa2]         ;496
000010  1f80              SUBS     r0,r0,#6              ;496
000012  b281              UXTH     r1,r0                 ;496
000014  1de0              ADDS     r0,r4,#7              ;496
000016  f7fffffe          BL       UART_GetCRCValue
00001a  4605              MOV      r5,r0                 ;496
00001c  f8b400a2          LDRH     r0,[r4,#0xa2]         ;499
000020  1e40              SUBS     r0,r0,#1              ;499
000022  1ca1              ADDS     r1,r4,#2              ;499
000024  5c08              LDRB     r0,[r1,r0]            ;499
000026  42a8              CMP      r0,r5                 ;499
000028  d001              BEQ      |L3.46|
00002a  2000              MOVS     r0,#0                 ;501
00002c  e7ed              B        |L3.10|
                  |L3.46|
00002e  2001              MOVS     r0,#1                 ;504
000030  e7eb              B        |L3.10|
;;;507    
                          ENDP


                          AREA ||i.LIME_UART_PROTOCOL_CmdFrameProcess||, CODE, READONLY, ALIGN=2

                  LIME_UART_PROTOCOL_CmdFrameProcess PROC
;;;596    // UART命令帧缓冲区处理
;;;597    void LIME_UART_PROTOCOL_CmdFrameProcess(LIME_UART_PROTOCOL_CB *pCB)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;598    {
000004  4604              MOV      r4,r0
;;;599        LIME_UART_PROTOCOL_CMD cmd = LIME_UART_PROTOCOL_CMD_NULL;
000006  2600              MOVS     r6,#0
;;;600        LIME_UART_PROTOCOL_RX_CMD_FRAME *pCmdFrame = NULL;
000008  2500              MOVS     r5,#0
;;;601        uint8 eraResual = 0;
00000a  2700              MOVS     r7,#0
;;;602        uint8 i;
;;;603        uint8 length1;
;;;604    
;;;605        // 参数合法性检验
;;;606        if (NULL == pCB)
00000c  b90c              CBNZ     r4,|L4.18|
                  |L4.14|
;;;607        {
;;;608            return;
;;;609        }
;;;610    
;;;611        // 命令帧缓冲区为空，退出
;;;612        if (pCB->rx.head == pCB->rx.end)
;;;613        {
;;;614            return;
;;;615        }
;;;616    
;;;617        // 获取当前要处理的命令帧指针
;;;618        pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.head];
;;;619    
;;;620        // 命令头非法，退出
;;;621        if (LIME_UART_PROTOCOL_CMD_HEAD != pCmdFrame->buff[LIME_UART_PROTOCOL_CMD_HEAD1_INDEX])
;;;622        {
;;;623            // 删除命令帧
;;;624            pCB->rx.head ++;
;;;625            pCB->rx.head %= LIME_UART_PROTOCOL_RX_QUEUE_SIZE;
;;;626            return;
;;;627        }
;;;628    
;;;629        // 命令头合法，则提取命令
;;;630        cmd = (LIME_UART_PROTOCOL_CMD)pCmdFrame->buff[LIME_UART_PROTOCOL_CMD_CMD_INDEX];
;;;631        switch (dut_info.ID)
;;;632        {
;;;633        case DUT_TYPE_NULL:
;;;634            break;
;;;635    
;;;636        case DUT_TYPE_LIME: // 串口通用升级
;;;637            // 执行命令帧
;;;638            switch (cmd)
;;;639            {
;;;640            // 收到仪表发送的ECO请求
;;;641            case LIME_UART_PROTOCOL_ECO_CMD_REQUEST: // 01
;;;642                // 发送允许进入工程模式
;;;643                STATE_SwitchStep(STEP_LIME_UART_SEG_UPGRADE_RECEIVE_DUT_ECO_REQUEST);
;;;644                break;
;;;645    
;;;646            // 仪表回应准备就绪
;;;647            case LIME_UART_PROTOCOL_ECO_CMD_READY:  // 02
;;;648                // 发送app擦除指令
;;;649                STATE_SwitchStep(STEP_LIME_UART_SEG_UPGRADE_SEND_APP_EAR);
;;;650                break;
;;;651    
;;;652            // dut擦除结果查询
;;;653            case LIME_UART_PROTOCOL_ECO_CMD_APP_ERASE:  //04
;;;654                // 提取仪表擦除结果
;;;655                eraResual = pCmdFrame->buff[LIME_UART_PROTOCOL_CMD_DATA2_INDEX];
;;;656    
;;;657                // 擦除失败
;;;658                if (0 == eraResual)
;;;659                {
;;;660                    // 擦除失败再擦除一次
;;;661                    STATE_SwitchStep(STEP_LIME_UART_SEG_UPGRADE_SEND_APP_EAR);
;;;662                    break;
;;;663                }
;;;664                // 擦除成功
;;;665                // 发送第一包数据
;;;666                STATE_SwitchStep(STEP_LIME_UART_SEG_UPGRADE_SEND_FIRST_APP_PACKET);
;;;667    
;;;668                break;
;;;669            case LIME_UART_PROTOCOL_ECO_CMD_APP_WRITE: // 05,app数据写入
;;;670               // eraResual = pCmdFrame->buff[LIME_UART_PROTOCOL_CMD_DATA2_INDEX];
;;;671    					 eraResual = pCmdFrame->buff[LIME_UART_PROTOCOL_CMD_DATA3_INDEX];
;;;672                if (0 == eraResual) // 如果仪表写入失败
;;;673                {
;;;674                    break;
;;;675                }
;;;676                else
;;;677                {
;;;678                    if (dut_info.currentAppSize < dut_info.appSize)
;;;679                    {
;;;680                        STATE_SwitchStep(STEP_LIME_UART_SEG_UPGRADE_SEND_APP_PACKET); // 发送app数据包
;;;681                    }
;;;682                    else
;;;683                    {
;;;684                        STATE_SwitchStep(STEP_LIME_UART_SEG_UPGRADE_APP_UP_SUCCESS);
;;;685                    }
;;;686                }
;;;687                break;
;;;688    
;;;689            case LIME_UART_PROTOCOL_ECO_CMD_APP_WRITE_FINISH: // 06，app升级完毕
;;;690                STATE_SwitchStep(STEP_LIME_UART_SEG_UPGRADE_ITEM_FINISH);
;;;691                break;
;;;692    
;;;693                break;
;;;694    
;;;695            default:
;;;696                break;
;;;697            }
;;;698            break;
;;;699        default:
;;;700            break;
;;;701        }
;;;702    
;;;703        // 无通讯，回到LOGO界面
;;;704    //  TIMER_AddTask(TIMER_ID_STATE_CONTROL,
;;;705    //                  timeOut,
;;;706    //                  LIME_UART_PROTOCOL_CALLBACK_UartBusError,
;;;707    //                  TRUE,
;;;708    //                  1,
;;;709    //                  ACTION_MODE_ADD_TO_QUEUE);
;;;710    
;;;711        // 删除命令帧
;;;712        pCB->rx.head ++;
;;;713        pCB->rx.head %= LIME_UART_PROTOCOL_RX_QUEUE_SIZE;
;;;714    }
00000e  e8bd81f0          POP      {r4-r8,pc}
                  |L4.18|
000012  f8b4135e          LDRH     r1,[r4,#0x35e]        ;612
000016  f8b40360          LDRH     r0,[r4,#0x360]        ;612
00001a  4281              CMP      r1,r0                 ;612
00001c  d100              BNE      |L4.32|
00001e  e7f6              B        |L4.14|
                  |L4.32|
000020  f8b4035e          LDRH     r0,[r4,#0x35e]        ;618
000024  eb0001c0          ADD      r1,r0,r0,LSL #3       ;618
000028  eb011140          ADD      r1,r1,r0,LSL #5       ;618
00002c  f10400ce          ADD      r0,r4,#0xce           ;618
000030  eb000581          ADD      r5,r0,r1,LSL #2       ;618
000034  78a8              LDRB     r0,[r5,#2]            ;621
000036  284c              CMP      r0,#0x4c              ;621
000038  d00f              BEQ      |L4.90|
00003a  f8b4035e          LDRH     r0,[r4,#0x35e]        ;624
00003e  1c40              ADDS     r0,r0,#1              ;624
000040  f8a4035e          STRH     r0,[r4,#0x35e]        ;624
000044  f8b4035e          LDRH     r0,[r4,#0x35e]        ;625
000048  17c1              ASRS     r1,r0,#31             ;625
00004a  eb007191          ADD      r1,r0,r1,LSR #30      ;625
00004e  1089              ASRS     r1,r1,#2              ;625
000050  eba00181          SUB      r1,r0,r1,LSL #2       ;625
000054  f8a4135e          STRH     r1,[r4,#0x35e]        ;625
000058  e7d9              B        |L4.14|
                  |L4.90|
00005a  7a6e              LDRB     r6,[r5,#9]            ;630
00005c  4825              LDR      r0,|L4.244|
00005e  7d80              LDRB     r0,[r0,#0x16]         ;631  ; dut_info
000060  b110              CBZ      r0,|L4.104|
000062  2806              CMP      r0,#6                 ;631
000064  d133              BNE      |L4.206|
000066  e000              B        |L4.106|
                  |L4.104|
000068  e032              B        |L4.208|
                  |L4.106|
00006a  2e07              CMP      r6,#7                 ;638
00006c  d22c              BCS      |L4.200|
00006e  e8dff006          TBB      [pc,r6]               ;638
000072  2b04              DCB      0x2b,0x04
000074  082b0c16          DCB      0x08,0x2b,0x0c,0x16
000078  2700              DCB      0x27,0x00
00007a  2088              MOVS     r0,#0x88              ;643
00007c  f7fffffe          BL       STATE_SwitchStep
000080  e023              B        |L4.202|
000082  208a              MOVS     r0,#0x8a              ;649
000084  f7fffffe          BL       STATE_SwitchStep
000088  e01f              B        |L4.202|
00008a  7b6f              LDRB     r7,[r5,#0xd]          ;655
00008c  b91f              CBNZ     r7,|L4.150|
00008e  208a              MOVS     r0,#0x8a              ;661
000090  f7fffffe          BL       STATE_SwitchStep
000094  e019              B        |L4.202|
                  |L4.150|
000096  208b              MOVS     r0,#0x8b              ;666
000098  f7fffffe          BL       STATE_SwitchStep
00009c  e015              B        |L4.202|
00009e  7baf              LDRB     r7,[r5,#0xe]          ;671
0000a0  b907              CBNZ     r7,|L4.164|
0000a2  e012              B        |L4.202|
                  |L4.164|
0000a4  4813              LDR      r0,|L4.244|
0000a6  6b00              LDR      r0,[r0,#0x30]         ;678  ; dut_info
0000a8  4912              LDR      r1,|L4.244|
0000aa  6a49              LDR      r1,[r1,#0x24]         ;678  ; dut_info
0000ac  4288              CMP      r0,r1                 ;678
0000ae  d203              BCS      |L4.184|
0000b0  208c              MOVS     r0,#0x8c              ;680
0000b2  f7fffffe          BL       STATE_SwitchStep
0000b6  e002              B        |L4.190|
                  |L4.184|
0000b8  208d              MOVS     r0,#0x8d              ;684
0000ba  f7fffffe          BL       STATE_SwitchStep
                  |L4.190|
0000be  e004              B        |L4.202|
0000c0  208e              MOVS     r0,#0x8e              ;690
0000c2  f7fffffe          BL       STATE_SwitchStep
0000c6  e000              B        |L4.202|
                  |L4.200|
0000c8  bf00              NOP                            ;696
                  |L4.202|
0000ca  bf00              NOP                            ;644
0000cc  e000              B        |L4.208|
                  |L4.206|
0000ce  bf00              NOP                            ;700
                  |L4.208|
0000d0  bf00              NOP                            ;634
0000d2  f8b4035e          LDRH     r0,[r4,#0x35e]        ;712
0000d6  1c40              ADDS     r0,r0,#1              ;712
0000d8  f8a4035e          STRH     r0,[r4,#0x35e]        ;712
0000dc  f8b4035e          LDRH     r0,[r4,#0x35e]        ;713
0000e0  17c1              ASRS     r1,r0,#31             ;713
0000e2  eb007191          ADD      r1,r0,r1,LSR #30      ;713
0000e6  1089              ASRS     r1,r1,#2              ;713
0000e8  eba00181          SUB      r1,r0,r1,LSL #2       ;713
0000ec  f8a4135e          STRH     r1,[r4,#0x35e]        ;713
0000f0  bf00              NOP      
0000f2  e78c              B        |L4.14|
;;;715    
                          ENDP

                  |L4.244|
                          DCD      dut_info

                          AREA ||i.LIME_UART_PROTOCOL_ConfirmTempCmdFrameBuff||, CODE, READONLY, ALIGN=1

                  LIME_UART_PROTOCOL_ConfirmTempCmdFrameBuff PROC
;;;266    // 将临时缓冲区添加到命令帧缓冲区中，其本质操作是承认临时缓冲区数据有效
;;;267    BOOL LIME_UART_PROTOCOL_ConfirmTempCmdFrameBuff(LIME_UART_PROTOCOL_CB *pCB)
000000  b510              PUSH     {r4,lr}
;;;268    {
000002  4601              MOV      r1,r0
;;;269        LIME_UART_PROTOCOL_RX_CMD_FRAME *pCmdFrame = NULL;
000004  2200              MOVS     r2,#0
;;;270    
;;;271        // 参数合法性检验
;;;272        if (NULL == pCB)
000006  b909              CBNZ     r1,|L5.12|
;;;273        {
;;;274            return FALSE;
000008  2000              MOVS     r0,#0
                  |L5.10|
;;;275        }
;;;276    
;;;277        // 临时缓冲区为空，不予添加
;;;278        pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.end];
;;;279        if (0 == pCmdFrame->length)
;;;280        {
;;;281            return FALSE;
;;;282        }
;;;283    
;;;284        // 添加
;;;285        pCB->rx.end ++;
;;;286        pCB->rx.end %= LIME_UART_PROTOCOL_RX_QUEUE_SIZE;
;;;287        pCB->rx.cmdQueue[pCB->rx.end].length = 0;   // 该行的作用是将新的添加位置有效数据个数清零，以便将这个位置当做临时帧缓冲区
;;;288    
;;;289        return TRUE;
;;;290    }
00000a  bd10              POP      {r4,pc}
                  |L5.12|
00000c  f8b10360          LDRH     r0,[r1,#0x360]        ;278
000010  eb0003c0          ADD      r3,r0,r0,LSL #3       ;278
000014  eb031340          ADD      r3,r3,r0,LSL #5       ;278
000018  f10100ce          ADD      r0,r1,#0xce           ;278
00001c  eb000283          ADD      r2,r0,r3,LSL #2       ;278
000020  f8b200a2          LDRH     r0,[r2,#0xa2]         ;279
000024  b908              CBNZ     r0,|L5.42|
000026  2000              MOVS     r0,#0                 ;281
000028  e7ef              B        |L5.10|
                  |L5.42|
00002a  f8b10360          LDRH     r0,[r1,#0x360]        ;285
00002e  1c40              ADDS     r0,r0,#1              ;285
000030  f8a10360          STRH     r0,[r1,#0x360]        ;285
000034  f8b10360          LDRH     r0,[r1,#0x360]        ;286
000038  17c3              ASRS     r3,r0,#31             ;286
00003a  eb007393          ADD      r3,r0,r3,LSR #30      ;286
00003e  109b              ASRS     r3,r3,#2              ;286
000040  eba00383          SUB      r3,r0,r3,LSL #2       ;286
000044  f8a13360          STRH     r3,[r1,#0x360]        ;286
000048  2300              MOVS     r3,#0                 ;287
00004a  f8b10360          LDRH     r0,[r1,#0x360]        ;287
00004e  eb0004c0          ADD      r4,r0,r0,LSL #3       ;287
000052  eb041440          ADD      r4,r4,r0,LSL #5       ;287
000056  f10100ce          ADD      r0,r1,#0xce           ;287
00005a  eb000084          ADD      r0,r0,r4,LSL #2       ;287
00005e  f8a030a2          STRH     r3,[r0,#0xa2]         ;287
000062  2001              MOVS     r0,#1                 ;289
000064  e7d1              B        |L5.10|
;;;291    
                          ENDP


                          AREA ||i.LIME_UART_PROTOCOL_DataStructInit||, CODE, READONLY, ALIGN=1

                  LIME_UART_PROTOCOL_DataStructInit PROC
;;;203    // 数据结构初始化
;;;204    void LIME_UART_PROTOCOL_DataStructInit(LIME_UART_PROTOCOL_CB *pCB)
000000  b510              PUSH     {r4,lr}
;;;205    {
;;;206        uint16 i;
;;;207    
;;;208        // 参数合法性检验
;;;209        if (NULL == pCB)
000002  b900              CBNZ     r0,|L6.6|
                  |L6.4|
;;;210        {
;;;211            return;
;;;212        }
;;;213    
;;;214        pCB->tx.txBusy = FALSE;
;;;215        pCB->tx.index = 0;
;;;216        pCB->tx.head = 0;
;;;217        pCB->tx.end = 0;
;;;218        for (i = 0; i < LIME_UART_PROTOCOL_TX_QUEUE_SIZE; i++)
;;;219        {
;;;220            pCB->tx.cmdQueue[i].length = 0;
;;;221        }
;;;222    
;;;223        pCB->rxFIFO.head = 0;
;;;224        pCB->rxFIFO.end = 0;
;;;225        pCB->rxFIFO.currentProcessIndex = 0;
;;;226    
;;;227        pCB->rx.head = 0;
;;;228        pCB->rx.end  = 0;
;;;229        for (i = 0; i < LIME_UART_PROTOCOL_RX_QUEUE_SIZE; i++)
;;;230        {
;;;231            pCB->rx.cmdQueue[i].length = 0;
;;;232        }
;;;233    }
000004  bd10              POP      {r4,pc}
                  |L6.6|
000006  2300              MOVS     r3,#0                 ;214
000008  f88035f8          STRB     r3,[r0,#0x5f8]        ;214
00000c  f8a035f6          STRH     r3,[r0,#0x5f6]        ;215
000010  f8a035f2          STRH     r3,[r0,#0x5f2]        ;216
000014  f8a035f4          STRH     r3,[r0,#0x5f4]        ;217
000018  2100              MOVS     r1,#0                 ;218
00001a  e00c              B        |L6.54|
                  |L6.28|
00001c  2300              MOVS     r3,#0                 ;220
00001e  eb0102c1          ADD      r2,r1,r1,LSL #3       ;220
000022  eb021441          ADD      r4,r2,r1,LSL #5       ;220
000026  f2003262          ADD      r2,r0,#0x362          ;220
00002a  eb020284          ADD      r2,r2,r4,LSL #2       ;220
00002e  f8a230a2          STRH     r3,[r2,#0xa2]         ;220
000032  1c4a              ADDS     r2,r1,#1              ;218
000034  b291              UXTH     r1,r2                 ;218
                  |L6.54|
000036  2904              CMP      r1,#4                 ;218
000038  dbf0              BLT      |L6.28|
00003a  2200              MOVS     r2,#0                 ;223
00003c  f8202fc8          STRH     r2,[r0,#0xc8]!        ;223
000040  8042              STRH     r2,[r0,#2]            ;224
000042  8082              STRH     r2,[r0,#4]            ;225
000044  38c8              SUBS     r0,r0,#0xc8           ;225
000046  2300              MOVS     r3,#0                 ;227
000048  f8a0335e          STRH     r3,[r0,#0x35e]        ;227
00004c  f8a03360          STRH     r3,[r0,#0x360]        ;228
000050  2100              MOVS     r1,#0                 ;229
000052  e00c              B        |L6.110|
                  |L6.84|
000054  2300              MOVS     r3,#0                 ;231
000056  eb0102c1          ADD      r2,r1,r1,LSL #3       ;231
00005a  eb021441          ADD      r4,r2,r1,LSL #5       ;231
00005e  f10002ce          ADD      r2,r0,#0xce           ;231
000062  eb020284          ADD      r2,r2,r4,LSL #2       ;231
000066  f8a230a2          STRH     r3,[r2,#0xa2]         ;231
00006a  1c4a              ADDS     r2,r1,#1              ;229
00006c  b291              UXTH     r1,r2                 ;229
                  |L6.110|
00006e  2904              CMP      r1,#4                 ;229
000070  dbf0              BLT      |L6.84|
000072  bf00              NOP      
000074  e7c6              B        |L6.4|
;;;234    
                          ENDP


                          AREA ||i.LIME_UART_PROTOCOL_Init||, CODE, READONLY, ALIGN=2

                  LIME_UART_PROTOCOL_Init PROC
;;;110    // 协议初始化
;;;111    void LIME_UART_PROTOCOL_Init(void)
000000  b510              PUSH     {r4,lr}
;;;112    {
;;;113        // 协议层数据结构初始化
;;;114        LIME_UART_PROTOCOL_DataStructInit(&uartProtocolCB4);
000002  4805              LDR      r0,|L7.24|
000004  f7fffffe          BL       LIME_UART_PROTOCOL_DataStructInit
;;;115    
;;;116        // 向驱动层注册数据接收接口
;;;117        UART_DRIVE_RegisterDataSendService(LIME_UART_PROTOCOL_MacProcess);
000008  4804              LDR      r0,|L7.28|
00000a  f7fffffe          BL       UART_DRIVE_RegisterDataSendService
;;;118    
;;;119        // 向驱动层注册数据发送接口
;;;120        LIME_UART_PROTOCOL_RegisterDataSendService(UART_DRIVE_AddTxArray);
00000e  4804              LDR      r0,|L7.32|
000010  f7fffffe          BL       LIME_UART_PROTOCOL_RegisterDataSendService
;;;121    }
000014  bd10              POP      {r4,pc}
;;;122    
                          ENDP

000016  0000              DCW      0x0000
                  |L7.24|
                          DCD      uartProtocolCB4
                  |L7.28|
                          DCD      LIME_UART_PROTOCOL_MacProcess
                  |L7.32|
                          DCD      UART_DRIVE_AddTxArray

                          AREA ||i.LIME_UART_PROTOCOL_MacProcess||, CODE, READONLY, ALIGN=2

                  LIME_UART_PROTOCOL_MacProcess PROC
;;;235    // UART报文接收处理函数(注意根据具体模块修改)
;;;236    void LIME_UART_PROTOCOL_MacProcess(uint16 standarID, uint8 *pData, uint16 length)
000000  b5f0              PUSH     {r4-r7,lr}
;;;237    {
000002  4604              MOV      r4,r0
000004  4615              MOV      r5,r2
;;;238        uint16 end = uartProtocolCB4.rxFIFO.end;
000006  4e12              LDR      r6,|L8.80|
000008  f8b600ca          LDRH     r0,[r6,#0xca]  ; uartProtocolCB4
;;;239        uint16 head = uartProtocolCB4.rxFIFO.head;
00000c  f8b620c8          LDRH     r2,[r6,#0xc8]  ; uartProtocolCB4
;;;240        uint8 rxdata = 0x00;
000010  2300              MOVS     r3,#0
;;;241    
;;;242        // 接收数据
;;;243        rxdata = *pData;
000012  780b              LDRB     r3,[r1,#0]
;;;244    
;;;245        // 一级缓冲区已满，不予接收
;;;246        if ((end + 1) % LIME_UART_PROTOCOL_RX_FIFO_SIZE == head)
000014  1c46              ADDS     r6,r0,#1
000016  27c8              MOVS     r7,#0xc8
000018  fb96fcf7          SDIV     r12,r6,r7
00001c  fb07661c          MLS      r6,r7,r12,r6
000020  4296              CMP      r6,r2
000022  d100              BNE      |L8.38|
                  |L8.36|
;;;247        {
;;;248            return;
;;;249        }
;;;250        // 一级缓冲区未满，接收
;;;251        else
;;;252        {
;;;253            // 将接收到的数据放到临时缓冲区中
;;;254            uartProtocolCB4.rxFIFO.buff[end] = rxdata;
;;;255            uartProtocolCB4.rxFIFO.end ++;
;;;256            uartProtocolCB4.rxFIFO.end %= LIME_UART_PROTOCOL_RX_FIFO_SIZE;
;;;257        }
;;;258    }
000024  bdf0              POP      {r4-r7,pc}
                  |L8.38|
000026  4e0a              LDR      r6,|L8.80|
000028  5433              STRB     r3,[r6,r0]            ;254
00002a  f8b660ca          LDRH     r6,[r6,#0xca]         ;255  ; uartProtocolCB4
00002e  1c76              ADDS     r6,r6,#1              ;255
000030  4f07              LDR      r7,|L8.80|
000032  f8a760ca          STRH     r6,[r7,#0xca]         ;255
000036  463e              MOV      r6,r7                 ;256
000038  f8b660ca          LDRH     r6,[r6,#0xca]         ;256  ; uartProtocolCB4
00003c  27c8              MOVS     r7,#0xc8              ;256
00003e  fb96fcf7          SDIV     r12,r6,r7             ;256
000042  fb07661c          MLS      r6,r7,r12,r6          ;256
000046  4f02              LDR      r7,|L8.80|
000048  f8a760ca          STRH     r6,[r7,#0xca]         ;256
00004c  bf00              NOP      
00004e  e7e9              B        |L8.36|
;;;259    
                          ENDP

                  |L8.80|
                          DCD      uartProtocolCB4

                          AREA ||i.LIME_UART_PROTOCOL_Process||, CODE, READONLY, ALIGN=2

                  LIME_UART_PROTOCOL_Process PROC
;;;123    // UART协议层过程处理
;;;124    void LIME_UART_PROTOCOL_Process(void)
000000  b510              PUSH     {r4,lr}
;;;125    {
;;;126        // UART接收FIFO缓冲区处理
;;;127        LIME_UART_PROTOCOL_RxFIFOProcess(&uartProtocolCB4);
000002  4804              LDR      r0,|L9.20|
000004  f7fffffe          BL       LIME_UART_PROTOCOL_RxFIFOProcess
;;;128    
;;;129        // UART接收命令缓冲区处理
;;;130        LIME_UART_PROTOCOL_CmdFrameProcess(&uartProtocolCB4);
000008  4802              LDR      r0,|L9.20|
00000a  f7fffffe          BL       LIME_UART_PROTOCOL_CmdFrameProcess
;;;131    
;;;132        // UART协议层发送处理过程
;;;133        LIME_UART_PROTOCOL_TxStateProcess();
00000e  f7fffffe          BL       LIME_UART_PROTOCOL_TxStateProcess
;;;134    }
000012  bd10              POP      {r4,pc}
;;;135    
                          ENDP

                  |L9.20|
                          DCD      uartProtocolCB4

                          AREA ||i.LIME_UART_PROTOCOL_RegisterDataSendService||, CODE, READONLY, ALIGN=2

                  LIME_UART_PROTOCOL_RegisterDataSendService PROC
;;;260    // UART协议层向驱动层注册数据发送接口
;;;261    void LIME_UART_PROTOCOL_RegisterDataSendService(BOOL (*service)(uint16 id, uint8 *pData, uint16 length))
000000  4901              LDR      r1,|L10.8|
;;;262    {
;;;263        uartProtocolCB4.sendDataThrowService = service;
000002  f8c105fc          STR      r0,[r1,#0x5fc]  ; uartProtocolCB4
;;;264    }
000006  4770              BX       lr
;;;265    
                          ENDP

                  |L10.8|
                          DCD      uartProtocolCB4

                          AREA ||i.LIME_UART_PROTOCOL_RxFIFOProcess||, CODE, READONLY, ALIGN=1

                  LIME_UART_PROTOCOL_RxFIFOProcess PROC
;;;325    // 一级接收缓冲区处理，从一级接收缓冲区中取出一个字节添加到命令帧缓冲区中
;;;326    void LIME_UART_PROTOCOL_RxFIFOProcess(LIME_UART_PROTOCOL_CB *pCB)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;327    {
000004  4604              MOV      r4,r0
;;;328        uint16 end = pCB->rxFIFO.end;
000006  f8b480ca          LDRH     r8,[r4,#0xca]
;;;329        uint16 head = pCB->rxFIFO.head;
00000a  f8b490c8          LDRH     r9,[r4,#0xc8]
;;;330        LIME_UART_PROTOCOL_RX_CMD_FRAME *pCmdFrame = NULL;
00000e  2500              MOVS     r5,#0
;;;331        uint16 length = 0;
000010  2700              MOVS     r7,#0
;;;332        uint8 currentData = 0;
000012  2600              MOVS     r6,#0
;;;333    
;;;334        // 参数合法性检验
;;;335        if (NULL == pCB)
000014  b90c              CBNZ     r4,|L11.26|
                  |L11.22|
;;;336        {
;;;337            return;
;;;338        }
;;;339    
;;;340        // 一级缓冲区为空，退出
;;;341        if (head == end)
;;;342        {
;;;343            return;
;;;344        }
;;;345    
;;;346        // 获取临时缓冲区指针
;;;347        pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.end];
;;;348        // 取出当前要处理的字节
;;;349        currentData = pCB->rxFIFO.buff[pCB->rxFIFO.currentProcessIndex];
;;;350    
;;;351        // 临时缓冲区长度为0时，搜索首字节
;;;352        if (0 == pCmdFrame->length)
;;;353        {
;;;354            // 命令头错误，删除当前字节并退出
;;;355            if (LIME_UART_PROTOCOL_CMD_HEAD != currentData)
;;;356            {
;;;357                pCB->rxFIFO.head ++;
;;;358                pCB->rxFIFO.head %= LIME_UART_PROTOCOL_RX_FIFO_SIZE;
;;;359                pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;360    
;;;361                return;
;;;362            }
;;;363    
;;;364            // 命令头正确，但无临时缓冲区可用，退出
;;;365            if ((pCB->rx.end + 1) % LIME_UART_PROTOCOL_RX_QUEUE_SIZE == pCB->rx.head)
;;;366            {
;;;367                return;
;;;368            }
;;;369    
;;;370            // 添加UART通讯超时时间设置-2016.1.5增加
;;;371    #if LIME_UART_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;372            TIMER_AddTask(TIMER_ID_UART_RX_TIME_OUT_CONTROL,
;;;373                          LIME_UART_PROTOCOL_BUS_UNIDIRECTIONAL_TIME_OUT,
;;;374                          LIME_UART_PROTOCOL_CALLBACK_RxTimeOut,
;;;375                          0,
;;;376                          1,
;;;377                          ACTION_MODE_ADD_TO_QUEUE);
;;;378    #endif
;;;379    
;;;380            // 命令头正确，有临时缓冲区可用，则将其添加到命令帧临时缓冲区中
;;;381            pCmdFrame->buff[pCmdFrame->length++] = currentData;
;;;382            pCB->rxFIFO.currentProcessIndex ++;
;;;383            pCB->rxFIFO.currentProcessIndex %= LIME_UART_PROTOCOL_RX_FIFO_SIZE;
;;;384        }
;;;385        // 非首字节，将数据添加到命令帧临时缓冲区中，但暂不删除当前数据
;;;386        else
;;;387        {
;;;388            // 临时缓冲区溢出，说明当前正在接收的命令帧是错误的，正确的命令帧不会出现长度溢出的情况
;;;389            if (pCmdFrame->length >= LIME_UART_PROTOCOL_RX_CMD_FRAME_LENGTH_MAX)
;;;390            {
;;;391    #if LIME_UART_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;392                // 停止RX通讯超时检测
;;;393                LIME_UART_PROTOCOL_StopRxTimeOutCheck();
;;;394    #endif
;;;395    
;;;396                // 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;397                pCmdFrame->length = 0;  // 2016.1.5增加
;;;398                // 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;399                pCB->rxFIFO.head ++;
;;;400                pCB->rxFIFO.head %= LIME_UART_PROTOCOL_RX_FIFO_SIZE;
;;;401                pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;402    
;;;403                return;
;;;404            }
;;;405    
;;;406            // 一直取到末尾
;;;407            while (end != pCB->rxFIFO.currentProcessIndex)
;;;408            {
;;;409                // 取出当前要处理的字节
;;;410                currentData = pCB->rxFIFO.buff[pCB->rxFIFO.currentProcessIndex];
;;;411                // 缓冲区未溢出，正常接收，将数据添加到临时缓冲区中
;;;412                pCmdFrame->buff[pCmdFrame->length++] = currentData;
;;;413                pCB->rxFIFO.currentProcessIndex ++;
;;;414                pCB->rxFIFO.currentProcessIndex %= LIME_UART_PROTOCOL_RX_FIFO_SIZE;
;;;415    
;;;416                // ■■接下来，需要检查命令帧是否完整，如果完整，则将命令帧临时缓冲区扶正■■
;;;417    
;;;418                // 首先判断命令帧最小长度，一个完整的命令字至少包括10个字节,因此不足8个字节的必定不完整
;;;419                if (pCmdFrame->length < LIME_UART_PROTOCOL_CMD_FRAME_LENGTH_MIN)
;;;420                {
;;;421                    // 继续接收
;;;422                    continue;
;;;423                }
;;;424    
;;;425                // 命令帧长度数值越界，说明当前命令帧错误，停止接收
;;;426                length = ((uint16)pCmdFrame->buff[LIME_UART_PROTOCOL_CMD_LENGTH_H_INDEX] << 8) + pCmdFrame->buff[LIME_UART_PROTOCOL_CMD_LENGTH_L_INDEX];
;;;427                if (length > LIME_UART_PROTOCOL_RX_CMD_FRAME_LENGTH_MAX - LIME_UART_PROTOCOL_CMD_FRAME_LENGTH_MIN)
;;;428                {
;;;429    #if LIME_UART_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;430                    // 停止RX通讯超时检测
;;;431                    LIME_UART_PROTOCOL_StopRxTimeOutCheck();
;;;432    #endif
;;;433    
;;;434                    // 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;435                    pCmdFrame->length = 0;
;;;436                    // 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;437                    pCB->rxFIFO.head ++;
;;;438                    pCB->rxFIFO.head %= LIME_UART_PROTOCOL_RX_FIFO_SIZE;
;;;439                    pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;440    
;;;441                    return;
;;;442                }
;;;443    
;;;444                // 命令帧长度校验，在命令长度描述字的数值上，增加命令帧最小长度，即为命令帧实际长度
;;;445                if (pCmdFrame->length < (length + LIME_UART_PROTOCOL_CMD_FRAME_LENGTH_MIN))
;;;446                {
;;;447                    // 长度要求不一致，说明未接收完毕，退出继续
;;;448                    continue;
;;;449                }
;;;450    
;;;451                // 命令帧长度OK，则进行校验，失败时删除命令头
;;;452                if (!LIME_UART_PROTOCOL_CheckSUM(pCmdFrame))
;;;453                {
;;;454    #if LIME_UART_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;455                    // 停止RX通讯超时检测
;;;456                    LIME_UART_PROTOCOL_StopRxTimeOutCheck();
;;;457    #endif
;;;458    
;;;459                    // 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;460                    pCmdFrame->length = 0;
;;;461                    // 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;462                    pCB->rxFIFO.head ++;
;;;463                    pCB->rxFIFO.head %= LIME_UART_PROTOCOL_RX_FIFO_SIZE;
;;;464                    pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;465    
;;;466                    return;
;;;467                }
;;;468    
;;;469    #if LIME_UART_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;470                // 停止RX通讯超时检测
;;;471                LIME_UART_PROTOCOL_StopRxTimeOutCheck();
;;;472    #endif
;;;473                length = pCmdFrame->length;
;;;474                // 执行到这里，即说明接收到了一个完整并且正确的命令帧，此时需将处理过的数据从一级缓冲区中删除，并将该命令帧扶正
;;;475                pCB->rxFIFO.head += length;
;;;476                pCB->rxFIFO.head %= LIME_UART_PROTOCOL_RX_FIFO_SIZE;
;;;477                pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;478                LIME_UART_PROTOCOL_ConfirmTempCmdFrameBuff(pCB);
;;;479    
;;;480                return;
;;;481            }
;;;482        }
;;;483    }
000016  e8bd83f0          POP      {r4-r9,pc}
                  |L11.26|
00001a  45c1              CMP      r9,r8                 ;341
00001c  d100              BNE      |L11.32|
00001e  e7fa              B        |L11.22|
                  |L11.32|
000020  f8b40360          LDRH     r0,[r4,#0x360]        ;347
000024  eb0001c0          ADD      r1,r0,r0,LSL #3       ;347
000028  eb011140          ADD      r1,r1,r0,LSL #5       ;347
00002c  f10400ce          ADD      r0,r4,#0xce           ;347
000030  eb000581          ADD      r5,r0,r1,LSL #2       ;347
000034  f8b400cc          LDRH     r0,[r4,#0xcc]         ;349
000038  5c26              LDRB     r6,[r4,r0]            ;349
00003a  f8b500a2          LDRH     r0,[r5,#0xa2]         ;352
00003e  bb98              CBNZ     r0,|L11.168|
000040  2e4c              CMP      r6,#0x4c              ;355
000042  d00e              BEQ      |L11.98|
000044  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;357
000048  1c40              ADDS     r0,r0,#1              ;357
00004a  8020              STRH     r0,[r4,#0]            ;357
00004c  8820              LDRH     r0,[r4,#0]            ;358
00004e  21c8              MOVS     r1,#0xc8              ;358
000050  fb90f2f1          SDIV     r2,r0,r1              ;358
000054  fb010012          MLS      r0,r1,r2,r0           ;358
000058  8020              STRH     r0,[r4,#0]            ;358
00005a  8820              LDRH     r0,[r4,#0]            ;359
00005c  80a0              STRH     r0,[r4,#4]            ;359
00005e  3cc8              SUBS     r4,r4,#0xc8           ;359
000060  e7d9              B        |L11.22|
                  |L11.98|
000062  f8b41360          LDRH     r1,[r4,#0x360]        ;365
000066  1c48              ADDS     r0,r1,#1              ;365
000068  17c1              ASRS     r1,r0,#31             ;365
00006a  eb007191          ADD      r1,r0,r1,LSR #30      ;365
00006e  1089              ASRS     r1,r1,#2              ;365
000070  eba00281          SUB      r2,r0,r1,LSL #2       ;365
000074  f8b4135e          LDRH     r1,[r4,#0x35e]        ;365
000078  428a              CMP      r2,r1                 ;365
00007a  d100              BNE      |L11.126|
00007c  e7cb              B        |L11.22|
                  |L11.126|
00007e  f8351fa2          LDRH     r1,[r5,#0xa2]!        ;381
000082  8828              LDRH     r0,[r5,#0]            ;381
000084  1c40              ADDS     r0,r0,#1              ;381
000086  f82509a2          STRH     r0,[r5],#-0xa2        ;381
00008a  1ca8              ADDS     r0,r5,#2              ;381
00008c  5446              STRB     r6,[r0,r1]            ;381
00008e  f8340fcc          LDRH     r0,[r4,#0xcc]!        ;382
000092  1c40              ADDS     r0,r0,#1              ;382
000094  8020              STRH     r0,[r4,#0]            ;382
000096  8820              LDRH     r0,[r4,#0]            ;383
000098  21c8              MOVS     r1,#0xc8              ;383
00009a  fb90f2f1          SDIV     r2,r0,r1              ;383
00009e  fb010012          MLS      r0,r1,r2,r0           ;383
0000a2  f82409cc          STRH     r0,[r4],#-0xcc        ;383
0000a6  e081              B        |L11.428|
                  |L11.168|
0000a8  e7ff              B        |L11.170|
                  |L11.170|
0000aa  f8b500a2          LDRH     r0,[r5,#0xa2]         ;389
0000ae  28a0              CMP      r0,#0xa0              ;389
0000b0  db11              BLT      |L11.214|
0000b2  2000              MOVS     r0,#0                 ;397
0000b4  f8a500a2          STRH     r0,[r5,#0xa2]         ;397
0000b8  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;399
0000bc  1c40              ADDS     r0,r0,#1              ;399
0000be  8020              STRH     r0,[r4,#0]            ;399
0000c0  8820              LDRH     r0,[r4,#0]            ;400
0000c2  21c8              MOVS     r1,#0xc8              ;400
0000c4  fb90f2f1          SDIV     r2,r0,r1              ;400
0000c8  fb010012          MLS      r0,r1,r2,r0           ;400
0000cc  8020              STRH     r0,[r4,#0]            ;400
0000ce  8820              LDRH     r0,[r4,#0]            ;401
0000d0  80a0              STRH     r0,[r4,#4]            ;401
0000d2  3cc8              SUBS     r4,r4,#0xc8           ;401
0000d4  e79f              B        |L11.22|
                  |L11.214|
0000d6  e065              B        |L11.420|
                  |L11.216|
0000d8  f8b400cc          LDRH     r0,[r4,#0xcc]         ;410
0000dc  5c26              LDRB     r6,[r4,r0]            ;410
0000de  f8351fa2          LDRH     r1,[r5,#0xa2]!        ;412
0000e2  8828              LDRH     r0,[r5,#0]            ;412
0000e4  1c40              ADDS     r0,r0,#1              ;412
0000e6  f82509a2          STRH     r0,[r5],#-0xa2        ;412
0000ea  1ca8              ADDS     r0,r5,#2              ;412
0000ec  5446              STRB     r6,[r0,r1]            ;412
0000ee  f8340fcc          LDRH     r0,[r4,#0xcc]!        ;413
0000f2  1c40              ADDS     r0,r0,#1              ;413
0000f4  8020              STRH     r0,[r4,#0]            ;413
0000f6  8820              LDRH     r0,[r4,#0]            ;414
0000f8  21c8              MOVS     r1,#0xc8              ;414
0000fa  fb90f2f1          SDIV     r2,r0,r1              ;414
0000fe  fb010012          MLS      r0,r1,r2,r0           ;414
000102  f82409cc          STRH     r0,[r4],#-0xcc        ;414
000106  f8b500a2          LDRH     r0,[r5,#0xa2]         ;419
00010a  280b              CMP      r0,#0xb               ;419
00010c  da00              BGE      |L11.272|
00010e  e049              B        |L11.420|
                  |L11.272|
000110  7ae9              LDRB     r1,[r5,#0xb]          ;426
000112  7aa8              LDRB     r0,[r5,#0xa]          ;426
000114  eb012000          ADD      r0,r1,r0,LSL #8       ;426
000118  b287              UXTH     r7,r0                 ;426
00011a  2f95              CMP      r7,#0x95              ;427
00011c  dd11              BLE      |L11.322|
00011e  2000              MOVS     r0,#0                 ;435
000120  f8a500a2          STRH     r0,[r5,#0xa2]         ;435
000124  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;437
000128  1c40              ADDS     r0,r0,#1              ;437
00012a  8020              STRH     r0,[r4,#0]            ;437
00012c  8820              LDRH     r0,[r4,#0]            ;438
00012e  21c8              MOVS     r1,#0xc8              ;438
000130  fb90f2f1          SDIV     r2,r0,r1              ;438
000134  fb010012          MLS      r0,r1,r2,r0           ;438
000138  8020              STRH     r0,[r4,#0]            ;438
00013a  8820              LDRH     r0,[r4,#0]            ;439
00013c  80a0              STRH     r0,[r4,#4]            ;439
00013e  3cc8              SUBS     r4,r4,#0xc8           ;439
000140  e769              B        |L11.22|
                  |L11.322|
000142  f8b510a2          LDRH     r1,[r5,#0xa2]         ;445
000146  f107000b          ADD      r0,r7,#0xb            ;445
00014a  4281              CMP      r1,r0                 ;445
00014c  da00              BGE      |L11.336|
00014e  e029              B        |L11.420|
                  |L11.336|
000150  4628              MOV      r0,r5                 ;452
000152  f7fffffe          BL       LIME_UART_PROTOCOL_CheckSUM
000156  b988              CBNZ     r0,|L11.380|
000158  2000              MOVS     r0,#0                 ;460
00015a  f8a500a2          STRH     r0,[r5,#0xa2]         ;460
00015e  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;462
000162  1c40              ADDS     r0,r0,#1              ;462
000164  8020              STRH     r0,[r4,#0]            ;462
000166  8820              LDRH     r0,[r4,#0]            ;463
000168  21c8              MOVS     r1,#0xc8              ;463
00016a  fb90f2f1          SDIV     r2,r0,r1              ;463
00016e  fb010012          MLS      r0,r1,r2,r0           ;463
000172  8020              STRH     r0,[r4,#0]            ;463
000174  8820              LDRH     r0,[r4,#0]            ;464
000176  80a0              STRH     r0,[r4,#4]            ;464
000178  3cc8              SUBS     r4,r4,#0xc8           ;464
00017a  e74c              B        |L11.22|
                  |L11.380|
00017c  f8b570a2          LDRH     r7,[r5,#0xa2]         ;473
000180  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;475
000184  4438              ADD      r0,r0,r7              ;475
000186  8020              STRH     r0,[r4,#0]            ;475
000188  8820              LDRH     r0,[r4,#0]            ;476
00018a  21c8              MOVS     r1,#0xc8              ;476
00018c  fb90f2f1          SDIV     r2,r0,r1              ;476
000190  fb010012          MLS      r0,r1,r2,r0           ;476
000194  8020              STRH     r0,[r4,#0]            ;476
000196  8820              LDRH     r0,[r4,#0]            ;477
000198  80a0              STRH     r0,[r4,#4]            ;477
00019a  3cc8              SUBS     r4,r4,#0xc8           ;477
00019c  4620              MOV      r0,r4                 ;478
00019e  f7fffffe          BL       LIME_UART_PROTOCOL_ConfirmTempCmdFrameBuff
0001a2  e738              B        |L11.22|
                  |L11.420|
0001a4  f8b400cc          LDRH     r0,[r4,#0xcc]         ;407
0001a8  4540              CMP      r0,r8                 ;407
0001aa  d195              BNE      |L11.216|
                  |L11.428|
0001ac  bf00              NOP      
0001ae  e732              B        |L11.22|
;;;484    
                          ENDP


                          AREA ||i.LIME_UART_PROTOCOL_Seg||, CODE, READONLY, ALIGN=1

                  LIME_UART_PROTOCOL_Seg PROC
;;;573    // 数码管显示
;;;574    void LIME_UART_PROTOCOL_Seg(uint32 cmd, uint16 d1, uint16 d2)
000000  b570              PUSH     {r4-r6,lr}
;;;575    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;576        LIME_UART_PROTOCOL_TxAddData(LIME_UART_PROTOCOL_CMD_HEAD1);
000008  204c              MOVS     r0,#0x4c
00000a  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;577        LIME_UART_PROTOCOL_TxAddData(LIME_UART_PROTOCOL_CMD_HEAD2);
00000e  2042              MOVS     r0,#0x42
000010  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;578        LIME_UART_PROTOCOL_TxAddData(LIME_UART_PROTOCOL_CMD_HEAD3);
000014  2044              MOVS     r0,#0x44
000016  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;579        LIME_UART_PROTOCOL_TxAddData(LIME_UART_PROTOCOL_CMD_HEAD4);
00001a  2043              MOVS     r0,#0x43
00001c  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;580        LIME_UART_PROTOCOL_TxAddData(LIME_UART_PROTOCOL_CMD_HEAD5);
000020  2050              MOVS     r0,#0x50
000022  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;581        LIME_UART_PROTOCOL_TxAddData(LIME_UART_PROTOCOL_CMD_PROTOCOL_VERSION);
000026  2001              MOVS     r0,#1
000028  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;582        LIME_UART_PROTOCOL_TxAddData(LIME_UART_PROTOCOL_CMD_DEVICE_ADDR);
00002c  2010              MOVS     r0,#0x10
00002e  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;583        LIME_UART_PROTOCOL_TxAddData(cmd);
000032  b2e0              UXTB     r0,r4
000034  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;584        LIME_UART_PROTOCOL_TxAddData(0);
000038  2000              MOVS     r0,#0
00003a  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;585        LIME_UART_PROTOCOL_TxAddData(2);
00003e  2002              MOVS     r0,#2
000040  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;586    
;;;587        // 写入字节数
;;;588        LIME_UART_PROTOCOL_TxAddData(d1);
000044  b2e8              UXTB     r0,r5
000046  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;589        LIME_UART_PROTOCOL_TxAddData(d2);
00004a  b2f0              UXTB     r0,r6
00004c  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;590    
;;;591        LIME_UART_PROTOCOL_TxAddFrame();
000050  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddFrame
;;;592    }
000054  bd70              POP      {r4-r6,pc}
;;;593    
                          ENDP


                          AREA ||i.LIME_UART_PROTOCOL_SendCmd||, CODE, READONLY, ALIGN=1

                  LIME_UART_PROTOCOL_SendCmd PROC
;;;770    // 发送命令字
;;;771    void LIME_UART_PROTOCOL_SendCmd(uint32 sndCmd)
000000  b510              PUSH     {r4,lr}
;;;772    {
000002  4604              MOV      r4,r0
;;;773        LIME_UART_PROTOCOL_TxAddData(LIME_UART_PROTOCOL_CMD_HEAD1);
000004  204c              MOVS     r0,#0x4c
000006  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;774        LIME_UART_PROTOCOL_TxAddData(LIME_UART_PROTOCOL_CMD_HEAD2);
00000a  2042              MOVS     r0,#0x42
00000c  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;775        LIME_UART_PROTOCOL_TxAddData(LIME_UART_PROTOCOL_CMD_HEAD3);
000010  2044              MOVS     r0,#0x44
000012  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;776        LIME_UART_PROTOCOL_TxAddData(LIME_UART_PROTOCOL_CMD_HEAD4);
000016  2043              MOVS     r0,#0x43
000018  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;777        LIME_UART_PROTOCOL_TxAddData(LIME_UART_PROTOCOL_CMD_HEAD5);
00001c  2050              MOVS     r0,#0x50
00001e  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;778        LIME_UART_PROTOCOL_TxAddData(LIME_UART_PROTOCOL_CMD_PROTOCOL_VERSION);
000022  2001              MOVS     r0,#1
000024  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;779        LIME_UART_PROTOCOL_TxAddData(LIME_UART_PROTOCOL_CMD_DEVICE_ADDR);
000028  2010              MOVS     r0,#0x10
00002a  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;780        LIME_UART_PROTOCOL_TxAddData((uint8)sndCmd);
00002e  b2e0              UXTB     r0,r4
000030  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;781        LIME_UART_PROTOCOL_TxAddData(0);
000034  2000              MOVS     r0,#0
000036  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;782        LIME_UART_PROTOCOL_TxAddData(0);
00003a  2000              MOVS     r0,#0
00003c  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;783        LIME_UART_PROTOCOL_TxAddFrame();
000040  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddFrame
;;;784    }
000044  bd10              POP      {r4,pc}
;;;785    
                          ENDP


                          AREA ||i.LIME_UART_PROTOCOL_SendCmdAck||, CODE, READONLY, ALIGN=1

                  LIME_UART_PROTOCOL_SendCmdAck PROC
;;;532    // 上报命令应答
;;;533    void LIME_UART_PROTOCOL_SendCmdAck(uint32 cmd)
000000  b510              PUSH     {r4,lr}
;;;534    {
000002  4604              MOV      r4,r0
;;;535        LIME_UART_PROTOCOL_TxAddData(LIME_UART_PROTOCOL_CMD_HEAD1);
000004  204c              MOVS     r0,#0x4c
000006  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;536        LIME_UART_PROTOCOL_TxAddData(LIME_UART_PROTOCOL_CMD_HEAD2);
00000a  2042              MOVS     r0,#0x42
00000c  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;537        LIME_UART_PROTOCOL_TxAddData(LIME_UART_PROTOCOL_CMD_HEAD3);
000010  2044              MOVS     r0,#0x44
000012  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;538        LIME_UART_PROTOCOL_TxAddData(LIME_UART_PROTOCOL_CMD_HEAD4);
000016  2043              MOVS     r0,#0x43
000018  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;539        LIME_UART_PROTOCOL_TxAddData(LIME_UART_PROTOCOL_CMD_HEAD5);
00001c  2050              MOVS     r0,#0x50
00001e  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;540        LIME_UART_PROTOCOL_TxAddData(LIME_UART_PROTOCOL_CMD_PROTOCOL_VERSION);
000022  2001              MOVS     r0,#1
000024  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;541        LIME_UART_PROTOCOL_TxAddData(LIME_UART_PROTOCOL_CMD_DEVICE_ADDR);
000028  2010              MOVS     r0,#0x10
00002a  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;542        LIME_UART_PROTOCOL_TxAddData(cmd);
00002e  b2e0              UXTB     r0,r4
000030  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;543        LIME_UART_PROTOCOL_TxAddData(0);
000034  2000              MOVS     r0,#0
000036  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;544        LIME_UART_PROTOCOL_TxAddData(0);
00003a  2000              MOVS     r0,#0
00003c  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;545    
;;;546        LIME_UART_PROTOCOL_TxAddFrame();
000040  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddFrame
;;;547    }
000044  bd10              POP      {r4,pc}
;;;548    
                          ENDP


                          AREA ||i.LIME_UART_PROTOCOL_SendCmdParamAck||, CODE, READONLY, ALIGN=1

                  LIME_UART_PROTOCOL_SendCmdParamAck PROC
;;;751    // 发送命令字及回复一个字节
;;;752    void LIME_UART_PROTOCOL_SendCmdParamAck(uint8 ackCmd, uint8 ackParam)
000000  b530              PUSH     {r4,r5,lr}
;;;753    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;754        LIME_UART_PROTOCOL_TxAddData(LIME_UART_PROTOCOL_CMD_HEAD1);
000006  204c              MOVS     r0,#0x4c
000008  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;755        LIME_UART_PROTOCOL_TxAddData(LIME_UART_PROTOCOL_CMD_HEAD2);
00000c  2042              MOVS     r0,#0x42
00000e  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;756        LIME_UART_PROTOCOL_TxAddData(LIME_UART_PROTOCOL_CMD_HEAD3);
000012  2044              MOVS     r0,#0x44
000014  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;757        LIME_UART_PROTOCOL_TxAddData(LIME_UART_PROTOCOL_CMD_HEAD4);
000018  2043              MOVS     r0,#0x43
00001a  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;758        LIME_UART_PROTOCOL_TxAddData(LIME_UART_PROTOCOL_CMD_HEAD5);
00001e  2050              MOVS     r0,#0x50
000020  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;759        LIME_UART_PROTOCOL_TxAddData(LIME_UART_PROTOCOL_CMD_PROTOCOL_VERSION);
000024  2001              MOVS     r0,#1
000026  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;760        LIME_UART_PROTOCOL_TxAddData(LIME_UART_PROTOCOL_CMD_DEVICE_ADDR);
00002a  2010              MOVS     r0,#0x10
00002c  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;761        LIME_UART_PROTOCOL_TxAddData((uint8)ackCmd);
000030  4628              MOV      r0,r5
000032  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;762        LIME_UART_PROTOCOL_TxAddData(0);
000036  2000              MOVS     r0,#0
000038  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;763        LIME_UART_PROTOCOL_TxAddData(2);
00003c  2002              MOVS     r0,#2
00003e  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;764        LIME_UART_PROTOCOL_TxAddData(1);
000042  2001              MOVS     r0,#1
000044  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;765        LIME_UART_PROTOCOL_TxAddData(ackParam);
000048  4620              MOV      r0,r4
00004a  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;766    
;;;767        LIME_UART_PROTOCOL_TxAddFrame();
00004e  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddFrame
;;;768    }
000052  bd30              POP      {r4,r5,pc}
;;;769    
                          ENDP


                          AREA ||i.LIME_UART_PROTOCOL_SendCmdResult||, CODE, READONLY, ALIGN=1

                  LIME_UART_PROTOCOL_SendCmdResult PROC
;;;508    // 上报命令执行结果
;;;509    void LIME_UART_PROTOCOL_SendCmdResult(uint32 cmd, uint32 param)
000000  b530              PUSH     {r4,r5,lr}
;;;510    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;511        LIME_UART_PROTOCOL_TxAddData(LIME_UART_PROTOCOL_CMD_HEAD1);
000006  204c              MOVS     r0,#0x4c
000008  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;512        LIME_UART_PROTOCOL_TxAddData(LIME_UART_PROTOCOL_CMD_HEAD2);
00000c  2042              MOVS     r0,#0x42
00000e  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;513        LIME_UART_PROTOCOL_TxAddData(LIME_UART_PROTOCOL_CMD_HEAD3);
000012  2044              MOVS     r0,#0x44
000014  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;514        LIME_UART_PROTOCOL_TxAddData(LIME_UART_PROTOCOL_CMD_HEAD4);
000018  2043              MOVS     r0,#0x43
00001a  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;515        LIME_UART_PROTOCOL_TxAddData(LIME_UART_PROTOCOL_CMD_HEAD5);
00001e  2050              MOVS     r0,#0x50
000020  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;516        LIME_UART_PROTOCOL_TxAddData(LIME_UART_PROTOCOL_CMD_PROTOCOL_VERSION);
000024  2001              MOVS     r0,#1
000026  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;517        LIME_UART_PROTOCOL_TxAddData(LIME_UART_PROTOCOL_CMD_DEVICE_ADDR);
00002a  2010              MOVS     r0,#0x10
00002c  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;518        LIME_UART_PROTOCOL_TxAddData(cmd);
000030  b2e0              UXTB     r0,r4
000032  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;519        LIME_UART_PROTOCOL_TxAddData(0);
000036  2000              MOVS     r0,#0
000038  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;520        LIME_UART_PROTOCOL_TxAddData(2);
00003c  2002              MOVS     r0,#2
00003e  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;521    
;;;522        // 写入字节数
;;;523        LIME_UART_PROTOCOL_TxAddData(1);
000042  2001              MOVS     r0,#1
000044  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;524    
;;;525        // 写入结果
;;;526        LIME_UART_PROTOCOL_TxAddData((uint8)param);
000048  b2e8              UXTB     r0,r5
00004a  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;527    
;;;528        LIME_UART_PROTOCOL_TxAddFrame();
00004e  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddFrame
;;;529    }
000052  bd30              POP      {r4,r5,pc}
;;;530    
                          ENDP


                          AREA ||i.LIME_UART_PROTOCOL_SendCmdWriteResult||, CODE, READONLY, ALIGN=1

                  LIME_UART_PROTOCOL_SendCmdWriteResult PROC
;;;549    // 上报模块写入结果
;;;550    void LIME_UART_PROTOCOL_SendCmdWriteResult(uint32 cmd, uint16 byteNum, uint32 exeResoult)
000000  b5f0              PUSH     {r4-r7,lr}
;;;551    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4617              MOV      r7,r2
;;;552        LIME_UART_PROTOCOL_TxAddData(LIME_UART_PROTOCOL_CMD_HEAD1);
000008  204c              MOVS     r0,#0x4c
00000a  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;553        LIME_UART_PROTOCOL_TxAddData(LIME_UART_PROTOCOL_CMD_HEAD2);
00000e  2042              MOVS     r0,#0x42
000010  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;554        LIME_UART_PROTOCOL_TxAddData(LIME_UART_PROTOCOL_CMD_HEAD3);
000014  2044              MOVS     r0,#0x44
000016  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;555        LIME_UART_PROTOCOL_TxAddData(LIME_UART_PROTOCOL_CMD_HEAD4);
00001a  2043              MOVS     r0,#0x43
00001c  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;556        LIME_UART_PROTOCOL_TxAddData(LIME_UART_PROTOCOL_CMD_HEAD5);
000020  2050              MOVS     r0,#0x50
000022  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;557        LIME_UART_PROTOCOL_TxAddData(LIME_UART_PROTOCOL_CMD_PROTOCOL_VERSION);
000026  2001              MOVS     r0,#1
000028  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;558        LIME_UART_PROTOCOL_TxAddData(LIME_UART_PROTOCOL_CMD_DEVICE_ADDR);
00002c  2010              MOVS     r0,#0x10
00002e  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;559        LIME_UART_PROTOCOL_TxAddData(cmd);
000032  b2f0              UXTB     r0,r6
000034  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;560        LIME_UART_PROTOCOL_TxAddData(0);
000038  2000              MOVS     r0,#0
00003a  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;561        LIME_UART_PROTOCOL_TxAddData(2);
00003e  2002              MOVS     r0,#2
000040  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;562    
;;;563        // 写入字节数
;;;564        LIME_UART_PROTOCOL_TxAddData(byteNum / 256);
000044  4625              MOV      r5,r4
000046  17e1              ASRS     r1,r4,#31
000048  eb046111          ADD      r1,r4,r1,LSR #24
00004c  f3c12007          UBFX     r0,r1,#8,#8
000050  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;565        LIME_UART_PROTOCOL_TxAddData(byteNum % 256);
000054  17e1              ASRS     r1,r4,#31
000056  eb046111          ADD      r1,r4,r1,LSR #24
00005a  1209              ASRS     r1,r1,#8
00005c  eba42101          SUB      r1,r4,r1,LSL #8
000060  b2c8              UXTB     r0,r1
000062  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;566    
;;;567        // 写入结果
;;;568        LIME_UART_PROTOCOL_TxAddData((uint8)exeResoult);
000066  b2f8              UXTB     r0,r7
000068  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddData
;;;569    
;;;570        LIME_UART_PROTOCOL_TxAddFrame();
00006c  f7fffffe          BL       LIME_UART_PROTOCOL_TxAddFrame
;;;571    }
000070  bdf0              POP      {r4-r7,pc}
;;;572    
                          ENDP


                          AREA ||i.LIME_UART_PROTOCOL_SetTxAtOnceRequest||, CODE, READONLY, ALIGN=2

                  LIME_UART_PROTOCOL_SetTxAtOnceRequest PROC
;;;739    // 码表设置立刻下发数据请求标志
;;;740    void LIME_UART_PROTOCOL_SetTxAtOnceRequest(uint32 param)
000000  4a01              LDR      r2,|L18.8|
;;;741    {
;;;742        uartProtocolCB4.txAtOnceRequest = (BOOL)param;
000002  f8820601          STRB     r0,[r2,#0x601]
;;;743    }
000006  4770              BX       lr
;;;744    
                          ENDP

                  |L18.8|
                          DCD      uartProtocolCB4

                          AREA ||i.LIME_UART_PROTOCOL_TxAddData||, CODE, READONLY, ALIGN=2

                  LIME_UART_PROTOCOL_TxAddData PROC
;;;136    // 向发送命令帧队列中添加数据
;;;137    void LIME_UART_PROTOCOL_TxAddData(uint8 data)
000000  b530              PUSH     {r4,r5,lr}
;;;138    {
000002  4602              MOV      r2,r0
;;;139        uint16 head = uartProtocolCB4.tx.head;
000004  4913              LDR      r1,|L19.84|
000006  f8b135f2          LDRH     r3,[r1,#0x5f2]
;;;140        uint16 end =  uartProtocolCB4.tx.end;
00000a  f8b145f4          LDRH     r4,[r1,#0x5f4]
;;;141        LIME_UART_PROTOCOL_TX_CMD_FRAME *pCmdFrame = &uartProtocolCB4.tx.cmdQueue[uartProtocolCB4.tx.end];
00000e  f8b115f4          LDRH     r1,[r1,#0x5f4]
000012  eb0105c1          ADD      r5,r1,r1,LSL #3
000016  eb051541          ADD      r5,r5,r1,LSL #5
00001a  490f              LDR      r1,|L19.88|
00001c  eb010085          ADD      r0,r1,r5,LSL #2
;;;142    
;;;143        // 发送缓冲区已满，不予接收
;;;144        if ((end + 1) % LIME_UART_PROTOCOL_TX_QUEUE_SIZE == head)
000020  1c61              ADDS     r1,r4,#1
000022  17cd              ASRS     r5,r1,#31
000024  eb017595          ADD      r5,r1,r5,LSR #30
000028  10ad              ASRS     r5,r5,#2
00002a  eba10585          SUB      r5,r1,r5,LSL #2
00002e  429d              CMP      r5,r3
000030  d100              BNE      |L19.52|
                  |L19.50|
;;;145        {
;;;146            return;
;;;147        }
;;;148    
;;;149        // 队尾命令帧已满，退出
;;;150        if (pCmdFrame->length >= LIME_UART_PROTOCOL_TX_CMD_FRAME_LENGTH_MAX)
;;;151        {
;;;152            return;
;;;153        }
;;;154    
;;;155        // 数据添加到帧末尾，并更新帧长度
;;;156        pCmdFrame->buff[pCmdFrame->length] = data;
;;;157        pCmdFrame->length ++;
;;;158    }
000032  bd30              POP      {r4,r5,pc}
                  |L19.52|
000034  f8b010a2          LDRH     r1,[r0,#0xa2]         ;150
000038  29a0              CMP      r1,#0xa0              ;150
00003a  db00              BLT      |L19.62|
00003c  e7f9              B        |L19.50|
                  |L19.62|
00003e  f8b050a2          LDRH     r5,[r0,#0xa2]         ;156
000042  1c81              ADDS     r1,r0,#2              ;156
000044  554a              STRB     r2,[r1,r5]            ;156
000046  f8b010a2          LDRH     r1,[r0,#0xa2]         ;157
00004a  1c49              ADDS     r1,r1,#1              ;157
00004c  f8a010a2          STRH     r1,[r0,#0xa2]         ;157
000050  bf00              NOP      
000052  e7ee              B        |L19.50|
;;;159    
                          ENDP

                  |L19.84|
                          DCD      uartProtocolCB4
                  |L19.88|
                          DCD      uartProtocolCB4+0x362

                          AREA ||i.LIME_UART_PROTOCOL_TxAddFrame||, CODE, READONLY, ALIGN=2

                  LIME_UART_PROTOCOL_TxAddFrame PROC
;;;160    // 确认添加命令帧，即承认之前填充的数据为命令帧，将其添加到发送队列中，由main进行调度发送，本函数内会自动校正命令长度，并添加校验码
;;;161    void LIME_UART_PROTOCOL_TxAddFrame(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;162    {
;;;163        uint8 cc = 0;
000004  2600              MOVS     r6,#0
;;;164        uint16 head = uartProtocolCB4.tx.head;
000006  4828              LDR      r0,|L20.168|
000008  f8b075f2          LDRH     r7,[r0,#0x5f2]
;;;165        uint16 end  = uartProtocolCB4.tx.end;
00000c  f8b085f4          LDRH     r8,[r0,#0x5f4]
;;;166        LIME_UART_PROTOCOL_TX_CMD_FRAME *pCmdFrame = &uartProtocolCB4.tx.cmdQueue[uartProtocolCB4.tx.end];
000010  f8b005f4          LDRH     r0,[r0,#0x5f4]
000014  eb0001c0          ADD      r1,r0,r0,LSL #3
000018  eb011140          ADD      r1,r1,r0,LSL #5
00001c  4823              LDR      r0,|L20.172|
00001e  eb000481          ADD      r4,r0,r1,LSL #2
;;;167        uint16 length = pCmdFrame->length;
000022  f8b450a2          LDRH     r5,[r4,#0xa2]
;;;168    
;;;169        // 发送缓冲区已满，不予接收
;;;170        if ((end + 1) % LIME_UART_PROTOCOL_TX_QUEUE_SIZE == head)
000026  f1080001          ADD      r0,r8,#1
00002a  17c1              ASRS     r1,r0,#31
00002c  eb007191          ADD      r1,r0,r1,LSR #30
000030  1089              ASRS     r1,r1,#2
000032  eba00181          SUB      r1,r0,r1,LSL #2
000036  42b9              CMP      r1,r7
000038  d101              BNE      |L20.62|
                  |L20.58|
;;;171        {
;;;172            return;
;;;173        }
;;;174    
;;;175        // 命令帧长度不足，清除已填充的数据，退出
;;;176        if (LIME_UART_PROTOCOL_CMD_FRAME_LENGTH_MIN - 1 > length) // 减去"校验码"1个字节
;;;177        {
;;;178            pCmdFrame->length = 0;
;;;179    
;;;180            return;
;;;181        }
;;;182    
;;;183        // 队尾命令帧已满，退出
;;;184        if (length >= LIME_UART_PROTOCOL_TX_CMD_FRAME_LENGTH_MAX)
;;;185        {
;;;186            return;
;;;187        }
;;;188    
;;;189        // 重新设置数据长度，系统在准备数据时，填充的"数据长度"可以为任意值，并且不需要添加校验码，在这里重新设置为正确的值
;;;190        // 重设数据长度，需要减去10=(5同步头+1协议版本+1设备号+1命令字+2数据长度)
;;;191        pCmdFrame->buff[LIME_UART_PROTOCOL_CMD_LENGTH_H_INDEX] = ((length - 10) & 0xFF00) >> 8;
;;;192        pCmdFrame->buff[LIME_UART_PROTOCOL_CMD_LENGTH_L_INDEX] = ((length - 10) & 0x00FF);
;;;193    
;;;194        cc = UART_GetCRCValue(&pCmdFrame->buff[LIME_UART_PROTOCOL_CMD_VERSION_INDEX], (pCmdFrame->length - LIME_UART_PROTOCOL_HEAD_BYTE));
;;;195        pCmdFrame->buff[length] = cc;
;;;196        pCmdFrame->length ++;
;;;197    
;;;198        uartProtocolCB4.tx.end ++;
;;;199        uartProtocolCB4.tx.end %= LIME_UART_PROTOCOL_TX_QUEUE_SIZE;
;;;200        //pCB->tx.cmdQueue[pCB->tx.end].length = 0;   //2015.12.2修改
;;;201    }
00003a  e8bd81f0          POP      {r4-r8,pc}
                  |L20.62|
00003e  2d0a              CMP      r5,#0xa               ;176
000040  da03              BGE      |L20.74|
000042  2000              MOVS     r0,#0                 ;178
000044  f8a400a2          STRH     r0,[r4,#0xa2]         ;178
000048  e7f7              B        |L20.58|
                  |L20.74|
00004a  2da0              CMP      r5,#0xa0              ;184
00004c  db00              BLT      |L20.80|
00004e  e7f4              B        |L20.58|
                  |L20.80|
000050  f1a5000a          SUB      r0,r5,#0xa            ;191
000054  0a01              LSRS     r1,r0,#8              ;191
000056  72a1              STRB     r1,[r4,#0xa]          ;191
000058  72e0              STRB     r0,[r4,#0xb]          ;192
00005a  f8b400a2          LDRH     r0,[r4,#0xa2]         ;194
00005e  1f40              SUBS     r0,r0,#5              ;194
000060  b281              UXTH     r1,r0                 ;194
000062  1de0              ADDS     r0,r4,#7              ;194
000064  f7fffffe          BL       UART_GetCRCValue
000068  4606              MOV      r6,r0                 ;194
00006a  1ca0              ADDS     r0,r4,#2              ;195
00006c  5546              STRB     r6,[r0,r5]            ;195
00006e  f8b400a2          LDRH     r0,[r4,#0xa2]         ;196
000072  1c40              ADDS     r0,r0,#1              ;196
000074  f8a400a2          STRH     r0,[r4,#0xa2]         ;196
000078  480b              LDR      r0,|L20.168|
00007a  f8b005f4          LDRH     r0,[r0,#0x5f4]        ;198
00007e  1c40              ADDS     r0,r0,#1              ;198
000080  b281              UXTH     r1,r0                 ;198
000082  4809              LDR      r0,|L20.168|
000084  f8a015f4          STRH     r1,[r0,#0x5f4]        ;198
000088  4601              MOV      r1,r0                 ;199
00008a  f8b105f4          LDRH     r0,[r1,#0x5f4]        ;199
00008e  17c1              ASRS     r1,r0,#31             ;199
000090  eb007191          ADD      r1,r0,r1,LSR #30      ;199
000094  1089              ASRS     r1,r1,#2              ;199
000096  eba00181          SUB      r1,r0,r1,LSL #2       ;199
00009a  b28a              UXTH     r2,r1                 ;199
00009c  4902              LDR      r1,|L20.168|
00009e  f8a125f4          STRH     r2,[r1,#0x5f4]        ;199
0000a2  bf00              NOP      
0000a4  e7c9              B        |L20.58|
;;;202    
                          ENDP

0000a6  0000              DCW      0x0000
                  |L20.168|
                          DCD      uartProtocolCB4
                  |L20.172|
                          DCD      uartProtocolCB4+0x362

                          AREA ||i.LIME_UART_PROTOCOL_TxStateProcess||, CODE, READONLY, ALIGN=2

                  LIME_UART_PROTOCOL_TxStateProcess PROC
;;;292    // 协议层发送处理过程
;;;293    void LIME_UART_PROTOCOL_TxStateProcess(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;294    {
;;;295        uint16 head = uartProtocolCB4.tx.head;
000004  4827              LDR      r0,|L21.164|
000006  f8b045f2          LDRH     r4,[r0,#0x5f2]
;;;296        uint16 end =  uartProtocolCB4.tx.end;
00000a  f8b055f4          LDRH     r5,[r0,#0x5f4]
;;;297        uint16 length = uartProtocolCB4.tx.cmdQueue[head].length;
00000e  eb0400c4          ADD      r0,r4,r4,LSL #3
000012  eb001144          ADD      r1,r0,r4,LSL #5
000016  4824              LDR      r0,|L21.168|
000018  eb000081          ADD      r0,r0,r1,LSL #2
00001c  f8b060a2          LDRH     r6,[r0,#0xa2]
;;;298        uint8 *pCmd = uartProtocolCB4.tx.cmdQueue[head].buff;
000020  eb0400c4          ADD      r0,r4,r4,LSL #3
000024  eb001144          ADD      r1,r0,r4,LSL #5
000028  481f              LDR      r0,|L21.168|
00002a  eb000081          ADD      r0,r0,r1,LSL #2
00002e  1c87              ADDS     r7,r0,#2
;;;299        uint16 localDeviceID = uartProtocolCB4.tx.cmdQueue[head].deviceID;
000030  eb0400c4          ADD      r0,r4,r4,LSL #3
000034  eb001144          ADD      r1,r0,r4,LSL #5
000038  481b              LDR      r0,|L21.168|
00003a  f8308021          LDRH     r8,[r0,r1,LSL #2]
;;;300    
;;;301        // 发送缓冲区为空，说明无数据
;;;302        if (head == end)
00003e  42ac              CMP      r4,r5
000040  d101              BNE      |L21.70|
                  |L21.66|
;;;303        {
;;;304            return;
;;;305        }
;;;306    
;;;307        // 发送函数没有注册直接返回
;;;308        if (NULL == uartProtocolCB4.sendDataThrowService)
;;;309        {
;;;310            return;
;;;311        }
;;;312    
;;;313        // 协议层有数据需要发送到驱动层
;;;314        if (!(*uartProtocolCB4.sendDataThrowService)(localDeviceID, pCmd, length))
;;;315        {
;;;316            return;
;;;317        }
;;;318    
;;;319        // 发送环形队列更新位置
;;;320        uartProtocolCB4.tx.cmdQueue[head].length = 0;
;;;321        uartProtocolCB4.tx.head ++;
;;;322        uartProtocolCB4.tx.head %= LIME_UART_PROTOCOL_TX_QUEUE_SIZE;
;;;323    }
000042  e8bd81f0          POP      {r4-r8,pc}
                  |L21.70|
000046  4817              LDR      r0,|L21.164|
000048  f8d005fc          LDR      r0,[r0,#0x5fc]        ;308  ; uartProtocolCB4
00004c  b900              CBNZ     r0,|L21.80|
00004e  e7f8              B        |L21.66|
                  |L21.80|
000050  4814              LDR      r0,|L21.164|
000052  4632              MOV      r2,r6                 ;314
000054  4639              MOV      r1,r7                 ;314
000056  f8d035fc          LDR      r3,[r0,#0x5fc]        ;314  ; uartProtocolCB4
00005a  4640              MOV      r0,r8                 ;314
00005c  4798              BLX      r3                    ;314
00005e  b900              CBNZ     r0,|L21.98|
000060  e7ef              B        |L21.66|
                  |L21.98|
000062  2100              MOVS     r1,#0                 ;320
000064  eb0400c4          ADD      r0,r4,r4,LSL #3       ;320
000068  eb001244          ADD      r2,r0,r4,LSL #5       ;320
00006c  480e              LDR      r0,|L21.168|
00006e  eb000082          ADD      r0,r0,r2,LSL #2       ;320
000072  f8a010a2          STRH     r1,[r0,#0xa2]         ;320
000076  480b              LDR      r0,|L21.164|
000078  f8b005f2          LDRH     r0,[r0,#0x5f2]        ;321
00007c  1c40              ADDS     r0,r0,#1              ;321
00007e  b281              UXTH     r1,r0                 ;321
000080  4808              LDR      r0,|L21.164|
000082  f8a015f2          STRH     r1,[r0,#0x5f2]        ;321
000086  4601              MOV      r1,r0                 ;322
000088  f8b105f2          LDRH     r0,[r1,#0x5f2]        ;322
00008c  17c1              ASRS     r1,r0,#31             ;322
00008e  eb007191          ADD      r1,r0,r1,LSR #30      ;322
000092  1089              ASRS     r1,r1,#2              ;322
000094  eba00181          SUB      r1,r0,r1,LSL #2       ;322
000098  b28a              UXTH     r2,r1                 ;322
00009a  4902              LDR      r1,|L21.164|
00009c  f8a125f2          STRH     r2,[r1,#0x5f2]        ;322
0000a0  bf00              NOP      
0000a2  e7ce              B        |L21.66|
;;;324    
                          ENDP

                  |L21.164|
                          DCD      uartProtocolCB4
                  |L21.168|
                          DCD      uartProtocolCB4+0x362

                          AREA ||i.UART_GetCRCValue||, CODE, READONLY, ALIGN=1

                  UART_GetCRCValue PROC
;;;82     // use the crc8
;;;83     uint8 UART_GetCRCValue(uint8 *ptr, uint16 len)
000000  b530              PUSH     {r4,r5,lr}
;;;84     {
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;85         uint8 crc;
;;;86         uint8 i;
;;;87     
;;;88         crc = 0;
000006  2000              MOVS     r0,#0
;;;89     
;;;90         while (len--)
000008  e010              B        |L22.44|
                  |L22.10|
;;;91         {
;;;92             crc ^= *ptr++;
00000a  f8124b01          LDRB     r4,[r2],#1
00000e  4060              EORS     r0,r0,r4
;;;93     
;;;94             for (i = 0; i < 8; i++)
000010  2100              MOVS     r1,#0
000012  e009              B        |L22.40|
                  |L22.20|
;;;95             {
;;;96                 if (crc & 0x01)
000014  f0000401          AND      r4,r0,#1
000018  b11c              CBZ      r4,|L22.34|
;;;97                 {
;;;98                     crc = (crc >> 1) ^ 0x8C;
00001a  248c              MOVS     r4,#0x8c
00001c  ea840060          EOR      r0,r4,r0,ASR #1
000020  e000              B        |L22.36|
                  |L22.34|
;;;99                 }
;;;100                else
;;;101                {
;;;102                    crc >>= 1;
000022  1040              ASRS     r0,r0,#1
                  |L22.36|
000024  1c4c              ADDS     r4,r1,#1              ;94
000026  b2e1              UXTB     r1,r4                 ;94
                  |L22.40|
000028  2908              CMP      r1,#8                 ;94
00002a  dbf3              BLT      |L22.20|
                  |L22.44|
00002c  1e1c              SUBS     r4,r3,#0              ;90
00002e  f1a30501          SUB      r5,r3,#1              ;90
000032  b2ab              UXTH     r3,r5                 ;90
000034  d1e9              BNE      |L22.10|
;;;103                }
;;;104            }
;;;105        }
;;;106    
;;;107        return crc;
;;;108    }
000036  bd30              POP      {r4,r5,pc}
;;;109    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  uartProtocolCB4
                          %        1548

                          AREA ||.data||, DATA, ALIGN=2

                  uartProtocolOutTimeDelay
                          DCD      0x001b7740
                          DCD      0x001b7740
                          DCD      0x001b7740
                          DCD      0x000003e8
                          DCD      0x000003e8
                          DCD      0x001b7740

;*** Start embedded assembler ***

#line 1 "User\\LimeUartProtocol.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_LimeUartProtocol_c_2f22fe36____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___18_LimeUartProtocol_c_2f22fe36____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_LimeUartProtocol_c_2f22fe36____REVSH|
#line 128
|__asm___18_LimeUartProtocol_c_2f22fe36____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
