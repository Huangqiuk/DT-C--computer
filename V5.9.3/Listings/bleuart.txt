; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\bleuart.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\bleuart.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -I.\User\qrencode -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.1\Device\Include -D__MICROLIB -D__UVISION_VERSION=534 -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\bleuart.crf User\BleUart.c]
                          THUMB

                          AREA ||i.BLE_CALL_TimeOut||, CODE, READONLY, ALIGN=2

                  BLE_CALL_TimeOut PROC
;;;203    
;;;204    void BLE_CALL_TimeOut(uint32 param)
000000  4901              LDR      r1,|L1.8|
;;;205    {
;;;206    	PARAM_SetBleCallRing(param);
000002  f88101fc          STRB     r0,[r1,#0x1fc]
;;;207    }
000006  4770              BX       lr
;;;208    
                          ENDP

                  |L1.8|
                          DCD      paramCB

                          AREA ||i.BLE_CMD_GPIO_CtrlPin||, CODE, READONLY, ALIGN=2

                  BLE_CMD_GPIO_CtrlPin PROC
;;;498    // BLE模块辅助控制引脚
;;;499    void BLE_CMD_GPIO_CtrlPin(void)
000000  b570              PUSH     {r4-r6,lr}
;;;500    {
;;;501    	// 打开时钟
;;;502    	rcu_periph_clock_enable(RCU_GPIOA);
000002  f2406002          MOV      r0,#0x602
000006  f7fffffe          BL       rcu_periph_clock_enable
;;;503    	rcu_periph_clock_enable(RCU_GPIOC);
00000a  f2406004          MOV      r0,#0x604
00000e  f7fffffe          BL       rcu_periph_clock_enable
;;;504    	gpio_init(GPIOA, GPIO_MODE_OUT_PP, GPIO_OSPEED_2MHZ, GPIO_PIN_11);
000012  4e12              LDR      r6,|L2.92|
000014  f44f6400          MOV      r4,#0x800
000018  4623              MOV      r3,r4
00001a  2202              MOVS     r2,#2
00001c  2110              MOVS     r1,#0x10
00001e  4630              MOV      r0,r6
000020  f7fffffe          BL       gpio_init
;;;505    	gpio_init(GPIOA, GPIO_MODE_OUT_PP, GPIO_OSPEED_2MHZ, GPIO_PIN_12);
000024  0065              LSLS     r5,r4,#1
000026  462b              MOV      r3,r5
000028  2202              MOVS     r2,#2
00002a  2110              MOVS     r1,#0x10
00002c  4630              MOV      r0,r6
00002e  f7fffffe          BL       gpio_init
;;;506    
;;;507    	// 释放复位
;;;508    	BLE_RST_RELEASE();
000032  4629              MOV      r1,r5
000034  4630              MOV      r0,r6
000036  f7fffffe          BL       gpio_bit_set
;;;509    	// 允许开始广播
;;;510    	BLE_EN_ENABLE();
00003a  4621              MOV      r1,r4
00003c  4630              MOV      r0,r6
00003e  f7fffffe          BL       gpio_bit_reset
;;;511    
;;;512    	gpio_init(GPIOC, GPIO_MODE_OUT_PP, GPIO_OSPEED_2MHZ, GPIO_PIN_12);
000042  4c07              LDR      r4,|L2.96|
000044  462b              MOV      r3,r5
000046  2202              MOVS     r2,#2
000048  2110              MOVS     r1,#0x10
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       gpio_init
;;;513    
;;;514    	// 上电后一直处于发送准备状态
;;;515    	gpio_bit_reset(GPIOC, GPIO_PIN_12);
000050  4629              MOV      r1,r5
000052  4620              MOV      r0,r4
000054  e8bd4070          POP      {r4-r6,lr}
000058  f7ffbffe          B.W      gpio_bit_reset
;;;516    }
;;;517    
                          ENDP

                  |L2.92|
                          DCD      0x40010800
                  |L2.96|
                          DCD      0x40011000

                          AREA ||i.BLE_MODULE_Reset||, CODE, READONLY, ALIGN=2

                  BLE_MODULE_Reset PROC
;;;578    // BLE模块复位
;;;579    void BLE_MODULE_Reset(uint32 param)
000000  b570              PUSH     {r4-r6,lr}
;;;580    {
;;;581    	// 蓝牙复位
;;;582    	BLE_RST_RESET();
000002  4d0a              LDR      r5,|L3.44|
000004  f44f5480          MOV      r4,#0x1000
000008  4621              MOV      r1,r4
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       gpio_bit_reset
;;;583    	Delayms(10);
000010  200a              MOVS     r0,#0xa
000012  f7fffffe          BL       Delayms
;;;584    	
;;;585    	// 释放复位
;;;586    	BLE_RST_RELEASE();
000016  4621              MOV      r1,r4
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       gpio_bit_set
;;;587    
;;;588    	// 允许开始广播
;;;589    	BLE_EN_ENABLE();
00001e  1061              ASRS     r1,r4,#1
000020  4628              MOV      r0,r5
000022  e8bd4070          POP      {r4-r6,lr}
000026  f7ffbffe          B.W      gpio_bit_reset
;;;590    }
;;;591    
                          ENDP

00002a  0000              DCW      0x0000
                  |L3.44|
                          DCD      0x40010800

                          AREA ||i.BLE_PROTOCOL_SendLockOk||, CODE, READONLY, ALIGN=2

                  BLE_PROTOCOL_SendLockOk PROC
;;;192    // 发送lock 应答
;;;193    void BLE_PROTOCOL_SendLockOk(uint32 param)
000000  b50e              PUSH     {r1-r3,lr}
;;;194    {
;;;195    	uint8 bleMacStr[] = "TTM:LOCK-OK";
000002  a007              ADR      r0,|L4.32|
000004  e9d01200          LDRD     r1,r2,[r0,#0]
000008  6880              LDR      r0,[r0,#8]
00000a  e9cd1200          STRD     r1,r2,[sp,#0]
00000e  9002              STR      r0,[sp,#8]
;;;196    	
;;;197    	// 使能BLE发送
;;;198    	BLE_BRTS_TX_REQUEST();
;;;199    
;;;200    	// 将待发送命令添加到物理层缓冲区
;;;201    	BLE_UART_AddTxArray(0xFFFF, bleMacStr, sizeof(bleMacStr));
000010  220c              MOVS     r2,#0xc
000012  4669              MOV      r1,sp
000014  f64f70ff          MOV      r0,#0xffff
000018  f7fffffe          BL       BLE_UART_AddTxArray
;;;202    }
00001c  bd0e              POP      {r1-r3,pc}
;;;203    
                          ENDP

00001e  0000              DCW      0x0000
                  |L4.32|
000020  54544d3a          DCB      "TTM:LOCK-OK",0
000024  4c4f434b
000028  2d4f4b00

                          AREA ||i.BLE_UART_AddTxArray||, CODE, READONLY, ALIGN=2

                  BLE_UART_AddTxArray PROC
;;;544    // 向发送缓冲区中添加一条待发送序列
;;;545    BOOL BLE_UART_AddTxArray(uint16 id, uint8 *pArray, uint16 length)
000000  b570              PUSH     {r4-r6,lr}
;;;546    {
;;;547    	uint16 i;
;;;548    	uint16 head = bleUartCB.tx.head;
000002  4c1b              LDR      r4,|L5.112|
000004  f8b454d4          LDRH     r5,[r4,#0x4d4]  ; bleUartCB
;;;549    	uint16 end = bleUartCB.tx.end;
000008  f8b434d6          LDRH     r3,[r4,#0x4d6]  ; bleUartCB
;;;550    	
;;;551    	// 参数检验
;;;552    	if ((NULL == pArray) || (0 == length))
00000c  2900              CMP      r1,#0
00000e  d007              BEQ      |L5.32|
000010  b132              CBZ      r2,|L5.32|
;;;553    	{
;;;554    		return FALSE;
;;;555    	}
;;;556    
;;;557    	// 发送缓冲区已满，不予接收
;;;558    	if((end + 1) % BLE_UART_DRIVE_TX_QUEUE_SIZE == head)
000012  1c5e              ADDS     r6,r3,#1
000014  f0060607          AND      r6,r6,#7
000018  42ae              CMP      r6,r5
00001a  d103              BNE      |L5.36|
;;;559    	{
;;;560    		return FALSE;
00001c  2000              MOVS     r0,#0
;;;561    	}
;;;562    
;;;563    	bleUartCB.tx.cmdQueue[end].deviceID = id;
;;;564    	for (i = 0; i < length; i++)
;;;565    	{
;;;566    		bleUartCB.tx.cmdQueue[end].buff[i] = *pArray++;
;;;567    	}
;;;568    	bleUartCB.tx.cmdQueue[end].length = length;
;;;569    	
;;;570    	// 发送环形队列更新位置
;;;571    	bleUartCB.tx.end ++;
;;;572    	bleUartCB.tx.end %= BLE_UART_DRIVE_TX_QUEUE_SIZE;
;;;573    	bleUartCB.tx.cmdQueue[bleUartCB.tx.end].length = 0;
;;;574    
;;;575    	return TRUE;
;;;576    }
00001e  bd70              POP      {r4-r6,pc}
                  |L5.32|
000020  2000              MOVS     r0,#0                 ;554
000022  bd70              POP      {r4-r6,pc}
                  |L5.36|
000024  254d              MOVS     r5,#0x4d              ;563
000026  436b              MULS     r3,r5,r3              ;563
000028  eb040343          ADD      r3,r4,r3,LSL #1       ;563
00002c  8098              STRH     r0,[r3,#4]            ;563
00002e  2000              MOVS     r0,#0                 ;564
000030  e005              B        |L5.62|
                  |L5.50|
000032  181e              ADDS     r6,r3,r0              ;566
000034  f8115b01          LDRB     r5,[r1],#1            ;566
000038  71b5              STRB     r5,[r6,#6]            ;566
00003a  1c40              ADDS     r0,r0,#1              ;564
00003c  b280              UXTH     r0,r0                 ;564
                  |L5.62|
00003e  4290              CMP      r0,r2                 ;564
000040  d3f7              BCC      |L5.50|
000042  f8a3209c          STRH     r2,[r3,#0x9c]         ;568
000046  f20444d6          ADD      r4,r4,#0x4d6          ;571
00004a  8820              LDRH     r0,[r4,#0]            ;571  ; bleUartCB
00004c  1c40              ADDS     r0,r0,#1              ;571
00004e  8020              STRH     r0,[r4,#0]            ;571
000050  8820              LDRH     r0,[r4,#0]            ;572  ; bleUartCB
000052  f0000007          AND      r0,r0,#7              ;572
000056  8020              STRH     r0,[r4,#0]            ;572
000058  8820              LDRH     r0,[r4,#0]            ;573  ; bleUartCB
00005a  2100              MOVS     r1,#0                 ;573
00005c  224d              MOVS     r2,#0x4d              ;573
00005e  f2a444d6          SUB      r4,r4,#0x4d6          ;573
000062  4350              MULS     r0,r2,r0              ;573
000064  eb040040          ADD      r0,r4,r0,LSL #1       ;573
000068  f8a0109c          STRH     r1,[r0,#0x9c]         ;573
00006c  2001              MOVS     r0,#1                 ;575
00006e  bd70              POP      {r4-r6,pc}
;;;577    
                          ENDP

                  |L5.112|
                          DCD      ||.bss||+0xdc

                          AREA ||i.BLE_UART_AtChannelDataProcess||, CODE, READONLY, ALIGN=2

                  BLE_UART_AtChannelDataProcess PROC
;;;303    // 接收蓝牙mac地址
;;;304    void BLE_UART_AtChannelDataProcess(uint8 data)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;305    {
;;;306    	uint8 i;
;;;307    	
;;;308    	if (!bleUartCB.rx.startFlag)
000004  4c3e              LDR      r4,|L6.256|
;;;309    	{
;;;310    		if (data == 'T')				// 起始标志
;;;311    		{
;;;312    			bleUartCB.rx.startFlag = TRUE;
000006  2601              MOVS     r6,#1
000008  2500              MOVS     r5,#0
00000a  f89414dc          LDRB     r1,[r4,#0x4dc]        ;308  ; bleUartCB
00000e  2900              CMP      r1,#0                 ;308
000010  d011              BEQ      |L6.54|
;;;313    
;;;314    			bleUartCB.rx.index = 0;
;;;315    
;;;316    			bleUartCB.rx.fifoBuff[bleUartCB.rx.index++] = data;		
;;;317    			
;;;318    			return;
;;;319    		}
;;;320    	}
;;;321    	else
;;;322    	{
;;;323    		// 连续接收数据
;;;324    		bleUartCB.rx.fifoBuff[bleUartCB.rx.index++] = data;
000012  f8941523          LDRB     r1,[r4,#0x523]  ; bleUartCB
000016  1c4a              ADDS     r2,r1,#1
000018  4421              ADD      r1,r1,r4
00001a  f8842523          STRB     r2,[r4,#0x523]
00001e  f88104dd          STRB     r0,[r1,#0x4dd]
;;;325    
;;;326    		// 越界判断
;;;327    		if (bleUartCB.rx.index >= sizeof(bleUartCB.rx.fifoBuff))
000022  f8941523          LDRB     r1,[r4,#0x523]  ; bleUartCB
000026  2932              CMP      r1,#0x32
000028  d30e              BCC      |L6.72|
;;;328    		{
;;;329    			bleUartCB.rx.startFlag = TRUE;
00002a  f88464dc          STRB     r6,[r4,#0x4dc]
;;;330    			bleUartCB.rx.index = 0;
00002e  f8845523          STRB     r5,[r4,#0x523]
                  |L6.50|
;;;331    
;;;332    			return;
;;;333    		}
;;;334    		
;;;335    		if (data == '\n')			// 收到结束标志
;;;336    		{
;;;337    			bleUartCB.rx.startFlag = FALSE;
;;;338    			bleUartCB.rx.index = 0;
;;;339    
;;;340    			bleUartCB.rx.macBuff[2] = ':';
;;;341    			bleUartCB.rx.macBuff[5] = ':';
;;;342    			bleUartCB.rx.macBuff[8] = ':';
;;;343    			bleUartCB.rx.macBuff[11] = ':';
;;;344    			bleUartCB.rx.macBuff[14] = ':';
;;;345    			bleUartCB.rx.macBuff[17] = '\0';
;;;346    
;;;347    			// 过滤回显指令
;;;348    			if ((strstr((const char*)bleUartCB.rx.fifoBuff, (const char*)"TTM:MAC-?") != NULL))
;;;349    			{
;;;350    				return ;
;;;351    			}
;;;352    
;;;353    			// 将读到的蓝牙mac地址提取出来
;;;354    			if ((strstr((const char*)bleUartCB.rx.fifoBuff, (const char*)"TTM:MAC-") != NULL) 
;;;355    			&& (bleUartCB.rx.fifoBuff[0] == 'T') && (bleUartCB.rx.fifoBuff[1] == 'T') && (bleUartCB.rx.fifoBuff[2] == 'M'))
;;;356    			{
;;;357    				bleUartCB.rx.macBuff[0] = bleUartCB.rx.fifoBuff[8];
;;;358    				bleUartCB.rx.macBuff[1] = bleUartCB.rx.fifoBuff[9];
;;;359    
;;;360    				bleUartCB.rx.macBuff[3] = bleUartCB.rx.fifoBuff[10];
;;;361    				bleUartCB.rx.macBuff[4] = bleUartCB.rx.fifoBuff[11];
;;;362    
;;;363    				bleUartCB.rx.macBuff[6] = bleUartCB.rx.fifoBuff[12];
;;;364    				bleUartCB.rx.macBuff[7] = bleUartCB.rx.fifoBuff[13];
;;;365    
;;;366    				bleUartCB.rx.macBuff[9] = bleUartCB.rx.fifoBuff[14];
;;;367    				bleUartCB.rx.macBuff[10] = bleUartCB.rx.fifoBuff[15];
;;;368    
;;;369    				bleUartCB.rx.macBuff[12] = bleUartCB.rx.fifoBuff[16];
;;;370    				bleUartCB.rx.macBuff[13] = bleUartCB.rx.fifoBuff[17];
;;;371    
;;;372    				bleUartCB.rx.macBuff[15] = bleUartCB.rx.fifoBuff[18];
;;;373    				bleUartCB.rx.macBuff[16] = bleUartCB.rx.fifoBuff[19];
;;;374    
;;;375    				//for (i = 0; i < 12; i++)
;;;376    				//{
;;;377    				//	bleUartCB.rx.macBuff[i] = bleUartCB.rx.fifoBuff[i+10];
;;;378    				//}
;;;379    				//bleUartCB.rx.macBuff[i] = '\0';
;;;380    				
;;;381    				for (i = 0; i < sizeof(bleUartCB.rx.fifoBuff); i++)
;;;382    				{
;;;383    					bleUartCB.rx.fifoBuff[i] = 0;
;;;384    				}				
;;;385    
;;;386    				// 注销该定时器
;;;387    //				TIMER_KillTask(TIMER_ID_BLE_CONTROL);
;;;388    				
;;;389    				// 蓝牙地址接收完成
;;;390    				bleUartCB.rcvBleMacOK = TRUE;
;;;391    			}	
;;;392    		}
;;;393    	}
;;;394    }
000032  e8bd81f0          POP      {r4-r8,pc}
                  |L6.54|
000036  2854              CMP      r0,#0x54              ;310
000038  d1fb              BNE      |L6.50|
00003a  f88464dc          STRB     r6,[r4,#0x4dc]        ;312
00003e  f8846523          STRB     r6,[r4,#0x523]        ;316
000042  f88404dd          STRB     r0,[r4,#0x4dd]        ;316
000046  e7f4              B        |L6.50|
                  |L6.72|
000048  280a              CMP      r0,#0xa               ;335
00004a  d1f2              BNE      |L6.50|
00004c  f2045404          ADD      r4,r4,#0x504          ;337
000050  f8045c28          STRB     r5,[r4,#-0x28]        ;337
000054  77e5              STRB     r5,[r4,#0x1f]         ;338
000056  203a              MOVS     r0,#0x3a              ;340
000058  7360              STRB     r0,[r4,#0xd]          ;340
00005a  7420              STRB     r0,[r4,#0x10]         ;341
00005c  74e0              STRB     r0,[r4,#0x13]         ;342
00005e  75a0              STRB     r0,[r4,#0x16]         ;343
000060  7660              STRB     r0,[r4,#0x19]         ;344
000062  7725              STRB     r5,[r4,#0x1c]         ;345
000064  f2a45404          SUB      r4,r4,#0x504          ;345
000068  4829              LDR      r0,|L6.272|
00006a  a126              ADR      r1,|L6.260|
00006c  4607              MOV      r7,r0                 ;348
00006e  f7fffffe          BL       strstr
000072  2800              CMP      r0,#0                 ;348
000074  d1dd              BNE      |L6.50|
000076  a127              ADR      r1,|L6.276|
000078  4638              MOV      r0,r7                 ;354
00007a  f7fffffe          BL       strstr
00007e  2800              CMP      r0,#0                 ;354
000080  d0d7              BEQ      |L6.50|
000082  f89404dd          LDRB     r0,[r4,#0x4dd]        ;355  ; bleUartCB
000086  2854              CMP      r0,#0x54              ;355
000088  d1d3              BNE      |L6.50|
00008a  f89404de          LDRB     r0,[r4,#0x4de]        ;355  ; bleUartCB
00008e  2854              CMP      r0,#0x54              ;355
000090  d1cf              BNE      |L6.50|
000092  f89404df          LDRB     r0,[r4,#0x4df]        ;355  ; bleUartCB
000096  284d              CMP      r0,#0x4d              ;355
000098  d1cb              BNE      |L6.50|
00009a  f20444e5          ADD      r4,r4,#0x4e5          ;357
00009e  7820              LDRB     r0,[r4,#0]            ;357  ; bleUartCB
0000a0  f884002a          STRB     r0,[r4,#0x2a]         ;357
0000a4  7860              LDRB     r0,[r4,#1]            ;358  ; bleUartCB
0000a6  f884002b          STRB     r0,[r4,#0x2b]         ;358
0000aa  78a0              LDRB     r0,[r4,#2]            ;360  ; bleUartCB
0000ac  f884002d          STRB     r0,[r4,#0x2d]         ;360
0000b0  78e0              LDRB     r0,[r4,#3]            ;361  ; bleUartCB
0000b2  f884002e          STRB     r0,[r4,#0x2e]         ;361
0000b6  7920              LDRB     r0,[r4,#4]            ;363  ; bleUartCB
0000b8  f8840030          STRB     r0,[r4,#0x30]         ;363
0000bc  7960              LDRB     r0,[r4,#5]            ;364  ; bleUartCB
0000be  f8840031          STRB     r0,[r4,#0x31]         ;364
0000c2  79a0              LDRB     r0,[r4,#6]            ;366  ; bleUartCB
0000c4  f8840033          STRB     r0,[r4,#0x33]         ;366
0000c8  79e0              LDRB     r0,[r4,#7]            ;367  ; bleUartCB
0000ca  f8840034          STRB     r0,[r4,#0x34]         ;367
0000ce  7a20              LDRB     r0,[r4,#8]            ;369  ; bleUartCB
0000d0  f8840036          STRB     r0,[r4,#0x36]         ;369
0000d4  7a60              LDRB     r0,[r4,#9]            ;370  ; bleUartCB
0000d6  f8840037          STRB     r0,[r4,#0x37]         ;370
0000da  7aa0              LDRB     r0,[r4,#0xa]          ;372  ; bleUartCB
0000dc  f8840039          STRB     r0,[r4,#0x39]         ;372
0000e0  7ae0              LDRB     r0,[r4,#0xb]          ;373  ; bleUartCB
0000e2  f884003a          STRB     r0,[r4,#0x3a]         ;373
0000e6  f2a444e5          SUB      r4,r4,#0x4e5          ;373
0000ea  2000              MOVS     r0,#0                 ;381
                  |L6.236|
0000ec  1821              ADDS     r1,r4,r0              ;383
0000ee  f88154dd          STRB     r5,[r1,#0x4dd]        ;383
0000f2  1c40              ADDS     r0,r0,#1              ;381
0000f4  b2c0              UXTB     r0,r0                 ;381
0000f6  2832              CMP      r0,#0x32              ;381
0000f8  d3f8              BCC      |L6.236|
0000fa  f8846524          STRB     r6,[r4,#0x524]        ;390
0000fe  e798              B        |L6.50|
;;;395    
                          ENDP

                  |L6.256|
                          DCD      ||.bss||+0xdc
                  |L6.260|
000104  54544d3a          DCB      "TTM:MAC-?",0
000108  4d41432d
00010c  3f00    
00010e  00                DCB      0
00010f  00                DCB      0
                  |L6.272|
                          DCD      ||.bss||+0x5b9
                  |L6.276|
000114  54544d3a          DCB      "TTM:MAC-",0
000118  4d41432d
00011c  00      
00011d  00                DCB      0
00011e  00                DCB      0
00011f  00                DCB      0

                          AREA ||i.BLE_UART_BC_SendData||, CODE, READONLY, ALIGN=2

                  BLE_UART_BC_SendData PROC
;;;179    // 阻塞发送一个字节数据
;;;180    void BLE_UART_BC_SendData(uint8 data)
000000  b570              PUSH     {r4-r6,lr}
;;;181    {	
000002  4605              MOV      r5,r0
;;;182    	// 防止丢失第一个字节(清除空标志位,务必加) 
;;;183    	usart_flag_get(BLE_UART_TYPE_DEF, USART_FLAG_TC);		
000004  4c07              LDR      r4,|L7.36|
000006  2106              MOVS     r1,#6
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       usart_flag_get
;;;184    
;;;185    	// 填充数据
;;;186    	usart_data_transmit(BLE_UART_TYPE_DEF, data);
00000e  4629              MOV      r1,r5
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       usart_data_transmit
                  |L7.22|
;;;187    
;;;188    	// 未发送完，持续等待
;;;189    	while(usart_flag_get(BLE_UART_TYPE_DEF, USART_FLAG_TC) != SET);		
000016  2106              MOVS     r1,#6
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       usart_flag_get
00001e  2801              CMP      r0,#1
000020  d1f9              BNE      |L7.22|
;;;190    }
000022  bd70              POP      {r4-r6,pc}
;;;191    
                          ENDP

                  |L7.36|
                          DCD      0x40004400

                          AREA ||i.BLE_UART_BleConnectState||, CODE, READONLY, ALIGN=2

                  BLE_UART_BleConnectState PROC
;;;219    uint8 bleIndex = 0;
;;;220    void BLE_UART_BleConnectState(uint32 param)
000000  b5fe              PUSH     {r1-r7,lr}
;;;221    {	
;;;222    	uint8 indexcnt ,i = 0;
000002  2400              MOVS     r4,#0
;;;223    	uint8 bleMACstr[] = "TTM:PAIR-OK";
000004  a03c              ADR      r0,|L8.248|
000006  e9d01200          LDRD     r1,r2,[r0,#0]
00000a  6880              LDR      r0,[r0,#8]
00000c  e9cd1200          STRD     r1,r2,[sp,#0]
000010  9002              STR      r0,[sp,#8]
;;;224    
;;;225    	if (-1 != STRING_Find(bleRxBuff, (uint8 *)"TTM:CONNECTED"))
000012  a13c              ADR      r1,|L8.260|
000014  483f              LDR      r0,|L8.276|
000016  f7fffffe          BL       STRING_Find
;;;226    	{
;;;227    		PARAM_SetBleConnectState(TRUE);
00001a  4d3f              LDR      r5,|L8.280|
00001c  1c40              ADDS     r0,r0,#1              ;225
00001e  f04f0701          MOV      r7,#1
000022  d001              BEQ      |L8.40|
000024  f88571fb          STRB     r7,[r5,#0x1fb]
                  |L8.40|
;;;228    		
;;;229    		// 开启鉴权定时器，10s钟内如果没有鉴权成功则退出蓝牙连接
;;;230    //		TIMER_AddTask(TIMER_ID_BLE_CONNECT_VERIFICATE,
;;;231    //					10000,
;;;232    //					BLE_MODULE_Reset,
;;;233    //					0,
;;;234    //					1,
;;;235    //					ACTION_MODE_ADD_TO_QUEUE);
;;;236    
;;;237    	}
;;;238    	
;;;239    	// 防止从设备断开指令冲突
;;;240    	if (-1 != STRING_Find(bleRxBuff, (uint8 *)"TTM:DISCONNECT") && (-1 == STRING_Find(bleRxBuff, (uint8 *)"TTM:DISCONNECTED")))
000028  a13c              ADR      r1,|L8.284|
00002a  483a              LDR      r0,|L8.276|
00002c  f7fffffe          BL       STRING_Find
000030  1c40              ADDS     r0,r0,#1
000032  f04f0600          MOV      r6,#0
000036  d009              BEQ      |L8.76|
000038  a13c              ADR      r1,|L8.300|
00003a  4836              LDR      r0,|L8.276|
00003c  f7fffffe          BL       STRING_Find
000040  1c40              ADDS     r0,r0,#1
000042  d103              BNE      |L8.76|
;;;241    	{
;;;242    		PARAM_SetBleConnectState(FALSE);
000044  f88561fb          STRB     r6,[r5,#0x1fb]
;;;243    		PARAM_SetBleCallRing(FALSE);
000048  f88561fc          STRB     r6,[r5,#0x1fc]
                  |L8.76|
;;;244    	}
;;;245    
;;;246    	// 读取号码
;;;247    	if (-1 != STRING_Find(bleRxBuff, (uint8 *)"TTM:CALL-IN1-"))
00004c  a13c              ADR      r1,|L8.320|
00004e  4831              LDR      r0,|L8.276|
000050  f7fffffe          BL       STRING_Find
000054  1c40              ADDS     r0,r0,#1
000056  d018              BEQ      |L8.138|
;;;248    	{
;;;249    		PARAM_SetBleCallRing(TRUE); 
000058  f88571fc          STRB     r7,[r5,#0x1fc]
;;;250    		memset(callringBuff, 0xFF, 20);	
00005c  482d              LDR      r0,|L8.276|
00005e  22ff              MOVS     r2,#0xff
000060  2114              MOVS     r1,#0x14
000062  30c8              ADDS     r0,r0,#0xc8
000064  f7fffffe          BL       __aeabi_memset
;;;251    		for(indexcnt = 13; indexcnt < 24; indexcnt++)
000068  200d              MOVS     r0,#0xd
00006a  4b2a              LDR      r3,|L8.276|
00006c  f10307c8          ADD      r7,r3,#0xc8           ;250
                  |L8.112|
;;;252    		{
;;;253    			callringBuff[i++] = bleRxBuff[indexcnt] - '0';
000070  5c19              LDRB     r1,[r3,r0]
000072  4622              MOV      r2,r4
000074  3930              SUBS     r1,r1,#0x30
000076  1c64              ADDS     r4,r4,#1
000078  b2e4              UXTB     r4,r4
00007a  54b9              STRB     r1,[r7,r2]
00007c  1c40              ADDS     r0,r0,#1              ;251
00007e  b2c0              UXTB     r0,r0                 ;251
000080  2818              CMP      r0,#0x18              ;251
000082  d3f5              BCC      |L8.112|
;;;254    		}
;;;255    		callringBuff[i + 1] = '\0';
000084  1938              ADDS     r0,r7,r4
000086  7046              STRB     r6,[r0,#1]
000088  e00d              B        |L8.166|
                  |L8.138|
;;;256    
;;;257    //		TIMER_AddTask(TIMER_ID_CALL_TIME_OUT,
;;;258    //				30*1000ul,
;;;259    //				BLE_CALL_TimeOut,
;;;260    //				FALSE,
;;;261    //				1,
;;;262    //				ACTION_MODE_ADD_TO_QUEUE);
;;;263    	}
;;;264    	else if (-1 != STRING_Find(bleRxBuff, (uint8 *)"TTM:CALL-IN2-"))
00008a  a131              ADR      r1,|L8.336|
00008c  4821              LDR      r0,|L8.276|
00008e  f7fffffe          BL       STRING_Find
000092  1c40              ADDS     r0,r0,#1
000094  d007              BEQ      |L8.166|
;;;265    	{
;;;266    		// 备注名显示不了
;;;267    		PARAM_SetBleCallRing(TRUE);
000096  f88571fc          STRB     r7,[r5,#0x1fc]
;;;268    		memset(callringBuff, 0xFF, 20);	
00009a  481e              LDR      r0,|L8.276|
00009c  22ff              MOVS     r2,#0xff
00009e  2114              MOVS     r1,#0x14
0000a0  30c8              ADDS     r0,r0,#0xc8
0000a2  f7fffffe          BL       __aeabi_memset
                  |L8.166|
;;;269    
;;;270    //		TIMER_AddTask(TIMER_ID_CALL_TIME_OUT,
;;;271    //				30*1000ul,
;;;272    //				BLE_CALL_TimeOut,
;;;273    //				FALSE,
;;;274    //				1,
;;;275    //				ACTION_MODE_ADD_TO_QUEUE);
;;;276    	}
;;;277    
;;;278    	//挂断电话
;;;279    	if (-1 != STRING_Find(bleRxBuff, (uint8 *)"TTM:CALL-HANGUP"))
0000a6  a12e              ADR      r1,|L8.352|
0000a8  481a              LDR      r0,|L8.276|
0000aa  f7fffffe          BL       STRING_Find
0000ae  1c40              ADDS     r0,r0,#1
0000b0  d001              BEQ      |L8.182|
;;;280    	{
;;;281    		PARAM_SetBleCallRing(FALSE);		
0000b2  f88561fc          STRB     r6,[r5,#0x1fc]
                  |L8.182|
;;;282    	}
;;;283    
;;;284    	//匹配直接连接
;;;285    	if (-1 != STRING_Find(bleRxBuff, (uint8 *)"TTM:PAIR-"))
0000b6  a12e              ADR      r1,|L8.368|
0000b8  4816              LDR      r0,|L8.276|
0000ba  f7fffffe          BL       STRING_Find
0000be  1c40              ADDS     r0,r0,#1
0000c0  d005              BEQ      |L8.206|
;;;286    	{
;;;287    		BLE_UART_AddTxArray(0XFFF,bleMACstr,sizeof(bleMACstr));
0000c2  220c              MOVS     r2,#0xc
0000c4  4669              MOV      r1,sp
0000c6  f64070ff          MOV      r0,#0xfff
0000ca  f7fffffe          BL       BLE_UART_AddTxArray
                  |L8.206|
;;;288    	}
;;;289    	 
;;;290    	if (-1 != STRING_Find(bleRxBuff, (uint8 *)"TTM:LOCK-ON"))
0000ce  a12b              ADR      r1,|L8.380|
0000d0  4810              LDR      r0,|L8.276|
0000d2  f7fffffe          BL       STRING_Find
0000d6  1c40              ADDS     r0,r0,#1
0000d8  d002              BEQ      |L8.224|
;;;291    	{
;;;292    		BLE_PROTOCOL_SendLockOk(TRUE);
0000da  2001              MOVS     r0,#1
0000dc  f7fffffe          BL       BLE_PROTOCOL_SendLockOk
                  |L8.224|
;;;293    	}
;;;294    
;;;295    	if (-1 != STRING_Find(bleRxBuff, (uint8 *)"TTM:LOCK-OFF"))
0000e0  a129              ADR      r1,|L8.392|
0000e2  480c              LDR      r0,|L8.276|
0000e4  f7fffffe          BL       STRING_Find
0000e8  1c40              ADDS     r0,r0,#1
0000ea  d002              BEQ      |L8.242|
;;;296    	{
;;;297    		BLE_PROTOCOL_SendLockOk(TRUE);
0000ec  2001              MOVS     r0,#1
0000ee  f7fffffe          BL       BLE_PROTOCOL_SendLockOk
                  |L8.242|
;;;298    	}
;;;299    
;;;300    	bleIndex = 0;
0000f2  4829              LDR      r0,|L8.408|
0000f4  7006              STRB     r6,[r0,#0]
;;;301    }
0000f6  bdfe              POP      {r1-r7,pc}
;;;302    
                          ENDP

                  |L8.248|
0000f8  54544d3a          DCB      "TTM:PAIR-OK",0
0000fc  50414952
000100  2d4f4b00
                  |L8.260|
000104  54544d3a          DCB      "TTM:CONNECTED",0
000108  434f4e4e
00010c  45435445
000110  4400    
000112  00                DCB      0
000113  00                DCB      0
                  |L8.276|
                          DCD      ||.bss||
                  |L8.280|
                          DCD      paramCB
                  |L8.284|
00011c  54544d3a          DCB      "TTM:DISCONNECT",0
000120  44495343
000124  4f4e4e45
000128  435400  
00012b  00                DCB      0
                  |L8.300|
00012c  54544d3a          DCB      "TTM:DISCONNECTED",0
000130  44495343
000134  4f4e4e45
000138  43544544
00013c  00      
00013d  00                DCB      0
00013e  00                DCB      0
00013f  00                DCB      0
                  |L8.320|
000140  54544d3a          DCB      "TTM:CALL-IN1-",0
000144  43414c4c
000148  2d494e31
00014c  2d00    
00014e  00                DCB      0
00014f  00                DCB      0
                  |L8.336|
000150  54544d3a          DCB      "TTM:CALL-IN2-",0
000154  43414c4c
000158  2d494e32
00015c  2d00    
00015e  00                DCB      0
00015f  00                DCB      0
                  |L8.352|
000160  54544d3a          DCB      "TTM:CALL-HANGUP",0
000164  43414c4c
000168  2d48414e
00016c  47555000
                  |L8.368|
000170  54544d3a          DCB      "TTM:PAIR-",0
000174  50414952
000178  2d00    
00017a  00                DCB      0
00017b  00                DCB      0
                  |L8.380|
00017c  54544d3a          DCB      "TTM:LOCK-ON",0
000180  4c4f434b
000184  2d4f4e00
                  |L8.392|
000188  54544d3a          DCB      "TTM:LOCK-OFF",0
00018c  4c4f434b
000190  2d4f4646
000194  00      
000195  00                DCB      0
000196  00                DCB      0
000197  00                DCB      0
                  |L8.408|
                          DCD      ||.data||

                          AREA ||i.BLE_UART_DataStructureInit||, CODE, READONLY, ALIGN=2

                  BLE_UART_DataStructureInit PROC
;;;68     // 数据结构初始化
;;;69     void BLE_UART_DataStructureInit(BLE_UART_CB* pCB)
000000  2800              CMP      r0,#0
;;;70     {
000002  d016              BEQ      |L9.50|
;;;71     	uint16 i;
;;;72     	
;;;73     	// 参数合法性检验
;;;74     	if (NULL == pCB)
;;;75     	{
;;;76     		return;
;;;77     	}
;;;78     
;;;79     	pCB->tx.txBusy = FALSE;
000004  2200              MOVS     r2,#0
000006  f88024da          STRB     r2,[r0,#0x4da]
;;;80     	pCB->tx.index = 0;
00000a  f8a024d8          STRH     r2,[r0,#0x4d8]
;;;81     	pCB->tx.head = 0;
00000e  f8a024d4          STRH     r2,[r0,#0x4d4]
;;;82     	pCB->tx.end = 0;
000012  f8a024d6          STRH     r2,[r0,#0x4d6]
;;;83     	for(i = 0; i < BLE_UART_DRIVE_TX_QUEUE_SIZE; i++)
000016  2100              MOVS     r1,#0
                  |L9.24|
;;;84     	{
;;;85     		pCB->tx.cmdQueue[i].length = 0;
000018  234d              MOVS     r3,#0x4d
00001a  434b              MULS     r3,r1,r3
00001c  eb000343          ADD      r3,r0,r3,LSL #1
000020  f8a3209c          STRH     r2,[r3,#0x9c]
000024  1c49              ADDS     r1,r1,#1              ;83
000026  b289              UXTH     r1,r1                 ;83
000028  2908              CMP      r1,#8                 ;83
00002a  d3f5              BCC      |L9.24|
;;;86     	}	
;;;87     
;;;88     	bleUartCB.rcvBleMacOK = FALSE;
00002c  4801              LDR      r0,|L9.52|
00002e  f8802524          STRB     r2,[r0,#0x524]
                  |L9.50|
;;;89     }
000032  4770              BX       lr
;;;90     
                          ENDP

                  |L9.52|
                          DCD      ||.bss||+0xdc

                          AREA ||i.BLE_UART_HwInit||, CODE, READONLY, ALIGN=2

                  BLE_UART_HwInit PROC
;;;37     // UART初始化
;;;38     void BLE_UART_HwInit(uint32 baud)
000000  b570              PUSH     {r4-r6,lr}
;;;39     {
000002  4605              MOV      r5,r0
;;;40     	// 打开时钟
;;;41     	rcu_periph_clock_enable(RCU_GPIOA);
000004  f2406002          MOV      r0,#0x602
000008  f7fffffe          BL       rcu_periph_clock_enable
;;;42     	gpio_init(GPIOA, GPIO_MODE_AF_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_2);
00000c  4c21              LDR      r4,|L10.148|
00000e  2304              MOVS     r3,#4
000010  2203              MOVS     r2,#3
000012  2118              MOVS     r1,#0x18
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       gpio_init
;;;43     	
;;;44     	gpio_init(GPIOA, GPIO_MODE_IPU, GPIO_OSPEED_50MHZ, GPIO_PIN_3);
00001a  2308              MOVS     r3,#8
00001c  2203              MOVS     r2,#3
00001e  2148              MOVS     r1,#0x48
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       gpio_init
;;;45     
;;;46     	// UART时钟配置
;;;47     	rcu_periph_clock_enable(RCU_USART1);
000026  f2407011          MOV      r0,#0x711
00002a  f7fffffe          BL       rcu_periph_clock_enable
;;;48     	usart_deinit(BLE_UART_TYPE_DEF);									// 复位串口
00002e  4c1a              LDR      r4,|L10.152|
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       usart_deinit
;;;49     		
;;;50     	// 串口配置
;;;51     	usart_baudrate_set(BLE_UART_TYPE_DEF, baud);						// 波特率
000036  4629              MOV      r1,r5
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       usart_baudrate_set
;;;52     	usart_word_length_set(BLE_UART_TYPE_DEF, USART_WL_8BIT);			// 8位数据位
00003e  2100              MOVS     r1,#0
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       usart_word_length_set
;;;53     	usart_stop_bit_set(BLE_UART_TYPE_DEF, USART_STB_1BIT); 				// 一个停止位
000046  2100              MOVS     r1,#0
000048  4620              MOV      r0,r4
00004a  f7fffffe          BL       usart_stop_bit_set
;;;54     	usart_parity_config(BLE_UART_TYPE_DEF, USART_PM_NONE); 				// 无奇偶校验
00004e  2100              MOVS     r1,#0
000050  4620              MOV      r0,r4
000052  f7fffffe          BL       usart_parity_config
;;;55     	usart_hardware_flow_rts_config(BLE_UART_TYPE_DEF, USART_RTS_DISABLE); // 无硬件数据流控制
000056  2100              MOVS     r1,#0
000058  4620              MOV      r0,r4
00005a  f7fffffe          BL       usart_hardware_flow_rts_config
;;;56     	usart_hardware_flow_cts_config(BLE_UART_TYPE_DEF, USART_CTS_DISABLE);
00005e  2100              MOVS     r1,#0
000060  4620              MOV      r0,r4
000062  f7fffffe          BL       usart_hardware_flow_cts_config
;;;57     	usart_transmit_config(BLE_UART_TYPE_DEF, USART_TRANSMIT_ENABLE);	// 使能发射
000066  2108              MOVS     r1,#8
000068  4620              MOV      r0,r4
00006a  f7fffffe          BL       usart_transmit_config
;;;58     	usart_receive_config(BLE_UART_TYPE_DEF, USART_RECEIVE_ENABLE); 		// 使能接收
00006e  2104              MOVS     r1,#4
000070  4620              MOV      r0,r4
000072  f7fffffe          BL       usart_receive_config
;;;59     
;;;60     	// 中断配置
;;;61     	nvic_irq_enable(BLE_UART_IRQn_DEF, 2, 1);
000076  2201              MOVS     r2,#1
000078  2102              MOVS     r1,#2
00007a  2026              MOVS     r0,#0x26
00007c  f7fffffe          BL       nvic_irq_enable
;;;62     
;;;63     	usart_interrupt_enable(BLE_UART_TYPE_DEF, USART_INT_RBNE); 			// 开启中断
000080  f2403105          MOV      r1,#0x305
000084  4620              MOV      r0,r4
000086  f7fffffe          BL       usart_interrupt_enable
;;;64     
;;;65     	usart_enable(BLE_UART_TYPE_DEF);									// 使能串口 
00008a  4620              MOV      r0,r4
00008c  e8bd4070          POP      {r4-r6,lr}
000090  f7ffbffe          B.W      usart_enable
;;;66     }
;;;67     
                          ENDP

                  |L10.148|
                          DCD      0x40010800
                  |L10.152|
                          DCD      0x40004400

                          AREA ||i.BLE_UART_IR_StartSendData||, CODE, READONLY, ALIGN=2

                  BLE_UART_IR_StartSendData PROC
;;;166    // 启动中断字节发送
;;;167    void BLE_UART_IR_StartSendData(uint8 data)
000000  b570              PUSH     {r4-r6,lr}
;;;168    {
000002  4605              MOV      r5,r0
;;;169    	// 先读SR，再填充DR会把TC标志清掉
;;;170    	usart_flag_get(BLE_UART_TYPE_DEF, USART_FLAG_TC);
000004  4c07              LDR      r4,|L11.36|
000006  2106              MOVS     r1,#6
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       usart_flag_get
;;;171    
;;;172    	// 发送一个字节
;;;173    	usart_data_transmit(BLE_UART_TYPE_DEF, data);
00000e  4629              MOV      r1,r5
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       usart_data_transmit
;;;174    
;;;175    	// 打开发送完成中断
;;;176    	usart_interrupt_enable(BLE_UART_TYPE_DEF, USART_INT_TC);	
000016  4620              MOV      r0,r4
000018  e8bd4070          POP      {r4-r6,lr}
00001c  f2403106          MOV      r1,#0x306
000020  f7ffbffe          B.W      usart_interrupt_enable
;;;177    }
;;;178    
                          ENDP

                  |L11.36|
                          DCD      0x40004400

                          AREA ||i.BLE_UART_Init||, CODE, READONLY, ALIGN=2

                  BLE_UART_Init PROC
;;;518    // UART初始化
;;;519    void BLE_UART_Init(void)
000000  b510              PUSH     {r4,lr}
;;;520    {
;;;521    	// BLE模块辅助控制引脚初始化
;;;522    	BLE_CMD_GPIO_CtrlPin();
000002  f7fffffe          BL       BLE_CMD_GPIO_CtrlPin
;;;523    
;;;524    	// 串口初始化
;;;525    	BLE_UART_HwInit(BLE_UART_BAUD_RATE);
000006  f44f30e1          MOV      r0,#0x1c200
00000a  f7fffffe          BL       BLE_UART_HwInit
;;;526    
;;;527    	// UART数据结构初始化
;;;528    	BLE_UART_DataStructureInit(&bleUartCB);
00000e  e8bd4010          POP      {r4,lr}
000012  4801              LDR      r0,|L12.24|
000014  f7ffbffe          B.W      BLE_UART_DataStructureInit
;;;529    }
;;;530    
                          ENDP

                  |L12.24|
                          DCD      ||.bss||+0xdc

                          AREA ||i.BLE_UART_Process||, CODE, READONLY, ALIGN=2

                  BLE_UART_Process PROC
;;;531    // UART模块处理入口
;;;532    void BLE_UART_Process(void)
000000  4801              LDR      r0,|L13.8|
;;;533    {
;;;534    	// 发送处理
;;;535    	BLE_UART_TxProcess(&bleUartCB);
000002  f7ffbffe          B.W      BLE_UART_TxProcess
;;;536    }
;;;537    
                          ENDP

000006  0000              DCW      0x0000
                  |L13.8|
                          DCD      ||.bss||+0xdc

                          AREA ||i.BLE_UART_RegisterDataSendService||, CODE, READONLY, ALIGN=2

                  BLE_UART_RegisterDataSendService PROC
;;;538    // 注册数据抛出接口服务
;;;539    void BLE_UART_RegisterDataSendService(void (*service)(uint16 id, uint8 *pData, uint16 length))
000000  4901              LDR      r1,|L14.8|
;;;540    {
;;;541    	bleUartCB.receiveDataThrowService = service;
000002  6008              STR      r0,[r1,#0]  ; bleUartCB
;;;542    }
000004  4770              BX       lr
;;;543    
                          ENDP

000006  0000              DCW      0x0000
                  |L14.8|
                          DCD      ||.bss||+0xdc

                          AREA ||i.BLE_UART_TxProcess||, CODE, READONLY, ALIGN=1

                  BLE_UART_TxProcess PROC
;;;91     // 发送处理
;;;92     void BLE_UART_TxProcess(BLE_UART_CB* pCB)
000000  b510              PUSH     {r4,lr}
;;;93     {
000002  4604              MOV      r4,r0
;;;94     // 中断方式
;;;95     #if (BLE_UART_TX_MODE == BLE_UART_INTERRUPT_TX_MODE)
;;;96     	uint16 index = pCB->tx.index;							// 当前发送数据的索引号
000004  f8b404d8          LDRH     r0,[r4,#0x4d8]
;;;97     	uint16 length = pCB->tx.cmdQueue[pCB->tx.head].length;	// 当前发送的命令帧的长度
000008  f8b414d4          LDRH     r1,[r4,#0x4d4]
00000c  224d              MOVS     r2,#0x4d
00000e  4351              MULS     r1,r2,r1
000010  eb040141          ADD      r1,r4,r1,LSL #1
000014  f8b1209c          LDRH     r2,[r1,#0x9c]
;;;98     	uint16 head = pCB->tx.head;								// 发送命令帧队列头索引号
000018  f8b414d4          LDRH     r1,[r4,#0x4d4]
;;;99     	uint16 end = pCB->tx.end;								// 发送命令帧队列尾索引号
00001c  f8b434d6          LDRH     r3,[r4,#0x4d6]
;;;100    
;;;101    	// 参数合法性检验
;;;102    	if (NULL == pCB)
000020  2c00              CMP      r4,#0
000022  d017              BEQ      |L15.84|
;;;103    	{
;;;104    		return;
;;;105    	}
;;;106    	
;;;107    	// 队列为空，不处理
;;;108    	if (head == end)
000024  4299              CMP      r1,r3
000026  d015              BEQ      |L15.84|
;;;109    	{
;;;110    		return;
;;;111    	}
;;;112    
;;;113    	// 发送忙，退出
;;;114    	if (pCB->tx.txBusy)
000028  f89434da          LDRB     r3,[r4,#0x4da]
00002c  2b00              CMP      r3,#0
00002e  d111              BNE      |L15.84|
;;;115    	{
;;;116    		return;
;;;117    	}
;;;118    
;;;119    	// ■■执行到这里，说明队列非空■■
;;;120    	
;;;121    	// 当前命令帧未发送完时，取出一个字节放到发送寄存器中
;;;122    	if (index < length)
000030  4290              CMP      r0,r2
000032  d20f              BCS      |L15.84|
;;;123    	{		
;;;124    		BLE_UART_IR_StartSendData(pCB->tx.cmdQueue[head].buff[pCB->tx.index++]);
000034  f8b404d8          LDRH     r0,[r4,#0x4d8]
000038  1c42              ADDS     r2,r0,#1
00003a  f8a424d8          STRH     r2,[r4,#0x4d8]
00003e  224d              MOVS     r2,#0x4d
000040  4351              MULS     r1,r2,r1
000042  eb040141          ADD      r1,r4,r1,LSL #1
000046  4408              ADD      r0,r0,r1
000048  7980              LDRB     r0,[r0,#6]
00004a  f7fffffe          BL       BLE_UART_IR_StartSendData
;;;125    		
;;;126    		// 设置发送忙状态
;;;127    		pCB->tx.txBusy = TRUE;
00004e  2001              MOVS     r0,#1
000050  f88404da          STRB     r0,[r4,#0x4da]
                  |L15.84|
;;;128    	}
;;;129    
;;;130    
;;;131    // 阻塞方式时启动发送
;;;132    #else
;;;133    	uint16 index = pCB->tx.index;
;;;134    	uint16 head = pCB->tx.head;
;;;135    	uint16 end = pCB->tx.end;
;;;136    
;;;137    	// 参数合法性检验
;;;138    	if(NULL == pCB)
;;;139    	{
;;;140    		return;
;;;141    	}
;;;142    
;;;143    	// 队列为空，不处理
;;;144    	if(head == end)
;;;145    	{
;;;146    		return;
;;;147    	}
;;;148    	
;;;149    	// 当前命令帧未发送完时，持续发送
;;;150    	while(index < pCB->tx.cmdQueue[head].length)
;;;151    	{
;;;152    		// 一直填充发送
;;;153    		BLE_UART_BC_SendData(pCB->tx.cmdQueue[head].buff[pCB->tx.index++]);
;;;154    		
;;;155    		index = pCB->tx.index;
;;;156    	}
;;;157    	
;;;158    	// 当前命令帧发送完时，删除之
;;;159    	pCB->tx.cmdQueue[head].length = 0;
;;;160    	pCB->tx.head ++;
;;;161    	pCB->tx.head %= BLE_UART_DRIVE_TX_QUEUE_SIZE;
;;;162    	pCB->tx.index = 0;
;;;163    #endif
;;;164    }
000054  bd10              POP      {r4,pc}
;;;165    
                          ENDP


                          AREA ||i.USART1_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART1_IRQHandler PROC
;;;403    *************************************************************/
;;;404    void USART1_IRQHandler(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;405    {
;;;406    	// 判断DR是否有数据，中断接收
;;;407    	if (usart_interrupt_flag_get(BLE_UART_TYPE_DEF, USART_INT_FLAG_RBNE) != RESET) 
000002  4e3f              LDR      r6,|L16.256|
000004  493d              LDR      r1,|L16.252|
000006  4630              MOV      r0,r6
000008  f7fffffe          BL       usart_interrupt_flag_get
;;;408    	{
;;;409    		uint8 rxdata = 0x00;
;;;410    		
;;;411    		// 接收数据
;;;412    		rxdata = (uint8)usart_data_receive(BLE_UART_TYPE_DEF);
;;;413    		
;;;414    		if (NULL != bleUartCB.receiveDataThrowService)
00000c  4c3d              LDR      r4,|L16.260|
00000e  2500              MOVS     r5,#0                 ;407
000010  b300              CBZ      r0,|L16.84|
000012  9500              STR      r5,[sp,#0]            ;409
000014  4630              MOV      r0,r6                 ;412
000016  f7fffffe          BL       usart_data_receive
00001a  9000              STR      r0,[sp,#0]            ;412
00001c  6823              LDR      r3,[r4,#0]  ; bleUartCB
00001e  b123              CBZ      r3,|L16.42|
;;;415    		{			
;;;416    			(*bleUartCB.receiveDataThrowService)(0xFFF, &rxdata, 1);
000020  2201              MOVS     r2,#1
000022  4669              MOV      r1,sp
000024  f64070ff          MOV      r0,#0xfff
000028  4798              BLX      r3
                  |L16.42|
;;;417    		}
;;;418    
;;;419    		if (!bleUartCB.rcvBleMacOK)
00002a  f8940524          LDRB     r0,[r4,#0x524]  ; bleUartCB
00002e  b918              CBNZ     r0,|L16.56|
;;;420    		{
;;;421    			BLE_UART_AtChannelDataProcess(rxdata);
000030  f89d0000          LDRB     r0,[sp,#0]
000034  f7fffffe          BL       BLE_UART_AtChannelDataProcess
                  |L16.56|
;;;422    		}
;;;423    
;;;424    //=================================================================
;;;425    		// 蓝牙连接判断
;;;426    		if ((bleIndex + 1)< sizeof(bleRxBuff)/sizeof(bleRxBuff[0]))
000038  4a33              LDR      r2,|L16.264|
00003a  7811              LDRB     r1,[r2,#0]  ; bleIndex
00003c  4608              MOV      r0,r1
00003e  1c49              ADDS     r1,r1,#1
000040  29c8              CMP      r1,#0xc8
000042  d207              BCS      |L16.84|
;;;427    		{
;;;428    			bleRxBuff[bleIndex++] = rxdata;
000044  f89d3000          LDRB     r3,[sp,#0]
000048  b2c9              UXTB     r1,r1
00004a  7011              STRB     r1,[r2,#0]
00004c  4a2d              LDR      r2,|L16.260|
00004e  3adc              SUBS     r2,r2,#0xdc
000050  5413              STRB     r3,[r2,r0]
;;;429    			bleRxBuff[bleIndex] = '\0';
000052  5455              STRB     r5,[r2,r1]
                  |L16.84|
;;;430    		}
;;;431    
;;;432    //		TIMER_AddTask(TIMER_ID_BLE_CONNECT_STATE,
;;;433    //					10,
;;;434    //					BLE_UART_BleConnectState,
;;;435    //					0,
;;;436    //					1,
;;;437    //					ACTION_MODE_ADD_TO_QUEUE);
;;;438    	}
;;;439    
;;;440    
;;;441    // 中断模式发送
;;;442    #if (BLE_UART_TX_MODE == BLE_UART_INTERRUPT_TX_MODE)
;;;443    	// 判断DR是否有数据，中断发送
;;;444    	if (usart_interrupt_flag_get(BLE_UART_TYPE_DEF, USART_INT_FLAG_TC) != RESET)
000054  492d              LDR      r1,|L16.268|
000056  4630              MOV      r0,r6
000058  f7fffffe          BL       usart_interrupt_flag_get
00005c  b3b0              CBZ      r0,|L16.204|
;;;445    	{
;;;446    		uint16 head = bleUartCB.tx.head;
00005e  f8b404d4          LDRH     r0,[r4,#0x4d4]  ; bleUartCB
;;;447    		uint16 end;
;;;448    		uint16 index = bleUartCB.tx.index;
000062  f8b414d8          LDRH     r1,[r4,#0x4d8]  ; bleUartCB
;;;449    		uint8 txdata = 0x00;
;;;450    
;;;451    		// 执行到这里，说明上一个数据已经发送完毕，当前命令帧未发送完时，取出一个字节放到发送寄存器中
;;;452    		if (index < bleUartCB.tx.cmdQueue[head].length)
000066  224d              MOVS     r2,#0x4d
000068  4350              MULS     r0,r2,r0
00006a  eb040240          ADD      r2,r4,r0,LSL #1
00006e  f8b2009c          LDRH     r0,[r2,#0x9c]
000072  4288              CMP      r0,r1
000074  d90a              BLS      |L16.140|
;;;453    		{
;;;454    			txdata = bleUartCB.tx.cmdQueue[head].buff[bleUartCB.tx.index++];
000076  f8b414d8          LDRH     r1,[r4,#0x4d8]  ; bleUartCB
00007a  1c48              ADDS     r0,r1,#1
00007c  f8a404d8          STRH     r0,[r4,#0x4d8]
000080  1888              ADDS     r0,r1,r2
000082  7981              LDRB     r1,[r0,#6]
;;;455    			
;;;456    			// 填充数据
;;;457    			usart_data_transmit(BLE_UART_TYPE_DEF, txdata);
000084  4630              MOV      r0,r6
000086  f7fffffe          BL       usart_data_transmit
00008a  e027              B        |L16.220|
                  |L16.140|
;;;458    		}
;;;459    		// 当前命令帧发送完时，删除之
;;;460    		else
;;;461    		{
;;;462    			bleUartCB.tx.cmdQueue[head].length = 0;
00008c  f8a2509c          STRH     r5,[r2,#0x9c]
;;;463    			bleUartCB.tx.head ++;
000090  f20444d4          ADD      r4,r4,#0x4d4
000094  8820              LDRH     r0,[r4,#0]  ; bleUartCB
000096  1c40              ADDS     r0,r0,#1
000098  8020              STRH     r0,[r4,#0]
;;;464    			bleUartCB.tx.head %= BLE_UART_DRIVE_TX_QUEUE_SIZE;
00009a  8820              LDRH     r0,[r4,#0]  ; bleUartCB
00009c  f0000007          AND      r0,r0,#7
0000a0  8020              STRH     r0,[r4,#0]
;;;465    			bleUartCB.tx.index = 0;
0000a2  80a5              STRH     r5,[r4,#4]
;;;466    
;;;467    			head = bleUartCB.tx.head;
0000a4  8822              LDRH     r2,[r4,#0]  ; bleUartCB
;;;468    			end = bleUartCB.tx.end;
0000a6  8860              LDRH     r0,[r4,#2]  ; bleUartCB
0000a8  f2a444d4          SUB      r4,r4,#0x4d4
;;;469    			
;;;470    			// 命令帧队列非空，继续发送下一个命令帧
;;;471    			if (head != end)
0000ac  4282              CMP      r2,r0
0000ae  d00e              BEQ      |L16.206|
;;;472    			{
;;;473    				txdata = bleUartCB.tx.cmdQueue[head].buff[bleUartCB.tx.index++];
0000b0  f8b414d8          LDRH     r1,[r4,#0x4d8]  ; bleUartCB
0000b4  1c48              ADDS     r0,r1,#1
0000b6  f8a404d8          STRH     r0,[r4,#0x4d8]
0000ba  204d              MOVS     r0,#0x4d
0000bc  4342              MULS     r2,r0,r2
0000be  eb040042          ADD      r0,r4,r2,LSL #1
0000c2  4408              ADD      r0,r0,r1
0000c4  7981              LDRB     r1,[r0,#6]
;;;474    
;;;475    				// 填充数据
;;;476    				usart_data_transmit(BLE_UART_TYPE_DEF, txdata);
0000c6  4630              MOV      r0,r6
0000c8  f7fffffe          BL       usart_data_transmit
                  |L16.204|
0000cc  e006              B        |L16.220|
                  |L16.206|
;;;477    			}
;;;478    			// 命令帧队列为空停止发送，设置空闲
;;;479    			else
;;;480    			{
;;;481    				// 关闭发送完成中断
;;;482    				usart_interrupt_disable(BLE_UART_TYPE_DEF, USART_INT_TC);
0000ce  f2403106          MOV      r1,#0x306
0000d2  4630              MOV      r0,r6
0000d4  f7fffffe          BL       usart_interrupt_disable
;;;483    				
;;;484    				bleUartCB.tx.txBusy = FALSE;				
0000d8  f88454da          STRB     r5,[r4,#0x4da]
                  |L16.220|
;;;485    			}
;;;486    		}		
;;;487    	}
;;;488    #endif
;;;489    
;;;490    	// Other USARTx interrupts handler can go here ...				 
;;;491    	if (usart_interrupt_flag_get(BLE_UART_TYPE_DEF, USART_INT_FLAG_ERR_ORERR) != RESET)	//----------------------- 接收溢出中断 
0000dc  490c              LDR      r1,|L16.272|
0000de  4630              MOV      r0,r6
0000e0  f7fffffe          BL       usart_interrupt_flag_get
0000e4  2800              CMP      r0,#0
0000e6  d008              BEQ      |L16.250|
;;;492    	{
;;;493    		usart_flag_get(BLE_UART_TYPE_DEF, USART_FLAG_ORERR); 			//----------------------- 清除接收溢出中断标志位 
0000e8  2103              MOVS     r1,#3
0000ea  4630              MOV      r0,r6
0000ec  f7fffffe          BL       usart_flag_get
;;;494    		usart_data_receive(BLE_UART_TYPE_DEF);									//----------------------- 清空寄存器
0000f0  4630              MOV      r0,r6
0000f2  e8bd40f8          POP      {r3-r7,lr}
0000f6  f7ffbffe          B.W      usart_data_receive
                  |L16.250|
;;;495    	}
;;;496    }
0000fa  bdf8              POP      {r3-r7,pc}
;;;497    
                          ENDP

                  |L16.252|
                          DCD      0x00050305
                  |L16.256|
                          DCD      0x40004400
                  |L16.260|
                          DCD      ||.bss||+0xdc
                  |L16.264|
                          DCD      ||.data||
                  |L16.268|
                          DCD      0x00060306
                  |L16.272|
                          DCD      0x00030500

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  bleRxBuff
                          %        200
                  callringBuff
                          %        20
                  bleUartCB
                          %        1320

                          AREA ||.data||, DATA, ALIGN=0

                  bleIndex
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "User\\BleUart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_BleUart_c_ff9078f0____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___9_BleUart_c_ff9078f0____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_BleUart_c_ff9078f0____REVSH|
#line 128
|__asm___9_BleUart_c_ff9078f0____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
