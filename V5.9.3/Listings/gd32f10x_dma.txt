; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\gd32f10x_dma.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\gd32f10x_dma.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -I.\User\qrencode -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.3\Device\Include -D__MICROLIB -D__UVISION_VERSION=539 -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\gd32f10x_dma.crf Libraries\src\gd32f10x_dma.c]
                          THUMB

                          AREA ||i.dma_channel_disable||, CODE, READONLY, ALIGN=1

                  dma_channel_disable PROC
;;;262    */
;;;263    void dma_channel_disable(uint32_t dma_periph, dma_channel_enum channelx)
000000  b570              PUSH     {r4-r6,lr}
;;;264    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;265        if(ERROR == dma_periph_and_channel_check(dma_periph, channelx)){
000006  4621              MOV      r1,r4
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       dma_periph_and_channel_check
00000e  b908              CBNZ     r0,|L1.20|
;;;266            DMA_WRONG_HANDLE
000010  bf00              NOP      
                  |L1.18|
000012  e7fe              B        |L1.18|
                  |L1.20|
;;;267        }
;;;268        
;;;269        DMA_CHCTL(dma_periph, channelx) &= ~DMA_CHXCTL_CHEN;
000014  eb040084          ADD      r0,r4,r4,LSL #2
000018  0081              LSLS     r1,r0,#2
00001a  f1050008          ADD      r0,r5,#8
00001e  5840              LDR      r0,[r0,r1]
000020  f0200101          BIC      r1,r0,#1
000024  eb040084          ADD      r0,r4,r4,LSL #2
000028  0082              LSLS     r2,r0,#2
00002a  f1050008          ADD      r0,r5,#8
00002e  5081              STR      r1,[r0,r2]
;;;270    }
000030  bd70              POP      {r4-r6,pc}
;;;271    
                          ENDP


                          AREA ||i.dma_channel_enable||, CODE, READONLY, ALIGN=1

                  dma_channel_enable PROC
;;;243    */
;;;244    void dma_channel_enable(uint32_t dma_periph, dma_channel_enum channelx)
000000  b570              PUSH     {r4-r6,lr}
;;;245    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;246        if(ERROR == dma_periph_and_channel_check(dma_periph, channelx)){
000006  4621              MOV      r1,r4
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       dma_periph_and_channel_check
00000e  b908              CBNZ     r0,|L2.20|
;;;247            DMA_WRONG_HANDLE
000010  bf00              NOP      
                  |L2.18|
000012  e7fe              B        |L2.18|
                  |L2.20|
;;;248        }
;;;249        
;;;250        DMA_CHCTL(dma_periph, channelx) |= DMA_CHXCTL_CHEN;
000014  eb040084          ADD      r0,r4,r4,LSL #2
000018  0081              LSLS     r1,r0,#2
00001a  f1050008          ADD      r0,r5,#8
00001e  5840              LDR      r0,[r0,r1]
000020  f0400101          ORR      r1,r0,#1
000024  eb040084          ADD      r0,r4,r4,LSL #2
000028  0082              LSLS     r2,r0,#2
00002a  f1050008          ADD      r0,r5,#8
00002e  5081              STR      r1,[r0,r2]
;;;251    }
000030  bd70              POP      {r4-r6,pc}
;;;252    
                          ENDP


                          AREA ||i.dma_circulation_disable||, CODE, READONLY, ALIGN=1

                  dma_circulation_disable PROC
;;;186    */
;;;187    void dma_circulation_disable(uint32_t dma_periph, dma_channel_enum channelx)
000000  b570              PUSH     {r4-r6,lr}
;;;188    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;189        if(ERROR == dma_periph_and_channel_check(dma_periph, channelx)){
000006  4621              MOV      r1,r4
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       dma_periph_and_channel_check
00000e  b908              CBNZ     r0,|L3.20|
;;;190            DMA_WRONG_HANDLE
000010  bf00              NOP      
                  |L3.18|
000012  e7fe              B        |L3.18|
                  |L3.20|
;;;191        }
;;;192        
;;;193        DMA_CHCTL(dma_periph, channelx) &= ~DMA_CHXCTL_CMEN;
000014  eb040084          ADD      r0,r4,r4,LSL #2
000018  0081              LSLS     r1,r0,#2
00001a  f1050008          ADD      r0,r5,#8
00001e  5840              LDR      r0,[r0,r1]
000020  f0200120          BIC      r1,r0,#0x20
000024  eb040084          ADD      r0,r4,r4,LSL #2
000028  0082              LSLS     r2,r0,#2
00002a  f1050008          ADD      r0,r5,#8
00002e  5081              STR      r1,[r0,r2]
;;;194    }
000030  bd70              POP      {r4-r6,pc}
;;;195    
                          ENDP


                          AREA ||i.dma_circulation_enable||, CODE, READONLY, ALIGN=1

                  dma_circulation_enable PROC
;;;167    */
;;;168    void dma_circulation_enable(uint32_t dma_periph, dma_channel_enum channelx)
000000  b570              PUSH     {r4-r6,lr}
;;;169    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;170        if(ERROR == dma_periph_and_channel_check(dma_periph, channelx)){
000006  4621              MOV      r1,r4
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       dma_periph_and_channel_check
00000e  b908              CBNZ     r0,|L4.20|
;;;171            DMA_WRONG_HANDLE
000010  bf00              NOP      
                  |L4.18|
000012  e7fe              B        |L4.18|
                  |L4.20|
;;;172        }
;;;173    
;;;174        DMA_CHCTL(dma_periph, channelx) |= DMA_CHXCTL_CMEN;
000014  eb040084          ADD      r0,r4,r4,LSL #2
000018  0081              LSLS     r1,r0,#2
00001a  f1050008          ADD      r0,r5,#8
00001e  5840              LDR      r0,[r0,r1]
000020  f0400120          ORR      r1,r0,#0x20
000024  eb040084          ADD      r0,r4,r4,LSL #2
000028  0082              LSLS     r2,r0,#2
00002a  f1050008          ADD      r0,r5,#8
00002e  5081              STR      r1,[r0,r2]
;;;175    }
000030  bd70              POP      {r4-r6,pc}
;;;176    
                          ENDP


                          AREA ||i.dma_deinit||, CODE, READONLY, ALIGN=1

                  dma_deinit PROC
;;;56     */
;;;57     void dma_deinit(uint32_t dma_periph, dma_channel_enum channelx)
000000  b570              PUSH     {r4-r6,lr}
;;;58     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;59         if(ERROR == dma_periph_and_channel_check(dma_periph, channelx)){
000006  4629              MOV      r1,r5
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       dma_periph_and_channel_check
00000e  b908              CBNZ     r0,|L5.20|
;;;60             DMA_WRONG_HANDLE
000010  bf00              NOP      
                  |L5.18|
000012  e7fe              B        |L5.18|
                  |L5.20|
;;;61         }
;;;62         
;;;63         /* disable DMA a channel */
;;;64         DMA_CHCTL(dma_periph, channelx) &= ~DMA_CHXCTL_CHEN;
000014  eb050085          ADD      r0,r5,r5,LSL #2
000018  0081              LSLS     r1,r0,#2
00001a  f1040008          ADD      r0,r4,#8
00001e  5840              LDR      r0,[r0,r1]
000020  f0200101          BIC      r1,r0,#1
000024  eb050085          ADD      r0,r5,r5,LSL #2
000028  0082              LSLS     r2,r0,#2
00002a  f1040008          ADD      r0,r4,#8
00002e  5081              STR      r1,[r0,r2]
;;;65         /* reset DMA channel registers */
;;;66         DMA_CHCTL(dma_periph, channelx) = DMA_CHCTL_RESET_VALUE;
000030  2100              MOVS     r1,#0
000032  eb050085          ADD      r0,r5,r5,LSL #2
000036  0082              LSLS     r2,r0,#2
000038  f1040008          ADD      r0,r4,#8
00003c  5081              STR      r1,[r0,r2]
;;;67         DMA_CHCNT(dma_periph, channelx) = DMA_CHCNT_RESET_VALUE;
00003e  eb050085          ADD      r0,r5,r5,LSL #2
000042  0082              LSLS     r2,r0,#2
000044  f104000c          ADD      r0,r4,#0xc
000048  5081              STR      r1,[r0,r2]
;;;68         DMA_CHPADDR(dma_periph, channelx) = DMA_CHPADDR_RESET_VALUE;
00004a  eb050085          ADD      r0,r5,r5,LSL #2
00004e  0082              LSLS     r2,r0,#2
000050  f1040010          ADD      r0,r4,#0x10
000054  5081              STR      r1,[r0,r2]
;;;69         DMA_CHMADDR(dma_periph, channelx) = DMA_CHMADDR_RESET_VALUE;
000056  eb050085          ADD      r0,r5,r5,LSL #2
00005a  0082              LSLS     r2,r0,#2
00005c  f1040014          ADD      r0,r4,#0x14
000060  5081              STR      r1,[r0,r2]
;;;70         DMA_INTC(dma_periph) |= DMA_FLAG_ADD(DMA_CHINTF_RESET_VALUE, channelx);
000062  6860              LDR      r0,[r4,#4]
000064  00aa              LSLS     r2,r5,#2
000066  210f              MOVS     r1,#0xf
000068  4091              LSLS     r1,r1,r2
00006a  4308              ORRS     r0,r0,r1
00006c  6060              STR      r0,[r4,#4]
;;;71     }
00006e  bd70              POP      {r4-r6,pc}
;;;72     
                          ENDP


                          AREA ||i.dma_flag_clear||, CODE, READONLY, ALIGN=1

                  dma_flag_clear PROC
;;;594    */
;;;595    void dma_flag_clear(uint32_t dma_periph, dma_channel_enum channelx, uint32_t flag)
000000  b510              PUSH     {r4,lr}
;;;596    {
;;;597        DMA_INTC(dma_periph) |= DMA_FLAG_ADD(flag, channelx);
000002  6843              LDR      r3,[r0,#4]
000004  008c              LSLS     r4,r1,#2
000006  fa02f404          LSL      r4,r2,r4
00000a  4323              ORRS     r3,r3,r4
00000c  6043              STR      r3,[r0,#4]
;;;598    }
00000e  bd10              POP      {r4,pc}
;;;599    
                          ENDP


                          AREA ||i.dma_flag_get||, CODE, READONLY, ALIGN=1

                  dma_flag_get PROC
;;;564    */
;;;565    FlagStatus dma_flag_get(uint32_t dma_periph, dma_channel_enum channelx, uint32_t flag)
000000  b530              PUSH     {r4,r5,lr}
;;;566    {
000002  4603              MOV      r3,r0
;;;567        FlagStatus reval;
;;;568    
;;;569        /* check whether the flag is set or not */
;;;570        if(RESET != (DMA_INTF(dma_periph) & DMA_FLAG_ADD(flag, channelx))){
000004  681c              LDR      r4,[r3,#0]
000006  008d              LSLS     r5,r1,#2
000008  fa02f505          LSL      r5,r2,r5
00000c  402c              ANDS     r4,r4,r5
00000e  b10c              CBZ      r4,|L7.20|
;;;571            reval = SET;
000010  2001              MOVS     r0,#1
000012  e000              B        |L7.22|
                  |L7.20|
;;;572        }else{
;;;573            reval = RESET;
000014  2000              MOVS     r0,#0
                  |L7.22|
;;;574        }
;;;575        
;;;576        return reval;
;;;577    }
000016  bd30              POP      {r4,r5,pc}
;;;578    
                          ENDP


                          AREA ||i.dma_init||, CODE, READONLY, ALIGN=1

                  dma_init PROC
;;;112    */
;;;113    void dma_init(uint32_t dma_periph, dma_channel_enum channelx, dma_parameter_struct *init_struct)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;114    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;115        uint32_t ctl;
;;;116        
;;;117        if(ERROR == dma_periph_and_channel_check(dma_periph, channelx)){
00000a  4629              MOV      r1,r5
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       dma_periph_and_channel_check
000012  b908              CBNZ     r0,|L8.24|
;;;118            DMA_WRONG_HANDLE
000014  bf00              NOP      
                  |L8.22|
000016  e7fe              B        |L8.22|
                  |L8.24|
;;;119        }
;;;120        
;;;121        /* configure peripheral base address */
;;;122        DMA_CHPADDR(dma_periph, channelx) = init_struct->periph_addr;
000018  eb050085          ADD      r0,r5,r5,LSL #2
00001c  0082              LSLS     r2,r0,#2
00001e  f1040010          ADD      r0,r4,#0x10
000022  6831              LDR      r1,[r6,#0]
000024  5081              STR      r1,[r0,r2]
;;;123        
;;;124        /* configure memory base address */
;;;125        DMA_CHMADDR(dma_periph, channelx) = init_struct->memory_addr;
000026  eb050085          ADD      r0,r5,r5,LSL #2
00002a  0082              LSLS     r2,r0,#2
00002c  f1040014          ADD      r0,r4,#0x14
000030  68b1              LDR      r1,[r6,#8]
000032  5081              STR      r1,[r0,r2]
;;;126        
;;;127        /* configure the number of remaining data to be transferred */
;;;128        DMA_CHCNT(dma_periph, channelx) = (init_struct->number & DMA_CHANNEL_CNT_MASK);
000034  8a30              LDRH     r0,[r6,#0x10]
000036  b281              UXTH     r1,r0
000038  eb050085          ADD      r0,r5,r5,LSL #2
00003c  0082              LSLS     r2,r0,#2
00003e  f104000c          ADD      r0,r4,#0xc
000042  5081              STR      r1,[r0,r2]
;;;129        
;;;130        /* configure peripheral transfer width,memory transfer width, */
;;;131        ctl = DMA_CHCTL(dma_periph, channelx);
000044  eb050085          ADD      r0,r5,r5,LSL #2
000048  0081              LSLS     r1,r0,#2
00004a  f1040008          ADD      r0,r4,#8
00004e  5847              LDR      r7,[r0,r1]
;;;132        ctl &= ~(DMA_CHXCTL_PWIDTH | DMA_CHXCTL_MWIDTH | DMA_CHXCTL_PRIO);
000050  f427577c          BIC      r7,r7,#0x3f00
;;;133        ctl |= (init_struct->periph_width | init_struct->memory_width | init_struct->priority);
000054  68f1              LDR      r1,[r6,#0xc]
000056  6870              LDR      r0,[r6,#4]
000058  4308              ORRS     r0,r0,r1
00005a  6971              LDR      r1,[r6,#0x14]
00005c  4308              ORRS     r0,r0,r1
00005e  4307              ORRS     r7,r7,r0
;;;134        DMA_CHCTL(dma_periph, channelx) = ctl;
000060  eb050085          ADD      r0,r5,r5,LSL #2
000064  0081              LSLS     r1,r0,#2
000066  f1040008          ADD      r0,r4,#8
00006a  5047              STR      r7,[r0,r1]
;;;135    
;;;136        /* configure peripheral increasing mode */
;;;137        if(DMA_PERIPH_INCREASE_ENABLE == init_struct->periph_inc){
00006c  7e30              LDRB     r0,[r6,#0x18]
00006e  2801              CMP      r0,#1
000070  d10e              BNE      |L8.144|
;;;138            DMA_CHCTL(dma_periph, channelx) |= DMA_CHXCTL_PNAGA;
000072  eb050085          ADD      r0,r5,r5,LSL #2
000076  0081              LSLS     r1,r0,#2
000078  f1040008          ADD      r0,r4,#8
00007c  5840              LDR      r0,[r0,r1]
00007e  f0400140          ORR      r1,r0,#0x40
000082  eb050085          ADD      r0,r5,r5,LSL #2
000086  0082              LSLS     r2,r0,#2
000088  f1040008          ADD      r0,r4,#8
00008c  5081              STR      r1,[r0,r2]
00008e  e00d              B        |L8.172|
                  |L8.144|
;;;139        }else{
;;;140            DMA_CHCTL(dma_periph, channelx) &= ~DMA_CHXCTL_PNAGA;
000090  eb050085          ADD      r0,r5,r5,LSL #2
000094  0081              LSLS     r1,r0,#2
000096  f1040008          ADD      r0,r4,#8
00009a  5840              LDR      r0,[r0,r1]
00009c  f0200140          BIC      r1,r0,#0x40
0000a0  eb050085          ADD      r0,r5,r5,LSL #2
0000a4  0082              LSLS     r2,r0,#2
0000a6  f1040008          ADD      r0,r4,#8
0000aa  5081              STR      r1,[r0,r2]
                  |L8.172|
;;;141        }
;;;142    
;;;143        /* configure memory increasing mode */
;;;144        if(DMA_MEMORY_INCREASE_ENABLE == init_struct->memory_inc){
0000ac  7e70              LDRB     r0,[r6,#0x19]
0000ae  2801              CMP      r0,#1
0000b0  d10e              BNE      |L8.208|
;;;145            DMA_CHCTL(dma_periph, channelx) |= DMA_CHXCTL_MNAGA;
0000b2  eb050085          ADD      r0,r5,r5,LSL #2
0000b6  0081              LSLS     r1,r0,#2
0000b8  f1040008          ADD      r0,r4,#8
0000bc  5840              LDR      r0,[r0,r1]
0000be  f0400180          ORR      r1,r0,#0x80
0000c2  eb050085          ADD      r0,r5,r5,LSL #2
0000c6  0082              LSLS     r2,r0,#2
0000c8  f1040008          ADD      r0,r4,#8
0000cc  5081              STR      r1,[r0,r2]
0000ce  e00d              B        |L8.236|
                  |L8.208|
;;;146        }else{
;;;147            DMA_CHCTL(dma_periph, channelx) &= ~DMA_CHXCTL_MNAGA;
0000d0  eb050085          ADD      r0,r5,r5,LSL #2
0000d4  0081              LSLS     r1,r0,#2
0000d6  f1040008          ADD      r0,r4,#8
0000da  5840              LDR      r0,[r0,r1]
0000dc  f0200180          BIC      r1,r0,#0x80
0000e0  eb050085          ADD      r0,r5,r5,LSL #2
0000e4  0082              LSLS     r2,r0,#2
0000e6  f1040008          ADD      r0,r4,#8
0000ea  5081              STR      r1,[r0,r2]
                  |L8.236|
;;;148        }
;;;149        
;;;150        /* configure the direction of  data transfer */
;;;151        if(DMA_PERIPHERAL_TO_MEMORY == init_struct->direction){
0000ec  7eb0              LDRB     r0,[r6,#0x1a]
0000ee  b970              CBNZ     r0,|L8.270|
;;;152            DMA_CHCTL(dma_periph, channelx) &= ~DMA_CHXCTL_DIR;
0000f0  eb050085          ADD      r0,r5,r5,LSL #2
0000f4  0081              LSLS     r1,r0,#2
0000f6  f1040008          ADD      r0,r4,#8
0000fa  5840              LDR      r0,[r0,r1]
0000fc  f0200110          BIC      r1,r0,#0x10
000100  eb050085          ADD      r0,r5,r5,LSL #2
000104  0082              LSLS     r2,r0,#2
000106  f1040008          ADD      r0,r4,#8
00010a  5081              STR      r1,[r0,r2]
00010c  e00d              B        |L8.298|
                  |L8.270|
;;;153        }else{
;;;154            DMA_CHCTL(dma_periph, channelx) |= DMA_CHXCTL_DIR;
00010e  eb050085          ADD      r0,r5,r5,LSL #2
000112  0081              LSLS     r1,r0,#2
000114  f1040008          ADD      r0,r4,#8
000118  5840              LDR      r0,[r0,r1]
00011a  f0400110          ORR      r1,r0,#0x10
00011e  eb050085          ADD      r0,r5,r5,LSL #2
000122  0082              LSLS     r2,r0,#2
000124  f1040008          ADD      r0,r4,#8
000128  5081              STR      r1,[r0,r2]
                  |L8.298|
;;;155        } 
;;;156    }
00012a  e8bd81f0          POP      {r4-r8,pc}
;;;157    
                          ENDP


                          AREA ||i.dma_interrupt_disable||, CODE, READONLY, ALIGN=1

                  dma_interrupt_disable PROC
;;;706    */
;;;707    void dma_interrupt_disable(uint32_t dma_periph, dma_channel_enum channelx, uint32_t source)
000000  b570              PUSH     {r4-r6,lr}
;;;708    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;709        if(ERROR == dma_periph_and_channel_check(dma_periph, channelx)){
000008  4629              MOV      r1,r5
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       dma_periph_and_channel_check
000010  b908              CBNZ     r0,|L9.22|
;;;710            DMA_WRONG_HANDLE
000012  bf00              NOP      
                  |L9.20|
000014  e7fe              B        |L9.20|
                  |L9.22|
;;;711        }
;;;712        
;;;713        DMA_CHCTL(dma_periph, channelx) &= ~source;
000016  eb050085          ADD      r0,r5,r5,LSL #2
00001a  0081              LSLS     r1,r0,#2
00001c  f1040008          ADD      r0,r4,#8
000020  5840              LDR      r0,[r0,r1]
000022  43b0              BICS     r0,r0,r6
000024  eb050185          ADD      r1,r5,r5,LSL #2
000028  008a              LSLS     r2,r1,#2
00002a  f1040108          ADD      r1,r4,#8
00002e  5088              STR      r0,[r1,r2]
;;;714    }
000030  bd70              POP      {r4-r6,pc}
;;;715    
                          ENDP


                          AREA ||i.dma_interrupt_enable||, CODE, READONLY, ALIGN=1

                  dma_interrupt_enable PROC
;;;682    */
;;;683    void dma_interrupt_enable(uint32_t dma_periph, dma_channel_enum channelx, uint32_t source)
000000  b570              PUSH     {r4-r6,lr}
;;;684    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;685        if(ERROR == dma_periph_and_channel_check(dma_periph, channelx)){
000008  4629              MOV      r1,r5
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       dma_periph_and_channel_check
000010  b908              CBNZ     r0,|L10.22|
;;;686            DMA_WRONG_HANDLE
000012  bf00              NOP      
                  |L10.20|
000014  e7fe              B        |L10.20|
                  |L10.22|
;;;687        }
;;;688        
;;;689        DMA_CHCTL(dma_periph, channelx) |= source;
000016  eb050085          ADD      r0,r5,r5,LSL #2
00001a  0081              LSLS     r1,r0,#2
00001c  f1040008          ADD      r0,r4,#8
000020  5840              LDR      r0,[r0,r1]
000022  4330              ORRS     r0,r0,r6
000024  eb050185          ADD      r1,r5,r5,LSL #2
000028  008a              LSLS     r2,r1,#2
00002a  f1040108          ADD      r1,r4,#8
00002e  5088              STR      r0,[r1,r2]
;;;690    }
000030  bd70              POP      {r4-r6,pc}
;;;691    
                          ENDP


                          AREA ||i.dma_interrupt_flag_clear||, CODE, READONLY, ALIGN=1

                  dma_interrupt_flag_clear PROC
;;;662    */
;;;663    void dma_interrupt_flag_clear(uint32_t dma_periph, dma_channel_enum channelx, uint32_t flag)
000000  b510              PUSH     {r4,lr}
;;;664    {
;;;665        DMA_INTC(dma_periph) |= DMA_FLAG_ADD(flag, channelx);
000002  6843              LDR      r3,[r0,#4]
000004  008c              LSLS     r4,r1,#2
000006  fa02f404          LSL      r4,r2,r4
00000a  4323              ORRS     r3,r3,r4
00000c  6043              STR      r3,[r0,#4]
;;;666    }
00000e  bd10              POP      {r4,pc}
;;;667    
                          ENDP


                          AREA ||i.dma_interrupt_flag_get||, CODE, READONLY, ALIGN=1

                  dma_interrupt_flag_get PROC
;;;614    */
;;;615    FlagStatus dma_interrupt_flag_get(uint32_t dma_periph, dma_channel_enum channelx, uint32_t flag)
000000  b570              PUSH     {r4-r6,lr}
;;;616    {
000002  4603              MOV      r3,r0
;;;617        uint32_t interrupt_enable = 0U, interrupt_flag = 0U;
000004  bf00              NOP      
000006  bf00              NOP      
;;;618        
;;;619        switch(flag){
000008  2a02              CMP      r2,#2
00000a  d004              BEQ      |L12.22|
00000c  2a04              CMP      r2,#4
00000e  d011              BEQ      |L12.52|
000010  2a08              CMP      r2,#8
000012  d12d              BNE      |L12.112|
000014  e01d              B        |L12.82|
                  |L12.22|
;;;620            case DMA_INT_FLAG_FTF:
;;;621                /* check whether the full transfer finish interrupt flag is set and enabled */
;;;622                interrupt_flag = DMA_INTF(dma_periph) & DMA_FLAG_ADD(flag, channelx);
000016  6818              LDR      r0,[r3,#0]
000018  008e              LSLS     r6,r1,#2
00001a  fa02f606          LSL      r6,r2,r6
00001e  ea000506          AND      r5,r0,r6
;;;623                interrupt_enable = DMA_CHCTL(dma_periph, channelx) & DMA_CHXCTL_FTFIE;
000022  eb010081          ADD      r0,r1,r1,LSL #2
000026  0086              LSLS     r6,r0,#2
000028  f1030008          ADD      r0,r3,#8
00002c  5980              LDR      r0,[r0,r6]
00002e  f0000402          AND      r4,r0,#2
;;;624                break;
000032  e01f              B        |L12.116|
                  |L12.52|
;;;625            case DMA_INT_FLAG_HTF:
;;;626                /* check whether the half transfer finish interrupt flag is set and enabled */
;;;627                interrupt_flag = DMA_INTF(dma_periph) & DMA_FLAG_ADD(flag, channelx);
000034  6818              LDR      r0,[r3,#0]
000036  008e              LSLS     r6,r1,#2
000038  fa02f606          LSL      r6,r2,r6
00003c  ea000506          AND      r5,r0,r6
;;;628                interrupt_enable = DMA_CHCTL(dma_periph, channelx) & DMA_CHXCTL_HTFIE;
000040  eb010081          ADD      r0,r1,r1,LSL #2
000044  0086              LSLS     r6,r0,#2
000046  f1030008          ADD      r0,r3,#8
00004a  5980              LDR      r0,[r0,r6]
00004c  f0000404          AND      r4,r0,#4
;;;629                break;
000050  e010              B        |L12.116|
                  |L12.82|
;;;630            case DMA_INT_FLAG_ERR:
;;;631                /* check whether the error interrupt flag is set and enabled */
;;;632                interrupt_flag = DMA_INTF(dma_periph) & DMA_FLAG_ADD(flag, channelx);
000052  6818              LDR      r0,[r3,#0]
000054  008e              LSLS     r6,r1,#2
000056  fa02f606          LSL      r6,r2,r6
00005a  ea000506          AND      r5,r0,r6
;;;633                interrupt_enable = DMA_CHCTL(dma_periph, channelx) & DMA_CHXCTL_ERRIE;
00005e  eb010081          ADD      r0,r1,r1,LSL #2
000062  0086              LSLS     r6,r0,#2
000064  f1030008          ADD      r0,r3,#8
000068  5980              LDR      r0,[r0,r6]
00006a  f0000408          AND      r4,r0,#8
;;;634                break;
00006e  e001              B        |L12.116|
                  |L12.112|
;;;635            default:
;;;636                DMA_WRONG_HANDLE
000070  bf00              NOP      
                  |L12.114|
000072  e7fe              B        |L12.114|
                  |L12.116|
000074  bf00              NOP                            ;624
;;;637            }
;;;638        
;;;639        /* when the interrupt flag is set and enabled, return SET */    
;;;640        if(interrupt_flag && interrupt_enable){
000076  b115              CBZ      r5,|L12.126|
000078  b10c              CBZ      r4,|L12.126|
;;;641            return SET;
00007a  2001              MOVS     r0,#1
                  |L12.124|
;;;642        }else{
;;;643            return RESET;
;;;644        }
;;;645    }
00007c  bd70              POP      {r4-r6,pc}
                  |L12.126|
00007e  2000              MOVS     r0,#0                 ;643
000080  e7fc              B        |L12.124|
;;;646    
                          ENDP


                          AREA ||i.dma_memory_address_config||, CODE, READONLY, ALIGN=1

                  dma_memory_address_config PROC
;;;302    */
;;;303    void dma_memory_address_config(uint32_t dma_periph, dma_channel_enum channelx, uint32_t address)
000000  b570              PUSH     {r4-r6,lr}
;;;304    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;305        if(ERROR == dma_periph_and_channel_check(dma_periph, channelx)){
000008  4621              MOV      r1,r4
00000a  4630              MOV      r0,r6
00000c  f7fffffe          BL       dma_periph_and_channel_check
000010  b908              CBNZ     r0,|L13.22|
;;;306            DMA_WRONG_HANDLE
000012  bf00              NOP      
                  |L13.20|
000014  e7fe              B        |L13.20|
                  |L13.22|
;;;307        }
;;;308        
;;;309        DMA_CHMADDR(dma_periph, channelx) = address;
000016  eb040084          ADD      r0,r4,r4,LSL #2
00001a  0081              LSLS     r1,r0,#2
00001c  f1060014          ADD      r0,r6,#0x14
000020  5045              STR      r5,[r0,r1]
;;;310    }
000022  bd70              POP      {r4-r6,pc}
;;;311    
                          ENDP


                          AREA ||i.dma_memory_increase_disable||, CODE, READONLY, ALIGN=1

                  dma_memory_increase_disable PROC
;;;474    */
;;;475    void dma_memory_increase_disable(uint32_t dma_periph, dma_channel_enum channelx)
000000  b570              PUSH     {r4-r6,lr}
;;;476    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;477        if(ERROR == dma_periph_and_channel_check(dma_periph, channelx)){
000006  4621              MOV      r1,r4
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       dma_periph_and_channel_check
00000e  b908              CBNZ     r0,|L14.20|
;;;478            DMA_WRONG_HANDLE
000010  bf00              NOP      
                  |L14.18|
000012  e7fe              B        |L14.18|
                  |L14.20|
;;;479        }
;;;480        
;;;481        DMA_CHCTL(dma_periph, channelx) &= ~DMA_CHXCTL_MNAGA;
000014  eb040084          ADD      r0,r4,r4,LSL #2
000018  0081              LSLS     r1,r0,#2
00001a  f1050008          ADD      r0,r5,#8
00001e  5840              LDR      r0,[r0,r1]
000020  f0200180          BIC      r1,r0,#0x80
000024  eb040084          ADD      r0,r4,r4,LSL #2
000028  0082              LSLS     r2,r0,#2
00002a  f1050008          ADD      r0,r5,#8
00002e  5081              STR      r1,[r0,r2]
;;;482    }
000030  bd70              POP      {r4-r6,pc}
;;;483    
                          ENDP


                          AREA ||i.dma_memory_increase_enable||, CODE, READONLY, ALIGN=1

                  dma_memory_increase_enable PROC
;;;455    */
;;;456    void dma_memory_increase_enable(uint32_t dma_periph, dma_channel_enum channelx)
000000  b570              PUSH     {r4-r6,lr}
;;;457    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;458        if(ERROR == dma_periph_and_channel_check(dma_periph, channelx)){
000006  4621              MOV      r1,r4
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       dma_periph_and_channel_check
00000e  b908              CBNZ     r0,|L15.20|
;;;459            DMA_WRONG_HANDLE
000010  bf00              NOP      
                  |L15.18|
000012  e7fe              B        |L15.18|
                  |L15.20|
;;;460        }
;;;461        
;;;462        DMA_CHCTL(dma_periph, channelx) |= DMA_CHXCTL_MNAGA;
000014  eb040084          ADD      r0,r4,r4,LSL #2
000018  0081              LSLS     r1,r0,#2
00001a  f1050008          ADD      r0,r5,#8
00001e  5840              LDR      r0,[r0,r1]
000020  f0400180          ORR      r1,r0,#0x80
000024  eb040084          ADD      r0,r4,r4,LSL #2
000028  0082              LSLS     r2,r0,#2
00002a  f1050008          ADD      r0,r5,#8
00002e  5081              STR      r1,[r0,r2]
;;;463    }
000030  bd70              POP      {r4-r6,pc}
;;;464    
                          ENDP


                          AREA ||i.dma_memory_to_memory_disable||, CODE, READONLY, ALIGN=1

                  dma_memory_to_memory_disable PROC
;;;224    */
;;;225    void dma_memory_to_memory_disable(uint32_t dma_periph, dma_channel_enum channelx)
000000  b570              PUSH     {r4-r6,lr}
;;;226    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;227        if(ERROR == dma_periph_and_channel_check(dma_periph, channelx)){
000006  4621              MOV      r1,r4
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       dma_periph_and_channel_check
00000e  b908              CBNZ     r0,|L16.20|
;;;228            DMA_WRONG_HANDLE
000010  bf00              NOP      
                  |L16.18|
000012  e7fe              B        |L16.18|
                  |L16.20|
;;;229        }
;;;230        
;;;231        DMA_CHCTL(dma_periph, channelx) &= ~DMA_CHXCTL_M2M;
000014  eb040084          ADD      r0,r4,r4,LSL #2
000018  0081              LSLS     r1,r0,#2
00001a  f1050008          ADD      r0,r5,#8
00001e  5840              LDR      r0,[r0,r1]
000020  f4204180          BIC      r1,r0,#0x4000
000024  eb040084          ADD      r0,r4,r4,LSL #2
000028  0082              LSLS     r2,r0,#2
00002a  f1050008          ADD      r0,r5,#8
00002e  5081              STR      r1,[r0,r2]
;;;232    }
000030  bd70              POP      {r4-r6,pc}
;;;233    
                          ENDP


                          AREA ||i.dma_memory_to_memory_enable||, CODE, READONLY, ALIGN=1

                  dma_memory_to_memory_enable PROC
;;;205    */
;;;206    void dma_memory_to_memory_enable(uint32_t dma_periph, dma_channel_enum channelx)
000000  b570              PUSH     {r4-r6,lr}
;;;207    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;208        if(ERROR == dma_periph_and_channel_check(dma_periph, channelx)){
000006  4621              MOV      r1,r4
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       dma_periph_and_channel_check
00000e  b908              CBNZ     r0,|L17.20|
;;;209            DMA_WRONG_HANDLE
000010  bf00              NOP      
                  |L17.18|
000012  e7fe              B        |L17.18|
                  |L17.20|
;;;210        }
;;;211        
;;;212        DMA_CHCTL(dma_periph, channelx) |= DMA_CHXCTL_M2M;
000014  eb040084          ADD      r0,r4,r4,LSL #2
000018  0081              LSLS     r1,r0,#2
00001a  f1050008          ADD      r0,r5,#8
00001e  5840              LDR      r0,[r0,r1]
000020  f4404180          ORR      r1,r0,#0x4000
000024  eb040084          ADD      r0,r4,r4,LSL #2
000028  0082              LSLS     r2,r0,#2
00002a  f1050008          ADD      r0,r5,#8
00002e  5081              STR      r1,[r0,r2]
;;;213    }
000030  bd70              POP      {r4-r6,pc}
;;;214    
                          ENDP


                          AREA ||i.dma_memory_width_config||, CODE, READONLY, ALIGN=1

                  dma_memory_width_config PROC
;;;398    */
;;;399    void dma_memory_width_config(uint32_t dma_periph, dma_channel_enum channelx, uint32_t mwidth)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;400    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
;;;401        uint32_t ctl;
;;;402        
;;;403        if(ERROR == dma_periph_and_channel_check(dma_periph, channelx)){
00000a  4629              MOV      r1,r5
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       dma_periph_and_channel_check
000012  b908              CBNZ     r0,|L18.24|
;;;404            DMA_WRONG_HANDLE
000014  bf00              NOP      
                  |L18.22|
000016  e7fe              B        |L18.22|
                  |L18.24|
;;;405        }
;;;406        
;;;407        /* acquire DMA_CHxCTL register */
;;;408        ctl = DMA_CHCTL(dma_periph, channelx);
000018  eb050085          ADD      r0,r5,r5,LSL #2
00001c  0081              LSLS     r1,r0,#2
00001e  f1040008          ADD      r0,r4,#8
000022  5846              LDR      r6,[r0,r1]
;;;409        /* assign regiser */
;;;410        ctl &= ~DMA_CHXCTL_MWIDTH;
000024  f4266640          BIC      r6,r6,#0xc00
;;;411        ctl |= mwidth;
000028  433e              ORRS     r6,r6,r7
;;;412        DMA_CHCTL(dma_periph, channelx) = ctl;
00002a  eb050085          ADD      r0,r5,r5,LSL #2
00002e  0081              LSLS     r1,r0,#2
000030  f1040008          ADD      r0,r4,#8
000034  5046              STR      r6,[r0,r1]
;;;413    }
000036  e8bd81f0          POP      {r4-r8,pc}
;;;414    
                          ENDP


                          AREA ||i.dma_periph_address_config||, CODE, READONLY, ALIGN=1

                  dma_periph_address_config PROC
;;;282    */
;;;283    void dma_periph_address_config(uint32_t dma_periph, dma_channel_enum channelx, uint32_t address)
000000  b570              PUSH     {r4-r6,lr}
;;;284    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;285        if(ERROR == dma_periph_and_channel_check(dma_periph, channelx)){
000008  4621              MOV      r1,r4
00000a  4630              MOV      r0,r6
00000c  f7fffffe          BL       dma_periph_and_channel_check
000010  b908              CBNZ     r0,|L19.22|
;;;286            DMA_WRONG_HANDLE
000012  bf00              NOP      
                  |L19.20|
000014  e7fe              B        |L19.20|
                  |L19.22|
;;;287        }
;;;288        
;;;289        DMA_CHPADDR(dma_periph, channelx) = address;
000016  eb040084          ADD      r0,r4,r4,LSL #2
00001a  0081              LSLS     r1,r0,#2
00001c  f1060010          ADD      r0,r6,#0x10
000020  5045              STR      r5,[r0,r1]
;;;290    }
000022  bd70              POP      {r4-r6,pc}
;;;291    
                          ENDP


                          AREA ||i.dma_periph_and_channel_check||, CODE, READONLY, ALIGN=2

                  dma_periph_and_channel_check PROC
;;;725    */
;;;726    static ErrStatus dma_periph_and_channel_check(uint32_t dma_periph, dma_channel_enum channelx)
000000  4602              MOV      r2,r0
;;;727    {
;;;728        ErrStatus val = SUCCESS;
000002  2001              MOVS     r0,#1
;;;729        
;;;730        if(DMA1 == dma_periph){
000004  4b03              LDR      r3,|L20.20|
000006  429a              CMP      r2,r3
000008  d102              BNE      |L20.16|
;;;731            /* for DMA1, the channel is from DMA_CH0 to DMA_CH4 */
;;;732            if(channelx > DMA_CH4){
00000a  2904              CMP      r1,#4
00000c  dd00              BLE      |L20.16|
;;;733                val = ERROR;
00000e  2000              MOVS     r0,#0
                  |L20.16|
;;;734            }
;;;735        }
;;;736        
;;;737        return val;
;;;738    }
000010  4770              BX       lr
                          ENDP

000012  0000              DCW      0x0000
                  |L20.20|
                          DCD      0x40020400

                          AREA ||i.dma_periph_increase_disable||, CODE, READONLY, ALIGN=1

                  dma_periph_increase_disable PROC
;;;512    */
;;;513    void dma_periph_increase_disable(uint32_t dma_periph, dma_channel_enum channelx)
000000  b570              PUSH     {r4-r6,lr}
;;;514    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;515        if(ERROR == dma_periph_and_channel_check(dma_periph, channelx)){
000006  4621              MOV      r1,r4
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       dma_periph_and_channel_check
00000e  b908              CBNZ     r0,|L21.20|
;;;516            DMA_WRONG_HANDLE
000010  bf00              NOP      
                  |L21.18|
000012  e7fe              B        |L21.18|
                  |L21.20|
;;;517        }
;;;518        
;;;519        DMA_CHCTL(dma_periph, channelx) &= ~DMA_CHXCTL_PNAGA;
000014  eb040084          ADD      r0,r4,r4,LSL #2
000018  0081              LSLS     r1,r0,#2
00001a  f1050008          ADD      r0,r5,#8
00001e  5840              LDR      r0,[r0,r1]
000020  f0200140          BIC      r1,r0,#0x40
000024  eb040084          ADD      r0,r4,r4,LSL #2
000028  0082              LSLS     r2,r0,#2
00002a  f1050008          ADD      r0,r5,#8
00002e  5081              STR      r1,[r0,r2]
;;;520    }
000030  bd70              POP      {r4-r6,pc}
;;;521    
                          ENDP


                          AREA ||i.dma_periph_increase_enable||, CODE, READONLY, ALIGN=1

                  dma_periph_increase_enable PROC
;;;493    */
;;;494    void dma_periph_increase_enable(uint32_t dma_periph, dma_channel_enum channelx)
000000  b570              PUSH     {r4-r6,lr}
;;;495    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;496        if(ERROR == dma_periph_and_channel_check(dma_periph, channelx)){
000006  4621              MOV      r1,r4
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       dma_periph_and_channel_check
00000e  b908              CBNZ     r0,|L22.20|
;;;497            DMA_WRONG_HANDLE
000010  bf00              NOP      
                  |L22.18|
000012  e7fe              B        |L22.18|
                  |L22.20|
;;;498        }
;;;499        
;;;500        DMA_CHCTL(dma_periph, channelx) |= DMA_CHXCTL_PNAGA;
000014  eb040084          ADD      r0,r4,r4,LSL #2
000018  0081              LSLS     r1,r0,#2
00001a  f1050008          ADD      r0,r5,#8
00001e  5840              LDR      r0,[r0,r1]
000020  f0400140          ORR      r1,r0,#0x40
000024  eb040084          ADD      r0,r4,r4,LSL #2
000028  0082              LSLS     r2,r0,#2
00002a  f1050008          ADD      r0,r5,#8
00002e  5081              STR      r1,[r0,r2]
;;;501    }
000030  bd70              POP      {r4-r6,pc}
;;;502    
                          ENDP


                          AREA ||i.dma_periph_width_config||, CODE, READONLY, ALIGN=1

                  dma_periph_width_config PROC
;;;429    */
;;;430    void dma_periph_width_config(uint32_t dma_periph, dma_channel_enum channelx, uint32_t pwidth)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;431    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
;;;432        uint32_t ctl;
;;;433        
;;;434        if(ERROR == dma_periph_and_channel_check(dma_periph, channelx)){
00000a  4629              MOV      r1,r5
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       dma_periph_and_channel_check
000012  b908              CBNZ     r0,|L23.24|
;;;435            DMA_WRONG_HANDLE
000014  bf00              NOP      
                  |L23.22|
000016  e7fe              B        |L23.22|
                  |L23.24|
;;;436        }
;;;437        
;;;438        /* acquire DMA_CHxCTL register */
;;;439        ctl = DMA_CHCTL(dma_periph, channelx);
000018  eb050085          ADD      r0,r5,r5,LSL #2
00001c  0081              LSLS     r1,r0,#2
00001e  f1040008          ADD      r0,r4,#8
000022  5846              LDR      r6,[r0,r1]
;;;440        /* assign regiser */
;;;441        ctl &= ~DMA_CHXCTL_PWIDTH;
000024  f4267640          BIC      r6,r6,#0x300
;;;442        ctl |= pwidth;
000028  433e              ORRS     r6,r6,r7
;;;443        DMA_CHCTL(dma_periph, channelx) = ctl;
00002a  eb050085          ADD      r0,r5,r5,LSL #2
00002e  0081              LSLS     r1,r0,#2
000030  f1040008          ADD      r0,r4,#8
000034  5046              STR      r6,[r0,r1]
;;;444    }
000036  e8bd81f0          POP      {r4-r8,pc}
;;;445    
                          ENDP


                          AREA ||i.dma_priority_config||, CODE, READONLY, ALIGN=1

                  dma_priority_config PROC
;;;367    */
;;;368    void dma_priority_config(uint32_t dma_periph, dma_channel_enum channelx, uint32_t priority)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;369    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
;;;370        uint32_t ctl;
;;;371        
;;;372        if(ERROR == dma_periph_and_channel_check(dma_periph, channelx)){
00000a  4629              MOV      r1,r5
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       dma_periph_and_channel_check
000012  b908              CBNZ     r0,|L24.24|
;;;373            DMA_WRONG_HANDLE
000014  bf00              NOP      
                  |L24.22|
000016  e7fe              B        |L24.22|
                  |L24.24|
;;;374        }
;;;375        
;;;376        /* acquire DMA_CHxCTL register */
;;;377        ctl = DMA_CHCTL(dma_periph, channelx);
000018  eb050085          ADD      r0,r5,r5,LSL #2
00001c  0081              LSLS     r1,r0,#2
00001e  f1040008          ADD      r0,r4,#8
000022  5846              LDR      r6,[r0,r1]
;;;378        /* assign regiser */
;;;379        ctl &= ~DMA_CHXCTL_PRIO;
000024  f4265640          BIC      r6,r6,#0x3000
;;;380        ctl |= priority;
000028  433e              ORRS     r6,r6,r7
;;;381        DMA_CHCTL(dma_periph, channelx) = ctl;
00002a  eb050085          ADD      r0,r5,r5,LSL #2
00002e  0081              LSLS     r1,r0,#2
000030  f1040008          ADD      r0,r4,#8
000034  5046              STR      r6,[r0,r1]
;;;382    }
000036  e8bd81f0          POP      {r4-r8,pc}
;;;383    
                          ENDP


                          AREA ||i.dma_struct_para_init||, CODE, READONLY, ALIGN=1

                  dma_struct_para_init PROC
;;;78     */
;;;79     void dma_struct_para_init(dma_parameter_struct* init_struct)
000000  2100              MOVS     r1,#0
;;;80     {
;;;81         /* set the DMA struct with the default values */
;;;82         init_struct->periph_addr  = 0U;
000002  6001              STR      r1,[r0,#0]
;;;83         init_struct->periph_width = 0U; 
000004  6041              STR      r1,[r0,#4]
;;;84         init_struct->periph_inc   = DMA_PERIPH_INCREASE_DISABLE;
000006  7601              STRB     r1,[r0,#0x18]
;;;85         init_struct->memory_addr  = 0U;
000008  6081              STR      r1,[r0,#8]
;;;86         init_struct->memory_width = 0U;
00000a  60c1              STR      r1,[r0,#0xc]
;;;87         init_struct->memory_inc   = DMA_MEMORY_INCREASE_DISABLE;
00000c  7641              STRB     r1,[r0,#0x19]
;;;88         init_struct->number       = 0U;
00000e  6101              STR      r1,[r0,#0x10]
;;;89         init_struct->direction    = DMA_PERIPHERAL_TO_MEMORY;
000010  7681              STRB     r1,[r0,#0x1a]
;;;90         init_struct->priority     = DMA_PRIORITY_LOW;
000012  6141              STR      r1,[r0,#0x14]
;;;91     }
000014  4770              BX       lr
;;;92     
                          ENDP


                          AREA ||i.dma_transfer_direction_config||, CODE, READONLY, ALIGN=1

                  dma_transfer_direction_config PROC
;;;535    */
;;;536    void dma_transfer_direction_config(uint32_t dma_periph, dma_channel_enum channelx, uint8_t direction)
000000  b570              PUSH     {r4-r6,lr}
;;;537    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;538        if(ERROR == dma_periph_and_channel_check(dma_periph, channelx)){
000008  4629              MOV      r1,r5
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       dma_periph_and_channel_check
000010  b908              CBNZ     r0,|L26.22|
;;;539            DMA_WRONG_HANDLE
000012  bf00              NOP      
                  |L26.20|
000014  e7fe              B        |L26.20|
                  |L26.22|
;;;540        }
;;;541        
;;;542        if(DMA_PERIPHERAL_TO_MEMORY == direction){
000016  b976              CBNZ     r6,|L26.54|
;;;543            DMA_CHCTL(dma_periph, channelx) &= ~DMA_CHXCTL_DIR;
000018  eb050085          ADD      r0,r5,r5,LSL #2
00001c  0081              LSLS     r1,r0,#2
00001e  f1040008          ADD      r0,r4,#8
000022  5840              LDR      r0,[r0,r1]
000024  f0200110          BIC      r1,r0,#0x10
000028  eb050085          ADD      r0,r5,r5,LSL #2
00002c  0082              LSLS     r2,r0,#2
00002e  f1040008          ADD      r0,r4,#8
000032  5081              STR      r1,[r0,r2]
000034  e00d              B        |L26.82|
                  |L26.54|
;;;544        } else {
;;;545            DMA_CHCTL(dma_periph, channelx) |= DMA_CHXCTL_DIR;
000036  eb050085          ADD      r0,r5,r5,LSL #2
00003a  0081              LSLS     r1,r0,#2
00003c  f1040008          ADD      r0,r4,#8
000040  5840              LDR      r0,[r0,r1]
000042  f0400110          ORR      r1,r0,#0x10
000046  eb050085          ADD      r0,r5,r5,LSL #2
00004a  0082              LSLS     r2,r0,#2
00004c  f1040008          ADD      r0,r4,#8
000050  5081              STR      r1,[r0,r2]
                  |L26.82|
;;;546        }
;;;547    }
000052  bd70              POP      {r4-r6,pc}
;;;548    
                          ENDP


                          AREA ||i.dma_transfer_number_config||, CODE, READONLY, ALIGN=1

                  dma_transfer_number_config PROC
;;;323    */
;;;324    void dma_transfer_number_config(uint32_t dma_periph, dma_channel_enum channelx, uint32_t number)
000000  b570              PUSH     {r4-r6,lr}
;;;325    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;326        if(ERROR == dma_periph_and_channel_check(dma_periph, channelx)){
000008  4621              MOV      r1,r4
00000a  4630              MOV      r0,r6
00000c  f7fffffe          BL       dma_periph_and_channel_check
000010  b908              CBNZ     r0,|L27.22|
;;;327            DMA_WRONG_HANDLE
000012  bf00              NOP      
                  |L27.20|
000014  e7fe              B        |L27.20|
                  |L27.22|
;;;328        }
;;;329        
;;;330        DMA_CHCNT(dma_periph, channelx) = (number & DMA_CHANNEL_CNT_MASK);
000016  b2a9              UXTH     r1,r5
000018  eb040084          ADD      r0,r4,r4,LSL #2
00001c  0082              LSLS     r2,r0,#2
00001e  f106000c          ADD      r0,r6,#0xc
000022  5081              STR      r1,[r0,r2]
;;;331    }
000024  bd70              POP      {r4-r6,pc}
;;;332    
                          ENDP


                          AREA ||i.dma_transfer_number_get||, CODE, READONLY, ALIGN=1

                  dma_transfer_number_get PROC
;;;342    */
;;;343    uint32_t dma_transfer_number_get(uint32_t dma_periph, dma_channel_enum channelx)
000000  b570              PUSH     {r4-r6,lr}
;;;344    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;345        if(ERROR == dma_periph_and_channel_check(dma_periph, channelx)){
000006  4621              MOV      r1,r4
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       dma_periph_and_channel_check
00000e  b908              CBNZ     r0,|L28.20|
;;;346            DMA_WRONG_HANDLE
000010  bf00              NOP      
                  |L28.18|
000012  e7fe              B        |L28.18|
                  |L28.20|
;;;347        }
;;;348        
;;;349        return (uint32_t)DMA_CHCNT(dma_periph, channelx);
000014  eb040084          ADD      r0,r4,r4,LSL #2
000018  0081              LSLS     r1,r0,#2
00001a  f105000c          ADD      r0,r5,#0xc
00001e  5840              LDR      r0,[r0,r1]
;;;350    }
000020  bd70              POP      {r4-r6,pc}
;;;351    
                          ENDP


;*** Start embedded assembler ***

#line 1 "Libraries\\src\\gd32f10x_dma.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_gd32f10x_dma_c_7af11ded____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___14_gd32f10x_dma_c_7af11ded____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_gd32f10x_dma_c_7af11ded____REVSH|
#line 128
|__asm___14_gd32f10x_dma_c_7af11ded____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
