; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\canprotocoluptest.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\canprotocoluptest.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -I.\User\qrencode -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.3\Device\Include -D__MICROLIB -D__UVISION_VERSION=539 -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\canprotocoluptest.crf User\CanProtocolUpTEST.c]
                          THUMB

                          AREA ||i.CAN_TEST_PROTOCOL_CALLBACK_UartBusError||, CODE, READONLY, ALIGN=1

                  CAN_TEST_PROTOCOL_CALLBACK_UartBusError PROC
;;;602    // 	UART总线超时错误处理
;;;603    void CAN_TEST_PROTOCOL_CALLBACK_UartBusError(uint32 param)
000000  4770              BX       lr
;;;604    {
;;;605    
;;;606    }
;;;607    
                          ENDP


                          AREA ||i.CAN_TEST_PROTOCOL_CheckSUM||, CODE, READONLY, ALIGN=1

                  CAN_TEST_PROTOCOL_CheckSUM PROC
;;;455    // 对传入的命令帧进行校验，返回校验结果
;;;456    BOOL CAN_TEST_PROTOCOL_CheckSUM(CAN_TEST_PROTOCOL_RX_CMD_FRAME* pCmdFrame)
000000  b530              PUSH     {r4,r5,lr}
;;;457    {
000002  4601              MOV      r1,r0
;;;458    	uint16 checkSum = 0;
000004  2300              MOVS     r3,#0
;;;459    	uint16 sumTemp;
;;;460    	uint16 i = 0;
000006  2200              MOVS     r2,#0
;;;461        
;;;462        uint8 length = pCmdFrame->length;
000008  f89140a2          LDRB     r4,[r1,#0xa2]
;;;463    	
;;;464    	if(NULL == pCmdFrame)
00000c  b909              CBNZ     r1,|L2.18|
;;;465    	{
;;;466    		return FALSE;
00000e  2000              MOVS     r0,#0
                  |L2.16|
;;;467    	}
;;;468    
;;;469    	// 从起始符开始，到校验码之前的一个字节，依次进行异或运算
;;;470    	for(i = 0; i < pCmdFrame->length - 1; i++)
;;;471    	{
;;;472    		checkSum ^= pCmdFrame->buff[i];
;;;473    	}
;;;474    	
;;;475    	// 判断计算得到的校验码与命令帧中的校验码是否相同
;;;476    	if(pCmdFrame->buff[pCmdFrame->length-1] != checkSum)
;;;477    	{
;;;478    		return FALSE;
;;;479    	}
;;;480    	
;;;481    	return TRUE;
;;;482    }
000010  bd30              POP      {r4,r5,pc}
                  |L2.18|
000012  2200              MOVS     r2,#0                 ;470
000014  e004              B        |L2.32|
                  |L2.22|
000016  1c88              ADDS     r0,r1,#2              ;472
000018  5c80              LDRB     r0,[r0,r2]            ;472
00001a  4043              EORS     r3,r3,r0              ;472
00001c  1c50              ADDS     r0,r2,#1              ;470
00001e  b282              UXTH     r2,r0                 ;470
                  |L2.32|
000020  f8b100a2          LDRH     r0,[r1,#0xa2]         ;470
000024  1e40              SUBS     r0,r0,#1              ;470
000026  4290              CMP      r0,r2                 ;470
000028  dcf5              BGT      |L2.22|
00002a  f8b100a2          LDRH     r0,[r1,#0xa2]         ;476
00002e  1e40              SUBS     r0,r0,#1              ;476
000030  1c8d              ADDS     r5,r1,#2              ;476
000032  5c28              LDRB     r0,[r5,r0]            ;476
000034  4298              CMP      r0,r3                 ;476
000036  d001              BEQ      |L2.60|
000038  2000              MOVS     r0,#0                 ;478
00003a  e7e9              B        |L2.16|
                  |L2.60|
00003c  2001              MOVS     r0,#1                 ;481
00003e  e7e7              B        |L2.16|
;;;483    
                          ENDP


                          AREA ||i.CAN_TEST_PROTOCOL_CmdFrameProcess||, CODE, READONLY, ALIGN=2

                  CAN_TEST_PROTOCOL_CmdFrameProcess PROC
;;;484    // UART命令帧缓冲区处理
;;;485    void CAN_TEST_PROTOCOL_CmdFrameProcess(CAN_TEST_PROTOCOL_CB* pCB)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;486    {
000004  4604              MOV      r4,r0
;;;487    	CAN_TEST_PROTOCOL_CMD cmd = CAN_TEST_PROTOCOL_CMD_NULL;
000006  2700              MOVS     r7,#0
;;;488    	CAN_TEST_PROTOCOL_RX_CMD_FRAME* pCmdFrame = NULL;
000008  2500              MOVS     r5,#0
;;;489        
;;;490        uint8 eraResual;
;;;491        uint32 temp = 0;
00000a  46a8              MOV      r8,r5
;;;492        uint16 length = 0;	
00000c  46a9              MOV      r9,r5
;;;493        
;;;494    	// 参数合法性检验
;;;495    	if(NULL == pCB)
00000e  b90c              CBNZ     r4,|L3.20|
                  |L3.16|
;;;496    	{
;;;497    		return;
;;;498    	}
;;;499    
;;;500    	// 命令帧缓冲区为空，退出
;;;501    	if(pCB->rx.head == pCB->rx.end)
;;;502    	{
;;;503    		return;
;;;504    	}
;;;505    
;;;506    	// 获取当前要处理的命令帧指针
;;;507    	pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.head];
;;;508    	
;;;509    	// 命令头非法，退出
;;;510    	if(CAN_TEST_PROTOCOL_CMD_HEAD != pCmdFrame->buff[CAN_TEST_PROTOCOL_CMD_HEAD_INDEX])
;;;511    	{
;;;512    		// 删除命令帧
;;;513    		pCB->rx.head ++;
;;;514    		pCB->rx.head %= CAN_TEST_PROTOCOL_RX_QUEUE_SIZE;
;;;515    		return;
;;;516    	}
;;;517    
;;;518    	// 命令头合法，则提取命令
;;;519    	cmd = (CAN_TEST_PROTOCOL_CMD)pCmdFrame->buff[CAN_TEST_PROTOCOL_CMD_INDEX];
;;;520    
;;;521    	// 执行命令帧
;;;522    	switch(cmd)
;;;523    	{
;;;524    		// 空命令，不予执行
;;;525    		case CAN_TEST_PROTOCOL_CMD_NULL:
;;;526    			break;
;;;527    
;;;528            case CAN_TEST_PROTOCOL_CMD_BOOT_ERASE_FLASH: 			        // DUT_BOOT擦除
;;;529                eraResual = pCmdFrame->buff[CAN_TEST_PROTOCOL_CMD_DATA1_INDEX];
;;;530                
;;;531                // 擦除失败
;;;532                if (0 == eraResual)
;;;533                {
;;;534                    // 擦除失败再擦除一次
;;;535                    STATE_SwitchStep(STEP_CM_CAN_BC_UPGRADE_SEND_BOOT_EAR);
;;;536                    break;
;;;537                }
;;;538    
;;;539                // 发送BOOT数据
;;;540                dut_info.currentBootSize = 0;
;;;541                TIMER_KillTask(TIMER_ID_UPGRADE_DUT_BOOT);
;;;542                STATE_SwitchStep(STEP_CM_CAN_BC_UPGRADE_SEND_BOOT_PACKET);                
;;;543                break;
;;;544                
;;;545            case CAN_TEST_PROTOCOL_CMD_BOOT_WRITE_FLASH: 				    // DUT_BOOT写入
;;;546                eraResual = pCmdFrame->buff[CAN_TEST_PROTOCOL_CMD_DATA1_INDEX];
;;;547    
;;;548                if (0 == eraResual) // 如果仪表写入失败就退出
;;;549                {
;;;550                    dut_info.currentBootSize--;
;;;551                }
;;;552                if (dut_info.currentBootSize < dut_info.bootSize)
;;;553                {
;;;554                    STATE_SwitchStep(STEP_CM_CAN_BC_UPGRADE_SEND_BOOT_PACKET);
;;;555                }
;;;556                else
;;;557                {
;;;558                    STATE_SwitchStep(STEP_CM_CAN_BC_UPGRADE_BOOT_UP_SUCCESS);
;;;559                }                
;;;560                break;
;;;561                
;;;562            case CAN_TEST_PROTOCOL_CMD_BOOT_UPDATA_FINISH: 		            	// DUT_BOOT写入完成
;;;563                STATE_SwitchStep(STEP_CM_CAN_UPGRADE_ITEM_FINISH);
;;;564                break;    
;;;565                        
;;;566            default:
;;;567                break;
;;;568    	}
;;;569    
;;;570    	// 启动UART总线通讯超时判断
;;;571    	CAN_TEST_PROTOCOL_StartTimeoutCheckTask();
;;;572    	
;;;573    	// 删除命令帧
;;;574    	pCB->rx.head ++;
;;;575    	pCB->rx.head %= CAN_TEST_PROTOCOL_RX_QUEUE_SIZE;
;;;576    }
000010  e8bd87f0          POP      {r4-r10,pc}
                  |L3.20|
000014  f8b412a6          LDRH     r1,[r4,#0x2a6]        ;501
000018  f8b402a8          LDRH     r0,[r4,#0x2a8]        ;501
00001c  4281              CMP      r1,r0                 ;501
00001e  d100              BNE      |L3.34|
000020  e7f6              B        |L3.16|
                  |L3.34|
000022  f8b402a6          LDRH     r0,[r4,#0x2a6]        ;507
000026  eb0001c0          ADD      r1,r0,r0,LSL #3       ;507
00002a  eb011140          ADD      r1,r1,r0,LSL #5       ;507
00002e  f10400ba          ADD      r0,r4,#0xba           ;507
000032  eb000581          ADD      r5,r0,r1,LSL #2       ;507
000036  78a8              LDRB     r0,[r5,#2]            ;510
000038  2855              CMP      r0,#0x55              ;510
00003a  d00e              BEQ      |L3.90|
00003c  f8b402a6          LDRH     r0,[r4,#0x2a6]        ;513
000040  1c40              ADDS     r0,r0,#1              ;513
000042  f8a402a6          STRH     r0,[r4,#0x2a6]        ;513
000046  f8b402a6          LDRH     r0,[r4,#0x2a6]        ;514
00004a  2103              MOVS     r1,#3                 ;514
00004c  fb90f2f1          SDIV     r2,r0,r1              ;514
000050  fb010012          MLS      r0,r1,r2,r0           ;514
000054  f8a402a6          STRH     r0,[r4,#0x2a6]        ;514
000058  e7da              B        |L3.16|
                  |L3.90|
00005a  78ef              LDRB     r7,[r5,#3]            ;519
00005c  b137              CBZ      r7,|L3.108|
00005e  2fd0              CMP      r7,#0xd0              ;522
000060  d005              BEQ      |L3.110|
000062  2fd1              CMP      r7,#0xd1              ;522
000064  d013              BEQ      |L3.142|
000066  2fd2              CMP      r7,#0xd2              ;522
000068  d12a              BNE      |L3.192|
00006a  e025              B        |L3.184|
                  |L3.108|
00006c  e029              B        |L3.194|
                  |L3.110|
00006e  796e              LDRB     r6,[r5,#5]            ;529
000070  b91e              CBNZ     r6,|L3.122|
000072  20a7              MOVS     r0,#0xa7              ;535
000074  f7fffffe          BL       STATE_SwitchStep
000078  e023              B        |L3.194|
                  |L3.122|
00007a  2000              MOVS     r0,#0                 ;540
00007c  491a              LDR      r1,|L3.232|
00007e  62c8              STR      r0,[r1,#0x2c]         ;540  ; dut_info
000080  2003              MOVS     r0,#3                 ;541
000082  f7fffffe          BL       TIMER_KillTask
000086  20a9              MOVS     r0,#0xa9              ;542
000088  f7fffffe          BL       STATE_SwitchStep
00008c  e019              B        |L3.194|
                  |L3.142|
00008e  796e              LDRB     r6,[r5,#5]            ;546
000090  b926              CBNZ     r6,|L3.156|
000092  4815              LDR      r0,|L3.232|
000094  6ac0              LDR      r0,[r0,#0x2c]         ;550  ; dut_info
000096  1e40              SUBS     r0,r0,#1              ;550
000098  4913              LDR      r1,|L3.232|
00009a  62c8              STR      r0,[r1,#0x2c]         ;550  ; dut_info
                  |L3.156|
00009c  4812              LDR      r0,|L3.232|
00009e  6ac0              LDR      r0,[r0,#0x2c]         ;552  ; dut_info
0000a0  4911              LDR      r1,|L3.232|
0000a2  6a09              LDR      r1,[r1,#0x20]         ;552  ; dut_info
0000a4  4288              CMP      r0,r1                 ;552
0000a6  d203              BCS      |L3.176|
0000a8  20a9              MOVS     r0,#0xa9              ;554
0000aa  f7fffffe          BL       STATE_SwitchStep
0000ae  e002              B        |L3.182|
                  |L3.176|
0000b0  20aa              MOVS     r0,#0xaa              ;558
0000b2  f7fffffe          BL       STATE_SwitchStep
                  |L3.182|
0000b6  e004              B        |L3.194|
                  |L3.184|
0000b8  201e              MOVS     r0,#0x1e              ;563
0000ba  f7fffffe          BL       STATE_SwitchStep
0000be  e000              B        |L3.194|
                  |L3.192|
0000c0  bf00              NOP                            ;567
                  |L3.194|
0000c2  bf00              NOP                            ;526
0000c4  f7fffffe          BL       CAN_TEST_PROTOCOL_StartTimeoutCheckTask
0000c8  f8b402a6          LDRH     r0,[r4,#0x2a6]        ;574
0000cc  1c40              ADDS     r0,r0,#1              ;574
0000ce  f8a402a6          STRH     r0,[r4,#0x2a6]        ;574
0000d2  f8b402a6          LDRH     r0,[r4,#0x2a6]        ;575
0000d6  2103              MOVS     r1,#3                 ;575
0000d8  fb90f2f1          SDIV     r2,r0,r1              ;575
0000dc  fb010012          MLS      r0,r1,r2,r0           ;575
0000e0  f8a402a6          STRH     r0,[r4,#0x2a6]        ;575
0000e4  bf00              NOP      
0000e6  e793              B        |L3.16|
;;;577    
                          ENDP

                  |L3.232|
                          DCD      dut_info

                          AREA ||i.CAN_TEST_PROTOCOL_ConfirmTempCmdFrameBuff||, CODE, READONLY, ALIGN=1

                  CAN_TEST_PROTOCOL_ConfirmTempCmdFrameBuff PROC
;;;235    // 将临时缓冲区添加到命令帧缓冲区中，其本质操作是承认临时缓冲区数据有效
;;;236    BOOL CAN_TEST_PROTOCOL_ConfirmTempCmdFrameBuff(CAN_TEST_PROTOCOL_CB* pCB)
000000  b510              PUSH     {r4,lr}
;;;237    {
000002  4601              MOV      r1,r0
;;;238    	CAN_TEST_PROTOCOL_RX_CMD_FRAME* pCmdFrame = NULL;
000004  2200              MOVS     r2,#0
;;;239    	
;;;240    	// 参数合法性检验
;;;241    	if(NULL == pCB)
000006  b909              CBNZ     r1,|L4.12|
;;;242    	{
;;;243    		return FALSE;
000008  2000              MOVS     r0,#0
                  |L4.10|
;;;244    	}
;;;245    
;;;246    	// 临时缓冲区为空，不予添加
;;;247    	pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.end];
;;;248    	if(0 == pCmdFrame->length)
;;;249    	{
;;;250    		return FALSE;
;;;251    	}
;;;252    
;;;253    	// 添加
;;;254    	pCB->rx.end ++;
;;;255    	pCB->rx.end %= CAN_TEST_PROTOCOL_RX_QUEUE_SIZE;
;;;256    	pCB->rx.cmdQueue[pCB->rx.end].length = 0;	// 该行的作用是将新的添加位置有效数据个数清零，以便将这个位置当做临时帧缓冲区
;;;257    	
;;;258    	return TRUE;
;;;259    }
00000a  bd10              POP      {r4,pc}
                  |L4.12|
00000c  f8b102a8          LDRH     r0,[r1,#0x2a8]        ;247
000010  eb0003c0          ADD      r3,r0,r0,LSL #3       ;247
000014  eb031340          ADD      r3,r3,r0,LSL #5       ;247
000018  f10100ba          ADD      r0,r1,#0xba           ;247
00001c  eb000283          ADD      r2,r0,r3,LSL #2       ;247
000020  f8b200a2          LDRH     r0,[r2,#0xa2]         ;248
000024  b908              CBNZ     r0,|L4.42|
000026  2000              MOVS     r0,#0                 ;250
000028  e7ef              B        |L4.10|
                  |L4.42|
00002a  f8b102a8          LDRH     r0,[r1,#0x2a8]        ;254
00002e  1c40              ADDS     r0,r0,#1              ;254
000030  f8a102a8          STRH     r0,[r1,#0x2a8]        ;254
000034  f8b102a8          LDRH     r0,[r1,#0x2a8]        ;255
000038  2303              MOVS     r3,#3                 ;255
00003a  fb90f4f3          SDIV     r4,r0,r3              ;255
00003e  fb030014          MLS      r0,r3,r4,r0           ;255
000042  f8a102a8          STRH     r0,[r1,#0x2a8]        ;255
000046  2300              MOVS     r3,#0                 ;256
000048  f8b102a8          LDRH     r0,[r1,#0x2a8]        ;256
00004c  eb0004c0          ADD      r4,r0,r0,LSL #3       ;256
000050  eb041440          ADD      r4,r4,r0,LSL #5       ;256
000054  f10100ba          ADD      r0,r1,#0xba           ;256
000058  eb000084          ADD      r0,r0,r4,LSL #2       ;256
00005c  f8a030a2          STRH     r3,[r0,#0xa2]         ;256
000060  2001              MOVS     r0,#1                 ;258
000062  e7d2              B        |L4.10|
;;;260    
                          ENDP


                          AREA ||i.CAN_TEST_PROTOCOL_DataStructInit||, CODE, READONLY, ALIGN=1

                  CAN_TEST_PROTOCOL_DataStructInit PROC
;;;165    // 数据结构初始化
;;;166    void CAN_TEST_PROTOCOL_DataStructInit(CAN_TEST_PROTOCOL_CB* pCB)
000000  b510              PUSH     {r4,lr}
;;;167    {
;;;168    	uint16 i;
;;;169    	
;;;170    	// 参数合法性检验
;;;171    	if (NULL == pCB)
000002  b900              CBNZ     r0,|L5.6|
                  |L5.4|
;;;172    	{
;;;173    		return;
;;;174    	}
;;;175    
;;;176    	pCB->tx.txBusy = FALSE;
;;;177    	pCB->tx.index = 0;
;;;178    	pCB->tx.head = 0;
;;;179    	pCB->tx.end = 0;
;;;180    	for(i = 0; i < CAN_TEST_PROTOCOL_TX_QUEUE_SIZE; i++)
;;;181    	{
;;;182    		pCB->tx.cmdQueue[i].length = 0;
;;;183    	}
;;;184    
;;;185    	pCB->rxFIFO.head = 0;
;;;186    	pCB->rxFIFO.end = 0;
;;;187    	pCB->rxFIFO.currentProcessIndex = 0;
;;;188    
;;;189    	pCB->rx.head = 0;
;;;190    	pCB->rx.end  = 0;
;;;191    	for(i=0; i<CAN_TEST_PROTOCOL_RX_QUEUE_SIZE; i++)
;;;192    	{
;;;193    		pCB->rx.cmdQueue[i].length = 0;
;;;194    	}
;;;195    }
000004  bd10              POP      {r4,pc}
                  |L5.6|
000006  2300              MOVS     r3,#0                 ;176
000008  f880349c          STRB     r3,[r0,#0x49c]        ;176
00000c  f8a0349a          STRH     r3,[r0,#0x49a]        ;177
000010  f8a03496          STRH     r3,[r0,#0x496]        ;178
000014  f8a03498          STRH     r3,[r0,#0x498]        ;179
000018  2100              MOVS     r1,#0                 ;180
00001a  e00c              B        |L5.54|
                  |L5.28|
00001c  2300              MOVS     r3,#0                 ;182
00001e  eb0102c1          ADD      r2,r1,r1,LSL #3       ;182
000022  eb021441          ADD      r4,r2,r1,LSL #5       ;182
000026  f20022aa          ADD      r2,r0,#0x2aa          ;182
00002a  eb020284          ADD      r2,r2,r4,LSL #2       ;182
00002e  f8a230a2          STRH     r3,[r2,#0xa2]         ;182
000032  1c4a              ADDS     r2,r1,#1              ;180
000034  b291              UXTH     r1,r2                 ;180
                  |L5.54|
000036  2903              CMP      r1,#3                 ;180
000038  dbf0              BLT      |L5.28|
00003a  2200              MOVS     r2,#0                 ;185
00003c  f8202fb4          STRH     r2,[r0,#0xb4]!        ;185
000040  8042              STRH     r2,[r0,#2]            ;186
000042  8082              STRH     r2,[r0,#4]            ;187
000044  38b4              SUBS     r0,r0,#0xb4           ;187
000046  2300              MOVS     r3,#0                 ;189
000048  f8a032a6          STRH     r3,[r0,#0x2a6]        ;189
00004c  f8a032a8          STRH     r3,[r0,#0x2a8]        ;190
000050  2100              MOVS     r1,#0                 ;191
000052  e00c              B        |L5.110|
                  |L5.84|
000054  2300              MOVS     r3,#0                 ;193
000056  eb0102c1          ADD      r2,r1,r1,LSL #3       ;193
00005a  eb021441          ADD      r4,r2,r1,LSL #5       ;193
00005e  f10002ba          ADD      r2,r0,#0xba           ;193
000062  eb020284          ADD      r2,r2,r4,LSL #2       ;193
000066  f8a230a2          STRH     r3,[r2,#0xa2]         ;193
00006a  1c4a              ADDS     r2,r1,#1              ;191
00006c  b291              UXTH     r1,r2                 ;191
                  |L5.110|
00006e  2903              CMP      r1,#3                 ;191
000070  dbf0              BLT      |L5.84|
000072  bf00              NOP      
000074  e7c6              B        |L5.4|
;;;196    
                          ENDP


                          AREA ||i.CAN_TEST_PROTOCOL_Init||, CODE, READONLY, ALIGN=2

                  CAN_TEST_PROTOCOL_Init PROC
;;;66     // 协议初始化
;;;67     void CAN_TEST_PROTOCOL_Init(void)
000000  b500              PUSH     {lr}
;;;68     {
;;;69     	// 协议层数据结构初始化
;;;70     	CAN_TEST_PROTOCOL_DataStructInit(&canTestProtocolCB);
000002  4803              LDR      r0,|L6.16|
000004  f7fffffe          BL       CAN_TEST_PROTOCOL_DataStructInit
;;;71     
;;;72     	// 向驱动层注册数据接收接口
;;;73     //	CAN_DRIVE_RegisterDataSendService(CAN_TEST_PROTOCOL_MacProcess);
;;;74     
;;;75     	// 向驱动层注册数据发送接口
;;;76     	CAN_TEST_PROTOCOL_RegisterDataSendService(CAN_DRIVE_AddTxArray);
000008  4802              LDR      r0,|L6.20|
00000a  f7fffffe          BL       CAN_TEST_PROTOCOL_RegisterDataSendService
;;;77     }
00000e  bd00              POP      {pc}
;;;78     
                          ENDP

                  |L6.16|
                          DCD      canTestProtocolCB
                  |L6.20|
                          DCD      CAN_DRIVE_AddTxArray

                          AREA ||i.CAN_TEST_PROTOCOL_MacProcess||, CODE, READONLY, ALIGN=2

                  CAN_TEST_PROTOCOL_MacProcess PROC
;;;197    // UART报文接收处理函数(注意根据具体模块修改)
;;;198    void CAN_TEST_PROTOCOL_MacProcess(uint32 standarID, uint8* pData, uint16 length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;199    {
000004  4606              MOV      r6,r0
;;;200    	uint16 end = canTestProtocolCB.rxFIFO.end;
000006  4f23              LDR      r7,|L7.148|
000008  f8b750b6          LDRH     r5,[r7,#0xb6]  ; canTestProtocolCB
;;;201    	uint16 head = canTestProtocolCB.rxFIFO.head;
00000c  f8b700b4          LDRH     r0,[r7,#0xb4]  ; canTestProtocolCB
;;;202    	uint16 i = 0;
000010  2300              MOVS     r3,#0
;;;203    	uint8 *rxdata = pData;
000012  460c              MOV      r4,r1
;;;204    	
;;;205    	//■■环形列队，入队■■
;;;206    	// 一级缓冲区已满，不予接收
;;;207    	if ((end + 1) % CAN_TEST_PROTOCOL_RX_FIFO_SIZE == head)
000014  1c6f              ADDS     r7,r5,#1
000016  f04f0cb4          MOV      r12,#0xb4
00001a  fb97f8fc          SDIV     r8,r7,r12
00001e  fb0c7718          MLS      r7,r12,r8,r7
000022  4287              CMP      r7,r0
000024  d101              BNE      |L7.42|
                  |L7.38|
;;;208    	{
;;;209    		return;
;;;210    	}
;;;211    	
;;;212    	for (i = 0; i < length; i++)
;;;213    	{
;;;214    		// 单个字节读取，并放入FIFO中
;;;215    		canTestProtocolCB.rxFIFO.buff[canTestProtocolCB.rxFIFO.end] = *rxdata++;
;;;216    		
;;;217    		canTestProtocolCB.rxFIFO.end++;
;;;218    		
;;;219    		// 一级缓冲区已满，不予接收
;;;220    		if ((canTestProtocolCB.rxFIFO.end + 1) % CAN_TEST_PROTOCOL_RX_FIFO_SIZE == head)
;;;221    		{
;;;222    			break;
;;;223    		}
;;;224    		
;;;225    		canTestProtocolCB.rxFIFO.end %= CAN_TEST_PROTOCOL_RX_FIFO_SIZE;
;;;226    	}
;;;227    }
000026  e8bd81f0          POP      {r4-r8,pc}
                  |L7.42|
00002a  2300              MOVS     r3,#0                 ;212
00002c  e02c              B        |L7.136|
                  |L7.46|
00002e  f8147b01          LDRB     r7,[r4],#1            ;215
000032  f8dfc060          LDR      r12,|L7.148|
000036  f8bcc0b6          LDRH     r12,[r12,#0xb6]       ;215  ; canTestProtocolCB
00003a  f8df8058          LDR      r8,|L7.148|
00003e  f808700c          STRB     r7,[r8,r12]           ;215
000042  4647              MOV      r7,r8                 ;217
000044  f8b770b6          LDRH     r7,[r7,#0xb6]         ;217  ; canTestProtocolCB
000048  1c7f              ADDS     r7,r7,#1              ;217
00004a  46c4              MOV      r12,r8                ;217
00004c  f8ac70b6          STRH     r7,[r12,#0xb6]        ;217
000050  4647              MOV      r7,r8                 ;220
000052  f8b770b6          LDRH     r7,[r7,#0xb6]         ;220  ; canTestProtocolCB
000056  1c7f              ADDS     r7,r7,#1              ;220
000058  f04f0cb4          MOV      r12,#0xb4             ;220
00005c  fb97f8fc          SDIV     r8,r7,r12             ;220
000060  fb0c7718          MLS      r7,r12,r8,r7          ;220
000064  4287              CMP      r7,r0                 ;220
000066  d100              BNE      |L7.106|
000068  e010              B        |L7.140|
                  |L7.106|
00006a  4f0a              LDR      r7,|L7.148|
00006c  f8b770b6          LDRH     r7,[r7,#0xb6]         ;225  ; canTestProtocolCB
000070  f04f0cb4          MOV      r12,#0xb4             ;225
000074  fb97f8fc          SDIV     r8,r7,r12             ;225
000078  fb0c7718          MLS      r7,r12,r8,r7          ;225
00007c  f8dfc014          LDR      r12,|L7.148|
000080  f8ac70b6          STRH     r7,[r12,#0xb6]        ;225
000084  1c5f              ADDS     r7,r3,#1              ;212
000086  b2bb              UXTH     r3,r7                 ;212
                  |L7.136|
000088  4293              CMP      r3,r2                 ;212
00008a  dbd0              BLT      |L7.46|
                  |L7.140|
00008c  bf00              NOP                            ;222
00008e  bf00              NOP      
000090  e7c9              B        |L7.38|
;;;228    
                          ENDP

000092  0000              DCW      0x0000
                  |L7.148|
                          DCD      canTestProtocolCB

                          AREA ||i.CAN_TEST_PROTOCOL_Process||, CODE, READONLY, ALIGN=2

                  CAN_TEST_PROTOCOL_Process PROC
;;;79     // UART协议层过程处理
;;;80     void CAN_TEST_PROTOCOL_Process(void)
000000  b510              PUSH     {r4,lr}
;;;81     {
;;;82     	// UART接收FIFO缓冲区处理
;;;83     	CAN_TEST_PROTOCOL_RxFIFOProcess(&canTestProtocolCB);
000002  4804              LDR      r0,|L8.20|
000004  f7fffffe          BL       CAN_TEST_PROTOCOL_RxFIFOProcess
;;;84     
;;;85     	// UART接收命令缓冲区处理
;;;86     	CAN_TEST_PROTOCOL_CmdFrameProcess(&canTestProtocolCB);
000008  4802              LDR      r0,|L8.20|
00000a  f7fffffe          BL       CAN_TEST_PROTOCOL_CmdFrameProcess
;;;87     	
;;;88     	// UART协议层发送处理过程
;;;89     	CAN_TEST_PROTOCOL_TxStateProcess();
00000e  f7fffffe          BL       CAN_TEST_PROTOCOL_TxStateProcess
;;;90     }
000012  bd10              POP      {r4,pc}
;;;91     
                          ENDP

                  |L8.20|
                          DCD      canTestProtocolCB

                          AREA ||i.CAN_TEST_PROTOCOL_RegisterDataSendService||, CODE, READONLY, ALIGN=2

                  CAN_TEST_PROTOCOL_RegisterDataSendService PROC
;;;229    // UART协议层向驱动层注册数据发送接口
;;;230    void CAN_TEST_PROTOCOL_RegisterDataSendService(BOOL (*service)(uint32 id, uint8 *pData, uint8 length))
000000  4901              LDR      r1,|L9.8|
;;;231    {		
;;;232    	canTestProtocolCB.sendDataThrowService = service;
000002  f8c104a0          STR      r0,[r1,#0x4a0]  ; canTestProtocolCB
;;;233    }
000006  4770              BX       lr
;;;234    
                          ENDP

                  |L9.8|
                          DCD      canTestProtocolCB

                          AREA ||i.CAN_TEST_PROTOCOL_RxFIFOProcess||, CODE, READONLY, ALIGN=1

                  CAN_TEST_PROTOCOL_RxFIFOProcess PROC
;;;294    // 一级接收缓冲区处理，从一级接收缓冲区中取出一个字节添加到命令帧缓冲区中
;;;295    void CAN_TEST_PROTOCOL_RxFIFOProcess(CAN_TEST_PROTOCOL_CB* pCB)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;296    {
000004  4604              MOV      r4,r0
;;;297    	uint16 end = pCB->rxFIFO.end;
000006  f8b470b6          LDRH     r7,[r4,#0xb6]
;;;298    	uint16 head = pCB->rxFIFO.head;
00000a  f8b490b4          LDRH     r9,[r4,#0xb4]
;;;299    	CAN_TEST_PROTOCOL_RX_CMD_FRAME* pCmdFrame = NULL;
00000e  2500              MOVS     r5,#0
;;;300    	uint16 length = 0;
000010  46a8              MOV      r8,r5
;;;301    	uint8 currentData = 0;
000012  2600              MOVS     r6,#0
;;;302    	
;;;303    	// 参数合法性检验
;;;304    	if(NULL == pCB)
000014  b90c              CBNZ     r4,|L10.26|
                  |L10.22|
;;;305    	{
;;;306    		return;
;;;307    	}
;;;308    	
;;;309    	// 一级缓冲区为空，退出
;;;310    	if(head == end)
;;;311    	{
;;;312    		return;
;;;313    	}
;;;314    
;;;315    	// 获取临时缓冲区指针
;;;316    	pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.end];
;;;317        
;;;318    	// 取出当前要处理的字节
;;;319    	currentData = pCB->rxFIFO.buff[pCB->rxFIFO.currentProcessIndex];
;;;320    	
;;;321    	// 临时缓冲区长度为0时，搜索首字节
;;;322    	if(0 == pCmdFrame->length)
;;;323    	{
;;;324    		// 命令头错误，删除当前字节并退出
;;;325    		if(CAN_TEST_PROTOCOL_CMD_HEAD != currentData)
;;;326    		{
;;;327    			pCB->rxFIFO.head ++;
;;;328    			pCB->rxFIFO.head %= CAN_TEST_PROTOCOL_RX_FIFO_SIZE;
;;;329    			pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;330    
;;;331    			return;
;;;332    		}
;;;333    		
;;;334    		// 命令头正确，但无临时缓冲区可用，退出
;;;335    		if((pCB->rx.end + 1)%CAN_TEST_PROTOCOL_RX_QUEUE_SIZE == pCB->rx.head)
;;;336    		{
;;;337    			return;
;;;338    		}
;;;339    
;;;340    		// 添加UART通讯超时时间设置-2016.1.5增加
;;;341    #if CAN_TEST_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;342    		TIMER_AddTask(TIMER_ID_CAN_COMMUNICATION_TIME_OUT,
;;;343    						CAN_TEST_PROTOCOL_BUS_UNIDIRECTIONAL_TIME_OUT,
;;;344    						CAN_TEST_PROTOCOL_CALLBACK_RxTimeOut,
;;;345    						0,
;;;346    						1,
;;;347    						ACTION_MODE_ADD_TO_QUEUE);
;;;348    #endif
;;;349    		
;;;350    		// 命令头正确，有临时缓冲区可用，则将其添加到命令帧临时缓冲区中
;;;351    		pCmdFrame->buff[pCmdFrame->length++]= currentData;
;;;352    		pCB->rxFIFO.currentProcessIndex ++;
;;;353    		pCB->rxFIFO.currentProcessIndex %= CAN_TEST_PROTOCOL_RX_FIFO_SIZE;
;;;354    	}
;;;355    	// 非首字节，将数据添加到命令帧临时缓冲区中，但暂不删除当前数据
;;;356    	else
;;;357    	{
;;;358    		// 临时缓冲区溢出，说明当前正在接收的命令帧是错误的，正确的命令帧不会出现长度溢出的情况
;;;359    		if(pCmdFrame->length >= CAN_TEST_PROTOCOL_RX_CMD_FRAME_LENGTH_MAX)
;;;360    		{
;;;361    #if CAN_TEST_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;362    			// 停止RX通讯超时检测
;;;363    			CAN_TEST_PROTOCOL_StopRxTimeOutCheck();
;;;364    #endif
;;;365    
;;;366    			// 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;367    			pCmdFrame->length = 0;	// 2016.1.5增加
;;;368    			// 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;369    			pCB->rxFIFO.head ++;
;;;370    			pCB->rxFIFO.head %= CAN_TEST_PROTOCOL_RX_FIFO_SIZE;
;;;371    			pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;372    
;;;373    			return;
;;;374    		}
;;;375    
;;;376    		// 一直取到末尾
;;;377    		while(end != pCB->rxFIFO.currentProcessIndex)
;;;378    		{
;;;379    			// 取出当前要处理的字节
;;;380    			currentData = pCB->rxFIFO.buff[pCB->rxFIFO.currentProcessIndex];
;;;381    			// 缓冲区未溢出，正常接收，将数据添加到临时缓冲区中
;;;382    			pCmdFrame->buff[pCmdFrame->length++] = currentData;
;;;383    			pCB->rxFIFO.currentProcessIndex ++;
;;;384    			pCB->rxFIFO.currentProcessIndex %= CAN_TEST_PROTOCOL_RX_FIFO_SIZE;
;;;385    
;;;386    			// ■■接下来，需要检查命令帧是否完整，如果完整，则将命令帧临时缓冲区扶正■■
;;;387    			
;;;388    			// 首先判断命令帧最小长度，一个完整的命令字至少包括8个字节: 命令头、设备地址、命令字、数据长度、校验和L、校验和H、结束标识0xD、结束标识OxA，因此不足8个字节的必定不完整
;;;389    			if(pCmdFrame->length < CAN_TEST_PROTOCOL_CMD_FRAME_LENGTH_MIN)
;;;390    			{
;;;391    				// 继续接收
;;;392    				continue;
;;;393    			}
;;;394    
;;;395    			// 命令帧长度数值越界，说明当前命令帧错误，停止接收
;;;396    			if(pCmdFrame->buff[CAN_TEST_PROTOCOL_CMD_LENGTH_INDEX] > CAN_TEST_PROTOCOL_RX_CMD_FRAME_LENGTH_MAX-CAN_TEST_PROTOCOL_CMD_FRAME_LENGTH_MIN)
;;;397    			{
;;;398    #if CAN_TEST_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;399    				// 停止RX通讯超时检测
;;;400    				CAN_TEST_PROTOCOL_StopRxTimeOutCheck();
;;;401    #endif
;;;402    			
;;;403    				// 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;404    				pCmdFrame->length = 0;
;;;405    				// 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;406    				pCB->rxFIFO.head ++;
;;;407    				pCB->rxFIFO.head %= CAN_TEST_PROTOCOL_RX_FIFO_SIZE;
;;;408    				pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;409    
;;;410    				return;
;;;411    			}
;;;412    
;;;413    			// 命令帧长度校验，在命令长度描述字的数值上，增加命令头、设备地址、命令字、数据长度、校验和L、校验和H、结束标识0xD、结束标识OxA，即为命令帧实际长度
;;;414    			length = pCmdFrame->length;
;;;415    			if(length < pCmdFrame->buff[CAN_TEST_PROTOCOL_CMD_LENGTH_INDEX] + CAN_TEST_PROTOCOL_CMD_FRAME_LENGTH_MIN)
;;;416    			{
;;;417    				// 长度要求不一致，说明未接收完毕，退出继续
;;;418    				continue;
;;;419    			}
;;;420    
;;;421    			// 命令帧长度OK，则进行校验，失败时删除命令头
;;;422    			if(!CAN_TEST_PROTOCOL_CheckSUM(pCmdFrame))
;;;423    			{
;;;424    #if CAN_TEST_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;425    				// 停止RX通讯超时检测
;;;426    				CAN_TEST_PROTOCOL_StopRxTimeOutCheck();
;;;427    #endif
;;;428    				
;;;429    				// 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;430    				pCmdFrame->length = 0;
;;;431    				// 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;432    				pCB->rxFIFO.head ++;
;;;433    				pCB->rxFIFO.head %= CAN_TEST_PROTOCOL_RX_FIFO_SIZE;
;;;434    				pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;435    				
;;;436    				return;
;;;437    			}
;;;438    
;;;439    #if CAN_TEST_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;440    			// 停止RX通讯超时检测
;;;441    			CAN_TEST_PROTOCOL_StopRxTimeOutCheck();
;;;442    #endif
;;;443    			
;;;444    			// 执行到这里，即说明接收到了一个完整并且正确的命令帧，此时需将处理过的数据从一级缓冲区中删除，并将该命令帧扶正
;;;445    			pCB->rxFIFO.head += length;
;;;446    			pCB->rxFIFO.head %= CAN_TEST_PROTOCOL_RX_FIFO_SIZE;
;;;447    			pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;448    			CAN_TEST_PROTOCOL_ConfirmTempCmdFrameBuff(pCB);
;;;449    
;;;450    			return;
;;;451    		}
;;;452    	}
;;;453    }
000016  e8bd83f0          POP      {r4-r9,pc}
                  |L10.26|
00001a  45b9              CMP      r9,r7                 ;310
00001c  d100              BNE      |L10.32|
00001e  e7fa              B        |L10.22|
                  |L10.32|
000020  f8b402a8          LDRH     r0,[r4,#0x2a8]        ;316
000024  eb0001c0          ADD      r1,r0,r0,LSL #3       ;316
000028  eb011140          ADD      r1,r1,r0,LSL #5       ;316
00002c  f10400ba          ADD      r0,r4,#0xba           ;316
000030  eb000581          ADD      r5,r0,r1,LSL #2       ;316
000034  f8b400b8          LDRH     r0,[r4,#0xb8]         ;319
000038  5c26              LDRB     r6,[r4,r0]            ;319
00003a  f8b500a2          LDRH     r0,[r5,#0xa2]         ;322
00003e  bb90              CBNZ     r0,|L10.166|
000040  2e55              CMP      r6,#0x55              ;325
000042  d00e              BEQ      |L10.98|
000044  f8340fb4          LDRH     r0,[r4,#0xb4]!        ;327
000048  1c40              ADDS     r0,r0,#1              ;327
00004a  8020              STRH     r0,[r4,#0]            ;327
00004c  8820              LDRH     r0,[r4,#0]            ;328
00004e  21b4              MOVS     r1,#0xb4              ;328
000050  fb90f2f1          SDIV     r2,r0,r1              ;328
000054  fb010012          MLS      r0,r1,r2,r0           ;328
000058  8020              STRH     r0,[r4,#0]            ;328
00005a  8820              LDRH     r0,[r4,#0]            ;329
00005c  80a0              STRH     r0,[r4,#4]            ;329
00005e  3cb4              SUBS     r4,r4,#0xb4           ;329
000060  e7d9              B        |L10.22|
                  |L10.98|
000062  f8b402a8          LDRH     r0,[r4,#0x2a8]        ;335
000066  1c40              ADDS     r0,r0,#1              ;335
000068  2103              MOVS     r1,#3                 ;335
00006a  fb90f2f1          SDIV     r2,r0,r1              ;335
00006e  fb010112          MLS      r1,r1,r2,r0           ;335
000072  f8b402a6          LDRH     r0,[r4,#0x2a6]        ;335
000076  4281              CMP      r1,r0                 ;335
000078  d100              BNE      |L10.124|
00007a  e7cc              B        |L10.22|
                  |L10.124|
00007c  f8351fa2          LDRH     r1,[r5,#0xa2]!        ;351
000080  8828              LDRH     r0,[r5,#0]            ;351
000082  1c40              ADDS     r0,r0,#1              ;351
000084  f82509a2          STRH     r0,[r5],#-0xa2        ;351
000088  1ca8              ADDS     r0,r5,#2              ;351
00008a  5446              STRB     r6,[r0,r1]            ;351
00008c  f8340fb8          LDRH     r0,[r4,#0xb8]!        ;352
000090  1c40              ADDS     r0,r0,#1              ;352
000092  8020              STRH     r0,[r4,#0]            ;352
000094  8820              LDRH     r0,[r4,#0]            ;353
000096  21b4              MOVS     r1,#0xb4              ;353
000098  fb90f2f1          SDIV     r2,r0,r1              ;353
00009c  fb010012          MLS      r0,r1,r2,r0           ;353
0000a0  f82409b8          STRH     r0,[r4],#-0xb8        ;353
0000a4  e07b              B        |L10.414|
                  |L10.166|
0000a6  e7ff              B        |L10.168|
                  |L10.168|
0000a8  f8b500a2          LDRH     r0,[r5,#0xa2]         ;359
0000ac  28a0              CMP      r0,#0xa0              ;359
0000ae  db11              BLT      |L10.212|
0000b0  2000              MOVS     r0,#0                 ;367
0000b2  f8a500a2          STRH     r0,[r5,#0xa2]         ;367
0000b6  f8340fb4          LDRH     r0,[r4,#0xb4]!        ;369
0000ba  1c40              ADDS     r0,r0,#1              ;369
0000bc  8020              STRH     r0,[r4,#0]            ;369
0000be  8820              LDRH     r0,[r4,#0]            ;370
0000c0  21b4              MOVS     r1,#0xb4              ;370
0000c2  fb90f2f1          SDIV     r2,r0,r1              ;370
0000c6  fb010012          MLS      r0,r1,r2,r0           ;370
0000ca  8020              STRH     r0,[r4,#0]            ;370
0000cc  8820              LDRH     r0,[r4,#0]            ;371
0000ce  80a0              STRH     r0,[r4,#4]            ;371
0000d0  3cb4              SUBS     r4,r4,#0xb4           ;371
0000d2  e7a0              B        |L10.22|
                  |L10.212|
0000d4  e05f              B        |L10.406|
                  |L10.214|
0000d6  f8b400b8          LDRH     r0,[r4,#0xb8]         ;380
0000da  5c26              LDRB     r6,[r4,r0]            ;380
0000dc  f8351fa2          LDRH     r1,[r5,#0xa2]!        ;382
0000e0  8828              LDRH     r0,[r5,#0]            ;382
0000e2  1c40              ADDS     r0,r0,#1              ;382
0000e4  f82509a2          STRH     r0,[r5],#-0xa2        ;382
0000e8  1ca8              ADDS     r0,r5,#2              ;382
0000ea  5446              STRB     r6,[r0,r1]            ;382
0000ec  f8340fb8          LDRH     r0,[r4,#0xb8]!        ;383
0000f0  1c40              ADDS     r0,r0,#1              ;383
0000f2  8020              STRH     r0,[r4,#0]            ;383
0000f4  8820              LDRH     r0,[r4,#0]            ;384
0000f6  21b4              MOVS     r1,#0xb4              ;384
0000f8  fb90f2f1          SDIV     r2,r0,r1              ;384
0000fc  fb010012          MLS      r0,r1,r2,r0           ;384
000100  f82409b8          STRH     r0,[r4],#-0xb8        ;384
000104  f8b500a2          LDRH     r0,[r5,#0xa2]         ;389
000108  2804              CMP      r0,#4                 ;389
00010a  da00              BGE      |L10.270|
00010c  e043              B        |L10.406|
                  |L10.270|
00010e  7928              LDRB     r0,[r5,#4]            ;396
000110  289c              CMP      r0,#0x9c              ;396
000112  dd11              BLE      |L10.312|
000114  2000              MOVS     r0,#0                 ;404
000116  f8a500a2          STRH     r0,[r5,#0xa2]         ;404
00011a  f8340fb4          LDRH     r0,[r4,#0xb4]!        ;406
00011e  1c40              ADDS     r0,r0,#1              ;406
000120  8020              STRH     r0,[r4,#0]            ;406
000122  8820              LDRH     r0,[r4,#0]            ;407
000124  21b4              MOVS     r1,#0xb4              ;407
000126  fb90f2f1          SDIV     r2,r0,r1              ;407
00012a  fb010012          MLS      r0,r1,r2,r0           ;407
00012e  8020              STRH     r0,[r4,#0]            ;407
000130  8820              LDRH     r0,[r4,#0]            ;408
000132  80a0              STRH     r0,[r4,#4]            ;408
000134  3cb4              SUBS     r4,r4,#0xb4           ;408
000136  e76e              B        |L10.22|
                  |L10.312|
000138  f8b580a2          LDRH     r8,[r5,#0xa2]         ;414
00013c  7928              LDRB     r0,[r5,#4]            ;415
00013e  1d00              ADDS     r0,r0,#4              ;415
000140  4540              CMP      r0,r8                 ;415
000142  dd00              BLE      |L10.326|
000144  e027              B        |L10.406|
                  |L10.326|
000146  4628              MOV      r0,r5                 ;422
000148  f7fffffe          BL       CAN_TEST_PROTOCOL_CheckSUM
00014c  b988              CBNZ     r0,|L10.370|
00014e  2000              MOVS     r0,#0                 ;430
000150  f8a500a2          STRH     r0,[r5,#0xa2]         ;430
000154  f8340fb4          LDRH     r0,[r4,#0xb4]!        ;432
000158  1c40              ADDS     r0,r0,#1              ;432
00015a  8020              STRH     r0,[r4,#0]            ;432
00015c  8820              LDRH     r0,[r4,#0]            ;433
00015e  21b4              MOVS     r1,#0xb4              ;433
000160  fb90f2f1          SDIV     r2,r0,r1              ;433
000164  fb010012          MLS      r0,r1,r2,r0           ;433
000168  8020              STRH     r0,[r4,#0]            ;433
00016a  8820              LDRH     r0,[r4,#0]            ;434
00016c  80a0              STRH     r0,[r4,#4]            ;434
00016e  3cb4              SUBS     r4,r4,#0xb4           ;434
000170  e751              B        |L10.22|
                  |L10.370|
000172  f8340fb4          LDRH     r0,[r4,#0xb4]!        ;445
000176  4440              ADD      r0,r0,r8              ;445
000178  8020              STRH     r0,[r4,#0]            ;445
00017a  8820              LDRH     r0,[r4,#0]            ;446
00017c  21b4              MOVS     r1,#0xb4              ;446
00017e  fb90f2f1          SDIV     r2,r0,r1              ;446
000182  fb010012          MLS      r0,r1,r2,r0           ;446
000186  8020              STRH     r0,[r4,#0]            ;446
000188  8820              LDRH     r0,[r4,#0]            ;447
00018a  80a0              STRH     r0,[r4,#4]            ;447
00018c  3cb4              SUBS     r4,r4,#0xb4           ;447
00018e  4620              MOV      r0,r4                 ;448
000190  f7fffffe          BL       CAN_TEST_PROTOCOL_ConfirmTempCmdFrameBuff
000194  e73f              B        |L10.22|
                  |L10.406|
000196  f8b400b8          LDRH     r0,[r4,#0xb8]         ;377
00019a  42b8              CMP      r0,r7                 ;377
00019c  d19b              BNE      |L10.214|
                  |L10.414|
00019e  bf00              NOP      
0001a0  e739              B        |L10.22|
;;;454    
                          ENDP


                          AREA ||i.CAN_TEST_PROTOCOL_SendCmdNoResult||, CODE, READONLY, ALIGN=1

                  CAN_TEST_PROTOCOL_SendCmdNoResult PROC
;;;625    // 发送命令无结果
;;;626    void CAN_TEST_PROTOCOL_SendCmdNoResult(uint8 cmdWord)
000000  b510              PUSH     {r4,lr}
;;;627    {
000002  4604              MOV      r4,r0
;;;628    	// 添加命令头
;;;629    	CAN_TEST_PROTOCOL_TxAddData(CAN_TEST_PROTOCOL_CMD_HEAD);
000004  2055              MOVS     r0,#0x55
000006  f7fffffe          BL       CAN_TEST_PROTOCOL_TxAddData
;;;630    
;;;631    	// 添加命令字
;;;632    	CAN_TEST_PROTOCOL_TxAddData(cmdWord);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       CAN_TEST_PROTOCOL_TxAddData
;;;633    	
;;;634    	CAN_TEST_PROTOCOL_TxAddData(0);		// 数据长度
000010  2000              MOVS     r0,#0
000012  f7fffffe          BL       CAN_TEST_PROTOCOL_TxAddData
;;;635    	
;;;636    	CAN_TEST_PROTOCOL_TxAddFrame();
000016  f7fffffe          BL       CAN_TEST_PROTOCOL_TxAddFrame
;;;637    }
00001a  bd10              POP      {r4,pc}
;;;638    
                          ENDP


                          AREA ||i.CAN_TEST_PROTOCOL_SendCmdWithCrc||, CODE, READONLY, ALIGN=1

                  CAN_TEST_PROTOCOL_SendCmdWithCrc PROC
;;;639    // 发送命令回复，带数据CRC
;;;640    void CAN_TEST_PROTOCOL_SendCmdWithCrc(uint8 ackCmd, uint8 ackParam, uint32 Crc)
000000  b570              PUSH     {r4-r6,lr}
;;;641    {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
000006  4614              MOV      r4,r2
;;;642        CAN_TEST_PROTOCOL_TxAddData(CAN_TEST_PROTOCOL_CMD_HEAD);
000008  2055              MOVS     r0,#0x55
00000a  f7fffffe          BL       CAN_TEST_PROTOCOL_TxAddData
;;;643        CAN_TEST_PROTOCOL_TxAddData(ackCmd);
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       CAN_TEST_PROTOCOL_TxAddData
;;;644        CAN_TEST_PROTOCOL_TxAddData(5);
000014  2005              MOVS     r0,#5
000016  f7fffffe          BL       CAN_TEST_PROTOCOL_TxAddData
;;;645        CAN_TEST_PROTOCOL_TxAddData(ackParam);
00001a  4628              MOV      r0,r5
00001c  f7fffffe          BL       CAN_TEST_PROTOCOL_TxAddData
;;;646        CAN_TEST_PROTOCOL_TxAddData((Crc >> 24) & 0xFF);
000020  0e20              LSRS     r0,r4,#24
000022  f7fffffe          BL       CAN_TEST_PROTOCOL_TxAddData
;;;647        CAN_TEST_PROTOCOL_TxAddData((Crc >> 16) & 0xFF);
000026  f3c44007          UBFX     r0,r4,#16,#8
00002a  f7fffffe          BL       CAN_TEST_PROTOCOL_TxAddData
;;;648        CAN_TEST_PROTOCOL_TxAddData((Crc >> 8) & 0xFF);
00002e  f3c42007          UBFX     r0,r4,#8,#8
000032  f7fffffe          BL       CAN_TEST_PROTOCOL_TxAddData
;;;649        CAN_TEST_PROTOCOL_TxAddData(Crc & 0xFF);  
000036  b2e0              UXTB     r0,r4
000038  f7fffffe          BL       CAN_TEST_PROTOCOL_TxAddData
;;;650        CAN_TEST_PROTOCOL_TxAddFrame();
00003c  f7fffffe          BL       CAN_TEST_PROTOCOL_TxAddFrame
;;;651    }
000040  bd70              POP      {r4-r6,pc}
;;;652    
                          ENDP


                          AREA ||i.CAN_TEST_PROTOCOL_SendCmdWithResult||, CODE, READONLY, ALIGN=1

                  CAN_TEST_PROTOCOL_SendCmdWithResult PROC
;;;608    // 发送命令带结果
;;;609    void CAN_TEST_PROTOCOL_SendCmdWithResult(uint8 cmdWord, uint8 result)
000000  b530              PUSH     {r4,r5,lr}
;;;610    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;611    	// 添加命令头
;;;612    	CAN_TEST_PROTOCOL_TxAddData(CAN_TEST_PROTOCOL_CMD_HEAD);
000006  2055              MOVS     r0,#0x55
000008  f7fffffe          BL       CAN_TEST_PROTOCOL_TxAddData
;;;613    
;;;614    	// 添加命令字
;;;615    	CAN_TEST_PROTOCOL_TxAddData(cmdWord);
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       CAN_TEST_PROTOCOL_TxAddData
;;;616    
;;;617    	// 添加数据长度
;;;618    	CAN_TEST_PROTOCOL_TxAddData(1);
000012  2001              MOVS     r0,#1
000014  f7fffffe          BL       CAN_TEST_PROTOCOL_TxAddData
;;;619    	
;;;620    	CAN_TEST_PROTOCOL_TxAddData(result);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       CAN_TEST_PROTOCOL_TxAddData
;;;621    	
;;;622    	CAN_TEST_PROTOCOL_TxAddFrame();
00001e  f7fffffe          BL       CAN_TEST_PROTOCOL_TxAddFrame
;;;623    }
000022  bd30              POP      {r4,r5,pc}
;;;624    
                          ENDP


                          AREA ||i.CAN_TEST_PROTOCOL_SendUpDataPacket||, CODE, READONLY, ALIGN=2

                  CAN_TEST_PROTOCOL_SendUpDataPacket PROC
;;;653    // 发送升级数据
;;;654    void CAN_TEST_PROTOCOL_SendUpDataPacket(DUT_FILE_TYPE upDataType, CAN_TEST_PROTOCOL_CMD cmd, uint32 flashAddr, uint32 addr)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;655    {
000004  4680              MOV      r8,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461c              MOV      r4,r3
;;;656    	uint8 i = 0;
00000c  2500              MOVS     r5,#0
;;;657        
;;;658    	switch (upDataType)
00000e  f1b80f01          CMP      r8,#1
000012  d025              BEQ      |L14.96|
000014  f1b80f05          CMP      r8,#5
000018  d14c              BNE      |L14.180|
;;;659    	{
;;;660            case DUT_FILE_TYPE_HEX:							 // hex
;;;661                dut_info.reconnectionRepeatContent[0] = 121; // 总长度
00001a  2079              MOVS     r0,#0x79
00001c  4928              LDR      r1,|L14.192|
00001e  f881004c          STRB     r0,[r1,#0x4c]
;;;662                dut_info.reconnectionRepeatContent[1] = CAN_TEST_PROTOCOL_CMD_HEAD;
000022  2155              MOVS     r1,#0x55
000024  4826              LDR      r0,|L14.192|
000026  f880104d          STRB     r1,[r0,#0x4d]
;;;663                dut_info.reconnectionRepeatContent[2] = cmd;
00002a  f880604e          STRB     r6,[r0,#0x4e]
;;;664                dut_info.reconnectionRepeatContent[3] = 0;											  // 数据长度
00002e  2100              MOVS     r1,#0
000030  f880104f          STRB     r1,[r0,#0x4f]
;;;665                dut_info.reconnectionRepeatContent[4] = 0;											  // 添加是否加密
000034  f8801050          STRB     r1,[r0,#0x50]
;;;666                dut_info.reconnectionRepeatContent[5] = 0;											  // 添加密钥
000038  f8801051          STRB     r1,[r0,#0x51]
;;;667                SPI_FLASH_ReadArray(&dut_info.reconnectionRepeatContent[6], flashAddr + (addr), 116); // 工具读取 4+112 个字节
00003c  1939              ADDS     r1,r7,r4
00003e  2274              MOVS     r2,#0x74
000040  3052              ADDS     r0,r0,#0x52
000042  f7fffffe          BL       SPI_FLASH_ReadArray
;;;668                for (i = 0; i < 121; i++)															  // 添加数据
000046  bf00              NOP      
000048  e007              B        |L14.90|
                  |L14.74|
;;;669                {
;;;670                    CAN_TEST_PROTOCOL_TxAddData(dut_info.reconnectionRepeatContent[i + 1]);
00004a  491d              LDR      r1,|L14.192|
00004c  314c              ADDS     r1,r1,#0x4c
00004e  1c6a              ADDS     r2,r5,#1
000050  5c88              LDRB     r0,[r1,r2]
000052  f7fffffe          BL       CAN_TEST_PROTOCOL_TxAddData
000056  1c68              ADDS     r0,r5,#1              ;668
000058  b2c5              UXTB     r5,r0                 ;668
                  |L14.90|
00005a  2d79              CMP      r5,#0x79              ;668
00005c  dbf5              BLT      |L14.74|
;;;671                }
;;;672                break;
00005e  e02a              B        |L14.182|
                  |L14.96|
;;;673    
;;;674            case DUT_FILE_TYPE_BIN:							 // bin
;;;675                dut_info.reconnectionRepeatContent[0] = 135; // 总长度
000060  2087              MOVS     r0,#0x87
000062  4917              LDR      r1,|L14.192|
000064  f881004c          STRB     r0,[r1,#0x4c]
;;;676                dut_info.reconnectionRepeatContent[1] = CAN_TEST_PROTOCOL_CMD_HEAD;
000068  2155              MOVS     r1,#0x55
00006a  4815              LDR      r0,|L14.192|
00006c  f880104d          STRB     r1,[r0,#0x4d]
;;;677                dut_info.reconnectionRepeatContent[2] = cmd;
000070  f880604e          STRB     r6,[r0,#0x4e]
;;;678                dut_info.reconnectionRepeatContent[3] = 0;											  // 数据长度
000074  2100              MOVS     r1,#0
000076  f880104f          STRB     r1,[r0,#0x4f]
;;;679                dut_info.reconnectionRepeatContent[4] = ((addr) & 0xFF000000) >> 24;				  // 数据长度
00007a  0e21              LSRS     r1,r4,#24
00007c  f8801050          STRB     r1,[r0,#0x50]
;;;680                dut_info.reconnectionRepeatContent[5] = ((addr) & 0x00FF0000) >> 16;				  // 数据长度
000080  0c21              LSRS     r1,r4,#16
000082  f8801051          STRB     r1,[r0,#0x51]
;;;681                dut_info.reconnectionRepeatContent[6] = ((addr) & 0x0000FF00) >> 8;					  // 数据长度
000086  0a21              LSRS     r1,r4,#8
000088  f8801052          STRB     r1,[r0,#0x52]
;;;682                dut_info.reconnectionRepeatContent[7] = ((addr) & 0x000000FF);						  // 数据长度
00008c  f8804053          STRB     r4,[r0,#0x53]
;;;683                SPI_FLASH_ReadArray(&dut_info.reconnectionRepeatContent[8], flashAddr + (addr), 128); // 工具读取128字节
000090  1939              ADDS     r1,r7,r4
000092  2280              MOVS     r2,#0x80
000094  3054              ADDS     r0,r0,#0x54
000096  f7fffffe          BL       SPI_FLASH_ReadArray
;;;684                for (i = 0; i < 135; i++)															  // 添加数据
00009a  2500              MOVS     r5,#0
00009c  e007              B        |L14.174|
                  |L14.158|
;;;685                {
;;;686                    CAN_TEST_PROTOCOL_TxAddData(dut_info.reconnectionRepeatContent[i + 1]);
00009e  4908              LDR      r1,|L14.192|
0000a0  314c              ADDS     r1,r1,#0x4c
0000a2  1c6a              ADDS     r2,r5,#1
0000a4  5c88              LDRB     r0,[r1,r2]
0000a6  f7fffffe          BL       CAN_TEST_PROTOCOL_TxAddData
0000aa  1c68              ADDS     r0,r5,#1              ;684
0000ac  b2c5              UXTB     r5,r0                 ;684
                  |L14.174|
0000ae  2d87              CMP      r5,#0x87              ;684
0000b0  dbf5              BLT      |L14.158|
;;;687                }
;;;688                break;
0000b2  e000              B        |L14.182|
                  |L14.180|
;;;689                
;;;690            default:
;;;691                break;
0000b4  bf00              NOP      
                  |L14.182|
0000b6  bf00              NOP                            ;672
;;;692    	}
;;;693    	CAN_TEST_PROTOCOL_TxAddFrame(); // 调整帧格式,修改长度和添加校验
0000b8  f7fffffe          BL       CAN_TEST_PROTOCOL_TxAddFrame
;;;694    }
0000bc  e8bd81f0          POP      {r4-r8,pc}
                          ENDP

                  |L14.192|
                          DCD      dut_info

                          AREA ||i.CAN_TEST_PROTOCOL_StartTimeoutCheckTask||, CODE, READONLY, ALIGN=1

                  CAN_TEST_PROTOCOL_StartTimeoutCheckTask PROC
;;;60     // 启动通讯超时判断任务
;;;61     void CAN_TEST_PROTOCOL_StartTimeoutCheckTask(void)
000000  4770              BX       lr
;;;62     {
;;;63     
;;;64     }
;;;65     
                          ENDP


                          AREA ||i.CAN_TEST_PROTOCOL_TxAddData||, CODE, READONLY, ALIGN=2

                  CAN_TEST_PROTOCOL_TxAddData PROC
;;;92     // 向发送命令帧队列中添加数据
;;;93     void CAN_TEST_PROTOCOL_TxAddData(uint8 data)
000000  b570              PUSH     {r4-r6,lr}
;;;94     {
000002  4601              MOV      r1,r0
;;;95     	uint16 head = canTestProtocolCB.tx.head;
000004  4c13              LDR      r4,|L16.84|
000006  f8b42496          LDRH     r2,[r4,#0x496]
;;;96     	uint16 end =  canTestProtocolCB.tx.end;
00000a  f8b43498          LDRH     r3,[r4,#0x498]
;;;97     	CAN_TEST_PROTOCOL_TX_CMD_FRAME* pCmdFrame = &canTestProtocolCB.tx.cmdQueue[canTestProtocolCB.tx.end];
00000e  f8b44498          LDRH     r4,[r4,#0x498]
000012  eb0405c4          ADD      r5,r4,r4,LSL #3
000016  eb051544          ADD      r5,r5,r4,LSL #5
00001a  4c0f              LDR      r4,|L16.88|
00001c  eb040085          ADD      r0,r4,r5,LSL #2
;;;98     
;;;99     	// 发送缓冲区已满，不予接收
;;;100    	if((end + 1) % CAN_TEST_PROTOCOL_TX_QUEUE_SIZE == head)
000020  1c5c              ADDS     r4,r3,#1
000022  2503              MOVS     r5,#3
000024  fb94f6f5          SDIV     r6,r4,r5
000028  fb054416          MLS      r4,r5,r6,r4
00002c  4294              CMP      r4,r2
00002e  d100              BNE      |L16.50|
                  |L16.48|
;;;101    	{
;;;102    		return;
;;;103    	}
;;;104    	
;;;105    	// 队尾命令帧已满，退出
;;;106    	if(pCmdFrame->length >= CAN_TEST_PROTOCOL_TX_CMD_FRAME_LENGTH_MAX)
;;;107    	{
;;;108    		return;
;;;109    	}
;;;110    
;;;111    	// 数据添加到帧末尾，并更新帧长度
;;;112    	pCmdFrame->buff[pCmdFrame->length] = data;
;;;113    	pCmdFrame->length ++;
;;;114    }
000030  bd70              POP      {r4-r6,pc}
                  |L16.50|
000032  f8b040a2          LDRH     r4,[r0,#0xa2]         ;106
000036  2ca0              CMP      r4,#0xa0              ;106
000038  db00              BLT      |L16.60|
00003a  e7f9              B        |L16.48|
                  |L16.60|
00003c  f8b050a2          LDRH     r5,[r0,#0xa2]         ;112
000040  1c84              ADDS     r4,r0,#2              ;112
000042  5561              STRB     r1,[r4,r5]            ;112
000044  f8b040a2          LDRH     r4,[r0,#0xa2]         ;113
000048  1c64              ADDS     r4,r4,#1              ;113
00004a  f8a040a2          STRH     r4,[r0,#0xa2]         ;113
00004e  bf00              NOP      
000050  e7ee              B        |L16.48|
;;;115    
                          ENDP

000052  0000              DCW      0x0000
                  |L16.84|
                          DCD      canTestProtocolCB
                  |L16.88|
                          DCD      canTestProtocolCB+0x2aa

                          AREA ||i.CAN_TEST_PROTOCOL_TxAddFrame||, CODE, READONLY, ALIGN=2

                  CAN_TEST_PROTOCOL_TxAddFrame PROC
;;;116    // 确认添加命令帧，即承认之前填充的数据为命令帧，将其添加到发送队列中，由main进行调度发送，本函数内会自动校正命令长度，并添加校验码
;;;117    void CAN_TEST_PROTOCOL_TxAddFrame(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;118    {
;;;119    	uint16 checkSum = 0;
000002  2300              MOVS     r3,#0
;;;120    	uint16 i = 0;
000004  2200              MOVS     r2,#0
;;;121    	uint16 head = canTestProtocolCB.tx.head;
000006  4e2b              LDR      r6,|L17.180|
000008  f8b64496          LDRH     r4,[r6,#0x496]
;;;122    	uint16 end  = canTestProtocolCB.tx.end;
00000c  f8b65498          LDRH     r5,[r6,#0x498]
;;;123    	CAN_TEST_PROTOCOL_TX_CMD_FRAME* pCmdFrame = &canTestProtocolCB.tx.cmdQueue[canTestProtocolCB.tx.end];
000010  f8b66498          LDRH     r6,[r6,#0x498]
000014  eb0607c6          ADD      r7,r6,r6,LSL #3
000018  eb071746          ADD      r7,r7,r6,LSL #5
00001c  4e26              LDR      r6,|L17.184|
00001e  eb060087          ADD      r0,r6,r7,LSL #2
;;;124    	uint16 length = pCmdFrame->length;
000022  f8b010a2          LDRH     r1,[r0,#0xa2]
;;;125        
;;;126        pCmdFrame->deviceID = 1;
000026  2601              MOVS     r6,#1
000028  8006              STRH     r6,[r0,#0]
;;;127    
;;;128    	// 发送缓冲区已满，不予接收
;;;129    	if((end + 1) % CAN_TEST_PROTOCOL_TX_QUEUE_SIZE == head)
00002a  1c6e              ADDS     r6,r5,#1
00002c  2703              MOVS     r7,#3
00002e  fb96fcf7          SDIV     r12,r6,r7
000032  fb07661c          MLS      r6,r7,r12,r6
000036  42a6              CMP      r6,r4
000038  d100              BNE      |L17.60|
                  |L17.58|
;;;130    	{
;;;131    		return;
;;;132    	}
;;;133    	
;;;134    	// 命令帧长度不足，清除已填充的数据，退出
;;;135    	if(CAN_TEST_PROTOCOL_CMD_FRAME_LENGTH_MIN - 1 > length)	// 减去"校验码"1个字节
;;;136    	{
;;;137    		pCmdFrame->length = 0;
;;;138    		
;;;139    		return;
;;;140    	}
;;;141    
;;;142    	// 队尾命令帧已满，退出
;;;143    	if((length >= CAN_TEST_PROTOCOL_TX_CMD_FRAME_LENGTH_MAX) || (length + 1 >= CAN_TEST_PROTOCOL_TX_CMD_FRAME_LENGTH_MAX)
;;;144    	|| (length + 2 >= CAN_TEST_PROTOCOL_TX_CMD_FRAME_LENGTH_MAX) || (length + 3 >= CAN_TEST_PROTOCOL_TX_CMD_FRAME_LENGTH_MAX))
;;;145    	{
;;;146    		return;
;;;147    	}
;;;148    
;;;149    	// 重新设置数据长度，系统在准备数据时，填充的"数据长度"可以为任意值，并且不需要添加校验码，在这里重新设置为正确的值
;;;150    	pCmdFrame->buff[CAN_TEST_PROTOCOL_CMD_LENGTH_INDEX] = length - 3;	// 重设数据长度，减去"命令头、命令字、数据长度"4个字节
;;;151    	
;;;152        for(i = 0; i < length; i++)
;;;153    	{
;;;154    		checkSum ^= pCmdFrame->buff[i];
;;;155    	}
;;;156        
;;;157    	// 校验码
;;;158    	pCmdFrame->buff[pCmdFrame->length++] = checkSum;
;;;159    
;;;160    	canTestProtocolCB.tx.end ++;
;;;161    	canTestProtocolCB.tx.end %= CAN_TEST_PROTOCOL_TX_QUEUE_SIZE;
;;;162    	//pCB->tx.cmdQueue[pCB->tx.end].length = 0;   //2015.12.2修改
;;;163    }
00003a  bdf0              POP      {r4-r7,pc}
                  |L17.60|
00003c  2903              CMP      r1,#3                 ;135
00003e  da03              BGE      |L17.72|
000040  2600              MOVS     r6,#0                 ;137
000042  f8a060a2          STRH     r6,[r0,#0xa2]         ;137
000046  e7f8              B        |L17.58|
                  |L17.72|
000048  29a0              CMP      r1,#0xa0              ;143
00004a  da08              BGE      |L17.94|
00004c  1c4e              ADDS     r6,r1,#1              ;143
00004e  2ea0              CMP      r6,#0xa0              ;143
000050  da05              BGE      |L17.94|
000052  1c8e              ADDS     r6,r1,#2              ;144
000054  2ea0              CMP      r6,#0xa0              ;144
000056  da02              BGE      |L17.94|
000058  1cce              ADDS     r6,r1,#3              ;144
00005a  2ea0              CMP      r6,#0xa0              ;144
00005c  db00              BLT      |L17.96|
                  |L17.94|
00005e  e7ec              B        |L17.58|
                  |L17.96|
000060  1ece              SUBS     r6,r1,#3              ;150
000062  7106              STRB     r6,[r0,#4]            ;150
000064  2200              MOVS     r2,#0                 ;152
000066  e004              B        |L17.114|
                  |L17.104|
000068  1c86              ADDS     r6,r0,#2              ;154
00006a  5cb6              LDRB     r6,[r6,r2]            ;154
00006c  4073              EORS     r3,r3,r6              ;154
00006e  1c56              ADDS     r6,r2,#1              ;152
000070  b2b2              UXTH     r2,r6                 ;152
                  |L17.114|
000072  428a              CMP      r2,r1                 ;152
000074  dbf8              BLT      |L17.104|
000076  f8b0c0a2          LDRH     r12,[r0,#0xa2]        ;158
00007a  f10c0601          ADD      r6,r12,#1             ;158
00007e  f8a060a2          STRH     r6,[r0,#0xa2]         ;158
000082  1c86              ADDS     r6,r0,#2              ;158
000084  f806300c          STRB     r3,[r6,r12]           ;158
000088  4e0a              LDR      r6,|L17.180|
00008a  f8b66498          LDRH     r6,[r6,#0x498]        ;160
00008e  1c76              ADDS     r6,r6,#1              ;160
000090  b2b7              UXTH     r7,r6                 ;160
000092  4e08              LDR      r6,|L17.180|
000094  f8a67498          STRH     r7,[r6,#0x498]        ;160
000098  f8b66498          LDRH     r6,[r6,#0x498]        ;161
00009c  2703              MOVS     r7,#3                 ;161
00009e  fb96fcf7          SDIV     r12,r6,r7             ;161
0000a2  fb07661c          MLS      r6,r7,r12,r6          ;161
0000a6  b2b7              UXTH     r7,r6                 ;161
0000a8  4e02              LDR      r6,|L17.180|
0000aa  f8a67498          STRH     r7,[r6,#0x498]        ;161
0000ae  bf00              NOP      
0000b0  e7c3              B        |L17.58|
;;;164    
                          ENDP

0000b2  0000              DCW      0x0000
                  |L17.180|
                          DCD      canTestProtocolCB
                  |L17.184|
                          DCD      canTestProtocolCB+0x2aa

                          AREA ||i.CAN_TEST_PROTOCOL_TxStateProcess||, CODE, READONLY, ALIGN=2

                  CAN_TEST_PROTOCOL_TxStateProcess PROC
;;;261    // 协议层发送处理过程
;;;262    void CAN_TEST_PROTOCOL_TxStateProcess(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;263    {
;;;264    	uint16 head = canTestProtocolCB.tx.head;
000004  4826              LDR      r0,|L18.160|
000006  f8b04496          LDRH     r4,[r0,#0x496]
;;;265    	uint16 end =  canTestProtocolCB.tx.end;
00000a  f8b05498          LDRH     r5,[r0,#0x498]
;;;266    	uint16 length = canTestProtocolCB.tx.cmdQueue[head].length;
00000e  eb0400c4          ADD      r0,r4,r4,LSL #3
000012  eb001144          ADD      r1,r0,r4,LSL #5
000016  4823              LDR      r0,|L18.164|
000018  eb000081          ADD      r0,r0,r1,LSL #2
00001c  f8b060a2          LDRH     r6,[r0,#0xa2]
;;;267    	uint8* pCmd = canTestProtocolCB.tx.cmdQueue[head].buff;
000020  eb0400c4          ADD      r0,r4,r4,LSL #3
000024  eb001144          ADD      r1,r0,r4,LSL #5
000028  481e              LDR      r0,|L18.164|
00002a  eb000081          ADD      r0,r0,r1,LSL #2
00002e  1c87              ADDS     r7,r0,#2
;;;268    	uint16 localDeviceID = canTestProtocolCB.tx.cmdQueue[head].deviceID;
000030  eb0400c4          ADD      r0,r4,r4,LSL #3
000034  eb001144          ADD      r1,r0,r4,LSL #5
000038  481a              LDR      r0,|L18.164|
00003a  f8308021          LDRH     r8,[r0,r1,LSL #2]
;;;269    
;;;270    	// 发送缓冲区为空，说明无数据
;;;271    	if (head == end)
00003e  42ac              CMP      r4,r5
000040  d101              BNE      |L18.70|
                  |L18.66|
;;;272    	{
;;;273    		return;
;;;274    	}
;;;275    
;;;276    	// 发送函数没有注册直接返回
;;;277    	if (NULL == canTestProtocolCB.sendDataThrowService)
;;;278    	{
;;;279    		return;
;;;280    	}
;;;281    
;;;282    	// 协议层有数据需要发送到驱动层		
;;;283    	if (!(*canTestProtocolCB.sendDataThrowService)(localDeviceID, pCmd, length))
;;;284    	{
;;;285    		return;
;;;286    	}
;;;287    
;;;288    	// 发送环形队列更新位置
;;;289    	canTestProtocolCB.tx.cmdQueue[head].length = 0;
;;;290    	canTestProtocolCB.tx.head ++;
;;;291    	canTestProtocolCB.tx.head %= CAN_TEST_PROTOCOL_TX_QUEUE_SIZE;
;;;292    }
000042  e8bd81f0          POP      {r4-r8,pc}
                  |L18.70|
000046  4816              LDR      r0,|L18.160|
000048  f8d004a0          LDR      r0,[r0,#0x4a0]        ;277  ; canTestProtocolCB
00004c  b900              CBNZ     r0,|L18.80|
00004e  e7f8              B        |L18.66|
                  |L18.80|
000050  b2f2              UXTB     r2,r6                 ;283
000052  4813              LDR      r0,|L18.160|
000054  4639              MOV      r1,r7                 ;283
000056  f8d034a0          LDR      r3,[r0,#0x4a0]        ;283  ; canTestProtocolCB
00005a  4640              MOV      r0,r8                 ;283
00005c  4798              BLX      r3                    ;283
00005e  b900              CBNZ     r0,|L18.98|
000060  e7ef              B        |L18.66|
                  |L18.98|
000062  2100              MOVS     r1,#0                 ;289
000064  eb0400c4          ADD      r0,r4,r4,LSL #3       ;289
000068  eb001244          ADD      r2,r0,r4,LSL #5       ;289
00006c  480d              LDR      r0,|L18.164|
00006e  eb000082          ADD      r0,r0,r2,LSL #2       ;289
000072  f8a010a2          STRH     r1,[r0,#0xa2]         ;289
000076  480a              LDR      r0,|L18.160|
000078  f8b00496          LDRH     r0,[r0,#0x496]        ;290
00007c  1c40              ADDS     r0,r0,#1              ;290
00007e  b281              UXTH     r1,r0                 ;290
000080  4807              LDR      r0,|L18.160|
000082  f8a01496          STRH     r1,[r0,#0x496]        ;290
000086  f8b00496          LDRH     r0,[r0,#0x496]        ;291
00008a  2103              MOVS     r1,#3                 ;291
00008c  fb90f2f1          SDIV     r2,r0,r1              ;291
000090  fb010012          MLS      r0,r1,r2,r0           ;291
000094  b281              UXTH     r1,r0                 ;291
000096  4802              LDR      r0,|L18.160|
000098  f8a01496          STRH     r1,[r0,#0x496]        ;291
00009c  bf00              NOP      
00009e  e7d0              B        |L18.66|
;;;293    
                          ENDP

                  |L18.160|
                          DCD      canTestProtocolCB
                  |L18.164|
                          DCD      canTestProtocolCB+0x2aa

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  canTestProtocolCB
                          %        1188

;*** Start embedded assembler ***

#line 1 "User\\CanProtocolUpTEST.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_CanProtocolUpTEST_c_00703c21____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___19_CanProtocolUpTEST_c_00703c21____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_CanProtocolUpTEST_c_00703c21____REVSH|
#line 128
|__asm___19_CanProtocolUpTEST_c_00703c21____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
