; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\spiflash.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\spiflash.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -I.\User\qrencode -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.3\Device\Include -D__MICROLIB -D__UVISION_VERSION=539 -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\spiflash.crf User\spiflash.c]
                          THUMB

                          AREA ||i.DMA0_Channel1_IRQHandler||, CODE, READONLY, ALIGN=2

                  DMA0_Channel1_IRQHandler PROC
;;;830    // DMA接收中断RX
;;;831    void DMA0_Channel1_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;832    {
;;;833    	if (dma_interrupt_flag_get(DMA0, DMA_CH1, DMA_INT_FLAG_FTF))
000002  2202              MOVS     r2,#2
000004  2101              MOVS     r1,#1
000006  480d              LDR      r0,|L1.60|
000008  f7fffffe          BL       dma_interrupt_flag_get
00000c  b1a0              CBZ      r0,|L1.56|
;;;834    	{
;;;835    #if STM32_DMA_SPI_DIRECTION
;;;836    		dma_interrupt_flag_clear(DMA0, DMA_CH1, DMA_INT_FLAG_FTF);
00000e  2202              MOVS     r2,#2
000010  2101              MOVS     r1,#1
000012  480a              LDR      r0,|L1.60|
000014  f7fffffe          BL       dma_interrupt_flag_clear
;;;837    
;;;838    		// 禁止SPI
;;;839    		// spi_disable(STM32_SPIx_NUM_DEF);
;;;840    		// 关闭接收DMA
;;;841    		dma_channel_disable(DMA0, DMA_CH1);
000018  2101              MOVS     r1,#1
00001a  4808              LDR      r0,|L1.60|
00001c  f7fffffe          BL       dma_channel_disable
;;;842    
;;;843    		// 禁止接收TC中断
;;;844    		dma_interrupt_disable(DMA0, DMA_CH1, DMA_INT_FTF);
000020  2202              MOVS     r2,#2
000022  2101              MOVS     r1,#1
000024  4805              LDR      r0,|L1.60|
000026  f7fffffe          BL       dma_interrupt_disable
;;;845    
;;;846    		SPI_FLASH_CS_H(); // 结束片选
00002a  2110              MOVS     r1,#0x10
00002c  4804              LDR      r0,|L1.64|
00002e  f7fffffe          BL       gpio_bit_set
;;;847    
;;;848    		// 设置DMA完成标识
;;;849    		spiCB.dmaFinished = TRUE;
000032  2001              MOVS     r0,#1
000034  4903              LDR      r1,|L1.68|
000036  7008              STRB     r0,[r1,#0]
                  |L1.56|
;;;850    #else
;;;851    
;;;852    		dma_interrupt_flag_clear(DMA0, DMA_CH1, DMA_INT_FLAG_FTF);
;;;853    		// 注意:当设置模式为双线只接收或单线接收模式下，不能在此加入忙BSY的判断死等，此时该标志已失效
;;;854    		// 传输的完成就已经是彻底的接收完成，无需别的动作
;;;855    
;;;856    		// 禁止SPI
;;;857    		spi_disable(STM32_SPIx_NUM_DEF);
;;;858    		// 关闭接收DMA
;;;859    		dma_channel_disable(DMA0, DMA_CH1);
;;;860    		// 禁止接收TC中断
;;;861    		dma_interrupt_disable(DMA0, DMA_CH1, DMA_INT_FTF);
;;;862    
;;;863    		SPI_FLASH_CS_H(); // 结束片选
;;;864    
;;;865    		// 设置DMA完成标识
;;;866    		spiCB.dmaFinished = TRUE;
;;;867    #endif
;;;868    	}
;;;869    }
000038  bd10              POP      {r4,pc}
;;;870    
                          ENDP

00003a  0000              DCW      0x0000
                  |L1.60|
                          DCD      0x40020000
                  |L1.64|
                          DCD      0x40010800
                  |L1.68|
                          DCD      spiCB

                          AREA ||i.DMA0_Channel2_IRQHandler||, CODE, READONLY, ALIGN=2

                  DMA0_Channel2_IRQHandler PROC
;;;871    // DMA发送中断TX
;;;872    void DMA0_Channel2_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;873    {
;;;874    	if (dma_interrupt_flag_get(DMA0, DMA_CH2, DMA_INT_FLAG_FTF))
000002  2202              MOVS     r2,#2
000004  4611              MOV      r1,r2
000006  480e              LDR      r0,|L2.64|
000008  f7fffffe          BL       dma_interrupt_flag_get
00000c  b1b8              CBZ      r0,|L2.62|
;;;875    	{
;;;876    		dma_interrupt_flag_clear(DMA0, DMA_CH2, DMA_INT_FLAG_FTF);
00000e  2202              MOVS     r2,#2
000010  4611              MOV      r1,r2
000012  480b              LDR      r0,|L2.64|
000014  f7fffffe          BL       dma_interrupt_flag_clear
;;;877    
;;;878    		// 注意:上面为止DMA已经将所有的数据搬运到SPI_DR，但是，但是，但是实际上SPI数据还没全发送出去
;;;879    		// 因此，软件等待忙标志，确保所有数据都发送出去才能将其关闭
;;;880    		while (spi_i2s_flag_get(STM32_SPIx_NUM_DEF, I2S_FLAG_TRANS) != RESET)
000018  bf00              NOP      
                  |L2.26|
00001a  2180              MOVS     r1,#0x80
00001c  4809              LDR      r0,|L2.68|
00001e  f7fffffe          BL       spi_i2s_flag_get
000022  2800              CMP      r0,#0
000024  d1f9              BNE      |L2.26|
;;;881    			;
;;;882    
;;;883    		// 关闭发送DMA
;;;884    		spi_dma_disable(SPI0, SPI_DMA_TRANSMIT);
000026  2100              MOVS     r1,#0
000028  4806              LDR      r0,|L2.68|
00002a  f7fffffe          BL       spi_dma_disable
;;;885    		// 关闭发送TC中断
;;;886    		dma_interrupt_disable(DMA0, DMA_CH2, DMA_INT_FTF);
00002e  2202              MOVS     r2,#2
000030  4611              MOV      r1,r2
000032  4803              LDR      r0,|L2.64|
000034  f7fffffe          BL       dma_interrupt_disable
;;;887    
;;;888    #if STM32_DMA_SPI_DIRECTION
;;;889    		spiCB.tx_dmaFinished = TRUE;
000038  2001              MOVS     r0,#1
00003a  4903              LDR      r1,|L2.72|
00003c  7048              STRB     r0,[r1,#1]
                  |L2.62|
;;;890    #endif
;;;891    	}
;;;892    }
00003e  bd10              POP      {r4,pc}
;;;893    
                          ENDP

                  |L2.64|
                          DCD      0x40020000
                  |L2.68|
                          DCD      0x40013000
                  |L2.72|
                          DCD      spiCB

                          AREA ||i.DMAy_SPIx_Configuration||, CODE, READONLY, ALIGN=2

                  DMAy_SPIx_Configuration PROC
;;;768    // DMA硬件初始化
;;;769    void DMAy_SPIx_Configuration(void)
000000  b510              PUSH     {r4,lr}
;;;770    {
;;;771    	static uint16 txByte = 0xFF; // 初始一个虚拟地址
;;;772    	static uint16 rxByte = 0xFF; // 初始一个虚拟地址
;;;773    
;;;774    	// 使能时钟DMAy
;;;775    	rcu_periph_clock_enable(RCU_DMA0);
000002  f44f60a0          MOV      r0,#0x500
000006  f7fffffe          BL       rcu_periph_clock_enable
;;;776    
;;;777    	// SPIx Rx DMA
;;;778    	dma_deinit(DMA0, DMA_CH1);
00000a  2101              MOVS     r1,#1
00000c  4839              LDR      r0,|L3.244|
00000e  f7fffffe          BL       dma_deinit
;;;779    	dma_rx_init_struct.periph_addr = STM32_SPIx_DR_Addr;		  // 设置SPI发送外设地址(源地址)
000012  4839              LDR      r0,|L3.248|
000014  4939              LDR      r1,|L3.252|
000016  6008              STR      r0,[r1,#0]  ; dma_rx_init_struct
;;;780    	dma_rx_init_struct.memory_addr = (uint32)(&rxByte);			  // 设置SRAM存储地址(目的地址)
000018  4839              LDR      r0,|L3.256|
00001a  6088              STR      r0,[r1,#8]  ; dma_rx_init_struct
;;;781    	dma_rx_init_struct.direction = DMA_PERIPHERAL_TO_MEMORY;	  // 传输方向外设-内存
00001c  2000              MOVS     r0,#0
00001e  7688              STRB     r0,[r1,#0x1a]
;;;782    	dma_rx_init_struct.number = 0;								  // 设置SPI发送长度
000020  6108              STR      r0,[r1,#0x10]  ; dma_rx_init_struct
;;;783    	dma_rx_init_struct.periph_inc = DMA_PERIPH_INCREASE_DISABLE;  // 外设地址不增加
000022  7608              STRB     r0,[r1,#0x18]
;;;784    	dma_rx_init_struct.memory_inc = DMA_MEMORY_INCREASE_DISABLE;  // 内存地址不增加
000024  7648              STRB     r0,[r1,#0x19]
;;;785    	dma_rx_init_struct.periph_width = DMA_PERIPHERAL_WIDTH_16BIT; // 外设的传输数据宽度16位
000026  f44f7080          MOV      r0,#0x100
00002a  6048              STR      r0,[r1,#4]  ; dma_rx_init_struct
;;;786    	dma_rx_init_struct.memory_width = DMA_MEMORY_WIDTH_16BIT;	  // 存储器的传输数据宽度16位
00002c  0080              LSLS     r0,r0,#2
00002e  60c8              STR      r0,[r1,#0xc]  ; dma_rx_init_struct
;;;787    	dma_circulation_disable(DMA0, DMA_CH1);						  // 不循环
000030  2101              MOVS     r1,#1
000032  4830              LDR      r0,|L3.244|
000034  f7fffffe          BL       dma_circulation_disable
;;;788    	dma_rx_init_struct.priority = DMA_PRIORITY_ULTRA_HIGH;		  // 通道优先级为高
000038  f44f5040          MOV      r0,#0x3000
00003c  492f              LDR      r1,|L3.252|
00003e  6148              STR      r0,[r1,#0x14]  ; dma_rx_init_struct
;;;789    	dma_memory_to_memory_disable(DMA0, DMA_CH1);				  // 失能内存到内存模式
000040  2101              MOVS     r1,#1
000042  482c              LDR      r0,|L3.244|
000044  f7fffffe          BL       dma_memory_to_memory_disable
;;;790    	dma_init(DMA0, DMA_CH1, &dma_rx_init_struct);				  // 初始化DMA0
000048  4a2c              LDR      r2,|L3.252|
00004a  2101              MOVS     r1,#1
00004c  4829              LDR      r0,|L3.244|
00004e  f7fffffe          BL       dma_init
;;;791    
;;;792    	// SPIx Tx DMA
;;;793    	dma_deinit(DMA0, DMA_CH2);
000052  2102              MOVS     r1,#2
000054  4827              LDR      r0,|L3.244|
000056  f7fffffe          BL       dma_deinit
;;;794    	dma_tx_init_struct.periph_addr = STM32_SPIx_DR_Addr;		  // 设置SPI发送外设地址(源地址)
00005a  4827              LDR      r0,|L3.248|
00005c  4929              LDR      r1,|L3.260|
00005e  6008              STR      r0,[r1,#0]  ; dma_tx_init_struct
;;;795    	dma_tx_init_struct.memory_addr = (uint32)(&txByte);			  // 设置SRAM存储地址(目的地址)
000060  4829              LDR      r0,|L3.264|
000062  6088              STR      r0,[r1,#8]  ; dma_tx_init_struct
;;;796    	dma_tx_init_struct.direction = DMA_MEMORY_TO_PERIPHERAL;	  // 传输方向内存-外设
000064  2001              MOVS     r0,#1
000066  7688              STRB     r0,[r1,#0x1a]
;;;797    	dma_tx_init_struct.number = 0;								  // 设置SPI发送长度
000068  2000              MOVS     r0,#0
00006a  6108              STR      r0,[r1,#0x10]  ; dma_tx_init_struct
;;;798    	dma_tx_init_struct.periph_inc = DMA_PERIPH_INCREASE_DISABLE;  // 外设地址不增加
00006c  7608              STRB     r0,[r1,#0x18]
;;;799    	dma_tx_init_struct.memory_inc = DMA_MEMORY_INCREASE_DISABLE;  // 内存地址不增加
00006e  7648              STRB     r0,[r1,#0x19]
;;;800    	dma_tx_init_struct.memory_width = DMA_MEMORY_WIDTH_16BIT;	  // 存储器的传输数据宽度16位
000070  f44f6080          MOV      r0,#0x400
000074  60c8              STR      r0,[r1,#0xc]  ; dma_tx_init_struct
;;;801    	dma_tx_init_struct.periph_width = DMA_PERIPHERAL_WIDTH_16BIT; // 外设的传输数据宽度16位
000076  1080              ASRS     r0,r0,#2
000078  6048              STR      r0,[r1,#4]  ; dma_tx_init_struct
;;;802    	dma_circulation_disable(DMA0, DMA_CH2);						  // 不循环
00007a  2102              MOVS     r1,#2
00007c  481d              LDR      r0,|L3.244|
00007e  f7fffffe          BL       dma_circulation_disable
;;;803    	dma_tx_init_struct.priority = DMA_PRIORITY_MEDIUM;			  // 中断方式
000082  f44f5080          MOV      r0,#0x1000
000086  491f              LDR      r1,|L3.260|
000088  6148              STR      r0,[r1,#0x14]  ; dma_tx_init_struct
;;;804    	dma_memory_to_memory_disable(DMA0, DMA_CH2);				  // 失能内存到内存模式
00008a  2102              MOVS     r1,#2
00008c  4819              LDR      r0,|L3.244|
00008e  f7fffffe          BL       dma_memory_to_memory_disable
;;;805    	dma_init(DMA0, DMA_CH2, &dma_tx_init_struct);				  // 初始化DMA0
000092  4a1c              LDR      r2,|L3.260|
000094  2102              MOVS     r1,#2
000096  4817              LDR      r0,|L3.244|
000098  f7fffffe          BL       dma_init
;;;806    
;;;807    	// 关闭DMA发送/接收中断，清DMA标记，禁止DMA1_TX，RX的传输完成中断
;;;808    	spi_dma_disable(STM32_SPIx_NUM_DEF, SPI_DMA_TRANSMIT);
00009c  2100              MOVS     r1,#0
00009e  4816              LDR      r0,|L3.248|
0000a0  380c              SUBS     r0,r0,#0xc
0000a2  f7fffffe          BL       spi_dma_disable
;;;809    	spi_dma_disable(STM32_SPIx_NUM_DEF, SPI_DMA_RECEIVE);
0000a6  2101              MOVS     r1,#1
0000a8  4813              LDR      r0,|L3.248|
0000aa  380c              SUBS     r0,r0,#0xc
0000ac  f7fffffe          BL       spi_dma_disable
;;;810    	dma_flag_clear(DMA0, DMA_CH1, DMA_FLAG_G);
0000b0  2201              MOVS     r2,#1
0000b2  4611              MOV      r1,r2
0000b4  480f              LDR      r0,|L3.244|
0000b6  f7fffffe          BL       dma_flag_clear
;;;811    	dma_flag_clear(DMA0, DMA_CH2, DMA_FLAG_G);
0000ba  2201              MOVS     r2,#1
0000bc  2102              MOVS     r1,#2
0000be  480d              LDR      r0,|L3.244|
0000c0  f7fffffe          BL       dma_flag_clear
;;;812    	dma_interrupt_disable(DMA0, DMA_CH1, DMA_INT_FTF);
0000c4  2202              MOVS     r2,#2
0000c6  2101              MOVS     r1,#1
0000c8  480a              LDR      r0,|L3.244|
0000ca  f7fffffe          BL       dma_interrupt_disable
;;;813    	dma_interrupt_disable(DMA0, DMA_CH2, DMA_INT_FTF);
0000ce  2202              MOVS     r2,#2
0000d0  4611              MOV      r1,r2
0000d2  4808              LDR      r0,|L3.244|
0000d4  f7fffffe          BL       dma_interrupt_disable
;;;814    
;;;815    	// 使能SPIx的DMA发送，接收请求
;;;816    	spi_dma_enable(STM32_SPIx_NUM_DEF, SPI_DMA_TRANSMIT);
0000d8  2100              MOVS     r1,#0
0000da  4807              LDR      r0,|L3.248|
0000dc  380c              SUBS     r0,r0,#0xc
0000de  f7fffffe          BL       spi_dma_enable
;;;817    	spi_dma_enable(STM32_SPIx_NUM_DEF, SPI_DMA_RECEIVE);
0000e2  2101              MOVS     r1,#1
0000e4  4804              LDR      r0,|L3.248|
0000e6  380c              SUBS     r0,r0,#0xc
0000e8  f7fffffe          BL       spi_dma_enable
;;;818    
;;;819    	// 使能NVIC中断
;;;820    	NVIC_DMAy_Configuration();
0000ec  f7fffffe          BL       NVIC_DMAy_Configuration
;;;821    }
0000f0  bd10              POP      {r4,pc}
;;;822    
                          ENDP

0000f2  0000              DCW      0x0000
                  |L3.244|
                          DCD      0x40020000
                  |L3.248|
                          DCD      0x4001300c
                  |L3.252|
                          DCD      dma_rx_init_struct
                  |L3.256|
                          DCD      rxByte
                  |L3.260|
                          DCD      dma_tx_init_struct
                  |L3.264|
                          DCD      txByte

                          AREA ||i.NVIC_DMAy_Configuration||, CODE, READONLY, ALIGN=1

                  NVIC_DMAy_Configuration PROC
;;;823    // 配置DMA通道中断
;;;824    static void NVIC_DMAy_Configuration(void)
000000  b510              PUSH     {r4,lr}
;;;825    {
;;;826    	nvic_irq_enable(DMA0_Channel1_IRQn, 2, 0); // 设置中断优先级
000002  2200              MOVS     r2,#0
000004  2102              MOVS     r1,#2
000006  200c              MOVS     r0,#0xc
000008  f7fffffe          BL       nvic_irq_enable
;;;827    	nvic_irq_enable(DMA0_Channel2_IRQn, 2, 0); // 设置中断优先级
00000c  2200              MOVS     r2,#0
00000e  2102              MOVS     r1,#2
000010  200d              MOVS     r0,#0xd
000012  f7fffffe          BL       nvic_irq_enable
;;;828    }
000016  bd10              POP      {r4,pc}
;;;829    
                          ENDP


                          AREA ||i.SPI_FLASH_EraseBlock||, CODE, READONLY, ALIGN=2

                  SPI_FLASH_EraseBlock PROC
;;;146    // 擦除块
;;;147    void SPI_FLASH_EraseBlock(uint32 BlockAddr)
000000  b510              PUSH     {r4,lr}
;;;148    {
000002  4604              MOV      r4,r0
;;;149    	// 使能写入操作
;;;150    	SPI_FLASH_WriteEnable();
000004  f7fffffe          BL       SPI_FLASH_WriteEnable
;;;151    
;;;152    	// 片选
;;;153    	SPI_FLASH_CS_L();
000008  2110              MOVS     r1,#0x10
00000a  480c              LDR      r0,|L5.60|
00000c  f7fffffe          BL       gpio_bit_reset
;;;154    
;;;155    	// 发送64K擦除命令
;;;156    	SPI_FLASH_SendByte(CMD_BLOCK_ERASE_64K);
000010  20d8              MOVS     r0,#0xd8
000012  f7fffffe          BL       SPI_FLASH_SendByte
;;;157    
;;;158    	// 发送24位地址
;;;159    	SPI_FLASH_SendByte((BlockAddr & 0xFF0000) >> 16);
000016  f3c44007          UBFX     r0,r4,#16,#8
00001a  f7fffffe          BL       SPI_FLASH_SendByte
;;;160    	SPI_FLASH_SendByte((BlockAddr & 0xFF00) >> 8);
00001e  f3c42007          UBFX     r0,r4,#8,#8
000022  f7fffffe          BL       SPI_FLASH_SendByte
;;;161    	SPI_FLASH_SendByte(BlockAddr & 0xFF);
000026  b2e0              UXTB     r0,r4
000028  f7fffffe          BL       SPI_FLASH_SendByte
;;;162    
;;;163    	// 释放
;;;164    	SPI_FLASH_CS_H();
00002c  2110              MOVS     r1,#0x10
00002e  4803              LDR      r0,|L5.60|
000030  f7fffffe          BL       gpio_bit_set
;;;165    
;;;166    	// 等待写入完成
;;;167    	SPI_FLASH_WaitForWriteEnd();
000034  f7fffffe          BL       SPI_FLASH_WaitForWriteEnd
;;;168    }
000038  bd10              POP      {r4,pc}
;;;169    
                          ENDP

00003a  0000              DCW      0x0000
                  |L5.60|
                          DCD      0x40010800

                          AREA ||i.SPI_FLASH_EraseChip||, CODE, READONLY, ALIGN=2

                  SPI_FLASH_EraseChip PROC
;;;170    // 擦除整个Flash
;;;171    void SPI_FLASH_EraseChip(void)
000000  b510              PUSH     {r4,lr}
;;;172    {
;;;173    	// 使能写入操作
;;;174    	SPI_FLASH_WriteEnable();
000002  f7fffffe          BL       SPI_FLASH_WriteEnable
;;;175    
;;;176    	// 片选
;;;177    	SPI_FLASH_CS_L();
000006  2110              MOVS     r1,#0x10
000008  4806              LDR      r0,|L6.36|
00000a  f7fffffe          BL       gpio_bit_reset
;;;178    
;;;179    	// 发送片擦除命令
;;;180    	SPI_FLASH_SendByte(CMD_CHIP_ERASE);
00000e  20c7              MOVS     r0,#0xc7
000010  f7fffffe          BL       SPI_FLASH_SendByte
;;;181    
;;;182    	// 释放
;;;183    	SPI_FLASH_CS_H();
000014  2110              MOVS     r1,#0x10
000016  4803              LDR      r0,|L6.36|
000018  f7fffffe          BL       gpio_bit_set
;;;184    
;;;185    	// 等待写入完成
;;;186    	SPI_FLASH_WaitForWriteEnd();
00001c  f7fffffe          BL       SPI_FLASH_WaitForWriteEnd
;;;187    }
000020  bd10              POP      {r4,pc}
;;;188    
                          ENDP

000022  0000              DCW      0x0000
                  |L6.36|
                          DCD      0x40010800

                          AREA ||i.SPI_FLASH_EraseRoom||, CODE, READONLY, ALIGN=1

                  SPI_FLASH_EraseRoom PROC
;;;508    // 擦除指定空间 先擦扇区再擦块再擦扇区
;;;509    void SPI_FLASH_EraseRoom(uint32 Addr, uint32 size)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;510    {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
;;;511    
;;;512    	uint16 blockStartNum = 0;	  // 块号
000008  f04f0800          MOV      r8,#0
;;;513    	uint16 blockCount = 0;		  // 需要擦除块的数量
00000c  46c1              MOV      r9,r8
;;;514    	uint16 blockSectorOffset = 0; // 块内扇区偏移量
00000e  2600              MOVS     r6,#0
;;;515    	uint16 i;
;;;516    
;;;517    	blockSectorOffset = Addr / SPI_FLASH_SECTOR_SIZE % SPI_FLASH_BLOCK_PER_16SECTORS;
000010  f3c53603          UBFX     r6,r5,#12,#4
;;;518    
;;;519    	if (blockSectorOffset) // 擦除扇区在块内存在偏移量
000014  b12e              CBZ      r6,|L7.34|
;;;520    	{
;;;521    		blockStartNum = Addr / SPI_FLASH_BLOCK_SIZE + 1;
000016  2001              MOVS     r0,#1
000018  eb004015          ADD      r0,r0,r5,LSR #16
00001c  fa1ff880          UXTH     r8,r0
000020  e003              B        |L7.42|
                  |L7.34|
;;;522    	}
;;;523    	else // 擦除开始地址等于块的起始地址，不存在偏移
;;;524    	{
;;;525    		blockStartNum = Addr / SPI_FLASH_BLOCK_SIZE;
000022  f64f70ff          MOV      r0,#0xffff
000026  ea004815          AND      r8,r0,r5,LSR #16
                  |L7.42|
;;;526    	}
;;;527    
;;;528    	// 擦除起始块内扇区偏移
;;;529    	for (i = 0; i < SPI_FLASH_BLOCK_PER_16SECTORS - blockSectorOffset; i++)
00002a  2400              MOVS     r4,#0
00002c  e006              B        |L7.60|
                  |L7.46|
;;;530    	{
;;;531    		SPI_FLASH_EraseSector((Addr / SPI_FLASH_SECTOR_SIZE + i) * SPI_FLASH_SECTOR_SIZE);
00002e  eb043115          ADD      r1,r4,r5,LSR #12
000032  0308              LSLS     r0,r1,#12
000034  f7fffffe          BL       SPI_FLASH_EraseSector
000038  1c60              ADDS     r0,r4,#1              ;529
00003a  b284              UXTH     r4,r0                 ;529
                  |L7.60|
00003c  f1c60010          RSB      r0,r6,#0x10           ;529
000040  42a0              CMP      r0,r4                 ;529
000042  dcf4              BGT      |L7.46|
;;;532    	}
;;;533    
;;;534    	// 计算出需要擦除的块的数量
;;;535    	blockCount = ((size / SPI_FLASH_SECTOR_SIZE) - (SPI_FLASH_BLOCK_PER_16SECTORS - blockSectorOffset)) / SPI_FLASH_BLOCK_PER_16SECTORS;
000044  f1c60010          RSB      r0,r6,#0x10
000048  ebc03017          RSB      r0,r0,r7,LSR #12
00004c  f3c0190f          UBFX     r9,r0,#4,#16
;;;536    
;;;537    	// 擦除块
;;;538    	for (i = 0; i < blockCount; i++)
000050  2400              MOVS     r4,#0
000052  e006              B        |L7.98|
                  |L7.84|
;;;539    	{
;;;540    		SPI_FLASH_EraseBlock((blockStartNum + i) * SPI_FLASH_BLOCK_SIZE);
000054  eb080104          ADD      r1,r8,r4
000058  0408              LSLS     r0,r1,#16
00005a  f7fffffe          BL       SPI_FLASH_EraseBlock
00005e  1c60              ADDS     r0,r4,#1              ;538
000060  b284              UXTH     r4,r0                 ;538
                  |L7.98|
000062  454c              CMP      r4,r9                 ;538
000064  dbf6              BLT      |L7.84|
;;;541    	}
;;;542    
;;;543    	// 擦除剩余扇区,剩余的扇区不满一个块
;;;544    	for (i = 0; i < ((size / SPI_FLASH_SECTOR_SIZE) - (SPI_FLASH_BLOCK_PER_16SECTORS - blockSectorOffset)) % SPI_FLASH_BLOCK_PER_16SECTORS; i++)
000066  2400              MOVS     r4,#0
000068  e008              B        |L7.124|
                  |L7.106|
;;;545    	{
;;;546    		SPI_FLASH_EraseSector((blockStartNum + blockCount) * SPI_FLASH_BLOCK_SIZE + i * SPI_FLASH_SECTOR_SIZE);
00006a  eb080109          ADD      r1,r8,r9
00006e  0409              LSLS     r1,r1,#16
000070  eb013004          ADD      r0,r1,r4,LSL #12
000074  f7fffffe          BL       SPI_FLASH_EraseSector
000078  1c60              ADDS     r0,r4,#1              ;544
00007a  b284              UXTH     r4,r0                 ;544
                  |L7.124|
00007c  4270              RSBS     r0,r6,#0              ;544
00007e  ebc03017          RSB      r0,r0,r7,LSR #12      ;544
000082  f000000f          AND      r0,r0,#0xf            ;544
000086  42a0              CMP      r0,r4                 ;544
000088  d8ef              BHI      |L7.106|
;;;547    	}
;;;548    }
00008a  e8bd87f0          POP      {r4-r10,pc}
;;;549    
                          ENDP


                          AREA ||i.SPI_FLASH_EraseSector||, CODE, READONLY, ALIGN=2

                  SPI_FLASH_EraseSector PROC
;;;122    // 擦除扇区
;;;123    void SPI_FLASH_EraseSector(uint32 SectorAddr)
000000  b510              PUSH     {r4,lr}
;;;124    {
000002  4604              MOV      r4,r0
;;;125    	// 使能写入操作
;;;126    	SPI_FLASH_WriteEnable();
000004  f7fffffe          BL       SPI_FLASH_WriteEnable
;;;127    
;;;128    	// 片选
;;;129    	SPI_FLASH_CS_L();
000008  2110              MOVS     r1,#0x10
00000a  480c              LDR      r0,|L8.60|
00000c  f7fffffe          BL       gpio_bit_reset
;;;130    
;;;131    	// 发送扇区擦除命令
;;;132    	SPI_FLASH_SendByte(CMD_SECTOR_ERASE_4K);
000010  2020              MOVS     r0,#0x20
000012  f7fffffe          BL       SPI_FLASH_SendByte
;;;133    
;;;134    	// 发送24位地址
;;;135    	SPI_FLASH_SendByte((SectorAddr & 0xFF0000) >> 16);
000016  f3c44007          UBFX     r0,r4,#16,#8
00001a  f7fffffe          BL       SPI_FLASH_SendByte
;;;136    	SPI_FLASH_SendByte((SectorAddr & 0xFF00) >> 8);
00001e  f3c42007          UBFX     r0,r4,#8,#8
000022  f7fffffe          BL       SPI_FLASH_SendByte
;;;137    	SPI_FLASH_SendByte(SectorAddr & 0xFF);
000026  b2e0              UXTB     r0,r4
000028  f7fffffe          BL       SPI_FLASH_SendByte
;;;138    
;;;139    	// 释放
;;;140    	SPI_FLASH_CS_H();
00002c  2110              MOVS     r1,#0x10
00002e  4803              LDR      r0,|L8.60|
000030  f7fffffe          BL       gpio_bit_set
;;;141    
;;;142    	// 等待写入完成
;;;143    	SPI_FLASH_WaitForWriteEnd();
000034  f7fffffe          BL       SPI_FLASH_WaitForWriteEnd
;;;144    }
000038  bd10              POP      {r4,pc}
;;;145    
                          ENDP

00003a  0000              DCW      0x0000
                  |L8.60|
                          DCD      0x40010800

                          AREA ||i.SPI_FLASH_ReadArray||, CODE, READONLY, ALIGN=2

                  SPI_FLASH_ReadArray PROC
;;;352    // 读取数据至指定缓冲区，数据个数最大可以为整片容量
;;;353    void SPI_FLASH_ReadArray(uint8 *pBuffer, uint32 ReadAddr, uint16 NumByteToRead)
000000  b570              PUSH     {r4-r6,lr}
;;;354    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;355    	// 片选
;;;356    	SPI_FLASH_CS_H();
000008  2110              MOVS     r1,#0x10
00000a  4815              LDR      r0,|L9.96|
00000c  f7fffffe          BL       gpio_bit_set
;;;357    
;;;358    	// 指针非空判断
;;;359    	if (NULL == pBuffer)
000010  b904              CBNZ     r4,|L9.20|
                  |L9.18|
;;;360    	{
;;;361    		return;
;;;362    	}
;;;363    
;;;364    	// 要读取的数据量为0，退出
;;;365    	if (0 == NumByteToRead)
;;;366    	{
;;;367    		return;
;;;368    	}
;;;369    
;;;370    	// 片选
;;;371    	SPI_FLASH_CS_L();
;;;372    
;;;373    	// 发送读取命令
;;;374    	SPI_FLASH_SendByte(CMD_READ_BYTE);
;;;375    
;;;376    	// 发送24位起始地址
;;;377    	SPI_FLASH_SendByte((ReadAddr & 0xFF0000) >> 16);
;;;378    	SPI_FLASH_SendByte((ReadAddr & 0xFF00) >> 8);
;;;379    	SPI_FLASH_SendByte(ReadAddr & 0xFF);
;;;380    
;;;381    	// 一直读取完指定的数量为止
;;;382    	while (NumByteToRead--)
;;;383    	{
;;;384    		// 读取一个字节
;;;385    		*(pBuffer++) = SPI_FLASH_SendByte(0);
;;;386    	}
;;;387    
;;;388    	// 释放
;;;389    	SPI_FLASH_CS_H();
;;;390    }
000012  bd70              POP      {r4-r6,pc}
                  |L9.20|
000014  b906              CBNZ     r6,|L9.24|
000016  e7fc              B        |L9.18|
                  |L9.24|
000018  2110              MOVS     r1,#0x10              ;371
00001a  4811              LDR      r0,|L9.96|
00001c  f7fffffe          BL       gpio_bit_reset
000020  2003              MOVS     r0,#3                 ;374
000022  f7fffffe          BL       SPI_FLASH_SendByte
000026  f3c54007          UBFX     r0,r5,#16,#8          ;377
00002a  f7fffffe          BL       SPI_FLASH_SendByte
00002e  f3c52007          UBFX     r0,r5,#8,#8           ;378
000032  f7fffffe          BL       SPI_FLASH_SendByte
000036  b2e8              UXTB     r0,r5                 ;379
000038  f7fffffe          BL       SPI_FLASH_SendByte
00003c  e004              B        |L9.72|
                  |L9.62|
00003e  2000              MOVS     r0,#0                 ;385
000040  f7fffffe          BL       SPI_FLASH_SendByte
000044  f8040b01          STRB     r0,[r4],#1            ;385
                  |L9.72|
000048  1e30              SUBS     r0,r6,#0              ;382
00004a  f1a60101          SUB      r1,r6,#1              ;382
00004e  b28e              UXTH     r6,r1                 ;382
000050  d1f5              BNE      |L9.62|
000052  2110              MOVS     r1,#0x10              ;389
000054  4802              LDR      r0,|L9.96|
000056  f7fffffe          BL       gpio_bit_set
00005a  bf00              NOP      
00005c  e7d9              B        |L9.18|
;;;391    
                          ENDP

00005e  0000              DCW      0x0000
                  |L9.96|
                          DCD      0x40010800

                          AREA ||i.SPI_FLASH_ReadByte||, CODE, READONLY, ALIGN=1

                  SPI_FLASH_ReadByte PROC
;;;324    
;;;325    uint8 SPI_FLASH_ReadByte(uint32 ReadAddr)
000000  b538              PUSH     {r3-r5,lr}
;;;326    {
000002  4604              MOV      r4,r0
;;;327    	uint8 buff[4];
;;;328    
;;;329    	SPI_FLASH_ReadArray(buff, ReadAddr, 4);
000004  2204              MOVS     r2,#4
000006  4621              MOV      r1,r4
000008  4668              MOV      r0,sp
00000a  f7fffffe          BL       SPI_FLASH_ReadArray
;;;330    
;;;331    	return buff[0];
00000e  f89d0000          LDRB     r0,[sp,#0]
;;;332    }
000012  bd38              POP      {r3-r5,pc}
;;;333    
                          ENDP


                          AREA ||i.SPI_FLASH_ReadChipID||, CODE, READONLY, ALIGN=2

                  SPI_FLASH_ReadChipID PROC
;;;392    // 读取芯片ID
;;;393    uint16 SPI_FLASH_ReadChipID(void)
000000  b510              PUSH     {r4,lr}
;;;394    {
;;;395    	uint16 W25xXX_ID = 0;
000002  2400              MOVS     r4,#0
;;;396    
;;;397    	// 使能写入操作
;;;398    	SPI_FLASH_WriteEnable();
000004  f7fffffe          BL       SPI_FLASH_WriteEnable
;;;399    
;;;400    	SPI_FLASH_CS_L();
000008  2110              MOVS     r1,#0x10
00000a  4811              LDR      r0,|L11.80|
00000c  f7fffffe          BL       gpio_bit_reset
;;;401    
;;;402    	// 发送读取ID命令
;;;403    	SPI_FLASH_SendByte(CMD_MANUFACT_DEVICE_ID);
000010  2090              MOVS     r0,#0x90
000012  f7fffffe          BL       SPI_FLASH_SendByte
;;;404    
;;;405    	// 发送24位的地址
;;;406    	SPI_FLASH_SendByte(0x00); // dummy
000016  2000              MOVS     r0,#0
000018  f7fffffe          BL       SPI_FLASH_SendByte
;;;407    	SPI_FLASH_SendByte(0x00); // dummy
00001c  2000              MOVS     r0,#0
00001e  f7fffffe          BL       SPI_FLASH_SendByte
;;;408    	SPI_FLASH_SendByte(0x00); // 0x00
000022  2000              MOVS     r0,#0
000024  f7fffffe          BL       SPI_FLASH_SendByte
;;;409    
;;;410    	// 读取返回的16位值
;;;411    	W25xXX_ID = SPI_FLASH_SendByte(0xFF); // 高8位数据
000028  20ff              MOVS     r0,#0xff
00002a  f7fffffe          BL       SPI_FLASH_SendByte
00002e  4604              MOV      r4,r0
;;;412    	W25xXX_ID <<= 8;
000030  f64f70ff          MOV      r0,#0xffff
000034  ea002404          AND      r4,r0,r4,LSL #8
;;;413    	W25xXX_ID += SPI_FLASH_SendByte(0xFF); // 底8位数据
000038  20ff              MOVS     r0,#0xff
00003a  f7fffffe          BL       SPI_FLASH_SendByte
00003e  4420              ADD      r0,r0,r4
000040  b284              UXTH     r4,r0
;;;414    
;;;415    	SPI_FLASH_CS_H();
000042  2110              MOVS     r1,#0x10
000044  4802              LDR      r0,|L11.80|
000046  f7fffffe          BL       gpio_bit_set
;;;416    
;;;417    	return W25xXX_ID;
00004a  4620              MOV      r0,r4
;;;418    }
00004c  bd10              POP      {r4,pc}
;;;419    
                          ENDP

00004e  0000              DCW      0x0000
                  |L11.80|
                          DCD      0x40010800

                          AREA ||i.SPI_FLASH_ReadHalfWord||, CODE, READONLY, ALIGN=1

                  SPI_FLASH_ReadHalfWord PROC
;;;333    
;;;334    uint16 SPI_FLASH_ReadHalfWord(uint32 ReadAddr)
000000  b538              PUSH     {r3-r5,lr}
;;;335    {
000002  4604              MOV      r4,r0
;;;336    	uint8 buff[4];
;;;337    
;;;338    	SPI_FLASH_ReadArray(buff, ReadAddr, 4);
000004  2204              MOVS     r2,#4
000006  4621              MOV      r1,r4
000008  4668              MOV      r0,sp
00000a  f7fffffe          BL       SPI_FLASH_ReadArray
;;;339    
;;;340    	return ((uint16)buff[0] << 8) + buff[1];
00000e  f89d0001          LDRB     r0,[sp,#1]
000012  f89d1000          LDRB     r1,[sp,#0]
000016  eb002001          ADD      r0,r0,r1,LSL #8
00001a  b280              UXTH     r0,r0
;;;341    }
00001c  bd38              POP      {r3-r5,pc}
;;;342    
                          ENDP


                          AREA ||i.SPI_FLASH_ReadWord||, CODE, READONLY, ALIGN=1

                  SPI_FLASH_ReadWord PROC
;;;342    
;;;343    uint32 SPI_FLASH_ReadWord(uint32 ReadAddr)
000000  b538              PUSH     {r3-r5,lr}
;;;344    {
000002  4604              MOV      r4,r0
;;;345    	uint8 buff[4];
;;;346    
;;;347    	SPI_FLASH_ReadArray(buff, ReadAddr, 4);
000004  2204              MOVS     r2,#4
000006  4621              MOV      r1,r4
000008  4668              MOV      r0,sp
00000a  f7fffffe          BL       SPI_FLASH_ReadArray
;;;348    
;;;349    	return ((uint32)buff[0] << 24) + ((uint32)buff[1] << 16) + ((uint32)buff[2] << 8) + buff[3];
00000e  f89d0000          LDRB     r0,[sp,#0]
000012  0600              LSLS     r0,r0,#24
000014  f89d1001          LDRB     r1,[sp,#1]
000018  eb004001          ADD      r0,r0,r1,LSL #16
00001c  f89d1002          LDRB     r1,[sp,#2]
000020  eb002001          ADD      r0,r0,r1,LSL #8
000024  f89d1003          LDRB     r1,[sp,#3]
000028  4408              ADD      r0,r0,r1
;;;350    }
00002a  bd38              POP      {r3-r5,pc}
;;;351    
                          ENDP


                          AREA ||i.SPI_FLASH_SendByte||, CODE, READONLY, ALIGN=2

                  SPI_FLASH_SendByte PROC
;;;420    // 发送一个字节
;;;421    uint8 SPI_FLASH_SendByte(uint8 byte)
000000  b570              PUSH     {r4-r6,lr}
;;;422    {
000002  4604              MOV      r4,r0
;;;423    	// 发送寄存器不为空，等待
;;;424    	uint16 spiRetryTime = 0;
000004  2500              MOVS     r5,#0
;;;425    
;;;426    	while (spi_i2s_flag_get(STM32_SPIx_NUM_DEF, SPI_STAT_TBE) == RESET)
000006  e006              B        |L14.22|
                  |L14.8|
;;;427    	{
;;;428    		if (spiRetryTime++ > SPI_FLASH_RETRY_READ_TIME)
000008  4628              MOV      r0,r5
00000a  1c69              ADDS     r1,r5,#1
00000c  b28d              UXTH     r5,r1
00000e  28c8              CMP      r0,#0xc8
000010  d901              BLS      |L14.22|
;;;429    		{
;;;430    			return 0x00;
000012  2000              MOVS     r0,#0
                  |L14.20|
;;;431    		}
;;;432    	}
;;;433    	// 发送
;;;434    	spi_i2s_data_transmit(STM32_SPIx_NUM_DEF, byte);
;;;435    
;;;436    	// 接收寄存器为空，等待
;;;437    	spiRetryTime = 0;
;;;438    	while (spi_i2s_flag_get(STM32_SPIx_NUM_DEF, SPI_STAT_RBNE) == RESET)
;;;439    	{
;;;440    		if (spiRetryTime++ > SPI_FLASH_RETRY_READ_TIME)
;;;441    		{
;;;442    			return 0x00;
;;;443    		}
;;;444    	}
;;;445    
;;;446    	// 返回接收到的值
;;;447    	return spi_i2s_data_receive(STM32_SPIx_NUM_DEF);
;;;448    }
000014  bd70              POP      {r4-r6,pc}
                  |L14.22|
000016  2102              MOVS     r1,#2                 ;426
000018  480e              LDR      r0,|L14.84|
00001a  f7fffffe          BL       spi_i2s_flag_get
00001e  2800              CMP      r0,#0                 ;426
000020  d0f2              BEQ      |L14.8|
000022  4621              MOV      r1,r4                 ;434
000024  480b              LDR      r0,|L14.84|
000026  f7fffffe          BL       spi_i2s_data_transmit
00002a  2500              MOVS     r5,#0                 ;437
00002c  e006              B        |L14.60|
                  |L14.46|
00002e  4628              MOV      r0,r5                 ;440
000030  1c69              ADDS     r1,r5,#1              ;440
000032  b28d              UXTH     r5,r1                 ;440
000034  28c8              CMP      r0,#0xc8              ;440
000036  d901              BLS      |L14.60|
000038  2000              MOVS     r0,#0                 ;442
00003a  e7eb              B        |L14.20|
                  |L14.60|
00003c  2101              MOVS     r1,#1                 ;438
00003e  4805              LDR      r0,|L14.84|
000040  f7fffffe          BL       spi_i2s_flag_get
000044  2800              CMP      r0,#0                 ;438
000046  d0f2              BEQ      |L14.46|
000048  4802              LDR      r0,|L14.84|
00004a  f7fffffe          BL       spi_i2s_data_receive
00004e  b2c0              UXTB     r0,r0                 ;447
000050  e7e0              B        |L14.20|
;;;449    
                          ENDP

000052  0000              DCW      0x0000
                  |L14.84|
                          DCD      0x40013000

                          AREA ||i.SPI_FLASH_WaitForWriteEnd||, CODE, READONLY, ALIGN=2

                  SPI_FLASH_WaitForWriteEnd PROC
;;;486    // 等待写入操作完成
;;;487    void SPI_FLASH_WaitForWriteEnd(void)
000000  b510              PUSH     {r4,lr}
;;;488    {
;;;489    	uint8 flashstatus = 0;
000002  2400              MOVS     r4,#0
;;;490    
;;;491    	// 片选
;;;492    	SPI_FLASH_CS_L();
000004  2110              MOVS     r1,#0x10
000006  480a              LDR      r0,|L15.48|
000008  f7fffffe          BL       gpio_bit_reset
;;;493    
;;;494    	// 发送读取状态寄存器1的命令
;;;495    	SPI_FLASH_SendByte(CMD_READ_STATUS_REGISTER1);
00000c  2005              MOVS     r0,#5
00000e  f7fffffe          BL       SPI_FLASH_SendByte
;;;496    
;;;497    	// 写入中，持续等待
;;;498    	do
000012  bf00              NOP      
                  |L15.20|
;;;499    	{
;;;500    		// 发送一个假数据，即可产生SPI时钟
;;;501    		flashstatus = SPI_FLASH_SendByte(0);
000014  2000              MOVS     r0,#0
000016  f7fffffe          BL       SPI_FLASH_SendByte
00001a  4604              MOV      r4,r0
;;;502    	} while ((flashstatus & BUSY_FLAG) == BUSY_FLAG);
00001c  f0040001          AND      r0,r4,#1
000020  2800              CMP      r0,#0
000022  d1f7              BNE      |L15.20|
;;;503    
;;;504    	// 释放
;;;505    	SPI_FLASH_CS_H();
000024  2110              MOVS     r1,#0x10
000026  4802              LDR      r0,|L15.48|
000028  f7fffffe          BL       gpio_bit_set
;;;506    }
00002c  bd10              POP      {r4,pc}
;;;507    
                          ENDP

00002e  0000              DCW      0x0000
                  |L15.48|
                          DCD      0x40010800

                          AREA ||i.SPI_FLASH_WriteArray||, CODE, READONLY, ALIGN=1

                  SPI_FLASH_WriteArray PROC
;;;228    // 将指定缓冲区的数据写入指定开始地址的区域
;;;229    void SPI_FLASH_WriteArray(uint8 *pBuffer, uint32 WriteAddr, uint16 NumByteToWrite)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;230    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
;;;231    	uint8 NumOfPage = 0, NumOfRestByte = 0, StartAddrOffset = 0, RestSpace = 0, temp = 0;
00000a  f04f0800          MOV      r8,#0
00000e  46c1              MOV      r9,r8
000010  46c2              MOV      r10,r8
000012  2500              MOVS     r5,#0
000014  46ab              MOV      r11,r5
;;;232    
;;;233    	// 指针非空判断
;;;234    	if (NULL == pBuffer)
000016  b90e              CBNZ     r6,|L16.28|
                  |L16.24|
;;;235    	{
;;;236    		return;
;;;237    	}
;;;238    
;;;239    	// 写入数据量为0，退出
;;;240    	if (0 == NumByteToWrite)
;;;241    	{
;;;242    		return;
;;;243    	}
;;;244    
;;;245    	StartAddrOffset = WriteAddr % SPI_FLASH_PAGE_SIZE;
;;;246    	RestSpace = SPI_FLASH_PAGE_SIZE - StartAddrOffset;
;;;247    	NumOfPage = NumByteToWrite / SPI_FLASH_PAGE_SIZE;
;;;248    	NumOfRestByte = NumByteToWrite % SPI_FLASH_PAGE_SIZE;
;;;249    
;;;250    	// 起始地址刚好位于当前页的起点
;;;251    	if (StartAddrOffset == 0)
;;;252    	{
;;;253    		// 数据量不足一页，直接写入
;;;254    		if (NumOfPage == 0)
;;;255    		{
;;;256    			SPI_FLASH_WritePage(pBuffer, WriteAddr, NumByteToWrite);
;;;257    		}
;;;258    		// 数据量超出一页
;;;259    		else
;;;260    		{
;;;261    			// 整页的部分，直接写入整页
;;;262    			while (NumOfPage--)
;;;263    			{
;;;264    				// 在当前页写满
;;;265    				SPI_FLASH_WritePage(pBuffer, WriteAddr, SPI_FLASH_PAGE_SIZE);
;;;266    
;;;267    				WriteAddr += SPI_FLASH_PAGE_SIZE;
;;;268    				pBuffer += SPI_FLASH_PAGE_SIZE;
;;;269    			}
;;;270    
;;;271    			// 写入不足一页的部分
;;;272    			SPI_FLASH_WritePage(pBuffer, WriteAddr, NumOfRestByte);
;;;273    		}
;;;274    	}
;;;275    	// 起始地址不是当前页的起点，即从中间插入写入
;;;276    	else
;;;277    	{
;;;278    		// 数据量不足一页，直接写入
;;;279    		if (NumOfPage == 0)
;;;280    		{
;;;281    			// 要写入的数据量超过了当前页剩余空间，则分开两次写入
;;;282    			if (NumOfRestByte > RestSpace)
;;;283    			{
;;;284    				// 先将当前页填满
;;;285    				temp = NumOfRestByte - RestSpace;
;;;286    
;;;287    				SPI_FLASH_WritePage(pBuffer, WriteAddr, RestSpace);
;;;288    				WriteAddr += RestSpace;
;;;289    				pBuffer += RestSpace;
;;;290    
;;;291    				// 再将剩余的数据写入下一页
;;;292    				SPI_FLASH_WritePage(pBuffer, WriteAddr, temp);
;;;293    			}
;;;294    			// 要写入的数据量不超过当前页的剩余空间，则直接写入
;;;295    			else
;;;296    			{
;;;297    				SPI_FLASH_WritePage(pBuffer, WriteAddr, NumByteToWrite);
;;;298    			}
;;;299    		}
;;;300    		// 数据量超过一页
;;;301    		else
;;;302    		{
;;;303    			// 先将当前页填满
;;;304    			SPI_FLASH_WritePage(pBuffer, WriteAddr, RestSpace);
;;;305    			WriteAddr += RestSpace;
;;;306    			pBuffer += RestSpace;
;;;307    
;;;308    			// 剩余的数据，写入起点就是下一页的起点了，和上面第一种情况相同的处理
;;;309    			NumByteToWrite -= RestSpace;
;;;310    			NumOfPage = NumByteToWrite / SPI_FLASH_PAGE_SIZE;
;;;311    			NumOfRestByte = NumByteToWrite % SPI_FLASH_PAGE_SIZE;
;;;312    
;;;313    			while (NumOfPage--)
;;;314    			{
;;;315    				SPI_FLASH_WritePage(pBuffer, WriteAddr, SPI_FLASH_PAGE_SIZE);
;;;316    				WriteAddr += SPI_FLASH_PAGE_SIZE;
;;;317    				pBuffer += SPI_FLASH_PAGE_SIZE;
;;;318    			}
;;;319    
;;;320    			SPI_FLASH_WritePage(pBuffer, WriteAddr, NumOfRestByte);
;;;321    		}
;;;322    	}
;;;323    }
000018  e8bd9ff0          POP      {r4-r12,pc}
                  |L16.28|
00001c  b904              CBNZ     r4,|L16.32|
00001e  e7fb              B        |L16.24|
                  |L16.32|
000020  f0070aff          AND      r10,r7,#0xff          ;245
000024  f1ca0000          RSB      r0,r10,#0             ;246
000028  b2c5              UXTB     r5,r0                 ;246
00002a  4620              MOV      r0,r4                 ;247
00002c  17e1              ASRS     r1,r4,#31             ;247
00002e  eb046111          ADD      r1,r4,r1,LSR #24      ;247
000032  f3c12807          UBFX     r8,r1,#8,#8           ;247
000036  17e1              ASRS     r1,r4,#31             ;248
000038  eb046111          ADD      r1,r4,r1,LSR #24      ;248
00003c  1209              ASRS     r1,r1,#8              ;248
00003e  eba42101          SUB      r1,r4,r1,LSL #8       ;248
000042  f00109ff          AND      r9,r1,#0xff           ;248
000046  f1ba0f00          CMP      r10,#0                ;251
00004a  d120              BNE      |L16.142|
00004c  f1b80f00          CMP      r8,#0                 ;254
000050  d105              BNE      |L16.94|
000052  4622              MOV      r2,r4                 ;256
000054  4639              MOV      r1,r7                 ;256
000056  4630              MOV      r0,r6                 ;256
000058  f7fffffe          BL       SPI_FLASH_WritePage
00005c  e061              B        |L16.290|
                  |L16.94|
00005e  e009              B        |L16.116|
                  |L16.96|
000060  f44f7280          MOV      r2,#0x100             ;265
000064  4639              MOV      r1,r7                 ;265
000066  4630              MOV      r0,r6                 ;265
000068  f7fffffe          BL       SPI_FLASH_WritePage
00006c  f5077780          ADD      r7,r7,#0x100          ;267
000070  f5067680          ADD      r6,r6,#0x100          ;268
                  |L16.116|
000074  f1b80000          SUBS     r0,r8,#0              ;262
000078  f1a80101          SUB      r1,r8,#1              ;262
00007c  f00108ff          AND      r8,r1,#0xff           ;262
000080  d1ee              BNE      |L16.96|
000082  464a              MOV      r2,r9                 ;272
000084  4639              MOV      r1,r7                 ;272
000086  4630              MOV      r0,r6                 ;272
000088  f7fffffe          BL       SPI_FLASH_WritePage
00008c  e049              B        |L16.290|
                  |L16.142|
00008e  f1b80f00          CMP      r8,#0                 ;279
000092  d118              BNE      |L16.198|
000094  45a9              CMP      r9,r5                 ;282
000096  dd10              BLE      |L16.186|
000098  eba90005          SUB      r0,r9,r5              ;285
00009c  f0000bff          AND      r11,r0,#0xff          ;285
0000a0  462a              MOV      r2,r5                 ;287
0000a2  4639              MOV      r1,r7                 ;287
0000a4  4630              MOV      r0,r6                 ;287
0000a6  f7fffffe          BL       SPI_FLASH_WritePage
0000aa  442f              ADD      r7,r7,r5              ;288
0000ac  442e              ADD      r6,r6,r5              ;289
0000ae  465a              MOV      r2,r11                ;292
0000b0  4639              MOV      r1,r7                 ;292
0000b2  4630              MOV      r0,r6                 ;292
0000b4  f7fffffe          BL       SPI_FLASH_WritePage
0000b8  e033              B        |L16.290|
                  |L16.186|
0000ba  4622              MOV      r2,r4                 ;297
0000bc  4639              MOV      r1,r7                 ;297
0000be  4630              MOV      r0,r6                 ;297
0000c0  f7fffffe          BL       SPI_FLASH_WritePage
0000c4  e02d              B        |L16.290|
                  |L16.198|
0000c6  462a              MOV      r2,r5                 ;304
0000c8  4639              MOV      r1,r7                 ;304
0000ca  4630              MOV      r0,r6                 ;304
0000cc  f7fffffe          BL       SPI_FLASH_WritePage
0000d0  442f              ADD      r7,r7,r5              ;305
0000d2  442e              ADD      r6,r6,r5              ;306
0000d4  1b60              SUBS     r0,r4,r5              ;309
0000d6  b284              UXTH     r4,r0                 ;309
0000d8  4620              MOV      r0,r4                 ;310
0000da  17e1              ASRS     r1,r4,#31             ;310
0000dc  eb046111          ADD      r1,r4,r1,LSR #24      ;310
0000e0  f3c12807          UBFX     r8,r1,#8,#8           ;310
0000e4  17e1              ASRS     r1,r4,#31             ;311
0000e6  eb046111          ADD      r1,r4,r1,LSR #24      ;311
0000ea  1209              ASRS     r1,r1,#8              ;311
0000ec  eba42101          SUB      r1,r4,r1,LSL #8       ;311
0000f0  f00109ff          AND      r9,r1,#0xff           ;311
0000f4  e009              B        |L16.266|
                  |L16.246|
0000f6  f44f7280          MOV      r2,#0x100             ;315
0000fa  4639              MOV      r1,r7                 ;315
0000fc  4630              MOV      r0,r6                 ;315
0000fe  f7fffffe          BL       SPI_FLASH_WritePage
000102  f5077780          ADD      r7,r7,#0x100          ;316
000106  f5067680          ADD      r6,r6,#0x100          ;317
                  |L16.266|
00010a  f1b80000          SUBS     r0,r8,#0              ;313
00010e  f1a80101          SUB      r1,r8,#1              ;313
000112  f00108ff          AND      r8,r1,#0xff           ;313
000116  d1ee              BNE      |L16.246|
000118  464a              MOV      r2,r9                 ;320
00011a  4639              MOV      r1,r7                 ;320
00011c  4630              MOV      r0,r6                 ;320
00011e  f7fffffe          BL       SPI_FLASH_WritePage
                  |L16.290|
000122  bf00              NOP      
000124  e778              B        |L16.24|
;;;324    
                          ENDP


                          AREA ||i.SPI_FLASH_WriteByte||, CODE, READONLY, ALIGN=1

                  SPI_FLASH_WriteByte PROC
;;;632    
;;;633    void SPI_FLASH_WriteByte(uint32 WriteAddr, uint8 data)
000000  b538              PUSH     {r3-r5,lr}
;;;634    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;635    	uint8 buff[4];
;;;636    
;;;637    	buff[0] = (data) & 0xFF;
000006  b2e8              UXTB     r0,r5
000008  f88d0000          STRB     r0,[sp,#0]
;;;638    
;;;639    	SPI_FLASH_WriteWithErase(buff, WriteAddr, 1);
00000c  2201              MOVS     r2,#1
00000e  4621              MOV      r1,r4
000010  4668              MOV      r0,sp
000012  f7fffffe          BL       SPI_FLASH_WriteWithErase
;;;640    }
000016  bd38              POP      {r3-r5,pc}
;;;641    
                          ENDP


                          AREA ||i.SPI_FLASH_WriteEnable||, CODE, READONLY, ALIGN=2

                  SPI_FLASH_WriteEnable PROC
;;;450    // 发送写入使能指令
;;;451    void SPI_FLASH_WriteEnable(void)
000000  b510              PUSH     {r4,lr}
;;;452    {
;;;453    	// 片选
;;;454    	SPI_FLASH_CS_L();
000002  2110              MOVS     r1,#0x10
000004  4805              LDR      r0,|L18.28|
000006  f7fffffe          BL       gpio_bit_reset
;;;455    
;;;456    	// 发送写入使能指令
;;;457    	SPI_FLASH_SendByte(CMD_WRITE_ENABLE);
00000a  2006              MOVS     r0,#6
00000c  f7fffffe          BL       SPI_FLASH_SendByte
;;;458    
;;;459    	// 释放
;;;460    	SPI_FLASH_CS_H();
000010  2110              MOVS     r1,#0x10
000012  4802              LDR      r0,|L18.28|
000014  f7fffffe          BL       gpio_bit_set
;;;461    }
000018  bd10              POP      {r4,pc}
;;;462    
                          ENDP

00001a  0000              DCW      0x0000
                  |L18.28|
                          DCD      0x40010800

                          AREA ||i.SPI_FLASH_WriteHalfWord||, CODE, READONLY, ALIGN=1

                  SPI_FLASH_WriteHalfWord PROC
;;;641    
;;;642    void SPI_FLASH_WriteHalfWord(uint32 WriteAddr, uint16 data)
000000  b538              PUSH     {r3-r5,lr}
;;;643    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;644    	uint8 buff[4];
;;;645    
;;;646    	buff[0] = (data >> 8) & 0xFF;
000006  0a20              LSRS     r0,r4,#8
000008  f88d0000          STRB     r0,[sp,#0]
;;;647    	buff[1] = (data) & 0xFF;
00000c  b2e0              UXTB     r0,r4
00000e  f88d0001          STRB     r0,[sp,#1]
;;;648    
;;;649    	SPI_FLASH_WriteWithErase(buff, WriteAddr, 2);
000012  2202              MOVS     r2,#2
000014  4629              MOV      r1,r5
000016  4668              MOV      r0,sp
000018  f7fffffe          BL       SPI_FLASH_WriteWithErase
;;;650    }
00001c  bd38              POP      {r3-r5,pc}
;;;651    
                          ENDP


                          AREA ||i.SPI_FLASH_WritePage||, CODE, READONLY, ALIGN=2

                  SPI_FLASH_WritePage PROC
;;;189    // 页写入
;;;190    void SPI_FLASH_WritePage(uint8 *pBuffer, uint32 WriteAddr, uint16 NumByteToWrite)
000000  b570              PUSH     {r4-r6,lr}
;;;191    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
000006  4616              MOV      r6,r2
;;;192    	// 写入数据量为0，退出
;;;193    	if (0 == NumByteToWrite)
000008  b906              CBNZ     r6,|L20.12|
                  |L20.10|
;;;194    	{
;;;195    		return;
;;;196    	}
;;;197    
;;;198    	// 使能写入操作
;;;199    	SPI_FLASH_WriteEnable();
;;;200    
;;;201    	// 片选
;;;202    	SPI_FLASH_CS_L();
;;;203    
;;;204    	// 发送页写入命令
;;;205    	SPI_FLASH_SendByte(CMD_PAGE_WRITE);
;;;206    
;;;207    	// 写入24位起始地址
;;;208    	SPI_FLASH_SendByte((WriteAddr >> 16) & 0xFF);
;;;209    	SPI_FLASH_SendByte((WriteAddr >> 8) & 0xFF);
;;;210    	SPI_FLASH_SendByte(WriteAddr & 0xFF);
;;;211    
;;;212    	// 连续写入指定数量的数据
;;;213    	while (NumByteToWrite--)
;;;214    	{
;;;215    		/// 写入一个字节
;;;216    		SPI_FLASH_SendByte(*pBuffer);
;;;217    
;;;218    		pBuffer++;
;;;219    	}
;;;220    
;;;221    	// 释放
;;;222    	SPI_FLASH_CS_H();
;;;223    
;;;224    	// 等待写入完成
;;;225    	SPI_FLASH_WaitForWriteEnd();
;;;226    }
00000a  bd70              POP      {r4-r6,pc}
                  |L20.12|
00000c  f7fffffe          BL       SPI_FLASH_WriteEnable
000010  2110              MOVS     r1,#0x10              ;202
000012  4811              LDR      r0,|L20.88|
000014  f7fffffe          BL       gpio_bit_reset
000018  2002              MOVS     r0,#2                 ;205
00001a  f7fffffe          BL       SPI_FLASH_SendByte
00001e  f3c44007          UBFX     r0,r4,#16,#8          ;208
000022  f7fffffe          BL       SPI_FLASH_SendByte
000026  f3c42007          UBFX     r0,r4,#8,#8           ;209
00002a  f7fffffe          BL       SPI_FLASH_SendByte
00002e  b2e0              UXTB     r0,r4                 ;210
000030  f7fffffe          BL       SPI_FLASH_SendByte
000034  e003              B        |L20.62|
                  |L20.54|
000036  7828              LDRB     r0,[r5,#0]            ;216
000038  f7fffffe          BL       SPI_FLASH_SendByte
00003c  1c6d              ADDS     r5,r5,#1              ;218
                  |L20.62|
00003e  1e30              SUBS     r0,r6,#0              ;213
000040  f1a60101          SUB      r1,r6,#1              ;213
000044  b28e              UXTH     r6,r1                 ;213
000046  d1f6              BNE      |L20.54|
000048  2110              MOVS     r1,#0x10              ;222
00004a  4803              LDR      r0,|L20.88|
00004c  f7fffffe          BL       gpio_bit_set
000050  f7fffffe          BL       SPI_FLASH_WaitForWriteEnd
000054  bf00              NOP      
000056  e7d8              B        |L20.10|
;;;227    
                          ENDP

                  |L20.88|
                          DCD      0x40010800

                          AREA ||i.SPI_FLASH_WriteStatus||, CODE, READONLY, ALIGN=2

                  SPI_FLASH_WriteStatus PROC
;;;463    // 写状态寄存器
;;;464    void SPI_FLASH_WriteStatus(uint8 data)
000000  b510              PUSH     {r4,lr}
;;;465    {
000002  4604              MOV      r4,r0
;;;466    	// 片选
;;;467    	SPI_FLASH_CS_L();
000004  2110              MOVS     r1,#0x10
000006  480c              LDR      r0,|L21.56|
000008  f7fffffe          BL       gpio_bit_reset
;;;468    
;;;469    	// 允许写状态寄存器
;;;470    	SPI_FLASH_SendByte(CMD_WRITE_REGISTER_ENABLE);
00000c  2050              MOVS     r0,#0x50
00000e  f7fffffe          BL       SPI_FLASH_SendByte
;;;471    
;;;472    	// 释放
;;;473    	SPI_FLASH_CS_H();
000012  2110              MOVS     r1,#0x10
000014  4808              LDR      r0,|L21.56|
000016  f7fffffe          BL       gpio_bit_set
;;;474    
;;;475    	// 片选
;;;476    	SPI_FLASH_CS_L();
00001a  2110              MOVS     r1,#0x10
00001c  4806              LDR      r0,|L21.56|
00001e  f7fffffe          BL       gpio_bit_reset
;;;477    
;;;478    	// 允许写状态寄存器
;;;479    	SPI_FLASH_SendByte(CMD_WRITE_STATUS_REGISTER);
000022  2001              MOVS     r0,#1
000024  f7fffffe          BL       SPI_FLASH_SendByte
;;;480    	SPI_FLASH_SendByte(data);
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       SPI_FLASH_SendByte
;;;481    
;;;482    	// 释放
;;;483    	SPI_FLASH_CS_H();
00002e  2110              MOVS     r1,#0x10
000030  4801              LDR      r0,|L21.56|
000032  f7fffffe          BL       gpio_bit_set
;;;484    }
000036  bd10              POP      {r4,pc}
;;;485    
                          ENDP

                  |L21.56|
                          DCD      0x40010800

                          AREA ||i.SPI_FLASH_WriteWithCheck||, CODE, READONLY, ALIGN=1

                  SPI_FLASH_WriteWithCheck PROC
;;;550    // 数据写入接口，返回写入结果
;;;551    BOOL SPI_FLASH_WriteWithCheck(uint8 *pBuffer, uint32 WriteAddr, uint16 NumByteToWrite)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;552    {
000004  4605              MOV      r5,r0
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
;;;553    	uint16 NumOfInt = 0;
00000a  f04f0a00          MOV      r10,#0
;;;554    	uint16 NumOfRestByte = 0;
00000e  46d1              MOV      r9,r10
;;;555    	uint16 i;
;;;556    	uint8 *pFlashBuff = NULL; // 保存读取扇区的数据
000010  2700              MOVS     r7,#0
;;;557    
;;;558    	if ((NULL == pBuffer) || (0 == NumByteToWrite))
000012  b105              CBZ      r5,|L22.22|
000014  b916              CBNZ     r6,|L22.28|
                  |L22.22|
;;;559    	{
;;;560    		return FALSE;
000016  2000              MOVS     r0,#0
                  |L22.24|
;;;561    	}
;;;562    
;;;563    	// 申请4096Byte空间保存扇区数据
;;;564    	pFlashBuff = (uint8 *)malloc(SPI_FLASH_SECTOR_SIZE);
;;;565    
;;;566    	// 指针非空判断
;;;567    	if (NULL == pFlashBuff)
;;;568    	{
;;;569    		return FALSE;
;;;570    	}
;;;571    
;;;572    	if (NumByteToWrite > SPI_FLASH_SECTOR_SIZE)
;;;573    	{
;;;574    		NumOfInt = NumByteToWrite / SPI_FLASH_SECTOR_SIZE;
;;;575    		NumOfRestByte = NumByteToWrite % SPI_FLASH_SECTOR_SIZE;
;;;576    
;;;577    		while (NumOfInt--)
;;;578    		{
;;;579    			// 执行写入
;;;580    			SPI_FLASH_WriteArray(pBuffer, WriteAddr, SPI_FLASH_SECTOR_SIZE);
;;;581    			// 执行读取
;;;582    			SPI_FLASH_ReadArray(pFlashBuff, WriteAddr, SPI_FLASH_SECTOR_SIZE);
;;;583    
;;;584    			for (i = 0; i < SPI_FLASH_SECTOR_SIZE; i++)
;;;585    			{
;;;586    				if (pBuffer[i] != pFlashBuff[i])
;;;587    				{
;;;588    					free(pFlashBuff);
;;;589    					return FALSE;
;;;590    				}
;;;591    			}
;;;592    
;;;593    			WriteAddr += SPI_FLASH_SECTOR_SIZE;
;;;594    			pBuffer += SPI_FLASH_SECTOR_SIZE;
;;;595    		}
;;;596    
;;;597    		// 执行写入
;;;598    		SPI_FLASH_WriteArray(pBuffer, WriteAddr, NumOfRestByte);
;;;599    		// 执行读取
;;;600    		SPI_FLASH_ReadArray(pFlashBuff, WriteAddr, NumOfRestByte);
;;;601    
;;;602    		for (i = 0; i < NumOfRestByte; i++)
;;;603    		{
;;;604    			if (pBuffer[i] != pFlashBuff[i])
;;;605    			{
;;;606    				free(pFlashBuff);
;;;607    				return FALSE;
;;;608    			}
;;;609    		}
;;;610    	}
;;;611    	else
;;;612    	{
;;;613    		// 执行写入
;;;614    		SPI_FLASH_WriteArray(pBuffer, WriteAddr, NumByteToWrite);
;;;615    		// 执行读取
;;;616    		SPI_FLASH_ReadArray(pFlashBuff, WriteAddr, NumByteToWrite);
;;;617    
;;;618    		for (i = 0; i < NumByteToWrite; i++)
;;;619    		{
;;;620    			if (pBuffer[i] != pFlashBuff[i])
;;;621    			{
;;;622    				free(pFlashBuff);
;;;623    				return FALSE;
;;;624    			}
;;;625    		}
;;;626    	}
;;;627    
;;;628    	free(pFlashBuff);
;;;629    
;;;630    	return TRUE;
;;;631    }
000018  e8bd87f0          POP      {r4-r10,pc}
                  |L22.28|
00001c  f44f5080          MOV      r0,#0x1000            ;564
000020  f7fffffe          BL       malloc
000024  4607              MOV      r7,r0                 ;564
000026  b90f              CBNZ     r7,|L22.44|
000028  2000              MOVS     r0,#0                 ;569
00002a  e7f5              B        |L22.24|
                  |L22.44|
00002c  f5b65f80          CMP      r6,#0x1000            ;572
000030  d945              BLS      |L22.190|
000032  ea4f3a16          LSR      r10,r6,#12            ;574
000036  f3c6090b          UBFX     r9,r6,#0,#12          ;575
00003a  e01f              B        |L22.124|
                  |L22.60|
00003c  f44f5280          MOV      r2,#0x1000            ;580
000040  4641              MOV      r1,r8                 ;580
000042  4628              MOV      r0,r5                 ;580
000044  f7fffffe          BL       SPI_FLASH_WriteArray
000048  f44f5280          MOV      r2,#0x1000            ;582
00004c  4641              MOV      r1,r8                 ;582
00004e  4638              MOV      r0,r7                 ;582
000050  f7fffffe          BL       SPI_FLASH_ReadArray
000054  2400              MOVS     r4,#0                 ;584
000056  e00a              B        |L22.110|
                  |L22.88|
000058  5d28              LDRB     r0,[r5,r4]            ;586
00005a  5d39              LDRB     r1,[r7,r4]            ;586
00005c  4288              CMP      r0,r1                 ;586
00005e  d004              BEQ      |L22.106|
000060  4638              MOV      r0,r7                 ;588
000062  f7fffffe          BL       free
000066  2000              MOVS     r0,#0                 ;589
000068  e7d6              B        |L22.24|
                  |L22.106|
00006a  1c60              ADDS     r0,r4,#1              ;584
00006c  b284              UXTH     r4,r0                 ;584
                  |L22.110|
00006e  f5b45f80          CMP      r4,#0x1000            ;584
000072  d3f1              BCC      |L22.88|
000074  f5085880          ADD      r8,r8,#0x1000         ;593
000078  f5055580          ADD      r5,r5,#0x1000         ;594
                  |L22.124|
00007c  f1ba0000          SUBS     r0,r10,#0             ;577
000080  f1aa0101          SUB      r1,r10,#1             ;577
000084  fa1ffa81          UXTH     r10,r1                ;577
000088  d1d8              BNE      |L22.60|
00008a  464a              MOV      r2,r9                 ;598
00008c  4641              MOV      r1,r8                 ;598
00008e  4628              MOV      r0,r5                 ;598
000090  f7fffffe          BL       SPI_FLASH_WriteArray
000094  464a              MOV      r2,r9                 ;600
000096  4641              MOV      r1,r8                 ;600
000098  4638              MOV      r0,r7                 ;600
00009a  f7fffffe          BL       SPI_FLASH_ReadArray
00009e  2400              MOVS     r4,#0                 ;602
0000a0  e00a              B        |L22.184|
                  |L22.162|
0000a2  5d28              LDRB     r0,[r5,r4]            ;604
0000a4  5d39              LDRB     r1,[r7,r4]            ;604
0000a6  4288              CMP      r0,r1                 ;604
0000a8  d004              BEQ      |L22.180|
0000aa  4638              MOV      r0,r7                 ;606
0000ac  f7fffffe          BL       free
0000b0  2000              MOVS     r0,#0                 ;607
0000b2  e7b1              B        |L22.24|
                  |L22.180|
0000b4  1c60              ADDS     r0,r4,#1              ;602
0000b6  b284              UXTH     r4,r0                 ;602
                  |L22.184|
0000b8  454c              CMP      r4,r9                 ;602
0000ba  dbf2              BLT      |L22.162|
0000bc  e018              B        |L22.240|
                  |L22.190|
0000be  4632              MOV      r2,r6                 ;614
0000c0  4641              MOV      r1,r8                 ;614
0000c2  4628              MOV      r0,r5                 ;614
0000c4  f7fffffe          BL       SPI_FLASH_WriteArray
0000c8  4632              MOV      r2,r6                 ;616
0000ca  4641              MOV      r1,r8                 ;616
0000cc  4638              MOV      r0,r7                 ;616
0000ce  f7fffffe          BL       SPI_FLASH_ReadArray
0000d2  2400              MOVS     r4,#0                 ;618
0000d4  e00a              B        |L22.236|
                  |L22.214|
0000d6  5d28              LDRB     r0,[r5,r4]            ;620
0000d8  5d39              LDRB     r1,[r7,r4]            ;620
0000da  4288              CMP      r0,r1                 ;620
0000dc  d004              BEQ      |L22.232|
0000de  4638              MOV      r0,r7                 ;622
0000e0  f7fffffe          BL       free
0000e4  2000              MOVS     r0,#0                 ;623
0000e6  e797              B        |L22.24|
                  |L22.232|
0000e8  1c60              ADDS     r0,r4,#1              ;618
0000ea  b284              UXTH     r4,r0                 ;618
                  |L22.236|
0000ec  42b4              CMP      r4,r6                 ;618
0000ee  dbf2              BLT      |L22.214|
                  |L22.240|
0000f0  4638              MOV      r0,r7                 ;628
0000f2  f7fffffe          BL       free
0000f6  2001              MOVS     r0,#1                 ;630
0000f8  e78e              B        |L22.24|
;;;632    
                          ENDP


                          AREA ||i.SPI_FLASH_WriteWithErase||, CODE, READONLY, ALIGN=1

                  SPI_FLASH_WriteWithErase PROC
;;;677    **********************************************************************/
;;;678    void SPI_FLASH_WriteWithErase(uint8 *pBuffer, uint32 WriteAddr, uint16 NumByteToWrite)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;679    {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4615              MOV      r5,r2
;;;680    	uint32 sectPos = 0;
00000a  f04f0900          MOV      r9,#0
;;;681    	uint16 sectOff = 0;
00000e  46cb              MOV      r11,r9
;;;682    	uint16 sectRemain = 0;
000010  2400              MOVS     r4,#0
;;;683    	uint16 i = 0;
000012  2600              MOVS     r6,#0
;;;684    	uint8 *pFlashBuff = NULL; // 保存读取扇区的数据
000014  46a2              MOV      r10,r4
;;;685    
;;;686    	if ((NULL == pBuffer) || (0 == NumByteToWrite))
000016  b107              CBZ      r7,|L23.26|
000018  b90d              CBNZ     r5,|L23.30|
                  |L23.26|
;;;687    	{
;;;688    		return;
;;;689    	}
;;;690    
;;;691    	// 申请4096Byte空间保存扇区数据
;;;692    	pFlashBuff = (uint8 *)malloc(SPI_FLASH_SECTOR_SIZE);
;;;693    
;;;694    	if (NULL == pFlashBuff)
;;;695    	{
;;;696    		return;
;;;697    	}
;;;698    
;;;699    	sectPos = WriteAddr / SPI_FLASH_SECTOR_SIZE;  // 扇区地址
;;;700    	sectOff = WriteAddr % SPI_FLASH_SECTOR_SIZE;  // 在扇区内的偏移
;;;701    	sectRemain = SPI_FLASH_SECTOR_SIZE - sectOff; // 扇区剩余空间大小
;;;702    
;;;703    	if (NumByteToWrite <= sectRemain)
;;;704    	{
;;;705    		sectRemain = NumByteToWrite; // 不大于4096个字节
;;;706    	}
;;;707    
;;;708    	while (1)
;;;709    	{
;;;710    		// 读出整个扇区的内容
;;;711    		SPI_FLASH_ReadArray(pFlashBuff, sectPos * SPI_FLASH_SECTOR_SIZE, SPI_FLASH_SECTOR_SIZE);
;;;712    
;;;713    		for (i = 0; i < sectRemain; i++) // 校验数据
;;;714    		{
;;;715    			if (pFlashBuff[sectOff + i] != 0xFF)
;;;716    			{
;;;717    				break; // 需要擦除
;;;718    			}
;;;719    		}
;;;720    
;;;721    		if (i < sectRemain) // 需要擦除
;;;722    		{
;;;723    			SPI_FLASH_EraseSector(sectPos * SPI_FLASH_SECTOR_SIZE); // 擦除这个扇区
;;;724    
;;;725    			// 复制
;;;726    			for (i = 0; i < sectRemain; i++)
;;;727    			{
;;;728    				pFlashBuff[i + sectOff] = pBuffer[i];
;;;729    			}
;;;730    
;;;731    			// 写入整个扇区
;;;732    			SPI_FLASH_WriteArray(pFlashBuff, sectPos * SPI_FLASH_SECTOR_SIZE, SPI_FLASH_SECTOR_SIZE);
;;;733    		}
;;;734    		else
;;;735    		{
;;;736    			// 写已经擦除了的,直接写入扇区剩余区间.
;;;737    			SPI_FLASH_WriteArray(pBuffer, WriteAddr, sectRemain);
;;;738    		}
;;;739    
;;;740    		if (NumByteToWrite == sectRemain)
;;;741    		{
;;;742    			break; // 写入结束了
;;;743    		}
;;;744    		else // 写入未结束
;;;745    		{
;;;746    			sectPos++;	 // 扇区地址增1
;;;747    			sectOff = 0; // 偏移位置为0
;;;748    
;;;749    			pBuffer += sectRemain;		  // 指针偏移
;;;750    			WriteAddr += sectRemain;	  // 写地址偏移
;;;751    			NumByteToWrite -= sectRemain; // 字节数递减
;;;752    
;;;753    			if (NumByteToWrite > SPI_FLASH_SECTOR_SIZE)
;;;754    			{
;;;755    				sectRemain = SPI_FLASH_SECTOR_SIZE; // 下一个扇区还是写不完
;;;756    			}
;;;757    			else
;;;758    			{
;;;759    				sectRemain = NumByteToWrite; // 下一个扇区可以写完了
;;;760    			}
;;;761    		}
;;;762    	}
;;;763    
;;;764    	// 释放数据缓存区
;;;765    	free(pFlashBuff);
;;;766    }
00001a  e8bd9ff0          POP      {r4-r12,pc}
                  |L23.30|
00001e  f44f5080          MOV      r0,#0x1000            ;692
000022  f7fffffe          BL       malloc
000026  4682              MOV      r10,r0                ;692
000028  f1ba0f00          CMP      r10,#0                ;694
00002c  d100              BNE      |L23.48|
00002e  e7f4              B        |L23.26|
                  |L23.48|
000030  ea4f3918          LSR      r9,r8,#12             ;699
000034  f3c80b0b          UBFX     r11,r8,#0,#12         ;700
000038  f5cb5480          RSB      r4,r11,#0x1000        ;701
00003c  42a5              CMP      r5,r4                 ;703
00003e  dc00              BGT      |L23.66|
000040  462c              MOV      r4,r5                 ;705
                  |L23.66|
000042  e044              B        |L23.206|
                  |L23.68|
000044  ea4f3109          LSL      r1,r9,#12             ;711
000048  f44f5280          MOV      r2,#0x1000            ;711
00004c  4650              MOV      r0,r10                ;711
00004e  f7fffffe          BL       SPI_FLASH_ReadArray
000052  2600              MOVS     r6,#0                 ;713
000054  e008              B        |L23.104|
                  |L23.86|
000056  eb0b0006          ADD      r0,r11,r6             ;715
00005a  f81a0000          LDRB     r0,[r10,r0]           ;715
00005e  28ff              CMP      r0,#0xff              ;715
000060  d000              BEQ      |L23.100|
000062  e003              B        |L23.108|
                  |L23.100|
000064  1c70              ADDS     r0,r6,#1              ;713
000066  b286              UXTH     r6,r0                 ;713
                  |L23.104|
000068  42a6              CMP      r6,r4                 ;713
00006a  dbf4              BLT      |L23.86|
                  |L23.108|
00006c  bf00              NOP                            ;717
00006e  42a6              CMP      r6,r4                 ;721
000070  da16              BGE      |L23.160|
000072  ea4f3009          LSL      r0,r9,#12             ;723
000076  f7fffffe          BL       SPI_FLASH_EraseSector
00007a  2600              MOVS     r6,#0                 ;726
00007c  e006              B        |L23.140|
                  |L23.126|
00007e  5db8              LDRB     r0,[r7,r6]            ;728
000080  eb06010b          ADD      r1,r6,r11             ;728
000084  f80a0001          STRB     r0,[r10,r1]           ;728
000088  1c70              ADDS     r0,r6,#1              ;726
00008a  b286              UXTH     r6,r0                 ;726
                  |L23.140|
00008c  42a6              CMP      r6,r4                 ;726
00008e  dbf6              BLT      |L23.126|
000090  ea4f3109          LSL      r1,r9,#12             ;732
000094  f44f5280          MOV      r2,#0x1000            ;732
000098  4650              MOV      r0,r10                ;732
00009a  f7fffffe          BL       SPI_FLASH_WriteArray
00009e  e004              B        |L23.170|
                  |L23.160|
0000a0  4622              MOV      r2,r4                 ;737
0000a2  4641              MOV      r1,r8                 ;737
0000a4  4638              MOV      r0,r7                 ;737
0000a6  f7fffffe          BL       SPI_FLASH_WriteArray
                  |L23.170|
0000aa  42a5              CMP      r5,r4                 ;740
0000ac  d100              BNE      |L23.176|
0000ae  e00f              B        |L23.208|
                  |L23.176|
0000b0  f1090901          ADD      r9,r9,#1              ;746
0000b4  f04f0b00          MOV      r11,#0                ;747
0000b8  4427              ADD      r7,r7,r4              ;749
0000ba  44a0              ADD      r8,r8,r4              ;750
0000bc  1b28              SUBS     r0,r5,r4              ;751
0000be  b285              UXTH     r5,r0                 ;751
0000c0  f5b55f80          CMP      r5,#0x1000            ;753
0000c4  d902              BLS      |L23.204|
0000c6  f44f5480          MOV      r4,#0x1000            ;755
0000ca  e000              B        |L23.206|
                  |L23.204|
0000cc  462c              MOV      r4,r5                 ;759
                  |L23.206|
0000ce  e7b9              B        |L23.68|
                  |L23.208|
0000d0  bf00              NOP                            ;742
0000d2  4650              MOV      r0,r10                ;765
0000d4  f7fffffe          BL       free
0000d8  bf00              NOP      
0000da  e79e              B        |L23.26|
;;;767    
                          ENDP


                          AREA ||i.SPI_FLASH_WriteWord||, CODE, READONLY, ALIGN=1

                  SPI_FLASH_WriteWord PROC
;;;651    
;;;652    void SPI_FLASH_WriteWord(uint32 WriteAddr, uint32 data)
000000  b538              PUSH     {r3-r5,lr}
;;;653    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;654    	uint8 buff[4];
;;;655    
;;;656    	buff[0] = (data >> 24) & 0xFF;
000006  0e20              LSRS     r0,r4,#24
000008  f88d0000          STRB     r0,[sp,#0]
;;;657    	buff[1] = (data >> 16) & 0xFF;
00000c  0c20              LSRS     r0,r4,#16
00000e  f88d0001          STRB     r0,[sp,#1]
;;;658    	buff[2] = (data >> 8) & 0xFF;
000012  0a20              LSRS     r0,r4,#8
000014  f88d0002          STRB     r0,[sp,#2]
;;;659    	buff[3] = (data) & 0xFF;
000018  b2e0              UXTB     r0,r4
00001a  f88d0003          STRB     r0,[sp,#3]
;;;660    
;;;661    	SPI_FLASH_WriteWithErase(buff, WriteAddr, 4);
00001e  2204              MOVS     r2,#4
000020  4629              MOV      r1,r5
000022  4668              MOV      r0,sp
000024  f7fffffe          BL       SPI_FLASH_WriteWithErase
;;;662    }
000028  bd38              POP      {r3-r5,pc}
;;;663    
                          ENDP


                          AREA ||i.SPI_FlashReadForCrc8||, CODE, READONLY, ALIGN=1

                  SPI_FlashReadForCrc8 PROC
;;;1217    *******************************************************************************/
;;;1218   uint8 SPI_FlashReadForCrc8(uint32 datalen)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1219   {
000004  4607              MOV      r7,r0
;;;1220   	uint8 crc = 0;
000006  2500              MOVS     r5,#0
;;;1221   	uint8 i, j;
;;;1222   	uint8 buf[4] = {0};
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;1223   	uint32 addrIndex = 0;
00000c  4681              MOV      r9,r0
;;;1224   	uint32 dataTemp;
;;;1225   	uint32 len = datalen / 4;
00000e  ea4f0a97          LSR      r10,r7,#2
;;;1226   
;;;1227   	while (len--)
000012  e02d              B        |L25.112|
                  |L25.20|
;;;1228   	{
;;;1229   		dataTemp = SPI_FLASH_ReadWord(SPI_FLASH_DUT_APP_ADDEESS + addrIndex);
000014  f50920c0          ADD      r0,r9,#0x60000
000018  f7fffffe          BL       SPI_FLASH_ReadWord
00001c  4604              MOV      r4,r0
;;;1230   		addrIndex += 4;
00001e  f1090904          ADD      r9,r9,#4
;;;1231   
;;;1232   		// 大端模式
;;;1233   		buf[0] = (uint8)(dataTemp >> 24);
000022  0e20              LSRS     r0,r4,#24
000024  f88d0000          STRB     r0,[sp,#0]
;;;1234   		buf[1] = (uint8)(dataTemp >> 16);
000028  0c20              LSRS     r0,r4,#16
00002a  f88d0001          STRB     r0,[sp,#1]
;;;1235   		buf[2] = (uint8)(dataTemp >> 8);
00002e  0a20              LSRS     r0,r4,#8
000030  f88d0002          STRB     r0,[sp,#2]
;;;1236   		buf[3] = (uint8)dataTemp;
000034  b2e0              UXTB     r0,r4
000036  f88d0003          STRB     r0,[sp,#3]
;;;1237   
;;;1238   		for (j = 0; j < 4; j++)
00003a  2600              MOVS     r6,#0
00003c  e016              B        |L25.108|
                  |L25.62|
;;;1239   		{
;;;1240   			crc ^= buf[j];
00003e  f81d0006          LDRB     r0,[sp,r6]
000042  4045              EORS     r5,r5,r0
;;;1241   
;;;1242   			for (i = 0; i < 8; i++)
000044  f04f0800          MOV      r8,#0
000048  e00b              B        |L25.98|
                  |L25.74|
;;;1243   			{
;;;1244   				if (crc & 0x01)
00004a  f0050001          AND      r0,r5,#1
00004e  b118              CBZ      r0,|L25.88|
;;;1245   				{
;;;1246   					crc = (crc >> 1) ^ 0x8C;
000050  208c              MOVS     r0,#0x8c
000052  ea800565          EOR      r5,r0,r5,ASR #1
000056  e000              B        |L25.90|
                  |L25.88|
;;;1247   				}
;;;1248   				else
;;;1249   				{
;;;1250   					crc >>= 1;
000058  106d              ASRS     r5,r5,#1
                  |L25.90|
00005a  f1080001          ADD      r0,r8,#1              ;1242
00005e  f00008ff          AND      r8,r0,#0xff           ;1242
                  |L25.98|
000062  f1b80f08          CMP      r8,#8                 ;1242
000066  dbf0              BLT      |L25.74|
000068  1c70              ADDS     r0,r6,#1              ;1238
00006a  b2c6              UXTB     r6,r0                 ;1238
                  |L25.108|
00006c  2e04              CMP      r6,#4                 ;1238
00006e  dbe6              BLT      |L25.62|
                  |L25.112|
000070  f1ba0000          SUBS     r0,r10,#0             ;1227
000074  f1aa0a01          SUB      r10,r10,#1            ;1227
000078  d1cc              BNE      |L25.20|
;;;1251   				}
;;;1252   			}
;;;1253   		}
;;;1254   	}
;;;1255   	return crc;
00007a  4628              MOV      r0,r5
;;;1256   }
00007c  e8bd8ff8          POP      {r3-r11,pc}
                          ENDP


                          AREA ||i.SPIx_ConfigureWorkMode||, CODE, READONLY, ALIGN=2

                  SPIx_ConfigureWorkMode PROC
;;;1200   // 配置SPI工作模式
;;;1201   void SPIx_ConfigureWorkMode(uint16 SpiDirection, uint16 SpiDataSize)
000000  b570              PUSH     {r4-r6,lr}
;;;1202   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1203   	spi_init_struct.trans_mode = SpiDirection;
000006  4807              LDR      r0,|L26.36|
000008  6045              STR      r5,[r0,#4]  ; spi_init_struct
;;;1204   	spi_init_struct.frame_size = SpiDataSize;
00000a  6084              STR      r4,[r0,#8]  ; spi_init_struct
;;;1205   
;;;1206   	spi_init(STM32_SPIx_NUM_DEF, &spi_init_struct);
00000c  4601              MOV      r1,r0
00000e  4806              LDR      r0,|L26.40|
000010  f7fffffe          BL       spi_init
;;;1207   	spi_enable(STM32_SPIx_NUM_DEF);
000014  4804              LDR      r0,|L26.40|
000016  f7fffffe          BL       spi_enable
;;;1208   
;;;1209   	spi_i2s_data_receive(STM32_SPIx_NUM_DEF);
00001a  4803              LDR      r0,|L26.40|
00001c  f7fffffe          BL       spi_i2s_data_receive
;;;1210   }
000020  bd70              POP      {r4-r6,pc}
;;;1211   
                          ENDP

000022  0000              DCW      0x0000
                  |L26.36|
                          DCD      spi_init_struct
                  |L26.40|
                          DCD      0x40013000

                          AREA ||i.SPIx_DMAy_Read||, CODE, READONLY, ALIGN=2

                  SPIx_DMAy_Read PROC
;;;966    // 启动DMA方式读取
;;;967    void SPIx_DMAy_Read(uint32 srcAddr, uint32 dstAddr, uint16 count)
000000  b537              PUSH     {r0-r2,r4,r5,lr}
;;;968    {
000002  4604              MOV      r4,r0
000004  4615              MOV      r5,r2
;;;969    	// uint32 number = 0;
;;;970    
;;;971    	// 片选
;;;972    	SPI_FLASH_CS_H();
000006  2110              MOVS     r1,#0x10
000008  4856              LDR      r0,|L27.356|
00000a  f7fffffe          BL       gpio_bit_set
;;;973    
;;;974    #if STM32_DMA_SPI_DIRECTION
;;;975    
;;;976    	// 入参检查
;;;977    	if (0 == count)
00000e  b905              CBNZ     r5,|L27.18|
                  |L27.16|
;;;978    	{
;;;979    		return;
;;;980    	}
;;;981    
;;;982    	// 设置DMA完成标识
;;;983    	spiCB.dmaFinished = FALSE;
;;;984    	spiCB.tx_dmaFinished = FALSE;
;;;985    	// 先禁止SPI以修改配置
;;;986    	spi_disable(STM32_SPIx_NUM_DEF);
;;;987    
;;;988    	// 关闭DMA
;;;989    	dma_channel_disable(DMA0, DMA_CH1);
;;;990    	dma_channel_disable(DMA0, DMA_CH2);
;;;991    
;;;992    	spi_i2s_deinit(STM32_SPIx_NUM_DEF);
;;;993    
;;;994    	spi_init_struct.trans_mode = SPI_TRANSMODE_FULLDUPLEX;
;;;995    	spi_init_struct.device_mode = SPI_MASTER;
;;;996    	spi_init_struct.frame_size = SPI_FRAMESIZE_8BIT;
;;;997    	spi_init_struct.clock_polarity_phase = SPI_CK_PL_LOW_PH_1EDGE; // 空闲时CLK拉底，在第一个时钟跳变沿采集第一个数据
;;;998    	spi_init_struct.nss = SPI_NSS_SOFT;							   // 片选软件控制
;;;999    
;;;1000   	// APB2 - SPI0 - 72M
;;;1001   	// APB1 - SPI1/SPI2 - 36M
;;;1002   	spi_init_struct.prescale = SPI_PSC_4;	 // 72/4=18M
;;;1003   	spi_init_struct.endian = SPI_ENDIAN_MSB; // 先发送高位
;;;1004   	spi_init(STM32_SPIx_NUM_DEF, &spi_init_struct);
;;;1005   
;;;1006   	// 重新配置接收地址以及接收数量
;;;1007   	dma_rx_init_struct.memory_inc = DMA_MEMORY_INCREASE_ENABLE; // 内存地址增量变化
;;;1008   	dma_rx_init_struct.memory_addr = (uint32)dstAddr;
;;;1009   	dma_rx_init_struct.number = count;
;;;1010   	dma_init(DMA0, DMA_CH1, &dma_rx_init_struct);
;;;1011   
;;;1012   	// 发送为dummy
;;;1013   	dma_tx_init_struct.memory_inc = DMA_MEMORY_INCREASE_DISABLE; // 内存地址增量不变化
;;;1014   	dma_tx_init_struct.memory_addr = (uint32)(&dstAddr);
;;;1015   	dma_tx_init_struct.number = count;
;;;1016   	dma_init(DMA0, DMA_CH2, &dma_tx_init_struct);
;;;1017   
;;;1018   	// 使能SPI，使用双工模式发送命令和地址
;;;1019   	spi_enable(STM32_SPIx_NUM_DEF);
;;;1020   
;;;1021   	// 片选
;;;1022   	SPI_FLASH_CS_L();
;;;1023   	// 发送读取命令
;;;1024   	SPI_FLASH_SendByte(CMD_READ_BYTE);
;;;1025   	// 发送24位起始地址
;;;1026   	SPI_FLASH_SendByte((srcAddr & 0xFF0000) >> 16);
;;;1027   	SPI_FLASH_SendByte((srcAddr & 0xFF00) >> 8);
;;;1028   	SPI_FLASH_SendByte(srcAddr & 0xFF);
;;;1029   	// 接收前读一次数据DR，保证接收缓冲区为空
;;;1030   	spi_i2s_data_receive(STM32_SPIx_NUM_DEF);
;;;1031   	// 再次禁止SPI以修改配置为只接收模式
;;;1032   	spi_disable(STM32_SPIx_NUM_DEF);
;;;1033   
;;;1034   	spi_i2s_deinit(STM32_SPIx_NUM_DEF);
;;;1035   
;;;1036   	// 配置为只接收16位模式
;;;1037   	spi_init_struct.trans_mode = SPI_TRANSMODE_FULLDUPLEX;
;;;1038   	spi_init_struct.device_mode = SPI_MASTER;
;;;1039   	spi_init_struct.frame_size = SPI_FRAMESIZE_16BIT;
;;;1040   	spi_init_struct.clock_polarity_phase = SPI_CK_PL_LOW_PH_1EDGE; // 空闲时CLK拉底，在第一个时钟跳变沿采集第一个数据
;;;1041   	spi_init_struct.nss = SPI_NSS_SOFT;							   // 片选软件控制
;;;1042   
;;;1043   	// APB2 - SPI0 - 72M
;;;1044   	// APB1 - SPI1/SPI2 - 36M
;;;1045   	spi_init_struct.prescale = SPI_PSC_4;	 // 72/4=18M
;;;1046   	spi_init_struct.endian = SPI_ENDIAN_MSB; // 先发送高位
;;;1047   	spi_init(STM32_SPIx_NUM_DEF, &spi_init_struct);
;;;1048   
;;;1049   	// 清DMA标记
;;;1050   	dma_flag_clear(DMA0, DMA_CH1, DMA_FLAG_G); // 清RX全局中断标志
;;;1051   	dma_flag_clear(DMA0, DMA_CH2, DMA_FLAG_G); // 清RX全局中断标志
;;;1052   
;;;1053   	// 使能RX的TC中断
;;;1054   	dma_interrupt_enable(DMA0, DMA_CH1, DMA_INT_FTF);
;;;1055   	dma_interrupt_enable(DMA0, DMA_CH2, DMA_INT_FTF);
;;;1056   
;;;1057   	// 重新使能SPI，SCK时钟立刻开始输出，开始接收数据
;;;1058   	spi_enable(STM32_SPIx_NUM_DEF);
;;;1059   	spi_i2s_data_receive(STM32_SPIx_NUM_DEF);
;;;1060   
;;;1061   	spi_dma_enable(STM32_SPIx_NUM_DEF, SPI_DMA_RECEIVE);
;;;1062   	spi_dma_enable(STM32_SPIx_NUM_DEF, SPI_DMA_TRANSMIT);
;;;1063   
;;;1064   	// 开启DMA通道DMA0_Channel1
;;;1065   	dma_channel_enable(DMA0, DMA_CH1);
;;;1066   	dma_channel_enable(DMA0, DMA_CH2);
;;;1067   
;;;1068   	while (!(spiCB.dmaFinished && spiCB.tx_dmaFinished))
;;;1069   		;
;;;1070   
;;;1071   	// DMA读完后，模式重新复位
;;;1072   	SPIx_ConfigureWorkMode(SPI_TRANSMODE_FULLDUPLEX, SPI_FRAMESIZE_8BIT);
;;;1073   
;;;1074   #else
;;;1075   
;;;1076   	// 入参检查
;;;1077   	if (0 == count)
;;;1078   	{
;;;1079   		return;
;;;1080   	}
;;;1081   
;;;1082   	// 设置DMA完成标识
;;;1083   	spiCB.dmaFinished = FALSE;
;;;1084   
;;;1085   	// 先禁止SPI以修改配置
;;;1086   	spi_disable(STM32_SPIx_NUM_DEF);
;;;1087   
;;;1088   	// 关闭DMA
;;;1089   	dma_channel_disable(DMA0, DMA_CH1);
;;;1090   
;;;1091   	// 先配置全双工模式，以在DMA之前写命令和地址
;;;1092   	spi_init_struct.trans_mode = SPI_TRANSMODE_FULLDUPLEX;
;;;1093   	spi_init_struct.frame_size = SPI_FRAMESIZE_8BIT;
;;;1094   	spi_init(STM32_SPIx_NUM_DEF, &spi_init_struct);
;;;1095   
;;;1096   	// 重新配置接收地址以及接收数量
;;;1097   	dma_rx_init_struct.memory_inc = DMA_MEMORY_INCREASE_ENABLE; // 内存地址增量变化
;;;1098   	dma_rx_init_struct.memory_addr = (uint32)dstAddr;
;;;1099   	dma_rx_init_struct.number = count;
;;;1100   	dma_init(DMA0, DMA_CH1, &dma_rx_init_struct);
;;;1101   
;;;1102   	// 使能SPI，使用双工模式发送命令和地址
;;;1103   	spi_enable(STM32_SPIx_NUM_DEF);
;;;1104   	// 片选
;;;1105   	SPI_FLASH_CS_L();
;;;1106   	// 发送读取命令
;;;1107   	SPI_FLASH_SendByte(CMD_READ_BYTE);
;;;1108   	// 发送24位起始地址
;;;1109   	SPI_FLASH_SendByte((srcAddr & 0xFF0000) >> 16);
;;;1110   	SPI_FLASH_SendByte((srcAddr & 0xFF00) >> 8);
;;;1111   	SPI_FLASH_SendByte(srcAddr & 0xFF);
;;;1112   	// 接收前读一次数据DR，保证接收缓冲区为空
;;;1113   	spi_i2s_data_receive(STM32_SPIx_NUM_DEF);
;;;1114   	// 再次禁止SPI以修改配置为只接收模式
;;;1115   	spi_disable(STM32_SPIx_NUM_DEF);
;;;1116   	// 配置为只接收16位模式
;;;1117   	spi_init_struct.trans_mode = SPI_TRANSMODE_RECEIVEONLY;
;;;1118   	spi_init_struct.frame_size = SPI_FRAMESIZE_16BIT;
;;;1119   	spi_init(STM32_SPIx_NUM_DEF, &spi_init_struct);
;;;1120   
;;;1121   	// 清DMA标记
;;;1122   	dma_flag_clear(DMA0, DMA_CH1, DMA_FLAG_G); // 清RX全局中断标志
;;;1123   	// 使能RX的TC中断
;;;1124   	dma_interrupt_enable(DMA0, DMA_CH1, DMA_INT_FTF);
;;;1125   
;;;1126   	// 重新使能SPI，SCK时钟立刻开始输出，开始接收数据
;;;1127   	spi_enable(STM32_SPIx_NUM_DEF);
;;;1128   	spi_i2s_data_receive(STM32_SPIx_NUM_DEF);
;;;1129   
;;;1130   	// 开启DMA通道DMA0_Channel1
;;;1131   	dma_channel_enable(DMA0, DMA_CH1);
;;;1132   
;;;1133   	while (!spiCB.dmaFinished)
;;;1134   	{
;;;1135   // DMA搬运做超时处理，超过门限则再次进行数据搬运，防止死机
;;;1136   // "#define _DMA_MOVE_BYTES_COUNT_TOP_			0xE000"超时值跟此宏密切相关，与主频也有关联，不可随意修改
;;;1137   #warning "此处计算需要注意主频与_DMA_MOVE_BYTES_COUNT_TOP_大小"
;;;1138   		if (number++ > 280000)
;;;1139   		{
;;;1140   			number = 0;
;;;1141   
;;;1142   			// 设置DMA完成标识
;;;1143   			spiCB.dmaFinished = FALSE;
;;;1144   
;;;1145   			// 先禁止SPI以修改配置
;;;1146   			spi_disable(STM32_SPIx_NUM_DEF);
;;;1147   
;;;1148   			// 关闭DMA
;;;1149   			dma_channel_disable(DMA0, DMA_CH1);
;;;1150   
;;;1151   			// 先配置全双工模式，以在DMA之前写命令和地址
;;;1152   			spi_init_struct.trans_mode = SPI_TRANSMODE_FULLDUPLEX;
;;;1153   			spi_init_struct.frame_size = SPI_FRAMESIZE_8BIT;
;;;1154   			spi_init(STM32_SPIx_NUM_DEF, &spi_init_struct);
;;;1155   
;;;1156   			// 重新配置接收地址以及接收数量
;;;1157   			dma_rx_init_struct.memory_inc = DMA_MEMORY_INCREASE_ENABLE; // 内存地址增量变化
;;;1158   			dma_rx_init_struct.memory_addr = (uint32)dstAddr;
;;;1159   			dma_rx_init_struct.number = count;
;;;1160   			dma_init(DMA0, DMA_CH1, &dma_rx_init_struct);
;;;1161   
;;;1162   			// 使能SPI，使用双工模式发送命令和地址
;;;1163   			spi_enable(STM32_SPIx_NUM_DEF);
;;;1164   			// 片选
;;;1165   			SPI_FLASH_CS_L();
;;;1166   			// 发送读取命令
;;;1167   			SPI_FLASH_SendByte(CMD_READ_BYTE);
;;;1168   			// 发送24位起始地址
;;;1169   			SPI_FLASH_SendByte((srcAddr & 0xFF0000) >> 16);
;;;1170   			SPI_FLASH_SendByte((srcAddr & 0xFF00) >> 8);
;;;1171   			SPI_FLASH_SendByte(srcAddr & 0xFF);
;;;1172   			// 接收前读一次数据DR，保证接收缓冲区为空
;;;1173   			spi_i2s_data_receive(STM32_SPIx_NUM_DEF);
;;;1174   			// 再次禁止SPI以修改配置为只接收模式
;;;1175   			spi_disable(STM32_SPIx_NUM_DEF);
;;;1176   			// 配置为只接收16位模式
;;;1177   			spi_init_struct.trans_mode = SPI_TRANSMODE_RECEIVEONLY;
;;;1178   			spi_init_struct.frame_size = SPI_FRAMESIZE_16BIT;
;;;1179   			spi_init(STM32_SPIx_NUM_DEF, &spi_init_struct);
;;;1180   
;;;1181   			// 清DMA标记
;;;1182   			dma_flag_clear(DMA0, DMA_CH1, DMA_FLAG_G); // 清RX全局中断标志
;;;1183   			// 使能RX的TC中断
;;;1184   			dma_interrupt_enable(DMA0, DMA_CH1, DMA_INT_FTF);
;;;1185   
;;;1186   			// 重新使能SPI，SCK时钟立刻开始输出，开始接收数据
;;;1187   			spi_enable(STM32_SPIx_NUM_DEF);
;;;1188   			spi_i2s_data_receive(STM32_SPIx_NUM_DEF);
;;;1189   
;;;1190   			// 开启DMA通道DMA0_Channel1
;;;1191   			dma_channel_enable(DMA0, DMA_CH1);
;;;1192   		}
;;;1193   	}
;;;1194   
;;;1195   	// DMA读完后，模式重新复位
;;;1196   	SPIx_ConfigureWorkMode(SPI_TRANSMODE_FULLDUPLEX, SPI_FRAMESIZE_8BIT);
;;;1197   #endif
;;;1198   }
000010  bd3e              POP      {r1-r5,pc}
                  |L27.18|
000012  2000              MOVS     r0,#0                 ;983
000014  4954              LDR      r1,|L27.360|
000016  7008              STRB     r0,[r1,#0]            ;983
000018  7048              STRB     r0,[r1,#1]            ;984
00001a  4854              LDR      r0,|L27.364|
00001c  f7fffffe          BL       spi_disable
000020  2101              MOVS     r1,#1                 ;989
000022  4853              LDR      r0,|L27.368|
000024  f7fffffe          BL       dma_channel_disable
000028  2102              MOVS     r1,#2                 ;990
00002a  4851              LDR      r0,|L27.368|
00002c  f7fffffe          BL       dma_channel_disable
000030  484e              LDR      r0,|L27.364|
000032  f7fffffe          BL       spi_i2s_deinit
000036  2000              MOVS     r0,#0                 ;994
000038  494e              LDR      r1,|L27.372|
00003a  6048              STR      r0,[r1,#4]            ;994  ; spi_init_struct
00003c  f44f7082          MOV      r0,#0x104             ;995
000040  6008              STR      r0,[r1,#0]            ;995  ; spi_init_struct
000042  2000              MOVS     r0,#0                 ;996
000044  6088              STR      r0,[r1,#8]            ;996  ; spi_init_struct
000046  6148              STR      r0,[r1,#0x14]         ;997  ; spi_init_struct
000048  f44f7000          MOV      r0,#0x200             ;998
00004c  60c8              STR      r0,[r1,#0xc]          ;998  ; spi_init_struct
00004e  2008              MOVS     r0,#8                 ;1002
000050  6188              STR      r0,[r1,#0x18]         ;1002  ; spi_init_struct
000052  2000              MOVS     r0,#0                 ;1003
000054  6108              STR      r0,[r1,#0x10]         ;1003  ; spi_init_struct
000056  4845              LDR      r0,|L27.364|
000058  f7fffffe          BL       spi_init
00005c  2001              MOVS     r0,#1                 ;1007
00005e  4946              LDR      r1,|L27.376|
000060  7648              STRB     r0,[r1,#0x19]         ;1007
000062  9801              LDR      r0,[sp,#4]            ;1008
000064  6088              STR      r0,[r1,#8]            ;1008  ; dma_rx_init_struct
000066  4608              MOV      r0,r1                 ;1009
000068  6105              STR      r5,[r0,#0x10]         ;1009  ; dma_rx_init_struct
00006a  4602              MOV      r2,r0                 ;1010
00006c  2101              MOVS     r1,#1                 ;1010
00006e  4840              LDR      r0,|L27.368|
000070  f7fffffe          BL       dma_init
000074  2000              MOVS     r0,#0                 ;1013
000076  4941              LDR      r1,|L27.380|
000078  7648              STRB     r0,[r1,#0x19]         ;1013
00007a  a801              ADD      r0,sp,#4              ;1014
00007c  6088              STR      r0,[r1,#8]            ;1014  ; dma_tx_init_struct
00007e  4608              MOV      r0,r1                 ;1015
000080  6105              STR      r5,[r0,#0x10]         ;1015  ; dma_tx_init_struct
000082  4602              MOV      r2,r0                 ;1016
000084  2102              MOVS     r1,#2                 ;1016
000086  483a              LDR      r0,|L27.368|
000088  f7fffffe          BL       dma_init
00008c  4837              LDR      r0,|L27.364|
00008e  f7fffffe          BL       spi_enable
000092  2110              MOVS     r1,#0x10              ;1022
000094  4833              LDR      r0,|L27.356|
000096  f7fffffe          BL       gpio_bit_reset
00009a  2003              MOVS     r0,#3                 ;1024
00009c  f7fffffe          BL       SPI_FLASH_SendByte
0000a0  f3c44007          UBFX     r0,r4,#16,#8          ;1026
0000a4  f7fffffe          BL       SPI_FLASH_SendByte
0000a8  f3c42007          UBFX     r0,r4,#8,#8           ;1027
0000ac  f7fffffe          BL       SPI_FLASH_SendByte
0000b0  b2e0              UXTB     r0,r4                 ;1028
0000b2  f7fffffe          BL       SPI_FLASH_SendByte
0000b6  482d              LDR      r0,|L27.364|
0000b8  f7fffffe          BL       spi_i2s_data_receive
0000bc  482b              LDR      r0,|L27.364|
0000be  f7fffffe          BL       spi_disable
0000c2  482a              LDR      r0,|L27.364|
0000c4  f7fffffe          BL       spi_i2s_deinit
0000c8  2000              MOVS     r0,#0                 ;1037
0000ca  492a              LDR      r1,|L27.372|
0000cc  6048              STR      r0,[r1,#4]            ;1037  ; spi_init_struct
0000ce  f44f7082          MOV      r0,#0x104             ;1038
0000d2  6008              STR      r0,[r1,#0]            ;1038  ; spi_init_struct
0000d4  f44f6000          MOV      r0,#0x800             ;1039
0000d8  6088              STR      r0,[r1,#8]            ;1039  ; spi_init_struct
0000da  2000              MOVS     r0,#0                 ;1040
0000dc  6148              STR      r0,[r1,#0x14]         ;1040  ; spi_init_struct
0000de  f44f7000          MOV      r0,#0x200             ;1041
0000e2  60c8              STR      r0,[r1,#0xc]          ;1041  ; spi_init_struct
0000e4  2008              MOVS     r0,#8                 ;1045
0000e6  6188              STR      r0,[r1,#0x18]         ;1045  ; spi_init_struct
0000e8  2000              MOVS     r0,#0                 ;1046
0000ea  6108              STR      r0,[r1,#0x10]         ;1046  ; spi_init_struct
0000ec  481f              LDR      r0,|L27.364|
0000ee  f7fffffe          BL       spi_init
0000f2  2201              MOVS     r2,#1                 ;1050
0000f4  4611              MOV      r1,r2                 ;1050
0000f6  481e              LDR      r0,|L27.368|
0000f8  f7fffffe          BL       dma_flag_clear
0000fc  2201              MOVS     r2,#1                 ;1051
0000fe  2102              MOVS     r1,#2                 ;1051
000100  481b              LDR      r0,|L27.368|
000102  f7fffffe          BL       dma_flag_clear
000106  2202              MOVS     r2,#2                 ;1054
000108  2101              MOVS     r1,#1                 ;1054
00010a  4819              LDR      r0,|L27.368|
00010c  f7fffffe          BL       dma_interrupt_enable
000110  2202              MOVS     r2,#2                 ;1055
000112  4611              MOV      r1,r2                 ;1055
000114  4816              LDR      r0,|L27.368|
000116  f7fffffe          BL       dma_interrupt_enable
00011a  4814              LDR      r0,|L27.364|
00011c  f7fffffe          BL       spi_enable
000120  4812              LDR      r0,|L27.364|
000122  f7fffffe          BL       spi_i2s_data_receive
000126  2101              MOVS     r1,#1                 ;1061
000128  4810              LDR      r0,|L27.364|
00012a  f7fffffe          BL       spi_dma_enable
00012e  2100              MOVS     r1,#0                 ;1062
000130  480e              LDR      r0,|L27.364|
000132  f7fffffe          BL       spi_dma_enable
000136  2101              MOVS     r1,#1                 ;1065
000138  480d              LDR      r0,|L27.368|
00013a  f7fffffe          BL       dma_channel_enable
00013e  2102              MOVS     r1,#2                 ;1066
000140  480b              LDR      r0,|L27.368|
000142  f7fffffe          BL       dma_channel_enable
000146  bf00              NOP                            ;1068
                  |L27.328|
000148  4807              LDR      r0,|L27.360|
00014a  7800              LDRB     r0,[r0,#0]            ;1068  ; spiCB
00014c  2800              CMP      r0,#0                 ;1068
00014e  d0fb              BEQ      |L27.328|
000150  4805              LDR      r0,|L27.360|
000152  7840              LDRB     r0,[r0,#1]            ;1068  ; spiCB
000154  2800              CMP      r0,#0                 ;1068
000156  d0f7              BEQ      |L27.328|
000158  2100              MOVS     r1,#0                 ;1072
00015a  4608              MOV      r0,r1                 ;1072
00015c  f7fffffe          BL       SPIx_ConfigureWorkMode
000160  bf00              NOP      
000162  e755              B        |L27.16|
;;;1199   
                          ENDP

                  |L27.356|
                          DCD      0x40010800
                  |L27.360|
                          DCD      spiCB
                  |L27.364|
                          DCD      0x40013000
                  |L27.368|
                          DCD      0x40020000
                  |L27.372|
                          DCD      spi_init_struct
                  |L27.376|
                          DCD      dma_rx_init_struct
                  |L27.380|
                          DCD      dma_tx_init_struct

                          AREA ||i.SPIx_DMAy_SendBuffer||, CODE, READONLY, ALIGN=2

                  SPIx_DMAy_SendBuffer PROC
;;;894    // DMA发送(只支持也写256Byte)
;;;895    void SPIx_DMAy_SendBuffer(uint8 *sendBuffer, uint32 WriteAddr, uint16 ndtr)
000000  b570              PUSH     {r4-r6,lr}
;;;896    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
000006  4616              MOV      r6,r2
;;;897    #if STM32_DMA_SPI_DIRECTION
;;;898    	// 关闭DMA
;;;899    	spi_dma_disable(SPI0, SPI_DMA_TRANSMIT);
000008  2100              MOVS     r1,#0
00000a  4817              LDR      r0,|L28.104|
00000c  f7fffffe          BL       spi_dma_disable
;;;900    
;;;901    	dma_tx_init_struct.memory_inc = DMA_MEMORY_INCREASE_ENABLE;
000010  2001              MOVS     r0,#1
000012  4916              LDR      r1,|L28.108|
000014  7648              STRB     r0,[r1,#0x19]
;;;902    	dma_tx_init_struct.memory_addr = (uint32)sendBuffer;
000016  4608              MOV      r0,r1
000018  6085              STR      r5,[r0,#8]  ; dma_tx_init_struct
;;;903    	dma_tx_init_struct.number = ndtr;
00001a  6106              STR      r6,[r0,#0x10]  ; dma_tx_init_struct
;;;904    	dma_init(DMA0, DMA_CH2, &dma_tx_init_struct);
00001c  4602              MOV      r2,r0
00001e  2102              MOVS     r1,#2
000020  4813              LDR      r0,|L28.112|
000022  f7fffffe          BL       dma_init
;;;905    
;;;906    	// 片选
;;;907    	SPI_FLASH_CS_L();
000026  2110              MOVS     r1,#0x10
000028  4812              LDR      r0,|L28.116|
00002a  f7fffffe          BL       gpio_bit_reset
;;;908    	// 发送页写入命令
;;;909    	SPI_FLASH_SendByte(CMD_PAGE_WRITE);
00002e  2002              MOVS     r0,#2
000030  f7fffffe          BL       SPI_FLASH_SendByte
;;;910    	// 写入24位起始地址
;;;911    	SPI_FLASH_SendByte((WriteAddr >> 16) & 0xFF);
000034  f3c44007          UBFX     r0,r4,#16,#8
000038  f7fffffe          BL       SPI_FLASH_SendByte
;;;912    	SPI_FLASH_SendByte((WriteAddr >> 8) & 0xFF);
00003c  f3c42007          UBFX     r0,r4,#8,#8
000040  f7fffffe          BL       SPI_FLASH_SendByte
;;;913    	SPI_FLASH_SendByte(WriteAddr & 0xFF);
000044  b2e0              UXTB     r0,r4
000046  f7fffffe          BL       SPI_FLASH_SendByte
;;;914    
;;;915    	// 清DMA标记
;;;916    	dma_flag_clear(DMA0, DMA_CH2, DMA_FLAG_G);
00004a  2201              MOVS     r2,#1
00004c  2102              MOVS     r1,#2
00004e  4808              LDR      r0,|L28.112|
000050  f7fffffe          BL       dma_flag_clear
;;;917    
;;;918    	// 使能TX的TC中断
;;;919    	dma_interrupt_enable(DMA0, DMA_CH2, DMA_INT_FTF);
000054  2202              MOVS     r2,#2
000056  4611              MOV      r1,r2
000058  4805              LDR      r0,|L28.112|
00005a  f7fffffe          BL       dma_interrupt_enable
;;;920    
;;;921    	// 开启DMA通道DMA0_Channel2
;;;922    	spi_dma_enable(SPI0, SPI_DMA_TRANSMIT);
00005e  2100              MOVS     r1,#0
000060  4801              LDR      r0,|L28.104|
000062  f7fffffe          BL       spi_dma_enable
;;;923    
;;;924    #else
;;;925    
;;;926    	// 先禁止SPI以修改配置
;;;927    	spi_disable(STM32_SPIx_NUM_DEF);
;;;928    
;;;929    	// 关闭DMA
;;;930    	spi_dma_disable(SPI0, SPI_DMA_TRANSMIT);
;;;931    
;;;932    	// 全双工发送接收模式，此时不用理会接收的数据
;;;933    	// 数据的开始以填数据进SPI_DR为启动时刻
;;;934    	spi_init_struct.trans_mode = SPI_TRANSMODE_FULLDUPLEX;
;;;935    	spi_init(STM32_SPIx_NUM_DEF, &spi_init_struct);
;;;936    
;;;937    	dma_tx_init_struct.memory_inc = DMA_MEMORY_INCREASE_ENABLE;
;;;938    	dma_tx_init_struct.memory_addr = (uint32)sendBuffer;
;;;939    	dma_tx_init_struct.number = ndtr;
;;;940    	dma_init(DMA0, DMA_CH2, &dma_tx_init_struct);
;;;941    
;;;942    	// 使能SPI，使用双工模式发送命令和地址
;;;943    	spi_enable(STM32_SPIx_NUM_DEF);
;;;944    
;;;945    	// 片选
;;;946    	SPI_FLASH_CS_L();
;;;947    	// 发送页写入命令
;;;948    	SPI_FLASH_SendByte(CMD_PAGE_WRITE);
;;;949    	// 写入24位起始地址
;;;950    	SPI_FLASH_SendByte((WriteAddr >> 16) & 0xFF);
;;;951    	SPI_FLASH_SendByte((WriteAddr >> 8) & 0xFF);
;;;952    	SPI_FLASH_SendByte(WriteAddr & 0xFF);
;;;953    
;;;954    	// 清DMA标记
;;;955    	dma_flag_clear(DMA0, DMA_CH2, DMA_FLAG_G);
;;;956    
;;;957    	// 使能TX的TC中断
;;;958    	dma_interrupt_enable(DMA0, DMA_CH2, DMA_INT_FTF);
;;;959    
;;;960    	// 开启DMA通道DMA0_Channel2
;;;961    	spi_dma_enable(SPI0, SPI_DMA_TRANSMIT);
;;;962    
;;;963    #endif
;;;964    }
000066  bd70              POP      {r4-r6,pc}
;;;965    
                          ENDP

                  |L28.104|
                          DCD      0x40013000
                  |L28.108|
                          DCD      dma_tx_init_struct
                  |L28.112|
                          DCD      0x40020000
                  |L28.116|
                          DCD      0x40010800

                          AREA ||i.SPIx_FLASH_Init||, CODE, READONLY, ALIGN=2

                  SPIx_FLASH_Init PROC
;;;49     // 初始化SPI Flash驱动端口
;;;50     void SPIx_FLASH_Init(void)
000000  b510              PUSH     {r4,lr}
;;;51     {
;;;52     	// GD32 - SPI
;;;53     	if (STM32_SPIx_NUM_DEF == SPI0)
;;;54     	{
;;;55     		/*
;;;56     		 * PA5 --> SPI1 SCK 			Mode: GPIO_Mode_AF_PP
;;;57     		 * PA7 --> SPI1 MOSI Write	Mode: GPIO_Mode_AF_PP
;;;58     		 * PA6 --> SPI1 MISO Read	Mode: GPIO_Mode_IPU
;;;59     		 * PA4 --> SPI1 CS			Mode: GPIO_Mode_Out_PP
;;;60     		 */
;;;61     
;;;62     		// 使能GPIO时钟
;;;63     		rcu_periph_clock_enable(RCU_GPIOA);
000002  f2406002          MOV      r0,#0x602
000006  f7fffffe          BL       rcu_periph_clock_enable
;;;64     
;;;65     		// SPI0 GPIO config: SCK/PA5, MOSI/PA7
;;;66     		gpio_init(GPIOA, GPIO_MODE_AF_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_5 | GPIO_PIN_7);
00000a  23a0              MOVS     r3,#0xa0
00000c  2203              MOVS     r2,#3
00000e  2118              MOVS     r1,#0x18
000010  4818              LDR      r0,|L29.116|
000012  f7fffffe          BL       gpio_init
;;;67     
;;;68     		// SPI0 GPIO config: MISO/PA6
;;;69     		gpio_init(GPIOA, GPIO_MODE_IPU, GPIO_OSPEED_50MHZ, GPIO_PIN_6);
000016  2340              MOVS     r3,#0x40
000018  2203              MOVS     r2,#3
00001a  2148              MOVS     r1,#0x48
00001c  4815              LDR      r0,|L29.116|
00001e  f7fffffe          BL       gpio_init
;;;70     
;;;71     		// SPI0 GPIO config: NSS/PA4
;;;72     		gpio_init(GPIOA, GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_4);
000022  2310              MOVS     r3,#0x10
000024  2203              MOVS     r2,#3
000026  4619              MOV      r1,r3
000028  4812              LDR      r0,|L29.116|
00002a  f7fffffe          BL       gpio_init
;;;73     
;;;74     		// SPIx配置选项
;;;75     		rcu_periph_clock_enable(RCU_SPI0);
00002e  f240600c          MOV      r0,#0x60c
000032  f7fffffe          BL       rcu_periph_clock_enable
;;;76     	}
;;;77     	else
;;;78     	{
;;;79     		// 使能GPIO时钟
;;;80     		rcu_periph_clock_enable(RCU_GPIOB);
;;;81     
;;;82     		// SPI1 GPIO config: SCK/PB13, MOSI/PB15
;;;83     		gpio_init(GPIOB, GPIO_MODE_AF_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_13 | GPIO_PIN_15);
;;;84     
;;;85     		// SPI1 GPIO config: MISO/PB14
;;;86     		gpio_init(GPIOB, GPIO_MODE_AF_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_14);
;;;87     
;;;88     		// SPI1 GPIO config: NSS/PB12
;;;89     		gpio_init(GPIOB, GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_12);
;;;90     
;;;91     		// SPIx配置选项
;;;92     		rcu_periph_clock_enable(RCU_SPI1);
;;;93     	}
;;;94     
;;;95     	spi_i2s_deinit(STM32_SPIx_NUM_DEF);
000036  4810              LDR      r0,|L29.120|
000038  f7fffffe          BL       spi_i2s_deinit
;;;96     
;;;97     	spi_init_struct.trans_mode = SPI_TRANSMODE_FULLDUPLEX;
00003c  2000              MOVS     r0,#0
00003e  490f              LDR      r1,|L29.124|
000040  6048              STR      r0,[r1,#4]  ; spi_init_struct
;;;98     	spi_init_struct.device_mode = SPI_MASTER;
000042  f44f7082          MOV      r0,#0x104
000046  6008              STR      r0,[r1,#0]  ; spi_init_struct
;;;99     	spi_init_struct.frame_size = SPI_FRAMESIZE_8BIT;
000048  2000              MOVS     r0,#0
00004a  6088              STR      r0,[r1,#8]  ; spi_init_struct
;;;100    	spi_init_struct.clock_polarity_phase = SPI_CK_PL_LOW_PH_1EDGE; // 空闲时CLK拉底，在第一个时钟跳变沿采集第一个数据
00004c  6148              STR      r0,[r1,#0x14]  ; spi_init_struct
;;;101    	spi_init_struct.nss = SPI_NSS_SOFT;							   // 片选软件控制
00004e  f44f7000          MOV      r0,#0x200
000052  60c8              STR      r0,[r1,#0xc]  ; spi_init_struct
;;;102    
;;;103    	// APB2 - SPI0 - 72M
;;;104    	// APB1 - SPI1/SPI2 - 36M
;;;105    	spi_init_struct.prescale = SPI_PSC_4;	 // 72/4=18M
000054  2008              MOVS     r0,#8
000056  6188              STR      r0,[r1,#0x18]  ; spi_init_struct
;;;106    	spi_init_struct.endian = SPI_ENDIAN_MSB; // 先发送高位
000058  2000              MOVS     r0,#0
00005a  6108              STR      r0,[r1,#0x10]  ; spi_init_struct
;;;107    	spi_init(STM32_SPIx_NUM_DEF, &spi_init_struct);
00005c  4806              LDR      r0,|L29.120|
00005e  f7fffffe          BL       spi_init
;;;108    
;;;109    	// 使能SPIx
;;;110    	spi_enable(STM32_SPIx_NUM_DEF);
000062  4805              LDR      r0,|L29.120|
000064  f7fffffe          BL       spi_enable
;;;111    
;;;112    	// 使能DMA功能
;;;113    	DMAy_SPIx_Configuration();
000068  f7fffffe          BL       DMAy_SPIx_Configuration
;;;114    
;;;115    	spiCB.dmaFinished = FALSE;
00006c  2000              MOVS     r0,#0
00006e  4904              LDR      r1,|L29.128|
000070  7008              STRB     r0,[r1,#0]
;;;116    
;;;117    #if SPI_FLASH_UNIT_TEST
;;;118    	SPI_FLASH_UnitTest();
;;;119    #endif
;;;120    }
000072  bd10              POP      {r4,pc}
;;;121    
                          ENDP

                  |L29.116|
                          DCD      0x40010800
                  |L29.120|
                          DCD      0x40013000
                  |L29.124|
                          DCD      spi_init_struct
                  |L29.128|
                          DCD      spiCB

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  spi_init_struct
                          %        28
                  dma_tx_init_struct
                          %        28
                  dma_rx_init_struct
                          %        28

                          AREA ||.data||, DATA, ALIGN=1

                  spiCB
000000  0000              DCB      0x00,0x00
                  txByte
000002  00ff              DCW      0x00ff
                  rxByte
000004  00ff              DCW      0x00ff

;*** Start embedded assembler ***

#line 1 "User\\spiflash.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_spiflash_c_de66f17a____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___10_spiflash_c_de66f17a____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_spiflash_c_de66f17a____REVSH|
#line 128
|__asm___10_spiflash_c_de66f17a____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
