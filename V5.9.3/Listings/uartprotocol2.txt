; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\uartprotocol2.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\uartprotocol2.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -I.\User\qrencode -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.1\Device\Include -D__MICROLIB -D__UVISION_VERSION=534 -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\uartprotocol2.crf User\UartProtocol2.c]
                          THUMB

                          AREA ||i.UART_PROTOCOL2_CALLBACK_SetTxPeriodRequest||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL2_CALLBACK_SetTxPeriodRequest PROC
;;;647    // 码表设置周期下发数据请求标志
;;;648    void UART_PROTOCOL2_CALLBACK_SetTxPeriodRequest(uint32 param)
000000  4901              LDR      r1,|L1.8|
;;;649    {
;;;650    	uartProtocolCB2.txPeriodRequest = (BOOL)param;
000002  f8810174          STRB     r0,[r1,#0x174]
;;;651    }
000006  4770              BX       lr
;;;652    
                          ENDP

                  |L1.8|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOL2_CALLBACK_UartBusError||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL2_CALLBACK_UartBusError PROC
;;;653    // 	UART总线超时错误处理
;;;654    void UART_PROTOCOL2_CALLBACK_UartBusError(uint32 param)
000000  4902              LDR      r1,|L2.12|
;;;655    {
;;;656    	PARAM_SetErrorCode(ERROR_TYPE_COMMUNICATION_TIME_OUT);
000002  2030              MOVS     r0,#0x30
000004  f8810221          STRB     r0,[r1,#0x221]
;;;657    }
000008  4770              BX       lr
;;;658    
                          ENDP

00000a  0000              DCW      0x0000
                  |L2.12|
                          DCD      paramCB

                          AREA ||i.UART_PROTOCOL2_CmdFrameProcess||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL2_CmdFrameProcess PROC
;;;376    // UART命令帧缓冲区处理
;;;377    void UART_PROTOCOL2_CmdFrameProcess(UART_PROTOCOL2_CB* pCB)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;378    {
000004  4604              MOV      r4,r0
;;;379    	static uint8 number = 0;
;;;380    	
;;;381    	UART_PROTOCOL2_CMD cmd = UART_PROTOCOL2_CMD_NULL;
;;;382    	UART_PROTOCOL2_RX_CMD_FRAME* pCmdFrame = NULL;
;;;383    	//uint16 i;
;;;384    	uint32 temp;
;;;385    
;;;386    	// 参数合法性检验
;;;387    	if(NULL == pCB)
000006  2c00              CMP      r4,#0
000008  d074              BEQ      |L3.244|
;;;388    	{
;;;389    		return;
;;;390    	}
;;;391    
;;;392    	// 命令帧缓冲区为空，退出
;;;393    	if(pCB->rx.head == pCB->rx.end)
00000a  f8b4012e          LDRH     r0,[r4,#0x12e]
00000e  f8b41130          LDRH     r1,[r4,#0x130]
000012  4288              CMP      r0,r1
000014  d06e              BEQ      |L3.244|
;;;394    	{
;;;395    		return;
;;;396    	}
;;;397    
;;;398    	// 获取当前要处理的命令帧指针
;;;399    	pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.head];	
000016  eb041040          ADD      r0,r4,r0,LSL #5
00001a  30ce              ADDS     r0,r0,#0xce
;;;400    
;;;401    	cmd = pCB->cmdType;
00001c  f8b41178          LDRH     r1,[r4,#0x178]
;;;402    	
;;;403    	// 执行命令帧
;;;404    	switch(cmd)
000020  f2411324          MOV      r3,#0x1124
;;;405    	{
;;;406    		// 空命令，不予执行
;;;407    		case UART_PROTOCOL2_CMD_NULL:
;;;408    			break;
;;;409    
;;;410    		// 读协议版本
;;;411    		case UART_PROTOCOL2_CMD_READ_PROTOCOL_VERSION:
;;;412    			break;
;;;413    
;;;414    		// 写限速
;;;415    		case UART_PROTOCOL2_CMD_WRITE_LIMIT_SPEED:
;;;416    			break;
;;;417    //============================================================================================
;;;418    //============================================================================================
;;;419    		// 读驱动器状态
;;;420    		case UART_PROTOCOL2_CMD_READ_DRIVER_STATUS:
;;;421    
;;;422    			// 按照八方协议需屏蔽掉 刹车，低压，大灯 故障
;;;423    			if ((ERROR_TYPE_TURN_BAR_NOT_BACK == pCmdFrame->buff[UART_PROTOCOL2_CMD_DATA1_INDEX]) ||
;;;424    				(ERROR_TYPE_TURN_BAR_ERROR == pCmdFrame->buff[UART_PROTOCOL2_CMD_DATA1_INDEX]) ||
;;;425    				(ERROR_TYPE_OVER_VOLTAGE_PROTECT == pCmdFrame->buff[UART_PROTOCOL2_CMD_DATA1_INDEX]) ||
;;;426    				(ERROR_TYPE_MOTOR_HALL_ERROR == pCmdFrame->buff[UART_PROTOCOL2_CMD_DATA1_INDEX]) ||
;;;427    				(ERROR_TYPE_MOTOR_PHASE_ERROR2 == pCmdFrame->buff[UART_PROTOCOL2_CMD_DATA1_INDEX]) ||
;;;428    				(ERROR_TYPE_CONTROLLER_TEMP_REACH_PROTECT_POINT == pCmdFrame->buff[UART_PROTOCOL2_CMD_DATA1_INDEX]) ||
;;;429    				(ERROR_TYPE_MOTOR_TEMP_REACH_PROTECT_POINT == pCmdFrame->buff[UART_PROTOCOL2_CMD_DATA1_INDEX]) ||
;;;430    				(ERROR_TYPE_CURRENT_SENSOR_ERROR == pCmdFrame->buff[UART_PROTOCOL2_CMD_DATA1_INDEX]) ||
;;;431    				(ERROR_TYPE_BATTERY_INSIDE_TEMP_ERROR == pCmdFrame->buff[UART_PROTOCOL2_CMD_DATA1_INDEX]) ||
;;;432    				(ERROR_TYPE_MOTOR_INSIDE_TEMP_ERROR == pCmdFrame->buff[UART_PROTOCOL2_CMD_DATA1_INDEX]) ||
;;;433    				(ERROR_TYPE_SPEED_SENSOR_ERROR == pCmdFrame->buff[UART_PROTOCOL2_CMD_DATA1_INDEX]) ||
;;;434    				(ERROR_TYPE_BMS_COMMUNICATION_ERROR == pCmdFrame->buff[UART_PROTOCOL2_CMD_DATA1_INDEX]) ||
;;;435    				(ERROR_TYPE_LIGHT_SENSOR_ERROR == pCmdFrame->buff[UART_PROTOCOL2_CMD_DATA1_INDEX]) ||
;;;436    				(ERROR_TYPE_TORQUE_SENSOR_TORQUE_ERROR == pCmdFrame->buff[UART_PROTOCOL2_CMD_DATA1_INDEX]) ||
;;;437    				(ERROR_TYPE_TORQUE_SENSOR_SPEED_ERROR == pCmdFrame->buff[UART_PROTOCOL2_CMD_DATA1_INDEX]))
;;;438    			{
;;;439    				number++;
;;;440    				if (number > 3)
;;;441    				{
;;;442    					number = 0;
;;;443    
;;;444    					PARAM_SetErrorCode((ERROR_TYPE_E)pCmdFrame->buff[UART_PROTOCOL2_CMD_DATA1_INDEX]);
000024  4d62              LDR      r5,|L3.432|
000026  4299              CMP      r1,r3                 ;404
000028  d074              BEQ      |L3.276|
00002a  dc49              BGT      |L3.192|
00002c  f241131b          MOV      r3,#0x111b            ;404
000030  eba10203          SUB      r2,r1,r3              ;404
000034  4299              CMP      r1,r3                 ;404
000036  d043              BEQ      |L3.192|
000038  dc0a              BGT      |L3.80|
00003a  2900              CMP      r1,#0                 ;404
00003c  d040              BEQ      |L3.192|
00003e  f5a15188          SUB      r1,r1,#0x1100         ;404
000042  3908              SUBS     r1,r1,#8              ;404
000044  d009              BEQ      |L3.90|
000046  2902              CMP      r1,#2                 ;404
000048  d03b              BEQ      |L3.194|
00004a  2909              CMP      r1,#9                 ;404
00004c  d138              BNE      |L3.192|
00004e  e04b              B        |L3.232|
                  |L3.80|
000050  2a05              CMP      r2,#5                 ;404
000052  d060              BEQ      |L3.278|
000054  2a06              CMP      r2,#6                 ;404
000056  d133              BNE      |L3.192|
000058  e089              B        |L3.366|
                  |L3.90|
00005a  7881              LDRB     r1,[r0,#2]            ;423
00005c  2600              MOVS     r6,#0                 ;423
00005e  4b55              LDR      r3,|L3.436|
000060  2904              CMP      r1,#4                 ;423
000062  d01b              BEQ      |L3.156|
000064  2905              CMP      r1,#5                 ;424
000066  d019              BEQ      |L3.156|
000068  2907              CMP      r1,#7                 ;425
00006a  d017              BEQ      |L3.156|
00006c  2908              CMP      r1,#8                 ;426
00006e  d015              BEQ      |L3.156|
000070  2909              CMP      r1,#9                 ;427
000072  d013              BEQ      |L3.156|
000074  2910              CMP      r1,#0x10              ;428
000076  d011              BEQ      |L3.156|
000078  2911              CMP      r1,#0x11              ;429
00007a  d00f              BEQ      |L3.156|
00007c  2912              CMP      r1,#0x12              ;430
00007e  d00d              BEQ      |L3.156|
000080  2913              CMP      r1,#0x13              ;431
000082  d00b              BEQ      |L3.156|
000084  2914              CMP      r1,#0x14              ;432
000086  d009              BEQ      |L3.156|
000088  2921              CMP      r1,#0x21              ;433
00008a  d007              BEQ      |L3.156|
00008c  2922              CMP      r1,#0x22              ;434
00008e  d005              BEQ      |L3.156|
000090  2924              CMP      r1,#0x24              ;435
000092  d003              BEQ      |L3.156|
000094  2925              CMP      r1,#0x25              ;436
000096  d001              BEQ      |L3.156|
000098  2926              CMP      r1,#0x26              ;437
00009a  d10b              BNE      |L3.180|
                  |L3.156|
00009c  781a              LDRB     r2,[r3,#0]            ;439  ; number
00009e  1c52              ADDS     r2,r2,#1              ;439
0000a0  b2d2              UXTB     r2,r2                 ;439
0000a2  701a              STRB     r2,[r3,#0]            ;439
0000a4  2a03              CMP      r2,#3                 ;440
0000a6  d902              BLS      |L3.174|
0000a8  701e              STRB     r6,[r3,#0]            ;442
0000aa  f8851221          STRB     r1,[r5,#0x221]
                  |L3.174|
;;;445    				}
;;;446    				
;;;447    				PARAM_SetErrorCode((ERROR_TYPE_E)pCmdFrame->buff[UART_PROTOCOL2_CMD_DATA1_INDEX]);
0000ae  7881              LDRB     r1,[r0,#2]
0000b0  f8851221          STRB     r1,[r5,#0x221]
                  |L3.180|
;;;448    			}
;;;449    
;;;450    			// 为了通用各种协议，将八方的无错误0x01转成0x00
;;;451    			if (0x01 == pCmdFrame->buff[UART_PROTOCOL2_CMD_DATA1_INDEX])
0000b4  7880              LDRB     r0,[r0,#2]
0000b6  2801              CMP      r0,#1
0000b8  d16a              BNE      |L3.400|
;;;452    			{
;;;453    				number = 0;
0000ba  701e              STRB     r6,[r3,#0]
;;;454    				PARAM_SetErrorCode(ERROR_TYPE_NO_ERROR);
0000bc  f8856221          STRB     r6,[r5,#0x221]
                  |L3.192|
0000c0  e066              B        |L3.400|
                  |L3.194|
;;;455    			}
;;;456    			
;;;457    			break;
;;;458    
;;;459    		// 读工作状态
;;;460    		case UART_PROTOCOL2_CMD_READ_WORK_STATUS:
;;;461    			if (pCmdFrame->buff[UART_PROTOCOL2_CMD_DATA1_INDEX] == pCmdFrame->buff[UART_PROTOCOL2_CMD_DATA2_INDEX])
;;;462    			{
;;;463    				// 不工作状态
;;;464    				if (0x30 == pCmdFrame->buff[UART_PROTOCOL2_CMD_DATA1_INDEX])
;;;465    				{
;;;466    					//PARAM_SetCruiseSwitch(FALSE);
;;;467    				}
;;;468    				// 工作状态
;;;469    				else if (0x31 == pCmdFrame->buff[UART_PROTOCOL2_CMD_DATA1_INDEX])
;;;470    				{
;;;471    					//PARAM_SetCruiseSwitch(TRUE);
;;;472    				}
;;;473    			}			
;;;474    			break;
;;;475    
;;;476    		// 读瞬时电流
;;;477    		case UART_PROTOCOL2_CMD_READ_INSTANTANEOUS_CURRENT:
;;;478    			if (pCmdFrame->buff[UART_PROTOCOL2_CMD_DATA1_INDEX] == pCmdFrame->buff[UART_PROTOCOL2_CMD_DATA2_INDEX])
0000c2  7881              LDRB     r1,[r0,#2]
0000c4  78c0              LDRB     r0,[r0,#3]
0000c6  4281              CMP      r1,r0
0000c8  d162              BNE      |L3.400|
;;;479    			{
;;;480    				temp = pCmdFrame->buff[UART_PROTOCOL2_CMD_DATA1_INDEX] * 0.5f * 1000;	// 上报的单位为0.5A
0000ca  4608              MOV      r0,r1
0000cc  f7fffffe          BL       __aeabi_ui2f
0000d0  f04f31ff          MOV      r1,#0xffffffff
0000d4  f7fffffe          BL       __ARM_scalbnf
0000d8  4937              LDR      r1,|L3.440|
0000da  f7fffffe          BL       __aeabi_fmul
0000de  f7fffffe          BL       __aeabi_f2uiz
;;;481    				PARAM_SetBatteryCurrent(temp);
0000e2  f8a5016c          STRH     r0,[r5,#0x16c]
0000e6  e053              B        |L3.400|
                  |L3.232|
;;;482    			}
;;;483    
;;;484    			break;
;;;485    
;;;486    		// 读电池容量
;;;487    		case UART_PROTOCOL2_CMD_READ_BATTERY_CAPACITY:
;;;488    			//if (pCmdFrame->buff[UART_PROTOCOL2_CMD_DATA1_INDEX] == pCmdFrame->buff[UART_PROTOCOL2_CMD_DATA2_INDEX])
;;;489    			//{
;;;490    			//	PARAM_SetBatteryPercent(pCmdFrame->buff[UART_PROTOCOL2_CMD_DATA1_INDEX]);
;;;491    			//}
;;;492    
;;;493    			if (BATTERY_DATA_SRC_CONTROLLER == PARAM_GetBatteryDataSrc())
0000e8  f8951173          LDRB     r1,[r5,#0x173]  ; paramCB
0000ec  b119              CBZ      r1,|L3.246|
;;;494    			{
;;;495    				// 没有电压上报的字段，故为了兼容人为采用固定电压
;;;496    				temp = PARAM_GetBatteryVoltageLevel();
;;;497    				temp *= 1000;											// 单位转换: 1V转换为1000mV	
;;;498    				
;;;499    				PARAM_SetBatteryVoltage(temp);
;;;500    			}
;;;501    			else if (BATTERY_DATA_SRC_BMS == PARAM_GetBatteryDataSrc())
0000ee  2901              CMP      r1,#1
0000f0  d009              BEQ      |L3.262|
0000f2  e04d              B        |L3.400|
                  |L3.244|
0000f4  e059              B        |L3.426|
                  |L3.246|
0000f6  f8950338          LDRB     r0,[r5,#0x338]        ;496  ; paramCB
0000fa  f44f717a          MOV      r1,#0x3e8             ;497
0000fe  4348              MULS     r0,r1,r0              ;497
000100  f8c50168          STR      r0,[r5,#0x168]        ;499  ; paramCB
000104  e044              B        |L3.400|
                  |L3.262|
;;;502    			{
;;;503    				// 电量
;;;504    				if (pCmdFrame->buff[UART_PROTOCOL2_CMD_DATA1_INDEX] == pCmdFrame->buff[UART_PROTOCOL2_CMD_DATA2_INDEX])
000106  7881              LDRB     r1,[r0,#2]
000108  78c0              LDRB     r0,[r0,#3]
00010a  4281              CMP      r1,r0
00010c  d140              BNE      |L3.400|
;;;505    				{
;;;506    					PARAM_SetBatteryPercent(pCmdFrame->buff[UART_PROTOCOL2_CMD_DATA1_INDEX]);
00010e  f8851172          STRB     r1,[r5,#0x172]
000112  e03d              B        |L3.400|
                  |L3.276|
000114  e036              B        |L3.388|
                  |L3.278|
;;;507    				}
;;;508    			}
;;;509    			
;;;510    			break;
;;;511    
;;;512    		// 读转速
;;;513    		case UART_PROTOCOL2_CMD_READ_RPM:
;;;514    			if (((pCmdFrame->buff[UART_PROTOCOL2_CMD_DATA1_INDEX] + pCmdFrame->buff[UART_PROTOCOL2_CMD_DATA2_INDEX] + 0x20) & 0xFF) == pCmdFrame->buff[UART_PROTOCOL2_CMD_DATA3_INDEX])
000116  7881              LDRB     r1,[r0,#2]
000118  78c2              LDRB     r2,[r0,#3]
00011a  7900              LDRB     r0,[r0,#4]
00011c  188b              ADDS     r3,r1,r2
00011e  3320              ADDS     r3,r3,#0x20
000120  b2db              UXTB     r3,r3
000122  4283              CMP      r3,r0
000124  d11f              BNE      |L3.358|
;;;515    			{
;;;516    				float speed;
;;;517    				
;;;518    				temp = pCmdFrame->buff[UART_PROTOCOL2_CMD_DATA1_INDEX];
;;;519    				temp <<= 8;
000126  0208              LSLS     r0,r1,#8
;;;520    				temp += pCmdFrame->buff[UART_PROTOCOL2_CMD_DATA2_INDEX];
000128  1816              ADDS     r6,r2,r0
;;;521    
;;;522    				//speed = 0.00006f * temp * PARAM_GetPerimeter(PARAM_GetWheelSizeID());
;;;523    				speed = 0.00006f * temp * PARAM_GetNewperimeter();
00012a  f8b502ba          LDRH     r0,[r5,#0x2ba]  ; paramCB
00012e  f7fffffe          BL       __aeabi_ui2f
000132  4607              MOV      r7,r0
000134  4630              MOV      r0,r6
000136  f7fffffe          BL       __aeabi_ui2f
00013a  4920              LDR      r1,|L3.444|
00013c  f7fffffe          BL       __aeabi_fmul
000140  4639              MOV      r1,r7
000142  f7fffffe          BL       __aeabi_fmul
;;;524    				LIMIT_TO_MAX(speed, 99.9);
000146  491e              LDR      r1,|L3.448|
000148  4288              CMP      r0,r1
00014a  db00              BLT      |L3.334|
00014c  4608              MOV      r0,r1
                  |L3.334|
;;;525    				PARAM_SetSpeed((uint16)(speed*10));	// 转换为0.1KM/H，传入到参数池
00014e  491d              LDR      r1,|L3.452|
000150  f7fffffe          BL       __aeabi_fmul
000154  f7fffffe          BL       __aeabi_f2uiz
000158  f8a50218          STRH     r0,[r5,#0x218]
;;;526    
;;;527    				// 速度不为0，重置定时关机任务
;;;528    				if(PARAM_GetSpeed() != 0)
00015c  f7fffffe          BL       PARAM_GetSpeed
000160  b108              CBZ      r0,|L3.358|
;;;529    				{
;;;530    					STATE_ResetAutoPowerOffControl();
000162  f7fffffe          BL       STATE_ResetAutoPowerOffControl
                  |L3.358|
;;;531    				}
;;;532    			}
;;;533    
;;;534    			// 参数计算标志打开
;;;535    			PARAM_SetRecaculateRequest(TRUE);
000166  2001              MOVS     r0,#1
000168  f8850486          STRB     r0,[r5,#0x486]
;;;536    			
;;;537    			break;
00016c  e010              B        |L3.400|
                  |L3.366|
;;;538    
;;;539    		// 读大灯开启值
;;;540    		case UART_PROTOCOL2_CMD_READ_LIGHT_SWITCH:
;;;541    			break;
;;;542    		// 读电池信息1
;;;543    		case UART_PROTOCOL2_CMD_READ_BATTERY_INFO1:
;;;544    			break;
;;;545    		// 读电池信息2
;;;546    		case UART_PROTOCOL2_CMD_READ_BATTERY_INFO2:
;;;547    			break;
;;;548    
;;;549    		// 读剩余里程
;;;550    		case UART_PROTOCOL2_CMD_READ_REMAINDER_MILEAGE:
;;;551    			if (pCmdFrame->buff[UART_PROTOCOL2_CMD_DATA1_INDEX] + pCmdFrame->buff[UART_PROTOCOL2_CMD_DATA2_INDEX] == pCmdFrame->buff[UART_PROTOCOL2_CMD_DATA3_INDEX])
;;;552    			{
;;;553    				temp = pCmdFrame->buff[UART_PROTOCOL2_CMD_DATA1_INDEX];
;;;554    				temp <<= 8;
;;;555    				temp += pCmdFrame->buff[UART_PROTOCOL2_CMD_DATA2_INDEX];
;;;556    
;;;557    				#warning "参数层需要增加剩余里程变量"
;;;558    			}						
;;;559    			
;;;560    			break;
;;;561    
;;;562    		// 读驱动器错误代码
;;;563    		case UART_PROTOCOL2_CMD_READ_DRIVER_ERROR_CODE:
;;;564    			break;
;;;565    
;;;566    		// 读踏频
;;;567    		case UART_PROTOCOL2_CMD_READ_CADENCE:
;;;568    			if (pCmdFrame->buff[UART_PROTOCOL2_CMD_DATA1_INDEX] + pCmdFrame->buff[UART_PROTOCOL2_CMD_DATA2_INDEX] == pCmdFrame->buff[UART_PROTOCOL2_CMD_DATA3_INDEX])
00016e  7881              LDRB     r1,[r0,#2]
000170  78c2              LDRB     r2,[r0,#3]
000172  7900              LDRB     r0,[r0,#4]
000174  188b              ADDS     r3,r1,r2
000176  4283              CMP      r3,r0
000178  d10a              BNE      |L3.400|
;;;569    			{
;;;570    				temp = pCmdFrame->buff[UART_PROTOCOL2_CMD_DATA1_INDEX];
;;;571    				temp <<= 8;
00017a  0208              LSLS     r0,r1,#8
;;;572    				temp += pCmdFrame->buff[UART_PROTOCOL2_CMD_DATA2_INDEX];
00017c  4410              ADD      r0,r0,r2
;;;573    				
;;;574    				PARAM_SetCadence(temp);
00017e  f885021a          STRB     r0,[r5,#0x21a]
000182  e005              B        |L3.400|
                  |L3.388|
;;;575    			}
;;;576    			break;
;;;577    
;;;578    		// 读脚踏半圈力矩最大值
;;;579    		case UART_PROTOCOL2_CMD_READ_TQKG:
;;;580    			if (pCmdFrame->buff[UART_PROTOCOL2_CMD_DATA1_INDEX] == pCmdFrame->buff[UART_PROTOCOL2_CMD_DATA2_INDEX])
000184  7881              LDRB     r1,[r0,#2]
000186  78c0              LDRB     r0,[r0,#3]
000188  4281              CMP      r1,r0
00018a  d101              BNE      |L3.400|
;;;581    			{
;;;582    				PARAM_SetTorque(pCmdFrame->buff[UART_PROTOCOL2_CMD_DATA1_INDEX]);
00018c  f8851225          STRB     r1,[r5,#0x225]
                  |L3.400|
;;;583    			}
;;;584    			break;
;;;585    		
;;;586    //===================================================
;;;587    //===================================================
;;;588    		// 写档位
;;;589    		case UART_PROTOCOL2_CMD_WRITE_ASSIST_LEVEL:
;;;590    			break;
;;;591    
;;;592    		// 写大灯开关
;;;593    		case UART_PROTOCOL2_CMD_WRITE_LIGHT_SWITCH:
;;;594    			break;
;;;595    
;;;596    		// 写清除控制器错误码
;;;597    		case UART_PROTOCOL2_CMD_WRITE_CLEAR_DRIVER_ERROR_CODE:
;;;598    			break;
;;;599    					
;;;600    		default:
;;;601    			break;
;;;602    	}
;;;603    
;;;604    	// 启动UART总线通讯超时判断
;;;605    	UART_PROTOCOL2_StartTimeoutCheckTask();
000190  f7fffffe          BL       UART_PROTOCOL2_StartTimeoutCheckTask
;;;606    	
;;;607    	// 删除命令帧
;;;608    	pCB->rx.head ++;
000194  f8b4012e          LDRH     r0,[r4,#0x12e]
000198  1c40              ADDS     r0,r0,#1
00019a  b280              UXTH     r0,r0
;;;609    	pCB->rx.head %= UART_PROTOCOL2_RX_QUEUE_SIZE;
00019c  2103              MOVS     r1,#3
00019e  fbb0f2f1          UDIV     r2,r0,r1
0001a2  fb010012          MLS      r0,r1,r2,r0
0001a6  f8a4012e          STRH     r0,[r4,#0x12e]
                  |L3.426|
;;;610    }
0001aa  e8bd81f0          POP      {r4-r8,pc}
;;;611    
                          ENDP

0001ae  0000              DCW      0x0000
                  |L3.432|
                          DCD      paramCB
                  |L3.436|
                          DCD      ||.data||
                  |L3.440|
                          DCD      0x447a0000
                  |L3.444|
                          DCD      0x387ba882
                  |L3.448|
                          DCD      0x42c7cccd
                  |L3.452|
                          DCD      0x41200000

                          AREA ||i.UART_PROTOCOL2_ConfirmTempCmdFrameBuff||, CODE, READONLY, ALIGN=1

                  UART_PROTOCOL2_ConfirmTempCmdFrameBuff PROC
;;;267    // 将临时缓冲区添加到命令帧缓冲区中，其本质操作是承认临时缓冲区数据有效
;;;268    BOOL UART_PROTOCOL2_ConfirmTempCmdFrameBuff(UART_PROTOCOL2_CB* pCB)
000000  2800              CMP      r0,#0
;;;269    {
000002  d016              BEQ      |L4.50|
;;;270    	UART_PROTOCOL2_RX_CMD_FRAME* pCmdFrame = NULL;
;;;271    	
;;;272    	// 参数合法性检验
;;;273    	if(NULL == pCB)
;;;274    	{
;;;275    		return FALSE;
;;;276    	}
;;;277    
;;;278    	// 临时缓冲区为空，不予添加
;;;279    	pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.end];
000004  f8b01130          LDRH     r1,[r0,#0x130]
000008  eb001241          ADD      r2,r0,r1,LSL #5
;;;280    	if(0 == pCmdFrame->length)
00000c  f8b220ec          LDRH     r2,[r2,#0xec]
000010  b18a              CBZ      r2,|L4.54|
;;;281    	{
;;;282    		return FALSE;
;;;283    	}
;;;284    
;;;285    	// 添加
;;;286    	pCB->rx.end ++;
000012  1c49              ADDS     r1,r1,#1
000014  b289              UXTH     r1,r1
;;;287    	pCB->rx.end %= UART_PROTOCOL2_RX_QUEUE_SIZE;
000016  2203              MOVS     r2,#3
000018  fbb1f3f2          UDIV     r3,r1,r2
00001c  fb021113          MLS      r1,r2,r3,r1
000020  f8a01130          STRH     r1,[r0,#0x130]
;;;288    	pCB->rx.cmdQueue[pCB->rx.end].length = 0;	// 该行的作用是将新的添加位置有效数据个数清零，以便将这个位置当做临时帧缓冲区
000024  eb001041          ADD      r0,r0,r1,LSL #5
000028  2200              MOVS     r2,#0
00002a  f8a020ec          STRH     r2,[r0,#0xec]
;;;289    	
;;;290    	return TRUE;
00002e  2001              MOVS     r0,#1
;;;291    }
000030  4770              BX       lr
                  |L4.50|
000032  2000              MOVS     r0,#0                 ;275
000034  4770              BX       lr
                  |L4.54|
000036  2000              MOVS     r0,#0                 ;282
000038  4770              BX       lr
;;;292    
                          ENDP


                          AREA ||i.UART_PROTOCOL2_DataCommunicationSequenceProcess||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL2_DataCommunicationSequenceProcess PROC
;;;659    // 码表发送数据通讯时序处理
;;;660    void UART_PROTOCOL2_DataCommunicationSequenceProcess(void)
000000  b510              PUSH     {r4,lr}
;;;661    {
;;;662    	// 如果正在接收数据，不允许中途打断
;;;663    	//if (uartProtocolCB2.rxFIFO.rxFIFOBusy)
;;;664    	//{
;;;665    	//	return;
;;;666    	//}
;;;667    	
;;;668    	// 立即发送请求
;;;669    	if (uartProtocolCB2.txAtOnceRequest)
000002  4813              LDR      r0,|L5.80|
000004  2100              MOVS     r1,#0
000006  f8902175          LDRB     r2,[r0,#0x175]  ; uartProtocolCB2
00000a  2a00              CMP      r2,#0
00000c  d013              BEQ      |L5.54|
;;;670    	{
;;;671    		// 重新复位参数下发定时器
;;;672    //		TIMER_ResetTimer(TIMER_ID_PROTOCOL_PARAM_TX);
;;;673    
;;;674    		uartProtocolCB2.txAtOnceRequest = FALSE;
00000e  f8801175          STRB     r1,[r0,#0x175]
;;;675    #if 0
;;;676    		if (UART_PROTOCOL2_TX_CMD_TYPE_ASSIST == uartProtocolCB2.txAtOnceCmdType)
;;;677    		{
;;;678    			// 写档位
;;;679    			UART_PROTOCOL2_WriteAssistLevel(PARAM_GetMaxAssist(), PARAM_GetAssistLevel());
;;;680    		}
;;;681    		else if (UART_PROTOCOL2_TX_CMD_TYPE_LIGHT == uartProtocolCB2.txAtOnceCmdType)
;;;682    		{
;;;683    			// 写大灯
;;;684    			UART_PROTOCOL2_WriteLightSwitch(PARAM_GetLightSwitch());
;;;685    		}
;;;686    #endif
;;;687    		// 写档位
;;;688    		UART_PROTOCOL2_WriteAssistLevel(PARAM_GetMaxAssist(), PARAM_GetAssistLevel());
000012  f7fffffe          BL       PARAM_GetAssistLevel
000016  4c0f              LDR      r4,|L5.84|
000018  4601              MOV      r1,r0
00001a  f894031a          LDRB     r0,[r4,#0x31a]  ; paramCB
00001e  f7fffffe          BL       UART_PROTOCOL2_WriteAssistLevel
;;;689    		// 写大灯状态
;;;690    		UART_PROTOCOL2_WriteLightSwitch(PARAM_GetLightSwitch());
000022  f8940202          LDRB     r0,[r4,#0x202]  ; paramCB
000026  f7fffffe          BL       UART_PROTOCOL2_WriteLightSwitch
;;;691    		// 写限速
;;;692    		UART_PROTOCOL2_WriteLimitSpeed(paramCB.nvm.param.common.speed.limitVal);
00002a  f8b40334          LDRH     r0,[r4,#0x334]  ; paramCB
00002e  e8bd4010          POP      {r4,lr}
000032  f7ffbffe          B.W      UART_PROTOCOL2_WriteLimitSpeed
                  |L5.54|
;;;693    
;;;694    		return;
;;;695    	}
;;;696    
;;;697    	// 周期性发送请求
;;;698    	if (uartProtocolCB2.txPeriodRequest)
000036  f8902174          LDRB     r2,[r0,#0x174]  ; uartProtocolCB2
00003a  2a00              CMP      r2,#0
00003c  d006              BEQ      |L5.76|
;;;699    	{
;;;700    		uartProtocolCB2.txPeriodRequest = FALSE;
00003e  f8801174          STRB     r1,[r0,#0x174]
;;;701    
;;;702    		UART_PROTOCOL2_DataInteractionProcess(TRUE);		
000042  e8bd4010          POP      {r4,lr}
000046  2001              MOVS     r0,#1
000048  f7ffbffe          B.W      UART_PROTOCOL2_DataInteractionProcess
                  |L5.76|
;;;703    	}	
;;;704    }
00004c  bd10              POP      {r4,pc}
;;;705    
                          ENDP

00004e  0000              DCW      0x0000
                  |L5.80|
                          DCD      ||.bss||
                  |L5.84|
                          DCD      paramCB

                          AREA ||i.UART_PROTOCOL2_DataInteractionProcess||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL2_DataInteractionProcess PROC
;;;706    // 和控制器数据交互步骤处理
;;;707    void UART_PROTOCOL2_DataInteractionProcess(uint32 param)
000000  b570              PUSH     {r4-r6,lr}
;;;708    {
;;;709    	switch (uartProtocolCB2.step)
000002  4c2e              LDR      r4,|L6.188|
000004  2501              MOVS     r5,#1
000006  f894017a          LDRB     r0,[r4,#0x17a]  ; uartProtocolCB2
00000a  2808              CMP      r0,#8
00000c  d252              BCS      |L6.180|
00000e  e8dff000          TBB      [pc,r0]
000012  040d              DCB      0x04,0x0d
000014  23273039          DCB      0x23,0x27,0x30,0x39
000018  424b              DCB      0x42,0x4b
;;;710    	{
;;;711    		case 0:
;;;712    			// 读取协议版本
;;;713    			UART_PROTOCOL2_ReadProtocolVersion(TRUE);
00001a  2001              MOVS     r0,#1
00001c  f7fffffe          BL       UART_PROTOCOL2_ReadProtocolVersion
;;;714    
;;;715    			uartProtocolCB2.step ++;
000020  f894017a          LDRB     r0,[r4,#0x17a]  ; uartProtocolCB2
000024  1c40              ADDS     r0,r0,#1
000026  f884017a          STRB     r0,[r4,#0x17a]
;;;716    			
;;;717    			break;
;;;718    
;;;719    		case 1:			
;;;720    			// 写档位
;;;721    			UART_PROTOCOL2_WriteAssistLevel(PARAM_GetMaxAssist(), PARAM_GetAssistLevel());
;;;722    			// 写大灯状态
;;;723    			UART_PROTOCOL2_WriteLightSwitch(PARAM_GetLightSwitch());
;;;724    			// 写限速
;;;725    			UART_PROTOCOL2_WriteLimitSpeed(paramCB.nvm.param.common.speed.limitVal);
;;;726    
;;;727    			uartProtocolCB2.step ++;
;;;728    			
;;;729    			break;
;;;730    
;;;731    		case 2:			
;;;732    			// 留出这段时间，让写档位大灯限速有充分的时间，防止控制器异常
;;;733    			uartProtocolCB2.step ++;
;;;734    			
;;;735    			break;
;;;736    
;;;737    		case 3:
;;;738    			// 读取转速
;;;739    			UART_PROTOCOL2_ReadRPM(TRUE);
;;;740    
;;;741    			uartProtocolCB2.step ++;
;;;742    			
;;;743    			break;
;;;744    
;;;745    		case 4:
;;;746    			// 读驱动器状态
;;;747    			UART_PROTOCOL2_ReadDriverStatus(TRUE);
;;;748    
;;;749    			uartProtocolCB2.step ++;
;;;750    			
;;;751    			break;
;;;752    
;;;753    		case 5:
;;;754    			// 读取电池容量
;;;755    			UART_PROTOCOL2_ReadBatteryCapacity(TRUE);
;;;756    
;;;757    			uartProtocolCB2.step ++;
;;;758    			
;;;759    			break;
;;;760    			
;;;761    		case 6:
;;;762    			// 读系统工作状态
;;;763    			UART_PROTOCOL2_ReadSysWorkStatus(TRUE);
;;;764    		
;;;765    			uartProtocolCB2.step ++;
;;;766    			
;;;767    			break;
;;;768    			
;;;769    
;;;770    		case 7:
;;;771    			// 读瞬时电流
;;;772    			UART_PROTOCOL2_ReadInstantaneousCurrent(TRUE);
;;;773    
;;;774    			uartProtocolCB2.step = 1;
;;;775    			
;;;776    			break;
;;;777    
;;;778    		default:
;;;779    			uartProtocolCB2.step = 1;
;;;780    			break;	
;;;781    	}
;;;782    }
00002a  bd70              POP      {r4-r6,pc}
00002c  f7fffffe          BL       PARAM_GetAssistLevel
000030  4d23              LDR      r5,|L6.192|
000032  4601              MOV      r1,r0                 ;721
000034  f895031a          LDRB     r0,[r5,#0x31a]        ;721  ; paramCB
000038  f7fffffe          BL       UART_PROTOCOL2_WriteAssistLevel
00003c  f8950202          LDRB     r0,[r5,#0x202]        ;723  ; paramCB
000040  f7fffffe          BL       UART_PROTOCOL2_WriteLightSwitch
000044  f8b50334          LDRH     r0,[r5,#0x334]        ;725  ; paramCB
000048  f7fffffe          BL       UART_PROTOCOL2_WriteLimitSpeed
00004c  f894017a          LDRB     r0,[r4,#0x17a]        ;727  ; uartProtocolCB2
000050  1c40              ADDS     r0,r0,#1              ;727
000052  f884017a          STRB     r0,[r4,#0x17a]        ;727
000056  bd70              POP      {r4-r6,pc}
000058  2003              MOVS     r0,#3                 ;733
00005a  f884017a          STRB     r0,[r4,#0x17a]        ;733
00005e  bd70              POP      {r4-r6,pc}
000060  2001              MOVS     r0,#1                 ;739
000062  f7fffffe          BL       UART_PROTOCOL2_ReadRPM
000066  f894017a          LDRB     r0,[r4,#0x17a]        ;741  ; uartProtocolCB2
00006a  1c40              ADDS     r0,r0,#1              ;741
00006c  f884017a          STRB     r0,[r4,#0x17a]        ;741
000070  bd70              POP      {r4-r6,pc}
000072  2001              MOVS     r0,#1                 ;747
000074  f7fffffe          BL       UART_PROTOCOL2_ReadDriverStatus
000078  f894017a          LDRB     r0,[r4,#0x17a]        ;749  ; uartProtocolCB2
00007c  1c40              ADDS     r0,r0,#1              ;749
00007e  f884017a          STRB     r0,[r4,#0x17a]        ;749
000082  bd70              POP      {r4-r6,pc}
000084  2001              MOVS     r0,#1                 ;755
000086  f7fffffe          BL       UART_PROTOCOL2_ReadBatteryCapacity
00008a  f894017a          LDRB     r0,[r4,#0x17a]        ;757  ; uartProtocolCB2
00008e  1c40              ADDS     r0,r0,#1              ;757
000090  f884017a          STRB     r0,[r4,#0x17a]        ;757
000094  bd70              POP      {r4-r6,pc}
000096  2001              MOVS     r0,#1                 ;763
000098  f7fffffe          BL       UART_PROTOCOL2_ReadSysWorkStatus
00009c  f894017a          LDRB     r0,[r4,#0x17a]        ;765  ; uartProtocolCB2
0000a0  1c40              ADDS     r0,r0,#1              ;765
0000a2  f884017a          STRB     r0,[r4,#0x17a]        ;765
0000a6  bd70              POP      {r4-r6,pc}
0000a8  2001              MOVS     r0,#1                 ;772
0000aa  f7fffffe          BL       UART_PROTOCOL2_ReadInstantaneousCurrent
0000ae  f884517a          STRB     r5,[r4,#0x17a]        ;774
0000b2  bd70              POP      {r4-r6,pc}
                  |L6.180|
0000b4  f884517a          STRB     r5,[r4,#0x17a]        ;779
0000b8  bd70              POP      {r4-r6,pc}
;;;783    
                          ENDP

0000ba  0000              DCW      0x0000
                  |L6.188|
                          DCD      ||.bss||
                  |L6.192|
                          DCD      paramCB

                          AREA ||i.UART_PROTOCOL2_DataStructInit||, CODE, READONLY, ALIGN=1

                  UART_PROTOCOL2_DataStructInit PROC
;;;201    // 数据结构初始化
;;;202    void UART_PROTOCOL2_DataStructInit(UART_PROTOCOL2_CB* pCB)
000000  2800              CMP      r0,#0
;;;203    {
000002  d024              BEQ      |L7.78|
;;;204    	uint16 i;
;;;205    	
;;;206    	// 参数合法性检验
;;;207    	if (NULL == pCB)
;;;208    	{
;;;209    		return;
;;;210    	}
;;;211    
;;;212    	pCB->tx.txBusy = FALSE;
000004  2200              MOVS     r2,#0
000006  f880216c          STRB     r2,[r0,#0x16c]
;;;213    	pCB->tx.index = 0;
00000a  f8a0216a          STRH     r2,[r0,#0x16a]
;;;214    	pCB->tx.head = 0;
00000e  f8a02166          STRH     r2,[r0,#0x166]
;;;215    	pCB->tx.end = 0;
000012  f8a02168          STRH     r2,[r0,#0x168]
;;;216    	for(i = 0; i < UART_PROTOCOL2_TX_QUEUE_SIZE; i++)
000016  2100              MOVS     r1,#0
                  |L7.24|
;;;217    	{
;;;218    		pCB->tx.cmdQueue[i].length = 0;
000018  eb010381          ADD      r3,r1,r1,LSL #2
00001c  eb000343          ADD      r3,r0,r3,LSL #1
000020  f8a3213c          STRH     r2,[r3,#0x13c]
000024  1c49              ADDS     r1,r1,#1              ;216
000026  b289              UXTH     r1,r1                 ;216
000028  2905              CMP      r1,#5                 ;216
00002a  d3f5              BCC      |L7.24|
;;;219    	}
;;;220    
;;;221    	pCB->rxFIFO.head = 0;
00002c  f8a020c8          STRH     r2,[r0,#0xc8]
;;;222    	pCB->rxFIFO.end = 0;
000030  f8a020ca          STRH     r2,[r0,#0xca]
;;;223    
;;;224    	pCB->rx.head = 0;
000034  f8a0212e          STRH     r2,[r0,#0x12e]
;;;225    	pCB->rx.end  = 0;
000038  f8a02130          STRH     r2,[r0,#0x130]
;;;226    	for(i=0; i<UART_PROTOCOL2_RX_QUEUE_SIZE; i++)
00003c  2100              MOVS     r1,#0
                  |L7.62|
;;;227    	{
;;;228    		pCB->rx.cmdQueue[i].length = 0;
00003e  eb001341          ADD      r3,r0,r1,LSL #5
000042  f8a320ec          STRH     r2,[r3,#0xec]
000046  1c49              ADDS     r1,r1,#1              ;226
000048  b289              UXTH     r1,r1                 ;226
00004a  2903              CMP      r1,#3                 ;226
00004c  d3f7              BCC      |L7.62|
                  |L7.78|
;;;229    	}
;;;230    }
00004e  4770              BX       lr
;;;231    
                          ENDP


                          AREA ||i.UART_PROTOCOL2_Init||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL2_Init PROC
;;;99     // 协议初始化
;;;100    void UART_PROTOCOL2_Init(void)
000000  b510              PUSH     {r4,lr}
;;;101    {
;;;102    	// 协议层数据结构初始化
;;;103    	UART_PROTOCOL2_DataStructInit(&uartProtocolCB2);
000002  4809              LDR      r0,|L8.40|
000004  f7fffffe          BL       UART_PROTOCOL2_DataStructInit
;;;104    
;;;105    	// 向驱动层注册数据接收接口
;;;106    	UART_DRIVE_RegisterDataSendService(UART_PROTOCOL2_MacProcess);
000008  4808              LDR      r0,|L8.44|
00000a  f7fffffe          BL       UART_DRIVE_RegisterDataSendService
;;;107    
;;;108    	// 向驱动层注册数据发送接口
;;;109    	UART_PROTOCOL2_RegisterDataSendService(UART_DRIVE_AddTxArray);
00000e  4808              LDR      r0,|L8.48|
000010  f7fffffe          BL       UART_PROTOCOL2_RegisterDataSendService
;;;110    
;;;111    	// 注册间隔参数设置时间
;;;112    //	TIMER_AddTask(TIMER_ID_PROTOCOL_PARAM_TX,
;;;113    //					UART_PROTOCOL2_CMD_SEND_TIME,
;;;114    //					UART_PROTOCOL2_CALLBACK_SetTxPeriodRequest,
;;;115    //					TRUE,
;;;116    //					TIMER_LOOP_FOREVER,
;;;117    //					ACTION_MODE_ADD_TO_QUEUE);
;;;118    
;;;119    	// 设置参数层参数周期更新时间
;;;120    	PARAM_SetParamCycleTime(UART_PROTOCOL2_CMD_SEND_TIME*7);	// 6条命令为1个循环+1个空等待写时间
000014  4907              LDR      r1,|L8.52|
000016  f44f7052          MOV      r0,#0x348
00001a  f8a10226          STRH     r0,[r1,#0x226]
;;;121    
;;;122    	// 启动UART总线通讯超时判断
;;;123    	UART_PROTOCOL2_StartTimeoutCheckTask();
00001e  e8bd4010          POP      {r4,lr}
000022  f7ffbffe          B.W      UART_PROTOCOL2_StartTimeoutCheckTask
;;;124    }
;;;125    
                          ENDP

000026  0000              DCW      0x0000
                  |L8.40|
                          DCD      ||.bss||
                  |L8.44|
                          DCD      UART_PROTOCOL2_MacProcess
                  |L8.48|
                          DCD      UART_DRIVE_AddTxArray
                  |L8.52|
                          DCD      paramCB

                          AREA ||i.UART_PROTOCOL2_MacProcess||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL2_MacProcess PROC
;;;232    // UART报文接收处理函数(注意根据具体模块修改)
;;;233    void UART_PROTOCOL2_MacProcess(uint16 standarID, uint8* pData, uint16 length)
000000  e92d03f0          PUSH     {r4-r9}
;;;234    {
;;;235    	uint16 end = uartProtocolCB2.rxFIFO.end;
000004  4b10              LDR      r3,|L9.72|
000006  f8b340ca          LDRH     r4,[r3,#0xca]  ; uartProtocolCB2
;;;236    	uint16 head = uartProtocolCB2.rxFIFO.head;
00000a  f8b370c8          LDRH     r7,[r3,#0xc8]  ; uartProtocolCB2
;;;237    	uint8 rxdata = 0x00;
;;;238    	
;;;239    	// 接收数据
;;;240    	rxdata = *pData;
00000e  f891c000          LDRB     r12,[r1,#0]
;;;241    
;;;242    	// 一级缓冲区已满，不予接收
;;;243    	if((end + 1)%UART_PROTOCOL2_RX_FIFO_SIZE == head)
000012  1c65              ADDS     r5,r4,#1
000014  26c8              MOVS     r6,#0xc8
000016  fbb5f8f6          UDIV     r8,r5,r6
00001a  fb065518          MLS      r5,r6,r8,r5
00001e  42bd              CMP      r5,r7
000020  d00f              BEQ      |L9.66|
;;;244    	{
;;;245    		return;
;;;246    	}
;;;247    	// 一级缓冲区未满，接收 
;;;248    	else
;;;249    	{
;;;250    		// 将接收到的数据放到临时缓冲区中
;;;251    		uartProtocolCB2.rxFIFO.buff[end] = rxdata;
000022  f803c004          STRB     r12,[r3,r4]
;;;252    		uartProtocolCB2.rxFIFO.end ++;
000026  f8334fca          LDRH     r4,[r3,#0xca]!  ; uartProtocolCB2
00002a  1c64              ADDS     r4,r4,#1
00002c  801c              STRH     r4,[r3,#0]
;;;253    		uartProtocolCB2.rxFIFO.end %= UART_PROTOCOL2_RX_FIFO_SIZE;
00002e  881c              LDRH     r4,[r3,#0]  ; uartProtocolCB2
000030  fbb4f5f6          UDIV     r5,r4,r6
000034  fb064415          MLS      r4,r6,r5,r4
000038  801c              STRH     r4,[r3,#0]
;;;254    	}	
;;;255    
;;;256    //====================================================================
;;;257    	// 借用KM5S协议解析
;;;258    	UART_PROTOCOL_MacProcess(standarID, pData, length);
00003a  e8bd03f0          POP      {r4-r9}
00003e  f7ffbffe          B.W      UART_PROTOCOL_MacProcess
                  |L9.66|
;;;259    }
000042  e8bd03f0          POP      {r4-r9}
000046  4770              BX       lr
;;;260    
                          ENDP

                  |L9.72|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOL2_Process||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL2_Process PROC
;;;126    // UART协议层过程处理
;;;127    void UART_PROTOCOL2_Process(void)
000000  b510              PUSH     {r4,lr}
;;;128    {
;;;129    	// UART接收FIFO缓冲区处理
;;;130    	UART_PROTOCOL2_RxFIFOProcess(&uartProtocolCB2);
000002  4807              LDR      r0,|L10.32|
000004  f7fffffe          BL       UART_PROTOCOL2_RxFIFOProcess
;;;131    
;;;132    	// UART接收命令缓冲区处理
;;;133    	UART_PROTOCOL2_CmdFrameProcess(&uartProtocolCB2);
000008  4805              LDR      r0,|L10.32|
00000a  f7fffffe          BL       UART_PROTOCOL2_CmdFrameProcess
;;;134    	
;;;135    	// UART协议层发送处理过程
;;;136    	UART_PROTOCOL2_TxStateProcess();
00000e  f7fffffe          BL       UART_PROTOCOL2_TxStateProcess
;;;137    
;;;138    	// 码表发送数据通讯时序处理
;;;139    	UART_PROTOCOL2_DataCommunicationSequenceProcess();
000012  f7fffffe          BL       UART_PROTOCOL2_DataCommunicationSequenceProcess
;;;140    
;;;141    //=========================================================
;;;142    	// 在八方协议中嵌入KM5S协议
;;;143    	UART_PROTOCOL_Process();
000016  e8bd4010          POP      {r4,lr}
00001a  f7ffbffe          B.W      UART_PROTOCOL_Process
;;;144    }
;;;145    
                          ENDP

00001e  0000              DCW      0x0000
                  |L10.32|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOL2_ReadBatteryCapacity||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL2_ReadBatteryCapacity PROC
;;;885    // 读取电池容量
;;;886    void UART_PROTOCOL2_ReadBatteryCapacity(uint8 param)
000000  b510              PUSH     {r4,lr}
;;;887    {
;;;888    	// 设置命令类型
;;;889    	uartProtocolCB2.cmdType = UART_PROTOCOL2_CMD_READ_BATTERY_CAPACITY;
000002  4c0f              LDR      r4,|L11.64|
000004  f2411011          MOV      r0,#0x1111
000008  f8a40178          STRH     r0,[r4,#0x178]
;;;890    
;;;891    	// 设置接收数据长度
;;;892    	uartProtocolCB2.rx.expectLength = 2;
00000c  2002              MOVS     r0,#2
00000e  f8840132          STRB     r0,[r4,#0x132]
;;;893    	
;;;894    	// 读取指令
;;;895    	UART_PROTOCOL2_TxAddData((UART_PROTOCOL2_CMD_READ_BATTERY_CAPACITY&0xFF00)>>8);
000012  2011              MOVS     r0,#0x11
000014  f7fffffe          BL       UART_PROTOCOL2_TxAddData
;;;896    
;;;897    	// 命令为读电池容量
;;;898    	UART_PROTOCOL2_TxAddData(UART_PROTOCOL2_CMD_READ_BATTERY_CAPACITY&0x00FF);
000018  2011              MOVS     r0,#0x11
00001a  f7fffffe          BL       UART_PROTOCOL2_TxAddData
;;;899    
;;;900    	// 组成完整命令帧
;;;901    	UART_PROTOCOL2_TxAddFrame();
00001e  f7fffffe          BL       UART_PROTOCOL2_TxAddFrame
;;;902    
;;;903    
;;;904    	// 清空一级接收队列以及命令帧队列
;;;905    	uartProtocolCB2.rxFIFO.head = uartProtocolCB2.rxFIFO.end;
000022  f8b400ca          LDRH     r0,[r4,#0xca]  ; uartProtocolCB2
000026  f8a400c8          STRH     r0,[r4,#0xc8]
;;;906    	uartProtocolCB2.rx.head = uartProtocolCB2.rx.end;
00002a  f8b40130          LDRH     r0,[r4,#0x130]  ; uartProtocolCB2
00002e  f8a4012e          STRH     r0,[r4,#0x12e]
;;;907    	uartProtocolCB2.rx.cmdQueue[uartProtocolCB2.rx.end].length = 0;
000032  eb041040          ADD      r0,r4,r0,LSL #5
000036  2100              MOVS     r1,#0
000038  f8a010ec          STRH     r1,[r0,#0xec]
;;;908    }
00003c  bd10              POP      {r4,pc}
;;;909    
                          ENDP

00003e  0000              DCW      0x0000
                  |L11.64|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOL2_ReadBatteryInfo1||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL2_ReadBatteryInfo1 PROC
;;;960    // 读取电池信息1
;;;961    void UART_PROTOCOL2_ReadBatteryInfo1(uint8 param)
000000  b510              PUSH     {r4,lr}
;;;962    {
;;;963    	// 设置命令类型
;;;964    	uartProtocolCB2.cmdType = UART_PROTOCOL2_CMD_READ_BATTERY_INFO1;
000002  4c10              LDR      r4,|L12.68|
000004  f44f508b          MOV      r0,#0x1160
000008  f8a40178          STRH     r0,[r4,#0x178]
;;;965    
;;;966    	// 设置接收数据长度
;;;967    	uartProtocolCB2.rx.expectLength = 27;
00000c  201b              MOVS     r0,#0x1b
00000e  f8840132          STRB     r0,[r4,#0x132]
;;;968    	
;;;969    	// 读取指令
;;;970    	UART_PROTOCOL2_TxAddData((UART_PROTOCOL2_CMD_READ_BATTERY_INFO1&0xFF00)>>8);
000012  2011              MOVS     r0,#0x11
000014  f7fffffe          BL       UART_PROTOCOL2_TxAddData
;;;971    
;;;972    	// 命令为读取电池信息1
;;;973    	UART_PROTOCOL2_TxAddData(UART_PROTOCOL2_CMD_READ_BATTERY_INFO1&0x00FF);
000018  2060              MOVS     r0,#0x60
00001a  f7fffffe          BL       UART_PROTOCOL2_TxAddData
;;;974    
;;;975    	// 校验和
;;;976    	UART_PROTOCOL2_TxAddData(((UART_PROTOCOL2_CMD_READ_BATTERY_INFO1&0xFF00)>>8)+(UART_PROTOCOL2_CMD_READ_BATTERY_INFO1&0x00FF));
00001e  2071              MOVS     r0,#0x71
000020  f7fffffe          BL       UART_PROTOCOL2_TxAddData
;;;977    
;;;978    	// 组成完整命令帧
;;;979    	UART_PROTOCOL2_TxAddFrame();
000024  f7fffffe          BL       UART_PROTOCOL2_TxAddFrame
;;;980    
;;;981    
;;;982    	// 清空一级接收队列以及命令帧队列
;;;983    	uartProtocolCB2.rxFIFO.head = uartProtocolCB2.rxFIFO.end;
000028  f8b400ca          LDRH     r0,[r4,#0xca]  ; uartProtocolCB2
00002c  f8a400c8          STRH     r0,[r4,#0xc8]
;;;984    	uartProtocolCB2.rx.head = uartProtocolCB2.rx.end;
000030  f8b40130          LDRH     r0,[r4,#0x130]  ; uartProtocolCB2
000034  f8a4012e          STRH     r0,[r4,#0x12e]
;;;985    	uartProtocolCB2.rx.cmdQueue[uartProtocolCB2.rx.end].length = 0;
000038  eb041040          ADD      r0,r4,r0,LSL #5
00003c  2100              MOVS     r1,#0
00003e  f8a010ec          STRH     r1,[r0,#0xec]
;;;986    }
000042  bd10              POP      {r4,pc}
;;;987    
                          ENDP

                  |L12.68|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOL2_ReadBatteryInfo2||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL2_ReadBatteryInfo2 PROC
;;;988    // 读取电池信息2
;;;989    void UART_PROTOCOL2_ReadBatteryInfo2(uint8 param)
000000  b510              PUSH     {r4,lr}
;;;990    {
;;;991    	// 设置命令类型
;;;992    	uartProtocolCB2.cmdType = UART_PROTOCOL2_CMD_READ_BATTERY_INFO2;
000002  4c10              LDR      r4,|L13.68|
000004  f2411061          MOV      r0,#0x1161
000008  f8a40178          STRH     r0,[r4,#0x178]
;;;993    
;;;994    	// 设置接收数据长度
;;;995    	uartProtocolCB2.rx.expectLength = (13+1)*2;
00000c  201c              MOVS     r0,#0x1c
00000e  f8840132          STRB     r0,[r4,#0x132]
;;;996    	
;;;997    	// 读取指令
;;;998    	UART_PROTOCOL2_TxAddData((UART_PROTOCOL2_CMD_READ_BATTERY_INFO2&0xFF00)>>8);
000012  2011              MOVS     r0,#0x11
000014  f7fffffe          BL       UART_PROTOCOL2_TxAddData
;;;999    
;;;1000   	// 命令为读取电池信息2
;;;1001   	UART_PROTOCOL2_TxAddData(UART_PROTOCOL2_CMD_READ_BATTERY_INFO2&0x00FF);
000018  2061              MOVS     r0,#0x61
00001a  f7fffffe          BL       UART_PROTOCOL2_TxAddData
;;;1002   
;;;1003   	// 校验和
;;;1004   	UART_PROTOCOL2_TxAddData(((UART_PROTOCOL2_CMD_READ_BATTERY_INFO2&0xFF00)>>8)+(UART_PROTOCOL2_CMD_READ_BATTERY_INFO2&0x00FF));
00001e  2072              MOVS     r0,#0x72
000020  f7fffffe          BL       UART_PROTOCOL2_TxAddData
;;;1005   
;;;1006   	// 组成完整命令帧
;;;1007   	UART_PROTOCOL2_TxAddFrame();
000024  f7fffffe          BL       UART_PROTOCOL2_TxAddFrame
;;;1008   
;;;1009   
;;;1010   	// 清空一级接收队列以及命令帧队列
;;;1011   	uartProtocolCB2.rxFIFO.head = uartProtocolCB2.rxFIFO.end;
000028  f8b400ca          LDRH     r0,[r4,#0xca]  ; uartProtocolCB2
00002c  f8a400c8          STRH     r0,[r4,#0xc8]
;;;1012   	uartProtocolCB2.rx.head = uartProtocolCB2.rx.end;
000030  f8b40130          LDRH     r0,[r4,#0x130]  ; uartProtocolCB2
000034  f8a4012e          STRH     r0,[r4,#0x12e]
;;;1013   	uartProtocolCB2.rx.cmdQueue[uartProtocolCB2.rx.end].length = 0;
000038  eb041040          ADD      r0,r4,r0,LSL #5
00003c  2100              MOVS     r1,#0
00003e  f8a010ec          STRH     r1,[r0,#0xec]
;;;1014   }
000042  bd10              POP      {r4,pc}
;;;1015   
                          ENDP

                  |L13.68|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOL2_ReadCadence||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL2_ReadCadence PROC
;;;1072   // 读取踏频
;;;1073   void UART_PROTOCOL2_ReadCadence(uint8 param)
000000  b510              PUSH     {r4,lr}
;;;1074   {
;;;1075   	// 设置命令类型
;;;1076   	uartProtocolCB2.cmdType = UART_PROTOCOL2_CMD_READ_CADENCE;
000002  4c0f              LDR      r4,|L14.64|
000004  f2411021          MOV      r0,#0x1121
000008  f8a40178          STRH     r0,[r4,#0x178]
;;;1077   
;;;1078   	// 设置接收数据长度
;;;1079   	uartProtocolCB2.rx.expectLength = 3;
00000c  2003              MOVS     r0,#3
00000e  f8840132          STRB     r0,[r4,#0x132]
;;;1080   	
;;;1081   	// 读取指令
;;;1082   	UART_PROTOCOL2_TxAddData((UART_PROTOCOL2_CMD_READ_CADENCE&0xFF00)>>8);
000012  2011              MOVS     r0,#0x11
000014  f7fffffe          BL       UART_PROTOCOL2_TxAddData
;;;1083   
;;;1084   	// 命令为读取踏频
;;;1085   	UART_PROTOCOL2_TxAddData(UART_PROTOCOL2_CMD_READ_CADENCE&0x00FF);
000018  2021              MOVS     r0,#0x21
00001a  f7fffffe          BL       UART_PROTOCOL2_TxAddData
;;;1086   
;;;1087   	// 组成完整命令帧
;;;1088   	UART_PROTOCOL2_TxAddFrame();
00001e  f7fffffe          BL       UART_PROTOCOL2_TxAddFrame
;;;1089   
;;;1090   
;;;1091   	// 清空一级接收队列以及命令帧队列
;;;1092   	uartProtocolCB2.rxFIFO.head = uartProtocolCB2.rxFIFO.end;
000022  f8b400ca          LDRH     r0,[r4,#0xca]  ; uartProtocolCB2
000026  f8a400c8          STRH     r0,[r4,#0xc8]
;;;1093   	uartProtocolCB2.rx.head = uartProtocolCB2.rx.end;
00002a  f8b40130          LDRH     r0,[r4,#0x130]  ; uartProtocolCB2
00002e  f8a4012e          STRH     r0,[r4,#0x12e]
;;;1094   	uartProtocolCB2.rx.cmdQueue[uartProtocolCB2.rx.end].length = 0;
000032  eb041040          ADD      r0,r4,r0,LSL #5
000036  2100              MOVS     r1,#0
000038  f8a010ec          STRH     r1,[r0,#0xec]
;;;1095   }
00003c  bd10              POP      {r4,pc}
;;;1096   
                          ENDP

00003e  0000              DCW      0x0000
                  |L14.64|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOL2_ReadDriverErrorCode||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL2_ReadDriverErrorCode PROC
;;;1044   // 读取控制器错误码
;;;1045   void UART_PROTOCOL2_ReadDriverErrorCode(uint8 param)
000000  b510              PUSH     {r4,lr}
;;;1046   {
;;;1047   	// 设置命令类型
;;;1048   	uartProtocolCB2.cmdType = UART_PROTOCOL2_CMD_READ_DRIVER_ERROR_CODE;
000002  4c10              LDR      r4,|L15.68|
000004  f2411023          MOV      r0,#0x1123
000008  f8a40178          STRH     r0,[r4,#0x178]
;;;1049   
;;;1050   	// 设置接收数据长度
;;;1051   	uartProtocolCB2.rx.expectLength = 11;
00000c  200b              MOVS     r0,#0xb
00000e  f8840132          STRB     r0,[r4,#0x132]
;;;1052   	
;;;1053   	// 读取指令
;;;1054   	UART_PROTOCOL2_TxAddData((UART_PROTOCOL2_CMD_READ_DRIVER_ERROR_CODE&0xFF00)>>8);
000012  2011              MOVS     r0,#0x11
000014  f7fffffe          BL       UART_PROTOCOL2_TxAddData
;;;1055   
;;;1056   	// 命令为读取控制器错误码
;;;1057   	UART_PROTOCOL2_TxAddData(UART_PROTOCOL2_CMD_READ_DRIVER_ERROR_CODE&0x00FF);
000018  2023              MOVS     r0,#0x23
00001a  f7fffffe          BL       UART_PROTOCOL2_TxAddData
;;;1058   
;;;1059   	// 校验和
;;;1060   	UART_PROTOCOL2_TxAddData(((UART_PROTOCOL2_CMD_READ_DRIVER_ERROR_CODE&0xFF00)>>8)+(UART_PROTOCOL2_CMD_READ_DRIVER_ERROR_CODE&0x00FF));
00001e  2034              MOVS     r0,#0x34
000020  f7fffffe          BL       UART_PROTOCOL2_TxAddData
;;;1061   
;;;1062   	// 组成完整命令帧
;;;1063   	UART_PROTOCOL2_TxAddFrame();
000024  f7fffffe          BL       UART_PROTOCOL2_TxAddFrame
;;;1064   
;;;1065   
;;;1066   	// 清空一级接收队列以及命令帧队列
;;;1067   	uartProtocolCB2.rxFIFO.head = uartProtocolCB2.rxFIFO.end;
000028  f8b400ca          LDRH     r0,[r4,#0xca]  ; uartProtocolCB2
00002c  f8a400c8          STRH     r0,[r4,#0xc8]
;;;1068   	uartProtocolCB2.rx.head = uartProtocolCB2.rx.end;
000030  f8b40130          LDRH     r0,[r4,#0x130]  ; uartProtocolCB2
000034  f8a4012e          STRH     r0,[r4,#0x12e]
;;;1069   	uartProtocolCB2.rx.cmdQueue[uartProtocolCB2.rx.end].length = 0;
000038  eb041040          ADD      r0,r4,r0,LSL #5
00003c  2100              MOVS     r1,#0
00003e  f8a010ec          STRH     r1,[r0,#0xec]
;;;1070   }
000042  bd10              POP      {r4,pc}
;;;1071   
                          ENDP

                  |L15.68|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOL2_ReadDriverStatus||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL2_ReadDriverStatus PROC
;;;810    // 读取驱动器状态
;;;811    void UART_PROTOCOL2_ReadDriverStatus(uint8 param)
000000  b510              PUSH     {r4,lr}
;;;812    {
;;;813    	// 设置命令类型
;;;814    	uartProtocolCB2.cmdType = UART_PROTOCOL2_CMD_READ_DRIVER_STATUS;
000002  4c0f              LDR      r4,|L16.64|
000004  f2411008          MOV      r0,#0x1108
000008  f8a40178          STRH     r0,[r4,#0x178]
;;;815    
;;;816    	// 设置接收数据长度
;;;817    	uartProtocolCB2.rx.expectLength = 1;
00000c  2001              MOVS     r0,#1
00000e  f8840132          STRB     r0,[r4,#0x132]
;;;818    	
;;;819    	// 读取指令
;;;820    	UART_PROTOCOL2_TxAddData((UART_PROTOCOL2_CMD_READ_DRIVER_STATUS&0xFF00)>>8);
000012  2011              MOVS     r0,#0x11
000014  f7fffffe          BL       UART_PROTOCOL2_TxAddData
;;;821    
;;;822    	// 命令为读驱动器状态
;;;823    	UART_PROTOCOL2_TxAddData(UART_PROTOCOL2_CMD_READ_DRIVER_STATUS&0x00FF);
000018  2008              MOVS     r0,#8
00001a  f7fffffe          BL       UART_PROTOCOL2_TxAddData
;;;824    
;;;825    	// 组成完整命令帧
;;;826    	UART_PROTOCOL2_TxAddFrame();
00001e  f7fffffe          BL       UART_PROTOCOL2_TxAddFrame
;;;827    
;;;828    
;;;829    	// 清空一级接收队列以及命令帧队列
;;;830    	uartProtocolCB2.rxFIFO.head = uartProtocolCB2.rxFIFO.end;
000022  f8b400ca          LDRH     r0,[r4,#0xca]  ; uartProtocolCB2
000026  f8a400c8          STRH     r0,[r4,#0xc8]
;;;831    	uartProtocolCB2.rx.head = uartProtocolCB2.rx.end;
00002a  f8b40130          LDRH     r0,[r4,#0x130]  ; uartProtocolCB2
00002e  f8a4012e          STRH     r0,[r4,#0x12e]
;;;832    	uartProtocolCB2.rx.cmdQueue[uartProtocolCB2.rx.end].length = 0;
000032  eb041040          ADD      r0,r4,r0,LSL #5
000036  2100              MOVS     r1,#0
000038  f8a010ec          STRH     r1,[r0,#0xec]
;;;833    }
00003c  bd10              POP      {r4,pc}
;;;834    
                          ENDP

00003e  0000              DCW      0x0000
                  |L16.64|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOL2_ReadInstantaneousCurrent||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL2_ReadInstantaneousCurrent PROC
;;;860    // 读取瞬时电流
;;;861    void UART_PROTOCOL2_ReadInstantaneousCurrent(uint8 param)
000000  b510              PUSH     {r4,lr}
;;;862    {
;;;863    	// 设置命令类型
;;;864    	uartProtocolCB2.cmdType = UART_PROTOCOL2_CMD_READ_INSTANTANEOUS_CURRENT;
000002  4c0f              LDR      r4,|L17.64|
000004  f241100a          MOV      r0,#0x110a
000008  f8a40178          STRH     r0,[r4,#0x178]
;;;865    
;;;866    	// 设置接收数据长度
;;;867    	uartProtocolCB2.rx.expectLength = 2;
00000c  2002              MOVS     r0,#2
00000e  f8840132          STRB     r0,[r4,#0x132]
;;;868    	
;;;869    	// 读取指令
;;;870    	UART_PROTOCOL2_TxAddData((UART_PROTOCOL2_CMD_READ_INSTANTANEOUS_CURRENT&0xFF00)>>8);
000012  2011              MOVS     r0,#0x11
000014  f7fffffe          BL       UART_PROTOCOL2_TxAddData
;;;871    
;;;872    	// 命令为读瞬时电流
;;;873    	UART_PROTOCOL2_TxAddData(UART_PROTOCOL2_CMD_READ_INSTANTANEOUS_CURRENT&0x00FF);
000018  200a              MOVS     r0,#0xa
00001a  f7fffffe          BL       UART_PROTOCOL2_TxAddData
;;;874    
;;;875    	// 组成完整命令帧
;;;876    	UART_PROTOCOL2_TxAddFrame();
00001e  f7fffffe          BL       UART_PROTOCOL2_TxAddFrame
;;;877    
;;;878    
;;;879    	// 清空一级接收队列以及命令帧队列
;;;880    	uartProtocolCB2.rxFIFO.head = uartProtocolCB2.rxFIFO.end;
000022  f8b400ca          LDRH     r0,[r4,#0xca]  ; uartProtocolCB2
000026  f8a400c8          STRH     r0,[r4,#0xc8]
;;;881    	uartProtocolCB2.rx.head = uartProtocolCB2.rx.end;
00002a  f8b40130          LDRH     r0,[r4,#0x130]  ; uartProtocolCB2
00002e  f8a4012e          STRH     r0,[r4,#0x12e]
;;;882    	uartProtocolCB2.rx.cmdQueue[uartProtocolCB2.rx.end].length = 0;
000032  eb041040          ADD      r0,r4,r0,LSL #5
000036  2100              MOVS     r1,#0
000038  f8a010ec          STRH     r1,[r0,#0xec]
;;;883    }
00003c  bd10              POP      {r4,pc}
;;;884    
                          ENDP

00003e  0000              DCW      0x0000
                  |L17.64|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOL2_ReadLightSwitch||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL2_ReadLightSwitch PROC
;;;935    // 读取大灯值
;;;936    void UART_PROTOCOL2_ReadLightSwitch(uint8 param)
000000  b510              PUSH     {r4,lr}
;;;937    {
;;;938    	// 设置命令类型
;;;939    	uartProtocolCB2.cmdType = UART_PROTOCOL2_CMD_READ_LIGHT_SWITCH;
000002  4c0f              LDR      r4,|L18.64|
000004  f241101b          MOV      r0,#0x111b
000008  f8a40178          STRH     r0,[r4,#0x178]
;;;940    
;;;941    	// 设置接收数据长度
;;;942    	uartProtocolCB2.rx.expectLength = 2;
00000c  2002              MOVS     r0,#2
00000e  f8840132          STRB     r0,[r4,#0x132]
;;;943    	
;;;944    	// 读取指令
;;;945    	UART_PROTOCOL2_TxAddData((UART_PROTOCOL2_CMD_READ_LIGHT_SWITCH&0xFF00)>>8);
000012  2011              MOVS     r0,#0x11
000014  f7fffffe          BL       UART_PROTOCOL2_TxAddData
;;;946    
;;;947    	// 命令为读取大灯值
;;;948    	UART_PROTOCOL2_TxAddData(UART_PROTOCOL2_CMD_READ_LIGHT_SWITCH&0x00FF);
000018  201b              MOVS     r0,#0x1b
00001a  f7fffffe          BL       UART_PROTOCOL2_TxAddData
;;;949    
;;;950    	// 组成完整命令帧
;;;951    	UART_PROTOCOL2_TxAddFrame();
00001e  f7fffffe          BL       UART_PROTOCOL2_TxAddFrame
;;;952    
;;;953    
;;;954    	// 清空一级接收队列以及命令帧队列
;;;955    	uartProtocolCB2.rxFIFO.head = uartProtocolCB2.rxFIFO.end;
000022  f8b400ca          LDRH     r0,[r4,#0xca]  ; uartProtocolCB2
000026  f8a400c8          STRH     r0,[r4,#0xc8]
;;;956    	uartProtocolCB2.rx.head = uartProtocolCB2.rx.end;
00002a  f8b40130          LDRH     r0,[r4,#0x130]  ; uartProtocolCB2
00002e  f8a4012e          STRH     r0,[r4,#0x12e]
;;;957    	uartProtocolCB2.rx.cmdQueue[uartProtocolCB2.rx.end].length = 0;
000032  eb041040          ADD      r0,r4,r0,LSL #5
000036  2100              MOVS     r1,#0
000038  f8a010ec          STRH     r1,[r0,#0xec]
;;;958    }
00003c  bd10              POP      {r4,pc}
;;;959    
                          ENDP

00003e  0000              DCW      0x0000
                  |L18.64|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOL2_ReadProtocolVersion||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL2_ReadProtocolVersion PROC
;;;784    // 读取协议版本
;;;785    void UART_PROTOCOL2_ReadProtocolVersion(uint8 param)
000000  b510              PUSH     {r4,lr}
;;;786    {
;;;787    	// 设置命令类型
;;;788    	uartProtocolCB2.cmdType = UART_PROTOCOL2_CMD_READ_PROTOCOL_VERSION;
000002  4c0f              LDR      r4,|L19.64|
000004  f2411090          MOV      r0,#0x1190
000008  f8a40178          STRH     r0,[r4,#0x178]
;;;789    
;;;790    	// 设置接收数据长度
;;;791    	uartProtocolCB2.rx.expectLength = 3;
00000c  2003              MOVS     r0,#3
00000e  f8840132          STRB     r0,[r4,#0x132]
;;;792    	
;;;793    	// 读取指令
;;;794    	UART_PROTOCOL2_TxAddData((UART_PROTOCOL2_CMD_READ_PROTOCOL_VERSION&0xFF00)>>8);
000012  2011              MOVS     r0,#0x11
000014  f7fffffe          BL       UART_PROTOCOL2_TxAddData
;;;795    
;;;796    	// 命令为读协议版本
;;;797    	UART_PROTOCOL2_TxAddData(UART_PROTOCOL2_CMD_READ_PROTOCOL_VERSION&0x00FF);
000018  2090              MOVS     r0,#0x90
00001a  f7fffffe          BL       UART_PROTOCOL2_TxAddData
;;;798    
;;;799    	// 组成完整命令帧
;;;800    	UART_PROTOCOL2_TxAddFrame();
00001e  f7fffffe          BL       UART_PROTOCOL2_TxAddFrame
;;;801    
;;;802    
;;;803    	// 清空一级接收队列以及命令帧队列
;;;804    	uartProtocolCB2.rxFIFO.head = uartProtocolCB2.rxFIFO.end;
000022  f8b400ca          LDRH     r0,[r4,#0xca]  ; uartProtocolCB2
000026  f8a400c8          STRH     r0,[r4,#0xc8]
;;;805    	uartProtocolCB2.rx.head = uartProtocolCB2.rx.end;
00002a  f8b40130          LDRH     r0,[r4,#0x130]  ; uartProtocolCB2
00002e  f8a4012e          STRH     r0,[r4,#0x12e]
;;;806    	uartProtocolCB2.rx.cmdQueue[uartProtocolCB2.rx.end].length = 0;
000032  eb041040          ADD      r0,r4,r0,LSL #5
000036  2100              MOVS     r1,#0
000038  f8a010ec          STRH     r1,[r0,#0xec]
;;;807    	
;;;808    }
00003c  bd10              POP      {r4,pc}
;;;809    
                          ENDP

00003e  0000              DCW      0x0000
                  |L19.64|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOL2_ReadRPM||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL2_ReadRPM PROC
;;;910    // 读取车轮转速
;;;911    void UART_PROTOCOL2_ReadRPM(uint8 param)
000000  b510              PUSH     {r4,lr}
;;;912    {
;;;913    	// 设置命令类型
;;;914    	uartProtocolCB2.cmdType = UART_PROTOCOL2_CMD_READ_RPM;
000002  4c0f              LDR      r4,|L20.64|
000004  f44f5089          MOV      r0,#0x1120
000008  f8a40178          STRH     r0,[r4,#0x178]
;;;915    
;;;916    	// 设置接收数据长度
;;;917    	uartProtocolCB2.rx.expectLength = 3;
00000c  2003              MOVS     r0,#3
00000e  f8840132          STRB     r0,[r4,#0x132]
;;;918    	
;;;919    	// 读取指令
;;;920    	UART_PROTOCOL2_TxAddData((UART_PROTOCOL2_CMD_READ_RPM&0xFF00)>>8);
000012  2011              MOVS     r0,#0x11
000014  f7fffffe          BL       UART_PROTOCOL2_TxAddData
;;;921    
;;;922    	// 命令为读取车轮转速
;;;923    	UART_PROTOCOL2_TxAddData(UART_PROTOCOL2_CMD_READ_RPM&0x00FF);
000018  2020              MOVS     r0,#0x20
00001a  f7fffffe          BL       UART_PROTOCOL2_TxAddData
;;;924    
;;;925    	// 组成完整命令帧
;;;926    	UART_PROTOCOL2_TxAddFrame();
00001e  f7fffffe          BL       UART_PROTOCOL2_TxAddFrame
;;;927    
;;;928    
;;;929    	// 清空一级接收队列以及命令帧队列
;;;930    	uartProtocolCB2.rxFIFO.head = uartProtocolCB2.rxFIFO.end;
000022  f8b400ca          LDRH     r0,[r4,#0xca]  ; uartProtocolCB2
000026  f8a400c8          STRH     r0,[r4,#0xc8]
;;;931    	uartProtocolCB2.rx.head = uartProtocolCB2.rx.end;
00002a  f8b40130          LDRH     r0,[r4,#0x130]  ; uartProtocolCB2
00002e  f8a4012e          STRH     r0,[r4,#0x12e]
;;;932    	uartProtocolCB2.rx.cmdQueue[uartProtocolCB2.rx.end].length = 0;
000032  eb041040          ADD      r0,r4,r0,LSL #5
000036  2100              MOVS     r1,#0
000038  f8a010ec          STRH     r1,[r0,#0xec]
;;;933    }
00003c  bd10              POP      {r4,pc}
;;;934    
                          ENDP

00003e  0000              DCW      0x0000
                  |L20.64|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOL2_ReadRemainderMileage||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL2_ReadRemainderMileage PROC
;;;1016   // 读取剩余里程
;;;1017   void UART_PROTOCOL2_ReadRemainderMileage(uint8 param)
000000  b510              PUSH     {r4,lr}
;;;1018   {
;;;1019   	// 设置命令类型
;;;1020   	uartProtocolCB2.cmdType = UART_PROTOCOL2_CMD_READ_REMAINDER_MILEAGE;
000002  4c10              LDR      r4,|L21.68|
000004  f2411022          MOV      r0,#0x1122
000008  f8a40178          STRH     r0,[r4,#0x178]
;;;1021   
;;;1022   	// 设置接收数据长度
;;;1023   	uartProtocolCB2.rx.expectLength = 3;
00000c  2003              MOVS     r0,#3
00000e  f8840132          STRB     r0,[r4,#0x132]
;;;1024   	
;;;1025   	// 读取指令
;;;1026   	UART_PROTOCOL2_TxAddData((UART_PROTOCOL2_CMD_READ_REMAINDER_MILEAGE&0xFF00)>>8);
000012  2011              MOVS     r0,#0x11
000014  f7fffffe          BL       UART_PROTOCOL2_TxAddData
;;;1027   
;;;1028   	// 命令为读取剩余里程
;;;1029   	UART_PROTOCOL2_TxAddData(UART_PROTOCOL2_CMD_READ_REMAINDER_MILEAGE&0x00FF);
000018  2022              MOVS     r0,#0x22
00001a  f7fffffe          BL       UART_PROTOCOL2_TxAddData
;;;1030   
;;;1031   	// 校验和
;;;1032   	UART_PROTOCOL2_TxAddData(((UART_PROTOCOL2_CMD_READ_REMAINDER_MILEAGE&0xFF00)>>8)+(UART_PROTOCOL2_CMD_READ_REMAINDER_MILEAGE&0x00FF));
00001e  2033              MOVS     r0,#0x33
000020  f7fffffe          BL       UART_PROTOCOL2_TxAddData
;;;1033   
;;;1034   	// 组成完整命令帧
;;;1035   	UART_PROTOCOL2_TxAddFrame();
000024  f7fffffe          BL       UART_PROTOCOL2_TxAddFrame
;;;1036   
;;;1037   
;;;1038   	// 清空一级接收队列以及命令帧队列
;;;1039   	uartProtocolCB2.rxFIFO.head = uartProtocolCB2.rxFIFO.end;
000028  f8b400ca          LDRH     r0,[r4,#0xca]  ; uartProtocolCB2
00002c  f8a400c8          STRH     r0,[r4,#0xc8]
;;;1040   	uartProtocolCB2.rx.head = uartProtocolCB2.rx.end;
000030  f8b40130          LDRH     r0,[r4,#0x130]  ; uartProtocolCB2
000034  f8a4012e          STRH     r0,[r4,#0x12e]
;;;1041   	uartProtocolCB2.rx.cmdQueue[uartProtocolCB2.rx.end].length = 0;
000038  eb041040          ADD      r0,r4,r0,LSL #5
00003c  2100              MOVS     r1,#0
00003e  f8a010ec          STRH     r1,[r0,#0xec]
;;;1042   }
000042  bd10              POP      {r4,pc}
;;;1043   
                          ENDP

                  |L21.68|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOL2_ReadSysWorkStatus||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL2_ReadSysWorkStatus PROC
;;;835    // 读取系统工作状态
;;;836    void UART_PROTOCOL2_ReadSysWorkStatus(uint8 param)
000000  b510              PUSH     {r4,lr}
;;;837    {
;;;838    	// 设置命令类型
;;;839    	uartProtocolCB2.cmdType = UART_PROTOCOL2_CMD_READ_WORK_STATUS;
000002  4c0f              LDR      r4,|L22.64|
000004  f2411031          MOV      r0,#0x1131
000008  f8a40178          STRH     r0,[r4,#0x178]
;;;840    
;;;841    	// 设置接收数据长度
;;;842    	uartProtocolCB2.rx.expectLength = 2;
00000c  2002              MOVS     r0,#2
00000e  f8840132          STRB     r0,[r4,#0x132]
;;;843    	
;;;844    	// 读取指令
;;;845    	UART_PROTOCOL2_TxAddData((UART_PROTOCOL2_CMD_READ_WORK_STATUS&0xFF00)>>8);
000012  2011              MOVS     r0,#0x11
000014  f7fffffe          BL       UART_PROTOCOL2_TxAddData
;;;846    
;;;847    	// 命令为读系统工作状态
;;;848    	UART_PROTOCOL2_TxAddData(UART_PROTOCOL2_CMD_READ_WORK_STATUS&0x00FF);
000018  2031              MOVS     r0,#0x31
00001a  f7fffffe          BL       UART_PROTOCOL2_TxAddData
;;;849    
;;;850    	// 组成完整命令帧
;;;851    	UART_PROTOCOL2_TxAddFrame();
00001e  f7fffffe          BL       UART_PROTOCOL2_TxAddFrame
;;;852    
;;;853    
;;;854    	// 清空一级接收队列以及命令帧队列
;;;855    	uartProtocolCB2.rxFIFO.head = uartProtocolCB2.rxFIFO.end;
000022  f8b400ca          LDRH     r0,[r4,#0xca]  ; uartProtocolCB2
000026  f8a400c8          STRH     r0,[r4,#0xc8]
;;;856    	uartProtocolCB2.rx.head = uartProtocolCB2.rx.end;
00002a  f8b40130          LDRH     r0,[r4,#0x130]  ; uartProtocolCB2
00002e  f8a4012e          STRH     r0,[r4,#0x12e]
;;;857    	uartProtocolCB2.rx.cmdQueue[uartProtocolCB2.rx.end].length = 0;
000032  eb041040          ADD      r0,r4,r0,LSL #5
000036  2100              MOVS     r1,#0
000038  f8a010ec          STRH     r1,[r0,#0xec]
;;;858    }
00003c  bd10              POP      {r4,pc}
;;;859    
                          ENDP

00003e  0000              DCW      0x0000
                  |L22.64|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOL2_ReadTQKG||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL2_ReadTQKG PROC
;;;1097   // 读取脚踏半圈力矩最大值命令
;;;1098   void UART_PROTOCOL2_ReadTQKG(uint8 param)
000000  b510              PUSH     {r4,lr}
;;;1099   {
;;;1100   	// 设置命令类型
;;;1101   	uartProtocolCB2.cmdType = UART_PROTOCOL2_CMD_READ_TQKG;
000002  4c0f              LDR      r4,|L23.64|
000004  f2411024          MOV      r0,#0x1124
000008  f8a40178          STRH     r0,[r4,#0x178]
;;;1102   
;;;1103   	// 设置接收数据长度
;;;1104   	uartProtocolCB2.rx.expectLength = 2;
00000c  2002              MOVS     r0,#2
00000e  f8840132          STRB     r0,[r4,#0x132]
;;;1105   	
;;;1106   	// 读取指令
;;;1107   	UART_PROTOCOL2_TxAddData((UART_PROTOCOL2_CMD_READ_TQKG&0xFF00)>>8);
000012  2011              MOVS     r0,#0x11
000014  f7fffffe          BL       UART_PROTOCOL2_TxAddData
;;;1108   
;;;1109   	// 命令为读取脚踏半圈力矩最大值命令
;;;1110   	UART_PROTOCOL2_TxAddData(UART_PROTOCOL2_CMD_READ_TQKG&0x00FF);
000018  2024              MOVS     r0,#0x24
00001a  f7fffffe          BL       UART_PROTOCOL2_TxAddData
;;;1111   
;;;1112   	// 组成完整命令帧
;;;1113   	UART_PROTOCOL2_TxAddFrame();
00001e  f7fffffe          BL       UART_PROTOCOL2_TxAddFrame
;;;1114   
;;;1115   
;;;1116   	// 清空一级接收队列以及命令帧队列
;;;1117   	uartProtocolCB2.rxFIFO.head = uartProtocolCB2.rxFIFO.end;
000022  f8b400ca          LDRH     r0,[r4,#0xca]  ; uartProtocolCB2
000026  f8a400c8          STRH     r0,[r4,#0xc8]
;;;1118   	uartProtocolCB2.rx.head = uartProtocolCB2.rx.end;
00002a  f8b40130          LDRH     r0,[r4,#0x130]  ; uartProtocolCB2
00002e  f8a4012e          STRH     r0,[r4,#0x12e]
;;;1119   	uartProtocolCB2.rx.cmdQueue[uartProtocolCB2.rx.end].length = 0;
000032  eb041040          ADD      r0,r4,r0,LSL #5
000036  2100              MOVS     r1,#0
000038  f8a010ec          STRH     r1,[r0,#0xec]
;;;1120   }
00003c  bd10              POP      {r4,pc}
;;;1121   
                          ENDP

00003e  0000              DCW      0x0000
                  |L23.64|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOL2_RegisterDataSendService||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL2_RegisterDataSendService PROC
;;;261    // UART协议层向驱动层注册数据发送接口
;;;262    void UART_PROTOCOL2_RegisterDataSendService(BOOL (*service)(uint16 id, uint8 *pData, uint16 length))
000000  4901              LDR      r1,|L24.8|
;;;263    {		
;;;264    	uartProtocolCB2.sendDataThrowService = service;
000002  f8c10170          STR      r0,[r1,#0x170]  ; uartProtocolCB2
;;;265    }
000006  4770              BX       lr
;;;266    
                          ENDP

                  |L24.8|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOL2_RxFIFOProcess||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL2_RxFIFOProcess PROC
;;;326    // 一级接收缓冲区处理，从一级接收缓冲区中取出一个字节添加到命令帧缓冲区中
;;;327    void UART_PROTOCOL2_RxFIFOProcess(UART_PROTOCOL2_CB* pCB)
000000  b430              PUSH     {r4,r5}
;;;328    {
;;;329    	uint16 end = pCB->rxFIFO.end;
000002  f8b010ca          LDRH     r1,[r0,#0xca]
;;;330    	uint16 head = pCB->rxFIFO.head;
000006  f8b020c8          LDRH     r2,[r0,#0xc8]
;;;331    	UART_PROTOCOL2_RX_CMD_FRAME* pCmdFrame = NULL;
;;;332    	
;;;333    	// 参数合法性检验
;;;334    	if(NULL == pCB)
00000a  2800              CMP      r0,#0
00000c  d032              BEQ      |L25.116|
;;;335    	{
;;;336    		return;
;;;337    	}
;;;338    	
;;;339    	// 一级缓冲区为空，退出
;;;340    	if(head == end)
00000e  428a              CMP      r2,r1
000010  d030              BEQ      |L25.116|
;;;341    	{
;;;342    		return;
;;;343    	}
;;;344    
;;;345    	// 无临时缓冲区可用，退出
;;;346    	if((pCB->rx.end + 1)%UART_PROTOCOL2_RX_QUEUE_SIZE == pCB->rx.head)
000012  f8b01130          LDRH     r1,[r0,#0x130]
000016  2303              MOVS     r3,#3
000018  460c              MOV      r4,r1
00001a  1c49              ADDS     r1,r1,#1
00001c  fbb1f5f3          UDIV     r5,r1,r3
000020  fb031115          MLS      r1,r3,r5,r1
000024  f8b0312e          LDRH     r3,[r0,#0x12e]
000028  4299              CMP      r1,r3
00002a  d023              BEQ      |L25.116|
;;;347    	{
;;;348    		return;
;;;349    	}
;;;350    	
;;;351    	pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.end];
00002c  eb001144          ADD      r1,r0,r4,LSL #5
000030  31ce              ADDS     r1,r1,#0xce
;;;352    
;;;353    	// 将数据添加到临时缓冲区中
;;;354    	pCmdFrame->buff[pCmdFrame->length++] = pCB->rxFIFO.buff[head];
000032  5c84              LDRB     r4,[r0,r2]
000034  8bca              LDRH     r2,[r1,#0x1e]
000036  1c53              ADDS     r3,r2,#1
000038  440a              ADD      r2,r2,r1
00003a  83cb              STRH     r3,[r1,#0x1e]
00003c  7094              STRB     r4,[r2,#2]
;;;355    
;;;356    	// 正在接收数据
;;;357    	uartProtocolCB2.rxFIFO.rxFIFOBusy = TRUE;
00003e  4c0e              LDR      r4,|L25.120|
000040  2201              MOVS     r2,#1
000042  f88420cc          STRB     r2,[r4,#0xcc]
;;;358    
;;;359    	// 添加成功，从一级缓冲区中删除当前数据
;;;360    	pCB->rxFIFO.head ++;
000046  f8302fc8          LDRH     r2,[r0,#0xc8]!
00004a  1c52              ADDS     r2,r2,#1
00004c  8002              STRH     r2,[r0,#0]
;;;361    	pCB->rxFIFO.head %= UART_PROTOCOL2_RX_FIFO_SIZE;
00004e  8802              LDRH     r2,[r0,#0]
000050  23c8              MOVS     r3,#0xc8
000052  fbb2f5f3          UDIV     r5,r2,r3
000056  fb032215          MLS      r2,r3,r5,r2
00005a  8002              STRH     r2,[r0,#0]
;;;362    
;;;363    	// 接收到的数据是否达到了期望长度
;;;364    	if(pCmdFrame->length < pCB->rx.expectLength)
00005c  8bc9              LDRH     r1,[r1,#0x1e]
00005e  f890206a          LDRB     r2,[r0,#0x6a]
000062  38c8              SUBS     r0,r0,#0xc8
000064  4291              CMP      r1,r2
000066  d305              BCC      |L25.116|
;;;365    	{
;;;366    		return;
;;;367    	}
;;;368    
;;;369    	// 数据已经接收完毕
;;;370    	uartProtocolCB2.rxFIFO.rxFIFOBusy = FALSE;
000068  2100              MOVS     r1,#0
00006a  f88410cc          STRB     r1,[r4,#0xcc]
;;;371    
;;;372    	// 数据长度已经满足，说明接收到了一个完整并且正确的命令帧，此时需要将其扶正
;;;373    	UART_PROTOCOL2_ConfirmTempCmdFrameBuff(pCB);
00006e  bc30              POP      {r4,r5}
000070  f7ffbffe          B.W      UART_PROTOCOL2_ConfirmTempCmdFrameBuff
                  |L25.116|
;;;374    }
000074  bc30              POP      {r4,r5}
000076  4770              BX       lr
;;;375    
                          ENDP

                  |L25.120|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOL2_SetTxAtOnceCmdType||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL2_SetTxAtOnceCmdType PROC
;;;641    // 码表设置立刻下发命令类型
;;;642    void UART_PROTOCOL2_SetTxAtOnceCmdType(UART_PROTOCOL2_TX_AT_ONCE_CMD_TYPE type)
000000  4901              LDR      r1,|L26.8|
;;;643    {
;;;644    	uartProtocolCB2.txAtOnceCmdType = type;
000002  f8810176          STRB     r0,[r1,#0x176]
;;;645    }
000006  4770              BX       lr
;;;646    
                          ENDP

                  |L26.8|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOL2_SetTxAtOnceRequest||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL2_SetTxAtOnceRequest PROC
;;;635    // 码表设置立刻下发数据请求标志
;;;636    void UART_PROTOCOL2_SetTxAtOnceRequest(uint32 param)
000000  4901              LDR      r1,|L27.8|
;;;637    {
;;;638    	uartProtocolCB2.txAtOnceRequest = (BOOL)param;
000002  f8810175          STRB     r0,[r1,#0x175]
;;;639    }
000006  4770              BX       lr
;;;640    
                          ENDP

                  |L27.8|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOL2_StartTimeoutCheckTask||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL2_StartTimeoutCheckTask PROC
;;;78     // 启动通讯超时判断任务
;;;79     void UART_PROTOCOL2_StartTimeoutCheckTask(void)
000000  4804              LDR      r0,|L28.20|
;;;80     {
;;;81     	// 清除通讯异常
;;;82     	if(ERROR_TYPE_COMMUNICATION_TIME_OUT == PARAM_GetErrorCode())
000002  f8901221          LDRB     r1,[r0,#0x221]  ; paramCB
000006  2930              CMP      r1,#0x30
000008  d102              BNE      |L28.16|
;;;83     	{
;;;84     		PARAM_SetErrorCode(ERROR_TYPE_NO_ERROR);
00000a  2100              MOVS     r1,#0
00000c  f8801221          STRB     r1,[r0,#0x221]
                  |L28.16|
;;;85     	}
;;;86     
;;;87     	// 开启UART通讯超时定时器
;;;88     #if __SYSTEM_NO_TIME_OUT_ERROR__		// 研发调试时不启用
;;;89     #else
;;;90     //	TIMER_AddTask(TIMER_ID_UART_TXRX_TIME_OUT,
;;;91     //					PARAM_GetBusAliveTime(),
;;;92     //					UART_PROTOCOL2_CALLBACK_UartBusError,
;;;93     //					TRUE,
;;;94     //					1,
;;;95     //					ACTION_MODE_ADD_TO_QUEUE);
;;;96     #endif
;;;97     }
000010  4770              BX       lr
;;;98     
                          ENDP

000012  0000              DCW      0x0000
                  |L28.20|
                          DCD      paramCB

                          AREA ||i.UART_PROTOCOL2_TxAddData||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL2_TxAddData PROC
;;;146    // 向发送命令帧队列中添加数据
;;;147    void UART_PROTOCOL2_TxAddData(uint8 data)
000000  b530              PUSH     {r4,r5,lr}
;;;148    {
;;;149    	uint16 head = uartProtocolCB2.tx.head;
000002  490e              LDR      r1,|L29.60|
000004  f8b14166          LDRH     r4,[r1,#0x166]  ; uartProtocolCB2
;;;150    	uint16 end =  uartProtocolCB2.tx.end;
000008  f8b12168          LDRH     r2,[r1,#0x168]  ; uartProtocolCB2
;;;151    	UART_PROTOCOL2_TX_CMD_FRAME* pCmdFrame = &uartProtocolCB2.tx.cmdQueue[uartProtocolCB2.tx.end];
00000c  eb020382          ADD      r3,r2,r2,LSL #2
000010  eb010143          ADD      r1,r1,r3,LSL #1
000014  f501719a          ADD      r1,r1,#0x134
;;;152    
;;;153    	// 发送缓冲区已满，不予接收
;;;154    	if((end + 1) % UART_PROTOCOL2_TX_QUEUE_SIZE == head)
000018  1c52              ADDS     r2,r2,#1
00001a  2305              MOVS     r3,#5
00001c  fbb2f5f3          UDIV     r5,r2,r3
000020  fb032215          MLS      r2,r3,r5,r2
000024  42a2              CMP      r2,r4
000026  d007              BEQ      |L29.56|
;;;155    	{
;;;156    		return;
;;;157    	}
;;;158    	
;;;159    	// 队尾命令帧已满，退出
;;;160    	if(pCmdFrame->length >= UART_PROTOCOL2_TX_CMD_FRAME_LENGTH_MAX)
000028  890a              LDRH     r2,[r1,#8]
00002a  2a05              CMP      r2,#5
00002c  d204              BCS      |L29.56|
;;;161    	{
;;;162    		return;
;;;163    	}
;;;164    
;;;165    	// 数据添加到帧末尾，并更新帧长度
;;;166    	pCmdFrame->buff[pCmdFrame->length] = data;
00002e  1c8b              ADDS     r3,r1,#2
000030  54d0              STRB     r0,[r2,r3]
;;;167    	pCmdFrame->length ++;
000032  8908              LDRH     r0,[r1,#8]
000034  1c40              ADDS     r0,r0,#1
000036  8108              STRH     r0,[r1,#8]
                  |L29.56|
;;;168    }
000038  bd30              POP      {r4,r5,pc}
;;;169    
                          ENDP

00003a  0000              DCW      0x0000
                  |L29.60|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOL2_TxAddFrame||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL2_TxAddFrame PROC
;;;170    // 确认添加命令帧，即承认之前填充的数据为命令帧，将其添加到发送队列中，由main进行调度发送，本函数内会自动校正命令长度，并添加校验码
;;;171    void UART_PROTOCOL2_TxAddFrame(void)
000000  b570              PUSH     {r4-r6,lr}
;;;172    {
;;;173    	uint16 head = uartProtocolCB2.tx.head;
000002  4c11              LDR      r4,|L30.72|
000004  f8b45166          LDRH     r5,[r4,#0x166]  ; uartProtocolCB2
;;;174    	uint16 end  = uartProtocolCB2.tx.end;
000008  f8b40168          LDRH     r0,[r4,#0x168]  ; uartProtocolCB2
;;;175    	UART_PROTOCOL2_TX_CMD_FRAME* pCmdFrame = &uartProtocolCB2.tx.cmdQueue[uartProtocolCB2.tx.end];
00000c  eb000180          ADD      r1,r0,r0,LSL #2
000010  eb040141          ADD      r1,r4,r1,LSL #1
000014  f501719a          ADD      r1,r1,#0x134
;;;176    	uint16 length = pCmdFrame->length;
000018  890a              LDRH     r2,[r1,#8]
;;;177    
;;;178    	// 发送缓冲区已满，不予接收
;;;179    	if((end + 1) % UART_PROTOCOL2_TX_QUEUE_SIZE == head)
00001a  1c40              ADDS     r0,r0,#1
00001c  2305              MOVS     r3,#5
00001e  fbb0f6f3          UDIV     r6,r0,r3
000022  fb030616          MLS      r6,r3,r6,r0
000026  42ae              CMP      r6,r5
000028  d003              BEQ      |L30.50|
;;;180    	{
;;;181    		return;
;;;182    	}
;;;183    	
;;;184    	// 命令帧长度不足，清除已填充的数据，退出
;;;185    	if(length < UART_PROTOCOL2_TX_CMD_FRAME_LENGTH_MIN)
00002a  2a02              CMP      r2,#2
00002c  d202              BCS      |L30.52|
;;;186    	{
;;;187    		pCmdFrame->length = 0;
00002e  2000              MOVS     r0,#0
000030  8108              STRH     r0,[r1,#8]
                  |L30.50|
;;;188    		
;;;189    		return;
;;;190    	}
;;;191    	// 队尾命令帧已满，退出
;;;192    	if(length > UART_PROTOCOL2_TX_CMD_FRAME_LENGTH_MAX)
;;;193    	{
;;;194    		return;
;;;195    	}
;;;196    	
;;;197    	uartProtocolCB2.tx.end ++;
;;;198    	uartProtocolCB2.tx.end %= UART_PROTOCOL2_TX_QUEUE_SIZE;
;;;199    }
000032  bd70              POP      {r4-r6,pc}
                  |L30.52|
000034  2a05              CMP      r2,#5                 ;192
000036  d8fc              BHI      |L30.50|
000038  b280              UXTH     r0,r0                 ;197
00003a  fbb0f1f3          UDIV     r1,r0,r3              ;198
00003e  fb030011          MLS      r0,r3,r1,r0           ;198
000042  f8a40168          STRH     r0,[r4,#0x168]        ;198
000046  bd70              POP      {r4-r6,pc}
;;;200    
                          ENDP

                  |L30.72|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOL2_TxStateProcess||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL2_TxStateProcess PROC
;;;293    // 协议层发送处理过程
;;;294    void UART_PROTOCOL2_TxStateProcess(void)
000000  b570              PUSH     {r4-r6,lr}
;;;295    {
;;;296    	uint16 head = uartProtocolCB2.tx.head;
000002  4c14              LDR      r4,|L31.84|
000004  f8b43166          LDRH     r3,[r4,#0x166]  ; uartProtocolCB2
;;;297    	uint16 end =  uartProtocolCB2.tx.end;
000008  f8b46168          LDRH     r6,[r4,#0x168]  ; uartProtocolCB2
;;;298    	uint16 length = uartProtocolCB2.tx.cmdQueue[head].length;
00000c  eb030083          ADD      r0,r3,r3,LSL #2
000010  eb040040          ADD      r0,r4,r0,LSL #1
000014  4605              MOV      r5,r0
000016  f8b0213c          LDRH     r2,[r0,#0x13c]
;;;299    	uint8* pCmd = uartProtocolCB2.tx.cmdQueue[head].buff;
00001a  f500719b          ADD      r1,r0,#0x136
;;;300    	uint16 localDeviceID = uartProtocolCB2.tx.cmdQueue[head].deviceID;
00001e  f8b00134          LDRH     r0,[r0,#0x134]
;;;301    
;;;302    	// 发送缓冲区为空，说明无数据
;;;303    	if (head == end)
000022  42b3              CMP      r3,r6
000024  d014              BEQ      |L31.80|
;;;304    	{
;;;305    		return;
;;;306    	}
;;;307    
;;;308    	// 发送函数没有注册直接返回
;;;309    	if (NULL == uartProtocolCB2.sendDataThrowService)
000026  f8d43170          LDR      r3,[r4,#0x170]  ; uartProtocolCB2
00002a  2b00              CMP      r3,#0
00002c  d010              BEQ      |L31.80|
;;;310    	{
;;;311    		return;
;;;312    	}
;;;313    
;;;314    	// 协议层有数据需要发送到驱动层		
;;;315    	if (!(*uartProtocolCB2.sendDataThrowService)(localDeviceID, pCmd, length))
00002e  4798              BLX      r3
000030  2800              CMP      r0,#0
000032  d00d              BEQ      |L31.80|
;;;316    	{
;;;317    		return;
;;;318    	}
;;;319    
;;;320    	// 发送环形队列更新位置
;;;321    	uartProtocolCB2.tx.cmdQueue[head].length = 0;
000034  2000              MOVS     r0,#0
000036  f8a5013c          STRH     r0,[r5,#0x13c]
;;;322    	uartProtocolCB2.tx.head ++;
00003a  f8b40166          LDRH     r0,[r4,#0x166]  ; uartProtocolCB2
00003e  1c40              ADDS     r0,r0,#1
000040  b280              UXTH     r0,r0
;;;323    	uartProtocolCB2.tx.head %= UART_PROTOCOL2_TX_QUEUE_SIZE;
000042  2105              MOVS     r1,#5
000044  fbb0f2f1          UDIV     r2,r0,r1
000048  fb010012          MLS      r0,r1,r2,r0
00004c  f8a40166          STRH     r0,[r4,#0x166]
                  |L31.80|
;;;324    }
000050  bd70              POP      {r4-r6,pc}
;;;325    
                          ENDP

000052  0000              DCW      0x0000
                  |L31.84|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOL2_WriteAssistLevel||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL2_WriteAssistLevel PROC
;;;1160   // 写档位
;;;1161   void UART_PROTOCOL2_WriteAssistLevel(uint8 maxAssistLevel, uint8 assistLevel)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1162   {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
;;;1163   	uint8 assistCode;
;;;1164   	uint8 checkVal;
;;;1165   	
;;;1166   	// 设置命令类型
;;;1167   	uartProtocolCB2.cmdType = UART_PROTOCOL2_CMD_WRITE_ASSIST_LEVEL;
000008  4e3e              LDR      r6,|L32.260|
00000a  f241610b          MOV      r1,#0x160b
00000e  f8a61178          STRH     r1,[r6,#0x178]
;;;1168   	// 设置接收数据长度
;;;1169   	uartProtocolCB2.rx.expectLength = 0;
000012  f04f0800          MOV      r8,#0
000016  f8868132          STRB     r8,[r6,#0x132]
;;;1170   	
;;;1171   	// 写指令
;;;1172   	UART_PROTOCOL2_TxAddData((UART_PROTOCOL2_CMD_WRITE_ASSIST_LEVEL&0xFF00)>>8);
00001a  2016              MOVS     r0,#0x16
00001c  f7fffffe          BL       UART_PROTOCOL2_TxAddData
;;;1173   
;;;1174   	// 命令为写档位
;;;1175   	UART_PROTOCOL2_TxAddData(UART_PROTOCOL2_CMD_WRITE_ASSIST_LEVEL&0x00FF);
000020  200b              MOVS     r0,#0xb
000022  f7fffffe          BL       UART_PROTOCOL2_TxAddData
;;;1176   
;;;1177   	switch (maxAssistLevel)
000026  2d03              CMP      r5,#3
000028  d004              BEQ      |L32.52|
00002a  2d05              CMP      r5,#5
00002c  d018              BEQ      |L32.96|
00002e  2d09              CMP      r5,#9
000030  d151              BNE      |L32.214|
000032  e02f              B        |L32.148|
                  |L32.52|
;;;1178   	{
;;;1179   		case 3:
;;;1180   			switch (assistLevel)
000034  2f0c              CMP      r7,#0xc
000036  d24e              BCS      |L32.214|
000038  e8dff007          TBB      [pc,r7]
00003c  06080a0c          DCB      0x06,0x08,0x0a,0x0c
000040  4d4d4d4d          DCB      0x4d,0x4d,0x4d,0x4d
000044  4d4d0e10          DCB      0x4d,0x4d,0x0e,0x10
;;;1181   			{
;;;1182   				case ASSIST_0:
;;;1183   					assistCode = 0;
000048  2400              MOVS     r4,#0
;;;1184   					break;
00004a  e044              B        |L32.214|
;;;1185   
;;;1186   				case ASSIST_1:
;;;1187   					assistCode = 12;
00004c  240c              MOVS     r4,#0xc
;;;1188   					break;
00004e  e042              B        |L32.214|
;;;1189   
;;;1190   				case ASSIST_2:
;;;1191   					assistCode = 2;
000050  2402              MOVS     r4,#2
;;;1192   					break;
000052  e040              B        |L32.214|
;;;1193   
;;;1194   				case ASSIST_3:
;;;1195   					assistCode = 3;
000054  2403              MOVS     r4,#3
;;;1196   					break;
000056  e03e              B        |L32.214|
;;;1197   
;;;1198   				// 推车
;;;1199   				case ASSIST_P:
;;;1200   					assistCode = 6;
000058  2406              MOVS     r4,#6
;;;1201   					break;
00005a  e03c              B        |L32.214|
;;;1202   
;;;1203   				// 限速
;;;1204   				case ASSIST_S:
;;;1205   					assistCode = 10;
00005c  240a              MOVS     r4,#0xa
;;;1206   					break;
00005e  e03a              B        |L32.214|
                  |L32.96|
;;;1207   			}
;;;1208   			break;
;;;1209   
;;;1210   		case 5:
;;;1211   			switch (assistLevel)
000060  2f0c              CMP      r7,#0xc
000062  d238              BCS      |L32.214|
000064  e8dff007          TBB      [pc,r7]
000068  06080a0c          DCB      0x06,0x08,0x0a,0x0c
00006c  0e103737          DCB      0x0e,0x10,0x37,0x37
000070  37371214          DCB      0x37,0x37,0x12,0x14
;;;1212   			{
;;;1213   				case ASSIST_0:
;;;1214   					assistCode = 0;
000074  2400              MOVS     r4,#0
;;;1215   					break;
000076  e02e              B        |L32.214|
;;;1216   
;;;1217   				case ASSIST_1:
;;;1218   					assistCode = 11;
000078  240b              MOVS     r4,#0xb
;;;1219   					break;
00007a  e02c              B        |L32.214|
;;;1220   
;;;1221   				case ASSIST_2:
;;;1222   					assistCode = 13;
00007c  240d              MOVS     r4,#0xd
;;;1223   					break;
00007e  e02a              B        |L32.214|
;;;1224   
;;;1225   				case ASSIST_3:
;;;1226   					assistCode = 21;
000080  2415              MOVS     r4,#0x15
;;;1227   					break;
000082  e028              B        |L32.214|
;;;1228   
;;;1229   				case ASSIST_4:
;;;1230   					assistCode = 23;
000084  2417              MOVS     r4,#0x17
;;;1231   					break;
000086  e026              B        |L32.214|
;;;1232   
;;;1233   				case ASSIST_5:
;;;1234   					assistCode = 3;
000088  2403              MOVS     r4,#3
;;;1235   					break;
00008a  e024              B        |L32.214|
;;;1236   
;;;1237   				// 推车
;;;1238   				case ASSIST_P:
;;;1239   					assistCode = 6;
00008c  2406              MOVS     r4,#6
;;;1240   					break;
00008e  e022              B        |L32.214|
;;;1241   
;;;1242   				// 限速
;;;1243   				case ASSIST_S:
;;;1244   					assistCode = 10;
000090  240a              MOVS     r4,#0xa
;;;1245   					break;
000092  e020              B        |L32.214|
                  |L32.148|
;;;1246   			}
;;;1247   			break;
;;;1248   
;;;1249   		case 9:
;;;1250   			switch (assistLevel)
000094  2f0c              CMP      r7,#0xc
000096  d21e              BCS      |L32.214|
000098  e8dff007          TBB      [pc,r7]
00009c  06080a0c          DCB      0x06,0x08,0x0a,0x0c
0000a0  0e101214          DCB      0x0e,0x10,0x12,0x14
0000a4  16181a1c          DCB      0x16,0x18,0x1a,0x1c
;;;1251   			{
;;;1252   				case ASSIST_0:
;;;1253   					assistCode = 0;
0000a8  2400              MOVS     r4,#0
;;;1254   					break;
0000aa  e014              B        |L32.214|
;;;1255   
;;;1256   				case ASSIST_1:
;;;1257   					assistCode = 1;
0000ac  2401              MOVS     r4,#1
;;;1258   					break;
0000ae  e012              B        |L32.214|
;;;1259   
;;;1260   				case ASSIST_2:
;;;1261   					assistCode = 11;
0000b0  240b              MOVS     r4,#0xb
;;;1262   					break;
0000b2  e010              B        |L32.214|
;;;1263   
;;;1264   				case ASSIST_3:
;;;1265   					assistCode = 12;
0000b4  240c              MOVS     r4,#0xc
;;;1266   					break;
0000b6  e00e              B        |L32.214|
;;;1267   
;;;1268   				case ASSIST_4:
;;;1269   					assistCode = 13;
0000b8  240d              MOVS     r4,#0xd
;;;1270   					break;
0000ba  e00c              B        |L32.214|
;;;1271   
;;;1272   				case ASSIST_5:
;;;1273   					assistCode = 2;
0000bc  2402              MOVS     r4,#2
;;;1274   					break;
0000be  e00a              B        |L32.214|
;;;1275   
;;;1276   				case ASSIST_6:
;;;1277   					assistCode = 21;
0000c0  2415              MOVS     r4,#0x15
;;;1278   					break;
0000c2  e008              B        |L32.214|
;;;1279   
;;;1280   				case ASSIST_7:
;;;1281   					assistCode = 22;
0000c4  2416              MOVS     r4,#0x16
;;;1282   					break;
0000c6  e006              B        |L32.214|
;;;1283   
;;;1284   				case ASSIST_8:
;;;1285   					assistCode = 23;
0000c8  2417              MOVS     r4,#0x17
;;;1286   					break;
0000ca  e004              B        |L32.214|
;;;1287   
;;;1288   				case ASSIST_9:
;;;1289   					assistCode = 3;
0000cc  2403              MOVS     r4,#3
;;;1290   					break;
0000ce  e002              B        |L32.214|
;;;1291   
;;;1292   				// 推车
;;;1293   				case ASSIST_P:
;;;1294   					assistCode = 6;
0000d0  2406              MOVS     r4,#6
;;;1295   					break;
0000d2  e000              B        |L32.214|
;;;1296   
;;;1297   				// 限速
;;;1298   				case ASSIST_S:
;;;1299   					assistCode = 10;
0000d4  240a              MOVS     r4,#0xa
                  |L32.214|
;;;1300   					break;
;;;1301   			}
;;;1302   			break;
;;;1303   	}
;;;1304   	UART_PROTOCOL2_TxAddData(assistCode);
0000d6  4620              MOV      r0,r4
0000d8  f7fffffe          BL       UART_PROTOCOL2_TxAddData
;;;1305   
;;;1306   	checkVal = ((UART_PROTOCOL2_CMD_WRITE_ASSIST_LEVEL&0xFF00)>>8) + (UART_PROTOCOL2_CMD_WRITE_ASSIST_LEVEL&0x00FF) + assistCode; 
0000dc  3421              ADDS     r4,r4,#0x21
0000de  b2e0              UXTB     r0,r4
;;;1307   	
;;;1308   	// 校验和
;;;1309   	UART_PROTOCOL2_TxAddData(checkVal);
0000e0  f7fffffe          BL       UART_PROTOCOL2_TxAddData
;;;1310   
;;;1311   	// 组成完整命令帧
;;;1312   	UART_PROTOCOL2_TxAddFrame();
0000e4  f7fffffe          BL       UART_PROTOCOL2_TxAddFrame
;;;1313   
;;;1314   
;;;1315   	// 清空一级接收队列以及命令帧队列
;;;1316   	uartProtocolCB2.rxFIFO.head = uartProtocolCB2.rxFIFO.end;
0000e8  f8b600ca          LDRH     r0,[r6,#0xca]  ; uartProtocolCB2
0000ec  f8a600c8          STRH     r0,[r6,#0xc8]
;;;1317   	uartProtocolCB2.rx.head = uartProtocolCB2.rx.end;
0000f0  f8b60130          LDRH     r0,[r6,#0x130]  ; uartProtocolCB2
0000f4  f8a6012e          STRH     r0,[r6,#0x12e]
;;;1318   	uartProtocolCB2.rx.cmdQueue[uartProtocolCB2.rx.end].length = 0;
0000f8  eb061040          ADD      r0,r6,r0,LSL #5
0000fc  f8a080ec          STRH     r8,[r0,#0xec]
;;;1319   }
000100  e8bd81f0          POP      {r4-r8,pc}
;;;1320   
                          ENDP

                  |L32.260|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOL2_WriteClearDriverErrorCode||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL2_WriteClearDriverErrorCode PROC
;;;1354   // 写清除控制器错误码
;;;1355   void UART_PROTOCOL2_WriteClearDriverErrorCode(uint8 param)
000000  b510              PUSH     {r4,lr}
;;;1356   {
;;;1357   	// 设置命令类型
;;;1358   	uartProtocolCB2.cmdType = UART_PROTOCOL2_CMD_WRITE_CLEAR_DRIVER_ERROR_CODE;
000002  4c10              LDR      r4,|L33.68|
000004  f2416023          MOV      r0,#0x1623
000008  f8a40178          STRH     r0,[r4,#0x178]
;;;1359   
;;;1360   	// 设置接收数据长度
;;;1361   	uartProtocolCB2.rx.expectLength = 2;
00000c  2002              MOVS     r0,#2
00000e  f8840132          STRB     r0,[r4,#0x132]
;;;1362   	
;;;1363   	
;;;1364   	// 写指令
;;;1365   	UART_PROTOCOL2_TxAddData((UART_PROTOCOL2_CMD_WRITE_CLEAR_DRIVER_ERROR_CODE&0xFF00)>>8);
000012  2016              MOVS     r0,#0x16
000014  f7fffffe          BL       UART_PROTOCOL2_TxAddData
;;;1366   
;;;1367   	// 命令为写清除控制器错误码
;;;1368   	UART_PROTOCOL2_TxAddData(UART_PROTOCOL2_CMD_WRITE_CLEAR_DRIVER_ERROR_CODE&0x00FF);
000018  2023              MOVS     r0,#0x23
00001a  f7fffffe          BL       UART_PROTOCOL2_TxAddData
;;;1369   
;;;1370   	// 校验和
;;;1371   	UART_PROTOCOL2_TxAddData(((UART_PROTOCOL2_CMD_WRITE_CLEAR_DRIVER_ERROR_CODE&0xFF00)>>8) + (UART_PROTOCOL2_CMD_WRITE_CLEAR_DRIVER_ERROR_CODE&0x00FF));
00001e  2039              MOVS     r0,#0x39
000020  f7fffffe          BL       UART_PROTOCOL2_TxAddData
;;;1372   
;;;1373   	// 组成完整命令帧
;;;1374   	UART_PROTOCOL2_TxAddFrame();
000024  f7fffffe          BL       UART_PROTOCOL2_TxAddFrame
;;;1375   
;;;1376   
;;;1377   	// 清空一级接收队列以及命令帧队列
;;;1378   	uartProtocolCB2.rxFIFO.head = uartProtocolCB2.rxFIFO.end;
000028  f8b400ca          LDRH     r0,[r4,#0xca]  ; uartProtocolCB2
00002c  f8a400c8          STRH     r0,[r4,#0xc8]
;;;1379   	uartProtocolCB2.rx.head = uartProtocolCB2.rx.end;
000030  f8b40130          LDRH     r0,[r4,#0x130]  ; uartProtocolCB2
000034  f8a4012e          STRH     r0,[r4,#0x12e]
;;;1380   	uartProtocolCB2.rx.cmdQueue[uartProtocolCB2.rx.end].length = 0;
000038  eb041040          ADD      r0,r4,r0,LSL #5
00003c  2100              MOVS     r1,#0
00003e  f8a010ec          STRH     r1,[r0,#0xec]
;;;1381   }
000042  bd10              POP      {r4,pc}
;;;1382   
                          ENDP

                  |L33.68|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOL2_WriteLightSwitch||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL2_WriteLightSwitch PROC
;;;1321   // 写大灯
;;;1322   void UART_PROTOCOL2_WriteLightSwitch(uint8 param)
000000  b570              PUSH     {r4-r6,lr}
;;;1323   {
000002  4606              MOV      r6,r0
;;;1324   	// 设置命令类型
;;;1325   	uartProtocolCB2.cmdType = UART_PROTOCOL2_CMD_WRITE_LIGHT_SWITCH;
000004  4c12              LDR      r4,|L34.80|
000006  f241611a          MOV      r1,#0x161a
00000a  f8a41178          STRH     r1,[r4,#0x178]
;;;1326   	// 设置接收数据长度
;;;1327   	uartProtocolCB2.rx.expectLength = 0;
00000e  2500              MOVS     r5,#0
000010  f8845132          STRB     r5,[r4,#0x132]
;;;1328   	
;;;1329   	// 写指令
;;;1330   	UART_PROTOCOL2_TxAddData((UART_PROTOCOL2_CMD_WRITE_LIGHT_SWITCH&0xFF00)>>8);
000014  2016              MOVS     r0,#0x16
000016  f7fffffe          BL       UART_PROTOCOL2_TxAddData
;;;1331   
;;;1332   	// 命令为写大灯
;;;1333   	UART_PROTOCOL2_TxAddData(UART_PROTOCOL2_CMD_WRITE_LIGHT_SWITCH&0x00FF);
00001a  201a              MOVS     r0,#0x1a
00001c  f7fffffe          BL       UART_PROTOCOL2_TxAddData
;;;1334   
;;;1335   	if (param)
000020  b11e              CBZ      r6,|L34.42|
;;;1336   	{
;;;1337   		UART_PROTOCOL2_TxAddData(0xF1);	// 开大灯
000022  20f1              MOVS     r0,#0xf1
000024  f7fffffe          BL       UART_PROTOCOL2_TxAddData
000028  e002              B        |L34.48|
                  |L34.42|
;;;1338   	}
;;;1339   	else
;;;1340   	{
;;;1341   		UART_PROTOCOL2_TxAddData(0xF0);	// 关大灯
00002a  20f0              MOVS     r0,#0xf0
00002c  f7fffffe          BL       UART_PROTOCOL2_TxAddData
                  |L34.48|
;;;1342   	}
;;;1343   
;;;1344   	// 组成完整命令帧
;;;1345   	UART_PROTOCOL2_TxAddFrame();
000030  f7fffffe          BL       UART_PROTOCOL2_TxAddFrame
;;;1346   
;;;1347   
;;;1348   	// 清空一级接收队列以及命令帧队列
;;;1349   	uartProtocolCB2.rxFIFO.head = uartProtocolCB2.rxFIFO.end;
000034  f8b400ca          LDRH     r0,[r4,#0xca]  ; uartProtocolCB2
000038  f8a400c8          STRH     r0,[r4,#0xc8]
;;;1350   	uartProtocolCB2.rx.head = uartProtocolCB2.rx.end;
00003c  f8b40130          LDRH     r0,[r4,#0x130]  ; uartProtocolCB2
000040  f8a4012e          STRH     r0,[r4,#0x12e]
;;;1351   	uartProtocolCB2.rx.cmdQueue[uartProtocolCB2.rx.end].length = 0;
000044  eb041040          ADD      r0,r4,r0,LSL #5
000048  f8a050ec          STRH     r5,[r0,#0xec]
;;;1352   }
00004c  bd70              POP      {r4-r6,pc}
;;;1353   
                          ENDP

00004e  0000              DCW      0x0000
                  |L34.80|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOL2_WriteLimitSpeed||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL2_WriteLimitSpeed PROC
;;;1123   // 写限速
;;;1124   void UART_PROTOCOL2_WriteLimitSpeed(uint16 param)
000000  b570              PUSH     {r4-r6,lr}
;;;1125   {
000002  4605              MOV      r5,r0
;;;1126   	uint8 checkVal;
;;;1127   	//uint16 perimeter = PARAM_GetPerimeter(PARAM_GetWheelSizeID());
;;;1128   	uint16 perimeter = PARAM_GetNewperimeter();
000004  4821              LDR      r0,|L35.140|
000006  f8b002ba          LDRH     r0,[r0,#0x2ba]  ; paramCB
;;;1129   	uint16 speedRpm = (uint16)(param*100000.0f/perimeter/60 + 0.5);
00000a  f7fffffe          BL       __aeabi_ui2f
00000e  4604              MOV      r4,r0
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       __aeabi_ui2f
000016  491e              LDR      r1,|L35.144|
000018  f7fffffe          BL       __aeabi_fmul
00001c  4621              MOV      r1,r4
00001e  f7fffffe          BL       __aeabi_fdiv
000022  491c              LDR      r1,|L35.148|
000024  f7fffffe          BL       __aeabi_fdiv
000028  f7fffffe          BL       __aeabi_f2d
00002c  2200              MOVS     r2,#0
00002e  4b1a              LDR      r3,|L35.152|
000030  f7fffffe          BL       __aeabi_dadd
000034  f7fffffe          BL       __aeabi_d2uiz
000038  b285              UXTH     r5,r0
;;;1130   
;;;1131   	// 设置命令类型
;;;1132   	uartProtocolCB2.cmdType = UART_PROTOCOL2_CMD_WRITE_LIMIT_SPEED;
00003a  4c18              LDR      r4,|L35.156|
00003c  f241601f          MOV      r0,#0x161f
000040  f8a40178          STRH     r0,[r4,#0x178]
;;;1133   	// 设置接收数据长度
;;;1134   	uartProtocolCB2.rx.expectLength = 0;
000044  2600              MOVS     r6,#0
000046  f8846132          STRB     r6,[r4,#0x132]
;;;1135   	
;;;1136   	// 写指令
;;;1137   	UART_PROTOCOL2_TxAddData((UART_PROTOCOL2_CMD_WRITE_LIMIT_SPEED&0xFF00)>>8);
00004a  2016              MOVS     r0,#0x16
00004c  f7fffffe          BL       UART_PROTOCOL2_TxAddData
;;;1138   
;;;1139   	// 命令为写限速
;;;1140   	UART_PROTOCOL2_TxAddData(UART_PROTOCOL2_CMD_WRITE_LIMIT_SPEED&0x00FF);
000050  201f              MOVS     r0,#0x1f
000052  f7fffffe          BL       UART_PROTOCOL2_TxAddData
;;;1141   
;;;1142   	UART_PROTOCOL2_TxAddData(speedRpm>>8);
000056  0a28              LSRS     r0,r5,#8
000058  f7fffffe          BL       UART_PROTOCOL2_TxAddData
;;;1143   	UART_PROTOCOL2_TxAddData(speedRpm&0x00FF);
00005c  b2e8              UXTB     r0,r5
00005e  f7fffffe          BL       UART_PROTOCOL2_TxAddData
;;;1144   
;;;1145   	checkVal = ((UART_PROTOCOL2_CMD_WRITE_LIMIT_SPEED&0xFF00)>>8) + (UART_PROTOCOL2_CMD_WRITE_LIMIT_SPEED&0x00FF) + (speedRpm>>8) + (speedRpm&0x00FF); 
000062  eb052015          ADD      r0,r5,r5,LSR #8
000066  3035              ADDS     r0,r0,#0x35
000068  b2c0              UXTB     r0,r0
;;;1146   	
;;;1147   	// 校验和
;;;1148   	UART_PROTOCOL2_TxAddData(checkVal);
00006a  f7fffffe          BL       UART_PROTOCOL2_TxAddData
;;;1149   
;;;1150   	// 组成完整命令帧
;;;1151   	UART_PROTOCOL2_TxAddFrame();
00006e  f7fffffe          BL       UART_PROTOCOL2_TxAddFrame
;;;1152   
;;;1153   
;;;1154   	// 清空一级接收队列以及命令帧队列
;;;1155   	uartProtocolCB2.rxFIFO.head = uartProtocolCB2.rxFIFO.end;
000072  f8b400ca          LDRH     r0,[r4,#0xca]  ; uartProtocolCB2
000076  f8a400c8          STRH     r0,[r4,#0xc8]
;;;1156   	uartProtocolCB2.rx.head = uartProtocolCB2.rx.end;
00007a  f8b40130          LDRH     r0,[r4,#0x130]  ; uartProtocolCB2
00007e  f8a4012e          STRH     r0,[r4,#0x12e]
;;;1157   	uartProtocolCB2.rx.cmdQueue[uartProtocolCB2.rx.end].length = 0;
000082  eb041040          ADD      r0,r4,r0,LSL #5
000086  f8a060ec          STRH     r6,[r0,#0xec]
;;;1158   }
00008a  bd70              POP      {r4-r6,pc}
;;;1159   
                          ENDP

                  |L35.140|
                          DCD      paramCB
                  |L35.144|
                          DCD      0x47c35000
                  |L35.148|
                          DCD      0x42700000
                  |L35.152|
                          DCD      0x3fe00000
                  |L35.156|
                          DCD      ||.bss||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  uartProtocolCB2
                          %        380

                          AREA ||.data||, DATA, ALIGN=0

                  number
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "User\\UartProtocol2.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_UartProtocol2_c_1823d7de____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___15_UartProtocol2_c_1823d7de____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_UartProtocol2_c_1823d7de____REVSH|
#line 128
|__asm___15_UartProtocol2_c_1823d7de____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
