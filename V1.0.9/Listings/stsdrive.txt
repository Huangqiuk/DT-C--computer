; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\stsdrive.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\stsdrive.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -I.\User\qrencode -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.3\Device\Include -D__MICROLIB -D__UVISION_VERSION=539 -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\stsdrive.crf User\StsDrive.c]
                          THUMB

                          AREA ||i.STS_UART_AddTxArray||, CODE, READONLY, ALIGN=2

                  STS_UART_AddTxArray PROC
;;;329    // 向发送缓冲区中添加一条待发送序列
;;;330    BOOL STS_UART_AddTxArray(uint16 id, uint8 *pArray, uint16 length)
000000  b570              PUSH     {r4-r6,lr}
;;;331    {
;;;332    	uint16 i;
;;;333    	uint16 head = STSUartCB.tx.head;
000002  4c1b              LDR      r4,|L1.112|
000004  f8b454d4          LDRH     r5,[r4,#0x4d4]  ; STSUartCB
;;;334    	uint16 end = STSUartCB.tx.end;
000008  f8b434d6          LDRH     r3,[r4,#0x4d6]  ; STSUartCB
;;;335    
;;;336    	// 参数检验
;;;337    	if ((NULL == pArray) || (0 == length))
00000c  2900              CMP      r1,#0
00000e  d007              BEQ      |L1.32|
000010  b132              CBZ      r2,|L1.32|
;;;338    	{
;;;339    		return FALSE;
;;;340    	}
;;;341    
;;;342    	// 发送缓冲区已满，不予接收
;;;343    	if ((end + 1) % STS_UART_DRIVE_TX_QUEUE_SIZE == head)
000012  1c5e              ADDS     r6,r3,#1
000014  f0060607          AND      r6,r6,#7
000018  42ae              CMP      r6,r5
00001a  d103              BNE      |L1.36|
;;;344    	{
;;;345    		return FALSE;
00001c  2000              MOVS     r0,#0
;;;346    	}
;;;347    
;;;348    	STSUartCB.tx.cmdQueue[end].deviceID = id;
;;;349    	for (i = 0; i < length; i++)
;;;350    	{
;;;351    		STSUartCB.tx.cmdQueue[end].buff[i] = *pArray++;
;;;352    	}
;;;353    	STSUartCB.tx.cmdQueue[end].length = length;
;;;354    
;;;355    	// 发送环形队列更新位置
;;;356    	STSUartCB.tx.end++;
;;;357    	STSUartCB.tx.end %= STS_UART_DRIVE_TX_QUEUE_SIZE;
;;;358    	STSUartCB.tx.cmdQueue[STSUartCB.tx.end].length = 0;
;;;359    
;;;360    	return TRUE;
;;;361    }
00001e  bd70              POP      {r4-r6,pc}
                  |L1.32|
000020  2000              MOVS     r0,#0                 ;339
000022  bd70              POP      {r4-r6,pc}
                  |L1.36|
000024  254d              MOVS     r5,#0x4d              ;348
000026  436b              MULS     r3,r5,r3              ;348
000028  eb040343          ADD      r3,r4,r3,LSL #1       ;348
00002c  8098              STRH     r0,[r3,#4]            ;348
00002e  2000              MOVS     r0,#0                 ;349
000030  e005              B        |L1.62|
                  |L1.50|
000032  181e              ADDS     r6,r3,r0              ;351
000034  f8115b01          LDRB     r5,[r1],#1            ;351
000038  71b5              STRB     r5,[r6,#6]            ;351
00003a  1c40              ADDS     r0,r0,#1              ;349
00003c  b280              UXTH     r0,r0                 ;349
                  |L1.62|
00003e  4290              CMP      r0,r2                 ;349
000040  d3f7              BCC      |L1.50|
000042  f8a3209c          STRH     r2,[r3,#0x9c]         ;353
000046  f20444d6          ADD      r4,r4,#0x4d6          ;356
00004a  8820              LDRH     r0,[r4,#0]            ;356  ; STSUartCB
00004c  1c40              ADDS     r0,r0,#1              ;356
00004e  8020              STRH     r0,[r4,#0]            ;356
000050  8820              LDRH     r0,[r4,#0]            ;357  ; STSUartCB
000052  f0000007          AND      r0,r0,#7              ;357
000056  8020              STRH     r0,[r4,#0]            ;357
000058  8820              LDRH     r0,[r4,#0]            ;358  ; STSUartCB
00005a  2100              MOVS     r1,#0                 ;358
00005c  224d              MOVS     r2,#0x4d              ;358
00005e  f2a444d6          SUB      r4,r4,#0x4d6          ;358
000062  4350              MULS     r0,r2,r0              ;358
000064  eb040040          ADD      r0,r4,r0,LSL #1       ;358
000068  f8a0109c          STRH     r1,[r0,#0x9c]         ;358
00006c  2001              MOVS     r0,#1                 ;360
00006e  bd70              POP      {r4-r6,pc}
;;;362    
                          ENDP

                  |L1.112|
                          DCD      ||area_number.13||

                          AREA ||i.STS_UART_BC_SendData||, CODE, READONLY, ALIGN=2

                  STS_UART_BC_SendData PROC
;;;176    // 阻塞发送一个字节数据
;;;177    void STS_UART_BC_SendData(uint8 data)
000000  b570              PUSH     {r4-r6,lr}
;;;178    {
000002  4605              MOV      r5,r0
;;;179    	// 防止丢失第一个字节(清除空标志位,务必加)
;;;180    	usart_flag_get(STS_UART_TYPE_DEF, USART_FLAG_TC);
000004  4c07              LDR      r4,|L2.36|
000006  2106              MOVS     r1,#6
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       usart_flag_get
;;;181    
;;;182    	// 填充数据
;;;183    	usart_data_transmit(STS_UART_TYPE_DEF, data);
00000e  4629              MOV      r1,r5
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       usart_data_transmit
                  |L2.22|
;;;184    
;;;185    	// 未发送完，持续等待
;;;186    	while (usart_flag_get(STS_UART_TYPE_DEF, USART_FLAG_TC) != SET);
000016  2106              MOVS     r1,#6
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       usart_flag_get
00001e  2801              CMP      r0,#1
000020  d1f9              BNE      |L2.22|
;;;187    }
000022  bd70              POP      {r4-r6,pc}
;;;188    
                          ENDP

                  |L2.36|
                          DCD      0x40004400

                          AREA ||i.STS_UART_DataStructureInit||, CODE, READONLY, ALIGN=2

                  STS_UART_DataStructureInit PROC
;;;66     // 数据结构初始化
;;;67     void STS_UART_DataStructureInit(STS_UART_CB *pCB)
000000  2800              CMP      r0,#0
;;;68     {
000002  d016              BEQ      |L3.50|
;;;69     	uint16 i;
;;;70     
;;;71     	// 参数合法性检验
;;;72     	if (NULL == pCB)
;;;73     	{
;;;74     		return;
;;;75     	}
;;;76     
;;;77     	pCB->tx.txBusy = FALSE;
000004  2200              MOVS     r2,#0
000006  f88024da          STRB     r2,[r0,#0x4da]
;;;78     	pCB->tx.index = 0;
00000a  f8a024d8          STRH     r2,[r0,#0x4d8]
;;;79     	pCB->tx.head = 0;
00000e  f8a024d4          STRH     r2,[r0,#0x4d4]
;;;80     	pCB->tx.end = 0;
000012  f8a024d6          STRH     r2,[r0,#0x4d6]
;;;81     	for (i = 0; i < STS_UART_DRIVE_TX_QUEUE_SIZE; i++)
000016  2100              MOVS     r1,#0
                  |L3.24|
;;;82     	{
;;;83     		pCB->tx.cmdQueue[i].length = 0;
000018  234d              MOVS     r3,#0x4d
00001a  434b              MULS     r3,r1,r3
00001c  eb000343          ADD      r3,r0,r3,LSL #1
000020  f8a3209c          STRH     r2,[r3,#0x9c]
000024  1c49              ADDS     r1,r1,#1              ;81
000026  b289              UXTH     r1,r1                 ;81
000028  2908              CMP      r1,#8                 ;81
00002a  d3f5              BCC      |L3.24|
;;;84     	}
;;;85     
;;;86     	STSUartCB.rcvBleMacOK = FALSE;
00002c  4801              LDR      r0,|L3.52|
00002e  f8802524          STRB     r2,[r0,#0x524]
                  |L3.50|
;;;87     }
000032  4770              BX       lr
;;;88     
                          ENDP

                  |L3.52|
                          DCD      ||area_number.13||

                          AREA ||i.STS_UART_HwInit||, CODE, READONLY, ALIGN=2

                  STS_UART_HwInit PROC
;;;35     // UART初始化
;;;36     void STS_UART_HwInit(uint32 baud)
000000  b570              PUSH     {r4-r6,lr}
;;;37     {
000002  4605              MOV      r5,r0
;;;38     	// 打开时钟
;;;39     	rcu_periph_clock_enable(RCU_GPIOA);
000004  f2406002          MOV      r0,#0x602
000008  f7fffffe          BL       rcu_periph_clock_enable
;;;40     	gpio_init(GPIOA, GPIO_MODE_AF_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_2); // TX
00000c  4c21              LDR      r4,|L4.148|
00000e  2304              MOVS     r3,#4
000010  2203              MOVS     r2,#3
000012  2118              MOVS     r1,#0x18
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       gpio_init
;;;41       
;;;42     	gpio_init(GPIOA, GPIO_MODE_IPU, GPIO_OSPEED_50MHZ, GPIO_PIN_3);  //RX
00001a  2308              MOVS     r3,#8
00001c  2203              MOVS     r2,#3
00001e  2148              MOVS     r1,#0x48
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       gpio_init
;;;43     
;;;44     	// UART时钟配置
;;;45     	rcu_periph_clock_enable(RCU_USART1);
000026  f2407011          MOV      r0,#0x711
00002a  f7fffffe          BL       rcu_periph_clock_enable
;;;46     	usart_deinit(STS_UART_TYPE_DEF); // 复位串口
00002e  4c1a              LDR      r4,|L4.152|
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       usart_deinit
;;;47     
;;;48     	// 串口配置
;;;49     	usart_baudrate_set(STS_UART_TYPE_DEF, baud);						  // 波特率
000036  4629              MOV      r1,r5
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       usart_baudrate_set
;;;50     	usart_word_length_set(STS_UART_TYPE_DEF, USART_WL_8BIT);			  // 8位数据位
00003e  2100              MOVS     r1,#0
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       usart_word_length_set
;;;51     	usart_stop_bit_set(STS_UART_TYPE_DEF, USART_STB_1BIT);				  // 一个停止位
000046  2100              MOVS     r1,#0
000048  4620              MOV      r0,r4
00004a  f7fffffe          BL       usart_stop_bit_set
;;;52     	usart_parity_config(STS_UART_TYPE_DEF, USART_PM_NONE);				  // 无奇偶校验
00004e  2100              MOVS     r1,#0
000050  4620              MOV      r0,r4
000052  f7fffffe          BL       usart_parity_config
;;;53     	usart_hardware_flow_rts_config(STS_UART_TYPE_DEF, USART_RTS_DISABLE); // 无硬件数据流控制
000056  2100              MOVS     r1,#0
000058  4620              MOV      r0,r4
00005a  f7fffffe          BL       usart_hardware_flow_rts_config
;;;54     	usart_hardware_flow_cts_config(STS_UART_TYPE_DEF, USART_CTS_DISABLE);
00005e  2100              MOVS     r1,#0
000060  4620              MOV      r0,r4
000062  f7fffffe          BL       usart_hardware_flow_cts_config
;;;55     	usart_transmit_config(STS_UART_TYPE_DEF, USART_TRANSMIT_ENABLE); // 使能发射
000066  2108              MOVS     r1,#8
000068  4620              MOV      r0,r4
00006a  f7fffffe          BL       usart_transmit_config
;;;56     	usart_receive_config(STS_UART_TYPE_DEF, USART_RECEIVE_ENABLE);	 // 使能接收
00006e  2104              MOVS     r1,#4
000070  4620              MOV      r0,r4
000072  f7fffffe          BL       usart_receive_config
;;;57     
;;;58     	// 中断配置
;;;59     	nvic_irq_enable(STS_UART_IRQn_DEF, 2, 1);
000076  2201              MOVS     r2,#1
000078  2102              MOVS     r1,#2
00007a  2026              MOVS     r0,#0x26
00007c  f7fffffe          BL       nvic_irq_enable
;;;60     
;;;61     	usart_interrupt_enable(STS_UART_TYPE_DEF, USART_INT_RBNE); // 开启中断
000080  f2403105          MOV      r1,#0x305
000084  4620              MOV      r0,r4
000086  f7fffffe          BL       usart_interrupt_enable
;;;62     
;;;63     	usart_enable(STS_UART_TYPE_DEF); // 使能串口
00008a  4620              MOV      r0,r4
00008c  e8bd4070          POP      {r4-r6,lr}
000090  f7ffbffe          B.W      usart_enable
;;;64     }
;;;65     
                          ENDP

                  |L4.148|
                          DCD      0x40010800
                  |L4.152|
                          DCD      0x40004400

                          AREA ||i.STS_UART_IR_StartSendData||, CODE, READONLY, ALIGN=2

                  STS_UART_IR_StartSendData PROC
;;;163    // 启动中断字节发送
;;;164    void STS_UART_IR_StartSendData(uint8 data)
000000  b570              PUSH     {r4-r6,lr}
;;;165    {
000002  4605              MOV      r5,r0
;;;166    	// 先读SR，再填充DR会把TC标志清掉
;;;167    	usart_flag_get(STS_UART_TYPE_DEF, USART_FLAG_TC);
000004  4c07              LDR      r4,|L5.36|
000006  2106              MOVS     r1,#6
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       usart_flag_get
;;;168    
;;;169    	// 发送一个字节
;;;170    	usart_data_transmit(STS_UART_TYPE_DEF, data);
00000e  4629              MOV      r1,r5
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       usart_data_transmit
;;;171    
;;;172    	// 打开发送完成中断
;;;173    	usart_interrupt_enable(STS_UART_TYPE_DEF, USART_INT_TC);
000016  4620              MOV      r0,r4
000018  e8bd4070          POP      {r4-r6,lr}
00001c  f2403106          MOV      r1,#0x306
000020  f7ffbffe          B.W      usart_interrupt_enable
;;;174    }
;;;175    
                          ENDP

                  |L5.36|
                          DCD      0x40004400

                          AREA ||i.STS_UART_Init||, CODE, READONLY, ALIGN=2

                  STS_UART_Init PROC
;;;306    // UART初始化
;;;307    void STS_UART_Init(void)
000000  b510              PUSH     {r4,lr}
;;;308    {
;;;309    	// STS串口初始化
;;;310    	STS_UART_HwInit(STS_UART_BAUD_RATE);
000002  f44f30e1          MOV      r0,#0x1c200
000006  f7fffffe          BL       STS_UART_HwInit
;;;311    
;;;312    	// STS数据结构初始化
;;;313    	STS_UART_DataStructureInit(&STSUartCB);
00000a  e8bd4010          POP      {r4,lr}
00000e  4801              LDR      r0,|L6.20|
000010  f7ffbffe          B.W      STS_UART_DataStructureInit
;;;314    }
;;;315    
                          ENDP

                  |L6.20|
                          DCD      ||area_number.13||

                          AREA ||i.STS_UART_Process||, CODE, READONLY, ALIGN=2

                  STS_UART_Process PROC
;;;316    // UART模块处理入口
;;;317    void STS_UART_Process(void)
000000  4801              LDR      r0,|L7.8|
;;;318    {
;;;319    	// 发送处理
;;;320    	STS_UART_TxProcess(&STSUartCB);
000002  f7ffbffe          B.W      STS_UART_TxProcess
;;;321    }
;;;322    
                          ENDP

000006  0000              DCW      0x0000
                  |L7.8|
                          DCD      ||area_number.13||

                          AREA ||i.STS_UART_RegisterDataSendService||, CODE, READONLY, ALIGN=2

                  STS_UART_RegisterDataSendService PROC
;;;323    // 注册数据抛出接口服务
;;;324    void STS_UART_RegisterDataSendService(void (*service)(uint16 id, uint8 *pData, uint16 length))
000000  4901              LDR      r1,|L8.8|
;;;325    {
;;;326    	STSUartCB.receiveDataThrowService = service;
000002  6008              STR      r0,[r1,#0]  ; STSUartCB
;;;327    }
000004  4770              BX       lr
;;;328    
                          ENDP

000006  0000              DCW      0x0000
                  |L8.8|
                          DCD      ||area_number.13||

                          AREA ||i.STS_UART_TxProcess||, CODE, READONLY, ALIGN=1

                  STS_UART_TxProcess PROC
;;;89     // 发送处理
;;;90     void STS_UART_TxProcess(STS_UART_CB *pCB)
000000  b510              PUSH     {r4,lr}
;;;91     {
000002  4604              MOV      r4,r0
;;;92     // 中断方式
;;;93     #if (STS_UART_TX_MODE == STS_UART_INTERRUPT_TX_MODE)
;;;94     	uint16 index = pCB->tx.index;						   // 当前发送数据的索引号
000004  f8b404d8          LDRH     r0,[r4,#0x4d8]
;;;95     	uint16 length = pCB->tx.cmdQueue[pCB->tx.head].length; // 当前发送的命令帧的长度
000008  f8b414d4          LDRH     r1,[r4,#0x4d4]
00000c  224d              MOVS     r2,#0x4d
00000e  4351              MULS     r1,r2,r1
000010  eb040141          ADD      r1,r4,r1,LSL #1
000014  f8b1209c          LDRH     r2,[r1,#0x9c]
;;;96     	uint16 head = pCB->tx.head;							   // 发送命令帧队列头索引号
000018  f8b414d4          LDRH     r1,[r4,#0x4d4]
;;;97     	uint16 end = pCB->tx.end;							   // 发送命令帧队列尾索引号
00001c  f8b434d6          LDRH     r3,[r4,#0x4d6]
;;;98     
;;;99     	// 参数合法性检验
;;;100    	if (NULL == pCB)
000020  2c00              CMP      r4,#0
000022  d017              BEQ      |L9.84|
;;;101    	{
;;;102    		return;
;;;103    	}
;;;104    
;;;105    	// 队列为空，不处理
;;;106    	if (head == end)
000024  4299              CMP      r1,r3
000026  d015              BEQ      |L9.84|
;;;107    	{
;;;108    		return;
;;;109    	}
;;;110    
;;;111    	// 发送忙，退出
;;;112    	if (pCB->tx.txBusy)
000028  f89434da          LDRB     r3,[r4,#0x4da]
00002c  2b00              CMP      r3,#0
00002e  d111              BNE      |L9.84|
;;;113    	{
;;;114    		return;
;;;115    	}
;;;116    
;;;117    	// ■■执行到这里，说明队列非空■■
;;;118    
;;;119    	// 当前命令帧未发送完时，取出一个字节放到发送寄存器中
;;;120    	if (index < length)
000030  4290              CMP      r0,r2
000032  d20f              BCS      |L9.84|
;;;121    	{
;;;122    		STS_UART_IR_StartSendData(pCB->tx.cmdQueue[head].buff[pCB->tx.index++]);
000034  f8b404d8          LDRH     r0,[r4,#0x4d8]
000038  1c42              ADDS     r2,r0,#1
00003a  f8a424d8          STRH     r2,[r4,#0x4d8]
00003e  224d              MOVS     r2,#0x4d
000040  4351              MULS     r1,r2,r1
000042  eb040141          ADD      r1,r4,r1,LSL #1
000046  4408              ADD      r0,r0,r1
000048  7980              LDRB     r0,[r0,#6]
00004a  f7fffffe          BL       STS_UART_IR_StartSendData
;;;123    
;;;124    		// 设置发送忙状态
;;;125    		pCB->tx.txBusy = TRUE;
00004e  2001              MOVS     r0,#1
000050  f88404da          STRB     r0,[r4,#0x4da]
                  |L9.84|
;;;126    	}
;;;127    
;;;128    // 阻塞方式时启动发送
;;;129    #else
;;;130    	uint16 index = pCB->tx.index;
;;;131    	uint16 head = pCB->tx.head;
;;;132    	uint16 end = pCB->tx.end;
;;;133    
;;;134    	// 参数合法性检验
;;;135    	if (NULL == pCB)
;;;136    	{
;;;137    		return;
;;;138    	}
;;;139    
;;;140    	// 队列为空，不处理
;;;141    	if (head == end)
;;;142    	{
;;;143    		return;
;;;144    	}
;;;145    
;;;146    	// 当前命令帧未发送完时，持续发送
;;;147    	while (index < pCB->tx.cmdQueue[head].length)
;;;148    	{
;;;149    		// 一直填充发送
;;;150    		STS_UART_BC_SendData(pCB->tx.cmdQueue[head].buff[pCB->tx.index++]);
;;;151    
;;;152    		index = pCB->tx.index;
;;;153    	}
;;;154    
;;;155    	// 当前命令帧发送完时，删除之
;;;156    	pCB->tx.cmdQueue[head].length = 0;
;;;157    	pCB->tx.head++;
;;;158    	pCB->tx.head %= STS_UART_DRIVE_TX_QUEUE_SIZE;
;;;159    	pCB->tx.index = 0;
;;;160    #endif
;;;161    }
000054  bd10              POP      {r4,pc}
;;;162    
                          ENDP


                          AREA ||i.USART1_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART1_IRQHandler PROC
;;;218     *************************************************************/
;;;219    void USART1_IRQHandler(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;220    {
;;;221    	// 判断DR是否有数据，中断接收
;;;222    	if (usart_interrupt_flag_get(STS_UART_TYPE_DEF, USART_INT_FLAG_RBNE) != RESET)
000002  4d35              LDR      r5,|L10.216|
000004  4933              LDR      r1,|L10.212|
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       usart_interrupt_flag_get
;;;223    	{
;;;224    		uint8 rxdata = 0x00;
;;;225    
;;;226    		// 接收数据
;;;227    		rxdata = (uint8)usart_data_receive(STS_UART_TYPE_DEF);
;;;228    
;;;229    		if (NULL != STSUartCB.receiveDataThrowService)
00000c  4c33              LDR      r4,|L10.220|
00000e  2600              MOVS     r6,#0                 ;222
000010  b158              CBZ      r0,|L10.42|
000012  9600              STR      r6,[sp,#0]            ;224
000014  4628              MOV      r0,r5                 ;227
000016  f7fffffe          BL       usart_data_receive
00001a  9000              STR      r0,[sp,#0]            ;227
00001c  6823              LDR      r3,[r4,#0]  ; STSUartCB
00001e  b123              CBZ      r3,|L10.42|
;;;230    		{
;;;231    ////             dut_info.passThroughStsToDut = TRUE;
;;;232    			(*STSUartCB.receiveDataThrowService)(0xFFF, &rxdata, 1);
000020  2201              MOVS     r2,#1
000022  4669              MOV      r1,sp
000024  f64070ff          MOV      r0,#0xfff
000028  4798              BLX      r3
                  |L10.42|
;;;233    		}
;;;234    
;;;235    		if (!STSUartCB.rcvBleMacOK)
;;;236    		{
;;;237    			//			BLE_UART_AtChannelDataProcess(rxdata);
;;;238    		}
;;;239    
;;;240    		//=================================================================
;;;241    		// 蓝牙连接判断
;;;242    //		if ((bleIndex + 1) < sizeof(STSRxBuff) / sizeof(STSRxBuff[0]))
;;;243    //		{
;;;244    //			STSRxBuff[bleIndex++] = rxdata;
;;;245    //			STSRxBuff[bleIndex] = '\0';
;;;246    //		}
;;;247    	}
;;;248    
;;;249    // 中断模式发送
;;;250    #if (STS_UART_TX_MODE == STS_UART_INTERRUPT_TX_MODE)
;;;251    	// 判断DR是否有数据，中断发送
;;;252    	if (usart_interrupt_flag_get(STS_UART_TYPE_DEF, USART_INT_FLAG_TC) != RESET)
00002a  492d              LDR      r1,|L10.224|
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       usart_interrupt_flag_get
000032  b3b0              CBZ      r0,|L10.162|
;;;253    	{
;;;254    		uint16 head = STSUartCB.tx.head;
000034  f8b404d4          LDRH     r0,[r4,#0x4d4]  ; STSUartCB
;;;255    		uint16 end;
;;;256    		uint16 index = STSUartCB.tx.index;
000038  f8b414d8          LDRH     r1,[r4,#0x4d8]  ; STSUartCB
;;;257    		uint8 txdata = 0x00;
;;;258    
;;;259    		// 执行到这里，说明上一个数据已经发送完毕，当前命令帧未发送完时，取出一个字节放到发送寄存器中
;;;260    		if (index < STSUartCB.tx.cmdQueue[head].length)
00003c  224d              MOVS     r2,#0x4d
00003e  4350              MULS     r0,r2,r0
000040  eb040240          ADD      r2,r4,r0,LSL #1
000044  f8b2009c          LDRH     r0,[r2,#0x9c]
000048  4288              CMP      r0,r1
00004a  d90a              BLS      |L10.98|
;;;261    		{
;;;262    			txdata = STSUartCB.tx.cmdQueue[head].buff[STSUartCB.tx.index++];
00004c  f8b414d8          LDRH     r1,[r4,#0x4d8]  ; STSUartCB
000050  1c48              ADDS     r0,r1,#1
000052  f8a404d8          STRH     r0,[r4,#0x4d8]
000056  1888              ADDS     r0,r1,r2
000058  7981              LDRB     r1,[r0,#6]
;;;263    
;;;264    			// 填充数据
;;;265    			usart_data_transmit(STS_UART_TYPE_DEF, txdata);
00005a  4628              MOV      r0,r5
00005c  f7fffffe          BL       usart_data_transmit
000060  e027              B        |L10.178|
                  |L10.98|
;;;266    		}
;;;267    		// 当前命令帧发送完时，删除之
;;;268    		else
;;;269    		{
;;;270    			STSUartCB.tx.cmdQueue[head].length = 0;
000062  f8a2609c          STRH     r6,[r2,#0x9c]
;;;271    			STSUartCB.tx.head++;
000066  f20444d4          ADD      r4,r4,#0x4d4
00006a  8820              LDRH     r0,[r4,#0]  ; STSUartCB
00006c  1c40              ADDS     r0,r0,#1
00006e  8020              STRH     r0,[r4,#0]
;;;272    			STSUartCB.tx.head %= STS_UART_DRIVE_TX_QUEUE_SIZE;
000070  8820              LDRH     r0,[r4,#0]  ; STSUartCB
000072  f0000007          AND      r0,r0,#7
000076  8020              STRH     r0,[r4,#0]
;;;273    			STSUartCB.tx.index = 0;
000078  80a6              STRH     r6,[r4,#4]
;;;274    
;;;275    			head = STSUartCB.tx.head;
00007a  8822              LDRH     r2,[r4,#0]  ; STSUartCB
;;;276    			end = STSUartCB.tx.end;
00007c  8860              LDRH     r0,[r4,#2]  ; STSUartCB
00007e  f2a444d4          SUB      r4,r4,#0x4d4
;;;277    
;;;278    			// 命令帧队列非空，继续发送下一个命令帧
;;;279    			if (head != end)
000082  4282              CMP      r2,r0
000084  d00e              BEQ      |L10.164|
;;;280    			{
;;;281    				txdata = STSUartCB.tx.cmdQueue[head].buff[STSUartCB.tx.index++];
000086  f8b414d8          LDRH     r1,[r4,#0x4d8]  ; STSUartCB
00008a  1c48              ADDS     r0,r1,#1
00008c  f8a404d8          STRH     r0,[r4,#0x4d8]
000090  204d              MOVS     r0,#0x4d
000092  4342              MULS     r2,r0,r2
000094  eb040042          ADD      r0,r4,r2,LSL #1
000098  4408              ADD      r0,r0,r1
00009a  7981              LDRB     r1,[r0,#6]
;;;282    
;;;283    				// 填充数据
;;;284    				usart_data_transmit(STS_UART_TYPE_DEF, txdata);
00009c  4628              MOV      r0,r5
00009e  f7fffffe          BL       usart_data_transmit
                  |L10.162|
0000a2  e006              B        |L10.178|
                  |L10.164|
;;;285    			}
;;;286    			// 命令帧队列为空停止发送，设置空闲
;;;287    			else
;;;288    			{
;;;289    				// 关闭发送完成中断
;;;290    				usart_interrupt_disable(STS_UART_TYPE_DEF, USART_INT_TC);
0000a4  f2403106          MOV      r1,#0x306
0000a8  4628              MOV      r0,r5
0000aa  f7fffffe          BL       usart_interrupt_disable
;;;291    
;;;292    				STSUartCB.tx.txBusy = FALSE;
0000ae  f88464da          STRB     r6,[r4,#0x4da]
                  |L10.178|
;;;293    			}
;;;294    		}
;;;295    	}
;;;296    #endif
;;;297    
;;;298    	// Other USARTx interrupts handler can go here ...
;;;299    	if (usart_interrupt_flag_get(STS_UART_TYPE_DEF, USART_INT_FLAG_ERR_ORERR) != RESET) //----------------------- 接收溢出中断
0000b2  490c              LDR      r1,|L10.228|
0000b4  4628              MOV      r0,r5
0000b6  f7fffffe          BL       usart_interrupt_flag_get
0000ba  2800              CMP      r0,#0
0000bc  d008              BEQ      |L10.208|
;;;300    	{
;;;301    		usart_flag_get(STS_UART_TYPE_DEF, USART_FLAG_ORERR); 							//----------------------- 清除接收溢出中断标志位
0000be  2103              MOVS     r1,#3
0000c0  4628              MOV      r0,r5
0000c2  f7fffffe          BL       usart_flag_get
;;;302    		usart_data_receive(STS_UART_TYPE_DEF);				 							//----------------------- 清空寄存器
0000c6  4628              MOV      r0,r5
0000c8  e8bd40f8          POP      {r3-r7,lr}
0000cc  f7ffbffe          B.W      usart_data_receive
                  |L10.208|
;;;303    	}
;;;304    }
0000d0  bdf8              POP      {r3-r7,pc}
;;;305    
                          ENDP

0000d2  0000              DCW      0x0000
                  |L10.212|
                          DCD      0x00050305
                  |L10.216|
                          DCD      0x40004400
                  |L10.220|
                          DCD      ||area_number.13||
                  |L10.224|
                          DCD      0x00060306
                  |L10.228|
                          DCD      0x00030500

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  STSRxBuff
                          %        200

                          AREA ||area_number.13||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.13||, ||.bss||
                  STSUartCB
                          %        1320

;*** Start embedded assembler ***

#line 1 "User\\StsDrive.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_StsDrive_c_4300670a____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___10_StsDrive_c_4300670a____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_StsDrive_c_4300670a____REVSH|
#line 128
|__asm___10_StsDrive_c_4300670a____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
