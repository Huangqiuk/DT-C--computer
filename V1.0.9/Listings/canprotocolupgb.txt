; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\canprotocolupgb.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\canprotocolupgb.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -I.\User\qrencode -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.3\Device\Include -D__MICROLIB -D__UVISION_VERSION=539 -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\canprotocolupgb.crf User\CanProtocolUpGB.c]
                          THUMB

                          AREA ||i.CAN_PGN_RequestGetData||, CODE, READONLY, ALIGN=2

                  CAN_PGN_RequestGetData PROC
;;;553    // state : 当前状态   DestAddress:目的地址   SourceAddress:源地址
;;;554    void CAN_PGN_RequestGetData(STATE_PGN state, uint8 PGN, uint8 DestAddress, uint8 SourceAddress)
000000  b5f0              PUSH     {r4-r7,lr}
;;;555    {
000002  460f              MOV      r7,r1
;;;556    	uint16 dataLength = 0, dataNumber = 0;
000004  2400              MOVS     r4,#0
000006  2500              MOVS     r5,#0
;;;557    
;;;558    	canProtocolCB.preState = canProtocolCB.state;
000008  4941              LDR      r1,|L1.272|
00000a  780e              LDRB     r6,[r1,#0]  ; canProtocolCB
00000c  704e              STRB     r6,[r1,#1]
;;;559    	canProtocolCB.state = state;
00000e  7008              STRB     r0,[r1,#0]
;;;560    
;;;561    	switch (PGN)
000010  f1a70150          SUB      r1,r7,#0x50
;;;562    	{
;;;563    	// 升级数据包大小下发
;;;564    	case 0x50:
;;;565    		// 发送的字节数
;;;566    		dataLength = 28;
;;;567    
;;;568    		// 发送的总包数
;;;569    		if (dataLength % 7)
000014  2607              MOVS     r6,#7
000016  2906              CMP      r1,#6                 ;561
000018  d21f              BCS      |L1.90|
00001a  e8dff001          TBB      [pc,r1]               ;561
00001e  031e              DCB      0x03,0x1e
000020  11111111          DCB      0x11,0x11,0x11,0x11
000024  241c              MOVS     r4,#0x1c              ;566
000026  fbb4f1f6          UDIV     r1,r4,r6
00002a  fb064111          MLS      r1,r6,r1,r4
00002e  b121              CBZ      r1,|L1.58|
;;;570    		{
;;;571    			dataNumber = (dataLength / 7) + 1;
000030  fbb4f1f6          UDIV     r1,r4,r6
000034  1c49              ADDS     r1,r1,#1
000036  b28d              UXTH     r5,r1
000038  e00f              B        |L1.90|
                  |L1.58|
;;;572    		}
;;;573    		else
;;;574    		{
;;;575    			dataNumber = dataLength / 7;
00003a  fbb4f5f6          UDIV     r5,r4,r6
00003e  e00c              B        |L1.90|
;;;576    		}
;;;577    
;;;578    		break;
;;;579    
;;;580    	case 0x52:
;;;581    	case 0x53:
;;;582    	case 0x54:
;;;583    	case 0x55:
;;;584    		// 发送的字节数
;;;585    		dataLength = 23;
000040  2417              MOVS     r4,#0x17
;;;586    
;;;587    		// 发送的总包数
;;;588    		if (dataLength % 7)
000042  fbb4f1f6          UDIV     r1,r4,r6
000046  fb064111          MLS      r1,r6,r1,r4
00004a  b121              CBZ      r1,|L1.86|
;;;589    		{
;;;590    			dataNumber = (dataLength / 7) + 1;
00004c  fbb4f1f6          UDIV     r1,r4,r6
000050  1c49              ADDS     r1,r1,#1
000052  b28d              UXTH     r5,r1
000054  e001              B        |L1.90|
                  |L1.86|
;;;591    		}
;;;592    		else
;;;593    		{
;;;594    			dataNumber = dataLength / 7;
000056  fbb4f5f6          UDIV     r5,r4,r6
                  |L1.90|
;;;595    		}
;;;596    		break;
;;;597    
;;;598    	default:
;;;599    		break;
;;;600    	}
;;;601    
;;;602    	switch (state)
00005a  2800              CMP      r0,#0
00005c  d056              BEQ      |L1.268|
00005e  2805              CMP      r0,#5
000060  d023              BEQ      |L1.170|
000062  2806              CMP      r0,#6
000064  d032              BEQ      |L1.204|
000066  2807              CMP      r0,#7
000068  d150              BNE      |L1.268|
;;;603    	{
;;;604    	case STATE_PGN_NULL:
;;;605    
;;;606    		break;
;;;607    
;;;608    	// 请求PGN数据 第一步:发送请求PGN  EA00
;;;609    	case STATE_PGN_GET_1:
;;;610    
;;;611    		CAN_PROTOCOL_TxAddNewFrame(0x06, 0xEA, DestAddress, SourceAddress);
;;;612    
;;;613    		CAN_PROTOCOL_TxAddData(0x00);
;;;614    
;;;615    		CAN_PROTOCOL_TxAddData(PGN);
;;;616    
;;;617    		CAN_PROTOCOL_TxAddData(0x00);
;;;618    
;;;619    		CAN_PROTOCOL_TxAddFrame();
;;;620    		break;
;;;621    
;;;622    	// 请求PGN数据 第二步:发送请求PGN  EC00
;;;623    	case STATE_PGN_GET_2:
;;;624    
;;;625    		CAN_PROTOCOL_TxAddNewFrame(0x06, 0xEC, DestAddress, SourceAddress);
;;;626    
;;;627    		CAN_PROTOCOL_TxAddData(0x11); // 准许发送
;;;628    
;;;629    		CAN_PROTOCOL_TxAddData(dataNumber);
;;;630    
;;;631    		CAN_PROTOCOL_TxAddData(0x01);
;;;632    
;;;633    		CAN_PROTOCOL_TxAddData(0xFF);
;;;634    
;;;635    		CAN_PROTOCOL_TxAddData(0xFF);
;;;636    
;;;637    		CAN_PROTOCOL_TxAddData(0);
;;;638    
;;;639    		CAN_PROTOCOL_TxAddData(PGN);
;;;640    
;;;641    		CAN_PROTOCOL_TxAddData(0);
;;;642    
;;;643    		CAN_PROTOCOL_TxAddFrame();
;;;644    		break;
;;;645    
;;;646    	// 请求PGN数据 第三步:发送请求PGN  EC00
;;;647    	case STATE_PGN_GET_3:
;;;648    
;;;649    		CAN_PROTOCOL_TxAddNewFrame(0x06, 0xEC, DestAddress, SourceAddress);
00006a  21ec              MOVS     r1,#0xec
00006c  2006              MOVS     r0,#6
00006e  f7fffffe          BL       CAN_PROTOCOL_TxAddNewFrame
;;;650    
;;;651    		CAN_PROTOCOL_TxAddData(0x13); // 结束应答
000072  2013              MOVS     r0,#0x13
000074  f7fffffe          BL       CAN_PROTOCOL_TxAddData
;;;652    
;;;653    		CAN_PROTOCOL_TxAddData(dataLength & 0xFF); // 	字节数
000078  b2e0              UXTB     r0,r4
00007a  f7fffffe          BL       CAN_PROTOCOL_TxAddData
;;;654    
;;;655    		CAN_PROTOCOL_TxAddData((dataLength >> 8) & 0xFF);
00007e  0a20              LSRS     r0,r4,#8
000080  f7fffffe          BL       CAN_PROTOCOL_TxAddData
;;;656    
;;;657    		CAN_PROTOCOL_TxAddData(dataNumber); // 	包数
000084  b2e8              UXTB     r0,r5
000086  f7fffffe          BL       CAN_PROTOCOL_TxAddData
;;;658    
;;;659    		CAN_PROTOCOL_TxAddData(0x01); // 数据校验成功
00008a  2001              MOVS     r0,#1
00008c  f7fffffe          BL       CAN_PROTOCOL_TxAddData
;;;660    
;;;661    		CAN_PROTOCOL_TxAddData(0);
000090  2000              MOVS     r0,#0
000092  f7fffffe          BL       CAN_PROTOCOL_TxAddData
;;;662    
;;;663    		CAN_PROTOCOL_TxAddData(PGN);
000096  4638              MOV      r0,r7
000098  f7fffffe          BL       CAN_PROTOCOL_TxAddData
;;;664    
;;;665    		CAN_PROTOCOL_TxAddData(0);
00009c  2000              MOVS     r0,#0
00009e  f7fffffe          BL       CAN_PROTOCOL_TxAddData
;;;666    
;;;667    		CAN_PROTOCOL_TxAddFrame();
0000a2  e8bd40f0          POP      {r4-r7,lr}
0000a6  f7ffbffe          B.W      CAN_PROTOCOL_TxAddFrame
                  |L1.170|
0000aa  21ea              MOVS     r1,#0xea              ;611
0000ac  2006              MOVS     r0,#6                 ;611
0000ae  f7fffffe          BL       CAN_PROTOCOL_TxAddNewFrame
0000b2  2000              MOVS     r0,#0                 ;613
0000b4  f7fffffe          BL       CAN_PROTOCOL_TxAddData
0000b8  4638              MOV      r0,r7                 ;615
0000ba  f7fffffe          BL       CAN_PROTOCOL_TxAddData
0000be  2000              MOVS     r0,#0                 ;617
0000c0  f7fffffe          BL       CAN_PROTOCOL_TxAddData
0000c4  e8bd40f0          POP      {r4-r7,lr}            ;619
0000c8  f7ffbffe          B.W      CAN_PROTOCOL_TxAddFrame
                  |L1.204|
0000cc  21ec              MOVS     r1,#0xec              ;625
0000ce  2006              MOVS     r0,#6                 ;625
0000d0  f7fffffe          BL       CAN_PROTOCOL_TxAddNewFrame
0000d4  2011              MOVS     r0,#0x11              ;627
0000d6  f7fffffe          BL       CAN_PROTOCOL_TxAddData
0000da  b2e8              UXTB     r0,r5                 ;629
0000dc  f7fffffe          BL       CAN_PROTOCOL_TxAddData
0000e0  2001              MOVS     r0,#1                 ;631
0000e2  f7fffffe          BL       CAN_PROTOCOL_TxAddData
0000e6  20ff              MOVS     r0,#0xff              ;633
0000e8  f7fffffe          BL       CAN_PROTOCOL_TxAddData
0000ec  20ff              MOVS     r0,#0xff              ;635
0000ee  f7fffffe          BL       CAN_PROTOCOL_TxAddData
0000f2  2000              MOVS     r0,#0                 ;637
0000f4  f7fffffe          BL       CAN_PROTOCOL_TxAddData
0000f8  4638              MOV      r0,r7                 ;639
0000fa  f7fffffe          BL       CAN_PROTOCOL_TxAddData
0000fe  2000              MOVS     r0,#0                 ;641
000100  f7fffffe          BL       CAN_PROTOCOL_TxAddData
000104  e8bd40f0          POP      {r4-r7,lr}            ;643
000108  f7ffbffe          B.W      CAN_PROTOCOL_TxAddFrame
                  |L1.268|
;;;668    		break;
;;;669    
;;;670    	default:
;;;671    		break;
;;;672    	}
;;;673    }
00010c  bdf0              POP      {r4-r7,pc}
;;;674    
                          ENDP

00010e  0000              DCW      0x0000
                  |L1.272|
                          DCD      ||area_number.21||+0x8c

                          AREA ||i.CAN_PGN_RequestSendData||, CODE, READONLY, ALIGN=2

                  CAN_PGN_RequestSendData PROC
;;;445    // state : 当前状态   DestAddress:目的地址   SourceAddress:源地址
;;;446    void CAN_PGN_RequestSendData(STATE_PGN state, uint8 PGN, uint8 DestAddress, uint8 SourceAddress)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;447    {
000004  460c              MOV      r4,r1
000006  4691              MOV      r9,r2
000008  469a              MOV      r10,r3
;;;448    	uint16 dataLength = 0, dataNumber = 0;
00000a  2700              MOVS     r7,#0
00000c  2600              MOVS     r6,#0
;;;449    	uint8 number = 1;
00000e  2501              MOVS     r5,#1
;;;450    
;;;451    	canProtocolCB.preState = canProtocolCB.state;
000010  f8df80e4          LDR      r8,|L2.248|
000014  f898108c          LDRB     r1,[r8,#0x8c]  ; canProtocolCB
000018  f888108d          STRB     r1,[r8,#0x8d]
;;;452    	canProtocolCB.state = state;
00001c  f888008c          STRB     r0,[r8,#0x8c]
;;;453    
;;;454    	switch (PGN)
000020  2c55              CMP      r4,#0x55
000022  d011              BEQ      |L2.72|
000024  dc06              BGT      |L2.52|
000026  2c52              CMP      r4,#0x52
000028  d00e              BEQ      |L2.72|
00002a  2c53              CMP      r4,#0x53
00002c  d00c              BEQ      |L2.72|
00002e  2c54              CMP      r4,#0x54
000030  d10c              BNE      |L2.76|
000032  e009              B        |L2.72|
                  |L2.52|
000034  2ced              CMP      r4,#0xed
000036  d004              BEQ      |L2.66|
000038  2cef              CMP      r4,#0xef
00003a  d107              BNE      |L2.76|
;;;455    	{
;;;456    	// 升级包数据大小
;;;457    	case 0xEF:
;;;458    
;;;459    		// 发送的字节数
;;;460    		dataLength = 132;
00003c  2784              MOVS     r7,#0x84
;;;461    
;;;462    		// 发送的总包数
;;;463    		dataNumber = 19;
00003e  2613              MOVS     r6,#0x13
;;;464    
;;;465    		break;
000040  e004              B        |L2.76|
                  |L2.66|
;;;466    
;;;467    	// 下发总成编码
;;;468    	case 0xED:
;;;469    
;;;470    		// 发送的字节数
;;;471    		dataLength = 43;
000042  272b              MOVS     r7,#0x2b
;;;472    
;;;473    		// 发送的总包数
;;;474    		dataNumber = 7;
000044  2607              MOVS     r6,#7
;;;475    		break;
000046  e001              B        |L2.76|
                  |L2.72|
;;;476    
;;;477    	case 0x52:
;;;478    	case 0x53:
;;;479    	case 0x54:
;;;480    	case 0x55:
;;;481    		// 发送的字节数
;;;482    		dataLength = 23;
000048  2717              MOVS     r7,#0x17
;;;483    
;;;484    		// 发送的总包数
;;;485    		dataNumber = 4;
00004a  2604              MOVS     r6,#4
                  |L2.76|
;;;486    		break;
;;;487    	default:
;;;488    		break;
;;;489    	}
;;;490    
;;;491    	switch (state)
00004c  2800              CMP      r0,#0
00004e  d050              BEQ      |L2.242|
000050  2801              CMP      r0,#1
000052  d002              BEQ      |L2.90|
000054  2802              CMP      r0,#2
000056  d14c              BNE      |L2.242|
000058  e049              B        |L2.238|
                  |L2.90|
;;;492    	{
;;;493    	case STATE_PGN_NULL:
;;;494    
;;;495    		break;
;;;496    
;;;497    	// 发送PGN数据第一步:请求发送
;;;498    	case STATE_PGN_SEND_1:
;;;499    
;;;500    		CAN_PROTOCOL_TxAddNewFrame(0x06, 0xEC, DestAddress, SourceAddress);
00005a  4653              MOV      r3,r10
00005c  464a              MOV      r2,r9
00005e  21ec              MOVS     r1,#0xec
000060  2006              MOVS     r0,#6
000062  f7fffffe          BL       CAN_PROTOCOL_TxAddNewFrame
;;;501    
;;;502    		CAN_PROTOCOL_TxAddData(0x10);
000066  2010              MOVS     r0,#0x10
000068  f7fffffe          BL       CAN_PROTOCOL_TxAddData
;;;503    
;;;504    		CAN_PROTOCOL_TxAddData(dataLength & 0xFF);
00006c  b2f8              UXTB     r0,r7
00006e  f7fffffe          BL       CAN_PROTOCOL_TxAddData
;;;505    
;;;506    		CAN_PROTOCOL_TxAddData((dataLength >> 8) & 0xFF);
000072  0a38              LSRS     r0,r7,#8
000074  f7fffffe          BL       CAN_PROTOCOL_TxAddData
;;;507    
;;;508    		CAN_PROTOCOL_TxAddData(dataNumber);
000078  b2f0              UXTB     r0,r6
00007a  f7fffffe          BL       CAN_PROTOCOL_TxAddData
;;;509    
;;;510    		CAN_PROTOCOL_TxAddData(0xFF);
00007e  20ff              MOVS     r0,#0xff
000080  f7fffffe          BL       CAN_PROTOCOL_TxAddData
;;;511    
;;;512    		CAN_PROTOCOL_TxAddData(0);
000084  2000              MOVS     r0,#0
000086  f7fffffe          BL       CAN_PROTOCOL_TxAddData
;;;513    
;;;514    		CAN_PROTOCOL_TxAddData(PGN);
00008a  4620              MOV      r0,r4
00008c  f7fffffe          BL       CAN_PROTOCOL_TxAddData
;;;515    
;;;516    		CAN_PROTOCOL_TxAddData(0);
000090  2000              MOVS     r0,#0
000092  f7fffffe          BL       CAN_PROTOCOL_TxAddData
;;;517    
;;;518    		CAN_PROTOCOL_TxAddFrame();
000096  e8bd47f0          POP      {r4-r10,lr}
00009a  f7ffbffe          B.W      CAN_PROTOCOL_TxAddFrame
                  |L2.158|
;;;519    		break;
;;;520    
;;;521    	// 发送PGN数据第二步:目的地址回应允许后下发对应的数据
;;;522    	case STATE_PGN_SEND_2:
;;;523    
;;;524    		for (number = 1; number <= dataNumber; number++)
;;;525    		{
;;;526    			CAN_PROTOCOL_TxAddNewFrame(0x06, 0xEB, DestAddress, SourceAddress);
00009e  4653              MOV      r3,r10
0000a0  464a              MOV      r2,r9
0000a2  21eb              MOVS     r1,#0xeb
0000a4  2006              MOVS     r0,#6
0000a6  f7fffffe          BL       CAN_PROTOCOL_TxAddNewFrame
;;;527    
;;;528    			CAN_PROTOCOL_TxAddData(number);
0000aa  4628              MOV      r0,r5
0000ac  f7fffffe          BL       CAN_PROTOCOL_TxAddData
;;;529    
;;;530    			CAN_PROTOCOL_TxAddData(canProtocolCB.sendBuff[((number - 1) * 7) + 0]);
0000b0  1e68              SUBS     r0,r5,#1
0000b2  ebc000c0          RSB      r0,r0,r0,LSL #3
0000b6  eb000408          ADD      r4,r0,r8
0000ba  f8140f8e          LDRB     r0,[r4,#0x8e]!
0000be  f7fffffe          BL       CAN_PROTOCOL_TxAddData
;;;531    
;;;532    			CAN_PROTOCOL_TxAddData(canProtocolCB.sendBuff[((number - 1) * 7) + 1]);
0000c2  7860              LDRB     r0,[r4,#1]
0000c4  f7fffffe          BL       CAN_PROTOCOL_TxAddData
;;;533    
;;;534    			CAN_PROTOCOL_TxAddData(canProtocolCB.sendBuff[((number - 1) * 7) + 2]);
0000c8  78a0              LDRB     r0,[r4,#2]
0000ca  f7fffffe          BL       CAN_PROTOCOL_TxAddData
;;;535    
;;;536    			CAN_PROTOCOL_TxAddData(canProtocolCB.sendBuff[((number - 1) * 7) + 3]);
0000ce  78e0              LDRB     r0,[r4,#3]
0000d0  f7fffffe          BL       CAN_PROTOCOL_TxAddData
;;;537    
;;;538    			CAN_PROTOCOL_TxAddData(canProtocolCB.sendBuff[((number - 1) * 7) + 4]);
0000d4  7920              LDRB     r0,[r4,#4]
0000d6  f7fffffe          BL       CAN_PROTOCOL_TxAddData
;;;539    
;;;540    			CAN_PROTOCOL_TxAddData(canProtocolCB.sendBuff[((number - 1) * 7) + 5]);
0000da  7960              LDRB     r0,[r4,#5]
0000dc  f7fffffe          BL       CAN_PROTOCOL_TxAddData
;;;541    
;;;542    			CAN_PROTOCOL_TxAddData(canProtocolCB.sendBuff[((number - 1) * 7) + 6]);
0000e0  79a0              LDRB     r0,[r4,#6]
0000e2  f7fffffe          BL       CAN_PROTOCOL_TxAddData
;;;543    
;;;544    			CAN_PROTOCOL_TxAddFrame();
0000e6  f7fffffe          BL       CAN_PROTOCOL_TxAddFrame
0000ea  1c6d              ADDS     r5,r5,#1              ;524
0000ec  b2ed              UXTB     r5,r5                 ;524
                  |L2.238|
0000ee  42b5              CMP      r5,r6                 ;524
0000f0  d9d5              BLS      |L2.158|
                  |L2.242|
;;;545    		}
;;;546    
;;;547    		break;
;;;548    	default:
;;;549    		break;
;;;550    	}
;;;551    }
0000f2  e8bd87f0          POP      {r4-r10,pc}
;;;552    
                          ENDP

0000f6  0000              DCW      0x0000
                  |L2.248|
                          DCD      ||area_number.21||

                          AREA ||i.CAN_PROTOCOL_AddSum||, CODE, READONLY, ALIGN=1

                  CAN_PROTOCOL_AddSum PROC
;;;355    // 对传入的命令帧进行校验，返回校验结果
;;;356    BOOL CAN_PROTOCOL_AddSum(uint8 *buff, uint32 len)
000000  b510              PUSH     {r4,lr}
;;;357    {
;;;358    	uint8 cc = 0;
000002  2300              MOVS     r3,#0
;;;359    	uint16 i = 0;
;;;360    
;;;361    	if (NULL == buff)
000004  2800              CMP      r0,#0
000006  d001              BEQ      |L3.12|
;;;362    	{
;;;363    		return FALSE;
;;;364    	}
;;;365    
;;;366    	// 从命令段长度开始(节点ID已经单独发送了，所以i为3)，到校验码之前的一个字节，依次进行异或运算
;;;367    	for (i = CAN_PROTOCOL_TX_CMD_LENGTH_INDEX; i < len; i++)
000008  2203              MOVS     r2,#3
00000a  e005              B        |L3.24|
                  |L3.12|
00000c  2000              MOVS     r0,#0                 ;363
;;;368    	{
;;;369    		cc ^= buff[i];
;;;370    	}
;;;371    
;;;372    	// 添加校验码
;;;373    	buff[len] = cc;
;;;374    
;;;375    	return TRUE;
;;;376    }
00000e  bd10              POP      {r4,pc}
                  |L3.16|
000010  5c84              LDRB     r4,[r0,r2]            ;369
000012  4063              EORS     r3,r3,r4              ;369
000014  1c52              ADDS     r2,r2,#1              ;367
000016  b292              UXTH     r2,r2                 ;367
                  |L3.24|
000018  428a              CMP      r2,r1                 ;367
00001a  d3f9              BCC      |L3.16|
00001c  5443              STRB     r3,[r0,r1]            ;373
00001e  2001              MOVS     r0,#1                 ;375
000020  bd10              POP      {r4,pc}
;;;377    
                          ENDP


                          AREA ||i.CAN_PROTOCOL_CheckSum||, CODE, READONLY, ALIGN=1

                  CAN_PROTOCOL_CheckSum PROC
;;;329    // 对传入的命令帧进行校验，返回校验结果
;;;330    BOOL CAN_PROTOCOL_CheckSum(uint8 *buff, uint32 len)
000000  b530              PUSH     {r4,r5,lr}
;;;331    {
;;;332    	uint8 cc = 0;
000002  2300              MOVS     r3,#0
;;;333    	uint16 i = 0;
;;;334    
;;;335    	if (NULL == buff)
000004  2800              CMP      r0,#0
000006  d002              BEQ      |L4.14|
;;;336    	{
;;;337    		return FALSE;
;;;338    	}
;;;339    
;;;340    	// 从命令段长度开始(节点ID已经在解析前去掉了，所以i为3)，到校验码之前的一个字节，依次进行异或运算
;;;341    	for (i = CAN_PROTOCOL_RX_CMD_LENGTH_INDEX; i < (len - CAN_PROTOCOL_CHECK_BYTE - CAN_PROTOCOL_TAIL_BYTE); i++)
000008  2203              MOVS     r2,#3
00000a  1e8c              SUBS     r4,r1,#2
00000c  e005              B        |L4.26|
                  |L4.14|
00000e  2000              MOVS     r0,#0                 ;337
;;;342    	{
;;;343    		cc ^= buff[i];
;;;344    	}
;;;345    
;;;346    	// 判断计算得到的校验码与命令帧中的校验码是否相同
;;;347    	if (buff[len - 2] != cc)
;;;348    	{
;;;349    		return FALSE;
;;;350    	}
;;;351    
;;;352    	return TRUE;
;;;353    }
000010  bd30              POP      {r4,r5,pc}
                  |L4.18|
000012  5c85              LDRB     r5,[r0,r2]            ;343
000014  406b              EORS     r3,r3,r5              ;343
000016  1c52              ADDS     r2,r2,#1              ;341
000018  b292              UXTH     r2,r2                 ;341
                  |L4.26|
00001a  42a2              CMP      r2,r4                 ;341
00001c  d3f9              BCC      |L4.18|
00001e  4408              ADD      r0,r0,r1              ;347
000020  f8100c02          LDRB     r0,[r0,#-2]           ;347
000024  4298              CMP      r0,r3                 ;347
000026  d001              BEQ      |L4.44|
000028  2000              MOVS     r0,#0                 ;349
00002a  bd30              POP      {r4,r5,pc}
                  |L4.44|
00002c  2001              MOVS     r0,#1                 ;352
00002e  bd30              POP      {r4,r5,pc}
;;;354    
                          ENDP


                          AREA ||i.CAN_PROTOCOL_CmdFrameProcess||, CODE, READONLY, ALIGN=2

                  CAN_PROTOCOL_CmdFrameProcess PROC
;;;261    // CAN命令帧缓冲区处理
;;;262    void CAN_PROTOCOL_CmdFrameProcess(CAN_PROTOCOL_RX *pCB)
000000  b510              PUSH     {r4,lr}
;;;263    {
000002  4604              MOV      r4,r0
;;;264    	if (pCB->head == pCB->end)
000004  8aa0              LDRH     r0,[r4,#0x14]
000006  8ae1              LDRH     r1,[r4,#0x16]
000008  4288              CMP      r0,r1
00000a  d03f              BEQ      |L5.140|
;;;265    	{
;;;266    		return;
;;;267    	}
;;;268    
;;;269    	switch (pCB->cmdQueue[pCB->head].uExtId.ExtId)
00000c  eb000080          ADD      r0,r0,r0,LSL #2
000010  eb040180          ADD      r1,r4,r0,LSL #2
000014  4a1e              LDR      r2,|L5.144|
000016  6848              LDR      r0,[r1,#4]
000018  1880              ADDS     r0,r0,r2
00001a  d006              BEQ      |L5.42|
00001c  4a1d              LDR      r2,|L5.148|
00001e  42d0              CMN      r0,r2
000020  d132              BNE      |L5.136|
;;;270    	{
;;;271    	case 0x1801FF28: // 仪表的状态
;;;272    	
;;;273    		// 升级流程是从app跳入boot开始升级
;;;274    		if (!canProtocolCB.UPDATA1) // 升级标志位
;;;275    		{
;;;276    			// 01表示当前在app
;;;277    			if (0x01 == (pCB->cmdQueue[pCB->head].Data[0] & 0x01))
;;;278    			{
;;;279    				// 如果需要升级就跳入boot
;;;280    				if (!canProtocolCB.UPDATA)
;;;281    				{
;;;282    					canProtocolCB.UPDATA = TRUE;
;;;283    					// 切换到跳入boot步骤
;;;284    					STATE_SwitchStep(STEP_GAOBIAO_CAN_UPGRADE_SEND_BOOT_CMD);
;;;285    				}
;;;286    			}
;;;287    			else // 在boot中，发送第一包升级的数据包，升级开始
;;;288    			{
;;;289    				canProtocolCB.UPDATA1 = TRUE;
;;;290    				STATE_SwitchStep(STEP_GAOBIAO_CAN_UPGRADE_ARE_YOU_READY);
;;;291    			}
;;;292    		}
;;;293    		break;
;;;294    
;;;295    	case 0x18ECF927: // 发送多包数据
;;;296    					 // 0xEF：一包132Byte数据，4个地址加128个数据。0x13：当前数据包仪表接收完成，
;;;297    		if ((0xEF == pCB->cmdQueue[pCB->head].Data[6]) && (0x13 == pCB->cmdQueue[pCB->head].Data[0]))
000022  7c48              LDRB     r0,[r1,#0x11]
000024  28ef              CMP      r0,#0xef
000026  d018              BEQ      |L5.90|
000028  e01a              B        |L5.96|
                  |L5.42|
00002a  481b              LDR      r0,|L5.152|
00002c  f8902267          LDRB     r2,[r0,#0x267]        ;274  ; canProtocolCB
000030  b9fa              CBNZ     r2,|L5.114|
000032  7ac9              LDRB     r1,[r1,#0xb]          ;277
000034  07ca              LSLS     r2,r1,#31             ;277
000036  f04f0101          MOV      r1,#1                 ;282
00003a  d008              BEQ      |L5.78|
00003c  f8902266          LDRB     r2,[r0,#0x266]        ;280  ; canProtocolCB
000040  b9ba              CBNZ     r2,|L5.114|
000042  f8801266          STRB     r1,[r0,#0x266]        ;282
000046  20ce              MOVS     r0,#0xce              ;284
000048  f7fffffe          BL       STATE_SwitchStep
00004c  e01c              B        |L5.136|
                  |L5.78|
00004e  f8801267          STRB     r1,[r0,#0x267]        ;289
000052  20cf              MOVS     r0,#0xcf              ;290
000054  f7fffffe          BL       STATE_SwitchStep
000058  e016              B        |L5.136|
                  |L5.90|
00005a  7aca              LDRB     r2,[r1,#0xb]
00005c  2a13              CMP      r2,#0x13
00005e  d002              BEQ      |L5.102|
                  |L5.96|
;;;298    		{
;;;299    			// 0x01：校验通过，发送下一个数据包
;;;300    			if (0x01 == pCB->cmdQueue[pCB->head].Data[4])
;;;301    			{
;;;302    				//				CAN_UP_DATA(1);
;;;303    				STATE_SwitchStep(STEP_GAOBIAO_CAN_UPGRADE_ARE_YOU_READY);
;;;304    			}
;;;305    			else
;;;306    			{
;;;307    				// 校验不通过
;;;308    				STATE_SwitchStep(STEP_GAOBIAO_CAN_UPGRADE_WRITE_ERROR);
;;;309    			}
;;;310    		}
;;;311    		// 升级PGN，容许发送升级数据，0x11：仪表允许工具发送数据
;;;312    		else if ((0xEF == pCB->cmdQueue[pCB->head].Data[6]) && (0x11 == pCB->cmdQueue[pCB->head].Data[0]))
000060  28ef              CMP      r0,#0xef
000062  d00b              BEQ      |L5.124|
000064  e010              B        |L5.136|
                  |L5.102|
000066  7bc8              LDRB     r0,[r1,#0xf]          ;300
000068  2801              CMP      r0,#1                 ;300
00006a  d003              BEQ      |L5.116|
00006c  20d2              MOVS     r0,#0xd2              ;308
00006e  f7fffffe          BL       STATE_SwitchStep
                  |L5.114|
000072  e009              B        |L5.136|
                  |L5.116|
000074  20cf              MOVS     r0,#0xcf              ;303
000076  f7fffffe          BL       STATE_SwitchStep
00007a  e005              B        |L5.136|
                  |L5.124|
00007c  7ac8              LDRB     r0,[r1,#0xb]
00007e  2811              CMP      r0,#0x11
000080  d102              BNE      |L5.136|
;;;313    		{
;;;314    			// STATE_PGN_SEND_2：工具发送数据
;;;315    			STATE_SwitchStep(STEP_GAOBIAO_CAN_UPGRADE_SEND_DATA);
000082  20d1              MOVS     r0,#0xd1
000084  f7fffffe          BL       STATE_SwitchStep
                  |L5.136|
;;;316    			// CAN_PGN_RequestSendData(STATE_PGN_SEND_2, pCB->cmdQueue[pCB->head].Data[6], 0x27, 0xF9);
;;;317    		}
;;;318    
;;;319    		break;
;;;320    
;;;321    	default:
;;;322    		break;
;;;323    	}
;;;324    
;;;325    	pCB->head++;
;;;326    	pCB->head %= CAN_PROTOCOL_RX_QUEUE_SIZE;
000088  2000              MOVS     r0,#0
00008a  82a0              STRH     r0,[r4,#0x14]
                  |L5.140|
;;;327    }
00008c  bd10              POP      {r4,pc}
;;;328    
                          ENDP

00008e  0000              DCW      0x0000
                  |L5.144|
                          DCD      0xe7fe00d8
                  |L5.148|
                          DCD      0xff150601
                  |L5.152|
                          DCD      ||area_number.21||

                          AREA ||i.CAN_PROTOCOL_ConfirmTempCmdFrameBuff||, CODE, READONLY, ALIGN=1

                  CAN_PROTOCOL_ConfirmTempCmdFrameBuff PROC
;;;378    // 将临时缓冲区添加到命令帧缓冲区中，其本质操作是承认临时缓冲区数据有效
;;;379    BOOL CAN_PROTOCOL_ConfirmTempCmdFrameBuff(CAN_PROTOCOL_CB *pCB, uint8 sourceSelect)
000000  2200              MOVS     r2,#0
;;;380    {
;;;381    	CAN_PROTOCOL_CMD_FRAME *pCmdFrame = NULL;
;;;382    
;;;383    	// 参数合法性检验
;;;384    	if (NULL == pCB)
000002  2800              CMP      r0,#0
000004  d009              BEQ      |L6.26|
;;;385    	{
;;;386    		return FALSE;
;;;387    	}
;;;388    
;;;389    	// 临时缓冲区为空，不予添加
;;;390    	//	pCmdFrame = &pCB->rx.rxEachNode[sourceSelect].cmdQueue[pCB->rx.rxEachNode[sourceSelect].end];
;;;391    
;;;392    	if (0 == pCmdFrame->length)
000006  8992              LDRH     r2,[r2,#0xc]
000008  b14a              CBZ      r2,|L6.30|
;;;393    	{
;;;394    		return FALSE;
;;;395    	}
;;;396    
;;;397    	// 添加
;;;398    	pCB->rx.rxEachNode[sourceSelect].end++;
00000a  eb010141          ADD      r1,r1,r1,LSL #1
00000e  eb0000c1          ADD      r0,r0,r1,LSL #3
;;;399    	pCB->rx.rxEachNode[sourceSelect].end %= CAN_PROTOCOL_RX_QUEUE_SIZE;
000012  2100              MOVS     r1,#0
000014  85c1              STRH     r1,[r0,#0x2e]
;;;400    	// 该行的作用是将新的添加位置有效数据个数清零，以便将这个位置当做临时帧缓冲区
;;;401    	//	pCB->rx.rxEachNode[sourceSelect].cmdQueue[pCB->rx.rxEachNode[sourceSelect].end].length = 0;
;;;402    
;;;403    	return TRUE;
000016  2001              MOVS     r0,#1
;;;404    }
000018  4770              BX       lr
                  |L6.26|
00001a  2000              MOVS     r0,#0                 ;386
00001c  4770              BX       lr
                  |L6.30|
00001e  2000              MOVS     r0,#0                 ;394
000020  4770              BX       lr
;;;405    
                          ENDP


                          AREA ||i.CAN_PROTOCOL_DataStructInit||, CODE, READONLY, ALIGN=2

                  CAN_PROTOCOL_DataStructInit PROC
;;;195    // 数据结构初始化
;;;196    void CAN_PROTOCOL_DataStructInit(CAN_PROTOCOL_CB *pCB)
000000  b510              PUSH     {r4,lr}
;;;197    {
;;;198    	uint16 i;
;;;199    	uint16 j;
;;;200    
;;;201    	// 参数合法性检验
;;;202    	if (NULL == pCB)
000002  2800              CMP      r0,#0
000004  d039              BEQ      |L7.122|
;;;203    	{
;;;204    		return;
;;;205    	}
;;;206    
;;;207    	pCB->tx.txBusy = FALSE;
000006  2400              MOVS     r4,#0
000008  3070              ADDS     r0,r0,#0x70
00000a  7184              STRB     r4,[r0,#6]
;;;208    	pCB->tx.index = 0;
00000c  8084              STRH     r4,[r0,#4]
;;;209    	pCB->tx.head = 0;
00000e  8004              STRH     r4,[r0,#0]
;;;210    	pCB->tx.end = 0;
000010  8044              STRH     r4,[r0,#2]
000012  3870              SUBS     r0,r0,#0x70
;;;211    	for (i = 0; i < CAN_PROTOCOL_TX_QUEUE_SIZE; i++)
000014  2100              MOVS     r1,#0
                  |L7.22|
;;;212    	{
;;;213    		pCB->tx.cmdQueue[i].length = 0;
000016  eb001201          ADD      r2,r0,r1,LSL #4
00001a  f8a2406c          STRH     r4,[r2,#0x6c]
00001e  1c49              ADDS     r1,r1,#1              ;211
000020  b289              UXTH     r1,r1                 ;211
000022  2900              CMP      r1,#0                 ;211
000024  d0f7              BEQ      |L7.22|
;;;214    	}
;;;215    
;;;216    	for (i = 0; i < CAN_PROTOCOL_DEVICE_SOURCE_ID_MAX; i++)
000026  2100              MOVS     r1,#0
                  |L7.40|
;;;217    	{
;;;218    		pCB->rxFIFO.rxFIFOEachNode[i].head = 0;
000028  eb0002c1          ADD      r2,r0,r1,LSL #3
00002c  8054              STRH     r4,[r2,#2]
;;;219    		pCB->rxFIFO.rxFIFOEachNode[i].end = 0;
00002e  8094              STRH     r4,[r2,#4]
;;;220    		pCB->rxFIFO.rxFIFOEachNode[i].currentProcessIndex = 0;
000030  80d4              STRH     r4,[r2,#6]
000032  1c49              ADDS     r1,r1,#1              ;216
000034  b289              UXTH     r1,r1                 ;216
000036  2903              CMP      r1,#3                 ;216
000038  d3f6              BCC      |L7.40|
;;;221    	}
;;;222    
;;;223    	for (i = 0; i < CAN_PROTOCOL_DEVICE_SOURCE_ID_MAX; i++)
00003a  2200              MOVS     r2,#0
                  |L7.60|
;;;224    	{
;;;225    		for (j = 0; j < CAN_PROTOCOL_RX_QUEUE_SIZE; j++)
00003c  2100              MOVS     r1,#0
                  |L7.62|
00003e  1c49              ADDS     r1,r1,#1
000040  b289              UXTH     r1,r1
000042  2900              CMP      r1,#0
000044  d0fb              BEQ      |L7.62|
;;;226    		{
;;;227    			//		pCB->rx.rxEachNode[i].cmdQueue[j].length = 0;
;;;228    		}
;;;229    		pCB->rx.rxEachNode[i].head = 0;
000046  eb020142          ADD      r1,r2,r2,LSL #1
00004a  eb0001c1          ADD      r1,r0,r1,LSL #3
00004e  858c              STRH     r4,[r1,#0x2c]
;;;230    		pCB->rx.rxEachNode[i].end = 0;
000050  85cc              STRH     r4,[r1,#0x2e]
000052  1c52              ADDS     r2,r2,#1              ;223
000054  b292              UXTH     r2,r2                 ;223
000056  2a03              CMP      r2,#3                 ;223
000058  d3f0              BCC      |L7.60|
;;;231    	}
;;;232    
;;;233    	memset(canProtocolCB.sendBuff, 0xFF, 128);
00005a  22ff              MOVS     r2,#0xff
00005c  2180              MOVS     r1,#0x80
00005e  4807              LDR      r0,|L7.124|
000060  f7fffffe          BL       __aeabi_memset
;;;234    	canProtocolCB.tripData.distance = 0;
000064  4805              LDR      r0,|L7.124|
000066  380a              SUBS     r0,r0,#0xa
000068  6004              STR      r4,[r0,#0]  ; canProtocolCB
;;;235    	canProtocolCB.tripData.times = 0;
00006a  6044              STR      r4,[r0,#4]  ; canProtocolCB
;;;236    	canProtocolCB.hmiState = 0;
00006c  f88040e6          STRB     r4,[r0,#0xe6]
;;;237    	canProtocolCB.UPDATA1 = TRUE;
000070  2101              MOVS     r1,#1
000072  f88011e3          STRB     r1,[r0,#0x1e3]
;;;238    	canProtocolCB.UPDATA = TRUE;
000076  f88011e2          STRB     r1,[r0,#0x1e2]
                  |L7.122|
;;;239    }
00007a  bd10              POP      {r4,pc}
;;;240    
                          ENDP

                  |L7.124|
                          DCD      ||area_number.21||+0x8e

                          AREA ||i.CAN_PROTOCOL_Init||, CODE, READONLY, ALIGN=2

                  CAN_PROTOCOL_Init PROC
;;;96     // CAN协议层初始化
;;;97     void CAN_PROTOCOL_Init(void)
000000  b510              PUSH     {r4,lr}
;;;98     {
;;;99     	// 协议层数据结构初始化
;;;100    	CAN_PROTOCOL_DataStructInit(&canProtocolCB);
000002  4807              LDR      r0,|L8.32|
000004  f7fffffe          BL       CAN_PROTOCOL_DataStructInit
;;;101    
;;;102    	// 向驱动层注册数据接收接口
;;;103    	//	CAN_DRIVE_RegisterDataSendService(CAN_PROTOCOL_MacProcess);
;;;104    
;;;105    	// 向驱动层注册数据发送接口
;;;106    	CAN_PROTOCOL_RegisterDataSendService(CAN_DRIVE_AddTxArray);
000008  4806              LDR      r0,|L8.36|
00000a  f7fffffe          BL       CAN_PROTOCOL_RegisterDataSendService
;;;107    
;;;108    	// 发送完毕，清空buff
;;;109    	memset(canProtocolCB.sendBuff, 0xFF, 200);
00000e  4804              LDR      r0,|L8.32|
000010  22ff              MOVS     r2,#0xff
000012  21c8              MOVS     r1,#0xc8
000014  e8bd4010          POP      {r4,lr}
000018  308e              ADDS     r0,r0,#0x8e
00001a  f7ffbffe          B.W      __aeabi_memset
;;;110    	//	TIMER_AddTask(TIMER_ID_CAN_TEST,
;;;111    	//					100,
;;;112    	//					CAN_UP_RESET,
;;;113    	//					1,
;;;114    	//					TIMER_LOOP_FOREVER,
;;;115    	//					ACTION_MODE_ADD_TO_QUEUE);
;;;116    	//	CAN_UP_RESET(1);
;;;117    }
;;;118    
                          ENDP

00001e  0000              DCW      0x0000
                  |L8.32|
                          DCD      ||area_number.21||
                  |L8.36|
                          DCD      CAN_DRIVE_AddTxArray

                          AREA ||i.CAN_PROTOCOL_MacProcess||, CODE, READONLY, ALIGN=2

                  CAN_PROTOCOL_MacProcess PROC
;;;241    // CAN 报文接收处理函数(注意根据具体模块修改)
;;;242    void CAN_PROTOCOL_MacProcess(uint32 standarID, uint8 *pData, uint8 length)
000000  b530              PUSH     {r4,r5,lr}
;;;243    {
;;;244    	uint8 i = 0;
000002  2300              MOVS     r3,#0
;;;245    
;;;246    	canProtocolRX.cmdQueue[canProtocolRX.end].uExtId.ExtId = standarID;
000004  4c0e              LDR      r4,|L9.64|
000006  8ae5              LDRH     r5,[r4,#0x16]  ; canProtocolRX
000008  eb050585          ADD      r5,r5,r5,LSL #2
00000c  eb040585          ADD      r5,r4,r5,LSL #2
000010  6068              STR      r0,[r5,#4]
000012  e00a              B        |L9.42|
                  |L9.20|
;;;247    	for (i = 0; i < length; i++)
;;;248    	{
;;;249    		canProtocolRX.cmdQueue[canProtocolRX.end].Data[i] = *pData++;
000014  8ae0              LDRH     r0,[r4,#0x16]  ; canProtocolRX
000016  f8115b01          LDRB     r5,[r1],#1
00001a  eb000080          ADD      r0,r0,r0,LSL #2
00001e  eb040080          ADD      r0,r4,r0,LSL #2
000022  4418              ADD      r0,r0,r3
000024  72c5              STRB     r5,[r0,#0xb]
000026  1c5b              ADDS     r3,r3,#1              ;247
000028  b2db              UXTB     r3,r3                 ;247
                  |L9.42|
00002a  4293              CMP      r3,r2                 ;247
00002c  d3f2              BCC      |L9.20|
;;;250    	}
;;;251    	canProtocolRX.cmdQueue[canProtocolRX.end].DLC = length;
00002e  8ae0              LDRH     r0,[r4,#0x16]  ; canProtocolRX
000030  eb000080          ADD      r0,r0,r0,LSL #2
000034  eb040080          ADD      r0,r4,r0,LSL #2
000038  7282              STRB     r2,[r0,#0xa]
;;;252    	canProtocolRX.end++;
;;;253    	canProtocolRX.end %= CAN_PROTOCOL_RX_QUEUE_SIZE;
00003a  2000              MOVS     r0,#0
00003c  82e0              STRH     r0,[r4,#0x16]
;;;254    }
00003e  bd30              POP      {r4,r5,pc}
;;;255    
                          ENDP

                  |L9.64|
                          DCD      ||area_number.21||+0x268

                          AREA ||i.CAN_PROTOCOL_Process_GB||, CODE, READONLY, ALIGN=2

                  CAN_PROTOCOL_Process_GB PROC
;;;182    // CAN协议层过程处理
;;;183    void CAN_PROTOCOL_Process_GB(void)
000000  b510              PUSH     {r4,lr}
;;;184    {
;;;185    	// CAN接收FIFO缓冲区处理
;;;186    	// CAN_PROTOCOL_RxFIFOProcess(&canProtocolCB);
;;;187    
;;;188    	// CAN接收命令缓冲区处理
;;;189    	CAN_PROTOCOL_CmdFrameProcess(&canProtocolRX);
000002  4803              LDR      r0,|L10.16|
000004  f7fffffe          BL       CAN_PROTOCOL_CmdFrameProcess
;;;190    
;;;191    	// CAN协议层发送处理过程
;;;192    	CAN_PROTOCOL_TxStateProcess();
000008  e8bd4010          POP      {r4,lr}
00000c  f7ffbffe          B.W      CAN_PROTOCOL_TxStateProcess
;;;193    }
;;;194    
                          ENDP

                  |L10.16|
                          DCD      ||area_number.21||+0x268

                          AREA ||i.CAN_PROTOCOL_RegisterDataSendService||, CODE, READONLY, ALIGN=2

                  CAN_PROTOCOL_RegisterDataSendService PROC
;;;439    // CAN协议层向驱动层注册数据发送接口
;;;440    void CAN_PROTOCOL_RegisterDataSendService(BOOL (*service)(uint32 id, uint8 *pData, uint8 length))
000000  4901              LDR      r1,|L11.8|
;;;441    {
;;;442    	canProtocolCB.sendDataThrowService = service;
000002  6788              STR      r0,[r1,#0x78]  ; canProtocolCB
;;;443    }
000004  4770              BX       lr
;;;444    
                          ENDP

000006  0000              DCW      0x0000
                  |L11.8|
                          DCD      ||area_number.21||

                          AREA ||i.CAN_PROTOCOL_RxFIFOProcess||, CODE, READONLY, ALIGN=1

                  CAN_PROTOCOL_RxFIFOProcess PROC
;;;256    // 一级报文接收缓冲区处理，从一级接收缓冲区中取出一个字节添加到命令帧缓冲区中
;;;257    void CAN_PROTOCOL_RxFIFOProcess(CAN_PROTOCOL_CB *pCB)
000000  4770              BX       lr
;;;258    {
;;;259    }
;;;260    
                          ENDP


                          AREA ||i.CAN_PROTOCOL_TxAddData||, CODE, READONLY, ALIGN=2

                  CAN_PROTOCOL_TxAddData PROC
;;;140    // 向发送命令帧队列中添加数据
;;;141    void CAN_PROTOCOL_TxAddData(uint8 data)
000000  4909              LDR      r1,|L13.40|
;;;142    {
;;;143    	uint16 head = canProtocolCB.tx.head;
000002  f8b12070          LDRH     r2,[r1,#0x70]  ; canProtocolCB
;;;144    	uint16 end = canProtocolCB.tx.end;
000006  f8b13072          LDRH     r3,[r1,#0x72]  ; canProtocolCB
;;;145    	CAN_PROTOCOL_CMD_FRAME *pCmdFrame = &canProtocolCB.tx.cmdQueue[canProtocolCB.tx.end];
00000a  eb011103          ADD      r1,r1,r3,LSL #4
00000e  3160              ADDS     r1,r1,#0x60
;;;146    
;;;147    	// 发送缓冲区已满，不予接收
;;;148    	if ((end + 1) % CAN_PROTOCOL_TX_QUEUE_SIZE == head)
000010  2a00              CMP      r2,#0
000012  d007              BEQ      |L13.36|
;;;149    	{
;;;150    		return;
;;;151    	}
;;;152    
;;;153    	// 队尾命令帧已满，退出
;;;154    	if (pCmdFrame->length >= CAN_PROTOCOL_CMD_FRAME_LENGTH_MAX)
000014  898a              LDRH     r2,[r1,#0xc]
000016  2a08              CMP      r2,#8
000018  d204              BCS      |L13.36|
;;;155    	{
;;;156    		return;
;;;157    	}
;;;158    
;;;159    	// 数据添加到帧末尾，并更新帧长度
;;;160    	pCmdFrame->buff[pCmdFrame->length] = data;
00001a  1d0b              ADDS     r3,r1,#4
00001c  54d0              STRB     r0,[r2,r3]
;;;161    	pCmdFrame->length++;
00001e  8988              LDRH     r0,[r1,#0xc]
000020  1c40              ADDS     r0,r0,#1
000022  8188              STRH     r0,[r1,#0xc]
                  |L13.36|
;;;162    }
000024  4770              BX       lr
;;;163    
                          ENDP

000026  0000              DCW      0x0000
                  |L13.40|
                          DCD      ||area_number.21||

                          AREA ||i.CAN_PROTOCOL_TxAddFrame||, CODE, READONLY, ALIGN=2

                  CAN_PROTOCOL_TxAddFrame PROC
;;;164    // 发送命令帧处理,自动扶正帧长度以及检验码
;;;165    void CAN_PROTOCOL_TxAddFrame(void)
000000  4904              LDR      r1,|L14.20|
;;;166    {
;;;167    	uint16 head = canProtocolCB.tx.head;
000002  f8b10070          LDRH     r0,[r1,#0x70]  ; canProtocolCB
;;;168    	uint16 end = canProtocolCB.tx.end;
;;;169    
;;;170    	// 发送缓冲区已满，不予接收
;;;171    	if ((end + 1) % CAN_PROTOCOL_TX_QUEUE_SIZE == head)
000006  2800              CMP      r0,#0
000008  d003              BEQ      |L14.18|
;;;172    	{
;;;173    		return;
;;;174    	}
;;;175    
;;;176    	// 发送环形队列更新位置
;;;177    	canProtocolCB.tx.end++;
;;;178    	canProtocolCB.tx.end %= CAN_PROTOCOL_TX_QUEUE_SIZE;
00000a  2000              MOVS     r0,#0
00000c  316c              ADDS     r1,r1,#0x6c
00000e  80c8              STRH     r0,[r1,#6]
;;;179    	canProtocolCB.tx.cmdQueue[canProtocolCB.tx.end].length = 0; // 2015.12.2修改
000010  8008              STRH     r0,[r1,#0]
                  |L14.18|
;;;180    }
000012  4770              BX       lr
;;;181    
                          ENDP

                  |L14.20|
                          DCD      ||area_number.21||

                          AREA ||i.CAN_PROTOCOL_TxAddNewFrame||, CODE, READONLY, ALIGN=2

                  CAN_PROTOCOL_TxAddNewFrame PROC
;;;119    // 向发送命令帧队列中添加帧源，帧目的
;;;120    void CAN_PROTOCOL_TxAddNewFrame(uint8 priority, uint16 pgn, uint8 destinationID, uint8 sourceID)
000000  b530              PUSH     {r4,r5,lr}
;;;121    {
;;;122    	CAN_PROTOCOL_CMD_FRAME *pCmdFrame = &canProtocolCB.tx.cmdQueue[canProtocolCB.tx.end];
000002  4c08              LDR      r4,|L15.36|
000004  f8b45072          LDRH     r5,[r4,#0x72]  ; canProtocolCB
000008  eb041405          ADD      r4,r4,r5,LSL #4
00000c  3460              ADDS     r4,r4,#0x60
;;;123    
;;;124    	// 帧源和帧目的超出范围
;;;125    	if ((sourceID > 0xFF) || (destinationID > 0xFF))
;;;126    	{
;;;127    		return;
;;;128    	}
;;;129    
;;;130    	// 数据添加到帧末尾，并更新帧长度
;;;131    	// pCmdFrame->deviceID = ((sourceID << 4) | destinationID);
;;;132    
;;;133    	pCmdFrame->EXTID.sDet.nHeard = 0;				   // 3bit:000
00000e  6825              LDR      r5,[r4,#0]
000010  f0254560          BIC      r5,r5,#0xe0000000
;;;134    	pCmdFrame->EXTID.sDet.priority = priority;		   // 3bit:优先级
000014  f360659c          BFI      r5,r0,#26,#3
;;;135    	pCmdFrame->EXTID.sDet.pgn = pgn;				   // 10bit:pgn
000018  f3614519          BFI      r5,r1,#16,#10
00001c  6025              STR      r5,[r4,#0]
;;;136    	pCmdFrame->EXTID.sDet.destination = destinationID; // 8bit:目的地址
00001e  7062              STRB     r2,[r4,#1]
;;;137    	pCmdFrame->EXTID.sDet.source = sourceID;		   // 8bit:源地址
000020  7023              STRB     r3,[r4,#0]
;;;138    }
000022  bd30              POP      {r4,r5,pc}
;;;139    
                          ENDP

                  |L15.36|
                          DCD      ||area_number.21||

                          AREA ||i.CAN_PROTOCOL_TxStateProcess||, CODE, READONLY, ALIGN=2

                  CAN_PROTOCOL_TxStateProcess PROC
;;;406    // 协议层发送处理过程
;;;407    void CAN_PROTOCOL_TxStateProcess(void)
000000  b570              PUSH     {r4-r6,lr}
;;;408    {
;;;409    	uint16 head = canProtocolCB.tx.head;
000002  4c0e              LDR      r4,|L16.60|
000004  f8b42070          LDRH     r2,[r4,#0x70]  ; canProtocolCB
;;;410    	uint16 end = canProtocolCB.tx.end;
000008  f8b43072          LDRH     r3,[r4,#0x72]  ; canProtocolCB
;;;411    	uint16 length = canProtocolCB.tx.cmdQueue[head].length;
00000c  eb041002          ADD      r0,r4,r2,LSL #4
000010  4605              MOV      r5,r0
000012  f8b0606c          LDRH     r6,[r0,#0x6c]
;;;412    	uint8 *pCmd = canProtocolCB.tx.cmdQueue[head].buff;
000016  f1000164          ADD      r1,r0,#0x64
;;;413    	uint32 localDeviceID = canProtocolCB.tx.cmdQueue[head].EXTID.deviceID;
00001a  6e00              LDR      r0,[r0,#0x60]
;;;414    
;;;415    	// 发送缓冲区为空，说明无数据
;;;416    	if (head == end)
00001c  429a              CMP      r2,r3
00001e  d00b              BEQ      |L16.56|
;;;417    	{
;;;418    		return;
;;;419    	}
;;;420    
;;;421    	// 发送函数没有注册直接返回
;;;422    	if (NULL == canProtocolCB.sendDataThrowService)
000020  6fa3              LDR      r3,[r4,#0x78]  ; canProtocolCB
000022  2b00              CMP      r3,#0
000024  d008              BEQ      |L16.56|
;;;423    	{
;;;424    		return;
;;;425    	}
;;;426    
;;;427    	// 协议层有数据需要发送到驱动层
;;;428    	if (!(*canProtocolCB.sendDataThrowService)(localDeviceID, pCmd, length))
000026  b2f2              UXTB     r2,r6
000028  4798              BLX      r3
00002a  2800              CMP      r0,#0
00002c  d004              BEQ      |L16.56|
;;;429    	{
;;;430    		return;
;;;431    	}
;;;432    
;;;433    	// 发送环形队列更新位置
;;;434    	canProtocolCB.tx.cmdQueue[head].length = 0;
00002e  2000              MOVS     r0,#0
000030  f8a5006c          STRH     r0,[r5,#0x6c]
;;;435    	canProtocolCB.tx.head++;
;;;436    	canProtocolCB.tx.head %= CAN_PROTOCOL_TX_QUEUE_SIZE;
000034  f8a40070          STRH     r0,[r4,#0x70]
                  |L16.56|
;;;437    }
000038  bd70              POP      {r4-r6,pc}
;;;438    
                          ENDP

00003a  0000              DCW      0x0000
                  |L16.60|
                          DCD      ||area_number.21||

                          AREA ||i.CAN_UP_DATA||, CODE, READONLY, ALIGN=2

                  CAN_UP_DATA PROC
;;;674    
;;;675    void CAN_UP_DATA(uint32 param)
000000  b510              PUSH     {r4,lr}
;;;676    {
;;;677    	dut_info.currentUiSize++;
000002  4913              LDR      r1,|L17.80|
000004  6dc8              LDR      r0,[r1,#0x5c]  ; dut_info
000006  1c40              ADDS     r0,r0,#1
000008  65c8              STR      r0,[r1,#0x5c]  ; dut_info
;;;678    	// 如果升级完成
;;;679    	if (dut_info.currentUiSize > dut_info.uiSize)
00000a  6d09              LDR      r1,[r1,#0x50]  ; dut_info
00000c  4288              CMP      r0,r1
00000e  d904              BLS      |L17.26|
;;;680    	{
;;;681    		STATE_SwitchStep(STEP_GAOBIAO_CAN_UPGRADE_FINISH);
000010  e8bd4010          POP      {r4,lr}
000014  20d3              MOVS     r0,#0xd3
000016  f7ffbffe          B.W      STATE_SwitchStep
                  |L17.26|
;;;682    		return;
;;;683    	}
;;;684    	// 向发送buff添加地址编号
;;;685    	canProtocolCB.sendBuff[0] = ((dut_info.currentUiSize >> 24) & 0xFF);
00001a  490e              LDR      r1,|L17.84|
00001c  0e02              LSRS     r2,r0,#24
00001e  700a              STRB     r2,[r1,#0]
;;;686    	canProtocolCB.sendBuff[1] = ((dut_info.currentUiSize >> 16) & 0xFF);
000020  0c02              LSRS     r2,r0,#16
000022  704a              STRB     r2,[r1,#1]
;;;687    	canProtocolCB.sendBuff[2] = ((dut_info.currentUiSize >> 8) & 0xFF);
000024  0a02              LSRS     r2,r0,#8
000026  708a              STRB     r2,[r1,#2]
;;;688    	canProtocolCB.sendBuff[3] = (dut_info.currentUiSize & 0xFF);
000028  70c8              STRB     r0,[r1,#3]
;;;689    	// 向发送buff添加数据
;;;690    	SPI_FLASH_ReadArray(&canProtocolCB.sendBuff[4], (SPI_FLASH_DUT_UI_ADDEESS + (dut_info.currentUiSize - 1) * 128), 128);
00002a  1e40              SUBS     r0,r0,#1
00002c  f44f1100          MOV      r1,#0x200000
000030  eb0111c0          ADD      r1,r1,r0,LSL #7
000034  4807              LDR      r0,|L17.84|
000036  2280              MOVS     r2,#0x80
000038  1d00              ADDS     r0,r0,#4
00003a  f7fffffe          BL       SPI_FLASH_ReadArray
;;;691    	// STATE_PGN_SEND_1：工具请求仪表接收数据
;;;692    	CAN_PGN_RequestSendData(STATE_PGN_SEND_1, 0xEF, 0x27, 0xF9);
00003e  23f9              MOVS     r3,#0xf9
000040  2227              MOVS     r2,#0x27
000042  21ef              MOVS     r1,#0xef
000044  e8bd4010          POP      {r4,lr}
000048  2001              MOVS     r0,#1
00004a  f7ffbffe          B.W      CAN_PGN_RequestSendData
;;;693    }
;;;694    
                          ENDP

00004e  0000              DCW      0x0000
                  |L17.80|
                          DCD      dut_info
                  |L17.84|
                          DCD      ||area_number.21||+0x8e

                          AREA ||i.CAN_UP_RESET||, CODE, READONLY, ALIGN=1

                  CAN_UP_RESET PROC
;;;694    
;;;695    void CAN_UP_RESET(uint32 param)
000000  b500              PUSH     {lr}
;;;696    {
;;;697    	if (1 == param)
000002  2801              CMP      r0,#1
000004  d023              BEQ      |L18.78|
;;;698    	{
;;;699    		CAN_PROTOCOL_TxAddNewFrame(0x06, 0x01, 0xFF, 0xF9);
;;;700    
;;;701    		CAN_PROTOCOL_TxAddData(0);
;;;702    
;;;703    		CAN_PROTOCOL_TxAddData(0);
;;;704    
;;;705    		CAN_PROTOCOL_TxAddData(0);
;;;706    
;;;707    		CAN_PROTOCOL_TxAddData(0);
;;;708    
;;;709    		CAN_PROTOCOL_TxAddData(0);
;;;710    
;;;711    		CAN_PROTOCOL_TxAddData(0);
;;;712    
;;;713    		CAN_PROTOCOL_TxAddData(0);
;;;714    
;;;715    		CAN_PROTOCOL_TxAddData(0);
;;;716    
;;;717    		CAN_PROTOCOL_TxAddFrame();
;;;718    	}
;;;719    	else if (2 == param)
000006  2802              CMP      r0,#2
000008  d143              BNE      |L18.146|
;;;720    	{
;;;721    		CAN_PROTOCOL_TxAddNewFrame(0x06, 0x01, 0xFF, 0xF9);
00000a  23f9              MOVS     r3,#0xf9
00000c  22ff              MOVS     r2,#0xff
00000e  2101              MOVS     r1,#1
000010  2006              MOVS     r0,#6
000012  f7fffffe          BL       CAN_PROTOCOL_TxAddNewFrame
;;;722    
;;;723    		CAN_PROTOCOL_TxAddData(0x40);
000016  2040              MOVS     r0,#0x40
000018  f7fffffe          BL       CAN_PROTOCOL_TxAddData
;;;724    
;;;725    		CAN_PROTOCOL_TxAddData(0);
00001c  2000              MOVS     r0,#0
00001e  f7fffffe          BL       CAN_PROTOCOL_TxAddData
;;;726    
;;;727    		CAN_PROTOCOL_TxAddData(0);
000022  2000              MOVS     r0,#0
000024  f7fffffe          BL       CAN_PROTOCOL_TxAddData
;;;728    
;;;729    		CAN_PROTOCOL_TxAddData(0x02);
000028  2002              MOVS     r0,#2
00002a  f7fffffe          BL       CAN_PROTOCOL_TxAddData
;;;730    
;;;731    		CAN_PROTOCOL_TxAddData(0);
00002e  2000              MOVS     r0,#0
000030  f7fffffe          BL       CAN_PROTOCOL_TxAddData
;;;732    
;;;733    		CAN_PROTOCOL_TxAddData(0);
000034  2000              MOVS     r0,#0
000036  f7fffffe          BL       CAN_PROTOCOL_TxAddData
;;;734    
;;;735    		CAN_PROTOCOL_TxAddData(0);
00003a  2000              MOVS     r0,#0
00003c  f7fffffe          BL       CAN_PROTOCOL_TxAddData
;;;736    
;;;737    		CAN_PROTOCOL_TxAddData(0);
000040  2000              MOVS     r0,#0
000042  f7fffffe          BL       CAN_PROTOCOL_TxAddData
;;;738    
;;;739    		CAN_PROTOCOL_TxAddFrame();
000046  f85deb04          POP      {lr}
00004a  f7ffbffe          B.W      CAN_PROTOCOL_TxAddFrame
                  |L18.78|
00004e  23f9              MOVS     r3,#0xf9              ;699
000050  22ff              MOVS     r2,#0xff              ;699
000052  2101              MOVS     r1,#1                 ;699
000054  2006              MOVS     r0,#6                 ;699
000056  f7fffffe          BL       CAN_PROTOCOL_TxAddNewFrame
00005a  2000              MOVS     r0,#0                 ;701
00005c  f7fffffe          BL       CAN_PROTOCOL_TxAddData
000060  2000              MOVS     r0,#0                 ;703
000062  f7fffffe          BL       CAN_PROTOCOL_TxAddData
000066  2000              MOVS     r0,#0                 ;705
000068  f7fffffe          BL       CAN_PROTOCOL_TxAddData
00006c  2000              MOVS     r0,#0                 ;707
00006e  f7fffffe          BL       CAN_PROTOCOL_TxAddData
000072  2000              MOVS     r0,#0                 ;709
000074  f7fffffe          BL       CAN_PROTOCOL_TxAddData
000078  2000              MOVS     r0,#0                 ;711
00007a  f7fffffe          BL       CAN_PROTOCOL_TxAddData
00007e  2000              MOVS     r0,#0                 ;713
000080  f7fffffe          BL       CAN_PROTOCOL_TxAddData
000084  2000              MOVS     r0,#0                 ;715
000086  f7fffffe          BL       CAN_PROTOCOL_TxAddData
00008a  f85deb04          POP      {lr}                  ;717
00008e  f7ffbffe          B.W      CAN_PROTOCOL_TxAddFrame
                  |L18.146|
;;;740    	}
;;;741    }
000092  bd00              POP      {pc}
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  canRxDriveCB
                          %        16

                          AREA ||area_number.21||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.21||, ||.bss||
                  canProtocolCB
                          %        616
                  canProtocolRX
                          %        24

;*** Start embedded assembler ***

#line 1 "User\\CanProtocolUpGB.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___17_CanProtocolUpGB_c_ac16862f____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___17_CanProtocolUpGB_c_ac16862f____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___17_CanProtocolUpGB_c_ac16862f____REVSH|
#line 128
|__asm___17_CanProtocolUpGB_c_ac16862f____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
