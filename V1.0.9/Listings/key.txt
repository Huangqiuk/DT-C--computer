; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\key.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\key.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -I.\User\qrencode -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.3\Device\Include -D__MICROLIB -D__UVISION_VERSION=539 -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\key.crf User\key.c]
                          THUMB

                          AREA ||i.KEY_CALLBACK_Scan||, CODE, READONLY, ALIGN=2

                  KEY_CALLBACK_Scan PROC
;;;48     uint8 keyRead = 0;
;;;49     void KEY_CALLBACK_Scan(uint8 *p8bitKeyValueArray)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;50     {
000004  4607              MOV      r7,r0
;;;51         uint8 keyMask = 0x07;
000006  2607              MOVS     r6,#7
;;;52     //    uint8 keyAddDecMask = 0x03;     // 加减同时按时
;;;53     //    uint8 keyAddInfo = 0x05;        // +,i同时按下
;;;54         uint8 mask = (0xFF >> (8 - KEY_FILTER_LEVEL_N)); //按键滤波的掩码
000008  2507              MOVS     r5,#7
;;;55         uint8 i;
;;;56         uint8 keyValue = 0;
00000a  2400              MOVS     r4,#0
;;;57     
;;;58         keyRead = gpio_input_bit_get(KEY_CHECK_PORT, KEY_CHECK_PIN); // 启动键
00000c  f44f5100          MOV      r1,#0x2000
000010  481c              LDR      r0,|L1.132|
000012  f7fffffe          BL       gpio_input_bit_get
000016  491c              LDR      r1,|L1.136|
000018  4602              MOV      r2,r0
00001a  7008              STRB     r0,[r1,#0]
;;;59     //  keyRead <<= 1;
;;;60     //  keyRead |= GPIO_ReadInputDataBit(GPIOA, GPIO_PIN_15);//-
;;;61     //  keyRead <<= 1;
;;;62     //  keyRead |= GPIO_ReadInputDataBit(GPIOB, GPIO_PIN_3);//+
;;;63     
;;;64         // ■■这里增加按键滤波措施■■
;;;65         // 【第一步】将读取到的按键放入缓冲区  eg:keyRead=111  变换过程
;;;66         for (i = 0; i < KEY_NAME_MAX; i++) //5-3=2  组合按键不需要在这里滤波，因此这里循环上限-1
00001c  2100              MOVS     r1,#0
;;;67         {
;;;68             // 读取到的每个按键的信息添加到对应的缓冲区里
;;;69             keyCB.buff[i] <<= 1;
00001e  4b1a              LDR      r3,|L1.136|
000020  1c5b              ADDS     r3,r3,#1
                  |L1.34|
000022  5c58              LDRB     r0,[r3,r1]
000024  0040              LSLS     r0,r0,#1
;;;70             keyCB.buff[i] |= (keyRead >> i) & 0x01;
000026  fa22fc01          LSR      r12,r2,r1
00002a  f00c0c01          AND      r12,r12,#1
00002e  ea40000c          ORR      r0,r0,r12
000032  5458              STRB     r0,[r3,r1]
000034  1c49              ADDS     r1,r1,#1              ;66
000036  b2c9              UXTB     r1,r1                 ;66
000038  2900              CMP      r1,#0                 ;66
00003a  d0f2              BEQ      |L1.34|
;;;71         }
;;;72     
;;;73         // 【第二步】缓冲区处理，连续N次读到同一个状态才确认，N可设定
;;;74         for (i = 0; i < KEY_NAME_MAX; i++)
00003c  2100              MOVS     r1,#0
;;;75         {
;;;76             // 当前按键缓冲区从低位开始连续N个均为1，判定为释放
;;;77             if ((keyCB.buff[i] & mask) == mask)
;;;78             {
;;;79                 keyCB.lastValue[i] = 0x01 << i;
00003e  f04f0c01          MOV      r12,#1
000042  4688              MOV      r8,r1
                  |L1.68|
000044  5c5a              LDRB     r2,[r3,r1]            ;77
000046  ea350002          BICS     r0,r5,r2              ;77
00004a  d010              BEQ      |L1.110|
;;;80             }
;;;81             // 从低位开始连续N个均为0，则判定为按下
;;;82             else if (0 == (keyCB.buff[i] & mask))
00004c  422a              TST      r2,r5
00004e  d102              BNE      |L1.86|
;;;83             {
;;;84                 keyCB.lastValue[i] = 0;
000050  1858              ADDS     r0,r3,r1
000052  f8808001          STRB     r8,[r0,#1]
                  |L1.86|
;;;85             }
;;;86             // 其余场景，为不稳定期，不处理
;;;87             else
;;;88             {}
;;;89     
;;;90             keyValue |= keyCB.lastValue[i];
000056  1858              ADDS     r0,r3,r1
000058  7840              LDRB     r0,[r0,#1]
00005a  4304              ORRS     r4,r4,r0
00005c  1c49              ADDS     r1,r1,#1              ;74
00005e  b2c9              UXTB     r1,r1                 ;74
000060  2900              CMP      r1,#0                 ;74
000062  d0ef              BEQ      |L1.68|
;;;91         }
;;;92     
;;;93     //  PARAM_SetKeyValue(keyRead);
;;;94     
;;;95         // 复位虚拟键为抬起状态，即没有按下
;;;96         keyValue |= 0x18;
000064  f0440418          ORR      r4,r4,#0x18
;;;97     
;;;98         // 三个按键全部释放，清除按键消息全局屏蔽请求
;;;99         if (keyMask == (keyValue & keyMask))
000068  43a6              BICS     r6,r6,r4
00006a  d005              BEQ      |L1.120|
00006c  e006              B        |L1.124|
                  |L1.110|
00006e  fa0cf001          LSL      r0,r12,r1             ;79
000072  185a              ADDS     r2,r3,r1              ;79
000074  7050              STRB     r0,[r2,#1]            ;79
000076  e7ee              B        |L1.86|
                  |L1.120|
;;;100        {
;;;101            // 清除全局屏蔽请求
;;;102            KEYMSG_ClearGlobalMaskRequest();
000078  f7fffffe          BL       KEYMSG_ClearGlobalMaskRequest
                  |L1.124|
;;;103    
;;;104    //        // 组合键引起的屏蔽+-键弹起功能，所以当按键释放后指定延时重新开启UP功能
;;;105    //        if (KEYMSG_GetAddDecKeyUpRecoveryRequest())
;;;106    //        {
;;;107    //            KEYMSG_SetAddDecKeyUpRecoveryRequest(FALSE);
;;;108    
;;;109    //            // 开启一个+-键弹起后定时器，指定时间恢复弹起功能
;;;110    //            TIMER_AddTask(TIMER_ID_RECOVERY_KEY_UP_ADD_DEC,
;;;111    //                          KEY_SCAN_TIME * 2,
;;;112    //                          KEY_CALLBACK_ClearAddDecKeyUpMaskRequest,
;;;113    //                          TRUE,
;;;114    //                          1,
;;;115    //                          ACTION_MODE_ADD_TO_QUEUE);
;;;116    //        }
;;;117    
;;;118    //        // 组合键引起的屏蔽+ i键弹起功能，所以当按键释放后指定延时重新开启UP功能
;;;119    //        if (KEYMSG_GetAddInfoKeyUpRecoveryRequest())
;;;120    //        {
;;;121    //            KEYMSG_SetAddInfoKeyUpRecoveryRequest(FALSE);
;;;122    
;;;123    //            // 开启一个+i键弹起后定时器，指定时间恢复弹起功能
;;;124    //            TIMER_AddTask(TIMER_ID_RECOVERY_KEY_UP_ADD_INFO,
;;;125    //                          KEY_SCAN_TIME * 2,
;;;126    //                          KEY_CALLBACK_ClearAddInfoKeyUpMaskRequest,
;;;127    //                          TRUE,
;;;128    //                          1,
;;;129    //                          ACTION_MODE_ADD_TO_QUEUE);
;;;130    //        }
;;;131        }
;;;132    
;;;133    //    // 检测到加减按键同时按下，根据原理图修改(bit0, +; bit1, -; bit2, i)
;;;134    //    if (0 == (keyValue & keyAddDecMask))
;;;135    //    {
;;;136    //        // 只要是组合键按下立刻允许当全部按键释放后重新恢复+-键弹起功能
;;;137    //        KEYMSG_SetAddDecKeyUpRecoveryRequest(TRUE);
;;;138    
;;;139    //        // 推车助力使能后+键的任意消息都拦截
;;;140    ////      if (PARAM_IsPushAssistOn())
;;;141    ////      {
;;;142    ////          return;
;;;143    ////      }
;;;144    
;;;145    //        // 将虚拟的按键置位
;;;146    //        keyValue &= ~KEY_MASK_ADD_DEC;
;;;147    
;;;148    //        // 消除单独的按键
;;;149    //        keyValue |= keyAddDecMask;
;;;150    
;;;151    //        // 屏蔽加键和减键的释放消息
;;;152    //        KEYMSG_SetMaskRequest(KEY_NAME_ADD, KEY_MSG_UP);
;;;153    //        KEYMSG_SetMaskRequest(KEY_NAME_DEC, KEY_MSG_UP);
;;;154    //    }
;;;155    
;;;156    //    // 检测到+,i按键同时按下，根据原理图修改(bit0, +; bit1, -; bit2, i)
;;;157    //    if (0 == (keyValue & keyAddInfo))
;;;158    //    {
;;;159    //        // 只要是组合键按下立刻允许当全部按键释放后重新恢复+-键弹起功能
;;;160    //        KEYMSG_SetAddInfoKeyUpRecoveryRequest(TRUE);
;;;161    
;;;162    //        // 将虚拟的按键置位
;;;163    //        keyValue &= ~KEY_MASK_ADD_INFO;
;;;164    
;;;165    //        // 消除单独的按键
;;;166    //        keyValue |= keyAddInfo;
;;;167    
;;;168    //        // 屏蔽加键和i键的释放消息
;;;169    //        KEYMSG_SetMaskRequest(KEY_NAME_ADD, KEY_MSG_UP);
;;;170    //        KEYMSG_SetMaskRequest(KEY_NAME_INFO, KEY_MSG_UP);
;;;171    //    }
;;;172        *p8bitKeyValueArray = keyValue;
00007c  703c              STRB     r4,[r7,#0]
;;;173    
;;;174        // 只要有按键触发就立刻重设自动关机时间
;;;175    //  if (keyValue != KEY_MASK_ALL)
;;;176    //  {
;;;177    //      // 重置自动关机任务
;;;178    //      STATE_ResetAutoPowerOffControl();
;;;179    //  }
;;;180    }
00007e  e8bd81f0          POP      {r4-r8,pc}
                          ENDP

000082  0000              DCW      0x0000
                  |L1.132|
                          DCD      0x40011000
                  |L1.136|
                          DCD      ||.data||

                          AREA ||i.KEY_Init||, CODE, READONLY, ALIGN=2

                  KEY_Init PROC
;;;9      
;;;10     void KEY_Init(void)
000000  b510              PUSH     {r4,lr}
;;;11     {
;;;12         rcu_periph_clock_enable(KEY_CHECK_RCU_PORT);
000002  f2406004          MOV      r0,#0x604
000006  f7fffffe          BL       rcu_periph_clock_enable
;;;13         gpio_init(KEY_CHECK_PORT, GPIO_MODE_IPU, GPIO_OSPEED_50MHZ, KEY_CHECK_PIN);
00000a  f44f5300          MOV      r3,#0x2000
00000e  2203              MOVS     r2,#3
000010  2148              MOVS     r1,#0x48
000012  480a              LDR      r0,|L2.60|
000014  f7fffffe          BL       gpio_init
;;;14     
;;;15         // 一定要在KEYMSG_RegisterKeyScanCallback()函数之前调用
;;;16         KEYMSG_Init();
000018  f7fffffe          BL       KEYMSG_Init
;;;17     
;;;18         // 注册按键扫描接口
;;;19         KEYMSG_RegisterKeyScanCallback(KEY_CALLBACK_Scan);
00001c  4808              LDR      r0,|L2.64|
00001e  f7fffffe          BL       KEYMSG_RegisterKeyScanCallback
;;;20     		
;;;21     		memset(keyCB.buff,      0xff, KEY_NAME_MAX);
000022  22ff              MOVS     r2,#0xff
000024  2101              MOVS     r1,#1
000026  4807              LDR      r0,|L2.68|
000028  f7fffffe          BL       __aeabi_memset
;;;22     		memset(keyCB.lastValue, 0xff, KEY_NAME_MAX);
00002c  4805              LDR      r0,|L2.68|
00002e  22ff              MOVS     r2,#0xff
000030  2101              MOVS     r1,#1
000032  e8bd4010          POP      {r4,lr}
000036  1c40              ADDS     r0,r0,#1
000038  f7ffbffe          B.W      __aeabi_memset
;;;23     		
;;;24     }
;;;25     
                          ENDP

                  |L2.60|
                          DCD      0x40011000
                  |L2.64|
                          DCD      KEY_CALLBACK_Scan
                  |L2.68|
                          DCD      ||.data||+0x1

                          AREA ||.data||, DATA, ALIGN=0

                  keyRead
000000  00                DCB      0x00
                  keyCB
000001  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "User\\key.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_key_c_KEY_Init____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___5_key_c_KEY_Init____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_key_c_KEY_Init____REVSH|
#line 128
|__asm___5_key_c_KEY_Init____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
