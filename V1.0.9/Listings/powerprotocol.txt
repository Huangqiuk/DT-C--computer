; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\powerprotocol.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\powerprotocol.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -I.\User\qrencode -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.3\Device\Include -D__MICROLIB -D__UVISION_VERSION=539 -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\powerprotocol.crf User\PowerProtocol.c]
                          THUMB

                          AREA ||i.POWER_PROTOCOL_CheckSUM||, CODE, READONLY, ALIGN=1

                  POWER_PROTOCOL_CheckSUM PROC
;;;446    // 对传入的命令帧进行校验，返回校验结果
;;;447    BOOL POWER_PROTOCOL_CheckSUM(POWER_PROTOCOL_RX_CMD_FRAME *pCmdFrame)
000000  b530              PUSH     {r4,r5,lr}
;;;448    {
;;;449        uint16 checkSum = 0;
000002  2200              MOVS     r2,#0
;;;450        uint16 sumTemp;
;;;451        uint16 i = 0;
;;;452    
;;;453        if (NULL == pCmdFrame)
000004  2800              CMP      r0,#0
000006  d004              BEQ      |L1.18|
;;;454        {
;;;455            return FALSE;
;;;456        }
;;;457    
;;;458        // 从设备地址开始，到校验码之前的一个字节，依次进行累加运算
;;;459        for (i = 1; i < pCmdFrame->length - 4; i++)
000008  2101              MOVS     r1,#1
00000a  f8b05098          LDRH     r5,[r0,#0x98]
00000e  1f2b              SUBS     r3,r5,#4
000010  e007              B        |L1.34|
                  |L1.18|
000012  2000              MOVS     r0,#0                 ;455
;;;460        {
;;;461            checkSum += pCmdFrame->buff[i];
;;;462        }
;;;463    
;;;464        // 累加和，低字节在前，高字节在后
;;;465        sumTemp = pCmdFrame->buff[pCmdFrame->length - 3]; // 高字节
;;;466        sumTemp <<= 8;
;;;467        sumTemp += pCmdFrame->buff[pCmdFrame->length - 4]; // 低字节
;;;468    
;;;469        // 判断计算得到的校验码与命令帧中的校验码是否相同
;;;470        if (sumTemp != checkSum)
;;;471        {
;;;472            return FALSE;
;;;473        }
;;;474    
;;;475        return TRUE;
;;;476    
;;;477    }
000014  bd30              POP      {r4,r5,pc}
                  |L1.22|
000016  1844              ADDS     r4,r0,r1              ;461
000018  78a4              LDRB     r4,[r4,#2]            ;461
00001a  4422              ADD      r2,r2,r4              ;461
00001c  b292              UXTH     r2,r2                 ;461
00001e  1c49              ADDS     r1,r1,#1              ;459
000020  b289              UXTH     r1,r1                 ;459
                  |L1.34|
000022  428b              CMP      r3,r1                 ;459
000024  dcf7              BGT      |L1.22|
000026  1e41              SUBS     r1,r0,#1              ;465
000028  5c69              LDRB     r1,[r5,r1]            ;465
00002a  f64f73ff          MOV      r3,#0xffff            ;466
00002e  ea032101          AND      r1,r3,r1,LSL #8       ;466
000032  1e80              SUBS     r0,r0,#2              ;467
000034  5c28              LDRB     r0,[r5,r0]            ;467
000036  4408              ADD      r0,r0,r1              ;467
000038  b280              UXTH     r0,r0                 ;467
00003a  4290              CMP      r0,r2                 ;470
00003c  d001              BEQ      |L1.66|
00003e  2000              MOVS     r0,#0                 ;472
000040  bd30              POP      {r4,r5,pc}
                  |L1.66|
000042  2001              MOVS     r0,#1                 ;475
000044  bd30              POP      {r4,r5,pc}
;;;478    
                          ENDP


                          AREA ||i.POWER_PROTOCOL_CmdFrameProcess||, CODE, READONLY, ALIGN=2

                  POWER_PROTOCOL_CmdFrameProcess PROC
;;;479    // POWER命令帧缓冲区处理
;;;480    void POWER_PROTOCOL_CmdFrameProcess(POWER_PROTOCOL_CB *pCB)
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;481    {
000004  4607              MOV      r7,r0
;;;482        POWER_PROTOCOL_CMD cmd = POWER_PROTOCOL_CMD_NULL;
;;;483        POWER_PROTOCOL_RX_CMD_FRAME *pCmdFrame = NULL;
;;;484        uint8 calibration_result = 0;
;;;485        uint16 i = 0;
000006  2500              MOVS     r5,#0
;;;486        // 我的变量
;;;487    
;;;488        // 参数合法性检验
;;;489        if (NULL == pCB)
000008  2f00              CMP      r7,#0
00000a  d016              BEQ      |L2.58|
;;;490        {
;;;491            return;
;;;492        }
;;;493    
;;;494        // 命令帧缓冲区为空，退出
;;;495        if (pCB->rx.head == pCB->rx.end)
00000c  f8b7029c          LDRH     r0,[r7,#0x29c]
000010  f8b7129e          LDRH     r1,[r7,#0x29e]
000014  4288              CMP      r0,r1
000016  d010              BEQ      |L2.58|
;;;496        {
;;;497            return;
;;;498        }
;;;499    
;;;500        // 获取当前要处理的命令帧指针
;;;501        pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.head];
000018  214d              MOVS     r1,#0x4d
00001a  4341              MULS     r1,r0,r1
00001c  eb070441          ADD      r4,r7,r1,LSL #1
000020  34ce              ADDS     r4,r4,#0xce
;;;502    
;;;503        // 命令头非法，退出
;;;504        if (POWER_PROTOCOL_CMD_HEAD != pCmdFrame->buff[POWER_PROTOCOL_CMD_HEAD_INDEX])
000022  78a1              LDRB     r1,[r4,#2]
000024  293a              CMP      r1,#0x3a
000026  d00a              BEQ      |L2.62|
;;;505        {
;;;506            // 删除命令帧
;;;507            pCB->rx.head++;
000028  1c40              ADDS     r0,r0,#1
00002a  b280              UXTH     r0,r0
;;;508            pCB->rx.head %= POWER_PROTOCOL_RX_QUEUE_SIZE;
00002c  2103              MOVS     r1,#3
00002e  fbb0f2f1          UDIV     r2,r0,r1
000032  fb010012          MLS      r0,r1,r2,r0
000036  f8a7029c          STRH     r0,[r7,#0x29c]
                  |L2.58|
;;;509            return;
;;;510        }
;;;511    
;;;512        // 命令头合法，则提取命令
;;;513        cmd = (POWER_PROTOCOL_CMD)pCmdFrame->buff[POWER_PROTOCOL_CMD_CMD_INDEX];
;;;514    
;;;515        // 执行命令帧
;;;516        switch (cmd)
;;;517        {
;;;518            case POWER_PROTOCOL_CMD_NULL:                                   // 空命令
;;;519                break;
;;;520    
;;;521            case POWER_PROTOCOL_CMD_CHECK_EXTERNAL_POWER:                   // 检测是否有外接电源接入（命令字=0x01）
;;;522                break;
;;;523    
;;;524            case POWER_PROTOCOL_CMD_GET_POWER_SUPPLY_VOLTAGE:               // 仪表供电电压获取（命令字=0x02）
;;;525                break;
;;;526    
;;;527            case POWER_PROTOCOL_CMD_GET_POWER_SUPPLY_CURRENT:               // 仪表供电电流获取（命令字=0x03）
;;;528                vout_Current.value[0] = pCmdFrame->buff[POWER_PROTOCOL_CMD_DATA1_INDEX];
;;;529                vout_Current.value[1] = pCmdFrame->buff[POWER_PROTOCOL_CMD_DATA2_INDEX];
;;;530                vout_Current.value[2] = pCmdFrame->buff[POWER_PROTOCOL_CMD_DATA3_INDEX];
;;;531                vout_Current.value[3] = pCmdFrame->buff[POWER_PROTOCOL_CMD_DATA4_INDEX];
;;;532                vout_Current.CURRENT = vout_Current.CURRENT;
;;;533                break;
;;;534    
;;;535            case POWER_PROTOCOL_CMD_ADJUST_DUT_POWER_SUPPLY_VOLTAGE:        // 调整DUT供电电压（命令字=0x04）
;;;536                calibration_result = pCmdFrame->buff[POWER_PROTOCOL_CMD_DATA1_INDEX];
;;;537                power_cnt++;
;;;538    
;;;539                // 一级校准
;;;540                if ((calibration_result) && (dut_info.cali_cnt == 1))
;;;541                {
;;;542                    if (power_cnt == 1)
;;;543                    {
;;;544                        STATE_SwitchStep(STEP_CALIBRATION_UART_TEST_NOTIFY_VOLTAGE_CALIBRATION);
;;;545                    }
;;;546                    if (power_cnt == 2)
;;;547                    {
;;;548                        STATE_SwitchStep(STEP_CALIBRATION_UART_TEST_COMPLETE);
;;;549                        power_cnt = 0;
;;;550                    }
;;;551    
;;;552                }
;;;553    
;;;554                // 二级校准
;;;555                if ((calibration_result) && (dut_info.cali_cnt == 2))
;;;556                {
;;;557    
;;;558                    if (power_cnt == 1)
;;;559                    {
;;;560                        STATE_SwitchStep(STEP_CALIBRATION_UART_TEST_NOTIFY_VOLTAGE_CALIBRATION);
;;;561                    }
;;;562                    if (power_cnt == 2)
;;;563                    {
;;;564                        STATE_SwitchStep(STEP_CALIBRATION_UART_TEST_TWO_NOTIFY_VOLTAGE_CALIBRATION);
;;;565                    }
;;;566                    if (power_cnt == 3)
;;;567                    {
;;;568                        STATE_SwitchStep(STEP_CALIBRATION_UART_TEST_COMPLETE);
;;;569                        power_cnt = 0;
;;;570                    }
;;;571    
;;;572                }
;;;573    
;;;574                // 三级校准
;;;575                if ((calibration_result) && (dut_info.cali_cnt == 3))
;;;576                {
;;;577    
;;;578                    if (power_cnt == 1)
;;;579                    {
;;;580                        STATE_SwitchStep(STEP_CALIBRATION_UART_TEST_NOTIFY_VOLTAGE_CALIBRATION);
;;;581                    }
;;;582                    if (power_cnt == 2)
;;;583                    {
;;;584                        STATE_SwitchStep(STEP_CALIBRATION_UART_TEST_TWO_NOTIFY_VOLTAGE_CALIBRATION);
;;;585                    }
;;;586                    if (power_cnt == 3)
;;;587                    {
;;;588                        STATE_SwitchStep(STEP_CALIBRATION_UART_TEST_THREE_NOTIFY_VOLTAGE_CALIBRATION);
;;;589                    }
;;;590                    if (power_cnt == 4)
;;;591                    {
;;;592                        STATE_SwitchStep(STEP_CALIBRATION_UART_TEST_COMPLETE);
;;;593                        power_cnt = 0;
;;;594                    }
;;;595                }
;;;596    
;;;597                // 调整DUT供电电压
;;;598                if ((calibration_result) && (dut_info.adjustState))
;;;599                {
;;;600                    STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_ADJUST_DUT_VOLTAGE, TRUE);
;;;601                    dut_info.adjustState = FALSE;
;;;602                    power_cnt = 0;
;;;603    
;;;604                    // vlk供电
;;;605                    VLK_PW_EN_OFF();
;;;606                }
;;;607    
;;;608                // 上报结果
;;;609                if ((!calibration_result) && (dut_info.adjustState == FALSE))
;;;610                {
;;;611                    Clear_All_Lines();
;;;612                    Display_Centered(0, "Calibration");
;;;613                    Display_Centered(1, "Power adjustment");
;;;614                    Display_Centered(2, "failure");
;;;615                    power_cnt = 0;
;;;616                    STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_VOLTAGE_CALIBRATION, FALSE);
;;;617                }
;;;618                break;
;;;619    
;;;620            // DUT电源控制
;;;621            case POWER_PROTOCOL_CMD_ADJUST_DUT_POWER_SWITCH:
;;;622                switch_cnt++;
;;;623    
;;;624                calibration_result = pCmdFrame->buff[POWER_PROTOCOL_CMD_DATA1_INDEX];
;;;625    
;;;626                // DUT电源控制
;;;627                if ((switch_cnt) && (dut_info.powerOnFlag))
;;;628                {
;;;629                    switch_cnt = 0;
;;;630                    dut_info.powerOnFlag = FALSE;
;;;631                    
;;;632    //                if(dut_info.passThroughControl)
;;;633    //                {
;;;634    //                     break;
;;;635    //                }
;;;636    //                else
;;;637    //                {
;;;638                        STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_CONTROL_DUT_POWER, TRUE);                
;;;639    //                }
;;;640                }
;;;641    
;;;642                // 仪表升级APP重启
;;;643                if ((1 == switch_cnt) && (resetFlag == TRUE)  && (configResetFlag == FALSE))
;;;644                {
;;;645                    Delayms(1000); // 延时1s,充分放电
;;;646    
;;;647                    switch (dut_info.ID)
;;;648                    {
;;;649                    case DUT_TYPE_CM:
;;;650                        if (dut_info.dutBusType)
;;;651                        {
;;;652                            STATE_SwitchStep(STEP_CM_CAN_UPGRADE_RESTART);
;;;653                        }
;;;654                        else
;;;655                        {
;;;656                            STATE_SwitchStep(STEP_CM_UART_BC_UPGRADE_RESTART);
;;;657                        }
;;;658                        break;
;;;659    
;;;660                    case DUT_TYPE_SEG:
;;;661                        if (dut_info.dutBusType)
;;;662                        {
;;;663                            STATE_SwitchStep(STEP_CM_CAN_UPGRADE_RESTART);
;;;664                        }
;;;665                        else
;;;666                        {
;;;667                            STATE_SwitchStep(STEP_CM_UART_SEG_UPGRADE_RESTART);
;;;668                        }
;;;669                        break;
;;;670    
;;;671                    default:
;;;672                        break;
;;;673                    }
;;;674                }
;;;675    
;;;676                if ((2 == switch_cnt) && (resetFlag == TRUE)  && (configResetFlag == FALSE))
;;;677                {
;;;678                    switch (dut_info.ID)
;;;679                    {
;;;680                    case DUT_TYPE_CM:
;;;681                        if (dut_info.dutBusType)
;;;682                        {
;;;683                            STATE_SwitchStep(STEP_CM_CAN_UPGRADE_WAIT_FOR_ACK);
;;;684                        }
;;;685                        else
;;;686                        {
;;;687                            STATE_SwitchStep(STEP_CM_UART_BC_UPGRADE_WAIT_FOR_ACK);
;;;688                        }
;;;689                        break;
;;;690    
;;;691                    case DUT_TYPE_SEG:
;;;692                        if (dut_info.dutBusType)
;;;693                        {
;;;694                            STATE_SwitchStep(STEP_CM_CAN_UPGRADE_RESTART);
;;;695                        }
;;;696                        else
;;;697                        {
;;;698                            STATE_SwitchStep(STEP_CM_UART_SEG_UPGRADE_WAIT_FOR_ACK);
;;;699                        }
;;;700                        break;
;;;701    
;;;702                    default:
;;;703                        break;
;;;704                    }
;;;705                    switch_cnt = 0;
;;;706                    resetFlag = FALSE;
;;;707                }
;;;708    
;;;709                // 仪表升级成功重启
;;;710                if ((appResetFlag) && (switch_cnt))
;;;711                {
;;;712                    Delayms(300); // 延时300ms，充分放电
;;;713    
;;;714                    // vlk供电
;;;715                    VLK_PW_EN_ON();
;;;716    
;;;717                    // 开启仪表电源
;;;718                    POWER_PROTOCOL_SendCmdParamAck(POWER_PROTOCOL_CMD_ADJUST_DUT_POWER_SWITCH, TRUE);
;;;719    
;;;720                    switch (dut_info.ID)
;;;721                    {
;;;722                    case DUT_TYPE_CM:
;;;723                        if (dut_info.dutBusType)
;;;724                        {
;;;725                            STATE_SwitchStep(STEP_CM_CAN_UPGRADE_WAIT_FOR_ACK);
;;;726                        }
;;;727                        else
;;;728                        {
;;;729                            STATE_SwitchStep(STEP_CM_UART_BC_UPGRADE_WAIT_FOR_ACK);
;;;730                        }
;;;731                        break;
;;;732    
;;;733                    case DUT_TYPE_SEG:
;;;734                        //                        if (dut_info.dutBusType)
;;;735                        //                        {
;;;736                        //                            STATE_SwitchStep(STEP_CM_CAN_UPGRADE_RESTART);
;;;737                        //                        }
;;;738                        //                        else
;;;739                        //                        {
;;;740                        STATE_SwitchStep(STEP_CM_UART_SEG_UPGRADE_WAIT_FOR_ACK);
;;;741                        //                        }
;;;742                        break;
;;;743    
;;;744                    default:
;;;745                        break;
;;;746                    }
;;;747                }
;;;748                if ((appResetFlag) && (2 == switch_cnt))
;;;749                {
;;;750                    switch (dut_info.ID)
;;;751                    {
;;;752                    case DUT_TYPE_CM:
;;;753                        if (dut_info.dutBusType)
;;;754                        {
;;;755                            STATE_SwitchStep(STEP_CM_CAN_UPGRADE_APP_UP_SUCCESS_YELLOW);
;;;756                        }
;;;757                        else
;;;758                        {
;;;759                            STATE_SwitchStep(STEP_CM_UART_BC_UPGRADE_WAIT_FOR_ACK);
;;;760                        }
;;;761                        break;
;;;762    
;;;763                    case DUT_TYPE_SEG:
;;;764                        //                        if (dut_info.dutBusType)
;;;765                        //                        {
;;;766                        //                            STATE_SwitchStep(STEP_CM_CAN_UPGRADE_RESTART);
;;;767                        //                        }
;;;768                        //                        else
;;;769                        //                        {
;;;770                        STATE_SwitchStep(STEP_CM_UART_SEG_UPGRADE_ITEM_FINISH);
;;;771                        //                        }
;;;772                        break;
;;;773    
;;;774                    default:
;;;775                        break;
;;;776                    }
;;;777                    appResetFlag = FALSE;
;;;778                    switch_cnt = 0;
;;;779                }
;;;780    
;;;781                // 仪表升级配置重启
;;;782                if ((1 == switch_cnt) && (resetFlag == FALSE) && (configResetFlag == TRUE))
;;;783                {
;;;784                    Delayms(1000); // 延时1s，充分放电
;;;785    
;;;786                    if (dut_info.dutBusType)
;;;787                    {
;;;788                        STATE_SwitchStep(STEP_CAN_CONFIG_RESET);
;;;789                    }
;;;790                    else
;;;791                    {
;;;792                        STATE_SwitchStep(STEP_UART_CONFIG_RESET);
;;;793                    }
;;;794                }
;;;795    
;;;796                if ((2 == switch_cnt) && (resetFlag == FALSE) && (configResetFlag == TRUE))
;;;797                {
;;;798                    if (dut_info.dutBusType)
;;;799                    {
;;;800                        STATE_SwitchStep(STEP_CM_UART_BC_UPGRADE_WAIT_FOR_ACK);
;;;801    
;;;802                        // 发送配置
;;;803                        TIMER_AddTask(TIMER_ID_SET_DUT_CONFIG,
;;;804                                      500,
;;;805                                      STATE_SwitchStep,
;;;806                                      STEP_CAN_SEND_SET_CONFIG,
;;;807                                      TIMER_LOOP_FOREVER,
;;;808                                      ACTION_MODE_ADD_TO_QUEUE);
;;;809                    }
;;;810                    else
;;;811                    {
;;;812                        TIMER_AddTask(TIMER_ID_PROTOCOL_SWITCCH,
;;;813                                      500,
;;;814                                      STATE_SwitchStep,
;;;815                                      STEP_UART_PROTOCOL_SWITCCH,
;;;816                                      TIMER_LOOP_FOREVER,
;;;817                                      ACTION_MODE_ADD_TO_QUEUE);
;;;818                    }
;;;819    
;;;820                    switch_cnt = 0;
;;;821                    configResetFlag = FALSE;
;;;822                }
;;;823                break;
;;;824    
;;;825            // 蓝牙测试
;;;826            case POWER_PROTOCOL_CMD_BLUETOOTH_CONNECT:
;;;827    
;;;828                // 测试成功
;;;829                if (pCmdFrame->buff[POWER_PROTOCOL_CMD_DATA1_INDEX])
;;;830                {
;;;831                    STS_PROTOCOL_TxAddData(STS_PROTOCOL_CMD_HEAD);
;;;832                    STS_PROTOCOL_TxAddData(STS_PROTOCOL_CMD_BLE_TEST);
;;;833                    STS_PROTOCOL_TxAddData(0x07);
;;;834                    STS_PROTOCOL_TxAddData(2);
;;;835                    STS_PROTOCOL_TxAddData(pCmdFrame->buff[POWER_PROTOCOL_CMD_DATA2_INDEX]);
;;;836                    STS_PROTOCOL_TxAddData(pCmdFrame->buff[POWER_PROTOCOL_CMD_DATA3_INDEX]);
;;;837                    STS_PROTOCOL_TxAddData(pCmdFrame->buff[POWER_PROTOCOL_CMD_DATA4_INDEX]);
;;;838                    STS_PROTOCOL_TxAddData(pCmdFrame->buff[POWER_PROTOCOL_CMD_DATA5_INDEX]);
;;;839                    STS_PROTOCOL_TxAddData(pCmdFrame->buff[POWER_PROTOCOL_CMD_DATA6_INDEX]);
;;;840                    STS_PROTOCOL_TxAddData(pCmdFrame->buff[POWER_PROTOCOL_CMD_DATA7_INDEX]);
;;;841                    
;;;842                    for(i = 0; i < 20 ;i++)
;;;843                    {
;;;844                      STS_PROTOCOL_TxAddData(dut_info.bleVerBuff[i]);
;;;845                    }
;;;846                    
;;;847                    STS_PROTOCOL_TxAddFrame();
;;;848                }
;;;849    
;;;850                // 无法连接测试失败
;;;851                if (!pCmdFrame->buff[POWER_PROTOCOL_CMD_DATA1_INDEX])
;;;852                {
;;;853                    STS_PROTOCOL_TxAddData(STS_PROTOCOL_CMD_HEAD);
;;;854                    STS_PROTOCOL_TxAddData(STS_PROTOCOL_CMD_BLE_TEST);
;;;855                    STS_PROTOCOL_TxAddData(0x07);
;;;856                    STS_PROTOCOL_TxAddData(0);
;;;857                    STS_PROTOCOL_TxAddData(pCmdFrame->buff[POWER_PROTOCOL_CMD_DATA2_INDEX]);
;;;858                    STS_PROTOCOL_TxAddData(pCmdFrame->buff[POWER_PROTOCOL_CMD_DATA3_INDEX]);
;;;859                    STS_PROTOCOL_TxAddData(pCmdFrame->buff[POWER_PROTOCOL_CMD_DATA4_INDEX]);
;;;860                    STS_PROTOCOL_TxAddData(pCmdFrame->buff[POWER_PROTOCOL_CMD_DATA5_INDEX]);
;;;861                    STS_PROTOCOL_TxAddData(pCmdFrame->buff[POWER_PROTOCOL_CMD_DATA6_INDEX]);
;;;862                    STS_PROTOCOL_TxAddData(pCmdFrame->buff[POWER_PROTOCOL_CMD_DATA7_INDEX]);
;;;863                    
;;;864                    for(i = 0; i < 20 ;i++)
;;;865                    {
;;;866                      STS_PROTOCOL_TxAddData(dut_info.bleVerBuff[i]);
;;;867                    }
;;;868                    STS_PROTOCOL_TxAddFrame();
;;;869                }
;;;870                break;
;;;871    
;;;872            // 获取POWER软件信息
;;;873            case POWER_PROTOCOL_CMD_GET_SOFTWARE_INFO:
;;;874                STS_PROTOCOL_TxAddData(STS_PROTOCOL_CMD_HEAD);
;;;875                STS_PROTOCOL_TxAddData(STS_PROTOCOL_CMD_POWER_GET_SOFTWARE_INFO);
;;;876                STS_PROTOCOL_TxAddData(6);
;;;877                STS_PROTOCOL_TxAddData(pCmdFrame->buff[POWER_PROTOCOL_CMD_DATA1_INDEX]);
;;;878                STS_PROTOCOL_TxAddData(pCmdFrame->buff[POWER_PROTOCOL_CMD_DATA2_INDEX]);
;;;879                STS_PROTOCOL_TxAddData(pCmdFrame->buff[POWER_PROTOCOL_CMD_DATA3_INDEX]);
;;;880                STS_PROTOCOL_TxAddData(pCmdFrame->buff[POWER_PROTOCOL_CMD_DATA4_INDEX]);
;;;881                STS_PROTOCOL_TxAddData(pCmdFrame->buff[POWER_PROTOCOL_CMD_DATA5_INDEX]);
;;;882                STS_PROTOCOL_TxAddData(pCmdFrame->buff[POWER_PROTOCOL_CMD_DATA6_INDEX]);
;;;883                STS_PROTOCOL_TxAddFrame();
;;;884                break;
;;;885    
;;;886            // APP2数据擦除
;;;887            case POWER_PROTOCOL_CMD_ECO_APP2_ERASE:
;;;888    
;;;889                // 上报擦除结果
;;;890                STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_POWER_UP_APP_ERASE, pCmdFrame->buff[POWER_PROTOCOL_CMD_DATA1_INDEX]);
;;;891                break;
;;;892    
;;;893            // APP2数据写入
;;;894            case POWER_PROTOCOL_CMD_ECO_APP2_WRITE:
;;;895    
;;;896                // 上报写入结果
;;;897                STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_POWER_UP_APP_WRITE, pCmdFrame->buff[POWER_PROTOCOL_CMD_DATA1_INDEX]);
;;;898                break;
;;;899    
;;;900            // APP2数据完成
;;;901            case POWER_PROTOCOL_CMD_ECO_APP_WRITE_FINISH:
;;;902    
;;;903                // 上报写入结果
;;;904                STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_POWER_UP_APP_WRITE_FINISH, pCmdFrame->buff[POWER_PROTOCOL_CMD_DATA1_INDEX]);
;;;905                break;
;;;906    
;;;907            // 重启命令
;;;908            case POWER_PROTOCOL_CMD_RST:
;;;909    
;;;910                // 上报重启结果
;;;911                STS_PROTOCOL_SendCmdParamAck(POWER_PROTOCOL_CMD_RST, pCmdFrame->buff[POWER_PROTOCOL_CMD_DATA1_INDEX]);
;;;912                break;
;;;913    
;;;914            // 升级成功上报
;;;915            case POWER_PROTOCOL_CMD_UP_FINISH:
;;;916    
;;;917                // 上报升级结果
;;;918                STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_POWER_UP_FINISH, 1);
;;;919                POWER_PROTOCOL_SendCmdAck(POWER_PROTOCOL_CMD_UP_FINISH);
;;;920                break;
;;;921    
;;;922            default:
;;;923                break;
;;;924            }
;;;925    
;;;926        // 删除命令帧
;;;927        pCB->rx.head++;
;;;928        pCB->rx.head %= POWER_PROTOCOL_RX_QUEUE_SIZE;
;;;929    }
00003a  e8bd9ffc          POP      {r2-r12,pc}
                  |L2.62|
00003e  7920              LDRB     r0,[r4,#4]            ;513
000040  f8dfa3f8          LDR      r10,|L2.1084|
000044  f8df93f8          LDR      r9,|L2.1088|
000048  4efe              LDR      r6,|L2.1092|
00004a  f04f0800          MOV      r8,#0                 ;605
00004e  2810              CMP      r0,#0x10              ;516
000050  d213              BCS      |L2.122|
000052  e8dff000          TBB      [pc,r0]               ;516
000056  1212              DCB      0x12,0x12
000058  1208139d          DCB      0x12,0x08,0x13,0x9d
00005c  ee121212          DCB      0xee,0x12,0x12,0x12
000060  edecebea          DCB      0xed,0xec,0xeb,0xea
000064  e9e8              DCB      0xe9,0xe8
000066  48f6              LDR      r0,|L2.1088|
000068  79a1              LDRB     r1,[r4,#6]            ;528
00006a  1d00              ADDS     r0,r0,#4              ;528
00006c  7001              STRB     r1,[r0,#0]            ;528
00006e  79e1              LDRB     r1,[r4,#7]            ;529
000070  7041              STRB     r1,[r0,#1]            ;529
000072  7a21              LDRB     r1,[r4,#8]            ;530
000074  7081              STRB     r1,[r0,#2]            ;530
000076  7a61              LDRB     r1,[r4,#9]            ;531
000078  70c1              STRB     r1,[r0,#3]            ;531
                  |L2.122|
00007a  e23a              B        |L2.1266|
00007c  79a4              LDRB     r4,[r4,#6]            ;536
00007e  f8990000          LDRB     r0,[r9,#0]            ;537  ; power_cnt
000082  1c40              ADDS     r0,r0,#1              ;537
000084  b2c0              UXTB     r0,r0                 ;537
000086  f8890000          STRB     r0,[r9,#0]            ;537
00008a  b18c              CBZ      r4,|L2.176|
00008c  f8961030          LDRB     r1,[r6,#0x30]         ;540  ; dut_info
000090  2901              CMP      r1,#1                 ;540
000092  d10d              BNE      |L2.176|
000094  2801              CMP      r0,#1                 ;542
000096  d102              BNE      |L2.158|
000098  2061              MOVS     r0,#0x61              ;544
00009a  f7fffffe          BL       STATE_SwitchStep
                  |L2.158|
00009e  f8990000          LDRB     r0,[r9,#0]            ;546  ; power_cnt
0000a2  2802              CMP      r0,#2                 ;546
0000a4  d104              BNE      |L2.176|
0000a6  2067              MOVS     r0,#0x67              ;548
0000a8  f7fffffe          BL       STATE_SwitchStep
0000ac  f8898000          STRB     r8,[r9,#0]            ;549
                  |L2.176|
0000b0  b1d4              CBZ      r4,|L2.232|
0000b2  f8960030          LDRB     r0,[r6,#0x30]         ;555  ; dut_info
0000b6  2802              CMP      r0,#2                 ;555
0000b8  d116              BNE      |L2.232|
0000ba  f8990000          LDRB     r0,[r9,#0]            ;558  ; power_cnt
0000be  2801              CMP      r0,#1                 ;558
0000c0  d102              BNE      |L2.200|
0000c2  2061              MOVS     r0,#0x61              ;560
0000c4  f7fffffe          BL       STATE_SwitchStep
                  |L2.200|
0000c8  f8990000          LDRB     r0,[r9,#0]            ;562  ; power_cnt
0000cc  2802              CMP      r0,#2                 ;562
0000ce  d102              BNE      |L2.214|
0000d0  2063              MOVS     r0,#0x63              ;564
0000d2  f7fffffe          BL       STATE_SwitchStep
                  |L2.214|
0000d6  f8990000          LDRB     r0,[r9,#0]            ;566  ; power_cnt
0000da  2803              CMP      r0,#3                 ;566
0000dc  d104              BNE      |L2.232|
0000de  2067              MOVS     r0,#0x67              ;568
0000e0  f7fffffe          BL       STATE_SwitchStep
0000e4  f8898000          STRB     r8,[r9,#0]            ;569
                  |L2.232|
0000e8  b30c              CBZ      r4,|L2.302|
0000ea  f8960030          LDRB     r0,[r6,#0x30]         ;575  ; dut_info
0000ee  2803              CMP      r0,#3                 ;575
0000f0  d11d              BNE      |L2.302|
0000f2  f8990000          LDRB     r0,[r9,#0]            ;578  ; power_cnt
0000f6  2801              CMP      r0,#1                 ;578
0000f8  d102              BNE      |L2.256|
0000fa  2061              MOVS     r0,#0x61              ;580
0000fc  f7fffffe          BL       STATE_SwitchStep
                  |L2.256|
000100  f8990000          LDRB     r0,[r9,#0]            ;582  ; power_cnt
000104  2802              CMP      r0,#2                 ;582
000106  d102              BNE      |L2.270|
000108  2063              MOVS     r0,#0x63              ;584
00010a  f7fffffe          BL       STATE_SwitchStep
                  |L2.270|
00010e  f8990000          LDRB     r0,[r9,#0]            ;586  ; power_cnt
000112  2803              CMP      r0,#3                 ;586
000114  d102              BNE      |L2.284|
000116  2065              MOVS     r0,#0x65              ;588
000118  f7fffffe          BL       STATE_SwitchStep
                  |L2.284|
00011c  f8990000          LDRB     r0,[r9,#0]            ;590  ; power_cnt
000120  2804              CMP      r0,#4                 ;590
000122  d104              BNE      |L2.302|
000124  2067              MOVS     r0,#0x67              ;592
000126  f7fffffe          BL       STATE_SwitchStep
00012a  f8898000          STRB     r8,[r9,#0]            ;593
                  |L2.302|
00012e  b1a4              CBZ      r4,|L2.346|
000130  f896002d          LDRB     r0,[r6,#0x2d]         ;598  ; dut_info
000134  b188              CBZ      r0,|L2.346|
000136  2101              MOVS     r1,#1                 ;600
000138  2016              MOVS     r0,#0x16              ;600
00013a  f7fffffe          BL       STS_PROTOCOL_SendCmdParamAck
00013e  f886802d          STRB     r8,[r6,#0x2d]         ;601
000142  f8898000          STRB     r8,[r9,#0]            ;602
000146  2380              MOVS     r3,#0x80              ;605
000148  2203              MOVS     r2,#3                 ;605
00014a  2110              MOVS     r1,#0x10              ;605
00014c  4650              MOV      r0,r10                ;605
00014e  f7fffffe          BL       gpio_init
000152  2180              MOVS     r1,#0x80              ;605
000154  4650              MOV      r0,r10                ;605
000156  f7fffffe          BL       gpio_bit_reset
                  |L2.346|
00015a  2c00              CMP      r4,#0                 ;609
00015c  d18d              BNE      |L2.122|
00015e  f896002d          LDRB     r0,[r6,#0x2d]         ;609  ; dut_info
000162  2800              CMP      r0,#0                 ;609
000164  d189              BNE      |L2.122|
000166  f7fffffe          BL       Clear_All_Lines
00016a  a1b7              ADR      r1,|L2.1096|
00016c  2000              MOVS     r0,#0                 ;612
00016e  f7fffffe          BL       Display_Centered
000172  a1b8              ADR      r1,|L2.1108|
000174  2001              MOVS     r0,#1                 ;613
000176  f7fffffe          BL       Display_Centered
00017a  a1bb              ADR      r1,|L2.1128|
00017c  2002              MOVS     r0,#2                 ;614
00017e  f7fffffe          BL       Display_Centered
000182  f8898000          STRB     r8,[r9,#0]            ;615
000186  2100              MOVS     r1,#0                 ;616
000188  2015              MOVS     r0,#0x15              ;616
00018a  f7fffffe          BL       STS_PROTOCOL_SendCmdParamAck
00018e  e1b0              B        |L2.1266|
000190  f8990001          LDRB     r0,[r9,#1]            ;622  ; switch_cnt
000194  1c40              ADDS     r0,r0,#1              ;622
000196  b2c0              UXTB     r0,r0                 ;622
000198  f8890001          STRB     r0,[r9,#1]            ;622
00019c  b150              CBZ      r0,|L2.436|
00019e  f896002e          LDRB     r0,[r6,#0x2e]         ;627  ; dut_info
0001a2  b138              CBZ      r0,|L2.436|
0001a4  f8898001          STRB     r8,[r9,#1]            ;629
0001a8  f886802e          STRB     r8,[r6,#0x2e]         ;630
0001ac  2101              MOVS     r1,#1                 ;638
0001ae  201a              MOVS     r0,#0x1a              ;638
0001b0  f7fffffe          BL       STS_PROTOCOL_SendCmdParamAck
                  |L2.436|
0001b4  f8990001          LDRB     r0,[r9,#1]            ;643  ; switch_cnt
0001b8  4cad              LDR      r4,|L2.1136|
0001ba  4dae              LDR      r5,|L2.1140|
0001bc  2801              CMP      r0,#1                 ;643
0001be  d123              BNE      |L2.520|
0001c0  7820              LDRB     r0,[r4,#0]            ;643  ; resetFlag
0001c2  2801              CMP      r0,#1                 ;643
0001c4  d120              BNE      |L2.520|
0001c6  7828              LDRB     r0,[r5,#0]            ;643  ; configResetFlag
0001c8  b9f0              CBNZ     r0,|L2.520|
0001ca  f44f707a          MOV      r0,#0x3e8             ;645
0001ce  f7fffffe          BL       Delayms
0001d2  7db0              LDRB     r0,[r6,#0x16]         ;647  ; dut_info
0001d4  2802              CMP      r0,#2                 ;647
0001d6  d002              BEQ      |L2.478|
0001d8  2804              CMP      r0,#4                 ;647
0001da  d115              BNE      |L2.520|
0001dc  e00a              B        |L2.500|
                  |L2.478|
0001de  7eb0              LDRB     r0,[r6,#0x1a]         ;650  ; dut_info
0001e0  b118              CBZ      r0,|L2.490|
0001e2  20d9              MOVS     r0,#0xd9              ;652
0001e4  f7fffffe          BL       STATE_SwitchStep
0001e8  e00e              B        |L2.520|
                  |L2.490|
0001ea  f44f708b          MOV      r0,#0x116             ;656
0001ee  f7fffffe          BL       STATE_SwitchStep
0001f2  e009              B        |L2.520|
                  |L2.500|
0001f4  7eb0              LDRB     r0,[r6,#0x1a]         ;661  ; dut_info
0001f6  b118              CBZ      r0,|L2.512|
0001f8  20d9              MOVS     r0,#0xd9              ;663
0001fa  f7fffffe          BL       STATE_SwitchStep
0001fe  e003              B        |L2.520|
                  |L2.512|
000200  f44f7097          MOV      r0,#0x12e             ;667
000204  f7fffffe          BL       STATE_SwitchStep
                  |L2.520|
000208  f8990001          LDRB     r0,[r9,#1]            ;676  ; switch_cnt
00020c  2802              CMP      r0,#2                 ;676
00020e  d12a              BNE      |L2.614|
000210  7820              LDRB     r0,[r4,#0]            ;676  ; resetFlag
000212  2801              CMP      r0,#1                 ;676
000214  d127              BNE      |L2.614|
000216  7828              LDRB     r0,[r5,#0]            ;676  ; configResetFlag
000218  bb28              CBNZ     r0,|L2.614|
00021a  7db0              LDRB     r0,[r6,#0x16]         ;678  ; dut_info
00021c  2802              CMP      r0,#2                 ;678
00021e  d009              BEQ      |L2.564|
000220  2804              CMP      r0,#4                 ;678
000222  d11c              BNE      |L2.606|
000224  e011              B        |L2.586|
000226  e15d              B        |L2.1252|
000228  e157              B        |L2.1242|
00022a  e151              B        |L2.1232|
00022c  e14b              B        |L2.1222|
00022e  e145              B        |L2.1212|
000230  e126              B        |L2.1152|
000232  e0ab              B        |L2.908|
                  |L2.564|
000234  7eb0              LDRB     r0,[r6,#0x1a]         ;681  ; dut_info
000236  b118              CBZ      r0,|L2.576|
000238  20d8              MOVS     r0,#0xd8              ;683
00023a  f7fffffe          BL       STATE_SwitchStep
00023e  e00e              B        |L2.606|
                  |L2.576|
000240  f44f708a          MOV      r0,#0x114             ;687
000244  f7fffffe          BL       STATE_SwitchStep
000248  e009              B        |L2.606|
                  |L2.586|
00024a  7eb0              LDRB     r0,[r6,#0x1a]         ;692  ; dut_info
00024c  b118              CBZ      r0,|L2.598|
00024e  20d9              MOVS     r0,#0xd9              ;694
000250  f7fffffe          BL       STATE_SwitchStep
000254  e003              B        |L2.606|
                  |L2.598|
000256  f240102d          MOV      r0,#0x12d             ;698
00025a  f7fffffe          BL       STATE_SwitchStep
                  |L2.606|
00025e  f8898001          STRB     r8,[r9,#1]            ;705
000262  f8848000          STRB     r8,[r4,#0]            ;706
                  |L2.614|
000266  f8dfb210          LDR      r11,|L2.1144|
00026a  f89b0000          LDRB     r0,[r11,#0]           ;710  ; appResetFlag
00026e  b1f8              CBZ      r0,|L2.688|
000270  f8990001          LDRB     r0,[r9,#1]            ;710  ; switch_cnt
000274  b1e0              CBZ      r0,|L2.688|
000276  f44f7096          MOV      r0,#0x12c             ;712
00027a  f7fffffe          BL       Delayms
00027e  2380              MOVS     r3,#0x80              ;715
000280  2203              MOVS     r2,#3                 ;715
000282  2110              MOVS     r1,#0x10              ;715
000284  4650              MOV      r0,r10                ;715
000286  f7fffffe          BL       gpio_init
00028a  2180              MOVS     r1,#0x80              ;715
00028c  4650              MOV      r0,r10                ;715
00028e  f7fffffe          BL       gpio_bit_set
000292  2101              MOVS     r1,#1                 ;718
000294  2005              MOVS     r0,#5                 ;718
000296  f7fffffe          BL       POWER_PROTOCOL_SendCmdParamAck
00029a  7db0              LDRB     r0,[r6,#0x16]         ;720  ; dut_info
00029c  2802              CMP      r0,#2                 ;720
00029e  d002              BEQ      |L2.678|
0002a0  2804              CMP      r0,#4                 ;720
0002a2  d10f              BNE      |L2.708|
0002a4  e00a              B        |L2.700|
                  |L2.678|
0002a6  7eb0              LDRB     r0,[r6,#0x1a]         ;723  ; dut_info
0002a8  b118              CBZ      r0,|L2.690|
0002aa  20d8              MOVS     r0,#0xd8              ;725
0002ac  f7fffffe          BL       STATE_SwitchStep
                  |L2.688|
0002b0  e008              B        |L2.708|
                  |L2.690|
0002b2  f44f708a          MOV      r0,#0x114             ;729
0002b6  f7fffffe          BL       STATE_SwitchStep
0002ba  e003              B        |L2.708|
                  |L2.700|
0002bc  f240102d          MOV      r0,#0x12d             ;740
0002c0  f7fffffe          BL       STATE_SwitchStep
                  |L2.708|
0002c4  f89b0000          LDRB     r0,[r11,#0]           ;748  ; appResetFlag
0002c8  b1e0              CBZ      r0,|L2.772|
0002ca  f8990001          LDRB     r0,[r9,#1]            ;748  ; switch_cnt
0002ce  2802              CMP      r0,#2                 ;748
0002d0  d118              BNE      |L2.772|
0002d2  7db0              LDRB     r0,[r6,#0x16]         ;750  ; dut_info
0002d4  2802              CMP      r0,#2                 ;750
0002d6  d002              BEQ      |L2.734|
0002d8  2804              CMP      r0,#4                 ;750
0002da  d10f              BNE      |L2.764|
0002dc  e00a              B        |L2.756|
                  |L2.734|
0002de  7eb0              LDRB     r0,[r6,#0x1a]         ;753  ; dut_info
0002e0  b118              CBZ      r0,|L2.746|
0002e2  20e1              MOVS     r0,#0xe1              ;755
0002e4  f7fffffe          BL       STATE_SwitchStep
0002e8  e008              B        |L2.764|
                  |L2.746|
0002ea  f44f708a          MOV      r0,#0x114             ;759
0002ee  f7fffffe          BL       STATE_SwitchStep
0002f2  e003              B        |L2.764|
                  |L2.756|
0002f4  f44f709b          MOV      r0,#0x136             ;770
0002f8  f7fffffe          BL       STATE_SwitchStep
                  |L2.764|
0002fc  f88b8000          STRB     r8,[r11,#0]           ;777
000300  f8898001          STRB     r8,[r9,#1]            ;778
                  |L2.772|
000304  f8990001          LDRB     r0,[r9,#1]            ;782  ; switch_cnt
000308  2801              CMP      r0,#1                 ;782
00030a  d113              BNE      |L2.820|
00030c  7820              LDRB     r0,[r4,#0]            ;782  ; resetFlag
00030e  b988              CBNZ     r0,|L2.820|
000310  7828              LDRB     r0,[r5,#0]            ;782  ; configResetFlag
000312  2801              CMP      r0,#1                 ;782
000314  d10e              BNE      |L2.820|
000316  f44f707a          MOV      r0,#0x3e8             ;784
00031a  f7fffffe          BL       Delayms
00031e  7eb0              LDRB     r0,[r6,#0x1a]         ;786  ; dut_info
000320  b120              CBZ      r0,|L2.812|
000322  f44f7087          MOV      r0,#0x10e             ;788
000326  f7fffffe          BL       STATE_SwitchStep
00032a  e003              B        |L2.820|
                  |L2.812|
00032c  f44f70a7          MOV      r0,#0x14e             ;792
000330  f7fffffe          BL       STATE_SwitchStep
                  |L2.820|
000334  f8990001          LDRB     r0,[r9,#1]            ;796  ; switch_cnt
000338  2802              CMP      r0,#2                 ;796
00033a  d126              BNE      |L2.906|
00033c  7820              LDRB     r0,[r4,#0]            ;796  ; resetFlag
00033e  2800              CMP      r0,#0                 ;796
000340  d123              BNE      |L2.906|
000342  7828              LDRB     r0,[r5,#0]            ;796  ; configResetFlag
000344  2801              CMP      r0,#1                 ;796
000346  d120              BNE      |L2.906|
000348  7eb0              LDRB     r0,[r6,#0x1a]         ;798  ; dut_info
00034a  2401              MOVS     r4,#1                 ;482
00034c  1ea6              SUBS     r6,r4,#2              ;803
00034e  f44f7afa          MOV      r10,#0x1f4            ;803
000352  b168              CBZ      r0,|L2.880|
000354  f44f708a          MOV      r0,#0x114             ;800
000358  f7fffffe          BL       STATE_SwitchStep
00035c  e9cd6400          STRD     r6,r4,[sp,#0]         ;803
000360  f240130f          MOV      r3,#0x10f             ;803
000364  4a45              LDR      r2,|L2.1148|
000366  4651              MOV      r1,r10                ;803
000368  2002              MOVS     r0,#2                 ;803
00036a  f7fffffe          BL       TIMER_AddTask
00036e  e008              B        |L2.898|
                  |L2.880|
000370  e9cd6400          STRD     r6,r4,[sp,#0]         ;812
000374  f240134f          MOV      r3,#0x14f             ;812
000378  4a40              LDR      r2,|L2.1148|
00037a  4651              MOV      r1,r10                ;812
00037c  2016              MOVS     r0,#0x16              ;812
00037e  f7fffffe          BL       TIMER_AddTask
                  |L2.898|
000382  f8898001          STRB     r8,[r9,#1]            ;820
000386  f8858000          STRB     r8,[r5,#0]            ;821
                  |L2.906|
00038a  e0b2              B        |L2.1266|
                  |L2.908|
00038c  79a0              LDRB     r0,[r4,#6]            ;829
00038e  b340              CBZ      r0,|L2.994|
000390  2055              MOVS     r0,#0x55              ;831
000392  f7fffffe          BL       STS_PROTOCOL_TxAddData
000396  200c              MOVS     r0,#0xc               ;832
000398  f7fffffe          BL       STS_PROTOCOL_TxAddData
00039c  2007              MOVS     r0,#7                 ;833
00039e  f7fffffe          BL       STS_PROTOCOL_TxAddData
0003a2  2002              MOVS     r0,#2                 ;834
0003a4  f7fffffe          BL       STS_PROTOCOL_TxAddData
0003a8  79e0              LDRB     r0,[r4,#7]            ;835
0003aa  f7fffffe          BL       STS_PROTOCOL_TxAddData
0003ae  7a20              LDRB     r0,[r4,#8]            ;836
0003b0  f7fffffe          BL       STS_PROTOCOL_TxAddData
0003b4  7a60              LDRB     r0,[r4,#9]            ;837
0003b6  f7fffffe          BL       STS_PROTOCOL_TxAddData
0003ba  7aa0              LDRB     r0,[r4,#0xa]          ;838
0003bc  f7fffffe          BL       STS_PROTOCOL_TxAddData
0003c0  7ae0              LDRB     r0,[r4,#0xb]          ;839
0003c2  f7fffffe          BL       STS_PROTOCOL_TxAddData
0003c6  7b20              LDRB     r0,[r4,#0xc]          ;840
0003c8  f7fffffe          BL       STS_PROTOCOL_TxAddData
                  |L2.972|
0003cc  1970              ADDS     r0,r6,r5              ;844
0003ce  f890010c          LDRB     r0,[r0,#0x10c]        ;844
0003d2  f7fffffe          BL       STS_PROTOCOL_TxAddData
0003d6  1c6d              ADDS     r5,r5,#1              ;842
0003d8  b2ad              UXTH     r5,r5                 ;842
0003da  2d14              CMP      r5,#0x14              ;842
0003dc  d3f6              BCC      |L2.972|
0003de  f7fffffe          BL       STS_PROTOCOL_TxAddFrame
                  |L2.994|
0003e2  79a0              LDRB     r0,[r4,#6]            ;851
0003e4  bb48              CBNZ     r0,|L2.1082|
0003e6  2055              MOVS     r0,#0x55              ;853
0003e8  f7fffffe          BL       STS_PROTOCOL_TxAddData
0003ec  200c              MOVS     r0,#0xc               ;854
0003ee  f7fffffe          BL       STS_PROTOCOL_TxAddData
0003f2  2007              MOVS     r0,#7                 ;855
0003f4  f7fffffe          BL       STS_PROTOCOL_TxAddData
0003f8  2000              MOVS     r0,#0                 ;856
0003fa  f7fffffe          BL       STS_PROTOCOL_TxAddData
0003fe  79e0              LDRB     r0,[r4,#7]            ;857
000400  f7fffffe          BL       STS_PROTOCOL_TxAddData
000404  7a20              LDRB     r0,[r4,#8]            ;858
000406  f7fffffe          BL       STS_PROTOCOL_TxAddData
00040a  7a60              LDRB     r0,[r4,#9]            ;859
00040c  f7fffffe          BL       STS_PROTOCOL_TxAddData
000410  7aa0              LDRB     r0,[r4,#0xa]          ;860
000412  f7fffffe          BL       STS_PROTOCOL_TxAddData
000416  7ae0              LDRB     r0,[r4,#0xb]          ;861
000418  f7fffffe          BL       STS_PROTOCOL_TxAddData
00041c  7b20              LDRB     r0,[r4,#0xc]          ;862
00041e  f7fffffe          BL       STS_PROTOCOL_TxAddData
000422  2400              MOVS     r4,#0                 ;864
                  |L2.1060|
000424  1930              ADDS     r0,r6,r4              ;866
000426  f890010c          LDRB     r0,[r0,#0x10c]        ;866
00042a  f7fffffe          BL       STS_PROTOCOL_TxAddData
00042e  1c64              ADDS     r4,r4,#1              ;864
000430  b2a4              UXTH     r4,r4                 ;864
000432  2c14              CMP      r4,#0x14              ;864
000434  d3f6              BCC      |L2.1060|
000436  f7fffffe          BL       STS_PROTOCOL_TxAddFrame
                  |L2.1082|
00043a  e05a              B        |L2.1266|
                  |L2.1084|
                          DCD      0x40010c00
                  |L2.1088|
                          DCD      ||.data||
                  |L2.1092|
                          DCD      dut_info
                  |L2.1096|
000448  43616c69          DCB      "Calibration",0
00044c  62726174
000450  696f6e00
                  |L2.1108|
000454  506f7765          DCB      "Power adjustment",0
000458  72206164
00045c  6a757374
000460  6d656e74
000464  00      
000465  00                DCB      0
000466  00                DCB      0
000467  00                DCB      0
                  |L2.1128|
000468  6661696c          DCB      "failure",0
00046c  75726500
                  |L2.1136|
                          DCD      resetFlag
                  |L2.1140|
                          DCD      configResetFlag
                  |L2.1144|
                          DCD      appResetFlag
                  |L2.1148|
                          DCD      STATE_SwitchStep
                  |L2.1152|
000480  2055              MOVS     r0,#0x55              ;874
000482  f7fffffe          BL       STS_PROTOCOL_TxAddData
000486  2035              MOVS     r0,#0x35              ;875
000488  f7fffffe          BL       STS_PROTOCOL_TxAddData
00048c  2006              MOVS     r0,#6                 ;876
00048e  f7fffffe          BL       STS_PROTOCOL_TxAddData
000492  79a0              LDRB     r0,[r4,#6]            ;877
000494  f7fffffe          BL       STS_PROTOCOL_TxAddData
000498  79e0              LDRB     r0,[r4,#7]            ;878
00049a  f7fffffe          BL       STS_PROTOCOL_TxAddData
00049e  7a20              LDRB     r0,[r4,#8]            ;879
0004a0  f7fffffe          BL       STS_PROTOCOL_TxAddData
0004a4  7a60              LDRB     r0,[r4,#9]            ;880
0004a6  f7fffffe          BL       STS_PROTOCOL_TxAddData
0004aa  7aa0              LDRB     r0,[r4,#0xa]          ;881
0004ac  f7fffffe          BL       STS_PROTOCOL_TxAddData
0004b0  7ae0              LDRB     r0,[r4,#0xb]          ;882
0004b2  f7fffffe          BL       STS_PROTOCOL_TxAddData
0004b6  f7fffffe          BL       STS_PROTOCOL_TxAddFrame
0004ba  e01a              B        |L2.1266|
                  |L2.1212|
0004bc  79a1              LDRB     r1,[r4,#6]            ;890
0004be  2036              MOVS     r0,#0x36              ;890
0004c0  f7fffffe          BL       STS_PROTOCOL_SendCmdParamAck
0004c4  e015              B        |L2.1266|
                  |L2.1222|
0004c6  79a1              LDRB     r1,[r4,#6]            ;897
0004c8  2037              MOVS     r0,#0x37              ;897
0004ca  f7fffffe          BL       STS_PROTOCOL_SendCmdParamAck
0004ce  e010              B        |L2.1266|
                  |L2.1232|
0004d0  79a1              LDRB     r1,[r4,#6]            ;904
0004d2  2038              MOVS     r0,#0x38              ;904
0004d4  f7fffffe          BL       STS_PROTOCOL_SendCmdParamAck
0004d8  e00b              B        |L2.1266|
                  |L2.1242|
0004da  79a1              LDRB     r1,[r4,#6]            ;911
0004dc  200e              MOVS     r0,#0xe               ;911
0004de  f7fffffe          BL       STS_PROTOCOL_SendCmdParamAck
0004e2  e006              B        |L2.1266|
                  |L2.1252|
0004e4  2101              MOVS     r1,#1                 ;918
0004e6  2039              MOVS     r0,#0x39              ;918
0004e8  f7fffffe          BL       STS_PROTOCOL_SendCmdParamAck
0004ec  200f              MOVS     r0,#0xf               ;919
0004ee  f7fffffe          BL       POWER_PROTOCOL_SendCmdAck
                  |L2.1266|
0004f2  f8b7029c          LDRH     r0,[r7,#0x29c]        ;927
0004f6  1c40              ADDS     r0,r0,#1              ;927
0004f8  b280              UXTH     r0,r0                 ;927
0004fa  2103              MOVS     r1,#3                 ;928
0004fc  fbb0f2f1          UDIV     r2,r0,r1              ;928
000500  fb010012          MLS      r0,r1,r2,r0           ;928
000504  f8a7029c          STRH     r0,[r7,#0x29c]        ;928
000508  e597              B        |L2.58|
;;;930    
                          ENDP


                          AREA ||i.POWER_PROTOCOL_ConfirmTempCmdFrameBuff||, CODE, READONLY, ALIGN=1

                  POWER_PROTOCOL_ConfirmTempCmdFrameBuff PROC
;;;228    // 将临时缓冲区添加到命令帧缓冲区中，其本质操作是承认临时缓冲区数据有效
;;;229    BOOL POWER_PROTOCOL_ConfirmTempCmdFrameBuff(POWER_PROTOCOL_CB *pCB)
000000  2800              CMP      r0,#0
;;;230    {
000002  d01a              BEQ      |L3.58|
;;;231        POWER_PROTOCOL_RX_CMD_FRAME *pCmdFrame = NULL;
;;;232    
;;;233        // 参数合法性检验
;;;234        if (NULL == pCB)
;;;235        {
;;;236            return FALSE;
;;;237        }
;;;238    
;;;239        // 临时缓冲区为空，不予添加
;;;240        pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.end];
000004  f8b0129e          LDRH     r1,[r0,#0x29e]
000008  224d              MOVS     r2,#0x4d
00000a  434a              MULS     r2,r1,r2
00000c  eb000242          ADD      r2,r0,r2,LSL #1
;;;241        if (0 == pCmdFrame->length)
000010  f8b22166          LDRH     r2,[r2,#0x166]
000014  b19a              CBZ      r2,|L3.62|
;;;242        {
;;;243            return FALSE;
;;;244        }
;;;245    
;;;246        // 添加
;;;247        pCB->rx.end++;
000016  1c49              ADDS     r1,r1,#1
000018  b289              UXTH     r1,r1
;;;248        pCB->rx.end %= POWER_PROTOCOL_RX_QUEUE_SIZE;
00001a  2203              MOVS     r2,#3
00001c  fbb1f3f2          UDIV     r3,r1,r2
000020  fb021113          MLS      r1,r2,r3,r1
000024  f8a0129e          STRH     r1,[r0,#0x29e]
;;;249        pCB->rx.cmdQueue[pCB->rx.end].length = 0; // 该行的作用是将新的添加位置有效数据个数清零，以便将这个位置当做临时帧缓冲区
000028  2200              MOVS     r2,#0
00002a  234d              MOVS     r3,#0x4d
00002c  4359              MULS     r1,r3,r1
00002e  eb000041          ADD      r0,r0,r1,LSL #1
000032  f8a02166          STRH     r2,[r0,#0x166]
;;;250    
;;;251        return TRUE;
000036  2001              MOVS     r0,#1
;;;252    }
000038  4770              BX       lr
                  |L3.58|
00003a  2000              MOVS     r0,#0                 ;236
00003c  4770              BX       lr
                  |L3.62|
00003e  2000              MOVS     r0,#0                 ;243
000040  4770              BX       lr
;;;253    
                          ENDP


                          AREA ||i.POWER_PROTOCOL_DataStructInit||, CODE, READONLY, ALIGN=1

                  POWER_PROTOCOL_DataStructInit PROC
;;;163    // 数据结构初始化
;;;164    void POWER_PROTOCOL_DataStructInit(POWER_PROTOCOL_CB *pCB)
000000  2800              CMP      r0,#0
;;;165    {
000002  d029              BEQ      |L4.88|
;;;166        uint16 i;
;;;167    
;;;168        // 参数合法性检验
;;;169        if (NULL == pCB)
;;;170        {
;;;171            return;
;;;172        }
;;;173    
;;;174        pCB->tx.txBusy = FALSE;
000004  2200              MOVS     r2,#0
000006  f8802474          STRB     r2,[r0,#0x474]
;;;175        pCB->tx.index = 0;
00000a  f8a02472          STRH     r2,[r0,#0x472]
;;;176        pCB->tx.head = 0;
00000e  f8a0246e          STRH     r2,[r0,#0x46e]
;;;177        pCB->tx.end = 0;
000012  f8a02470          STRH     r2,[r0,#0x470]
;;;178        for (i = 0; i < POWER_PROTOCOL_TX_QUEUE_SIZE; i++)
000016  2100              MOVS     r1,#0
                  |L4.24|
;;;179        {
;;;180            pCB->tx.cmdQueue[i].length = 0;
000018  234d              MOVS     r3,#0x4d
00001a  434b              MULS     r3,r1,r3
00001c  eb000343          ADD      r3,r0,r3,LSL #1
000020  f8a32338          STRH     r2,[r3,#0x338]
000024  1c49              ADDS     r1,r1,#1              ;178
000026  b289              UXTH     r1,r1                 ;178
000028  2903              CMP      r1,#3                 ;178
00002a  d3f5              BCC      |L4.24|
;;;181        }
;;;182    
;;;183        pCB->rxFIFO.head = 0;
00002c  f8202fc8          STRH     r2,[r0,#0xc8]!
;;;184        pCB->rxFIFO.end = 0;
000030  8042              STRH     r2,[r0,#2]
;;;185        pCB->rxFIFO.currentProcessIndex = 0;
000032  8082              STRH     r2,[r0,#4]
;;;186    
;;;187        pCB->rx.head = 0;
000034  f8a021d4          STRH     r2,[r0,#0x1d4]
;;;188        pCB->rx.end = 0;
000038  f8a021d6          STRH     r2,[r0,#0x1d6]
00003c  38c8              SUBS     r0,r0,#0xc8
;;;189        for (i = 0; i < POWER_PROTOCOL_RX_QUEUE_SIZE; i++)
00003e  2100              MOVS     r1,#0
                  |L4.64|
;;;190        {
;;;191            pCB->rx.cmdQueue[i].length = 0;
000040  234d              MOVS     r3,#0x4d
000042  434b              MULS     r3,r1,r3
000044  eb000343          ADD      r3,r0,r3,LSL #1
000048  f8a32166          STRH     r2,[r3,#0x166]
00004c  1c49              ADDS     r1,r1,#1              ;189
00004e  b289              UXTH     r1,r1                 ;189
000050  2903              CMP      r1,#3                 ;189
000052  d3f5              BCC      |L4.64|
;;;192        }
;;;193    
;;;194        pCB->isTimeCheck = FALSE;
000054  f8802480          STRB     r2,[r0,#0x480]
                  |L4.88|
;;;195    }
000058  4770              BX       lr
;;;196    
                          ENDP


                          AREA ||i.POWER_PROTOCOL_Init||, CODE, READONLY, ALIGN=2

                  POWER_PROTOCOL_Init PROC
;;;56     // 协议初始化
;;;57     void POWER_PROTOCOL_Init(void)
000000  b510              PUSH     {r4,lr}
;;;58     {
;;;59         // 协议层数据结构初始化
;;;60         POWER_PROTOCOL_DataStructInit(&POWERProtocolCB);
000002  4805              LDR      r0,|L5.24|
000004  f7fffffe          BL       POWER_PROTOCOL_DataStructInit
;;;61     
;;;62         // 向驱动层注册数据接收接口
;;;63         POWER_UART_RegisterDataSendService(POWER_PROTOCOL_MacProcess);
000008  4804              LDR      r0,|L5.28|
00000a  f7fffffe          BL       POWER_UART_RegisterDataSendService
;;;64     
;;;65         // 向驱动层注册数据发送接口
;;;66         POWER_PROTOCOL_RegisterDataSendService(POWER_UART_AddTxArray);
00000e  e8bd4010          POP      {r4,lr}
000012  4803              LDR      r0,|L5.32|
000014  f7ffbffe          B.W      POWER_PROTOCOL_RegisterDataSendService
;;;67     }
;;;68     
                          ENDP

                  |L5.24|
                          DCD      ||.bss||
                  |L5.28|
                          DCD      POWER_PROTOCOL_MacProcess
                  |L5.32|
                          DCD      POWER_UART_AddTxArray

                          AREA ||i.POWER_PROTOCOL_MacProcess||, CODE, READONLY, ALIGN=2

                  POWER_PROTOCOL_MacProcess PROC
;;;197    // UART报文接收处理函数(注意根据具体模块修改)
;;;198    void POWER_PROTOCOL_MacProcess(uint16 standarID, uint8 *pData, uint16 length)
000000  b570              PUSH     {r4-r6,lr}
;;;199    {
;;;200        uint16 end = POWERProtocolCB.rxFIFO.end;
000002  480d              LDR      r0,|L6.56|
000004  f8b020ca          LDRH     r2,[r0,#0xca]  ; POWERProtocolCB
;;;201        uint16 head = POWERProtocolCB.rxFIFO.head;
000008  f8b040c8          LDRH     r4,[r0,#0xc8]  ; POWERProtocolCB
;;;202        uint8 rxdata = 0x00;
;;;203    
;;;204        // 接收数据
;;;205        rxdata = *pData;
00000c  780d              LDRB     r5,[r1,#0]
;;;206    
;;;207        // 一级缓冲区已满，不予接收
;;;208        if ((end + 1) % POWER_PROTOCOL_RX_FIFO_SIZE == head)
00000e  1c53              ADDS     r3,r2,#1
000010  21c8              MOVS     r1,#0xc8
000012  fbb3f6f1          UDIV     r6,r3,r1
000016  fb013316          MLS      r3,r1,r6,r3
00001a  42a3              CMP      r3,r4
00001c  d00a              BEQ      |L6.52|
;;;209        {
;;;210            return;
;;;211        }
;;;212        // 一级缓冲区未满，接收
;;;213        else
;;;214        {
;;;215            // 将接收到的数据放到临时缓冲区中
;;;216            POWERProtocolCB.rxFIFO.buff[end] = rxdata;
00001e  5485              STRB     r5,[r0,r2]
;;;217            POWERProtocolCB.rxFIFO.end++;
000020  f8302fca          LDRH     r2,[r0,#0xca]!  ; POWERProtocolCB
000024  1c52              ADDS     r2,r2,#1
000026  8002              STRH     r2,[r0,#0]
;;;218            POWERProtocolCB.rxFIFO.end %= POWER_PROTOCOL_RX_FIFO_SIZE;
000028  8802              LDRH     r2,[r0,#0]  ; POWERProtocolCB
00002a  fbb2f3f1          UDIV     r3,r2,r1
00002e  fb012113          MLS      r1,r1,r3,r2
000032  8001              STRH     r1,[r0,#0]
                  |L6.52|
;;;219        }
;;;220    }
000034  bd70              POP      {r4-r6,pc}
;;;221    
                          ENDP

000036  0000              DCW      0x0000
                  |L6.56|
                          DCD      ||.bss||

                          AREA ||i.POWER_PROTOCOL_Process||, CODE, READONLY, ALIGN=2

                  POWER_PROTOCOL_Process PROC
;;;69     // POWER协议层过程处理
;;;70     void POWER_PROTOCOL_Process(void)
000000  b510              PUSH     {r4,lr}
;;;71     {
;;;72         // POWER接收FIFO缓冲区处理
;;;73         POWER_PROTOCOL_RxFIFOProcess(&POWERProtocolCB);
000002  4805              LDR      r0,|L7.24|
000004  f7fffffe          BL       POWER_PROTOCOL_RxFIFOProcess
;;;74     
;;;75         // POWER接收命令缓冲区处理
;;;76         POWER_PROTOCOL_CmdFrameProcess(&POWERProtocolCB);
000008  4803              LDR      r0,|L7.24|
00000a  f7fffffe          BL       POWER_PROTOCOL_CmdFrameProcess
;;;77     
;;;78         // POWER协议层发送处理过程
;;;79         POWER_PROTOCOL_TxStateProcess();
00000e  e8bd4010          POP      {r4,lr}
000012  f7ffbffe          B.W      POWER_PROTOCOL_TxStateProcess
;;;80     }
;;;81     
                          ENDP

000016  0000              DCW      0x0000
                  |L7.24|
                          DCD      ||.bss||

                          AREA ||i.POWER_PROTOCOL_RegisterDataSendService||, CODE, READONLY, ALIGN=2

                  POWER_PROTOCOL_RegisterDataSendService PROC
;;;222    // UART协议层向驱动层注册数据发送接口
;;;223    void POWER_PROTOCOL_RegisterDataSendService(BOOL (*service)(uint16 id, uint8 *pData, uint16 length))
000000  4901              LDR      r1,|L8.8|
;;;224    {
;;;225        POWERProtocolCB.sendDataThrowService = service;
000002  f8c10478          STR      r0,[r1,#0x478]  ; POWERProtocolCB
;;;226    }
000006  4770              BX       lr
;;;227    
                          ENDP

                  |L8.8|
                          DCD      ||.bss||

                          AREA ||i.POWER_PROTOCOL_RxFIFOProcess||, CODE, READONLY, ALIGN=1

                  POWER_PROTOCOL_RxFIFOProcess PROC
;;;287    // 一级接收缓冲区处理，从一级接收缓冲区中取出一个字节添加到命令帧缓冲区中
;;;288    void POWER_PROTOCOL_RxFIFOProcess(POWER_PROTOCOL_CB *pCB)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;289    {
000004  4604              MOV      r4,r0
;;;290        uint16 end = pCB->rxFIFO.end;
000006  f8b410ca          LDRH     r1,[r4,#0xca]
;;;291        uint16 head = pCB->rxFIFO.head;
00000a  f8b400c8          LDRH     r0,[r4,#0xc8]
;;;292        POWER_PROTOCOL_RX_CMD_FRAME *pCmdFrame = NULL;
;;;293        uint16 length = 0;
;;;294        uint8 currentData = 0;
;;;295    
;;;296        // 参数合法性检验
;;;297        if (NULL == pCB)
00000e  2c00              CMP      r4,#0
000010  d021              BEQ      |L9.86|
;;;298        {
;;;299            return;
;;;300        }
;;;301    
;;;302        // 一级缓冲区为空，退出
;;;303        if (head == end)
000012  4288              CMP      r0,r1
000014  d01f              BEQ      |L9.86|
;;;304        {
;;;305            return;
;;;306        }
;;;307    
;;;308        // 获取临时缓冲区指针
;;;309        pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.end];
000016  f8b4229e          LDRH     r2,[r4,#0x29e]
00001a  204d              MOVS     r0,#0x4d
00001c  4350              MULS     r0,r2,r0
00001e  eb040540          ADD      r5,r4,r0,LSL #1
000022  35ce              ADDS     r5,r5,#0xce
;;;310        // 取出当前要处理的字节
;;;311        currentData = pCB->rxFIFO.buff[pCB->rxFIFO.currentProcessIndex];
000024  f8b400cc          LDRH     r0,[r4,#0xcc]
000028  5c20              LDRB     r0,[r4,r0]
;;;312    
;;;313        // 临时缓冲区长度为0时，搜索首字节
;;;314        if (0 == pCmdFrame->length)
00002a  f8b53098          LDRH     r3,[r5,#0x98]
;;;315        {
;;;316            // 命令头错误，删除当前字节并退出
;;;317            if (POWER_PROTOCOL_CMD_HEAD != currentData)
;;;318            {
;;;319                pCB->rxFIFO.head++;
;;;320                pCB->rxFIFO.head %= POWER_PROTOCOL_RX_FIFO_SIZE;
00002e  27c8              MOVS     r7,#0xc8
000030  b19b              CBZ      r3,|L9.90|
;;;321                pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;322    
;;;323                return;
;;;324            }
;;;325    
;;;326            // 命令头正确，但无临时缓冲区可用，退出
;;;327            if ((pCB->rx.end + 1) % POWER_PROTOCOL_RX_QUEUE_SIZE == pCB->rx.head)
;;;328            {
;;;329                return;
;;;330            }
;;;331    
;;;332            // 添加UART通讯超时时间设置-2016.1.5增加
;;;333    #if BLE_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;334            TIMER_AddTask(TIMER_ID_UART_RX_TIME_OUT_CONTROL,
;;;335                          BLE_PROTOCOL_BUS_UNIDIRECTIONAL_TIME_OUT,
;;;336                          BLE_PROTOCOL_CALLBACK_RxTimeOut,
;;;337                          0,
;;;338                          1,
;;;339                          ACTION_MODE_ADD_TO_QUEUE);
;;;340    #endif
;;;341    
;;;342            // 命令头正确，有临时缓冲区可用，则将其添加到命令帧临时缓冲区中
;;;343            pCmdFrame->buff[pCmdFrame->length++] = currentData;
;;;344            pCB->rxFIFO.currentProcessIndex++;
;;;345            pCB->rxFIFO.currentProcessIndex %= POWER_PROTOCOL_RX_FIFO_SIZE;
;;;346        }
;;;347        // 非首字节，将数据添加到命令帧临时缓冲区中，但暂不删除当前数据
;;;348        else
;;;349        {
;;;350            // 临时缓冲区溢出，说明当前正在接收的命令帧是错误的，正确的命令帧不会出现长度溢出的情况
;;;351            if (pCmdFrame->length >= POWER_PROTOCOL_RX_CMD_FRAME_LENGTH_MAX)
000032  f04f0800          MOV      r8,#0
000036  2b96              CMP      r3,#0x96
000038  d37e              BCC      |L9.312|
;;;352            {
;;;353    #if BLE_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;354                // 停止RX通讯超时检测
;;;355                BLE_PROTOCOL_StopRxTimeOutCheck();
;;;356    #endif
;;;357    
;;;358                // 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;359                pCmdFrame->length = 0; // 2016.1.5增加
00003a  f8a58098          STRH     r8,[r5,#0x98]
;;;360                // 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;361                pCB->rxFIFO.head++;
00003e  f8340fc8          LDRH     r0,[r4,#0xc8]!
000042  1c40              ADDS     r0,r0,#1
000044  8020              STRH     r0,[r4,#0]
;;;362                pCB->rxFIFO.head %= POWER_PROTOCOL_RX_FIFO_SIZE;
000046  8820              LDRH     r0,[r4,#0]
000048  fbb0f1f7          UDIV     r1,r0,r7
00004c  fb070011          MLS      r0,r7,r1,r0
000050  8020              STRH     r0,[r4,#0]
;;;363                pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
000052  8820              LDRH     r0,[r4,#0]
000054  80a0              STRH     r0,[r4,#4]
                  |L9.86|
;;;364    
;;;365                return;
;;;366            }
;;;367    
;;;368            // 一直取到末尾
;;;369            while (end != pCB->rxFIFO.currentProcessIndex)
;;;370            {
;;;371                // 取出当前要处理的字节
;;;372                currentData = pCB->rxFIFO.buff[pCB->rxFIFO.currentProcessIndex];
;;;373                // 缓冲区未溢出，正常接收，将数据添加到临时缓冲区中
;;;374                pCmdFrame->buff[pCmdFrame->length++] = currentData;
;;;375                pCB->rxFIFO.currentProcessIndex++;
;;;376                pCB->rxFIFO.currentProcessIndex %= POWER_PROTOCOL_RX_FIFO_SIZE;
;;;377    
;;;378                // ■■接下来，需要检查命令帧是否完整，如果完整，则将命令帧临时缓冲区扶正 ■■
;;;379    
;;;380                // 首先判断命令帧最小长度，一个完整的命令字至少包括8个字节: 命令头、设备地址、命令字、数据长度、校验和L、校验和H、结束标识0xD、结束标识OxA，因此不足8个字节的必定不完整
;;;381                if (pCmdFrame->length < POWER_PROTOCOL_CMD_FRAME_LENGTH_MIN)
;;;382                {
;;;383                    // 继续接收
;;;384                    continue;
;;;385                }
;;;386    
;;;387                // 命令帧长度数值越界，说明当前命令帧错误，停止接收
;;;388                if (pCmdFrame->buff[POWER_PROTOCOL_CMD_LENGTH_INDEX] > (POWER_PROTOCOL_RX_CMD_FRAME_LENGTH_MAX - POWER_PROTOCOL_CMD_FRAME_LENGTH_MIN))
;;;389                {
;;;390    #if BLE_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;391                    // 停止RX通讯超时检测
;;;392                    BLE_PROTOCOL_StopRxTimeOutCheck();
;;;393    #endif
;;;394    
;;;395                    // 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;396                    pCmdFrame->length = 0;
;;;397                    // 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;398                    pCB->rxFIFO.head++;
;;;399                    pCB->rxFIFO.head %= POWER_PROTOCOL_RX_FIFO_SIZE;
;;;400                    pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;401    
;;;402                    return;
;;;403                }
;;;404    
;;;405                // 命令帧长度校验
;;;406                length = pCmdFrame->length;
;;;407                if (length < pCmdFrame->buff[POWER_PROTOCOL_CMD_LENGTH_INDEX] + POWER_PROTOCOL_CMD_FRAME_LENGTH_MIN)
;;;408                {
;;;409                    // 长度要求不一致，说明未接收完毕，退出继续
;;;410                    continue;
;;;411                }
;;;412    
;;;413                // 命令帧长度OK，则进行校验，失败时删除命令头
;;;414                if (!POWER_PROTOCOL_CheckSUM(pCmdFrame))
;;;415                {
;;;416    #if BLE_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;417                    // 停止RX通讯超时检测
;;;418                    BLE_PROTOCOL_StopRxTimeOutCheck();
;;;419    #endif
;;;420    
;;;421                    // 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;422                    pCmdFrame->length = 0;
;;;423                    // 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;424                    pCB->rxFIFO.head++;
;;;425                    pCB->rxFIFO.head %= POWER_PROTOCOL_RX_FIFO_SIZE;
;;;426                    pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;427    
;;;428                    return;
;;;429                }
;;;430    
;;;431    #if BLE_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;432                // 停止RX通讯超时检测
;;;433                BLE_PROTOCOL_StopRxTimeOutCheck();
;;;434    #endif
;;;435                // 执行到这里，即说明接收到了一个完整并且正确的命令帧，此时需将处理过的数据从一级缓冲区中删除，并将该命令帧扶正
;;;436                pCB->rxFIFO.head += length;
;;;437                pCB->rxFIFO.head %= POWER_PROTOCOL_RX_FIFO_SIZE;
;;;438                pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;439                POWER_PROTOCOL_ConfirmTempCmdFrameBuff(pCB);
;;;440    
;;;441                return;
;;;442            }
;;;443        }
;;;444    }
000056  e8bd81f0          POP      {r4-r8,pc}
                  |L9.90|
00005a  283a              CMP      r0,#0x3a              ;317
00005c  d00c              BEQ      |L9.120|
00005e  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;319
000062  1c40              ADDS     r0,r0,#1              ;319
000064  8020              STRH     r0,[r4,#0]            ;319
000066  8820              LDRH     r0,[r4,#0]            ;320
000068  fbb0f1f7          UDIV     r1,r0,r7              ;320
00006c  fb070011          MLS      r0,r7,r1,r0           ;320
000070  8020              STRH     r0,[r4,#0]            ;320
000072  8820              LDRH     r0,[r4,#0]            ;321
000074  80a0              STRH     r0,[r4,#4]            ;321
000076  e7ee              B        |L9.86|
                  |L9.120|
000078  1c52              ADDS     r2,r2,#1              ;327
00007a  2103              MOVS     r1,#3                 ;327
00007c  fbb2f3f1          UDIV     r3,r2,r1              ;327
000080  fb012113          MLS      r1,r1,r3,r2           ;327
000084  f8b4229c          LDRH     r2,[r4,#0x29c]        ;327
000088  4291              CMP      r1,r2                 ;327
00008a  d0e4              BEQ      |L9.86|
00008c  2101              MOVS     r1,#1                 ;343
00008e  f8a51098          STRH     r1,[r5,#0x98]         ;343
000092  70a8              STRB     r0,[r5,#2]            ;343
000094  f8340fcc          LDRH     r0,[r4,#0xcc]!        ;344
000098  1c40              ADDS     r0,r0,#1              ;344
00009a  b280              UXTH     r0,r0                 ;344
00009c  fbb0f1f7          UDIV     r1,r0,r7              ;345
0000a0  fb070011          MLS      r0,r7,r1,r0           ;345
0000a4  8020              STRH     r0,[r4,#0]            ;345
0000a6  e7d6              B        |L9.86|
                  |L9.168|
0000a8  5c22              LDRB     r2,[r4,r0]            ;372
0000aa  f8b50098          LDRH     r0,[r5,#0x98]         ;374
0000ae  1c43              ADDS     r3,r0,#1              ;374
0000b0  4428              ADD      r0,r0,r5              ;374
0000b2  f8a53098          STRH     r3,[r5,#0x98]         ;374
0000b6  7082              STRB     r2,[r0,#2]            ;374
0000b8  f8b400cc          LDRH     r0,[r4,#0xcc]         ;375
0000bc  1c40              ADDS     r0,r0,#1              ;375
0000be  b280              UXTH     r0,r0                 ;375
0000c0  fbb0f2f7          UDIV     r2,r0,r7              ;376
0000c4  fb070012          MLS      r0,r7,r2,r0           ;376
0000c8  f8a400cc          STRH     r0,[r4,#0xcc]         ;376
0000cc  f8b56098          LDRH     r6,[r5,#0x98]         ;381
0000d0  2e08              CMP      r6,#8                 ;381
0000d2  d33b              BCC      |L9.332|
0000d4  7968              LDRB     r0,[r5,#5]            ;388
0000d6  288e              CMP      r0,#0x8e              ;388
0000d8  d90e              BLS      |L9.248|
0000da  f8a58098          STRH     r8,[r5,#0x98]         ;396
0000de  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;398
0000e2  1c40              ADDS     r0,r0,#1              ;398
0000e4  8020              STRH     r0,[r4,#0]            ;398
0000e6  8820              LDRH     r0,[r4,#0]            ;399
0000e8  fbb0f1f7          UDIV     r1,r0,r7              ;399
0000ec  fb070011          MLS      r0,r7,r1,r0           ;399
0000f0  8020              STRH     r0,[r4,#0]            ;399
0000f2  8820              LDRH     r0,[r4,#0]            ;400
0000f4  80a0              STRH     r0,[r4,#4]            ;400
0000f6  e7ae              B        |L9.86|
                  |L9.248|
0000f8  3008              ADDS     r0,r0,#8              ;407
0000fa  42b0              CMP      r0,r6                 ;407
0000fc  d826              BHI      |L9.332|
0000fe  4628              MOV      r0,r5                 ;414
000100  f7fffffe          BL       POWER_PROTOCOL_CheckSUM
000104  b188              CBZ      r0,|L9.298|
000106  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;436
00010a  4430              ADD      r0,r0,r6              ;436
00010c  8020              STRH     r0,[r4,#0]            ;436
00010e  8820              LDRH     r0,[r4,#0]            ;437
000110  fbb0f1f7          UDIV     r1,r0,r7              ;437
000114  fb070011          MLS      r0,r7,r1,r0           ;437
000118  8020              STRH     r0,[r4,#0]            ;437
00011a  8820              LDRH     r0,[r4,#0]            ;438
00011c  80a0              STRH     r0,[r4,#4]            ;438
00011e  3cc8              SUBS     r4,r4,#0xc8           ;438
000120  4620              MOV      r0,r4                 ;439
000122  e8bd41f0          POP      {r4-r8,lr}            ;439
000126  f7ffbffe          B.W      POWER_PROTOCOL_ConfirmTempCmdFrameBuff
                  |L9.298|
00012a  f8a58098          STRH     r8,[r5,#0x98]         ;422
00012e  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;424
000132  1c40              ADDS     r0,r0,#1              ;424
000134  8020              STRH     r0,[r4,#0]            ;424
000136  e000              B        |L9.314|
                  |L9.312|
000138  e008              B        |L9.332|
                  |L9.314|
00013a  8820              LDRH     r0,[r4,#0]            ;425
00013c  fbb0f1f7          UDIV     r1,r0,r7              ;425
000140  fb070011          MLS      r0,r7,r1,r0           ;425
000144  8020              STRH     r0,[r4,#0]            ;425
000146  8820              LDRH     r0,[r4,#0]            ;426
000148  80a0              STRH     r0,[r4,#4]            ;426
00014a  e784              B        |L9.86|
                  |L9.332|
00014c  f8b400cc          LDRH     r0,[r4,#0xcc]         ;369
000150  4288              CMP      r0,r1                 ;369
000152  d1a9              BNE      |L9.168|
000154  e77f              B        |L9.86|
;;;445    
                          ENDP


                          AREA ||i.POWER_PROTOCOL_SendCmdAck||, CODE, READONLY, ALIGN=1

                  POWER_PROTOCOL_SendCmdAck PROC
;;;967    // 发送命令回复
;;;968    void POWER_PROTOCOL_SendCmdAck(uint8 ackCmd)
000000  b510              PUSH     {r4,lr}
;;;969    {
000002  4604              MOV      r4,r0
;;;970        POWER_PROTOCOL_TxAddData(POWER_PROTOCOL_CMD_HEAD);
000004  203a              MOVS     r0,#0x3a
000006  f7fffffe          BL       POWER_PROTOCOL_TxAddData
;;;971        POWER_PROTOCOL_TxAddData(POWER_PROTOCOL_CMD_DEVICE_ADDR);
00000a  201a              MOVS     r0,#0x1a
00000c  f7fffffe          BL       POWER_PROTOCOL_TxAddData
;;;972        POWER_PROTOCOL_TxAddData(ackCmd);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       POWER_PROTOCOL_TxAddData
;;;973        POWER_PROTOCOL_TxAddData(0x00);
000016  2000              MOVS     r0,#0
000018  f7fffffe          BL       POWER_PROTOCOL_TxAddData
;;;974        POWER_PROTOCOL_TxAddFrame();
00001c  e8bd4010          POP      {r4,lr}
000020  f7ffbffe          B.W      POWER_PROTOCOL_TxAddFrame
;;;975    }
;;;976    
                          ENDP


                          AREA ||i.POWER_PROTOCOL_SendCmdParamAck||, CODE, READONLY, ALIGN=1

                  POWER_PROTOCOL_SendCmdParamAck PROC
;;;977    // 发送命令回复，带一个参数
;;;978    void POWER_PROTOCOL_SendCmdParamAck(uint8 ackCmd, uint8 ackParam)
000000  b530              PUSH     {r4,r5,lr}
;;;979    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;980        POWER_PROTOCOL_TxAddData(POWER_PROTOCOL_CMD_HEAD);
000006  203a              MOVS     r0,#0x3a
000008  f7fffffe          BL       POWER_PROTOCOL_TxAddData
;;;981        POWER_PROTOCOL_TxAddData(POWER_PROTOCOL_CMD_DEVICE_ADDR);
00000c  201a              MOVS     r0,#0x1a
00000e  f7fffffe          BL       POWER_PROTOCOL_TxAddData
;;;982        POWER_PROTOCOL_TxAddData(ackCmd);
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       POWER_PROTOCOL_TxAddData
;;;983        POWER_PROTOCOL_TxAddData(0x01);
000018  2001              MOVS     r0,#1
00001a  f7fffffe          BL       POWER_PROTOCOL_TxAddData
;;;984        POWER_PROTOCOL_TxAddData(ackParam);
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       POWER_PROTOCOL_TxAddData
;;;985        POWER_PROTOCOL_TxAddFrame();
000024  e8bd4030          POP      {r4,r5,lr}
000028  f7ffbffe          B.W      POWER_PROTOCOL_TxAddFrame
;;;986    }
;;;987    
                          ENDP


                          AREA ||i.POWER_PROTOCOL_TxAddData||, CODE, READONLY, ALIGN=2

                  POWER_PROTOCOL_TxAddData PROC
;;;82     // 向发送命令帧队列中添加数据
;;;83     void POWER_PROTOCOL_TxAddData(uint8 data)
000000  b530              PUSH     {r4,r5,lr}
;;;84     {
;;;85         uint16 head = POWERProtocolCB.tx.head;
000002  490f              LDR      r1,|L12.64|
000004  f8b1446e          LDRH     r4,[r1,#0x46e]  ; POWERProtocolCB
;;;86         uint16 end = POWERProtocolCB.tx.end;
000008  f8b12470          LDRH     r2,[r1,#0x470]  ; POWERProtocolCB
;;;87         POWER_PROTOCOL_TX_CMD_FRAME *pCmdFrame = &POWERProtocolCB.tx.cmdQueue[POWERProtocolCB.tx.end];
00000c  234d              MOVS     r3,#0x4d
00000e  4353              MULS     r3,r2,r3
000010  eb010143          ADD      r1,r1,r3,LSL #1
000014  f5017128          ADD      r1,r1,#0x2a0
;;;88     
;;;89         // 发送缓冲区已满，不予接收
;;;90         if ((end + 1) % POWER_PROTOCOL_TX_QUEUE_SIZE == head)
000018  1c52              ADDS     r2,r2,#1
00001a  2303              MOVS     r3,#3
00001c  fbb2f5f3          UDIV     r5,r2,r3
000020  fb032215          MLS      r2,r3,r5,r2
000024  42a2              CMP      r2,r4
000026  d009              BEQ      |L12.60|
;;;91         {
;;;92             return;
;;;93         }
;;;94     
;;;95         // 队尾命令帧已满，退出
;;;96         if (pCmdFrame->length >= POWER_PROTOCOL_TX_CMD_FRAME_LENGTH_MAX)
000028  f8b12098          LDRH     r2,[r1,#0x98]
00002c  2a96              CMP      r2,#0x96
00002e  d205              BCS      |L12.60|
;;;97         {
;;;98             return;
;;;99         }
;;;100    
;;;101        // 数据添加到帧末尾，并更新帧长度
;;;102        pCmdFrame->buff[pCmdFrame->length] = data;
000030  1c8b              ADDS     r3,r1,#2
000032  54d0              STRB     r0,[r2,r3]
;;;103        pCmdFrame->length++;
000034  f8310f98          LDRH     r0,[r1,#0x98]!
000038  1c40              ADDS     r0,r0,#1
00003a  8008              STRH     r0,[r1,#0]
                  |L12.60|
;;;104    }
00003c  bd30              POP      {r4,r5,pc}
;;;105    
                          ENDP

00003e  0000              DCW      0x0000
                  |L12.64|
                          DCD      ||.bss||

                          AREA ||i.POWER_PROTOCOL_TxAddFrame||, CODE, READONLY, ALIGN=2

                  POWER_PROTOCOL_TxAddFrame PROC
;;;106    // 确认添加命令帧，即承认之前填充的数据为命令帧，将其添加到发送队列中，由main进行调度发送，本函数内会自动校正命令长度，并添加校验码
;;;107    void POWER_PROTOCOL_TxAddFrame(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;108    {
;;;109        uint16 checkSum = 0;
000002  2300              MOVS     r3,#0
;;;110        uint16 i = 0;
;;;111        uint16 head = POWERProtocolCB.tx.head;
000004  4c2f              LDR      r4,|L13.196|
000006  f8b4646e          LDRH     r6,[r4,#0x46e]  ; POWERProtocolCB
;;;112        uint16 end = POWERProtocolCB.tx.end;
00000a  f8b42470          LDRH     r2,[r4,#0x470]  ; POWERProtocolCB
;;;113        POWER_PROTOCOL_TX_CMD_FRAME *pCmdFrame = &POWERProtocolCB.tx.cmdQueue[POWERProtocolCB.tx.end];
00000e  204d              MOVS     r0,#0x4d
000010  4350              MULS     r0,r2,r0
000012  eb040040          ADD      r0,r4,r0,LSL #1
000016  f5007028          ADD      r0,r0,#0x2a0
;;;114        uint16 length = pCmdFrame->length;
00001a  f8b01098          LDRH     r1,[r0,#0x98]
;;;115    
;;;116        // 发送缓冲区已满，不予接收
;;;117        if ((end + 1) % POWER_PROTOCOL_TX_QUEUE_SIZE == head)
00001e  1c52              ADDS     r2,r2,#1
000020  2503              MOVS     r5,#3
000022  fbb2f7f5          UDIV     r7,r2,r5
000026  fb052217          MLS      r2,r5,r7,r2
00002a  42b2              CMP      r2,r6
00002c  d004              BEQ      |L13.56|
;;;118        {
;;;119            return;
;;;120        }
;;;121    
;;;122        // 命令帧长度不足，清除已填充的数据，退出
;;;123        if (POWER_PROTOCOL_CMD_FRAME_LENGTH_MIN - 4 > length)  // 减去"校验和L、校验和H、结束标识0xD、结束标识OxA"4个字节
00002e  2200              MOVS     r2,#0
000030  2904              CMP      r1,#4
000032  d202              BCS      |L13.58|
;;;124        {
;;;125            pCmdFrame->length = 0;
000034  f8a02098          STRH     r2,[r0,#0x98]
                  |L13.56|
;;;126    
;;;127            return;
;;;128        }
;;;129    
;;;130        // 队尾命令帧已满，退出
;;;131        if ((length >= POWER_PROTOCOL_TX_CMD_FRAME_LENGTH_MAX) || (length + 1 >= POWER_PROTOCOL_TX_CMD_FRAME_LENGTH_MAX)
;;;132                || (length + 2 >= POWER_PROTOCOL_TX_CMD_FRAME_LENGTH_MAX) || (length + 3 >= POWER_PROTOCOL_TX_CMD_FRAME_LENGTH_MAX))
;;;133        {
;;;134            pCmdFrame->length = 0;
;;;135    
;;;136            return;
;;;137        }
;;;138    
;;;139        // 队尾命令帧已满，退出
;;;140        if (length >= POWER_PROTOCOL_TX_CMD_FRAME_LENGTH_MAX)
;;;141        {
;;;142            return;
;;;143        }
;;;144    
;;;145        // 重新设置数据长度，系统在准备数据时，填充的"数据长度"可以为任意值，并且不需要添加校验码，在这里重新设置为正确的值
;;;146        pCmdFrame->buff[POWER_PROTOCOL_CMD_LENGTH_INDEX] = length - 4;   // 重设数据长度，减去"命令头、设备地址、命令字、数据长度"4个字节
;;;147        for (i = 1; i < length; i++)
;;;148        {
;;;149            checkSum += pCmdFrame->buff[i];
;;;150        }
;;;151        pCmdFrame->buff[pCmdFrame->length++] = (checkSum & 0x00FF);         // 低字节在前
;;;152        pCmdFrame->buff[pCmdFrame->length++] = ((checkSum >> 8) & 0x00FF);  // 高字节在后
;;;153    
;;;154        // 结束标识
;;;155        pCmdFrame->buff[pCmdFrame->length++] = 0x0D;
;;;156        pCmdFrame->buff[pCmdFrame->length++] = 0x0A;
;;;157    
;;;158        POWERProtocolCB.tx.end++;
;;;159        POWERProtocolCB.tx.end %= POWER_PROTOCOL_TX_QUEUE_SIZE;
;;;160        // pCB->tx.cmdQueue[pCB->tx.end].length = 0;   //2015.12.2修改
;;;161    }
000038  bdf0              POP      {r4-r7,pc}
                  |L13.58|
00003a  2996              CMP      r1,#0x96              ;131
00003c  d208              BCS      |L13.80|
00003e  1c4e              ADDS     r6,r1,#1              ;131
000040  2e96              CMP      r6,#0x96              ;131
000042  d205              BCS      |L13.80|
000044  1c8e              ADDS     r6,r1,#2              ;132
000046  2e96              CMP      r6,#0x96              ;132
000048  d202              BCS      |L13.80|
00004a  1cce              ADDS     r6,r1,#3              ;132
00004c  2e96              CMP      r6,#0x96              ;132
00004e  d302              BCC      |L13.86|
                  |L13.80|
000050  f8a02098          STRH     r2,[r0,#0x98]         ;134
000054  bdf0              POP      {r4-r7,pc}
                  |L13.86|
000056  1f0a              SUBS     r2,r1,#4              ;146
000058  7142              STRB     r2,[r0,#5]            ;146
00005a  2201              MOVS     r2,#1                 ;147
00005c  e005              B        |L13.106|
                  |L13.94|
00005e  1886              ADDS     r6,r0,r2              ;149
000060  78b6              LDRB     r6,[r6,#2]            ;149
000062  4433              ADD      r3,r3,r6              ;149
000064  b29b              UXTH     r3,r3                 ;149
000066  1c52              ADDS     r2,r2,#1              ;147
000068  b292              UXTH     r2,r2                 ;147
                  |L13.106|
00006a  428a              CMP      r2,r1                 ;147
00006c  d3f7              BCC      |L13.94|
00006e  f8b01098          LDRH     r1,[r0,#0x98]         ;151
000072  1c4a              ADDS     r2,r1,#1              ;151
000074  4401              ADD      r1,r1,r0              ;151
000076  f8a02098          STRH     r2,[r0,#0x98]         ;151
00007a  708b              STRB     r3,[r1,#2]            ;151
00007c  f8b01098          LDRH     r1,[r0,#0x98]         ;152
000080  0a1b              LSRS     r3,r3,#8              ;152
000082  1c4a              ADDS     r2,r1,#1              ;152
000084  4401              ADD      r1,r1,r0              ;152
000086  f8a02098          STRH     r2,[r0,#0x98]         ;152
00008a  708b              STRB     r3,[r1,#2]            ;152
00008c  f8b01098          LDRH     r1,[r0,#0x98]         ;155
000090  230d              MOVS     r3,#0xd               ;155
000092  1c4a              ADDS     r2,r1,#1              ;155
000094  4401              ADD      r1,r1,r0              ;155
000096  f8a02098          STRH     r2,[r0,#0x98]         ;155
00009a  708b              STRB     r3,[r1,#2]            ;155
00009c  f8b01098          LDRH     r1,[r0,#0x98]         ;156
0000a0  230a              MOVS     r3,#0xa               ;156
0000a2  1c4a              ADDS     r2,r1,#1              ;156
0000a4  f8a02098          STRH     r2,[r0,#0x98]         ;156
0000a8  4408              ADD      r0,r0,r1              ;156
0000aa  7083              STRB     r3,[r0,#2]            ;156
0000ac  f8b40470          LDRH     r0,[r4,#0x470]        ;158  ; POWERProtocolCB
0000b0  1c40              ADDS     r0,r0,#1              ;158
0000b2  b280              UXTH     r0,r0                 ;158
0000b4  fbb0f1f5          UDIV     r1,r0,r5              ;159
0000b8  fb050011          MLS      r0,r5,r1,r0           ;159
0000bc  f8a40470          STRH     r0,[r4,#0x470]        ;159
0000c0  bdf0              POP      {r4-r7,pc}
;;;162    
                          ENDP

0000c2  0000              DCW      0x0000
                  |L13.196|
                          DCD      ||.bss||

                          AREA ||i.POWER_PROTOCOL_TxStateProcess||, CODE, READONLY, ALIGN=2

                  POWER_PROTOCOL_TxStateProcess PROC
;;;254    // 协议层发送处理过程
;;;255    void POWER_PROTOCOL_TxStateProcess(void)
000000  b570              PUSH     {r4-r6,lr}
;;;256    {
;;;257        uint16 head = POWERProtocolCB.tx.head;
000002  4c14              LDR      r4,|L14.84|
000004  f8b4346e          LDRH     r3,[r4,#0x46e]  ; POWERProtocolCB
;;;258        uint16 end = POWERProtocolCB.tx.end;
000008  f8b46470          LDRH     r6,[r4,#0x470]  ; POWERProtocolCB
;;;259        uint16 length = POWERProtocolCB.tx.cmdQueue[head].length;
00000c  204d              MOVS     r0,#0x4d
00000e  4358              MULS     r0,r3,r0
000010  eb040040          ADD      r0,r4,r0,LSL #1
000014  4605              MOV      r5,r0
000016  f8b02338          LDRH     r2,[r0,#0x338]
;;;260        uint8 *pCmd = POWERProtocolCB.tx.cmdQueue[head].buff;
00001a  f20021a2          ADD      r1,r0,#0x2a2
;;;261        uint16 localDeviceID = POWERProtocolCB.tx.cmdQueue[head].deviceID;
00001e  f8b002a0          LDRH     r0,[r0,#0x2a0]
;;;262    
;;;263        // 发送缓冲区为空，说明无数据
;;;264        if (head == end)
000022  42b3              CMP      r3,r6
000024  d014              BEQ      |L14.80|
;;;265        {
;;;266            return;
;;;267        }
;;;268    
;;;269        // 发送函数没有注册直接返回
;;;270        if (NULL == POWERProtocolCB.sendDataThrowService)
000026  f8d43478          LDR      r3,[r4,#0x478]  ; POWERProtocolCB
00002a  2b00              CMP      r3,#0
00002c  d010              BEQ      |L14.80|
;;;271        {
;;;272            return;
;;;273        }
;;;274    
;;;275        // 协议层有数据需要发送到驱动层
;;;276        if (!(*POWERProtocolCB.sendDataThrowService)(localDeviceID, pCmd, length))
00002e  4798              BLX      r3
000030  2800              CMP      r0,#0
000032  d00d              BEQ      |L14.80|
;;;277        {
;;;278            return;
;;;279        }
;;;280    
;;;281        // 发送环形队列更新位置
;;;282        POWERProtocolCB.tx.cmdQueue[head].length = 0;
000034  2000              MOVS     r0,#0
000036  f8a50338          STRH     r0,[r5,#0x338]
;;;283        POWERProtocolCB.tx.head++;
00003a  f8b4046e          LDRH     r0,[r4,#0x46e]  ; POWERProtocolCB
00003e  1c40              ADDS     r0,r0,#1
000040  b280              UXTH     r0,r0
;;;284        POWERProtocolCB.tx.head %= POWER_PROTOCOL_TX_QUEUE_SIZE;
000042  2103              MOVS     r1,#3
000044  fbb0f2f1          UDIV     r2,r0,r1
000048  fb010012          MLS      r0,r1,r2,r0
00004c  f8a4046e          STRH     r0,[r4,#0x46e]
                  |L14.80|
;;;285    }
000050  bd70              POP      {r4-r6,pc}
;;;286    
                          ENDP

000052  0000              DCW      0x0000
                  |L14.84|
                          DCD      ||.bss||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  POWERProtocolCB
                          %        1156

                          AREA ||.data||, DATA, ALIGN=2

                  power_cnt
000000  00                DCB      0x00
                  switch_cnt
000001  000000            DCB      0x00,0x00,0x00
                  vout_Current
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "User\\PowerProtocol.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_PowerProtocol_c_986c3f0e____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___15_PowerProtocol_c_986c3f0e____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_PowerProtocol_c_986c3f0e____REVSH|
#line 128
|__asm___15_PowerProtocol_c_986c3f0e____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
