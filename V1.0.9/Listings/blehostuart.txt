; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\blehostuart.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\blehostuart.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -I.\User\qrencode -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.1\Device\Include -D__MICROLIB -D__UVISION_VERSION=534 -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\blehostuart.crf User\BleHostUart.c]
                          THUMB

                          AREA ||i.BLE_HOST_UART_AddTxArray||, CODE, READONLY, ALIGN=2

                  BLE_HOST_UART_AddTxArray PROC
;;;328    // 向发送缓冲区中添加一条待发送序列
;;;329    BOOL BLE_HOST_UART_AddTxArray(uint16 id, uint8 *pArray, uint16 length)
000000  b5f0              PUSH     {r4-r7,lr}
;;;330    {
;;;331    	uint16 i;
;;;332    	uint16 head = bleHostUartCB.tx.head;
000002  4d1e              LDR      r5,|L1.124|
000004  f8b57306          LDRH     r7,[r5,#0x306]  ; bleHostUartCB
;;;333    	uint16 end = bleHostUartCB.tx.end;
000008  f8b53308          LDRH     r3,[r5,#0x308]  ; bleHostUartCB
;;;334    	
;;;335    	// 参数检验
;;;336    	if ((NULL == pArray) || (0 == length))
00000c  2900              CMP      r1,#0
00000e  d00a              BEQ      |L1.38|
000010  b14a              CBZ      r2,|L1.38|
;;;337    	{
;;;338    		return FALSE;
;;;339    	}
;;;340    
;;;341    	// 发送缓冲区已满，不予接收
;;;342    	if((end + 1) % BLE_HOST_UART_DRIVE_TX_QUEUE_SIZE == head)
000012  1c5e              ADDS     r6,r3,#1
000014  2405              MOVS     r4,#5
000016  fbb6fcf4          UDIV     r12,r6,r4
00001a  fb04661c          MLS      r6,r4,r12,r6
00001e  42be              CMP      r6,r7
000020  d103              BNE      |L1.42|
;;;343    	{
;;;344    		return FALSE;
000022  2000              MOVS     r0,#0
;;;345    	}
;;;346    
;;;347    	bleHostUartCB.tx.cmdQueue[end].deviceID = id;
;;;348    	for (i = 0; i < length; i++)
;;;349    	{
;;;350    		bleHostUartCB.tx.cmdQueue[end].buff[i] = *pArray++;
;;;351    	}
;;;352    	bleHostUartCB.tx.cmdQueue[end].length = length;
;;;353    	
;;;354    	// 发送环形队列更新位置
;;;355    	bleHostUartCB.tx.end ++;
;;;356    	bleHostUartCB.tx.end %= BLE_HOST_UART_DRIVE_TX_QUEUE_SIZE;
;;;357    	bleHostUartCB.tx.cmdQueue[bleHostUartCB.tx.end].length = 0;
;;;358    
;;;359    	return TRUE;
;;;360    }
000024  bdf0              POP      {r4-r7,pc}
                  |L1.38|
000026  2000              MOVS     r0,#0                 ;338
000028  bdf0              POP      {r4-r7,pc}
                  |L1.42|
00002a  264d              MOVS     r6,#0x4d              ;347
00002c  4373              MULS     r3,r6,r3              ;347
00002e  eb050343          ADD      r3,r5,r3,LSL #1       ;347
000032  8098              STRH     r0,[r3,#4]            ;347
000034  2000              MOVS     r0,#0                 ;348
000036  e005              B        |L1.68|
                  |L1.56|
000038  181f              ADDS     r7,r3,r0              ;350
00003a  f8116b01          LDRB     r6,[r1],#1            ;350
00003e  71be              STRB     r6,[r7,#6]            ;350
000040  1c40              ADDS     r0,r0,#1              ;348
000042  b280              UXTH     r0,r0                 ;348
                  |L1.68|
000044  4290              CMP      r0,r2                 ;348
000046  d3f7              BCC      |L1.56|
000048  f8a3209c          STRH     r2,[r3,#0x9c]         ;352
00004c  f5057542          ADD      r5,r5,#0x308          ;355
000050  8828              LDRH     r0,[r5,#0]            ;355  ; bleHostUartCB
000052  1c40              ADDS     r0,r0,#1              ;355
000054  8028              STRH     r0,[r5,#0]            ;355
000056  8828              LDRH     r0,[r5,#0]            ;356  ; bleHostUartCB
000058  fbb0f1f4          UDIV     r1,r0,r4              ;356
00005c  fb040011          MLS      r0,r4,r1,r0           ;356
000060  8028              STRH     r0,[r5,#0]            ;356
000062  8828              LDRH     r0,[r5,#0]            ;357  ; bleHostUartCB
000064  2100              MOVS     r1,#0                 ;357
000066  224d              MOVS     r2,#0x4d              ;357
000068  f5a57542          SUB      r5,r5,#0x308          ;357
00006c  4350              MULS     r0,r2,r0              ;357
00006e  eb050040          ADD      r0,r5,r0,LSL #1       ;357
000072  f8a0109c          STRH     r1,[r0,#0x9c]         ;357
000076  2001              MOVS     r0,#1                 ;359
000078  bdf0              POP      {r4-r7,pc}
;;;361    
                          ENDP

00007a  0000              DCW      0x0000
                  |L1.124|
                          DCD      ||.bss||+0xc8

                          AREA ||i.BLE_HOST_UART_BC_SendData||, CODE, READONLY, ALIGN=2

                  BLE_HOST_UART_BC_SendData PROC
;;;177    // 阻塞发送一个字节数据
;;;178    void BLE_HOST_UART_BC_SendData(uint8 data)
000000  b570              PUSH     {r4-r6,lr}
;;;179    {	
000002  4605              MOV      r5,r0
;;;180    	// 防止丢失第一个字节(清除空标志位,务必加) 
;;;181    	usart_flag_get(BLE_HOST_UART_TYPE_DEF, USART_FLAG_TC);		
000004  4c07              LDR      r4,|L2.36|
000006  2106              MOVS     r1,#6
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       usart_flag_get
;;;182    
;;;183    	// 填充数据
;;;184    	usart_data_transmit(BLE_HOST_UART_TYPE_DEF, data);
00000e  4629              MOV      r1,r5
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       usart_data_transmit
                  |L2.22|
;;;185    
;;;186    	// 未发送完，持续等待
;;;187    	while(usart_flag_get(BLE_HOST_UART_TYPE_DEF, USART_FLAG_TC) != SET);			
000016  2106              MOVS     r1,#6
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       usart_flag_get
00001e  2801              CMP      r0,#1
000020  d1f9              BNE      |L2.22|
;;;188    }
000022  bd70              POP      {r4-r6,pc}
;;;189    
                          ENDP

                  |L2.36|
                          DCD      0x40004800

                          AREA ||i.BLE_HOST_UART_BleConnectState||, CODE, READONLY, ALIGN=2

                  BLE_HOST_UART_BleConnectState PROC
;;;198    uint8 bleHostIndex = 0;
;;;199    void BLE_HOST_UART_BleConnectState(uint32 param)
000000  b510              PUSH     {r4,lr}
;;;200    {	
;;;201    	// 解析TTM命令
;;;202    	BLE_HOST_UART_TTM_AnalysisCmd(bleHostRxBuff, bleHostIndex);
000002  4c04              LDR      r4,|L3.20|
000004  4804              LDR      r0,|L3.24|
000006  7821              LDRB     r1,[r4,#0]  ; bleHostIndex
000008  f7fffffe          BL       BLE_HOST_UART_TTM_AnalysisCmd
;;;203    
;;;204    	bleHostIndex = 0;
00000c  2000              MOVS     r0,#0
00000e  7020              STRB     r0,[r4,#0]
;;;205    }
000010  bd10              POP      {r4,pc}
;;;206    
                          ENDP

000012  0000              DCW      0x0000
                  |L3.20|
                          DCD      ||.data||
                  |L3.24|
                          DCD      ||.bss||

                          AREA ||i.BLE_HOST_UART_DataStructureInit||, CODE, READONLY, ALIGN=2

                  BLE_HOST_UART_DataStructureInit PROC
;;;66     // 数据结构初始化
;;;67     void BLE_HOST_UART_DataStructureInit(BLE_HOST_UART_CB* pCB)
000000  2800              CMP      r0,#0
;;;68     {
000002  d016              BEQ      |L4.50|
;;;69     	uint16 i;
;;;70     	
;;;71     	// 参数合法性检验
;;;72     	if (NULL == pCB)
;;;73     	{
;;;74     		return;
;;;75     	}
;;;76     
;;;77     	pCB->tx.txBusy = FALSE;
000004  2200              MOVS     r2,#0
000006  f880230c          STRB     r2,[r0,#0x30c]
;;;78     	pCB->tx.index = 0;
00000a  f8a0230a          STRH     r2,[r0,#0x30a]
;;;79     	pCB->tx.head = 0;
00000e  f8a02306          STRH     r2,[r0,#0x306]
;;;80     	pCB->tx.end = 0;
000012  f8a02308          STRH     r2,[r0,#0x308]
;;;81     	for(i = 0; i < BLE_HOST_UART_DRIVE_TX_QUEUE_SIZE; i++)
000016  2100              MOVS     r1,#0
                  |L4.24|
;;;82     	{
;;;83     		pCB->tx.cmdQueue[i].length = 0;
000018  234d              MOVS     r3,#0x4d
00001a  434b              MULS     r3,r1,r3
00001c  eb000343          ADD      r3,r0,r3,LSL #1
000020  f8a3209c          STRH     r2,[r3,#0x9c]
000024  1c49              ADDS     r1,r1,#1              ;81
000026  b289              UXTH     r1,r1                 ;81
000028  2905              CMP      r1,#5                 ;81
00002a  d3f5              BCC      |L4.24|
;;;84     	}	
;;;85     
;;;86     	bleHostUartCB.rcvBleMacOK = FALSE;
00002c  4801              LDR      r0,|L4.52|
00002e  f8802356          STRB     r2,[r0,#0x356]
                  |L4.50|
;;;87     }
000032  4770              BX       lr
;;;88     
                          ENDP

                  |L4.52|
                          DCD      ||.bss||+0xc8

                          AREA ||i.BLE_HOST_UART_HwInit||, CODE, READONLY, ALIGN=2

                  BLE_HOST_UART_HwInit PROC
;;;35     // UART初始化
;;;36     void BLE_HOST_UART_HwInit(uint32 baud)
000000  b570              PUSH     {r4-r6,lr}
;;;37     {
000002  4605              MOV      r5,r0
;;;38      	// 打开时钟
;;;39     	rcu_periph_clock_enable(RCU_GPIOB);
000004  f2406003          MOV      r0,#0x603
000008  f7fffffe          BL       rcu_periph_clock_enable
;;;40     	gpio_init(GPIOB, GPIO_MODE_AF_PP, GPIO_OSPEED_2MHZ, GPIO_PIN_10);
00000c  4c22              LDR      r4,|L5.152|
00000e  f44f6380          MOV      r3,#0x400
000012  2202              MOVS     r2,#2
000014  2118              MOVS     r1,#0x18
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       gpio_init
;;;41     	
;;;42     	gpio_init(GPIOB, GPIO_MODE_IPU, GPIO_OSPEED_2MHZ, GPIO_PIN_11);
00001c  14e3              ASRS     r3,r4,#19
00001e  2202              MOVS     r2,#2
000020  2148              MOVS     r1,#0x48
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       gpio_init
;;;43     
;;;44     	// UART时钟配置
;;;45     	rcu_periph_clock_enable(RCU_USART2);
000028  f2407012          MOV      r0,#0x712
00002c  f7fffffe          BL       rcu_periph_clock_enable
;;;46     	usart_deinit(BLE_HOST_UART_TYPE_DEF);									// 复位串口
000030  4c1a              LDR      r4,|L5.156|
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       usart_deinit
;;;47     		
;;;48     	// 串口配置
;;;49     	usart_baudrate_set(BLE_HOST_UART_TYPE_DEF, baud);						// 波特率
000038  4629              MOV      r1,r5
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       usart_baudrate_set
;;;50     	usart_word_length_set(BLE_HOST_UART_TYPE_DEF, USART_WL_8BIT);			// 8位数据位
000040  2100              MOVS     r1,#0
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       usart_word_length_set
;;;51     	usart_stop_bit_set(BLE_HOST_UART_TYPE_DEF, USART_STB_1BIT); 				// 一个停止位
000048  2100              MOVS     r1,#0
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       usart_stop_bit_set
;;;52     	usart_parity_config(BLE_HOST_UART_TYPE_DEF, USART_PM_NONE); 				// 无奇偶校验
000050  2100              MOVS     r1,#0
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       usart_parity_config
;;;53     	usart_hardware_flow_rts_config(BLE_HOST_UART_TYPE_DEF, USART_RTS_DISABLE); // 无硬件数据流控制
000058  2100              MOVS     r1,#0
00005a  4620              MOV      r0,r4
00005c  f7fffffe          BL       usart_hardware_flow_rts_config
;;;54     	usart_hardware_flow_cts_config(BLE_HOST_UART_TYPE_DEF, USART_CTS_DISABLE);
000060  2100              MOVS     r1,#0
000062  4620              MOV      r0,r4
000064  f7fffffe          BL       usart_hardware_flow_cts_config
;;;55     	usart_transmit_config(BLE_HOST_UART_TYPE_DEF, USART_TRANSMIT_ENABLE);	// 使能发射
000068  2108              MOVS     r1,#8
00006a  4620              MOV      r0,r4
00006c  f7fffffe          BL       usart_transmit_config
;;;56     	usart_receive_config(BLE_HOST_UART_TYPE_DEF, USART_RECEIVE_ENABLE); 		// 使能接收
000070  2104              MOVS     r1,#4
000072  4620              MOV      r0,r4
000074  f7fffffe          BL       usart_receive_config
;;;57     
;;;58     	// 中断配置
;;;59     	nvic_irq_enable(BLE_HOST_UART_IRQn_DEF, 2, 2);
000078  2202              MOVS     r2,#2
00007a  4611              MOV      r1,r2
00007c  2027              MOVS     r0,#0x27
00007e  f7fffffe          BL       nvic_irq_enable
;;;60     
;;;61     	usart_interrupt_enable(BLE_HOST_UART_TYPE_DEF, USART_INT_RBNE); 			// 开启中断
000082  f2403105          MOV      r1,#0x305
000086  4620              MOV      r0,r4
000088  f7fffffe          BL       usart_interrupt_enable
;;;62     
;;;63     	usart_enable(BLE_HOST_UART_TYPE_DEF);									// 使能串口 
00008c  4620              MOV      r0,r4
00008e  e8bd4070          POP      {r4-r6,lr}
000092  f7ffbffe          B.W      usart_enable
;;;64     }	
;;;65     
                          ENDP

000096  0000              DCW      0x0000
                  |L5.152|
                          DCD      0x40010c00
                  |L5.156|
                          DCD      0x40004800

                          AREA ||i.BLE_HOST_UART_IR_StartSendData||, CODE, READONLY, ALIGN=2

                  BLE_HOST_UART_IR_StartSendData PROC
;;;163    // 启动中断字节发送
;;;164    void BLE_HOST_UART_IR_StartSendData(uint8 data)
000000  b570              PUSH     {r4-r6,lr}
;;;165    {
000002  4605              MOV      r5,r0
;;;166    	// 先读SR，再填充DR会把TC标志清掉
;;;167    	usart_flag_get(BLE_HOST_UART_TYPE_DEF, USART_FLAG_TC);
000004  4c07              LDR      r4,|L6.36|
000006  2106              MOVS     r1,#6
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       usart_flag_get
;;;168    
;;;169    	// 发送一个字节
;;;170    	usart_data_transmit(BLE_HOST_UART_TYPE_DEF, data);
00000e  4629              MOV      r1,r5
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       usart_data_transmit
;;;171    
;;;172    	// 打开发送完成中断
;;;173    	usart_interrupt_enable(BLE_HOST_UART_TYPE_DEF, USART_INT_TC);	
000016  4620              MOV      r0,r4
000018  e8bd4070          POP      {r4-r6,lr}
00001c  f2403106          MOV      r1,#0x306
000020  f7ffbffe          B.W      usart_interrupt_enable
;;;174    }
;;;175    
                          ENDP

                  |L6.36|
                          DCD      0x40004800

                          AREA ||i.BLE_HOST_UART_Init||, CODE, READONLY, ALIGN=2

                  BLE_HOST_UART_Init PROC
;;;305    // UART初始化
;;;306    void BLE_HOST_UART_Init(void)
000000  b510              PUSH     {r4,lr}
;;;307    {
;;;308    	// 串口初始化
;;;309    	BLE_HOST_UART_HwInit(BLE_HOST_UART_BAUD_RATE);
000002  f44f30e1          MOV      r0,#0x1c200
000006  f7fffffe          BL       BLE_HOST_UART_HwInit
;;;310    
;;;311    	// UART数据结构初始化
;;;312    	BLE_HOST_UART_DataStructureInit(&bleHostUartCB);
00000a  e8bd4010          POP      {r4,lr}
00000e  4801              LDR      r0,|L7.20|
000010  f7ffbffe          B.W      BLE_HOST_UART_DataStructureInit
;;;313    }
;;;314    
                          ENDP

                  |L7.20|
                          DCD      ||.bss||+0xc8

                          AREA ||i.BLE_HOST_UART_Process||, CODE, READONLY, ALIGN=2

                  BLE_HOST_UART_Process PROC
;;;315    // UART模块处理入口
;;;316    void BLE_HOST_UART_Process(void)
000000  4801              LDR      r0,|L8.8|
;;;317    {
;;;318    	// 发送处理
;;;319    	BLE_HOST_UART_TxProcess(&bleHostUartCB);
000002  f7ffbffe          B.W      BLE_HOST_UART_TxProcess
;;;320    }
;;;321    
                          ENDP

000006  0000              DCW      0x0000
                  |L8.8|
                          DCD      ||.bss||+0xc8

                          AREA ||i.BLE_HOST_UART_RegisterDataSendService||, CODE, READONLY, ALIGN=2

                  BLE_HOST_UART_RegisterDataSendService PROC
;;;322    // 注册数据抛出接口服务
;;;323    void BLE_HOST_UART_RegisterDataSendService(void (*service)(uint16 id, uint8 *pData, uint16 length))
000000  4901              LDR      r1,|L9.8|
;;;324    {
;;;325    	bleHostUartCB.receiveDataThrowService = service;
000002  6008              STR      r0,[r1,#0]  ; bleHostUartCB
;;;326    }
000004  4770              BX       lr
;;;327    
                          ENDP

000006  0000              DCW      0x0000
                  |L9.8|
                          DCD      ||.bss||+0xc8

                          AREA ||i.BLE_HOST_UART_TxProcess||, CODE, READONLY, ALIGN=1

                  BLE_HOST_UART_TxProcess PROC
;;;89     // 发送处理
;;;90     void BLE_HOST_UART_TxProcess(BLE_HOST_UART_CB* pCB)
000000  b510              PUSH     {r4,lr}
;;;91     {
000002  4604              MOV      r4,r0
;;;92     	// 中断方式
;;;93     #if (BLE_HOST_UART_TX_MODE == BLE_HOST_UART_INTERRUPT_TX_MODE)
;;;94     	uint16 index = pCB->tx.index;							// 当前发送数据的索引号
000004  f8b4030a          LDRH     r0,[r4,#0x30a]
;;;95     	uint16 length = pCB->tx.cmdQueue[pCB->tx.head].length;	// 当前发送的命令帧的长度
000008  f8b41306          LDRH     r1,[r4,#0x306]
00000c  224d              MOVS     r2,#0x4d
00000e  4351              MULS     r1,r2,r1
000010  eb040141          ADD      r1,r4,r1,LSL #1
000014  f8b1209c          LDRH     r2,[r1,#0x9c]
;;;96     	uint16 head = pCB->tx.head;								// 发送命令帧队列头索引号
000018  f8b41306          LDRH     r1,[r4,#0x306]
;;;97     	uint16 end = pCB->tx.end;								// 发送命令帧队列尾索引号
00001c  f8b43308          LDRH     r3,[r4,#0x308]
;;;98     
;;;99     	// 参数合法性检验
;;;100    	if (NULL == pCB)
000020  2c00              CMP      r4,#0
000022  d017              BEQ      |L10.84|
;;;101    	{
;;;102    		return;
;;;103    	}
;;;104    	
;;;105    	// 队列为空，不处理
;;;106    	if (head == end)
000024  4299              CMP      r1,r3
000026  d015              BEQ      |L10.84|
;;;107    	{
;;;108    		return;
;;;109    	}
;;;110    
;;;111    	// 发送忙，退出
;;;112    	if (pCB->tx.txBusy)
000028  f894330c          LDRB     r3,[r4,#0x30c]
00002c  2b00              CMP      r3,#0
00002e  d111              BNE      |L10.84|
;;;113    	{
;;;114    		return;
;;;115    	}
;;;116    
;;;117    	// ■■执行到这里，说明队列非空■■
;;;118    	
;;;119    	// 当前命令帧未发送完时，取出一个字节放到发送寄存器中
;;;120    	if (index < length)
000030  4290              CMP      r0,r2
000032  d20f              BCS      |L10.84|
;;;121    	{		
;;;122    		BLE_HOST_UART_IR_StartSendData(pCB->tx.cmdQueue[head].buff[pCB->tx.index++]);
000034  f8b4030a          LDRH     r0,[r4,#0x30a]
000038  1c42              ADDS     r2,r0,#1
00003a  f8a4230a          STRH     r2,[r4,#0x30a]
00003e  224d              MOVS     r2,#0x4d
000040  4351              MULS     r1,r2,r1
000042  eb040141          ADD      r1,r4,r1,LSL #1
000046  4408              ADD      r0,r0,r1
000048  7980              LDRB     r0,[r0,#6]
00004a  f7fffffe          BL       BLE_HOST_UART_IR_StartSendData
;;;123    		
;;;124    		// 设置发送忙状态
;;;125    		pCB->tx.txBusy = TRUE;
00004e  2001              MOVS     r0,#1
000050  f884030c          STRB     r0,[r4,#0x30c]
                  |L10.84|
;;;126    	}
;;;127    
;;;128    // 阻塞方式时启动发送
;;;129    #else
;;;130    	uint16 index = pCB->tx.index;
;;;131    	uint16 head = pCB->tx.head;
;;;132    	uint16 end = pCB->tx.end;
;;;133    
;;;134    	// 参数合法性检验
;;;135    	if(NULL == pCB)
;;;136    	{
;;;137    		return;
;;;138    	}
;;;139    
;;;140    	// 队列为空，不处理
;;;141    	if(head == end)
;;;142    	{
;;;143    		return;
;;;144    	}
;;;145    	
;;;146    	// 当前命令帧未发送完时，持续发送
;;;147    	while(index < pCB->tx.cmdQueue[head].length)
;;;148    	{
;;;149    		// 一直填充发送
;;;150    		BLE_HOST_UART_BC_SendData(pCB->tx.cmdQueue[head].buff[pCB->tx.index++]);
;;;151    		
;;;152    		index = pCB->tx.index;
;;;153    	}
;;;154    	
;;;155    	// 当前命令帧发送完时，删除之
;;;156    	pCB->tx.cmdQueue[head].length = 0;
;;;157    	pCB->tx.head ++;
;;;158    	pCB->tx.head %= BLE_HOST_UART_DRIVE_TX_QUEUE_SIZE;
;;;159    	pCB->tx.index = 0;
;;;160    #endif
;;;161    }
000054  bd10              POP      {r4,pc}
;;;162    
                          ENDP


                          AREA ||i.USART2_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART2_IRQHandler PROC
;;;213    *************************************************************/
;;;214    void USART2_IRQHandler(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;215    {
;;;216    	// 判断DR是否有数据，中断接收
;;;217    	if (usart_interrupt_flag_get(BLE_HOST_UART_TYPE_DEF, USART_INT_FLAG_RBNE) != RESET) 
000002  4e3d              LDR      r6,|L11.248|
000004  493b              LDR      r1,|L11.244|
000006  4630              MOV      r0,r6
000008  f7fffffe          BL       usart_interrupt_flag_get
;;;218    	{
;;;219    		uint8 rxdata = 0x00;
;;;220    		uint32_t chr;
;;;221    		
;;;222    		// 接收数据
;;;223    		rxdata = (uint8)usart_data_receive(BLE_HOST_UART_TYPE_DEF);
;;;224    		
;;;225    		if (NULL != bleHostUartCB.receiveDataThrowService)
00000c  4c3b              LDR      r4,|L11.252|
00000e  2500              MOVS     r5,#0                 ;217
000010  b1c8              CBZ      r0,|L11.70|
000012  9500              STR      r5,[sp,#0]            ;219
000014  4630              MOV      r0,r6                 ;223
000016  f7fffffe          BL       usart_data_receive
00001a  9000              STR      r0,[sp,#0]            ;223
00001c  6823              LDR      r3,[r4,#0]  ; bleHostUartCB
00001e  b123              CBZ      r3,|L11.42|
;;;226    		{			
;;;227    			(*bleHostUartCB.receiveDataThrowService)(0xFFF, &rxdata, 1);
000020  2201              MOVS     r2,#1
000022  4669              MOV      r1,sp
000024  f64070ff          MOV      r0,#0xfff
000028  4798              BLX      r3
                  |L11.42|
;;;228    		}
;;;229    		
;;;230    //=================================================================
;;;231    		// 蓝牙连接判断
;;;232    		if ((bleHostIndex + 1)< sizeof(bleHostRxBuff)/sizeof(bleHostRxBuff[0]))
00002a  4a35              LDR      r2,|L11.256|
00002c  7811              LDRB     r1,[r2,#0]  ; bleHostIndex
00002e  4608              MOV      r0,r1
000030  1c49              ADDS     r1,r1,#1
000032  29c8              CMP      r1,#0xc8
000034  d207              BCS      |L11.70|
;;;233    		{
;;;234    			bleHostRxBuff[bleHostIndex++] = rxdata;
000036  f89d3000          LDRB     r3,[sp,#0]
00003a  b2c9              UXTB     r1,r1
00003c  7011              STRB     r1,[r2,#0]
00003e  4a2f              LDR      r2,|L11.252|
000040  3ac8              SUBS     r2,r2,#0xc8
000042  5413              STRB     r3,[r2,r0]
;;;235    			bleHostRxBuff[bleHostIndex] = '\0';
000044  5455              STRB     r5,[r2,r1]
                  |L11.70|
;;;236    		}
;;;237    
;;;238    //		TIMER_AddTask(TIMER_ID_BLE_HOST_CONNECT_STATE,
;;;239    //					10,
;;;240    //					BLE_HOST_UART_BleConnectState,
;;;241    //					0,
;;;242    //					1,
;;;243    //					ACTION_MODE_ADD_TO_QUEUE);
;;;244    	}
;;;245    
;;;246    
;;;247    // 中断模式发送
;;;248    #if (BLE_HOST_UART_TX_MODE == BLE_HOST_UART_INTERRUPT_TX_MODE)
;;;249    	// 判断DR是否有数据，中断发送
;;;250    	if (usart_interrupt_flag_get(BLE_HOST_UART_TYPE_DEF, USART_INT_FLAG_TC) != RESET)
000046  492f              LDR      r1,|L11.260|
000048  4630              MOV      r0,r6
00004a  f7fffffe          BL       usart_interrupt_flag_get
00004e  b3c8              CBZ      r0,|L11.196|
;;;251    	{
;;;252    		uint16 head = bleHostUartCB.tx.head;
000050  f8b40306          LDRH     r0,[r4,#0x306]  ; bleHostUartCB
;;;253    		uint16 end;
;;;254    		uint16 index = bleHostUartCB.tx.index;
000054  f8b4130a          LDRH     r1,[r4,#0x30a]  ; bleHostUartCB
;;;255    		uint8 txdata = 0x00;
;;;256    
;;;257    		// 执行到这里，说明上一个数据已经发送完毕，当前命令帧未发送完时，取出一个字节放到发送寄存器中
;;;258    		if (index < bleHostUartCB.tx.cmdQueue[head].length)
000058  224d              MOVS     r2,#0x4d
00005a  4350              MULS     r0,r2,r0
00005c  eb040240          ADD      r2,r4,r0,LSL #1
000060  f8b2009c          LDRH     r0,[r2,#0x9c]
000064  4288              CMP      r0,r1
000066  d90a              BLS      |L11.126|
;;;259    		{
;;;260    			txdata = bleHostUartCB.tx.cmdQueue[head].buff[bleHostUartCB.tx.index++];
000068  f8b4130a          LDRH     r1,[r4,#0x30a]  ; bleHostUartCB
00006c  1c48              ADDS     r0,r1,#1
00006e  f8a4030a          STRH     r0,[r4,#0x30a]
000072  1888              ADDS     r0,r1,r2
000074  7981              LDRB     r1,[r0,#6]
;;;261    			
;;;262    			// 填充数据
;;;263    			usart_data_transmit(BLE_HOST_UART_TYPE_DEF, txdata);
000076  4630              MOV      r0,r6
000078  f7fffffe          BL       usart_data_transmit
00007c  e02a              B        |L11.212|
                  |L11.126|
;;;264    		}
;;;265    		// 当前命令帧发送完时，删除之
;;;266    		else
;;;267    		{
;;;268    			bleHostUartCB.tx.cmdQueue[head].length = 0;
00007e  f8a2509c          STRH     r5,[r2,#0x9c]
;;;269    			bleHostUartCB.tx.head ++;
000082  f2043406          ADD      r4,r4,#0x306
000086  8820              LDRH     r0,[r4,#0]  ; bleHostUartCB
000088  1c40              ADDS     r0,r0,#1
00008a  8020              STRH     r0,[r4,#0]
;;;270    			bleHostUartCB.tx.head %= BLE_HOST_UART_DRIVE_TX_QUEUE_SIZE;
00008c  8820              LDRH     r0,[r4,#0]  ; bleHostUartCB
00008e  2105              MOVS     r1,#5
000090  fbb0f2f1          UDIV     r2,r0,r1
000094  fb010012          MLS      r0,r1,r2,r0
000098  8020              STRH     r0,[r4,#0]
;;;271    			bleHostUartCB.tx.index = 0;
00009a  80a5              STRH     r5,[r4,#4]
;;;272    
;;;273    			head = bleHostUartCB.tx.head;
00009c  8822              LDRH     r2,[r4,#0]  ; bleHostUartCB
;;;274    			end = bleHostUartCB.tx.end;
00009e  8860              LDRH     r0,[r4,#2]  ; bleHostUartCB
0000a0  f2a43406          SUB      r4,r4,#0x306
;;;275    			
;;;276    			// 命令帧队列非空，继续发送下一个命令帧
;;;277    			if (head != end)
0000a4  4282              CMP      r2,r0
0000a6  d00e              BEQ      |L11.198|
;;;278    			{
;;;279    				txdata = bleHostUartCB.tx.cmdQueue[head].buff[bleHostUartCB.tx.index++];
0000a8  f8b4130a          LDRH     r1,[r4,#0x30a]  ; bleHostUartCB
0000ac  1c48              ADDS     r0,r1,#1
0000ae  f8a4030a          STRH     r0,[r4,#0x30a]
0000b2  204d              MOVS     r0,#0x4d
0000b4  4342              MULS     r2,r0,r2
0000b6  eb040042          ADD      r0,r4,r2,LSL #1
0000ba  4408              ADD      r0,r0,r1
0000bc  7981              LDRB     r1,[r0,#6]
;;;280    
;;;281    				// 填充数据
;;;282    				usart_data_transmit(BLE_HOST_UART_TYPE_DEF, txdata);
0000be  4630              MOV      r0,r6
0000c0  f7fffffe          BL       usart_data_transmit
                  |L11.196|
0000c4  e006              B        |L11.212|
                  |L11.198|
;;;283    			}
;;;284    			// 命令帧队列为空停止发送，设置空闲
;;;285    			else
;;;286    			{
;;;287    				// 关闭发送完成中断
;;;288    				usart_interrupt_disable(BLE_HOST_UART_TYPE_DEF, USART_INT_TC);
0000c6  f2403106          MOV      r1,#0x306
0000ca  4630              MOV      r0,r6
0000cc  f7fffffe          BL       usart_interrupt_disable
;;;289    				
;;;290    				bleHostUartCB.tx.txBusy = FALSE;				
0000d0  f884530c          STRB     r5,[r4,#0x30c]
                  |L11.212|
;;;291    			}
;;;292    		}		
;;;293    	}
;;;294    #endif
;;;295    	
;;;296    	// Other USARTx interrupts handler can go here ...				 
;;;297    	if (usart_interrupt_flag_get(BLE_HOST_UART_TYPE_DEF, USART_INT_FLAG_ERR_ORERR) != RESET)	//----------------------- 接收溢出中断 
0000d4  490c              LDR      r1,|L11.264|
0000d6  4630              MOV      r0,r6
0000d8  f7fffffe          BL       usart_interrupt_flag_get
0000dc  2800              CMP      r0,#0
0000de  d008              BEQ      |L11.242|
;;;298    	{
;;;299    		usart_flag_get(BLE_HOST_UART_TYPE_DEF, USART_FLAG_ORERR); 			//----------------------- 清除接收溢出中断标志位 
0000e0  2103              MOVS     r1,#3
0000e2  4630              MOV      r0,r6
0000e4  f7fffffe          BL       usart_flag_get
;;;300    		usart_data_receive(BLE_HOST_UART_TYPE_DEF);									//----------------------- 清空寄存器
0000e8  4630              MOV      r0,r6
0000ea  e8bd40f8          POP      {r3-r7,lr}
0000ee  f7ffbffe          B.W      usart_data_receive
                  |L11.242|
;;;301    	}
;;;302    }
0000f2  bdf8              POP      {r3-r7,pc}
;;;303    
                          ENDP

                  |L11.244|
                          DCD      0x00050305
                  |L11.248|
                          DCD      0x40004800
                  |L11.252|
                          DCD      ||.bss||+0xc8
                  |L11.256|
                          DCD      ||.data||
                  |L11.260|
                          DCD      0x00060306
                  |L11.264|
                          DCD      0x00030500

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  bleHostRxBuff
                          %        200
                  bleHostUartCB
                          %        856

                          AREA ||.data||, DATA, ALIGN=0

                  bleHostIndex
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "User\\BleHostUart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_BleHostUart_c_5f57f8e8____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___13_BleHostUart_c_5f57f8e8____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_BleHostUart_c_5f57f8e8____REVSH|
#line 128
|__asm___13_BleHostUart_c_5f57f8e8____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
