; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\uartprotocol3.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\uartprotocol3.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -I.\User\qrencode -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.3\Device\Include -D__MICROLIB -D__UVISION_VERSION=539 -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\uartprotocol3.crf User\UartProtocol3.c]
                          THUMB

                          AREA ||i.UART_PROTOCOL4_CheckSUM||, CODE, READONLY, ALIGN=1

                  UART_PROTOCOL4_CheckSUM PROC
;;;418    // 对传入的命令帧进行校验，返回校验结果
;;;419    BOOL UART_PROTOCOL4_CheckSUM(UART_PROTOCOL4_RX_CMD_FRAME *pCmdFrame)
000000  b530              PUSH     {r4,r5,lr}
;;;420    {
;;;421        uint16 checkSum = 0;
000002  2200              MOVS     r2,#0
;;;422        uint16 sumTemp;
;;;423        uint16 i = 0;
;;;424    
;;;425        if (NULL == pCmdFrame)
000004  2800              CMP      r0,#0
000006  d004              BEQ      |L1.18|
;;;426        {
;;;427            return FALSE;
;;;428        }
;;;429    
;;;430        // 从设备地址开始，到校验码之前的一个字节，依次进行累加运算
;;;431        for (i = 1; i < pCmdFrame->length - 4; i++)
000008  2101              MOVS     r1,#1
00000a  f8b05098          LDRH     r5,[r0,#0x98]
00000e  1f2b              SUBS     r3,r5,#4
000010  e007              B        |L1.34|
                  |L1.18|
000012  2000              MOVS     r0,#0                 ;427
;;;432        {
;;;433            checkSum += pCmdFrame->buff[i];
;;;434        }
;;;435    
;;;436        // 累加和，低字节在前，高字节在后
;;;437        sumTemp = pCmdFrame->buff[pCmdFrame->length - 3]; // 高字节
;;;438        sumTemp <<= 8;
;;;439        sumTemp += pCmdFrame->buff[pCmdFrame->length - 4]; // 低字节
;;;440    
;;;441        // 判断计算得到的校验码与命令帧中的校验码是否相同
;;;442        if (sumTemp != checkSum)
;;;443        {
;;;444            return FALSE;
;;;445        }
;;;446    
;;;447        return TRUE;
;;;448    }
000014  bd30              POP      {r4,r5,pc}
                  |L1.22|
000016  1844              ADDS     r4,r0,r1              ;433
000018  78a4              LDRB     r4,[r4,#2]            ;433
00001a  4422              ADD      r2,r2,r4              ;433
00001c  b292              UXTH     r2,r2                 ;433
00001e  1c49              ADDS     r1,r1,#1              ;431
000020  b289              UXTH     r1,r1                 ;431
                  |L1.34|
000022  428b              CMP      r3,r1                 ;431
000024  dcf7              BGT      |L1.22|
000026  1e41              SUBS     r1,r0,#1              ;437
000028  5c69              LDRB     r1,[r5,r1]            ;437
00002a  f64f73ff          MOV      r3,#0xffff            ;438
00002e  ea032101          AND      r1,r3,r1,LSL #8       ;438
000032  1e80              SUBS     r0,r0,#2              ;439
000034  5c28              LDRB     r0,[r5,r0]            ;439
000036  4408              ADD      r0,r0,r1              ;439
000038  b280              UXTH     r0,r0                 ;439
00003a  4290              CMP      r0,r2                 ;442
00003c  d001              BEQ      |L1.66|
00003e  2000              MOVS     r0,#0                 ;444
000040  bd30              POP      {r4,r5,pc}
                  |L1.66|
000042  2001              MOVS     r0,#1                 ;447
000044  bd30              POP      {r4,r5,pc}
;;;449    
                          ENDP


                          AREA ||i.UART_PROTOCOL4_CmdFrameProcess||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL4_CmdFrameProcess PROC
;;;450    // UART命令帧缓冲区处理
;;;451    void UART_PROTOCOL4_CmdFrameProcess(UART_PROTOCOL4_CB *pCB)
000000  b570              PUSH     {r4-r6,lr}
;;;452    {
000002  4604              MOV      r4,r0
;;;453        UART_PROTOCOL4_CMD cmd = UART_PROTOCOL4_CMD_NULL;
;;;454        UART_PROTOCOL4_RX_CMD_FRAME *pCmdFrame = NULL;
;;;455        
;;;456        uint8_t i = 0;
;;;457        BOOL checkMark;
;;;458        
;;;459        // 参数合法性检验
;;;460        if (NULL == pCB)
000004  2c00              CMP      r4,#0
000006  d016              BEQ      |L2.54|
;;;461        {
;;;462            return;
;;;463        }
;;;464    
;;;465        // 命令帧缓冲区为空，退出
;;;466        if (pCB->rx.head == pCB->rx.end)
000008  f8b4029e          LDRH     r0,[r4,#0x29e]
00000c  f8b412a0          LDRH     r1,[r4,#0x2a0]
000010  4288              CMP      r0,r1
000012  d010              BEQ      |L2.54|
;;;467        {
;;;468            return;
;;;469        }
;;;470    
;;;471        // 获取当前要处理的命令帧指针
;;;472        pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.head];
000014  214d              MOVS     r1,#0x4d
000016  4341              MULS     r1,r0,r1
000018  eb040141          ADD      r1,r4,r1,LSL #1
00001c  31d0              ADDS     r1,r1,#0xd0
;;;473    
;;;474        // 命令头非法，退出
;;;475        if (UART_PROTOCOL4_CMD_HEAD != pCmdFrame->buff[UART_PROTOCOL4_CMD_HEAD_INDEX])
;;;476        {
;;;477            // 删除命令帧
;;;478            pCB->rx.head++;
;;;479            pCB->rx.head %= UART_PROTOCOL4_RX_QUEUE_SIZE;
00001e  2503              MOVS     r5,#3
000020  788a              LDRB     r2,[r1,#2]            ;475
000022  2a3a              CMP      r2,#0x3a              ;475
000024  d008              BEQ      |L2.56|
000026  1c40              ADDS     r0,r0,#1              ;478
000028  b280              UXTH     r0,r0                 ;478
00002a  fbb0f1f5          UDIV     r1,r0,r5
00002e  fb050011          MLS      r0,r5,r1,r0
000032  f8a4029e          STRH     r0,[r4,#0x29e]
                  |L2.54|
;;;480            return;
;;;481        }
;;;482    
;;;483        // 命令头合法，则提取命令
;;;484        cmd = (UART_PROTOCOL4_CMD)pCmdFrame->buff[UART_PROTOCOL4_CMD_CMD_INDEX];
;;;485    
;;;486        // 执行命令帧
;;;487        switch (cmd)
;;;488        {
;;;489            // 空命令，不予执行
;;;490            case UART_PROTOCOL4_CMD_NULL: // 0x53
;;;491                break;
;;;492    
;;;493    //       // 协议切换
;;;494    //       case UART_PROTOCOL4_CMD_PROTOCOL_SWITCCH:
;;;495    //            TIMER_KillTask(TIMER_ID_PROTOCOL_SWITCCH);
;;;496    //            
;;;497    //            // 协议切换成功
;;;498    //            if(pCmdFrame->buff[UART_PROTOCOL4_CMD_DATA1_INDEX])
;;;499    //            {
;;;500    //                STATE_SwitchStep(STEP_CM_UART_BC_UPGRADE_WAIT_FOR_ACK);
;;;501    //                
;;;502    //                // 发送配置
;;;503    //                TIMER_AddTask(TIMER_ID_SET_DUT_CONFIG,
;;;504    //                              500,
;;;505    //                              STATE_SwitchStep,
;;;506    //                              STEP_UART_SEND_SET_CONFIG,
;;;507    //                              TIMER_LOOP_FOREVER,
;;;508    //                              ACTION_MODE_ADD_TO_QUEUE);
;;;509    //            }             
;;;510    //            break;
;;;511    //            
;;;512    //        case UART_PROTOCOL4_CMD_WRITE_CONFIG_RESULT: // 0xc1
;;;513    //            // dut_config升级成功
;;;514    //            STATE_SwitchStep(STEP_UART_READ_CONFIG);
;;;515    //            break;
;;;516    
;;;517    //        case UART_PROTOCOL4_CMD_NEW_WRITE_CONTROL_PARAM: // 0x50
;;;518    //            // dut_config升级成功
;;;519    //            STATE_SwitchStep(STEP_UART_READ_CONFIG);
;;;520    //            break;
;;;521    
;;;522    //        // 校验配置参数
;;;523    //        case UART_PROTOCOL4_CMD_READ_CONTROL_PARAM_REPORT: // 0xc3     
;;;524    //            
;;;525    //            for(i = 0; i< pCmdFrame->buff[UART_PROTOCOL4_CMD_LENGTH_INDEX]; i++)
;;;526    //            {  
;;;527    //               if(verifiedBuff[i] == pCmdFrame->buff[UART_PROTOCOL4_CMD_DATA1_INDEX + i] )
;;;528    //               {
;;;529    //                  checkMark = TRUE;
;;;530    //               }
;;;531    //               else
;;;532    //               {
;;;533    //                  checkMark = FALSE;
;;;534    //               }
;;;535    //            }
;;;536    //            
;;;537    //            if(checkMark)
;;;538    //            {
;;;539    //                STATE_SwitchStep(STEP_UART_SET_CONFIG_SUCCESS);
;;;540    //            }
;;;541    //            else
;;;542    //            {
;;;543    //                STATE_SwitchStep(STEP_CM_UART_BC_UPGRADE_ITEM_FINISH);
;;;544    //            }
;;;545    
;;;546    //            break;
;;;547    
;;;548            default:
;;;549                if(dut_info.passThroughControl)
;;;550                {
;;;551                    STS_UART_AddTxArray(0, pCmdFrame->buff, pCmdFrame->length);            
;;;552                }             
;;;553                break;
;;;554        }
;;;555    
;;;556        // 删除命令帧
;;;557        pCB->rx.head++;
;;;558        pCB->rx.head %= UART_PROTOCOL4_RX_QUEUE_SIZE;
;;;559    }
000036  bd70              POP      {r4-r6,pc}
                  |L2.56|
000038  7908              LDRB     r0,[r1,#4]            ;484
00003a  b148              CBZ      r0,|L2.80|
00003c  480a              LDR      r0,|L2.104|
00003e  f8900120          LDRB     r0,[r0,#0x120]        ;549  ; dut_info
000042  b128              CBZ      r0,|L2.80|
000044  f8b12098          LDRH     r2,[r1,#0x98]         ;551
000048  1c89              ADDS     r1,r1,#2              ;551
00004a  2000              MOVS     r0,#0                 ;551
00004c  f7fffffe          BL       STS_UART_AddTxArray
                  |L2.80|
000050  f8b4029e          LDRH     r0,[r4,#0x29e]        ;557
000054  1c40              ADDS     r0,r0,#1              ;557
000056  b280              UXTH     r0,r0                 ;557
000058  fbb0f1f5          UDIV     r1,r0,r5              ;558
00005c  fb050011          MLS      r0,r5,r1,r0           ;558
000060  f8a4029e          STRH     r0,[r4,#0x29e]        ;558
000064  bd70              POP      {r4-r6,pc}
                          ENDP

000066  0000              DCW      0x0000
                  |L2.104|
                          DCD      dut_info

                          AREA ||i.UART_PROTOCOL4_ConfirmTempCmdFrameBuff||, CODE, READONLY, ALIGN=1

                  UART_PROTOCOL4_ConfirmTempCmdFrameBuff PROC
;;;199    // 将临时缓冲区添加到命令帧缓冲区中，其本质操作是承认临时缓冲区数据有效
;;;200    BOOL UART_PROTOCOL4_ConfirmTempCmdFrameBuff(UART_PROTOCOL4_CB *pCB)
000000  2800              CMP      r0,#0
;;;201    {
000002  d01a              BEQ      |L3.58|
;;;202        UART_PROTOCOL4_RX_CMD_FRAME *pCmdFrame = NULL;
;;;203    
;;;204        // 参数合法性检验
;;;205        if (NULL == pCB)
;;;206        {
;;;207            return FALSE;
;;;208        }
;;;209    
;;;210        // 临时缓冲区为空，不予添加
;;;211        pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.end];
000004  f8b012a0          LDRH     r1,[r0,#0x2a0]
000008  224d              MOVS     r2,#0x4d
00000a  434a              MULS     r2,r1,r2
00000c  eb000242          ADD      r2,r0,r2,LSL #1
;;;212        if (0 == pCmdFrame->length)
000010  f8b22168          LDRH     r2,[r2,#0x168]
000014  b19a              CBZ      r2,|L3.62|
;;;213        {
;;;214            return FALSE;
;;;215        }
;;;216    
;;;217        // 添加
;;;218        pCB->rx.end++;
000016  1c49              ADDS     r1,r1,#1
000018  b289              UXTH     r1,r1
;;;219        pCB->rx.end %= UART_PROTOCOL4_RX_QUEUE_SIZE;
00001a  2203              MOVS     r2,#3
00001c  fbb1f3f2          UDIV     r3,r1,r2
000020  fb021113          MLS      r1,r2,r3,r1
000024  f8a012a0          STRH     r1,[r0,#0x2a0]
;;;220        pCB->rx.cmdQueue[pCB->rx.end].length = 0; // 该行的作用是将新的添加位置有效数据个数清零，以便将这个位置当做临时帧缓冲区
000028  2200              MOVS     r2,#0
00002a  234d              MOVS     r3,#0x4d
00002c  4359              MULS     r1,r3,r1
00002e  eb000041          ADD      r0,r0,r1,LSL #1
000032  f8a02168          STRH     r2,[r0,#0x168]
;;;221    
;;;222        return TRUE;
000036  2001              MOVS     r0,#1
;;;223    }
000038  4770              BX       lr
                  |L3.58|
00003a  2000              MOVS     r0,#0                 ;207
00003c  4770              BX       lr
                  |L3.62|
00003e  2000              MOVS     r0,#0                 ;214
000040  4770              BX       lr
;;;224    
                          ENDP


                          AREA ||i.UART_PROTOCOL4_DataStructInit||, CODE, READONLY, ALIGN=1

                  UART_PROTOCOL4_DataStructInit PROC
;;;132    // 数据结构初始化
;;;133    void UART_PROTOCOL4_DataStructInit(UART_PROTOCOL4_CB *pCB)
000000  2800              CMP      r0,#0
;;;134    {
000002  d027              BEQ      |L4.84|
;;;135        uint16 i;
;;;136    
;;;137        // 参数合法性检验
;;;138        if (NULL == pCB)
;;;139        {
;;;140            return;
;;;141        }
;;;142    
;;;143        pCB->tx.txBusy = FALSE;
000004  2200              MOVS     r2,#0
000006  f8802476          STRB     r2,[r0,#0x476]
;;;144        pCB->tx.index = 0;
00000a  f8a02474          STRH     r2,[r0,#0x474]
;;;145        pCB->tx.head = 0;
00000e  f8a02470          STRH     r2,[r0,#0x470]
;;;146        pCB->tx.end = 0;
000012  f8a02472          STRH     r2,[r0,#0x472]
;;;147        for (i = 0; i < UART_PROTOCOL4_TX_QUEUE_SIZE; i++)
000016  2100              MOVS     r1,#0
                  |L4.24|
;;;148        {
;;;149            pCB->tx.cmdQueue[i].length = 0;
000018  234d              MOVS     r3,#0x4d
00001a  434b              MULS     r3,r1,r3
00001c  eb000343          ADD      r3,r0,r3,LSL #1
000020  f8a3233a          STRH     r2,[r3,#0x33a]
000024  1c49              ADDS     r1,r1,#1              ;147
000026  b289              UXTH     r1,r1                 ;147
000028  2903              CMP      r1,#3                 ;147
00002a  d3f5              BCC      |L4.24|
;;;150        }
;;;151    
;;;152        pCB->rxFIFO.head = 0;
00002c  f8202fc8          STRH     r2,[r0,#0xc8]!
;;;153        pCB->rxFIFO.end = 0;
000030  8042              STRH     r2,[r0,#2]
;;;154        pCB->rxFIFO.currentProcessIndex = 0;
000032  8082              STRH     r2,[r0,#4]
;;;155    
;;;156        pCB->rx.head = 0;
000034  f8a021d6          STRH     r2,[r0,#0x1d6]
;;;157        pCB->rx.end = 0;
000038  f8a021d8          STRH     r2,[r0,#0x1d8]
00003c  38c8              SUBS     r0,r0,#0xc8
;;;158        for (i = 0; i < UART_PROTOCOL4_RX_QUEUE_SIZE; i++)
00003e  2100              MOVS     r1,#0
                  |L4.64|
;;;159        {
;;;160            pCB->rx.cmdQueue[i].length = 0;
000040  234d              MOVS     r3,#0x4d
000042  434b              MULS     r3,r1,r3
000044  eb000343          ADD      r3,r0,r3,LSL #1
000048  f8a32168          STRH     r2,[r3,#0x168]
00004c  1c49              ADDS     r1,r1,#1              ;158
00004e  b289              UXTH     r1,r1                 ;158
000050  2903              CMP      r1,#3                 ;158
000052  d3f5              BCC      |L4.64|
                  |L4.84|
;;;161        }
;;;162    }
000054  4770              BX       lr
;;;163    
                          ENDP


                          AREA ||i.UART_PROTOCOL4_Init||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL4_Init PROC
;;;41     // 协议初始化
;;;42     void UART_PROTOCOL4_Init(void)
000000  b510              PUSH     {r4,lr}
;;;43     {
;;;44         // 协议层数据结构初始化
;;;45         UART_PROTOCOL4_DataStructInit(&uartProtocolCB4);
000002  4805              LDR      r0,|L5.24|
000004  f7fffffe          BL       UART_PROTOCOL4_DataStructInit
;;;46     
;;;47         // 向驱动层注册数据接收接口
;;;48         UART_DRIVE_RegisterDataSendService(UART_PROTOCOL4_MacProcess);
000008  4804              LDR      r0,|L5.28|
00000a  f7fffffe          BL       UART_DRIVE_RegisterDataSendService
;;;49     
;;;50         // 向驱动层注册数据发送接口
;;;51         UART_PROTOCOL4_RegisterDataSendService(UART_DRIVE_AddTxArray);
00000e  e8bd4010          POP      {r4,lr}
000012  4803              LDR      r0,|L5.32|
000014  f7ffbffe          B.W      UART_PROTOCOL4_RegisterDataSendService
;;;52     
;;;53         //  TIMER_AddTask(TIMER_ID_PROTOCOL_3A_PARAM_TX,
;;;54         //                  200,
;;;55         //                  UART_PROTOCOL4_22,
;;;56         //                  TRUE,
;;;57         //                  TIMER_LOOP_FOREVER,
;;;58         //                  ACTION_MODE_ADD_TO_QUEUE);
;;;59     }
;;;60     
                          ENDP

                  |L5.24|
                          DCD      ||.bss||
                  |L5.28|
                          DCD      UART_PROTOCOL4_MacProcess
                  |L5.32|
                          DCD      UART_DRIVE_AddTxArray

                          AREA ||i.UART_PROTOCOL4_MacProcess||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL4_MacProcess PROC
;;;164    // UART报文接收处理函数(注意根据具体模块修改)
;;;165    void UART_PROTOCOL4_MacProcess(uint16 standarID, uint8 *pData, uint16 length)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;166    {
000004  4681              MOV      r9,r0
000006  4688              MOV      r8,r1
000008  4692              MOV      r10,r2
;;;167        uint16 end = uartProtocolCB4.rxFIFO.end;
00000a  4c13              LDR      r4,|L6.88|
00000c  f8b450ca          LDRH     r5,[r4,#0xca]  ; uartProtocolCB4
;;;168        uint16 head = uartProtocolCB4.rxFIFO.head;
000010  f8b460c8          LDRH     r6,[r4,#0xc8]  ; uartProtocolCB4
;;;169        uint8 rxdata = 0x00;
;;;170    
;;;171        // 接收数据
;;;172        rxdata = *pData;
000014  f8987000          LDRB     r7,[r8,#0]
;;;173    
;;;174        // 借用KM5S协议解析
;;;175        UART_PROTOCOL_MacProcess(standarID, pData, length);
000018  4652              MOV      r2,r10
00001a  4641              MOV      r1,r8
00001c  4648              MOV      r0,r9
00001e  f7fffffe          BL       UART_PROTOCOL_MacProcess
;;;176        UART_PROTOCOL_XM_MacProcess(standarID, pData, length);
000022  4652              MOV      r2,r10
000024  4641              MOV      r1,r8
000026  4648              MOV      r0,r9
000028  f7fffffe          BL       UART_PROTOCOL_XM_MacProcess
;;;177        
;;;178        // 一级缓冲区已满，不予接收
;;;179        if ((end + 1) % UART_PROTOCOL4_RX_FIFO_SIZE == head)
00002c  1c6b              ADDS     r3,r5,#1
00002e  20c8              MOVS     r0,#0xc8
000030  fbb3f1f0          UDIV     r1,r3,r0
000034  fb003111          MLS      r1,r0,r1,r3
000038  42b1              CMP      r1,r6
00003a  d00a              BEQ      |L6.82|
;;;180        {
;;;181            return;
;;;182        }
;;;183        // 一级缓冲区未满，接收
;;;184        else
;;;185        {
;;;186            // 将接收到的数据放到临时缓冲区中
;;;187            uartProtocolCB4.rxFIFO.buff[end] = rxdata;
00003c  5567              STRB     r7,[r4,r5]
;;;188            uartProtocolCB4.rxFIFO.end++;
00003e  f8341fca          LDRH     r1,[r4,#0xca]!  ; uartProtocolCB4
000042  1c49              ADDS     r1,r1,#1
000044  8021              STRH     r1,[r4,#0]
;;;189            uartProtocolCB4.rxFIFO.end %= UART_PROTOCOL4_RX_FIFO_SIZE;
000046  8821              LDRH     r1,[r4,#0]  ; uartProtocolCB4
000048  fbb1f2f0          UDIV     r2,r1,r0
00004c  fb001012          MLS      r0,r0,r2,r1
000050  8020              STRH     r0,[r4,#0]
                  |L6.82|
;;;190        }
;;;191    }
000052  e8bd87f0          POP      {r4-r10,pc}
;;;192    
                          ENDP

000056  0000              DCW      0x0000
                  |L6.88|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOL4_RegisterDataSendService||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL4_RegisterDataSendService PROC
;;;193    // UART协议层向驱动层注册数据发送接口
;;;194    void UART_PROTOCOL4_RegisterDataSendService(BOOL (*service)(uint16 id, uint8 *pData, uint16 length))
000000  4901              LDR      r1,|L7.8|
;;;195    {
;;;196        uartProtocolCB4.sendDataThrowService = service;
000002  f8c10478          STR      r0,[r1,#0x478]  ; uartProtocolCB4
;;;197    }
000006  4770              BX       lr
;;;198    
                          ENDP

                  |L7.8|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOL4_RxFIFOProcess||, CODE, READONLY, ALIGN=1

                  UART_PROTOCOL4_RxFIFOProcess PROC
;;;258    // 一级接收缓冲区处理，从一级接收缓冲区中取出一个字节添加到命令帧缓冲区中
;;;259    void UART_PROTOCOL4_RxFIFOProcess(UART_PROTOCOL4_CB *pCB)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;260    {
000004  4604              MOV      r4,r0
;;;261        uint16 end = pCB->rxFIFO.end;
000006  f8b410ca          LDRH     r1,[r4,#0xca]
;;;262        uint16 head = pCB->rxFIFO.head;
00000a  f8b400c8          LDRH     r0,[r4,#0xc8]
;;;263        UART_PROTOCOL4_RX_CMD_FRAME *pCmdFrame = NULL;
;;;264        uint16 length = 0;
;;;265        uint8 currentData = 0;
;;;266    
;;;267        // 参数合法性检验
;;;268        if (NULL == pCB)
00000e  2c00              CMP      r4,#0
000010  d021              BEQ      |L8.86|
;;;269        {
;;;270            return;
;;;271        }
;;;272    
;;;273        // 一级缓冲区为空，退出
;;;274        if (head == end)
000012  4288              CMP      r0,r1
000014  d01f              BEQ      |L8.86|
;;;275        {
;;;276            return;
;;;277        }
;;;278    
;;;279        // 获取临时缓冲区指针
;;;280        pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.end];
000016  f8b422a0          LDRH     r2,[r4,#0x2a0]
00001a  204d              MOVS     r0,#0x4d
00001c  4350              MULS     r0,r2,r0
00001e  eb040540          ADD      r5,r4,r0,LSL #1
000022  35d0              ADDS     r5,r5,#0xd0
;;;281        // 取出当前要处理的字节
;;;282        currentData = pCB->rxFIFO.buff[pCB->rxFIFO.currentProcessIndex];
000024  f8b400cc          LDRH     r0,[r4,#0xcc]
000028  5c20              LDRB     r0,[r4,r0]
;;;283    
;;;284        // 临时缓冲区长度为0时，搜索首字节
;;;285        if (0 == pCmdFrame->length)
00002a  f8b53098          LDRH     r3,[r5,#0x98]
;;;286        {
;;;287            // 命令头错误，删除当前字节并退出
;;;288            if (UART_PROTOCOL4_CMD_HEAD != currentData)
;;;289            {
;;;290                pCB->rxFIFO.head++;
;;;291                pCB->rxFIFO.head %= UART_PROTOCOL4_RX_FIFO_SIZE;
00002e  27c8              MOVS     r7,#0xc8
000030  b19b              CBZ      r3,|L8.90|
;;;292                pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;293    
;;;294                return;
;;;295            }
;;;296    
;;;297            // 命令头正确，但无临时缓冲区可用，退出
;;;298            if ((pCB->rx.end + 1) % UART_PROTOCOL4_RX_QUEUE_SIZE == pCB->rx.head)
;;;299            {
;;;300                return;
;;;301            }
;;;302    
;;;303            // 添加UART通讯超时时间设置-2016.1.5增加
;;;304    #if UART_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;305            TIMER_AddTask(TIMER_ID_UART_RX_TIME_OUT_CONTROL,
;;;306                          UART_PROTOCOL_BUS_UNIDIRECTIONAL_TIME_OUT,
;;;307                          UART_PROTOCOL_CALLBACK_RxTimeOut,
;;;308                          0,
;;;309                          1,
;;;310                          ACTION_MODE_ADD_TO_QUEUE);
;;;311    #endif
;;;312    
;;;313            // 命令头正确，有临时缓冲区可用，则将其添加到命令帧临时缓冲区中
;;;314            pCmdFrame->buff[pCmdFrame->length++] = currentData;
;;;315            pCB->rxFIFO.currentProcessIndex++;
;;;316            pCB->rxFIFO.currentProcessIndex %= UART_PROTOCOL4_RX_FIFO_SIZE;
;;;317        }
;;;318        // 非首字节，将数据添加到命令帧临时缓冲区中，但暂不删除当前数据
;;;319        else
;;;320        {
;;;321            // 临时缓冲区溢出，说明当前正在接收的命令帧是错误的，正确的命令帧不会出现长度溢出的情况
;;;322            if (pCmdFrame->length >= UART_PROTOCOL4_RX_CMD_FRAME_LENGTH_MAX)
000032  f04f0800          MOV      r8,#0
000036  2b96              CMP      r3,#0x96
000038  d37e              BCC      |L8.312|
;;;323            {
;;;324    #if UART_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;325                // 停止RX通讯超时检测
;;;326                UART_PROTOCOL_StopRxTimeOutCheck();
;;;327    #endif
;;;328    
;;;329                // 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;330                pCmdFrame->length = 0; // 2016.1.5增加
00003a  f8a58098          STRH     r8,[r5,#0x98]
;;;331                // 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;332                pCB->rxFIFO.head++;
00003e  f8340fc8          LDRH     r0,[r4,#0xc8]!
000042  1c40              ADDS     r0,r0,#1
000044  8020              STRH     r0,[r4,#0]
;;;333                pCB->rxFIFO.head %= UART_PROTOCOL4_RX_FIFO_SIZE;
000046  8820              LDRH     r0,[r4,#0]
000048  fbb0f1f7          UDIV     r1,r0,r7
00004c  fb070011          MLS      r0,r7,r1,r0
000050  8020              STRH     r0,[r4,#0]
;;;334                pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
000052  8820              LDRH     r0,[r4,#0]
000054  80a0              STRH     r0,[r4,#4]
                  |L8.86|
;;;335    
;;;336                return;
;;;337            }
;;;338    
;;;339            // 一直取到末尾
;;;340            while (end != pCB->rxFIFO.currentProcessIndex)
;;;341            {
;;;342                // 取出当前要处理的字节
;;;343                currentData = pCB->rxFIFO.buff[pCB->rxFIFO.currentProcessIndex];
;;;344                // 缓冲区未溢出，正常接收，将数据添加到临时缓冲区中
;;;345                pCmdFrame->buff[pCmdFrame->length++] = currentData;
;;;346                pCB->rxFIFO.currentProcessIndex++;
;;;347                pCB->rxFIFO.currentProcessIndex %= UART_PROTOCOL_RX_FIFO_SIZE;
;;;348    
;;;349                // ■■接下来，需要检查命令帧是否完整，如果完整，则将命令帧临时缓冲区扶正■■
;;;350    
;;;351                // 首先判断命令帧最小长度，一个完整的命令字至少包括8个字节: 命令头、设备地址、命令字、数据长度、校验和L、校验和H、结束标识0xD、结束标识OxA，因此不足8个字节的必定不完整
;;;352                if (pCmdFrame->length < UART_PROTOCOL4_CMD_FRAME_LENGTH_MIN)
;;;353                {
;;;354                    // 继续接收
;;;355                    continue;
;;;356                }
;;;357    
;;;358                // 命令帧长度数值越界，说明当前命令帧错误，停止接收
;;;359                if (pCmdFrame->buff[UART_PROTOCOL4_CMD_LENGTH_INDEX] > UART_PROTOCOL4_RX_CMD_FRAME_LENGTH_MAX - UART_PROTOCOL4_CMD_FRAME_LENGTH_MIN)
;;;360                {
;;;361    #if UART_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;362                    // 停止RX通讯超时检测
;;;363                    UART_PROTOCOL_StopRxTimeOutCheck();
;;;364    #endif
;;;365    
;;;366                    // 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;367                    pCmdFrame->length = 0;
;;;368                    // 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;369                    pCB->rxFIFO.head++;
;;;370                    pCB->rxFIFO.head %= UART_PROTOCOL4_RX_FIFO_SIZE;
;;;371                    pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;372    
;;;373                    return;
;;;374                }
;;;375    
;;;376                // 命令帧长度校验，在命令长度描述字的数值上，增加命令头、设备地址、命令字、数据长度、校验和L、校验和H、结束标识0xD、结束标识OxA，即为命令帧实际长度
;;;377                length = pCmdFrame->length;
;;;378                if (length < pCmdFrame->buff[UART_PROTOCOL4_CMD_LENGTH_INDEX] + UART_PROTOCOL4_CMD_FRAME_LENGTH_MIN)
;;;379                {
;;;380                    // 长度要求不一致，说明未接收完毕，退出继续
;;;381                    continue;
;;;382                }
;;;383    
;;;384                // 命令帧长度OK，则进行校验，失败时删除命令头
;;;385                if (!UART_PROTOCOL4_CheckSUM(pCmdFrame))
;;;386                {
;;;387    #if UART_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;388                    // 停止RX通讯超时检测
;;;389                    UART_PROTOCOL_StopRxTimeOutCheck();
;;;390    #endif
;;;391    
;;;392                    // 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;393                    pCmdFrame->length = 0;
;;;394                    // 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;395                    pCB->rxFIFO.head++;
;;;396                    pCB->rxFIFO.head %= UART_PROTOCOL4_RX_FIFO_SIZE;
;;;397                    pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;398    
;;;399                    return;
;;;400                }
;;;401    
;;;402    #if UART_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;403                // 停止RX通讯超时检测
;;;404                UART_PROTOCOL_StopRxTimeOutCheck();
;;;405    #endif
;;;406    
;;;407                // 执行到这里，即说明接收到了一个完整并且正确的命令帧，此时需将处理过的数据从一级缓冲区中删除，并将该命令帧扶正
;;;408                pCB->rxFIFO.head += length;
;;;409                pCB->rxFIFO.head %= UART_PROTOCOL_RX_FIFO_SIZE;
;;;410                pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;411                UART_PROTOCOL4_ConfirmTempCmdFrameBuff(pCB);
;;;412    
;;;413                return;
;;;414            }
;;;415        }
;;;416    }
000056  e8bd81f0          POP      {r4-r8,pc}
                  |L8.90|
00005a  283a              CMP      r0,#0x3a              ;288
00005c  d00c              BEQ      |L8.120|
00005e  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;290
000062  1c40              ADDS     r0,r0,#1              ;290
000064  8020              STRH     r0,[r4,#0]            ;290
000066  8820              LDRH     r0,[r4,#0]            ;291
000068  fbb0f1f7          UDIV     r1,r0,r7              ;291
00006c  fb070011          MLS      r0,r7,r1,r0           ;291
000070  8020              STRH     r0,[r4,#0]            ;291
000072  8820              LDRH     r0,[r4,#0]            ;292
000074  80a0              STRH     r0,[r4,#4]            ;292
000076  e7ee              B        |L8.86|
                  |L8.120|
000078  1c52              ADDS     r2,r2,#1              ;298
00007a  2103              MOVS     r1,#3                 ;298
00007c  fbb2f3f1          UDIV     r3,r2,r1              ;298
000080  fb012113          MLS      r1,r1,r3,r2           ;298
000084  f8b4229e          LDRH     r2,[r4,#0x29e]        ;298
000088  4291              CMP      r1,r2                 ;298
00008a  d0e4              BEQ      |L8.86|
00008c  2101              MOVS     r1,#1                 ;314
00008e  f8a51098          STRH     r1,[r5,#0x98]         ;314
000092  70a8              STRB     r0,[r5,#2]            ;314
000094  f8340fcc          LDRH     r0,[r4,#0xcc]!        ;315
000098  1c40              ADDS     r0,r0,#1              ;315
00009a  b280              UXTH     r0,r0                 ;315
00009c  fbb0f1f7          UDIV     r1,r0,r7              ;316
0000a0  fb070011          MLS      r0,r7,r1,r0           ;316
0000a4  8020              STRH     r0,[r4,#0]            ;316
0000a6  e7d6              B        |L8.86|
                  |L8.168|
0000a8  5c22              LDRB     r2,[r4,r0]            ;343
0000aa  f8b50098          LDRH     r0,[r5,#0x98]         ;345
0000ae  1c43              ADDS     r3,r0,#1              ;345
0000b0  4428              ADD      r0,r0,r5              ;345
0000b2  f8a53098          STRH     r3,[r5,#0x98]         ;345
0000b6  7082              STRB     r2,[r0,#2]            ;345
0000b8  f8b400cc          LDRH     r0,[r4,#0xcc]         ;346
0000bc  1c40              ADDS     r0,r0,#1              ;346
0000be  b280              UXTH     r0,r0                 ;346
0000c0  fbb0f2f7          UDIV     r2,r0,r7              ;347
0000c4  fb070012          MLS      r0,r7,r2,r0           ;347
0000c8  f8a400cc          STRH     r0,[r4,#0xcc]         ;347
0000cc  f8b56098          LDRH     r6,[r5,#0x98]         ;352
0000d0  2e08              CMP      r6,#8                 ;352
0000d2  d33b              BCC      |L8.332|
0000d4  7968              LDRB     r0,[r5,#5]            ;359
0000d6  288e              CMP      r0,#0x8e              ;359
0000d8  d90e              BLS      |L8.248|
0000da  f8a58098          STRH     r8,[r5,#0x98]         ;367
0000de  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;369
0000e2  1c40              ADDS     r0,r0,#1              ;369
0000e4  8020              STRH     r0,[r4,#0]            ;369
0000e6  8820              LDRH     r0,[r4,#0]            ;370
0000e8  fbb0f1f7          UDIV     r1,r0,r7              ;370
0000ec  fb070011          MLS      r0,r7,r1,r0           ;370
0000f0  8020              STRH     r0,[r4,#0]            ;370
0000f2  8820              LDRH     r0,[r4,#0]            ;371
0000f4  80a0              STRH     r0,[r4,#4]            ;371
0000f6  e7ae              B        |L8.86|
                  |L8.248|
0000f8  3008              ADDS     r0,r0,#8              ;378
0000fa  42b0              CMP      r0,r6                 ;378
0000fc  d826              BHI      |L8.332|
0000fe  4628              MOV      r0,r5                 ;385
000100  f7fffffe          BL       UART_PROTOCOL4_CheckSUM
000104  b188              CBZ      r0,|L8.298|
000106  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;408
00010a  4430              ADD      r0,r0,r6              ;408
00010c  8020              STRH     r0,[r4,#0]            ;408
00010e  8820              LDRH     r0,[r4,#0]            ;409
000110  fbb0f1f7          UDIV     r1,r0,r7              ;409
000114  fb070011          MLS      r0,r7,r1,r0           ;409
000118  8020              STRH     r0,[r4,#0]            ;409
00011a  8820              LDRH     r0,[r4,#0]            ;410
00011c  80a0              STRH     r0,[r4,#4]            ;410
00011e  3cc8              SUBS     r4,r4,#0xc8           ;410
000120  4620              MOV      r0,r4                 ;411
000122  e8bd41f0          POP      {r4-r8,lr}            ;411
000126  f7ffbffe          B.W      UART_PROTOCOL4_ConfirmTempCmdFrameBuff
                  |L8.298|
00012a  f8a58098          STRH     r8,[r5,#0x98]         ;393
00012e  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;395
000132  1c40              ADDS     r0,r0,#1              ;395
000134  8020              STRH     r0,[r4,#0]            ;395
000136  e000              B        |L8.314|
                  |L8.312|
000138  e008              B        |L8.332|
                  |L8.314|
00013a  8820              LDRH     r0,[r4,#0]            ;396
00013c  fbb0f1f7          UDIV     r1,r0,r7              ;396
000140  fb070011          MLS      r0,r7,r1,r0           ;396
000144  8020              STRH     r0,[r4,#0]            ;396
000146  8820              LDRH     r0,[r4,#0]            ;397
000148  80a0              STRH     r0,[r4,#4]            ;397
00014a  e784              B        |L8.86|
                  |L8.332|
00014c  f8b400cc          LDRH     r0,[r4,#0xcc]         ;340
000150  4288              CMP      r0,r1                 ;340
000152  d1a9              BNE      |L8.168|
000154  e77f              B        |L8.86|
;;;417    
                          ENDP


                          AREA ||i.UART_PROTOCOL4_TxAddData||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL4_TxAddData PROC
;;;61     // 向发送命令帧队列中添加数据
;;;62     void UART_PROTOCOL4_TxAddData(uint8 data)
000000  b530              PUSH     {r4,r5,lr}
;;;63     {
;;;64         uint16 head = uartProtocolCB4.tx.head;
000002  490f              LDR      r1,|L9.64|
000004  f8b14470          LDRH     r4,[r1,#0x470]  ; uartProtocolCB4
;;;65         uint16 end = uartProtocolCB4.tx.end;
000008  f8b12472          LDRH     r2,[r1,#0x472]  ; uartProtocolCB4
;;;66         UART_PROTOCOL4_TX_CMD_FRAME *pCmdFrame = &uartProtocolCB4.tx.cmdQueue[uartProtocolCB4.tx.end];
00000c  234d              MOVS     r3,#0x4d
00000e  4353              MULS     r3,r2,r3
000010  eb010143          ADD      r1,r1,r3,LSL #1
000014  f20121a2          ADD      r1,r1,#0x2a2
;;;67     
;;;68         // 发送缓冲区已满，不予接收
;;;69         if ((end + 1) % UART_PROTOCOL4_TX_QUEUE_SIZE == head)
000018  1c52              ADDS     r2,r2,#1
00001a  2303              MOVS     r3,#3
00001c  fbb2f5f3          UDIV     r5,r2,r3
000020  fb032215          MLS      r2,r3,r5,r2
000024  42a2              CMP      r2,r4
000026  d009              BEQ      |L9.60|
;;;70         {
;;;71             return;
;;;72         }
;;;73     
;;;74         // 队尾命令帧已满，退出
;;;75         if (pCmdFrame->length >= UART_PROTOCOL4_TX_CMD_FRAME_LENGTH_MAX)
000028  f8b12098          LDRH     r2,[r1,#0x98]
00002c  2a96              CMP      r2,#0x96
00002e  d205              BCS      |L9.60|
;;;76         {
;;;77             return;
;;;78         }
;;;79     
;;;80         // 数据添加到帧末尾，并更新帧长度
;;;81         pCmdFrame->buff[pCmdFrame->length] = data;
000030  1c8b              ADDS     r3,r1,#2
000032  54d0              STRB     r0,[r2,r3]
;;;82         pCmdFrame->length++;
000034  f8310f98          LDRH     r0,[r1,#0x98]!
000038  1c40              ADDS     r0,r0,#1
00003a  8008              STRH     r0,[r1,#0]
                  |L9.60|
;;;83     }
00003c  bd30              POP      {r4,r5,pc}
;;;84     
                          ENDP

00003e  0000              DCW      0x0000
                  |L9.64|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOL4_TxAddFrame||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL4_TxAddFrame PROC
;;;85     // 确认添加命令帧，即承认之前填充的数据为命令帧，将其添加到发送队列中，由main进行调度发送，本函数内会自动校正命令长度，并添加校验码
;;;86     void UART_PROTOCOL4_TxAddFrame(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;87     {
;;;88         uint16 checkSum = 0;
000002  2300              MOVS     r3,#0
;;;89         uint16 i = 0;
;;;90         uint16 head = uartProtocolCB4.tx.head;
000004  4c2d              LDR      r4,|L10.188|
000006  f8b46470          LDRH     r6,[r4,#0x470]  ; uartProtocolCB4
;;;91         uint16 end = uartProtocolCB4.tx.end;
00000a  f8b42472          LDRH     r2,[r4,#0x472]  ; uartProtocolCB4
;;;92         UART_PROTOCOL4_TX_CMD_FRAME *pCmdFrame = &uartProtocolCB4.tx.cmdQueue[uartProtocolCB4.tx.end];
00000e  204d              MOVS     r0,#0x4d
000010  4350              MULS     r0,r2,r0
000012  eb040040          ADD      r0,r4,r0,LSL #1
000016  f20020a2          ADD      r0,r0,#0x2a2
;;;93         uint16 length = pCmdFrame->length;
00001a  f8b01098          LDRH     r1,[r0,#0x98]
;;;94     
;;;95         // 发送缓冲区已满，不予接收
;;;96         if ((end + 1) % UART_PROTOCOL4_TX_QUEUE_SIZE == head)
00001e  1c52              ADDS     r2,r2,#1
000020  2503              MOVS     r5,#3
000022  fbb2f7f5          UDIV     r7,r2,r5
000026  fb052217          MLS      r2,r5,r7,r2
00002a  42b2              CMP      r2,r6
00002c  d004              BEQ      |L10.56|
;;;97         {
;;;98             return;
;;;99         }
;;;100    
;;;101        // 命令帧长度不足，清除已填充的数据，退出
;;;102        if (UART_PROTOCOL4_CMD_FRAME_LENGTH_MIN - 4 > length) // 减去"校验和L、校验和H、结束标识0xD、结束标识OxA"4个字节
00002e  2904              CMP      r1,#4
000030  d203              BCS      |L10.58|
;;;103        {
;;;104            pCmdFrame->length = 0;
000032  2100              MOVS     r1,#0
000034  f8a01098          STRH     r1,[r0,#0x98]
                  |L10.56|
;;;105    
;;;106            return;
;;;107        }
;;;108    
;;;109        // 队尾命令帧已满，退出
;;;110        if ((length >= UART_PROTOCOL4_TX_CMD_FRAME_LENGTH_MAX) || (length + 1 >= UART_PROTOCOL4_TX_CMD_FRAME_LENGTH_MAX) || (length + 2 >= UART_PROTOCOL4_TX_CMD_FRAME_LENGTH_MAX) || (length + 3 >= UART_PROTOCOL4_TX_CMD_FRAME_LENGTH_MAX))
;;;111        {
;;;112            return;
;;;113        }
;;;114    
;;;115        // 重新设置数据长度，系统在准备数据时，填充的"数据长度"可以为任意值，并且不需要添加校验码，在这里重新设置为正确的值
;;;116        pCmdFrame->buff[UART_PROTOCOL4_CMD_LENGTH_INDEX] = length - 4; // 重设数据长度，减去"命令头、设备地址、命令字、数据长度"4个字节
;;;117        for (i = 1; i < length; i++)
;;;118        {
;;;119            checkSum += pCmdFrame->buff[i];
;;;120        }
;;;121        pCmdFrame->buff[pCmdFrame->length++] = (checkSum & 0x00FF);        // 低字节在前
;;;122        pCmdFrame->buff[pCmdFrame->length++] = ((checkSum >> 8) & 0x00FF); // 高字节在后
;;;123    
;;;124        // 结束标识
;;;125        pCmdFrame->buff[pCmdFrame->length++] = 0x0D;
;;;126        pCmdFrame->buff[pCmdFrame->length++] = 0x0A;
;;;127    
;;;128        uartProtocolCB4.tx.end++;
;;;129        uartProtocolCB4.tx.end %= UART_PROTOCOL4_TX_QUEUE_SIZE;
;;;130    }
000038  bdf0              POP      {r4-r7,pc}
                  |L10.58|
00003a  2996              CMP      r1,#0x96              ;110
00003c  d2fc              BCS      |L10.56|
00003e  1c4a              ADDS     r2,r1,#1              ;110
000040  2a96              CMP      r2,#0x96              ;110
000042  d2f9              BCS      |L10.56|
000044  1c8a              ADDS     r2,r1,#2              ;110
000046  2a96              CMP      r2,#0x96              ;110
000048  d2f6              BCS      |L10.56|
00004a  1cca              ADDS     r2,r1,#3              ;110
00004c  2a96              CMP      r2,#0x96              ;110
00004e  d2f3              BCS      |L10.56|
000050  1f0a              SUBS     r2,r1,#4              ;116
000052  7142              STRB     r2,[r0,#5]            ;116
000054  2201              MOVS     r2,#1                 ;117
000056  e005              B        |L10.100|
                  |L10.88|
000058  1886              ADDS     r6,r0,r2              ;119
00005a  78b6              LDRB     r6,[r6,#2]            ;119
00005c  4433              ADD      r3,r3,r6              ;119
00005e  b29b              UXTH     r3,r3                 ;119
000060  1c52              ADDS     r2,r2,#1              ;117
000062  b292              UXTH     r2,r2                 ;117
                  |L10.100|
000064  428a              CMP      r2,r1                 ;117
000066  d3f7              BCC      |L10.88|
000068  f8b01098          LDRH     r1,[r0,#0x98]         ;121
00006c  1c4a              ADDS     r2,r1,#1              ;121
00006e  4401              ADD      r1,r1,r0              ;121
000070  f8a02098          STRH     r2,[r0,#0x98]         ;121
000074  708b              STRB     r3,[r1,#2]            ;121
000076  f8b01098          LDRH     r1,[r0,#0x98]         ;122
00007a  0a1b              LSRS     r3,r3,#8              ;122
00007c  1c4a              ADDS     r2,r1,#1              ;122
00007e  4401              ADD      r1,r1,r0              ;122
000080  f8a02098          STRH     r2,[r0,#0x98]         ;122
000084  708b              STRB     r3,[r1,#2]            ;122
000086  f8b01098          LDRH     r1,[r0,#0x98]         ;125
00008a  230d              MOVS     r3,#0xd               ;125
00008c  1c4a              ADDS     r2,r1,#1              ;125
00008e  4401              ADD      r1,r1,r0              ;125
000090  f8a02098          STRH     r2,[r0,#0x98]         ;125
000094  708b              STRB     r3,[r1,#2]            ;125
000096  f8b01098          LDRH     r1,[r0,#0x98]         ;126
00009a  230a              MOVS     r3,#0xa               ;126
00009c  1c4a              ADDS     r2,r1,#1              ;126
00009e  f8a02098          STRH     r2,[r0,#0x98]         ;126
0000a2  4408              ADD      r0,r0,r1              ;126
0000a4  7083              STRB     r3,[r0,#2]            ;126
0000a6  f8b40472          LDRH     r0,[r4,#0x472]        ;128  ; uartProtocolCB4
0000aa  1c40              ADDS     r0,r0,#1              ;128
0000ac  b280              UXTH     r0,r0                 ;128
0000ae  fbb0f1f5          UDIV     r1,r0,r5              ;129
0000b2  fb050011          MLS      r0,r5,r1,r0           ;129
0000b6  f8a40472          STRH     r0,[r4,#0x472]        ;129
0000ba  bdf0              POP      {r4-r7,pc}
;;;131    
                          ENDP

                  |L10.188|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOL4_TxStateProcess||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL4_TxStateProcess PROC
;;;225    // 协议层发送处理过程
;;;226    void UART_PROTOCOL4_TxStateProcess(void)
000000  b570              PUSH     {r4-r6,lr}
;;;227    {
;;;228        uint16 head = uartProtocolCB4.tx.head;
000002  4c14              LDR      r4,|L11.84|
000004  f8b43470          LDRH     r3,[r4,#0x470]  ; uartProtocolCB4
;;;229        uint16 end = uartProtocolCB4.tx.end;
000008  f8b46472          LDRH     r6,[r4,#0x472]  ; uartProtocolCB4
;;;230        uint16 length = uartProtocolCB4.tx.cmdQueue[head].length;
00000c  204d              MOVS     r0,#0x4d
00000e  4358              MULS     r0,r3,r0
000010  eb040040          ADD      r0,r4,r0,LSL #1
000014  4605              MOV      r5,r0
000016  f8b0233a          LDRH     r2,[r0,#0x33a]
;;;231        uint8 *pCmd = uartProtocolCB4.tx.cmdQueue[head].buff;
00001a  f5007129          ADD      r1,r0,#0x2a4
;;;232        uint16 localDeviceID = uartProtocolCB4.tx.cmdQueue[head].deviceID;
00001e  f8b002a2          LDRH     r0,[r0,#0x2a2]
;;;233    
;;;234        // 发送缓冲区为空，说明无数据
;;;235        if (head == end)
000022  42b3              CMP      r3,r6
000024  d014              BEQ      |L11.80|
;;;236        {
;;;237            return;
;;;238        }
;;;239    
;;;240        // 发送函数没有注册直接返回
;;;241        if (NULL == uartProtocolCB4.sendDataThrowService)
000026  f8d43478          LDR      r3,[r4,#0x478]  ; uartProtocolCB4
00002a  2b00              CMP      r3,#0
00002c  d010              BEQ      |L11.80|
;;;242        {
;;;243            return;
;;;244        }
;;;245    
;;;246        // 协议层有数据需要发送到驱动层
;;;247        if (!(*uartProtocolCB4.sendDataThrowService)(localDeviceID, pCmd, length))
00002e  4798              BLX      r3
000030  2800              CMP      r0,#0
000032  d00d              BEQ      |L11.80|
;;;248        {
;;;249            return;
;;;250        }
;;;251    
;;;252        // 发送环形队列更新位置
;;;253        uartProtocolCB4.tx.cmdQueue[head].length = 0;
000034  2000              MOVS     r0,#0
000036  f8a5033a          STRH     r0,[r5,#0x33a]
;;;254        uartProtocolCB4.tx.head++;
00003a  f8b40470          LDRH     r0,[r4,#0x470]  ; uartProtocolCB4
00003e  1c40              ADDS     r0,r0,#1
000040  b280              UXTH     r0,r0
;;;255        uartProtocolCB4.tx.head %= UART_PROTOCOL4_TX_QUEUE_SIZE;
000042  2103              MOVS     r1,#3
000044  fbb0f2f1          UDIV     r2,r0,r1
000048  fb010012          MLS      r0,r1,r2,r0
00004c  f8a40470          STRH     r0,[r4,#0x470]
                  |L11.80|
;;;256    }
000050  bd70              POP      {r4-r6,pc}
;;;257    
                          ENDP

000052  0000              DCW      0x0000
                  |L11.84|
                          DCD      ||.bss||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  uartProtocolCB4
                          %        1160

                          AREA ||area_number.14||, DATA, NOINIT, ALIGN=0

                          EXPORTAS ||area_number.14||, ||.bss||
                  hmiDriveCB3
                          %        10

;*** Start embedded assembler ***

#line 1 "User\\UartProtocol3.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_UartProtocol3_c_ea1a70a0____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___15_UartProtocol3_c_ea1a70a0____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_UartProtocol3_c_ea1a70a0____REVSH|
#line 128
|__asm___15_UartProtocol3_c_ea1a70a0____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
