; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\canprotocoltest.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\canprotocoltest.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -I.\User\qrencode -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.3\Device\Include -D__MICROLIB -D__UVISION_VERSION=539 -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\canprotocoltest.crf User\CanProtocolTest.c]
                          THUMB

                          AREA ||i.CAN_PROTOCOL_Process_Test||, CODE, READONLY, ALIGN=2

                  CAN_PROTOCOL_Process_Test PROC
;;;1135   // CAN处理测试过程函数
;;;1136   void CAN_PROTOCOL_Process_Test(void)
000000  b510              PUSH     {r4,lr}
;;;1137   {
;;;1138       // CAN接收FIFO缓冲区处理
;;;1139       CAN_TEST_RxFIFOProcess(&testCanCB);
000002  4805              LDR      r0,|L1.24|
000004  f7fffffe          BL       CAN_TEST_RxFIFOProcess
;;;1140   
;;;1141       // CAN接收命令缓冲区处理
;;;1142       CAN_TEST_CmdFrameProcess(&testCanCB);
000008  4803              LDR      r0,|L1.24|
00000a  f7fffffe          BL       CAN_TEST_CmdFrameProcess
;;;1143   
;;;1144       // CAN发送状态机处理过程
;;;1145       CAN_TEST_TxStateProcess();
00000e  e8bd4010          POP      {r4,lr}
000012  f7ffbffe          B.W      CAN_TEST_TxStateProcess
;;;1146   }
;;;1147   
                          ENDP

000016  0000              DCW      0x0000
                  |L1.24|
                          DCD      ||.bss||

                          AREA ||i.CAN_PROTOCOL_TEST_Init||, CODE, READONLY, ALIGN=2

                  CAN_PROTOCOL_TEST_Init PROC
;;;120    // CAN 初始化
;;;121    void CAN_PROTOCOL_TEST_Init(uint16 bund)
000000  b510              PUSH     {r4,lr}
;;;122    {
;;;123        // 初始化硬件配置
;;;124        CAN_TEST_HW_Init(bund);
000002  f7fffffe          BL       CAN_TEST_HW_Init
;;;125    
;;;126        // 初始化结构体
;;;127        CAN_TEST_DataStructureInit(&testCanCB);
000006  4803              LDR      r0,|L2.20|
000008  f7fffffe          BL       CAN_TEST_DataStructureInit
;;;128    
;;;129        // CAN发送状态机初始化
;;;130        CAN_TEST_TxStateInit();
00000c  e8bd4010          POP      {r4,lr}
000010  f7ffbffe          B.W      CAN_TEST_TxStateInit
;;;131    
;;;132        //  TIMER_AddTask(TIMER_ID_CAN_TEST,//测试
;;;133        //                          500,
;;;134        //                          CAN_TEST,
;;;135        //                          TRUE,
;;;136        //                          -1,
;;;137        //                          ACTION_MODE_ADD_TO_QUEUE);
;;;138    }
;;;139    
                          ENDP

                  |L2.20|
                          DCD      ||.bss||

                          AREA ||i.CAN_PROTOCOL_TEST_SendCmdAck||, CODE, READONLY, ALIGN=1

                  CAN_PROTOCOL_TEST_SendCmdAck PROC
;;;1525   // 发送命令不带应答
;;;1526   void CAN_PROTOCOL_TEST_SendCmdAck(uint8 param)
000000  b510              PUSH     {r4,lr}
;;;1527   {
000002  4604              MOV      r4,r0
;;;1528       CAN_PROTOCOL_TEST_TxAddData(CAN_PROTOCOL_TEST_HEAD);
000004  2055              MOVS     r0,#0x55
000006  f7fffffe          BL       CAN_PROTOCOL_TEST_TxAddData
;;;1529       CAN_PROTOCOL_TEST_TxAddData(param);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       CAN_PROTOCOL_TEST_TxAddData
;;;1530       CAN_PROTOCOL_TEST_TxAddData(0);
000010  2000              MOVS     r0,#0
000012  f7fffffe          BL       CAN_PROTOCOL_TEST_TxAddData
;;;1531       CAN_PROTOCOL_TEST_TxAddFrame();
000016  e8bd4010          POP      {r4,lr}
00001a  f7ffbffe          B.W      CAN_PROTOCOL_TEST_TxAddFrame
;;;1532   }
;;;1533   
                          ENDP


                          AREA ||i.CAN_PROTOCOL_TEST_SendCmdParamAck||, CODE, READONLY, ALIGN=1

                  CAN_PROTOCOL_TEST_SendCmdParamAck PROC
;;;1560   // 发送命令带应答
;;;1561   void CAN_PROTOCOL_TEST_SendCmdParamAck(uint8 ackCmd, uint8 ackParam)
000000  b530              PUSH     {r4,r5,lr}
;;;1562   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1563       CAN_PROTOCOL_TEST_TxAddData(CAN_PROTOCOL_TEST_HEAD);
000006  2055              MOVS     r0,#0x55
000008  f7fffffe          BL       CAN_PROTOCOL_TEST_TxAddData
;;;1564       CAN_PROTOCOL_TEST_TxAddData(ackCmd);
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       CAN_PROTOCOL_TEST_TxAddData
;;;1565       CAN_PROTOCOL_TEST_TxAddData(1);
000012  2001              MOVS     r0,#1
000014  f7fffffe          BL       CAN_PROTOCOL_TEST_TxAddData
;;;1566       CAN_PROTOCOL_TEST_TxAddData(ackParam);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       CAN_PROTOCOL_TEST_TxAddData
;;;1567       CAN_PROTOCOL_TEST_TxAddFrame();
00001e  e8bd4030          POP      {r4,r5,lr}
000022  f7ffbffe          B.W      CAN_PROTOCOL_TEST_TxAddFrame
;;;1568   }
                          ENDP


                          AREA ||i.CAN_PROTOCOL_TEST_SendCmdTest||, CODE, READONLY, ALIGN=1

                  CAN_PROTOCOL_TEST_SendCmdTest PROC
;;;1534   // 发送命令测试
;;;1535   void CAN_PROTOCOL_TEST_SendCmdTest(uint32 param)
000000  b500              PUSH     {lr}
;;;1536   {
;;;1537       CAN_PROTOCOL_TEST_TxAddData(CAN_PROTOCOL_TEST_HEAD);
000002  2055              MOVS     r0,#0x55
000004  f7fffffe          BL       CAN_PROTOCOL_TEST_TxAddData
;;;1538       CAN_PROTOCOL_TEST_TxAddData(1);
000008  2001              MOVS     r0,#1
00000a  f7fffffe          BL       CAN_PROTOCOL_TEST_TxAddData
;;;1539       CAN_PROTOCOL_TEST_TxAddData(0);
00000e  2000              MOVS     r0,#0
000010  f7fffffe          BL       CAN_PROTOCOL_TEST_TxAddData
;;;1540       CAN_PROTOCOL_TEST_TxAddData(1);
000014  2001              MOVS     r0,#1
000016  f7fffffe          BL       CAN_PROTOCOL_TEST_TxAddData
;;;1541       CAN_PROTOCOL_TEST_TxAddFrame();
00001a  f85deb04          POP      {lr}
00001e  f7ffbffe          B.W      CAN_PROTOCOL_TEST_TxAddFrame
;;;1542   }
;;;1543   
                          ENDP


                          AREA ||i.CAN_PROTOCOL_TEST_TxAddData||, CODE, READONLY, ALIGN=2

                  CAN_PROTOCOL_TEST_TxAddData PROC
;;;179    // 向发送命令帧队列中添加数据
;;;180    void CAN_PROTOCOL_TEST_TxAddData(uint8 data)
000000  b530              PUSH     {r4,r5,lr}
;;;181    {
;;;182        uint16 head = testCanCB.tx.head;
000002  4910              LDR      r1,|L6.68|
000004  880c              LDRH     r4,[r1,#0]  ; testCanCB
;;;183        uint16 end = testCanCB.tx.end;
000006  884a              LDRH     r2,[r1,#2]  ; testCanCB
;;;184        CAN_PROTOCOL_TEST_FRAME *pCmdFrame = &testCanCB.tx.cmdQueue[testCanCB.tx.end];
000008  8849              LDRH     r1,[r1,#2]  ; testCanCB
00000a  eb010381          ADD      r3,r1,r1,LSL #2
00000e  eb031141          ADD      r1,r3,r1,LSL #5
000012  4b0d              LDR      r3,|L6.72|
000014  eb030181          ADD      r1,r3,r1,LSL #2
000018  f642639c          MOV      r3,#0x2e9c
00001c  4419              ADD      r1,r1,r3
;;;185    
;;;186        // 发送缓冲区已满，不予接收
;;;187        if ((end + 1) % CAN_TEST_TX_QUEUE_SIZE == head)
00001e  1c52              ADDS     r2,r2,#1
000020  2350              MOVS     r3,#0x50
000022  fbb2f5f3          UDIV     r5,r2,r3
000026  fb032215          MLS      r2,r3,r5,r2
00002a  42a2              CMP      r2,r4
00002c  d009              BEQ      |L6.66|
;;;188        {
;;;189            return;
;;;190        }
;;;191    
;;;192        // 队尾命令帧已满，退出
;;;193        if (pCmdFrame->length >= CAN_PROTOCOL_TEST_FRAME_LENGTH_MAX)
00002e  f8b12090          LDRH     r2,[r1,#0x90]
000032  2a8c              CMP      r2,#0x8c
000034  d205              BCS      |L6.66|
;;;194        {
;;;195            return;
;;;196        }
;;;197    
;;;198        // 数据添加到帧末尾，并更新帧长度
;;;199        pCmdFrame->buff[pCmdFrame->length] = data;
000036  1d0b              ADDS     r3,r1,#4
000038  54d0              STRB     r0,[r2,r3]
;;;200        pCmdFrame->length++;
00003a  f8310f90          LDRH     r0,[r1,#0x90]!
00003e  1c40              ADDS     r0,r0,#1
000040  8008              STRH     r0,[r1,#0]
                  |L6.66|
;;;201    }
000042  bd30              POP      {r4,r5,pc}
;;;202    
                          ENDP

                  |L6.68|
                          DCD      ||.bss||+0x5cdc
                  |L6.72|
                          DCD      ||.bss||

                          AREA ||i.CAN_PROTOCOL_TEST_TxAddFrame||, CODE, READONLY, ALIGN=2

                  CAN_PROTOCOL_TEST_TxAddFrame PROC
;;;203    // 发送命令帧处理,自动扶正帧长度以及检验码
;;;204    void CAN_PROTOCOL_TEST_TxAddFrame(void)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;205    {
;;;206        uint16 head = testCanCB.tx.head;
000004  4c25              LDR      r4,|L7.156|
000006  f8b41cdc          LDRH     r1,[r4,#0xcdc]  ; testCanCB
;;;207        uint16 end = testCanCB.tx.end;
00000a  f8b42cde          LDRH     r2,[r4,#0xcde]  ; testCanCB
;;;208        uint8 *buff = testCanCB.tx.cmdQueue[end].buff;
00000e  f5a447a0          SUB      r7,r4,#0x5000
000012  eb020082          ADD      r0,r2,r2,LSL #2
000016  eb001042          ADD      r0,r0,r2,LSL #5
00001a  eb070580          ADD      r5,r7,r0,LSL #2
00001e  f64260a0          MOV      r0,#0x2ea0
000022  4428              ADD      r0,r0,r5
;;;209        uint16 length = testCanCB.tx.cmdQueue[end].length;
000024  f5055500          ADD      r5,r5,#0x2000
000028  f8b56f2c          LDRH     r6,[r5,#0xf2c]
;;;210        uint8 cmdHead = buff[CAN_PROTOCOL_TEST_HEAD_INDEX]; // 帧头
00002c  7803              LDRB     r3,[r0,#0]
;;;211    
;;;212        // 发送缓冲区已满，不予接收
;;;213        if ((end + 1) % CAN_TEST_TX_QUEUE_SIZE == head)
00002e  1c52              ADDS     r2,r2,#1
000030  f04f0850          MOV      r8,#0x50
000034  fbb2fcf8          UDIV     r12,r2,r8
000038  fb08221c          MLS      r2,r8,r12,r2
00003c  428a              CMP      r2,r1
00003e  d005              BEQ      |L7.76|
;;;214        {
;;;215            return;
;;;216        }
;;;217    
;;;218        // 命令头错误
;;;219        if (CAN_PROTOCOL_TEST_HEAD != cmdHead)
000040  f04f0900          MOV      r9,#0
000044  2b55              CMP      r3,#0x55
000046  d003              BEQ      |L7.80|
;;;220        {
;;;221            // 把帧数据索引放在最开始位置
;;;222            testCanCB.tx.cmdQueue[end].length = 0;
000048  f8a59f2c          STRH     r9,[r5,#0xf2c]
                  |L7.76|
;;;223            return;
;;;224        }
;;;225    
;;;226        // 命令头正确，但数据长度不对(数据长度减去CRC的长度)
;;;227        if ((CAN_PROTOCOL_TEST_FRAME_LENGTH_MAX - CAN_CHECK_BYTE_SIZE < length) || (CAN_PROTOCOL_TEST_FRAME_LENGTH_MIN - CAN_CHECK_BYTE_SIZE > length))
;;;228        {
;;;229            // 把帧数据索引放在最开始位置
;;;230            testCanCB.tx.cmdQueue[end].length = 0;
;;;231            buff[CAN_PROTOCOL_TEST_HEAD_INDEX] = CAN_PROTOCOL_TEST_NONHEAD; // 避免数据没更新时，再次进入
;;;232            return;
;;;233        }
;;;234    
;;;235        // 执行到此，命令头正确，数据长度正确,发送缓冲区未满
;;;236        // 长度扶正
;;;237        buff[CAN_PROTOCOL_TEST_LENGTH_INDEX] = length - CAN_PROTOCOL_TEST_FRAME_LENGTH_MIN + CAN_CHECK_BYTE_SIZE;
;;;238    
;;;239        // 填充CRC校验码
;;;240        CAN_TEST_AddSum(buff, length);
;;;241    
;;;242        // 将数据长度填到待发送缓冲器
;;;243        testCanCB.tx.cmdQueue[end].length = length + CAN_CHECK_BYTE_SIZE;
;;;244    
;;;245        // 发送环形队列更新位置
;;;246        testCanCB.tx.end++;
;;;247        testCanCB.tx.end %= CAN_TEST_TX_QUEUE_SIZE;
;;;248        testCanCB.tx.cmdQueue[testCanCB.tx.end].length = 0; // 2015.12.2修改
;;;249    }
00004c  e8bd83f0          POP      {r4-r9,pc}
                  |L7.80|
000050  1ef1              SUBS     r1,r6,#3              ;227
000052  2989              CMP      r1,#0x89              ;227
000054  d304              BCC      |L7.96|
000056  f8a59f2c          STRH     r9,[r5,#0xf2c]        ;230
00005a  21ff              MOVS     r1,#0xff              ;231
00005c  7001              STRB     r1,[r0,#0]            ;231
00005e  e7f5              B        |L7.76|
                  |L7.96|
000060  7081              STRB     r1,[r0,#2]            ;237
000062  4631              MOV      r1,r6                 ;240
000064  f7fffffe          BL       CAN_TEST_AddSum
000068  1c76              ADDS     r6,r6,#1              ;243
00006a  f8a56f2c          STRH     r6,[r5,#0xf2c]        ;243
00006e  f60444de          ADD      r4,r4,#0xcde          ;246
000072  8820              LDRH     r0,[r4,#0]            ;246  ; testCanCB
000074  1c40              ADDS     r0,r0,#1              ;246
000076  8020              STRH     r0,[r4,#0]            ;246
000078  8820              LDRH     r0,[r4,#0]            ;247  ; testCanCB
00007a  fbb0f1f8          UDIV     r1,r0,r8              ;247
00007e  fb080011          MLS      r0,r8,r1,r0           ;247
000082  8020              STRH     r0,[r4,#0]            ;247
000084  8820              LDRH     r0,[r4,#0]            ;248  ; testCanCB
000086  eb000180          ADD      r1,r0,r0,LSL #2       ;248
00008a  eb011040          ADD      r0,r1,r0,LSL #5       ;248
00008e  eb070080          ADD      r0,r7,r0,LSL #2       ;248
000092  f5005000          ADD      r0,r0,#0x2000         ;248
000096  f8a09f2c          STRH     r9,[r0,#0xf2c]        ;248
00009a  e7d7              B        |L7.76|
;;;250    
                          ENDP

                  |L7.156|
                          DCD      ||.bss||+0x5000

                          AREA ||i.CAN_PROTOCOL_TEST_WriteFlag||, CODE, READONLY, ALIGN=1

                  CAN_PROTOCOL_TEST_WriteFlag PROC
;;;1544   // 写入标志区数据
;;;1545   void CAN_PROTOCOL_TEST_WriteFlag(uint8 placeParam, uint8 shutdownFlagParam)
000000  b530              PUSH     {r4,r5,lr}
;;;1546   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1547       CAN_PROTOCOL_TEST_TxAddData(CAN_PROTOCOL_TEST_HEAD);
000006  2055              MOVS     r0,#0x55
000008  f7fffffe          BL       CAN_PROTOCOL_TEST_TxAddData
;;;1548       CAN_PROTOCOL_TEST_TxAddData(CAN_PROTOCOL_TEST_CMD_WRITE_FLAG_DATA);
00000c  20a7              MOVS     r0,#0xa7
00000e  f7fffffe          BL       CAN_PROTOCOL_TEST_TxAddData
;;;1549       CAN_PROTOCOL_TEST_TxAddData(0x06);
000012  2006              MOVS     r0,#6
000014  f7fffffe          BL       CAN_PROTOCOL_TEST_TxAddData
;;;1550   
;;;1551       CAN_PROTOCOL_TEST_TxAddData(placeParam);
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       CAN_PROTOCOL_TEST_TxAddData
;;;1552       CAN_PROTOCOL_TEST_TxAddData(0x00);
00001e  2000              MOVS     r0,#0
000020  f7fffffe          BL       CAN_PROTOCOL_TEST_TxAddData
;;;1553       CAN_PROTOCOL_TEST_TxAddData(0x00);
000024  2000              MOVS     r0,#0
000026  f7fffffe          BL       CAN_PROTOCOL_TEST_TxAddData
;;;1554       CAN_PROTOCOL_TEST_TxAddData(0x00);
00002a  2000              MOVS     r0,#0
00002c  f7fffffe          BL       CAN_PROTOCOL_TEST_TxAddData
;;;1555       CAN_PROTOCOL_TEST_TxAddData(0x02);
000030  2002              MOVS     r0,#2
000032  f7fffffe          BL       CAN_PROTOCOL_TEST_TxAddData
;;;1556       CAN_PROTOCOL_TEST_TxAddData(shutdownFlagParam);
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       CAN_PROTOCOL_TEST_TxAddData
;;;1557       CAN_PROTOCOL_TEST_TxAddFrame();
00003c  e8bd4030          POP      {r4,r5,lr}
000040  f7ffbffe          B.W      CAN_PROTOCOL_TEST_TxAddFrame
;;;1558   }
;;;1559   
                          ENDP


                          AREA ||i.CAN_TEST_AddSum||, CODE, READONLY, ALIGN=1

                  CAN_TEST_AddSum PROC
;;;1176   // 对传入的命令帧进行校验，返回校验结果
;;;1177   BOOL CAN_TEST_AddSum(uint8 *buff, uint32 len)
000000  b510              PUSH     {r4,lr}
;;;1178   {
;;;1179       uint8 cc = 0;
000002  2300              MOVS     r3,#0
;;;1180       uint16 i = 0;
000004  2200              MOVS     r2,#0
;;;1181   
;;;1182       if (NULL == buff)
000006  2800              CMP      r0,#0
000008  d104              BNE      |L9.20|
;;;1183       {
;;;1184           return FALSE;
;;;1185       }
;;;1186   
;;;1187       // 从命令头开始，到校验码之前的一个字节，依次进行异或运算
;;;1188       for (i = 0; i < len; i++)
;;;1189       {
;;;1190           cc ^= buff[i];
;;;1191       }
;;;1192   
;;;1193   //  cc = ~cc;
;;;1194   
;;;1195       // 添加校验码
;;;1196       buff[len] = cc;
;;;1197   
;;;1198       return TRUE;
;;;1199   }
00000a  bd10              POP      {r4,pc}
                  |L9.12|
00000c  5c84              LDRB     r4,[r0,r2]            ;1190
00000e  4063              EORS     r3,r3,r4              ;1190
000010  1c52              ADDS     r2,r2,#1              ;1188
000012  b292              UXTH     r2,r2                 ;1188
                  |L9.20|
000014  428a              CMP      r2,r1                 ;1188
000016  d3f9              BCC      |L9.12|
000018  5443              STRB     r3,[r0,r1]            ;1196
00001a  2001              MOVS     r0,#1                 ;1198
00001c  bd10              POP      {r4,pc}
;;;1200   
                          ENDP


                          AREA ||i.CAN_TEST_CheckSum||, CODE, READONLY, ALIGN=1

                  CAN_TEST_CheckSum PROC
;;;1148   // 对传入的命令帧进行校验，返回校验结果
;;;1149   BOOL CAN_TEST_CheckSum(uint8 *buff, uint32 len)
000000  b530              PUSH     {r4,r5,lr}
;;;1150   {
;;;1151       uint8 cc = 0;
000002  2300              MOVS     r3,#0
;;;1152       uint16 i = 0;
000004  2200              MOVS     r2,#0
;;;1153   
;;;1154       if (NULL == buff)
000006  2800              CMP      r0,#0
000008  d001              BEQ      |L10.14|
;;;1155       {
;;;1156           return FALSE;
;;;1157       }
;;;1158   
;;;1159       // 从命令头开始，到校验码之前的一个字节，依次进行异或运算
;;;1160       for (i = 0; i < (len - CAN_CHECK_BYTE_SIZE); i++)
00000a  1e4c              SUBS     r4,r1,#1
00000c  e005              B        |L10.26|
                  |L10.14|
00000e  2000              MOVS     r0,#0                 ;1156
;;;1161       {
;;;1162           cc ^= buff[i];
;;;1163       }
;;;1164   
;;;1165   //  cc = ~cc;
;;;1166   
;;;1167       // 判断计算得到的校验码与命令帧中的校验码是否相同
;;;1168       if (buff[len - 1] != cc)
;;;1169       {
;;;1170           return FALSE;
;;;1171       }
;;;1172   
;;;1173       return TRUE;
;;;1174   }
000010  bd30              POP      {r4,r5,pc}
                  |L10.18|
000012  5c85              LDRB     r5,[r0,r2]            ;1162
000014  406b              EORS     r3,r3,r5              ;1162
000016  1c52              ADDS     r2,r2,#1              ;1160
000018  b292              UXTH     r2,r2                 ;1160
                  |L10.26|
00001a  42a2              CMP      r2,r4                 ;1160
00001c  d3f9              BCC      |L10.18|
00001e  4408              ADD      r0,r0,r1              ;1168
000020  f8100c01          LDRB     r0,[r0,#-1]           ;1168
000024  4298              CMP      r0,r3                 ;1168
000026  d001              BEQ      |L10.44|
000028  2000              MOVS     r0,#0                 ;1170
00002a  bd30              POP      {r4,r5,pc}
                  |L10.44|
00002c  2001              MOVS     r0,#1                 ;1173
00002e  bd30              POP      {r4,r5,pc}
;;;1175   
                          ENDP


                          AREA ||i.CAN_TEST_CmdFrameProcess||, CODE, READONLY, ALIGN=2

                  CAN_TEST_CmdFrameProcess PROC
;;;610    // CAN命令帧缓冲区处理
;;;611    void CAN_TEST_CmdFrameProcess(CAN_TEST_CB *pCB)
000000  e92d4ff1          PUSH     {r0,r4-r11,lr}
;;;612    {
000004  b09c              SUB      sp,sp,#0x70
;;;613        CAN_PROTOCOL_TEST cmd = CAN_PROTOCOL_TEST_CMD_NULL;
;;;614        CAN_PROTOCOL_TEST_FRAME *pCmdFrame = NULL;
;;;615        uint8 sourceBuffSelect = CAN_TEST_DEVICE_SOURCE_ID_MAX;
;;;616        volatile uint32 temp = 0;
000006  2600              MOVS     r6,#0
000008  961b              STR      r6,[sp,#0x6c]
;;;617        volatile uint16 length;
;;;618        volatile uint8 errStatus;
;;;619        volatile uint16 i;
;;;620        uint8 buffFlag[4] = {0xFF};
00000a  48fb              LDR      r0,|L11.1016|
00000c  6800              LDR      r0,[r0,#0]  ; <Data5>
00000e  9019              STR      r0,[sp,#0x64]
;;;621        uint8_t verType = 0;
;;;622        uint8_t infoLen = 0;
;;;623        char  verBuff[100] = {0};
000010  2164              MOVS     r1,#0x64
000012  4668              MOV      r0,sp
000014  f7fffffe          BL       __aeabi_memclr4
;;;624        uint8 calibration_result = 0;
;;;625        uint8 switch_state = 0;
;;;626        uint8 Peripheral_type = 0;
;;;627        uint8 turn_item = 0;
;;;628        uint8 turn_state = 0;
;;;629        BOOL testResult = 0;
;;;630    
;;;631    
;;;632        // 参数合法性检验
;;;633        if (NULL == pCB)
000018  981c              LDR      r0,[sp,#0x70]
00001a  2800              CMP      r0,#0
00001c  d068              BEQ      |L11.240|
;;;634        {
;;;635            return;
;;;636        }
;;;637    
;;;638        // 循环判断是否有数据需要处理
;;;639        for (sourceBuffSelect = 0; sourceBuffSelect < CAN_TEST_DEVICE_SOURCE_ID_MAX; sourceBuffSelect++)
00001e  2700              MOVS     r7,#0
;;;640        {
;;;641            // 命令帧缓冲区为空，退出
;;;642            if (pCB->rx.rxEachNode[sourceBuffSelect].head == pCB->rx.rxEachNode[sourceBuffSelect].end)
;;;643            {
;;;644                continue;
;;;645            }
;;;646    
;;;647            // 获取当前要处理的命令帧指针
;;;648            pCmdFrame = &pCB->rx.rxEachNode[sourceBuffSelect].cmdQueue[pCB->rx.rxEachNode[sourceBuffSelect].head];
;;;649    
;;;650            // 命令头非法，退出
;;;651            if (CAN_PROTOCOL_TEST_HEAD != pCmdFrame->buff[CAN_PROTOCOL_TEST_HEAD_INDEX])
;;;652            {
;;;653                // 删除命令帧
;;;654                pCB->rx.rxEachNode[sourceBuffSelect].head++;
;;;655                pCB->rx.rxEachNode[sourceBuffSelect].head %= CAN_TEST_RX_QUEUE_SIZE;
;;;656                continue;
;;;657            }
;;;658    
;;;659            // 命令头合法，则提取命令
;;;660            cmd = (CAN_PROTOCOL_TEST)(pCmdFrame->buff[CAN_PROTOCOL_TEST_CMD_INDEX]);
;;;661    
;;;662            switch (cmd)
;;;663            {
;;;664                // 空命令
;;;665                case CAN_PROTOCOL_TEST_CMD_NULL:
;;;666                    break;
;;;667    
;;;668                // 大灯控制
;;;669                case CAN_PROTOCOL_TEST_CMD_HEADLIGHT_CONTROL:
;;;670                    switch_state = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA1_INDEX];   // 执行结果
;;;671    
;;;672                    // 执行失败
;;;673                    if (0x00 == (switch_state & 0x00))
;;;674                    {
;;;675        #if DEBUG_ENABLE
;;;676                        Clear_All_Lines();
;;;677                        Display_Centered(1, "Headlights fail to turn on");
;;;678        #endif
;;;679                        can_light_cnt = 0;
000020  f8dfa3d8          LDR      r10,|L11.1020|
;;;680                        STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_MULTIPLE_TEST, FALSE);
;;;681                    }
;;;682    
;;;683                    // 执行成功
;;;684                    if (0x01 == (switch_state & 0x01))
;;;685                    {
;;;686                        can_light_cnt++;
;;;687                        if (can_light_cnt == 1)
;;;688                        {
;;;689                            STATE_SwitchStep(STEP_HEADLIGHT_CAN_TEST_OPEN);
;;;690                        }
;;;691                        if (can_light_cnt == 2)
;;;692                        {
;;;693                            STATE_SwitchStep(STEP_HEADLIGHT_CAN_TEST_COMPLETE);
;;;694                            can_light_cnt = 0;
;;;695                        }
;;;696                    }
;;;697                    break;
;;;698    
;;;699                // 获取油门/刹车的模拟数字值
;;;700                case CAN_PROTOCOL_TEST_CMD_GET_THROTTLE_BRAKE_AD:
;;;701    
;;;702                    // 获取AD值并且比对
;;;703                    Peripheral_type = pCmdFrame->buff[CAN_PROTOCOL_TEST_DATA1_INDEX];   // 外设类型
;;;704    
;;;705                    if (0x01 == (Peripheral_type & 0x01))  // 油门
;;;706                    {
;;;707                        dut_info.throttleAd = pCmdFrame->buff[CAN_PROTOCOL_TEST_DATA2_INDEX] << 8;
000024  f8df93d8          LDR      r9,|L11.1024|
                  |L11.40|
000028  f6403091          MOV      r0,#0xb91             ;642
00002c  991c              LDR      r1,[sp,#0x70]         ;642
00002e  4378              MULS     r0,r7,r0              ;642
000030  eb010880          ADD      r8,r1,r0,LSL #2       ;642
000034  4641              MOV      r1,r8                 ;642
000036  f5085800          ADD      r8,r8,#0x2000         ;642
00003a  f8b80e98          LDRH     r0,[r8,#0xe98]        ;642
00003e  f8b82e9a          LDRH     r2,[r8,#0xe9a]        ;642
000042  4290              CMP      r0,r2                 ;642
000044  d050              BEQ      |L11.232|
000046  eb000280          ADD      r2,r0,r0,LSL #2       ;648
00004a  eb021240          ADD      r2,r2,r0,LSL #5       ;648
00004e  eb010482          ADD      r4,r1,r2,LSL #2       ;648
000052  3458              ADDS     r4,r4,#0x58           ;648
000054  7921              LDRB     r1,[r4,#4]            ;651
000056  2955              CMP      r1,#0x55              ;651
000058  d009              BEQ      |L11.110|
00005a  1c40              ADDS     r0,r0,#1              ;654
00005c  b280              UXTH     r0,r0                 ;654
00005e  2150              MOVS     r1,#0x50              ;655
000060  fbb0f2f1          UDIV     r2,r0,r1              ;655
000064  fb010012          MLS      r0,r1,r2,r0           ;655
000068  f8a80e98          STRH     r0,[r8,#0xe98]        ;655
00006c  e03c              B        |L11.232|
                  |L11.110|
00006e  7960              LDRB     r0,[r4,#5]            ;660
000070  28a6              CMP      r0,#0xa6              ;662
000072  d07d              BEQ      |L11.368|
000074  dc0f              BGT      |L11.150|
000076  2809              CMP      r0,#9                 ;662
000078  d07b              BEQ      |L11.370|
00007a  dc05              BGT      |L11.136|
00007c  b348              CBZ      r0,|L11.210|
00007e  2803              CMP      r0,#3                 ;662
000080  d078              BEQ      |L11.372|
000082  2805              CMP      r0,#5                 ;662
000084  d117              BNE      |L11.182|
000086  e331              B        |L11.1772|
                  |L11.136|
000088  280c              CMP      r0,#0xc               ;662
00008a  d074              BEQ      |L11.374|
00008c  2890              CMP      r0,#0x90              ;662
00008e  d020              BEQ      |L11.210|
000090  2891              CMP      r0,#0x91              ;662
000092  d110              BNE      |L11.182|
000094  e117              B        |L11.710|
                  |L11.150|
000096  28ea              CMP      r0,#0xea              ;662
000098  d02d              BEQ      |L11.246|
00009a  dc06              BGT      |L11.170|
00009c  28a7              CMP      r0,#0xa7              ;662
00009e  d06b              BEQ      |L11.376|
0000a0  28a8              CMP      r0,#0xa8              ;662
0000a2  d06a              BEQ      |L11.378|
0000a4  28a9              CMP      r0,#0xa9              ;662
0000a6  d106              BNE      |L11.182|
0000a8  e1e1              B        |L11.1134|
                  |L11.170|
0000aa  28eb              CMP      r0,#0xeb              ;662
0000ac  d047              BEQ      |L11.318|
0000ae  28ec              CMP      r0,#0xec              ;662
0000b0  d07e              BEQ      |L11.432|
0000b2  28ed              CMP      r0,#0xed              ;662
0000b4  d07d              BEQ      |L11.434|
                  |L11.182|
;;;708                        dut_info.throttleAd = dut_info.throttleAd | pCmdFrame->buff[CAN_PROTOCOL_TEST_DATA3_INDEX];
;;;709                        can_throttleAd_cnt++;
;;;710                        switch (can_throttleAd_cnt)
;;;711                        {
;;;712                            case 0:
;;;713                                break;
;;;714                                
;;;715                            case 1:
;;;716                                STATE_SwitchStep(STEP_THROTTLE_CAN_TEST_CHECK_DAC1_VALUE);
;;;717                                break;
;;;718                                
;;;719                            case 2:
;;;720                                STATE_SwitchStep(STEP_THROTTLE_CAN_TEST_CHECK_DAC3_VALUE);
;;;721                                break;
;;;722                                
;;;723                            case 3:
;;;724                                STATE_SwitchStep(STEP_THROTTLE_CAN_TEST_CHECK_DAC5_VALUE);
;;;725                                can_throttleAd_cnt = 0;
;;;726                                break;
;;;727                                
;;;728                            default:
;;;729                                break;
;;;730                        }
;;;731                    }
;;;732    
;;;733                    if (0x02 == (Peripheral_type & 0x02))  // 刹把
;;;734                    {
;;;735                        dut_info.brakeAd = pCmdFrame->buff[CAN_PROTOCOL_TEST_DATA2_INDEX] << 8;
;;;736                        dut_info.brakeAd = dut_info.brakeAd | pCmdFrame->buff[CAN_PROTOCOL_TEST_DATA3_INDEX];
;;;737                        can_brake_cnt++;
;;;738                        
;;;739                        switch (can_brake_cnt)
;;;740                        {
;;;741                            case 0:
;;;742                                break;
;;;743                                
;;;744                            case 1:
;;;745                                STATE_SwitchStep(STEP_BRAKE_CAN_TEST_CHECK_DAC1_VALUE);
;;;746                                break;
;;;747                                
;;;748                            case 2:
;;;749                                STATE_SwitchStep(STEP_BRAKE_CAN_TEST_CHECK_DAC3_VALUE);
;;;750                                break;
;;;751                                
;;;752                            case 3:
;;;753                                STATE_SwitchStep(STEP_BRAKE_CAN_TEST_CHECK_DAC5_VALUE);
;;;754                                can_brake_cnt = 0;
;;;755                                break;
;;;756                                
;;;757                            default:
;;;758                                break;
;;;759                        }
;;;760                    }
;;;761    
;;;762                    // 电子变速
;;;763                    if (0x03 == (Peripheral_type & 0x03))
;;;764                    {
;;;765                        // 获取刹把AD值
;;;766                        dut_info.derailleurAd = pCmdFrame->buff[CAN_PROTOCOL_TEST_DATA2_INDEX] << 8;
;;;767                        dut_info.derailleurAd = dut_info.derailleurAd | pCmdFrame->buff[CAN_PROTOCOL_TEST_DATA3_INDEX];
;;;768                        can_derailleurAd_cnt++;
;;;769                        
;;;770                        switch (can_derailleurAd_cnt)
;;;771                        {
;;;772                            case 0:
;;;773                                break;
;;;774    
;;;775                            case 1:
;;;776                                STATE_SwitchStep(STEP_DERAILLEUR_UART_TEST_CHECK_DAC1_VALUE);
;;;777                                break;
;;;778    
;;;779                            case 2:
;;;780                                STATE_SwitchStep(STEP_DERAILLEUR_UART_TEST_CHECK_DAC3_VALUE);
;;;781                                break;
;;;782    
;;;783                            case 3:
;;;784                                STATE_SwitchStep(STEP_DERAILLEUR_UART_TEST_CHECK_DAC5_VALUE);
;;;785                                can_derailleurAd_cnt = 0;
;;;786                                break;
;;;787    
;;;788                            default:
;;;789                                break;
;;;790                        }
;;;791                    }
;;;792                    break;
;;;793    
;;;794                // 转向灯控制
;;;795                case CAN_PROTOCOL_TEST_CMD_TURN_SIGNAL_CONTROL:
;;;796                    turn_item = pCmdFrame->buff[CAN_PROTOCOL_TEST_DATA1_INDEX];  // 转向灯类型
;;;797                    turn_state = pCmdFrame->buff[CAN_PROTOCOL_TEST_DATA2_INDEX]; // 执行结果
;;;798    
;;;799                    // 执行失败
;;;800                    if (0x00 == (switch_state & 0x00))
;;;801                    {
;;;802        #if DEBUG_ENABLE
;;;803                        Clear_All_Lines();
;;;804                        Display_Centered(1, "TURN SIGNAL fail to turn on");
;;;805        #endif
;;;806                        can_left_light_cnt = 0;
;;;807                        can_right_light_cnt = 0;
;;;808                        STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_MULTIPLE_TEST, FALSE);
;;;809                    }
;;;810    
;;;811                    // 左转向灯打开成功
;;;812                    if ((turn_item == 0) && (turn_state == 1))
;;;813                    {
;;;814                        can_left_light_cnt++;
;;;815                        STATE_SwitchStep(STEP_LEFT_TURN_SIGNAL_CAN_TEST_OPEN);
;;;816                        if (can_left_light_cnt == 2)
;;;817                        {
;;;818                            STATE_SwitchStep(STEP_LEFT_TURN_SIGNAL_CAN_TEST_COMPLETE);
;;;819                            can_left_light_cnt = 0;
;;;820                        }
;;;821                    }
;;;822    
;;;823                    // 右转向灯打开成功
;;;824                    if ((turn_item == 1) && (turn_state == 1))
;;;825                    {
;;;826                        can_right_light_cnt++;
;;;827                        STATE_SwitchStep(STEP_RIGHT_TURN_SIGNAL_CAN_TEST_OPEN);
;;;828                        if (can_right_light_cnt == 2)
;;;829                        {
;;;830                            STATE_SwitchStep(STEP_RIGHT_TURN_SIGNAL_CAN_TEST_COMPLETE);
;;;831                            can_right_light_cnt = 0;
;;;832                        }
;;;833                    }
;;;834                    break;
;;;835    
;;;836                // 在线检测
;;;837                case CAN_PROTOCOL_TEST_CMD_ONLINE_DETECTION:
;;;838                    online_detection_cnt++;            
;;;839                    TIMER_ResetTimer(TIMER_ID_ONLINE_DETECT);
;;;840                    
;;;841                    if(1 == online_detection_cnt)
;;;842                    {
;;;843                       // 上报仪表启动状态
;;;844                       STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_ONLINE_DETECTION,TRUE);
;;;845                    }
;;;846                    break;
;;;847    
;;;848                // 获取光敏传感器的数值
;;;849                case CAN_PROTOCOL_TEST_CMD_GET_PHOTORESISTOR_VALUE:
;;;850                    break;
;;;851    
;;;852                // 进行电压校准
;;;853                case CAN_PROTOCOL_TEST_CMD_VOLTAGE_CALIBRATION:
;;;854                    cali_cnt++;
;;;855                    calibration_result = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA1_INDEX];
;;;856    
;;;857                    // 一级校准
;;;858                    if ((calibration_result) && (dut_info.cali_cnt == 1))
;;;859                    {
;;;860                        STATE_SwitchStep(STEP_CALIBRATION_UART_TEST_RESTORE_VOLTAGE_CALIBRATION);
;;;861                        cali_cnt = 0;
;;;862                    }
;;;863    
;;;864                    // 二级校准
;;;865                    if ((calibration_result) && (dut_info.cali_cnt == 2))
;;;866                    {
;;;867                        if (cali_cnt == 1)
;;;868                        {
;;;869                            STATE_SwitchStep(STEP_CALIBRATION_UART_TEST_TWO_NOTIFY_POWER_BOARD);
;;;870                        }
;;;871                        if (cali_cnt == 2)
;;;872                        {
;;;873                            STATE_SwitchStep(STEP_CALIBRATION_UART_TEST_RESTORE_VOLTAGE_CALIBRATION);
;;;874                            cali_cnt = 0;
;;;875                        }
;;;876                    }
;;;877    
;;;878                    // 三级校准
;;;879                    if ((calibration_result) && (dut_info.cali_cnt == 3))
;;;880                    {
;;;881                        if (cali_cnt == 1)
;;;882                        {
;;;883                            STATE_SwitchStep(STEP_CALIBRATION_UART_TEST_TWO_NOTIFY_POWER_BOARD);
;;;884                        }
;;;885                        if (cali_cnt == 2)
;;;886                        {
;;;887                            STATE_SwitchStep(STEP_CALIBRATION_UART_TEST_THREE_NOTIFY_POWER_BOARD);
;;;888                        }
;;;889                        if (cali_cnt == 3)
;;;890                        {
;;;891                            STATE_SwitchStep(STEP_CALIBRATION_UART_TEST_RESTORE_VOLTAGE_CALIBRATION);
;;;892                        }
;;;893                    }
;;;894    
;;;895                    // 校准失败
;;;896                    if (!calibration_result)
;;;897                    {
;;;898                        cali_cnt = 0;
;;;899                        Clear_All_Lines();
;;;900                        Display_Centered(0, "Calibration");
;;;901                        Display_Centered(1, "Fail");
;;;902                        STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_VOLTAGE_CALIBRATION, FALSE);
;;;903                        TIMER_KillTask(TIMER_ID_DUT_TIMEOUT);
;;;904                    }
;;;905                    break;
;;;906    
;;;907                // 读取标志区数据
;;;908                case CAN_PROTOCOL_TEST_CMD_READ_FLAG_DATA:
;;;909                    TIMER_KillTask(TIMER_ID_WRITE_FLAG_TIMEOUT);
;;;910    
;;;911                    // 读取标志区数据
;;;912                    for (i = 0; i < 4; i++)
;;;913                    {
;;;914                        buffFlag[i] = pCmdFrame->buff[(stationNumber * 4) + 4 + i];
;;;915                    }
;;;916    
;;;917                    // 校验标志区数据
;;;918                    if ((buffFlag[0] == 0x00) && (buffFlag[1] == 0x00) && (buffFlag[2] == 0x00) && (buffFlag[3] == 0x02))
;;;919                    {
;;;920                        STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_CHECK_STATION_FLAG, TRUE);
;;;921                    }
;;;922                    else
;;;923                    {
;;;924                        STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_CHECK_STATION_FLAG, FALSE);
;;;925                    }
;;;926                    break;
;;;927    
;;;928                // 写入标志区数据
;;;929                case CAN_PROTOCOL_TEST_CMD_WRITE_FLAG_DATA:
;;;930    
;;;931                    // 关闭写入超时定时器
;;;932                    TIMER_ResetTimer(TIMER_ID_WRITE_FLAG_TIMEOUT);
;;;933    
;;;934                    // 收到写入成功再读取出来进行校验
;;;935                    if (pCmdFrame->buff[STS_PROTOCOL_CMD_DATA1_INDEX])
;;;936                    {
;;;937                        CAN_PROTOCOL_TEST_SendCmdAck(CAN_PROTOCOL_TEST_CMD_READ_FLAG_DATA);
;;;938                    }
;;;939                    else
;;;940                    {
;;;941                        STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_CHECK_STATION_FLAG, FALSE);
;;;942                    }
;;;943                    break;
;;;944    
;;;945                // 写入版本类型数据
;;;946                case CAN_PROTOCOL_TEST_CMD_WRITE_VERSION_TYPE_DATA:
;;;947    
;;;948                    // 关闭定时器
;;;949                    TIMER_ResetTimer(TIMER_ID_OPERATE_VER_TIMEOUT);
;;;950    
;;;951                    // 获取类型
;;;952                    verType =  pCmdFrame->buff[CAN_PROTOCOL_TEST_DATA1_INDEX];
;;;953    
;;;954                    // 类型正确并且执行成功，上报STS
;;;955                    if ((dutverType == verType) && (pCmdFrame->buff[CAN_PROTOCOL_TEST_DATA2_INDEX]))
;;;956                    {
;;;957                        // 读取版本类型信息
;;;958                        CAN_PROTOCOL_TEST_SendCmdParamAck(CAN_PROTOCOL_TEST_CMD_READ_VERSION_TYPE_INFO, dutverType);
;;;959                    }
;;;960                    else
;;;961                    {
;;;962                        STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_CHECK_VERSION_INFO, FALSE);
;;;963                    }
;;;964                    break;
;;;965    
;;;966                // 读取版本类型信息
;;;967                case CAN_PROTOCOL_TEST_CMD_READ_VERSION_TYPE_INFO:
;;;968                    TIMER_KillTask(TIMER_ID_OPERATE_VER_TIMEOUT);
;;;969    
;;;970                    // 获取类型
;;;971                    verType =  pCmdFrame->buff[CAN_PROTOCOL_TEST_DATA1_INDEX];
;;;972    
;;;973                    // 获取信息长度
;;;974                    infoLen = pCmdFrame->buff[CAN_PROTOCOL_TEST_DATA2_INDEX];
;;;975    
;;;976                    // 获取类型信息
;;;977                    strcpy(verBuff, (const char *)&pCmdFrame->buff[CAN_PROTOCOL_TEST_DATA3_INDEX]);
;;;978                    verBuff[infoLen] = 0;
;;;979    
;;;980                    // 只读取
;;;981                    if (verreadFlag)
;;;982                    {
;;;983                        STS_PROTOCOL_TxAddData(STS_PROTOCOL_CMD_HEAD);
;;;984                        STS_PROTOCOL_TxAddData(STS_PROTOCOL_CMD_CHECK_VERSION_INFO);
;;;985                        STS_PROTOCOL_TxAddData(0x00);       // 数据长度
;;;986                        STS_PROTOCOL_TxAddData(1);          // 校验读取结果
;;;987                        STS_PROTOCOL_TxAddData(verType);    // 版本类型
;;;988                        STS_PROTOCOL_TxAddData(infoLen);    // 信息长度
;;;989    
;;;990                        // 类型信息
;;;991                        for (i = 0; i < infoLen; i++)
;;;992                        {
;;;993                            STS_PROTOCOL_TxAddData(pCmdFrame->buff[5 + i]);
;;;994                        }
;;;995                        STS_PROTOCOL_TxAddFrame();     // 版本类型
;;;996                        verreadFlag = FALSE;
;;;997                    }
;;;998    
;;;999                    // 写入对比
;;;1000                   if (verwriteFlag)
;;;1001                   {
;;;1002                       // 版本对比
;;;1003                       if ((dutverType == verType) && (strstr((const char *)dutverBuff, (char *)verBuff) != NULL))
;;;1004                       {
;;;1005                           STS_PROTOCOL_TxAddData(STS_PROTOCOL_CMD_HEAD);
;;;1006                           STS_PROTOCOL_TxAddData(STS_PROTOCOL_CMD_CHECK_VERSION_INFO);
;;;1007                           STS_PROTOCOL_TxAddData(0x00);       // 数据长度
;;;1008                           STS_PROTOCOL_TxAddData(1);          // 校验读取结果
;;;1009                           STS_PROTOCOL_TxAddData(verType);    // 版本类型
;;;1010                           STS_PROTOCOL_TxAddData(infoLen);    // 信息长度
;;;1011   
;;;1012                           // 类型信息
;;;1013                           for (i = 0; i < infoLen; i++)
;;;1014                           {
;;;1015                               STS_PROTOCOL_TxAddData(pCmdFrame->buff[5 + i]);
;;;1016                           }
;;;1017                           STS_PROTOCOL_TxAddFrame();     // 版本类型
;;;1018                       }
;;;1019                       else
;;;1020                       {
;;;1021                           STS_PROTOCOL_TxAddData(STS_PROTOCOL_CMD_HEAD);
;;;1022                           STS_PROTOCOL_TxAddData(STS_PROTOCOL_CMD_CHECK_VERSION_INFO);
;;;1023                           STS_PROTOCOL_TxAddData(0x00);       // 数据长度
;;;1024                           STS_PROTOCOL_TxAddData(0);          // 校验读取结果
;;;1025                           STS_PROTOCOL_TxAddData(verType);    // 版本类型
;;;1026                           STS_PROTOCOL_TxAddData(infoLen);    // 信息长度
;;;1027   
;;;1028                           // 类型信息
;;;1029                           for (i = 0; i < infoLen; i++)
;;;1030                           {
;;;1031                               STS_PROTOCOL_TxAddData(pCmdFrame->buff[5 + i]);
;;;1032                           }
;;;1033                           STS_PROTOCOL_TxAddFrame();     // 版本类型
;;;1034                       }
;;;1035                       verwriteFlag = FALSE;
;;;1036                   }
;;;1037                   break;
;;;1038   
;;;1039               // 蓝牙测试
;;;1040               case CAN_PROTOCOL_TEST_CMD_BLUETOOTH_MAC_ADDRESS_READ:
;;;1041   
;;;1042                   // 版本比对成功将MAC地址发给电源板连接
;;;1043                   if (pCmdFrame->buff[CAN_PROTOCOL_TEST_DATA1_INDEX])
;;;1044                   {
;;;1045                       POWER_PROTOCOL_TxAddData(POWER_PROTOCOL_CMD_HEAD);
;;;1046                       POWER_PROTOCOL_TxAddData(POWER_PROTOCOL_CMD_DEVICE_ADDR);
;;;1047                       POWER_PROTOCOL_TxAddData(POWER_PROTOCOL_CMD_BLUETOOTH_CONNECT);
;;;1048                       POWER_PROTOCOL_TxAddData(12);
;;;1049                       POWER_PROTOCOL_TxAddData(pCmdFrame->buff[CAN_PROTOCOL_TEST_DATA2_INDEX]);
;;;1050                       POWER_PROTOCOL_TxAddData(pCmdFrame->buff[CAN_PROTOCOL_TEST_DATA3_INDEX]);
;;;1051                       POWER_PROTOCOL_TxAddData(pCmdFrame->buff[CAN_PROTOCOL_TEST_DATA4_INDEX]);
;;;1052                       POWER_PROTOCOL_TxAddData(pCmdFrame->buff[CAN_PROTOCOL_TEST_DATA5_INDEX]);
;;;1053                       POWER_PROTOCOL_TxAddData(pCmdFrame->buff[CAN_PROTOCOL_TEST_DATA6_INDEX]);
;;;1054                       POWER_PROTOCOL_TxAddData(pCmdFrame->buff[CAN_PROTOCOL_TEST_DATA7_INDEX]);
;;;1055                       POWER_PROTOCOL_TxAddData(pCmdFrame->buff[CAN_PROTOCOL_TEST_DATA8_INDEX]);
;;;1056                       POWER_PROTOCOL_TxAddData(pCmdFrame->buff[CAN_PROTOCOL_TEST_DATA9_INDEX]);
;;;1057                       POWER_PROTOCOL_TxAddData(pCmdFrame->buff[CAN_PROTOCOL_TEST_DATA10_INDEX]);
;;;1058                       POWER_PROTOCOL_TxAddData(pCmdFrame->buff[CAN_PROTOCOL_TEST_DATA11_INDEX]);
;;;1059                       POWER_PROTOCOL_TxAddData(pCmdFrame->buff[CAN_PROTOCOL_TEST_DATA12_INDEX]);
;;;1060                       POWER_PROTOCOL_TxAddData(pCmdFrame->buff[CAN_PROTOCOL_TEST_DATA13_INDEX]);
;;;1061                       POWER_PROTOCOL_TxAddFrame();
;;;1062                   }
;;;1063   
;;;1064                   // 版本比对失败上报STS
;;;1065                   if (0 == pCmdFrame->buff[CAN_PROTOCOL_TEST_DATA1_INDEX])
;;;1066                   {
;;;1067                       STS_PROTOCOL_TxAddData(STS_PROTOCOL_CMD_HEAD);
;;;1068                       STS_PROTOCOL_TxAddData(STS_PROTOCOL_CMD_BLE_TEST);
;;;1069                       STS_PROTOCOL_TxAddData(7);
;;;1070                       STS_PROTOCOL_TxAddData(1);
;;;1071                       STS_PROTOCOL_TxAddData((HexToChar(pCmdFrame->buff[CAN_PROTOCOL_TEST_DATA2_INDEX]) << 4) | (HexToChar(pCmdFrame->buff[CAN_PROTOCOL_TEST_DATA3_INDEX]) & 0x0F)); 
;;;1072                       STS_PROTOCOL_TxAddData((HexToChar(pCmdFrame->buff[CAN_PROTOCOL_TEST_DATA4_INDEX]) << 4) | (HexToChar(pCmdFrame->buff[CAN_PROTOCOL_TEST_DATA5_INDEX]) & 0x0F)); 
;;;1073                       STS_PROTOCOL_TxAddData((HexToChar(pCmdFrame->buff[CAN_PROTOCOL_TEST_DATA6_INDEX]) << 4) | (HexToChar(pCmdFrame->buff[CAN_PROTOCOL_TEST_DATA7_INDEX]) & 0x0F)); 
;;;1074                       STS_PROTOCOL_TxAddData((HexToChar(pCmdFrame->buff[CAN_PROTOCOL_TEST_DATA8_INDEX]) << 4) | (HexToChar(pCmdFrame->buff[CAN_PROTOCOL_TEST_DATA9_INDEX]) & 0x0F)); 
;;;1075                       STS_PROTOCOL_TxAddData((HexToChar(pCmdFrame->buff[CAN_PROTOCOL_TEST_DATA10_INDEX]) << 4) | (HexToChar(pCmdFrame->buff[CAN_PROTOCOL_TEST_DATA11_INDEX]) & 0x0F)); 
;;;1076                       STS_PROTOCOL_TxAddData((HexToChar(pCmdFrame->buff[CAN_PROTOCOL_TEST_DATA12_INDEX]) << 4) | (HexToChar(pCmdFrame->buff[CAN_PROTOCOL_TEST_DATA13_INDEX]) & 0x0F)); 
;;;1077                       
;;;1078                       for(i = 0; i < 20 ;i++)
;;;1079                       {
;;;1080                         STS_PROTOCOL_TxAddData(dut_info.bleVerBuff[i]);
;;;1081                       }
;;;1082                   
;;;1083                       STS_PROTOCOL_TxAddFrame();
;;;1084                   }
;;;1085                   break;
;;;1086   
;;;1087               // LCD 颜色测试（命令字=0x03）
;;;1088               case CAN_PROTOCOL_TEST_CMD_TEST_LCD:
;;;1089                   STS_PROTOCOL_SendCmdParamAck(CAN_PROTOCOL_TEST_CMD_TEST_LCD, TRUE);
;;;1090                   break;
;;;1091   
;;;1092               // Flash 校验测试
;;;1093               case CAN_PROTOCOL_TEST_CMD_FLASH_CHECK_TEST:
;;;1094                   TIMER_ChangeTime(TIMER_ID_ONLINE_DETECT, 3000);
;;;1095                   STS_UART_AddTxArray(0, pCmdFrame->buff, pCmdFrame->length);
;;;1096                   break;
;;;1097                   
;;;1098                // 按键测试
;;;1099               case CAN_PROTOCOL_TEST_CMD_KEY_TEST:
;;;1100                
;;;1101                   // 按键模拟测试
;;;1102                   if(dut_info.buttonSimulationFlag)
;;;1103                   {
;;;1104                       if(keyValue == pCmdFrame->buff[CAN_PROTOCOL_TEST_DATA1_INDEX])
;;;1105                       {
;;;1106                            testResult = TRUE;
;;;1107                       }
;;;1108                       else
;;;1109                       {
;;;1110                            testResult = FALSE;
;;;1111                       }
;;;1112                       STS_PROTOCOL_SendCmdParamTwoAck(STS_PROTOCOL_CMD_SIMULATION_KEY_TEST, testResult, pCmdFrame->buff[CAN_PROTOCOL_TEST_DATA1_INDEX]);                
;;;1113                   }
;;;1114                   // 按键正常测试
;;;1115                   else
;;;1116                   {
;;;1117                       STS_UART_AddTxArray(0, pCmdFrame->buff, pCmdFrame->length);                
;;;1118                   }
;;;1119                   break;               
;;;1120                   
;;;1121               default:
;;;1122                   testFlag = FALSE;
0000b6  48d3              LDR      r0,|L11.1028|
0000b8  7006              STRB     r6,[r0,#0]
;;;1123                   STS_UART_AddTxArray(0, pCmdFrame->buff, pCmdFrame->length);
0000ba  f8b42090          LDRH     r2,[r4,#0x90]
0000be  1d21              ADDS     r1,r4,#4
0000c0  2000              MOVS     r0,#0
0000c2  f7fffffe          BL       STS_UART_AddTxArray
;;;1124   
;;;1125                   // LCD显示
;;;1126                   Vertical_Scrolling_Display(ptUpMsgBuff, 4, 0);
0000c6  48cd              LDR      r0,|L11.1020|
0000c8  2200              MOVS     r2,#0
0000ca  2104              MOVS     r1,#4
0000cc  300d              ADDS     r0,r0,#0xd
0000ce  f7fffffe          BL       Vertical_Scrolling_Display
                  |L11.210|
;;;1127                   break;
;;;1128           }
;;;1129           // 删除命令帧
;;;1130           pCB->rx.rxEachNode[sourceBuffSelect].head++;
0000d2  f8b80e98          LDRH     r0,[r8,#0xe98]
0000d6  1c40              ADDS     r0,r0,#1
0000d8  b280              UXTH     r0,r0
;;;1131           pCB->rx.rxEachNode[sourceBuffSelect].head %= CAN_TEST_RX_QUEUE_SIZE;
0000da  2150              MOVS     r1,#0x50
0000dc  fbb0f2f1          UDIV     r2,r0,r1
0000e0  fb010012          MLS      r0,r1,r2,r0
0000e4  f8a80e98          STRH     r0,[r8,#0xe98]
                  |L11.232|
0000e8  1c7f              ADDS     r7,r7,#1              ;639
0000ea  b2ff              UXTB     r7,r7                 ;639
0000ec  2f00              CMP      r7,#0                 ;639
0000ee  d09b              BEQ      |L11.40|
                  |L11.240|
;;;1132       }
;;;1133   }
0000f0  b01d              ADD      sp,sp,#0x74
0000f2  e8bd8ff0          POP      {r4-r11,pc}
                  |L11.246|
0000f6  79e4              LDRB     r4,[r4,#7]            ;670
0000f8  f7fffffe          BL       Clear_All_Lines
0000fc  a1c2              ADR      r1,|L11.1032|
0000fe  2001              MOVS     r0,#1                 ;677
000100  f7fffffe          BL       Display_Centered
000104  f88a6000          STRB     r6,[r10,#0]           ;679
000108  2100              MOVS     r1,#0                 ;680
00010a  200b              MOVS     r0,#0xb               ;680
00010c  f7fffffe          BL       STS_PROTOCOL_SendCmdParamAck
000110  07e0              LSLS     r0,r4,#31             ;684
000112  d0de              BEQ      |L11.210|
000114  f89a0000          LDRB     r0,[r10,#0]           ;686  ; can_light_cnt
000118  1c40              ADDS     r0,r0,#1              ;686
00011a  b2c0              UXTB     r0,r0                 ;686
00011c  f88a0000          STRB     r0,[r10,#0]           ;686
000120  2801              CMP      r0,#1                 ;687
000122  d102              BNE      |L11.298|
000124  206e              MOVS     r0,#0x6e              ;689
000126  f7fffffe          BL       STATE_SwitchStep
                  |L11.298|
00012a  f89a0000          LDRB     r0,[r10,#0]           ;691  ; can_light_cnt
00012e  2802              CMP      r0,#2                 ;691
000130  d1cf              BNE      |L11.210|
000132  2072              MOVS     r0,#0x72              ;693
000134  f7fffffe          BL       STATE_SwitchStep
000138  f88a6000          STRB     r6,[r10,#0]           ;694
                  |L11.316|
00013c  e7c9              B        |L11.210|
                  |L11.318|
00013e  79e5              LDRB     r5,[r4,#7]            ;703
000140  07e8              LSLS     r0,r5,#31             ;705
000142  d028              BEQ      |L11.406|
000144  7a20              LDRB     r0,[r4,#8]            ;707
000146  0200              LSLS     r0,r0,#8              ;707
000148  f8a90040          STRH     r0,[r9,#0x40]         ;707
00014c  7a61              LDRB     r1,[r4,#9]            ;708
00014e  4308              ORRS     r0,r0,r1              ;708
000150  f8a90040          STRH     r0,[r9,#0x40]         ;708
000154  f89a0004          LDRB     r0,[r10,#4]           ;709  ; can_throttleAd_cnt
000158  1c40              ADDS     r0,r0,#1              ;709
00015a  b2c0              UXTB     r0,r0                 ;709
00015c  f88a0004          STRB     r0,[r10,#4]           ;709
000160  b1c8              CBZ      r0,|L11.406|
000162  2801              CMP      r0,#1                 ;710
000164  d00a              BEQ      |L11.380|
000166  2802              CMP      r0,#2                 ;710
000168  d00c              BEQ      |L11.388|
00016a  2803              CMP      r0,#3                 ;710
00016c  d113              BNE      |L11.406|
00016e  e00d              B        |L11.396|
                  |L11.368|
000170  e0f5              B        |L11.862|
                  |L11.370|
000172  e2af              B        |L11.1748|
                  |L11.372|
000174  e2a9              B        |L11.1738|
                  |L11.374|
000176  e209              B        |L11.1420|
                  |L11.376|
000178  e121              B        |L11.958|
                  |L11.378|
00017a  e12e              B        |L11.986|
                  |L11.380|
00017c  209a              MOVS     r0,#0x9a              ;716
00017e  f7fffffe          BL       STATE_SwitchStep
000182  e008              B        |L11.406|
                  |L11.388|
000184  209b              MOVS     r0,#0x9b              ;720
000186  f7fffffe          BL       STATE_SwitchStep
00018a  e004              B        |L11.406|
                  |L11.396|
00018c  209c              MOVS     r0,#0x9c              ;724
00018e  f7fffffe          BL       STATE_SwitchStep
000192  f88a6004          STRB     r6,[r10,#4]           ;725
                  |L11.406|
000196  07a8              LSLS     r0,r5,#30             ;733
000198  d525              BPL      |L11.486|
00019a  7a20              LDRB     r0,[r4,#8]            ;735
00019c  0200              LSLS     r0,r0,#8              ;735
00019e  f8a90042          STRH     r0,[r9,#0x42]         ;735
0001a2  7a61              LDRB     r1,[r4,#9]            ;736
0001a4  4308              ORRS     r0,r0,r1              ;736
0001a6  f8a90042          STRH     r0,[r9,#0x42]         ;736
0001aa  f89a0003          LDRB     r0,[r10,#3]           ;737  ; can_brake_cnt
0001ae  e001              B        |L11.436|
                  |L11.432|
0001b0  e040              B        |L11.564|
                  |L11.434|
0001b2  e079              B        |L11.680|
                  |L11.436|
0001b4  1c40              ADDS     r0,r0,#1              ;737
0001b6  b2c0              UXTB     r0,r0                 ;737
0001b8  f88a0003          STRB     r0,[r10,#3]           ;737
0001bc  b198              CBZ      r0,|L11.486|
0001be  2801              CMP      r0,#1                 ;739
0001c0  d004              BEQ      |L11.460|
0001c2  2802              CMP      r0,#2                 ;739
0001c4  d006              BEQ      |L11.468|
0001c6  2803              CMP      r0,#3                 ;739
0001c8  d10d              BNE      |L11.486|
0001ca  e007              B        |L11.476|
                  |L11.460|
0001cc  20a3              MOVS     r0,#0xa3              ;745
0001ce  f7fffffe          BL       STATE_SwitchStep
0001d2  e008              B        |L11.486|
                  |L11.468|
0001d4  20a4              MOVS     r0,#0xa4              ;749
0001d6  f7fffffe          BL       STATE_SwitchStep
0001da  e004              B        |L11.486|
                  |L11.476|
0001dc  20a5              MOVS     r0,#0xa5              ;753
0001de  f7fffffe          BL       STATE_SwitchStep
0001e2  f88a6003          STRB     r6,[r10,#3]           ;754
                  |L11.486|
0001e6  43e8              MVNS     r0,r5                 ;763
0001e8  0780              LSLS     r0,r0,#30             ;763
0001ea  d1a7              BNE      |L11.316|
0001ec  7a20              LDRB     r0,[r4,#8]            ;766
0001ee  0200              LSLS     r0,r0,#8              ;766
0001f0  f8a90044          STRH     r0,[r9,#0x44]         ;766
0001f4  7a61              LDRB     r1,[r4,#9]            ;767
0001f6  4308              ORRS     r0,r0,r1              ;767
0001f8  f8a90044          STRH     r0,[r9,#0x44]         ;767
0001fc  f89a0005          LDRB     r0,[r10,#5]           ;768  ; can_derailleurAd_cnt
000200  1c40              ADDS     r0,r0,#1              ;768
000202  b2c0              UXTB     r0,r0                 ;768
000204  f88a0005          STRB     r0,[r10,#5]           ;768
000208  2800              CMP      r0,#0                 ;770
00020a  d097              BEQ      |L11.316|
00020c  2801              CMP      r0,#1                 ;770
00020e  d009              BEQ      |L11.548|
000210  2802              CMP      r0,#2                 ;770
000212  d00b              BEQ      |L11.556|
000214  2803              CMP      r0,#3                 ;770
000216  d191              BNE      |L11.316|
000218  2053              MOVS     r0,#0x53              ;784
00021a  f7fffffe          BL       STATE_SwitchStep
00021e  f88a6005          STRB     r6,[r10,#5]           ;785
                  |L11.546|
000222  e756              B        |L11.210|
                  |L11.548|
000224  2051              MOVS     r0,#0x51              ;776
000226  f7fffffe          BL       STATE_SwitchStep
00022a  e752              B        |L11.210|
                  |L11.556|
00022c  2052              MOVS     r0,#0x52              ;780
00022e  f7fffffe          BL       STATE_SwitchStep
000232  e74e              B        |L11.210|
                  |L11.564|
000234  79e5              LDRB     r5,[r4,#7]            ;796
000236  7a24              LDRB     r4,[r4,#8]            ;797
000238  f7fffffe          BL       Clear_All_Lines
00023c  a179              ADR      r1,|L11.1060|
00023e  2001              MOVS     r0,#1                 ;804
000240  f7fffffe          BL       Display_Centered
000244  f88a6001          STRB     r6,[r10,#1]           ;806
000248  f88a6002          STRB     r6,[r10,#2]           ;807
00024c  2100              MOVS     r1,#0                 ;808
00024e  200b              MOVS     r0,#0xb               ;808
000250  f7fffffe          BL       STS_PROTOCOL_SendCmdParamAck
000254  b995              CBNZ     r5,|L11.636|
000256  2c01              CMP      r4,#1                 ;812
000258  d110              BNE      |L11.636|
00025a  f89a0001          LDRB     r0,[r10,#1]           ;814  ; can_left_light_cnt
00025e  1c40              ADDS     r0,r0,#1              ;814
000260  f88a0001          STRB     r0,[r10,#1]           ;814
000264  2087              MOVS     r0,#0x87              ;815
000266  f7fffffe          BL       STATE_SwitchStep
00026a  f89a0001          LDRB     r0,[r10,#1]           ;816  ; can_left_light_cnt
00026e  2802              CMP      r0,#2                 ;816
000270  d104              BNE      |L11.636|
000272  208b              MOVS     r0,#0x8b              ;818
000274  f7fffffe          BL       STATE_SwitchStep
000278  f88a6001          STRB     r6,[r10,#1]           ;819
                  |L11.636|
00027c  2d01              CMP      r5,#1                 ;824
00027e  d1d0              BNE      |L11.546|
000280  2c01              CMP      r4,#1                 ;824
000282  d1ce              BNE      |L11.546|
000284  f89a0002          LDRB     r0,[r10,#2]           ;826  ; can_right_light_cnt
000288  1c40              ADDS     r0,r0,#1              ;826
00028a  f88a0002          STRB     r0,[r10,#2]           ;826
00028e  2090              MOVS     r0,#0x90              ;827
000290  f7fffffe          BL       STATE_SwitchStep
000294  f89a0002          LDRB     r0,[r10,#2]           ;828  ; can_right_light_cnt
000298  2802              CMP      r0,#2                 ;828
00029a  d1c2              BNE      |L11.546|
00029c  2094              MOVS     r0,#0x94              ;830
00029e  f7fffffe          BL       STATE_SwitchStep
0002a2  f88a6002          STRB     r6,[r10,#2]           ;831
                  |L11.678|
0002a6  e714              B        |L11.210|
                  |L11.680|
0002a8  4c65              LDR      r4,|L11.1088|
0002aa  6820              LDR      r0,[r4,#0]            ;838  ; online_detection_cnt
0002ac  1c40              ADDS     r0,r0,#1              ;838
0002ae  6020              STR      r0,[r4,#0]            ;838  ; online_detection_cnt
0002b0  2011              MOVS     r0,#0x11              ;839
0002b2  f7fffffe          BL       TIMER_ResetTimer
0002b6  6820              LDR      r0,[r4,#0]            ;841  ; online_detection_cnt
0002b8  2801              CMP      r0,#1                 ;841
0002ba  d1b2              BNE      |L11.546|
0002bc  2101              MOVS     r1,#1                 ;844
0002be  2018              MOVS     r0,#0x18              ;844
0002c0  f7fffffe          BL       STS_PROTOCOL_SendCmdParamAck
0002c4  e705              B        |L11.210|
                  |L11.710|
0002c6  4d5f              LDR      r5,|L11.1092|
0002c8  7828              LDRB     r0,[r5,#0]            ;854  ; cali_cnt
0002ca  1c40              ADDS     r0,r0,#1              ;854
0002cc  7028              STRB     r0,[r5,#0]            ;854
0002ce  79e4              LDRB     r4,[r4,#7]            ;855
0002d0  b13c              CBZ      r4,|L11.738|
0002d2  f8990030          LDRB     r0,[r9,#0x30]         ;858  ; dut_info
0002d6  2801              CMP      r0,#1                 ;858
0002d8  d103              BNE      |L11.738|
0002da  2066              MOVS     r0,#0x66              ;860
0002dc  f7fffffe          BL       STATE_SwitchStep
0002e0  702e              STRB     r6,[r5,#0]            ;861
                  |L11.738|
0002e2  b184              CBZ      r4,|L11.774|
0002e4  f8990030          LDRB     r0,[r9,#0x30]         ;865  ; dut_info
0002e8  2802              CMP      r0,#2                 ;865
0002ea  d10c              BNE      |L11.774|
0002ec  7828              LDRB     r0,[r5,#0]            ;867  ; cali_cnt
0002ee  2801              CMP      r0,#1                 ;867
0002f0  d102              BNE      |L11.760|
0002f2  2062              MOVS     r0,#0x62              ;869
0002f4  f7fffffe          BL       STATE_SwitchStep
                  |L11.760|
0002f8  7828              LDRB     r0,[r5,#0]            ;871  ; cali_cnt
0002fa  2802              CMP      r0,#2                 ;871
0002fc  d103              BNE      |L11.774|
0002fe  2066              MOVS     r0,#0x66              ;873
000300  f7fffffe          BL       STATE_SwitchStep
000304  702e              STRB     r6,[r5,#0]            ;874
                  |L11.774|
000306  b1ac              CBZ      r4,|L11.820|
000308  f8990030          LDRB     r0,[r9,#0x30]         ;879  ; dut_info
00030c  2803              CMP      r0,#3                 ;879
00030e  d111              BNE      |L11.820|
000310  7828              LDRB     r0,[r5,#0]            ;881  ; cali_cnt
000312  2801              CMP      r0,#1                 ;881
000314  d102              BNE      |L11.796|
000316  2062              MOVS     r0,#0x62              ;883
000318  f7fffffe          BL       STATE_SwitchStep
                  |L11.796|
00031c  7828              LDRB     r0,[r5,#0]            ;885  ; cali_cnt
00031e  2802              CMP      r0,#2                 ;885
000320  d102              BNE      |L11.808|
000322  2064              MOVS     r0,#0x64              ;887
000324  f7fffffe          BL       STATE_SwitchStep
                  |L11.808|
000328  7828              LDRB     r0,[r5,#0]            ;889  ; cali_cnt
00032a  2803              CMP      r0,#3                 ;889
00032c  d102              BNE      |L11.820|
00032e  2066              MOVS     r0,#0x66              ;891
000330  f7fffffe          BL       STATE_SwitchStep
                  |L11.820|
000334  2c00              CMP      r4,#0                 ;896
000336  d1b6              BNE      |L11.678|
000338  702e              STRB     r6,[r5,#0]            ;898
00033a  f7fffffe          BL       Clear_All_Lines
00033e  a142              ADR      r1,|L11.1096|
000340  2000              MOVS     r0,#0                 ;900
000342  f7fffffe          BL       Display_Centered
000346  a143              ADR      r1,|L11.1108|
000348  2001              MOVS     r0,#1                 ;901
00034a  f7fffffe          BL       Display_Centered
00034e  2100              MOVS     r1,#0                 ;902
000350  2015              MOVS     r0,#0x15              ;902
000352  f7fffffe          BL       STS_PROTOCOL_SendCmdParamAck
000356  2008              MOVS     r0,#8                 ;903
000358  f7fffffe          BL       TIMER_KillTask
00035c  e6b9              B        |L11.210|
                  |L11.862|
00035e  2012              MOVS     r0,#0x12              ;909
000360  f7fffffe          BL       TIMER_KillTask
000364  961a              STR      r6,[sp,#0x68]         ;912
000366  483d              LDR      r0,|L11.1116|
000368  aa19              ADD      r2,sp,#0x64           ;620
00036a  7800              LDRB     r0,[r0,#0]            ;914
00036c  e00c              B        |L11.904|
                  |L11.878|
00036e  f8bd1068          LDRH     r1,[sp,#0x68]         ;914
000372  f8bd3068          LDRH     r3,[sp,#0x68]         ;914
000376  eb010180          ADD      r1,r1,r0,LSL #2       ;914
00037a  4421              ADD      r1,r1,r4              ;914
00037c  7a09              LDRB     r1,[r1,#8]            ;914
00037e  54d1              STRB     r1,[r2,r3]            ;914
000380  f8bd1068          LDRH     r1,[sp,#0x68]         ;912
000384  1c49              ADDS     r1,r1,#1              ;912
000386  911a              STR      r1,[sp,#0x68]         ;912
                  |L11.904|
000388  f8bd1068          LDRH     r1,[sp,#0x68]         ;912
00038c  2904              CMP      r1,#4                 ;912
00038e  d3ee              BCC      |L11.878|
000390  f89d0064          LDRB     r0,[sp,#0x64]         ;918
000394  b948              CBNZ     r0,|L11.938|
000396  f89d0065          LDRB     r0,[sp,#0x65]         ;918
00039a  b930              CBNZ     r0,|L11.938|
00039c  f89d0066          LDRB     r0,[sp,#0x66]         ;918
0003a0  b918              CBNZ     r0,|L11.938|
0003a2  f89d0067          LDRB     r0,[sp,#0x67]         ;918
0003a6  2802              CMP      r0,#2                 ;918
0003a8  d004              BEQ      |L11.948|
                  |L11.938|
0003aa  2100              MOVS     r1,#0                 ;924
0003ac  2001              MOVS     r0,#1                 ;924
0003ae  f7fffffe          BL       STS_PROTOCOL_SendCmdParamAck
0003b2  e68e              B        |L11.210|
                  |L11.948|
0003b4  2101              MOVS     r1,#1                 ;920
0003b6  4608              MOV      r0,r1                 ;920
0003b8  f7fffffe          BL       STS_PROTOCOL_SendCmdParamAck
0003bc  e689              B        |L11.210|
                  |L11.958|
0003be  2012              MOVS     r0,#0x12              ;932
0003c0  f7fffffe          BL       TIMER_ResetTimer
0003c4  79e0              LDRB     r0,[r4,#7]            ;935
0003c6  b118              CBZ      r0,|L11.976|
0003c8  20a6              MOVS     r0,#0xa6              ;937
0003ca  f7fffffe          BL       CAN_PROTOCOL_TEST_SendCmdAck
0003ce  e680              B        |L11.210|
                  |L11.976|
0003d0  2100              MOVS     r1,#0                 ;941
0003d2  2001              MOVS     r0,#1                 ;941
0003d4  f7fffffe          BL       STS_PROTOCOL_SendCmdParamAck
0003d8  e67b              B        |L11.210|
                  |L11.986|
0003da  2013              MOVS     r0,#0x13              ;949
0003dc  f7fffffe          BL       TIMER_ResetTimer
0003e0  79e0              LDRB     r0,[r4,#7]            ;952
0003e2  491f              LDR      r1,|L11.1120|
0003e4  7809              LDRB     r1,[r1,#0]            ;955  ; dutverType
0003e6  4281              CMP      r1,r0                 ;955
0003e8  d13c              BNE      |L11.1124|
0003ea  7a20              LDRB     r0,[r4,#8]            ;955
0003ec  b118              CBZ      r0,|L11.1014|
0003ee  20a9              MOVS     r0,#0xa9              ;958
0003f0  f7fffffe          BL       CAN_PROTOCOL_TEST_SendCmdParamAck
                  |L11.1012|
0003f4  e66d              B        |L11.210|
                  |L11.1014|
0003f6  e035              B        |L11.1124|
                  |L11.1016|
                          DCD      ||.constdata||
                  |L11.1020|
                          DCD      ||.data||
                  |L11.1024|
                          DCD      dut_info
                  |L11.1028|
                          DCD      testFlag
                  |L11.1032|
000408  48656164          DCB      "Headlights fail to turn on",0
00040c  6c696768
000410  74732066
000414  61696c20
000418  746f2074
00041c  75726e20
000420  6f6e00  
000423  00                DCB      0
                  |L11.1060|
000424  5455524e          DCB      "TURN SIGNAL fail to turn on",0
000428  20534947
00042c  4e414c20
000430  6661696c
000434  20746f20
000438  7475726e
00043c  206f6e00
                  |L11.1088|
                          DCD      online_detection_cnt
                  |L11.1092|
                          DCD      cali_cnt
                  |L11.1096|
000448  43616c69          DCB      "Calibration",0
00044c  62726174
000450  696f6e00
                  |L11.1108|
000454  4661696c          DCB      "Fail",0
000458  00      
000459  00                DCB      0
00045a  00                DCB      0
00045b  00                DCB      0
                  |L11.1116|
                          DCD      stationNumber
                  |L11.1120|
                          DCD      dutverType
                  |L11.1124|
000464  2100              MOVS     r1,#0                 ;962
000466  2002              MOVS     r0,#2                 ;962
000468  f7fffffe          BL       STS_PROTOCOL_SendCmdParamAck
00046c  e631              B        |L11.210|
                  |L11.1134|
00046e  2013              MOVS     r0,#0x13              ;968
000470  f7fffffe          BL       TIMER_KillTask
000474  f894b007          LDRB     r11,[r4,#7]           ;971
000478  7a25              LDRB     r5,[r4,#8]            ;974
00047a  f1040109          ADD      r1,r4,#9              ;977
00047e  4668              MOV      r0,sp                 ;977
000480  f7fffffe          BL       strcpy
000484  f80d6005          STRB     r6,[sp,r5]            ;978
000488  48a3              LDR      r0,|L11.1816|
00048a  7800              LDRB     r0,[r0,#0]            ;981  ; verreadFlag
00048c  b328              CBZ      r0,|L11.1242|
00048e  2055              MOVS     r0,#0x55              ;983
000490  f7fffffe          BL       STS_PROTOCOL_TxAddData
000494  2002              MOVS     r0,#2                 ;984
000496  f7fffffe          BL       STS_PROTOCOL_TxAddData
00049a  2000              MOVS     r0,#0                 ;985
00049c  f7fffffe          BL       STS_PROTOCOL_TxAddData
0004a0  2001              MOVS     r0,#1                 ;986
0004a2  f7fffffe          BL       STS_PROTOCOL_TxAddData
0004a6  4658              MOV      r0,r11                ;987
0004a8  f7fffffe          BL       STS_PROTOCOL_TxAddData
0004ac  4628              MOV      r0,r5                 ;988
0004ae  f7fffffe          BL       STS_PROTOCOL_TxAddData
0004b2  961a              STR      r6,[sp,#0x68]         ;991
0004b4  e009              B        |L11.1226|
                  |L11.1206|
0004b6  f8bd0068          LDRH     r0,[sp,#0x68]         ;993
0004ba  4420              ADD      r0,r0,r4              ;993
0004bc  7a40              LDRB     r0,[r0,#9]            ;993
0004be  f7fffffe          BL       STS_PROTOCOL_TxAddData
0004c2  f8bd0068          LDRH     r0,[sp,#0x68]         ;991
0004c6  1c40              ADDS     r0,r0,#1              ;991
0004c8  901a              STR      r0,[sp,#0x68]         ;991
                  |L11.1226|
0004ca  f8bd0068          LDRH     r0,[sp,#0x68]         ;991
0004ce  42a8              CMP      r0,r5                 ;991
0004d0  d3f1              BCC      |L11.1206|
0004d2  f7fffffe          BL       STS_PROTOCOL_TxAddFrame
0004d6  4890              LDR      r0,|L11.1816|
0004d8  7006              STRB     r6,[r0,#0]            ;996
                  |L11.1242|
0004da  4890              LDR      r0,|L11.1820|
0004dc  7800              LDRB     r0,[r0,#0]            ;1000  ; verwriteFlag
0004de  2800              CMP      r0,#0                 ;1000
0004e0  d088              BEQ      |L11.1012|
0004e2  488f              LDR      r0,|L11.1824|
0004e4  7800              LDRB     r0,[r0,#0]            ;1003  ; dutverType
0004e6  4558              CMP      r0,r11                ;1003
0004e8  d129              BNE      |L11.1342|
0004ea  4669              MOV      r1,sp                 ;1003
0004ec  488d              LDR      r0,|L11.1828|
0004ee  f7fffffe          BL       strstr
0004f2  b320              CBZ      r0,|L11.1342|
0004f4  2055              MOVS     r0,#0x55              ;1005
0004f6  f7fffffe          BL       STS_PROTOCOL_TxAddData
0004fa  2002              MOVS     r0,#2                 ;1006
0004fc  f7fffffe          BL       STS_PROTOCOL_TxAddData
000500  2000              MOVS     r0,#0                 ;1007
000502  f7fffffe          BL       STS_PROTOCOL_TxAddData
000506  2001              MOVS     r0,#1                 ;1008
000508  f7fffffe          BL       STS_PROTOCOL_TxAddData
00050c  4658              MOV      r0,r11                ;1009
00050e  f7fffffe          BL       STS_PROTOCOL_TxAddData
000512  4628              MOV      r0,r5                 ;1010
000514  f7fffffe          BL       STS_PROTOCOL_TxAddData
000518  961a              STR      r6,[sp,#0x68]         ;1013
00051a  e009              B        |L11.1328|
                  |L11.1308|
00051c  f8bd0068          LDRH     r0,[sp,#0x68]         ;1015
000520  4420              ADD      r0,r0,r4              ;1015
000522  7a40              LDRB     r0,[r0,#9]            ;1015
000524  f7fffffe          BL       STS_PROTOCOL_TxAddData
000528  f8bd0068          LDRH     r0,[sp,#0x68]         ;1013
00052c  1c40              ADDS     r0,r0,#1              ;1013
00052e  901a              STR      r0,[sp,#0x68]         ;1013
                  |L11.1328|
000530  f8bd0068          LDRH     r0,[sp,#0x68]         ;1013
000534  42a8              CMP      r0,r5                 ;1013
000536  d3f1              BCC      |L11.1308|
000538  f7fffffe          BL       STS_PROTOCOL_TxAddFrame
00053c  e023              B        |L11.1414|
                  |L11.1342|
00053e  2055              MOVS     r0,#0x55              ;1021
000540  f7fffffe          BL       STS_PROTOCOL_TxAddData
000544  2002              MOVS     r0,#2                 ;1022
000546  f7fffffe          BL       STS_PROTOCOL_TxAddData
00054a  2000              MOVS     r0,#0                 ;1023
00054c  f7fffffe          BL       STS_PROTOCOL_TxAddData
000550  2000              MOVS     r0,#0                 ;1024
000552  f7fffffe          BL       STS_PROTOCOL_TxAddData
000556  4658              MOV      r0,r11                ;1025
000558  f7fffffe          BL       STS_PROTOCOL_TxAddData
00055c  4628              MOV      r0,r5                 ;1026
00055e  f7fffffe          BL       STS_PROTOCOL_TxAddData
000562  961a              STR      r6,[sp,#0x68]         ;1029
000564  e009              B        |L11.1402|
                  |L11.1382|
000566  f8bd0068          LDRH     r0,[sp,#0x68]         ;1031
00056a  4420              ADD      r0,r0,r4              ;1031
00056c  7a40              LDRB     r0,[r0,#9]            ;1031
00056e  f7fffffe          BL       STS_PROTOCOL_TxAddData
000572  f8bd0068          LDRH     r0,[sp,#0x68]         ;1029
000576  1c40              ADDS     r0,r0,#1              ;1029
000578  901a              STR      r0,[sp,#0x68]         ;1029
                  |L11.1402|
00057a  f8bd0068          LDRH     r0,[sp,#0x68]         ;1029
00057e  42a8              CMP      r0,r5                 ;1029
000580  d3f1              BCC      |L11.1382|
000582  f7fffffe          BL       STS_PROTOCOL_TxAddFrame
                  |L11.1414|
000586  4865              LDR      r0,|L11.1820|
000588  7006              STRB     r6,[r0,#0]            ;1035
                  |L11.1418|
00058a  e5a2              B        |L11.210|
                  |L11.1420|
00058c  79e0              LDRB     r0,[r4,#7]            ;1043
00058e  b388              CBZ      r0,|L11.1524|
000590  203a              MOVS     r0,#0x3a              ;1045
000592  f7fffffe          BL       POWER_PROTOCOL_TxAddData
000596  201a              MOVS     r0,#0x1a              ;1046
000598  f7fffffe          BL       POWER_PROTOCOL_TxAddData
00059c  2006              MOVS     r0,#6                 ;1047
00059e  f7fffffe          BL       POWER_PROTOCOL_TxAddData
0005a2  200c              MOVS     r0,#0xc               ;1048
0005a4  f7fffffe          BL       POWER_PROTOCOL_TxAddData
0005a8  7a20              LDRB     r0,[r4,#8]            ;1049
0005aa  f7fffffe          BL       POWER_PROTOCOL_TxAddData
0005ae  7a60              LDRB     r0,[r4,#9]            ;1050
0005b0  f7fffffe          BL       POWER_PROTOCOL_TxAddData
0005b4  7aa0              LDRB     r0,[r4,#0xa]          ;1051
0005b6  f7fffffe          BL       POWER_PROTOCOL_TxAddData
0005ba  7ae0              LDRB     r0,[r4,#0xb]          ;1052
0005bc  f7fffffe          BL       POWER_PROTOCOL_TxAddData
0005c0  7b20              LDRB     r0,[r4,#0xc]          ;1053
0005c2  f7fffffe          BL       POWER_PROTOCOL_TxAddData
0005c6  7b60              LDRB     r0,[r4,#0xd]          ;1054
0005c8  f7fffffe          BL       POWER_PROTOCOL_TxAddData
0005cc  7ba0              LDRB     r0,[r4,#0xe]          ;1055
0005ce  f7fffffe          BL       POWER_PROTOCOL_TxAddData
0005d2  7be0              LDRB     r0,[r4,#0xf]          ;1056
0005d4  f7fffffe          BL       POWER_PROTOCOL_TxAddData
0005d8  7c20              LDRB     r0,[r4,#0x10]         ;1057
0005da  f7fffffe          BL       POWER_PROTOCOL_TxAddData
0005de  7c60              LDRB     r0,[r4,#0x11]         ;1058
0005e0  f7fffffe          BL       POWER_PROTOCOL_TxAddData
0005e4  7ca0              LDRB     r0,[r4,#0x12]         ;1059
0005e6  f7fffffe          BL       POWER_PROTOCOL_TxAddData
0005ea  7ce0              LDRB     r0,[r4,#0x13]         ;1060
0005ec  f7fffffe          BL       POWER_PROTOCOL_TxAddData
0005f0  f7fffffe          BL       POWER_PROTOCOL_TxAddFrame
                  |L11.1524|
0005f4  79e0              LDRB     r0,[r4,#7]            ;1065
0005f6  2800              CMP      r0,#0                 ;1065
0005f8  d1c7              BNE      |L11.1418|
0005fa  2055              MOVS     r0,#0x55              ;1067
0005fc  f7fffffe          BL       STS_PROTOCOL_TxAddData
000600  200c              MOVS     r0,#0xc               ;1068
000602  f7fffffe          BL       STS_PROTOCOL_TxAddData
000606  2007              MOVS     r0,#7                 ;1069
000608  f7fffffe          BL       STS_PROTOCOL_TxAddData
00060c  2001              MOVS     r0,#1                 ;1070
00060e  f7fffffe          BL       STS_PROTOCOL_TxAddData
000612  7a20              LDRB     r0,[r4,#8]            ;1071
000614  f7fffffe          BL       HexToChar
000618  4605              MOV      r5,r0                 ;1071
00061a  7a60              LDRB     r0,[r4,#9]            ;1071
00061c  f7fffffe          BL       HexToChar
000620  f365101f          BFI      r0,r5,#4,#28          ;1071
000624  b2c0              UXTB     r0,r0                 ;1071
000626  f7fffffe          BL       STS_PROTOCOL_TxAddData
00062a  7aa0              LDRB     r0,[r4,#0xa]          ;1072
00062c  f7fffffe          BL       HexToChar
000630  4605              MOV      r5,r0                 ;1072
000632  7ae0              LDRB     r0,[r4,#0xb]          ;1072
000634  f7fffffe          BL       HexToChar
000638  f365101f          BFI      r0,r5,#4,#28          ;1072
00063c  b2c0              UXTB     r0,r0                 ;1072
00063e  f7fffffe          BL       STS_PROTOCOL_TxAddData
000642  7b20              LDRB     r0,[r4,#0xc]          ;1073
000644  f7fffffe          BL       HexToChar
000648  4605              MOV      r5,r0                 ;1073
00064a  7b60              LDRB     r0,[r4,#0xd]          ;1073
00064c  f7fffffe          BL       HexToChar
000650  f365101f          BFI      r0,r5,#4,#28          ;1073
000654  b2c0              UXTB     r0,r0                 ;1073
000656  f7fffffe          BL       STS_PROTOCOL_TxAddData
00065a  7ba0              LDRB     r0,[r4,#0xe]          ;1074
00065c  f7fffffe          BL       HexToChar
000660  4605              MOV      r5,r0                 ;1074
000662  7be0              LDRB     r0,[r4,#0xf]          ;1074
000664  f7fffffe          BL       HexToChar
000668  f365101f          BFI      r0,r5,#4,#28          ;1074
00066c  b2c0              UXTB     r0,r0                 ;1074
00066e  f7fffffe          BL       STS_PROTOCOL_TxAddData
000672  7c20              LDRB     r0,[r4,#0x10]         ;1075
000674  f7fffffe          BL       HexToChar
000678  4605              MOV      r5,r0                 ;1075
00067a  7c60              LDRB     r0,[r4,#0x11]         ;1075
00067c  f7fffffe          BL       HexToChar
000680  f365101f          BFI      r0,r5,#4,#28          ;1075
000684  b2c0              UXTB     r0,r0                 ;1075
000686  f7fffffe          BL       STS_PROTOCOL_TxAddData
00068a  7ca0              LDRB     r0,[r4,#0x12]         ;1076
00068c  f7fffffe          BL       HexToChar
000690  4605              MOV      r5,r0                 ;1076
000692  7ce0              LDRB     r0,[r4,#0x13]         ;1076
000694  f7fffffe          BL       HexToChar
000698  f365101f          BFI      r0,r5,#4,#28          ;1076
00069c  b2c0              UXTB     r0,r0                 ;1076
00069e  f7fffffe          BL       STS_PROTOCOL_TxAddData
0006a2  961a              STR      r6,[sp,#0x68]         ;1078
0006a4  e00a              B        |L11.1724|
                  |L11.1702|
0006a6  f8bd0068          LDRH     r0,[sp,#0x68]         ;1080
0006aa  4448              ADD      r0,r0,r9              ;1080
0006ac  f890010c          LDRB     r0,[r0,#0x10c]        ;1080
0006b0  f7fffffe          BL       STS_PROTOCOL_TxAddData
0006b4  f8bd0068          LDRH     r0,[sp,#0x68]         ;1078
0006b8  1c40              ADDS     r0,r0,#1              ;1078
0006ba  901a              STR      r0,[sp,#0x68]         ;1078
                  |L11.1724|
0006bc  f8bd0068          LDRH     r0,[sp,#0x68]         ;1078
0006c0  2814              CMP      r0,#0x14              ;1078
0006c2  d3f0              BCC      |L11.1702|
0006c4  f7fffffe          BL       STS_PROTOCOL_TxAddFrame
0006c8  e503              B        |L11.210|
                  |L11.1738|
0006ca  2101              MOVS     r1,#1                 ;1089
0006cc  2003              MOVS     r0,#3                 ;1089
0006ce  f7fffffe          BL       STS_PROTOCOL_SendCmdParamAck
0006d2  e4fe              B        |L11.210|
                  |L11.1748|
0006d4  f64031b8          MOV      r1,#0xbb8             ;1094
0006d8  2011              MOVS     r0,#0x11              ;1094
0006da  f7fffffe          BL       TIMER_ChangeTime
0006de  f8b42090          LDRH     r2,[r4,#0x90]         ;1095
0006e2  1d21              ADDS     r1,r4,#4              ;1095
0006e4  2000              MOVS     r0,#0                 ;1095
0006e6  f7fffffe          BL       STS_UART_AddTxArray
0006ea  e4f2              B        |L11.210|
                  |L11.1772|
0006ec  f899010a          LDRB     r0,[r9,#0x10a]        ;1102  ; dut_info
0006f0  b158              CBZ      r0,|L11.1802|
0006f2  480d              LDR      r0,|L11.1832|
0006f4  79e2              LDRB     r2,[r4,#7]            ;1104
0006f6  7800              LDRB     r0,[r0,#0]            ;1104  ; keyValue
0006f8  4282              CMP      r2,r0                 ;1104
0006fa  d101              BNE      |L11.1792|
0006fc  2101              MOVS     r1,#1                 ;1106
0006fe  e000              B        |L11.1794|
                  |L11.1792|
000700  2100              MOVS     r1,#0                 ;1110
                  |L11.1794|
000702  201e              MOVS     r0,#0x1e              ;1112
000704  f7fffffe          BL       STS_PROTOCOL_SendCmdParamTwoAck
000708  e4e3              B        |L11.210|
                  |L11.1802|
00070a  f8b42090          LDRH     r2,[r4,#0x90]         ;1117
00070e  1d21              ADDS     r1,r4,#4              ;1117
000710  2000              MOVS     r0,#0                 ;1117
000712  f7fffffe          BL       STS_UART_AddTxArray
000716  e4dc              B        |L11.210|
;;;1134   
                          ENDP

                  |L11.1816|
                          DCD      verreadFlag
                  |L11.1820|
                          DCD      verwriteFlag
                  |L11.1824|
                          DCD      dutverType
                  |L11.1828|
                          DCD      dutverBuff
                  |L11.1832|
                          DCD      keyValue

                          AREA ||i.CAN_TEST_ConfirmTempCmdFrameBuff||, CODE, READONLY, ALIGN=1

                  CAN_TEST_ConfirmTempCmdFrameBuff PROC
;;;1201   // 将临时缓冲区添加到命令帧缓冲区中，其本质操作是承认临时缓冲区数据有效
;;;1202   BOOL CAN_TEST_ConfirmTempCmdFrameBuff(CAN_TEST_CB *pCB, uint8 sourceSelect)
000000  b510              PUSH     {r4,lr}
;;;1203   {
;;;1204       CAN_PROTOCOL_TEST_FRAME *pCmdFrame = NULL;
;;;1205   
;;;1206       // 参数合法性检验
;;;1207       if (NULL == pCB)
000002  2800              CMP      r0,#0
000004  d026              BEQ      |L12.84|
;;;1208       {
;;;1209           return FALSE;
;;;1210       }
;;;1211   
;;;1212       // 临时缓冲区为空，不予添加
;;;1213       pCmdFrame = &pCB->rx.rxEachNode[sourceSelect].cmdQueue[pCB->rx.rxEachNode[sourceSelect].end];
000006  f6403291          MOV      r2,#0xb91
00000a  4351              MULS     r1,r2,r1
00000c  eb000181          ADD      r1,r0,r1,LSL #2
000010  f5015200          ADD      r2,r1,#0x2000
000014  4613              MOV      r3,r2
000016  f8b20e9a          LDRH     r0,[r2,#0xe9a]
00001a  eb000280          ADD      r2,r0,r0,LSL #2
00001e  eb021240          ADD      r2,r2,r0,LSL #5
000022  eb010282          ADD      r2,r1,r2,LSL #2
;;;1214   
;;;1215       if (0 == pCmdFrame->length)
000026  f8b220e8          LDRH     r2,[r2,#0xe8]
00002a  b1aa              CBZ      r2,|L12.88|
;;;1216       {
;;;1217           return FALSE;
;;;1218       }
;;;1219   
;;;1220       // 添加
;;;1221       pCB->rx.rxEachNode[sourceSelect].end++;
00002c  1c40              ADDS     r0,r0,#1
00002e  b280              UXTH     r0,r0
;;;1222       pCB->rx.rxEachNode[sourceSelect].end %= CAN_TEST_RX_QUEUE_SIZE;
000030  2250              MOVS     r2,#0x50
000032  fbb0f4f2          UDIV     r4,r0,r2
000036  fb020014          MLS      r0,r2,r4,r0
00003a  f8a30e9a          STRH     r0,[r3,#0xe9a]
;;;1223       // 该行的作用是将新的添加位置有效数据个数清零，以便将这个位置当做临时帧缓冲区
;;;1224       pCB->rx.rxEachNode[sourceSelect].cmdQueue[pCB->rx.rxEachNode[sourceSelect].end].length = 0;
00003e  eb000380          ADD      r3,r0,r0,LSL #2
000042  eb031040          ADD      r0,r3,r0,LSL #5
000046  eb010080          ADD      r0,r1,r0,LSL #2
00004a  2200              MOVS     r2,#0
00004c  f8a020e8          STRH     r2,[r0,#0xe8]
;;;1225   
;;;1226       return TRUE;
000050  2001              MOVS     r0,#1
;;;1227   }
000052  bd10              POP      {r4,pc}
                  |L12.84|
000054  2000              MOVS     r0,#0                 ;1209
000056  bd10              POP      {r4,pc}
                  |L12.88|
000058  2000              MOVS     r0,#0                 ;1217
00005a  bd10              POP      {r4,pc}
;;;1228   
                          ENDP


                          AREA ||i.CAN_TEST_DRIVE_AddTxArray||, CODE, READONLY, ALIGN=2

                  CAN_TEST_DRIVE_AddTxArray PROC
;;;1271   // 向发送缓冲区中添加一条待发送序列
;;;1272   BOOL CAN_TEST_DRIVE_AddTxArray(uint32 id, uint8 *pArray, uint8 length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1273   {
;;;1274       uint16 i;
;;;1275       uint16 head = testCanCB.tx.head;
000004  4b24              LDR      r3,|L13.152|
000006  f8b35cdc          LDRH     r5,[r3,#0xcdc]  ; testCanCB
;;;1276       uint16 end = testCanCB.tx.end;
00000a  f8b30cde          LDRH     r0,[r3,#0xcde]  ; testCanCB
;;;1277   
;;;1278       // 参数检验
;;;1279       if ((NULL == pArray) || (0 == length))
00000e  2900              CMP      r1,#0
000010  d00b              BEQ      |L13.42|
000012  b152              CBZ      r2,|L13.42|
;;;1280       {
;;;1281           return FALSE;
;;;1282       }
;;;1283   
;;;1284       // 发送缓冲区已满，不予接收
;;;1285       if ((end + 1) % CAN_TEST_TX_QUEUE_SIZE == head)
000014  1c44              ADDS     r4,r0,#1
000016  2750              MOVS     r7,#0x50
000018  fbb4f6f7          UDIV     r6,r4,r7
00001c  fb074416          MLS      r4,r7,r6,r4
000020  42ac              CMP      r4,r5
000022  d104              BNE      |L13.46|
;;;1286       {
;;;1287           return FALSE;
000024  2000              MOVS     r0,#0
                  |L13.38|
;;;1288       }
;;;1289   
;;;1290   //    testCanCB.tx.cmdQueue[end].deviceID = id;
;;;1291       testCanCB.tx.cmdQueue[end].deviceID = 0x1801FFF4;
;;;1292       
;;;1293       for (i = 0; i < length; i++)
;;;1294       {
;;;1295           testCanCB.tx.cmdQueue[end].buff[i] = *pArray++;
;;;1296       }
;;;1297       testCanCB.tx.cmdQueue[end].length = length;
;;;1298   
;;;1299       // 发送环形队列更新位置
;;;1300       testCanCB.tx.end++;
;;;1301       testCanCB.tx.end %= CAN_TEST_TX_QUEUE_SIZE;
;;;1302       testCanCB.tx.cmdQueue[testCanCB.tx.end].length = 0;
;;;1303   
;;;1304       return TRUE;
;;;1305   }
000026  e8bd81f0          POP      {r4-r8,pc}
                  |L13.42|
00002a  2000              MOVS     r0,#0                 ;1281
00002c  e7fb              B        |L13.38|
                  |L13.46|
00002e  eb000480          ADD      r4,r0,r0,LSL #2       ;1291
000032  f8dfc06c          LDR      r12,|L13.160|
000036  eb041040          ADD      r0,r4,r0,LSL #5       ;1291
00003a  eb0c0480          ADD      r4,r12,r0,LSL #2      ;1291
00003e  f5045600          ADD      r6,r4,#0x2000         ;1291
000042  4d16              LDR      r5,|L13.156|
000044  f8c65e9c          STR      r5,[r6,#0xe9c]        ;1291
000048  2000              MOVS     r0,#0                 ;1293
00004a  e008              B        |L13.94|
                  |L13.76|
00004c  1825              ADDS     r5,r4,r0              ;1295
00004e  f5055500          ADD      r5,r5,#0x2000         ;1295
000052  f8118b01          LDRB     r8,[r1],#1            ;1295
000056  f8858ea0          STRB     r8,[r5,#0xea0]        ;1295
00005a  1c40              ADDS     r0,r0,#1              ;1293
00005c  b280              UXTH     r0,r0                 ;1293
                  |L13.94|
00005e  4290              CMP      r0,r2                 ;1293
000060  d3f4              BCC      |L13.76|
000062  f8a62f2c          STRH     r2,[r6,#0xf2c]        ;1297
000066  f60343de          ADD      r3,r3,#0xcde          ;1300
00006a  8818              LDRH     r0,[r3,#0]            ;1300  ; testCanCB
00006c  1c40              ADDS     r0,r0,#1              ;1300
00006e  8018              STRH     r0,[r3,#0]            ;1300
000070  8818              LDRH     r0,[r3,#0]            ;1301  ; testCanCB
000072  fbb0f1f7          UDIV     r1,r0,r7              ;1301
000076  fb070011          MLS      r0,r7,r1,r0           ;1301
00007a  8018              STRH     r0,[r3,#0]            ;1301
00007c  8818              LDRH     r0,[r3,#0]            ;1302  ; testCanCB
00007e  2100              MOVS     r1,#0                 ;1302
000080  eb000280          ADD      r2,r0,r0,LSL #2       ;1302
000084  eb021040          ADD      r0,r2,r0,LSL #5       ;1302
000088  eb0c0080          ADD      r0,r12,r0,LSL #2      ;1302
00008c  f5005000          ADD      r0,r0,#0x2000         ;1302
000090  f8a01f2c          STRH     r1,[r0,#0xf2c]        ;1302
000094  2001              MOVS     r0,#1                 ;1304
000096  e7c6              B        |L13.38|
;;;1306   
                          ENDP

                  |L13.152|
                          DCD      ||.bss||+0x5000
                  |L13.156|
                          DCD      0x1801fff4
                  |L13.160|
                          DCD      ||.bss||

                          AREA ||i.CAN_TEST_DataStructureInit||, CODE, READONLY, ALIGN=1

                  CAN_TEST_DataStructureInit PROC
;;;140    // 数据结构初始化
;;;141    void CAN_TEST_DataStructureInit(CAN_TEST_CB *pCB)
000000  b530              PUSH     {r4,r5,lr}
;;;142    {
;;;143        uint8 i;
;;;144        uint8 j;
;;;145    
;;;146        // 参数合法性检验
;;;147        if (NULL == pCB)
000002  2800              CMP      r0,#0
000004  d041              BEQ      |L14.138|
;;;148        {
;;;149            return;
;;;150        }
;;;151    
;;;152        pCB->tx.txBusy = FALSE;
000006  f50041a0          ADD      r1,r0,#0x5000
00000a  f60141dc          ADD      r1,r1,#0xcdc
00000e  2400              MOVS     r4,#0
000010  718c              STRB     r4,[r1,#6]
;;;153        pCB->tx.index = 0;
000012  808c              STRH     r4,[r1,#4]
;;;154        pCB->tx.head = 0;
000014  800c              STRH     r4,[r1,#0]
;;;155        pCB->tx.end = 0;
000016  804c              STRH     r4,[r1,#2]
;;;156        for (i = 0; i < CAN_TEST_TX_QUEUE_SIZE; i++)
000018  2100              MOVS     r1,#0
                  |L14.26|
;;;157        {
;;;158            pCB->tx.cmdQueue[i].length = 0;
00001a  eb010281          ADD      r2,r1,r1,LSL #2
00001e  eb021241          ADD      r2,r2,r1,LSL #5
000022  eb000282          ADD      r2,r0,r2,LSL #2
000026  f5025200          ADD      r2,r2,#0x2000
00002a  f8a24f2c          STRH     r4,[r2,#0xf2c]
00002e  1c49              ADDS     r1,r1,#1              ;156
000030  b2c9              UXTB     r1,r1                 ;156
000032  2950              CMP      r1,#0x50              ;156
000034  d3f1              BCC      |L14.26|
;;;159        }
;;;160    
;;;161        for (i = 0; i < CAN_TEST_DEVICE_SOURCE_ID_MAX; i++)
000036  2100              MOVS     r1,#0
                  |L14.56|
;;;162        {
;;;163            pCB->rxFIFO.rxFIFOEachNode[i].head = 0;
000038  222b              MOVS     r2,#0x2b
00003a  434a              MULS     r2,r1,r2
00003c  eb000242          ADD      r2,r0,r2,LSL #1
000040  f8224f50          STRH     r4,[r2,#0x50]!
;;;164            pCB->rxFIFO.rxFIFOEachNode[i].end = 0;
000044  8054              STRH     r4,[r2,#2]
;;;165            pCB->rxFIFO.rxFIFOEachNode[i].currentProcessIndex = 0;
000046  8094              STRH     r4,[r2,#4]
000048  1c49              ADDS     r1,r1,#1              ;161
00004a  b2c9              UXTB     r1,r1                 ;161
00004c  2900              CMP      r1,#0                 ;161
00004e  d0f3              BEQ      |L14.56|
;;;166        }
;;;167    
;;;168        for (i = 0; i < CAN_TEST_DEVICE_SOURCE_ID_MAX; i++)
000050  2200              MOVS     r2,#0
                  |L14.82|
;;;169        {
;;;170            for (j = 0; j < CAN_TEST_RX_QUEUE_SIZE; j++)
000052  2100              MOVS     r1,#0
;;;171            {
;;;172                pCB->rx.rxEachNode[i].cmdQueue[j].length = 0;
000054  f6403391          MOV      r3,#0xb91
000058  4353              MULS     r3,r2,r3
00005a  eb000383          ADD      r3,r0,r3,LSL #2
                  |L14.94|
00005e  eb010581          ADD      r5,r1,r1,LSL #2
000062  eb051541          ADD      r5,r5,r1,LSL #5
000066  eb030585          ADD      r5,r3,r5,LSL #2
00006a  f8a540e8          STRH     r4,[r5,#0xe8]
00006e  1c49              ADDS     r1,r1,#1              ;170
000070  b2c9              UXTB     r1,r1                 ;170
000072  2950              CMP      r1,#0x50              ;170
000074  d3f3              BCC      |L14.94|
;;;173            }
;;;174            pCB->rx.rxEachNode[i].head = 0;
000076  f5035300          ADD      r3,r3,#0x2000
00007a  f8a34e98          STRH     r4,[r3,#0xe98]
;;;175            pCB->rx.rxEachNode[i].end = 0;
00007e  f8a34e9a          STRH     r4,[r3,#0xe9a]
000082  1c52              ADDS     r2,r2,#1              ;168
000084  b2d2              UXTB     r2,r2                 ;168
000086  2a00              CMP      r2,#0                 ;168
000088  d0e3              BEQ      |L14.82|
                  |L14.138|
;;;176        }
;;;177    }
00008a  bd30              POP      {r4,r5,pc}
;;;178    
                          ENDP


                          AREA ||i.CAN_TEST_HW_Init||, CODE, READONLY, ALIGN=2

                  CAN_TEST_HW_Init PROC
;;;1360   // 功能函数：CAN初始化
;;;1361   void CAN_TEST_HW_Init(uint16 bund)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1362   {
000002  b089              SUB      sp,sp,#0x24
000004  4605              MOV      r5,r0
;;;1363       can_parameter_struct can_parameter;
;;;1364       can_filter_parameter_struct can_filter;
;;;1365   
;;;1366       // 时钟分配与使能
;;;1367       rcu_periph_clock_enable(RCU_CAN0);
000006  f2407019          MOV      r0,#0x719
00000a  f7fffffe          BL       rcu_periph_clock_enable
;;;1368       rcu_periph_clock_enable(RCU_GPIOB);
00000e  f2406003          MOV      r0,#0x603
000012  f7fffffe          BL       rcu_periph_clock_enable
;;;1369   //  rcu_periph_clock_enable(RCU_GPIOA); // 后加
;;;1370       rcu_periph_clock_enable(RCU_AF);
000016  f44f60c0          MOV      r0,#0x600
00001a  f7fffffe          BL       rcu_periph_clock_enable
;;;1371   
;;;1372       // 配置CAN的接收中断
;;;1373       nvic_irq_enable(USBD_LP_CAN0_RX0_IRQn, 1, 0);
00001e  2200              MOVS     r2,#0
000020  2101              MOVS     r1,#1
000022  2014              MOVS     r0,#0x14
000024  f7fffffe          BL       nvic_irq_enable
;;;1374   
;;;1375       // 配置CAN邮箱空中断
;;;1376       nvic_irq_enable(USBD_HP_CAN0_TX_IRQn, 2, 0);
000028  2200              MOVS     r2,#0
00002a  2102              MOVS     r1,#2
00002c  2013              MOVS     r0,#0x13
00002e  f7fffffe          BL       nvic_irq_enable
;;;1377   
;;;1378       // CAN管脚重映射到PB8-9
;;;1379       gpio_pin_remap_config(GPIO_CAN_PARTIAL_REMAP, ENABLE);
000032  2101              MOVS     r1,#1
000034  f44f10ea          MOV      r0,#0x1d4000
000038  f7fffffe          BL       gpio_pin_remap_config
;;;1380   
;;;1381       /* configure CAN0 GPIO */
;;;1382       gpio_init(GPIOB, GPIO_MODE_IPU, GPIO_OSPEED_50MHZ, GPIO_PIN_8);
00003c  4c32              LDR      r4,|L15.264|
00003e  f44f7380          MOV      r3,#0x100
000042  2203              MOVS     r2,#3
000044  2148              MOVS     r1,#0x48
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       gpio_init
;;;1383       gpio_init(GPIOB, GPIO_MODE_AF_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_9);
00004c  1563              ASRS     r3,r4,#21
00004e  2203              MOVS     r2,#3
000050  2118              MOVS     r1,#0x18
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       gpio_init
;;;1384   
;;;1385       can_struct_para_init(CAN_INIT_STRUCT, &can_parameter);
000058  a906              ADD      r1,sp,#0x18
00005a  2000              MOVS     r0,#0
00005c  f7fffffe          BL       can_struct_para_init
;;;1386       can_struct_para_init(CAN_INIT_STRUCT, &can_filter);
000060  a901              ADD      r1,sp,#4
000062  2000              MOVS     r0,#0
000064  f7fffffe          BL       can_struct_para_init
;;;1387   
;;;1388       /* initialize CAN register */
;;;1389       can_deinit(CAN0);
000068  4f28              LDR      r7,|L15.268|
00006a  4638              MOV      r0,r7
00006c  f7fffffe          BL       can_deinit
;;;1390   
;;;1391       /* initialize CAN parameters */
;;;1392       can_parameter.time_triggered = DISABLE;
000070  2400              MOVS     r4,#0
000072  f88d401c          STRB     r4,[sp,#0x1c]
;;;1393       can_parameter.auto_bus_off_recovery = ENABLE;
000076  2601              MOVS     r6,#1
000078  f88d601d          STRB     r6,[sp,#0x1d]
;;;1394       can_parameter.auto_wake_up = DISABLE;
00007c  f88d401e          STRB     r4,[sp,#0x1e]
;;;1395       can_parameter.no_auto_retrans = DISABLE;
000080  f88d401f          STRB     r4,[sp,#0x1f]
;;;1396       can_parameter.rec_fifo_overwrite = DISABLE;
000084  f88d4020          STRB     r4,[sp,#0x20]
;;;1397       can_parameter.trans_fifo_order = DISABLE;
000088  f88d4021          STRB     r4,[sp,#0x21]
;;;1398       can_parameter.working_mode = CAN_NORMAL_MODE;
00008c  f88d4018          STRB     r4,[sp,#0x18]
;;;1399   
;;;1400       // 波特率计算：36MHz / (1+6+1) / 36 = 125K bit
;;;1401       can_parameter.resync_jump_width = CAN_BT_SJW_1TQ;
000090  f88d4019          STRB     r4,[sp,#0x19]
;;;1402       can_parameter.time_segment_1 = CAN_BT_BS1_6TQ;// 6
000094  2005              MOVS     r0,#5
000096  f88d001a          STRB     r0,[sp,#0x1a]
;;;1403       can_parameter.time_segment_2 = CAN_BT_BS2_1TQ;// 1
00009a  f88d401b          STRB     r4,[sp,#0x1b]
;;;1404       
;;;1405       if (CAN_BAUD_RATE_125K == bund)
;;;1406       {
;;;1407           can_parameter.prescaler = 36;
00009e  2024              MOVS     r0,#0x24
0000a0  2d7d              CMP      r5,#0x7d              ;1405
0000a2  d025              BEQ      |L15.240|
;;;1408       }
;;;1409       else if (CAN_BAUD_RATE_250K == bund)
0000a4  2dfa              CMP      r5,#0xfa
0000a6  d026              BEQ      |L15.246|
;;;1410       {
;;;1411           can_parameter.prescaler = 18;
;;;1412       }
;;;1413       else if (CAN_BAUD_RATE_500K == bund)
0000a8  f5b57ffa          CMP      r5,#0x1f4
0000ac  d027              BEQ      |L15.254|
;;;1414       {
;;;1415           can_parameter.prescaler = 9;
;;;1416       }
;;;1417       else
;;;1418       {
;;;1419           can_parameter.prescaler = 36;
0000ae  f8ad0022          STRH     r0,[sp,#0x22]
                  |L15.178|
;;;1420       }
;;;1421   
;;;1422       /* initialize CAN */
;;;1423       can_init(CAN0, &can_parameter);
0000b2  a906              ADD      r1,sp,#0x18
0000b4  4638              MOV      r0,r7
0000b6  f7fffffe          BL       can_init
;;;1424   
;;;1425       /* initialize filter */
;;;1426       can_filter.filter_number = 1;
0000ba  f8ad600e          STRH     r6,[sp,#0xe]
;;;1427       can_filter.filter_mode = CAN_FILTERMODE_MASK;
0000be  f8ad4010          STRH     r4,[sp,#0x10]
;;;1428       can_filter.filter_bits = CAN_FILTERBITS_32BIT;
0000c2  f8ad6012          STRH     r6,[sp,#0x12]
;;;1429       can_filter.filter_list_high = 0x0000;
0000c6  f8ad4004          STRH     r4,[sp,#4]
;;;1430       can_filter.filter_list_low = 0x0000;
0000ca  f8ad4006          STRH     r4,[sp,#6]
;;;1431       can_filter.filter_mask_high = 0x0000;
0000ce  f8ad4008          STRH     r4,[sp,#8]
;;;1432       can_filter.filter_mask_low = 0x0000;
0000d2  f8ad400a          STRH     r4,[sp,#0xa]
;;;1433       can_filter.filter_fifo_number = CAN_FIFO0;
0000d6  f8ad400c          STRH     r4,[sp,#0xc]
;;;1434       can_filter.filter_enable = ENABLE;
0000da  f88d6014          STRB     r6,[sp,#0x14]
;;;1435   
;;;1436       can_filter_init(&can_filter);
0000de  a801              ADD      r0,sp,#4
0000e0  f7fffffe          BL       can_filter_init
;;;1437   
;;;1438       /* enable can receive FIFO0 not empty interrupt */
;;;1439       can_interrupt_enable(CAN0, CAN_INT_RFNE0);
0000e4  2102              MOVS     r1,#2
0000e6  4638              MOV      r0,r7
0000e8  f7fffffe          BL       can_interrupt_enable
;;;1440   }
0000ec  b009              ADD      sp,sp,#0x24
0000ee  bdf0              POP      {r4-r7,pc}
                  |L15.240|
0000f0  f8ad0022          STRH     r0,[sp,#0x22]         ;1407
0000f4  e7dd              B        |L15.178|
                  |L15.246|
0000f6  2012              MOVS     r0,#0x12              ;1411
0000f8  f8ad0022          STRH     r0,[sp,#0x22]         ;1411
0000fc  e7d9              B        |L15.178|
                  |L15.254|
0000fe  2009              MOVS     r0,#9                 ;1415
000100  f8ad0022          STRH     r0,[sp,#0x22]         ;1415
000104  e7d5              B        |L15.178|
;;;1441   
                          ENDP

000106  0000              DCW      0x0000
                  |L15.264|
                          DCD      0x40010c00
                  |L15.268|
                          DCD      0x40006400

                          AREA ||i.CAN_TEST_MacProcess||, CODE, READONLY, ALIGN=2

                  CAN_TEST_MacProcess PROC
;;;395    // CAN 报文接收处理函数(注意根据具体模块修改)
;;;396    void CAN_TEST_MacProcess(uint16 standarID, uint8 *data, uint8 length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;397    {
;;;398        uint16 end;
;;;399        uint16 head;
;;;400        uint8 i;
;;;401        int8 sourceBuffSelect = 0; // 节点缓存区编号选择
000004  2600              MOVS     r6,#0
;;;402    
;;;403        // 参数合法性判断
;;;404        if (NULL == data)
000006  2900              CMP      r1,#0
000008  d02a              BEQ      |L16.96|
;;;405        {
;;;406            return;
;;;407        }
;;;408    
;;;409        // 标准帧判断
;;;410    //    if (standarID > 0x7FF)
;;;411    //    {
;;;412    //        return;
;;;413    //    }
;;;414    
;;;415        // 取出目标节点
;;;416        //  destinationID = standarID & 0x07FF;
;;;417    
;;;418        // 不是发给自身ID的数据直接丢掉
;;;419        //  if (CAN_TEST_DEVICE_ID_HMI != destinationID)
;;;420        //  {
;;;421        //      return;
;;;422        //  }
;;;423    
;;;424        // 已经使能
;;;425    //    if (CAN_TEST_RX_DEVICE_PUC)
;;;426    //    {
;;;427    //        sourceBuffSelect = CAN_TEST_RX_DEVICE_PUC - 1;
;;;428    //    }
;;;429    
;;;430    //    // 没有合适的源节点
;;;431    //    if ((sourceBuffSelect >= CAN_TEST_DEVICE_SOURCE_ID_MAX) || (sourceBuffSelect < 0))
;;;432    //    {
;;;433    //        return;
;;;434    //    }
;;;435    
;;;436        // 取相应缓存区结构体数据
;;;437        end = testCanCB.rxFIFO.rxFIFOEachNode[sourceBuffSelect].end;
00000a  f8dfc058          LDR      r12,|L16.100|
00000e  f8bc0052          LDRH     r0,[r12,#0x52]
;;;438        head = testCanCB.rxFIFO.rxFIFOEachNode[sourceBuffSelect].head;
000012  f8bc7050          LDRH     r7,[r12,#0x50]
;;;439    
;;;440        // ■■环形列队，入队■■
;;;441        //  一级缓冲区已满，不予接收
;;;442    //    if ((end + 1) % CAN_TEST_RX_FIFO_SIZE == head)
;;;443    //    {
;;;444    //        return;
;;;445    //    }
;;;446    
;;;447        for (i = 0; i < length; i++)
000016  2300              MOVS     r3,#0
;;;448        {
;;;449            // 单个字节读取，并放入FIFO中
;;;450            testCanCB.rxFIFO.rxFIFOEachNode[sourceBuffSelect].buff[testCanCB.rxFIFO.rxFIFOEachNode[sourceBuffSelect].end] = *data++;
;;;451    
;;;452            testCanCB.rxFIFO.rxFIFOEachNode[sourceBuffSelect].end++;
;;;453    
;;;454            // 一级缓冲区已满，不予接收
;;;455            if ((testCanCB.rxFIFO.rxFIFOEachNode[sourceBuffSelect].end + 1) % CAN_TEST_RX_FIFO_SIZE == head)
000018  2450              MOVS     r4,#0x50
00001a  e01f              B        |L16.92|
                  |L16.28|
00001c  202b              MOVS     r0,#0x2b              ;450
00001e  4370              MULS     r0,r6,r0              ;450
000020  eb0c0040          ADD      r0,r12,r0,LSL #1      ;450
000024  f8115b01          LDRB     r5,[r1],#1            ;450
000028  f8b08052          LDRH     r8,[r0,#0x52]         ;450
00002c  f8085000          STRB     r5,[r8,r0]            ;450
000030  f8305f52          LDRH     r5,[r0,#0x52]!        ;452
000034  1c6d              ADDS     r5,r5,#1              ;452
000036  8005              STRH     r5,[r0,#0]            ;452
000038  f8305952          LDRH     r5,[r0],#-0x52
00003c  1c6d              ADDS     r5,r5,#1
00003e  fbb5f8f4          UDIV     r8,r5,r4
000042  fb045518          MLS      r5,r4,r8,r5
000046  42bd              CMP      r5,r7
000048  d00a              BEQ      |L16.96|
;;;456            {
;;;457                break;
;;;458            }
;;;459    
;;;460            testCanCB.rxFIFO.rxFIFOEachNode[sourceBuffSelect].end %= CAN_TEST_RX_FIFO_SIZE;
00004a  f8305f52          LDRH     r5,[r0,#0x52]!
00004e  fbb5f8f4          UDIV     r8,r5,r4
000052  fb045518          MLS      r5,r4,r8,r5
000056  8005              STRH     r5,[r0,#0]
000058  1c5b              ADDS     r3,r3,#1              ;447
00005a  b2db              UXTB     r3,r3                 ;447
                  |L16.92|
00005c  4293              CMP      r3,r2                 ;447
00005e  d3dd              BCC      |L16.28|
                  |L16.96|
;;;461        }
;;;462    }
000060  e8bd81f0          POP      {r4-r8,pc}
;;;463    
                          ENDP

                  |L16.100|
                          DCD      ||.bss||

                          AREA ||i.CAN_TEST_RxFIFOProcess||, CODE, READONLY, ALIGN=1

                  CAN_TEST_RxFIFOProcess PROC
;;;464    // 一级报文接收缓冲区处理，从一级接收缓冲区中取出一个字节添加到命令帧缓冲区中
;;;465    void CAN_TEST_RxFIFOProcess(CAN_TEST_CB *pCB)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;466    {
000004  4604              MOV      r4,r0
;;;467        uint16 end;
;;;468        uint16 head;
;;;469        CAN_PROTOCOL_TEST_FRAME *pCmdFrame = NULL;
;;;470        CAN_TEST_RX_FIFO *pRxFIFO = NULL;
;;;471        uint16 length = 0;
;;;472        uint8 currentData = 0;
;;;473        uint8 sourceBuffSelect = 0;
000006  f04f0800          MOV      r8,#0
;;;474    
;;;475        // 参数合法性检验
;;;476        if (NULL == pCB)
00000a  2c00              CMP      r4,#0
00000c  d027              BEQ      |L17.94|
;;;477        {
;;;478            return;
;;;479        }
;;;480    
;;;481        // 循环判断是否有数据需要处理
;;;482    //    for (sourceBuffSelect = 0; sourceBuffSelect < CAN_TEST_DEVICE_SOURCE_ID_MAX; sourceBuffSelect++)
;;;483    //    {
;;;484            // 获取接收一级缓冲区节点临时缓冲区指针
;;;485            pRxFIFO = &pCB->rxFIFO.rxFIFOEachNode[sourceBuffSelect];
00000e  2700              MOVS     r7,#0
;;;486    
;;;487            end = pRxFIFO->end;
000010  f8b42052          LDRH     r2,[r4,#0x52]
;;;488            head = pRxFIFO->head;
000014  f8b40050          LDRH     r0,[r4,#0x50]
;;;489    
;;;490            // 一级缓冲区为空，继续
;;;491            if (head == end)
000018  4290              CMP      r0,r2
00001a  d020              BEQ      |L17.94|
;;;492            {
;;;493                return;
;;;494            }
;;;495    
;;;496            // 获取接收命令临时缓冲区指针
;;;497            pCmdFrame = &pCB->rx.rxEachNode[sourceBuffSelect].cmdQueue[pCB->rx.rxEachNode[sourceBuffSelect].end];
00001c  f5045000          ADD      r0,r4,#0x2000
000020  4684              MOV      r12,r0
000022  f8b00e9a          LDRH     r0,[r0,#0xe9a]
000026  eb000380          ADD      r3,r0,r0,LSL #2
00002a  eb031340          ADD      r3,r3,r0,LSL #5
00002e  eb040583          ADD      r5,r4,r3,LSL #2
000032  3558              ADDS     r5,r5,#0x58
;;;498    
;;;499            // 取出当前要处理的字节
;;;500            currentData = pRxFIFO->buff[pRxFIFO->currentProcessIndex];
000034  f8b43054          LDRH     r3,[r4,#0x54]
000038  5ce1              LDRB     r1,[r4,r3]
;;;501    
;;;502            // 临时缓冲区长度为0时，搜索首字节
;;;503            if (0 == pCmdFrame->length)
00003a  f8b53090          LDRH     r3,[r5,#0x90]
;;;504            {
;;;505                // 命令头错误，删除当前字节并退出
;;;506                if (CAN_PROTOCOL_TEST_HEAD != currentData)
;;;507                {
;;;508                    pRxFIFO->head++;
;;;509                    pRxFIFO->head %= CAN_TEST_RX_FIFO_SIZE;
00003e  2650              MOVS     r6,#0x50
000040  b17b              CBZ      r3,|L17.98|
;;;510                    pRxFIFO->currentProcessIndex = pRxFIFO->head;
;;;511    
;;;512                    return;
;;;513                }
;;;514    
;;;515                // 命令头正确，但无命令临时缓冲区可用，退出
;;;516                if ((pCB->rx.rxEachNode[sourceBuffSelect].end + 1) % CAN_TEST_RX_QUEUE_SIZE == pCB->rx.rxEachNode[sourceBuffSelect].head)
;;;517                {
;;;518                    return;
;;;519                }
;;;520    
;;;521                // 命令头正确，有临时缓冲区可用，则将其添加到命令帧临时缓冲区中
;;;522                pCmdFrame->buff[pCmdFrame->length++] = currentData;
;;;523                pRxFIFO->currentProcessIndex++;
;;;524                pRxFIFO->currentProcessIndex %= CAN_TEST_RX_FIFO_SIZE;
;;;525            }
;;;526            // 非首字节，将数据添加到命令帧临时缓冲区中，但暂不删除当前数据
;;;527            else
;;;528            {
;;;529                // 临时缓冲区溢出，说明当前正在接收的命令帧是错误的，正确的命令帧不会出现长度溢出的情况
;;;530                if (pCmdFrame->length >= CAN_PROTOCOL_TEST_FRAME_LENGTH_MAX)
000042  2b8c              CMP      r3,#0x8c
000044  d37e              BCC      |L17.324|
;;;531                {
;;;532                    // 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;533                    pRxFIFO->head++;
000046  f8340f50          LDRH     r0,[r4,#0x50]!
00004a  1c40              ADDS     r0,r0,#1
00004c  8020              STRH     r0,[r4,#0]
;;;534                    pRxFIFO->head %= CAN_TEST_RX_FIFO_SIZE;
00004e  8820              LDRH     r0,[r4,#0]
000050  fbb0f1f6          UDIV     r1,r0,r6
000054  fb060011          MLS      r0,r6,r1,r0
000058  8020              STRH     r0,[r4,#0]
;;;535                    pRxFIFO->currentProcessIndex = pRxFIFO->head;
00005a  8820              LDRH     r0,[r4,#0]
00005c  80a0              STRH     r0,[r4,#4]
                  |L17.94|
;;;536    
;;;537                    return;
;;;538                }
;;;539    
;;;540                // 一直取到末尾
;;;541                while (end != pRxFIFO->currentProcessIndex)
;;;542                {
;;;543                    // 取出当前要处理的字节
;;;544                    currentData = pRxFIFO->buff[pRxFIFO->currentProcessIndex];
;;;545    
;;;546                    // 缓冲区未溢出，正常接收，将数据添加到临时缓冲区中
;;;547                    pCmdFrame->buff[pCmdFrame->length++] = currentData;
;;;548                    pRxFIFO->currentProcessIndex++;
;;;549                    pRxFIFO->currentProcessIndex %= CAN_TEST_RX_FIFO_SIZE;
;;;550    
;;;551                    // ■■接下来，需要检查命令帧是否完整，如果完整，则将命令帧临时缓冲区扶正■■
;;;552    
;;;553                    // 首先判断命令帧最小长度，一个完整的命令字至少包括4个字节: 命令头(1Byte)+命令字(1Byte)+数据长度(1Byte)+校验码(1Byte) ，因此不足4个字节的必定不完整
;;;554                    if (pCmdFrame->length < CAN_PROTOCOL_TEST_FRAME_LENGTH_MIN)
;;;555                    {
;;;556                        // 继续接收
;;;557                        continue;
;;;558                    }
;;;559    
;;;560                    // 命令帧长度数值越界，说明当前命令帧错误，停止接收
;;;561                    if (pCmdFrame->buff[CAN_PROTOCOL_TEST_LENGTH_INDEX] > (CAN_PROTOCOL_TEST_FRAME_LENGTH_MAX - CAN_PROTOCOL_TEST_FRAME_LENGTH_MIN))
;;;562                    {
;;;563                        // 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;564                        pCmdFrame->length = 0;
;;;565    
;;;566                        // 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;567                        pRxFIFO->head++;
;;;568                        pRxFIFO->head %= CAN_TEST_RX_FIFO_SIZE;
;;;569                        pRxFIFO->currentProcessIndex = pRxFIFO->head;
;;;570    
;;;571                        break;
;;;572                    }
;;;573    
;;;574                    // 命令帧长度校验，在命令长度描述字的数值上，增加命令头、命令字、...、数据长度、校验码，即为命令帧实际长度
;;;575                    length = pCmdFrame->length;
;;;576                    if (length < (pCmdFrame->buff[CAN_PROTOCOL_TEST_LENGTH_INDEX] + CAN_PROTOCOL_TEST_FRAME_LENGTH_MIN))
;;;577                    {
;;;578                        // 长度要求不一致，说明未接收完毕，继续
;;;579                        continue;
;;;580                    }
;;;581    
;;;582                    // 命令帧长度OK，则进行校验，失败时删除命令头
;;;583                    if (!CAN_TEST_CheckSum(pCmdFrame->buff, pCmdFrame->length))
;;;584                    {
;;;585                        // 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;586                        pCmdFrame->length = 0;
;;;587    
;;;588                        // 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;589                        pRxFIFO->head++;
;;;590                        pRxFIFO->head %= CAN_TEST_RX_FIFO_SIZE;
;;;591                        pRxFIFO->currentProcessIndex = pRxFIFO->head;
;;;592    
;;;593                        break;
;;;594                    }
;;;595    
;;;596                    // 执行到这里，即说明接收到了一个完整并且正确的命令帧，此时需将处理过的数据从一级缓冲区中删除，并将该命令帧扶正
;;;597                    pRxFIFO->head += length;
;;;598                    pRxFIFO->head %= CAN_TEST_RX_FIFO_SIZE;
;;;599                    pRxFIFO->currentProcessIndex = pRxFIFO->head;
;;;600    
;;;601                    CAN_TEST_ConfirmTempCmdFrameBuff(pCB, sourceBuffSelect);
;;;602                    break;
;;;603                }
;;;604            }
;;;605    //    }
;;;606        return;
;;;607    }
00005e  e8bd83f0          POP      {r4-r9,pc}
                  |L17.98|
000062  2955              CMP      r1,#0x55              ;506
000064  d00c              BEQ      |L17.128|
000066  f8340f50          LDRH     r0,[r4,#0x50]!        ;508
00006a  1c40              ADDS     r0,r0,#1              ;508
00006c  8020              STRH     r0,[r4,#0]            ;508
00006e  8820              LDRH     r0,[r4,#0]            ;509
000070  fbb0f1f6          UDIV     r1,r0,r6              ;509
000074  fb060011          MLS      r0,r6,r1,r0           ;509
000078  8020              STRH     r0,[r4,#0]            ;509
00007a  8820              LDRH     r0,[r4,#0]            ;510
00007c  80a0              STRH     r0,[r4,#4]            ;510
00007e  e7ee              B        |L17.94|
                  |L17.128|
000080  1c40              ADDS     r0,r0,#1              ;516
000082  fbb0f2f6          UDIV     r2,r0,r6              ;516
000086  fb060012          MLS      r0,r6,r2,r0           ;516
00008a  f8bc2e98          LDRH     r2,[r12,#0xe98]       ;516
00008e  4290              CMP      r0,r2                 ;516
000090  d0e5              BEQ      |L17.94|
000092  2001              MOVS     r0,#1                 ;522
000094  f8a50090          STRH     r0,[r5,#0x90]         ;522
000098  7129              STRB     r1,[r5,#4]            ;522
00009a  f8340f54          LDRH     r0,[r4,#0x54]!        ;523
00009e  1c40              ADDS     r0,r0,#1              ;523
0000a0  b280              UXTH     r0,r0                 ;523
0000a2  fbb0f1f6          UDIV     r1,r0,r6              ;524
0000a6  fb060011          MLS      r0,r6,r1,r0           ;524
0000aa  8020              STRH     r0,[r4,#0]            ;524
0000ac  e7d7              B        |L17.94|
                  |L17.174|
0000ae  5c21              LDRB     r1,[r4,r0]            ;544
0000b0  f8b50090          LDRH     r0,[r5,#0x90]         ;547
0000b4  1c43              ADDS     r3,r0,#1              ;547
0000b6  4428              ADD      r0,r0,r5              ;547
0000b8  f8a53090          STRH     r3,[r5,#0x90]         ;547
0000bc  7101              STRB     r1,[r0,#4]            ;547
0000be  f8b40054          LDRH     r0,[r4,#0x54]         ;548
0000c2  1c40              ADDS     r0,r0,#1              ;548
0000c4  b280              UXTH     r0,r0                 ;548
0000c6  fbb0f1f6          UDIV     r1,r0,r6              ;549
0000ca  fb060111          MLS      r1,r6,r1,r0           ;549
0000ce  f8a41054          STRH     r1,[r4,#0x54]         ;549
0000d2  f8b51090          LDRH     r1,[r5,#0x90]         ;554
0000d6  2904              CMP      r1,#4                 ;554
0000d8  d342              BCC      |L17.352|
0000da  79a8              LDRB     r0,[r5,#6]            ;561
0000dc  2888              CMP      r0,#0x88              ;561
0000de  d90e              BLS      |L17.254|
0000e0  f8a57090          STRH     r7,[r5,#0x90]         ;564
0000e4  f8340f50          LDRH     r0,[r4,#0x50]!        ;567
0000e8  1c40              ADDS     r0,r0,#1              ;567
0000ea  8020              STRH     r0,[r4,#0]            ;567
0000ec  8820              LDRH     r0,[r4,#0]            ;568
0000ee  fbb0f1f6          UDIV     r1,r0,r6              ;568
0000f2  fb060011          MLS      r0,r6,r1,r0           ;568
0000f6  8020              STRH     r0,[r4,#0]            ;568
0000f8  8820              LDRH     r0,[r4,#0]            ;569
0000fa  80a0              STRH     r0,[r4,#4]            ;569
0000fc  e7af              B        |L17.94|
                  |L17.254|
0000fe  4689              MOV      r9,r1                 ;575
000100  1d00              ADDS     r0,r0,#4              ;576
000102  4649              MOV      r1,r9                 ;576
000104  4288              CMP      r0,r1                 ;576
000106  d82b              BHI      |L17.352|
000108  1d28              ADDS     r0,r5,#4              ;583
00010a  f7fffffe          BL       CAN_TEST_CheckSum
00010e  b1b0              CBZ      r0,|L17.318|
000110  f8b40050          LDRH     r0,[r4,#0x50]         ;597
000114  4448              ADD      r0,r0,r9              ;597
000116  f8a40050          STRH     r0,[r4,#0x50]         ;597
00011a  f8b40050          LDRH     r0,[r4,#0x50]         ;598
00011e  fbb0f1f6          UDIV     r1,r0,r6              ;598
000122  fb060111          MLS      r1,r6,r1,r0           ;598
000126  f8a41050          STRH     r1,[r4,#0x50]         ;598
00012a  f8b41050          LDRH     r1,[r4,#0x50]         ;599
00012e  f8a41054          STRH     r1,[r4,#0x54]         ;599
000132  4641              MOV      r1,r8                 ;601
000134  4620              MOV      r0,r4                 ;601
000136  e8bd43f0          POP      {r4-r9,lr}            ;601
00013a  f7ffbffe          B.W      CAN_TEST_ConfirmTempCmdFrameBuff
                  |L17.318|
00013e  f8a57090          STRH     r7,[r5,#0x90]         ;586
000142  e000              B        |L17.326|
                  |L17.324|
000144  e00c              B        |L17.352|
                  |L17.326|
000146  f8340f50          LDRH     r0,[r4,#0x50]!        ;589
00014a  1c40              ADDS     r0,r0,#1              ;589
00014c  8020              STRH     r0,[r4,#0]            ;589
00014e  8820              LDRH     r0,[r4,#0]            ;590
000150  fbb0f1f6          UDIV     r1,r0,r6              ;590
000154  fb060011          MLS      r0,r6,r1,r0           ;590
000158  8020              STRH     r0,[r4,#0]            ;590
00015a  8820              LDRH     r0,[r4,#0]            ;591
00015c  80a0              STRH     r0,[r4,#4]            ;591
00015e  e77e              B        |L17.94|
                  |L17.352|
000160  f8b40054          LDRH     r0,[r4,#0x54]         ;541
000164  4290              CMP      r0,r2                 ;541
000166  d1a2              BNE      |L17.174|
000168  e779              B        |L17.94|
;;;608    
                          ENDP


                          AREA ||i.CAN_TEST_TxEnterState||, CODE, READONLY, ALIGN=2

                  CAN_TEST_TxEnterState PROC
;;;1235   // CANTX状态迁移函数
;;;1236   void CAN_TEST_TxEnterState(uint32 state)
000000  4902              LDR      r1,|L18.12|
;;;1237   {
;;;1238       // 让当前的状态成为历史
;;;1239       canTestTxStateCB.preState = canTestTxStateCB.state;
000002  780a              LDRB     r2,[r1,#0]  ; canTestTxStateCB
000004  704a              STRB     r2,[r1,#1]
;;;1240   
;;;1241       // 设置新的状态
;;;1242       canTestTxStateCB.state = (CAN_TEST_TX_STATE_E)state;
000006  7008              STRB     r0,[r1,#0]
;;;1243   
;;;1244       switch (state)
;;;1245       {
;;;1246           // ■■状态的入口处理■■
;;;1247           case CAN_TEST_TX_STATE_NULL:
;;;1248   
;;;1249               break;
;;;1250   
;;;1251           // ■■入口状态的入口处理■■
;;;1252           case CAN_TEST_TX_STATE_ENTRY:
;;;1253   
;;;1254               break;
;;;1255   
;;;1256           // ■■待机状态状态的入口处理■■
;;;1257           case CAN_TEST_TX_STATE_STANDBY:
;;;1258   
;;;1259               break;
;;;1260   
;;;1261           // ■■CAN消息发送中■■
;;;1262           case CAN_TEST_TX_STATE_SENDING:
;;;1263   
;;;1264               break;
;;;1265   
;;;1266           default:
;;;1267               break;
;;;1268       }
;;;1269   }
000008  4770              BX       lr
;;;1270   
                          ENDP

00000a  0000              DCW      0x0000
                  |L18.12|
                          DCD      ||.data||+0x6

                          AREA ||i.CAN_TEST_TxStateInit||, CODE, READONLY, ALIGN=1

                  CAN_TEST_TxStateInit PROC
;;;1229   // CANTX状态机初始化
;;;1230   void CAN_TEST_TxStateInit(void)
000000  2002              MOVS     r0,#2
;;;1231   {
;;;1232       CAN_TEST_TxEnterState(CAN_TEST_TX_STATE_STANDBY);
000002  f7ffbffe          B.W      CAN_TEST_TxEnterState
;;;1233   }
;;;1234   
                          ENDP


                          AREA ||i.CAN_TEST_TxStateProcess||, CODE, READONLY, ALIGN=2

                  CAN_TEST_TxStateProcess PROC
;;;1307   // CANTX过程处理函数
;;;1308   void CAN_TEST_TxStateProcess(void)
000000  b510              PUSH     {r4,lr}
;;;1309   {
;;;1310       uint16 head = testCanCB.tx.head;
000002  480f              LDR      r0,|L20.64|
000004  f8b01cdc          LDRH     r1,[r0,#0xcdc]  ; testCanCB
;;;1311       uint16 end = testCanCB.tx.end;
000008  f8b02cde          LDRH     r2,[r0,#0xcde]  ; testCanCB
;;;1312   
;;;1313       switch (canTestTxStateCB.state)
00000c  480d              LDR      r0,|L20.68|
00000e  7800              LDRB     r0,[r0,#0]  ; canTestTxStateCB
000010  2800              CMP      r0,#0
000012  d013              BEQ      |L20.60|
000014  2801              CMP      r0,#1
000016  d011              BEQ      |L20.60|
000018  2802              CMP      r0,#2
00001a  d10f              BNE      |L20.60|
;;;1314       {
;;;1315           // ■■状态的入口处理■■
;;;1316           case CAN_TEST_TX_STATE_NULL:
;;;1317   
;;;1318               break;
;;;1319   
;;;1320           // ■■入口状态的入口处理■■
;;;1321           case CAN_TEST_TX_STATE_ENTRY:
;;;1322   
;;;1323               break;
;;;1324   
;;;1325           // ■■待机状态状态的入口处理■■
;;;1326           case CAN_TEST_TX_STATE_STANDBY:
;;;1327           
;;;1328               // 检测是否有Tx请求
;;;1329               if (head != end)
00001c  4291              CMP      r1,r2
00001e  d00d              BEQ      |L20.60|
;;;1330               {
;;;1331                   // 调用此函数填充与启动发送can消息
;;;1332                   if (CAN_TEST_Tx_FillAndSend(&testCanCB))
000020  4809              LDR      r0,|L20.72|
000022  f7fffffe          BL       CAN_TEST_Tx_FillAndSend
000026  b120              CBZ      r0,|L20.50|
;;;1333                   {
;;;1334                       // 进入CAN消息发送中状态
;;;1335                       CAN_TEST_TxEnterState(CAN_TEST_TX_STATE_SENDING);
000028  e8bd4010          POP      {r4,lr}
00002c  2004              MOVS     r0,#4
00002e  f7ffbffe          B.W      CAN_TEST_TxEnterState
                  |L20.50|
;;;1336                   }
;;;1337                   else
;;;1338                   {
;;;1339                       // 进入CAN消息发送待机状态
;;;1340                       CAN_TEST_TxEnterState(CAN_TEST_TX_STATE_STANDBY);
000032  e8bd4010          POP      {r4,lr}
000036  2002              MOVS     r0,#2
000038  f7ffbffe          B.W      CAN_TEST_TxEnterState
                  |L20.60|
;;;1341                   }
;;;1342               }
;;;1343               else
;;;1344               {
;;;1345                   // 否则什么也不处理
;;;1346               }
;;;1347   
;;;1348               break;
;;;1349   
;;;1350           // ■■CAN消息发送中■■
;;;1351           case CAN_TEST_TX_STATE_SENDING:
;;;1352   
;;;1353               break;
;;;1354   
;;;1355           default:
;;;1356               break;
;;;1357       }
;;;1358   }
00003c  bd10              POP      {r4,pc}
;;;1359   
                          ENDP

00003e  0000              DCW      0x0000
                  |L20.64|
                          DCD      ||.bss||+0x5000
                  |L20.68|
                          DCD      ||.data||+0x6
                  |L20.72|
                          DCD      ||.bss||

                          AREA ||i.CAN_TEST_Tx_FillAndSend||, CODE, READONLY, ALIGN=2

                  CAN_TEST_Tx_FillAndSend PROC
;;;251    // 填充与发送处理:TRUE,填充与发送；FALSE，环形队列向前滑移.
;;;252    BOOL CAN_TEST_Tx_FillAndSend(CAN_TEST_CB *pCB)
000000  b5f0              PUSH     {r4-r7,lr}
;;;253    {
000002  b085              SUB      sp,sp,#0x14
;;;254        uint16 index = pCB->tx.index;                          // 当前发送数据的索引号
000004  f50041a0          ADD      r1,r0,#0x5000
000008  f60141dc          ADD      r1,r1,#0xcdc
00000c  888a              LDRH     r2,[r1,#4]
;;;255        uint16 length = pCB->tx.cmdQueue[pCB->tx.head].length; // 当前发送的命令帧的长度
00000e  880b              LDRH     r3,[r1,#0]
000010  eb030483          ADD      r4,r3,r3,LSL #2
000014  eb041343          ADD      r3,r4,r3,LSL #5
000018  eb000383          ADD      r3,r0,r3,LSL #2
00001c  f5035300          ADD      r3,r3,#0x2000
000020  f8b35f2c          LDRH     r5,[r3,#0xf2c]
;;;256        uint16 head = pCB->tx.head;                            // 发送命令帧队列头索引号
000024  880c              LDRH     r4,[r1,#0]
;;;257        uint16 end = pCB->tx.end;                              // 发送命令帧队列尾索引号
000026  884e              LDRH     r6,[r1,#2]
;;;258        CAN_PROTOCOL_TEST_FRAME *pCmd = &pCB->tx.cmdQueue[pCB->tx.head]; // 取当前发送缓冲区地址
000028  880b              LDRH     r3,[r1,#0]
00002a  f6a141dc          SUB      r1,r1,#0xcdc
00002e  eb030783          ADD      r7,r3,r3,LSL #2
000032  eb071343          ADD      r3,r7,r3,LSL #5
000036  eb000383          ADD      r3,r0,r3,LSL #2
00003a  f642679c          MOV      r7,#0x2e9c
00003e  443b              ADD      r3,r3,r7
;;;259        can_trasnmit_message_struct canTxMsgCB;
;;;260        uint16 standardID = 0x000;
;;;261        uint8 i; // 内部赋值用
;;;262        uint32 extendedID;
;;;263    
;;;264        // 参数合法性检验
;;;265        if (NULL == pCB)
000040  2800              CMP      r0,#0
000042  d004              BEQ      |L21.78|
;;;266        {
;;;267            return FALSE;
;;;268        }
;;;269    
;;;270        // 队列为空，不处理
;;;271        if (head == end)
000044  42b4              CMP      r4,r6
000046  d104              BNE      |L21.82|
;;;272        {
;;;273            return FALSE;
000048  2000              MOVS     r0,#0
                  |L21.74|
;;;274        }
;;;275    
;;;276        // ■■执行到这里，说明队列非空■■
;;;277    
;;;278        // 当前命令帧未发送完时，根据长度的变化取出命令帧中的数据放到发送寄存器中
;;;279        if (index < length)
;;;280        {
;;;281            // 配置为标准帧
;;;282            // 配置为数据帧
;;;283            canTxMsgCB.tx_ft = CAN_FT_DATA;
;;;284    
;;;285            if(testFlag)
;;;286            {
;;;287                // 扩展帧
;;;288                canTxMsgCB.tx_ff = CAN_FF_EXTENDED;
;;;289    //            extendedID = pCmd->deviceID;
;;;290                extendedID = 0x1801FFF4;
;;;291                canTxMsgCB.tx_efid = extendedID;
;;;292            }
;;;293            else
;;;294            {
;;;295                switch (dut_info.ID)
;;;296                {
;;;297                    case DUT_TYPE_GB:
;;;298                    case DUT_TYPE_KAIYANG:
;;;299    
;;;300                        // 扩展帧
;;;301                        canTxMsgCB.tx_ff = CAN_FF_EXTENDED;
;;;302                        extendedID = pCmd->deviceID;
;;;303                        canTxMsgCB.tx_efid = extendedID;
;;;304                        break;
;;;305    
;;;306                    default:
;;;307                        // 标准帧
;;;308                        canTxMsgCB.tx_ff = CAN_FF_STANDARD;
;;;309                        standardID = (uint16)CAN_TEST_DEVICE_ID_HMI; // id：001
;;;310                        canTxMsgCB.tx_sfid = standardID;
;;;311                        break;
;;;312                }
;;;313             }
;;;314            // ■■标准数据帧CAN消息格式■■
;;;315    
;;;316            // 填充 DLC，最大8字节.当前长度>8字节，先发8字节。
;;;317            if ((length - index) >= CAN_ONCEMESSAGE_MAX_SIZE)
;;;318            {
;;;319                canTxMsgCB.tx_dlen = CAN_ONCEMESSAGE_MAX_SIZE;
;;;320            }
;;;321            else
;;;322            {
;;;323                canTxMsgCB.tx_dlen = length - index;
;;;324            }
;;;325    
;;;326            // 填充数据
;;;327            for (i = 0; i < canTxMsgCB.tx_dlen; i++)
;;;328            {
;;;329                canTxMsgCB.tx_data[i] = pCmd->buff[index + i];
;;;330            }
;;;331    
;;;332            // 发送数据
;;;333            if (can_message_transmit(CAN0, &canTxMsgCB) == CAN_TRANSMIT_NOMAILBOX)
;;;334            {
;;;335                return FALSE;
;;;336            }
;;;337    
;;;338            // 开启邮箱空中断
;;;339            can_interrupt_enable(CAN0, CAN_INT_TME);
;;;340    
;;;341            return TRUE;
;;;342        }
;;;343        // 当前命令帧发送完时，删除之
;;;344        else
;;;345        {
;;;346            pCB->tx.cmdQueue[head].length = 0;
;;;347            pCB->tx.head++;
;;;348            pCB->tx.head %= CAN_TEST_TX_QUEUE_SIZE;
;;;349            pCB->tx.index = 0;
;;;350    
;;;351            // 进入CAN消息发送待机状态
;;;352            CAN_TEST_TxEnterState(CAN_TEST_TX_STATE_STANDBY);
;;;353    
;;;354            return FALSE;
;;;355        }
;;;356    }
00004a  b005              ADD      sp,sp,#0x14
00004c  bdf0              POP      {r4-r7,pc}
                  |L21.78|
00004e  2000              MOVS     r0,#0                 ;267
000050  e7fb              B        |L21.74|
                  |L21.82|
000052  2600              MOVS     r6,#0                 ;279
000054  42aa              CMP      r2,r5                 ;279
000056  d23f              BCS      |L21.216|
000058  f88d6009          STRB     r6,[sp,#9]            ;283
00005c  482c              LDR      r0,|L21.272|
00005e  2104              MOVS     r1,#4                 ;288
000060  7800              LDRB     r0,[r0,#0]            ;285  ; testFlag
000062  b120              CBZ      r0,|L21.110|
000064  f88d1008          STRB     r1,[sp,#8]            ;288
000068  482a              LDR      r0,|L21.276|
00006a  9001              STR      r0,[sp,#4]            ;291
00006c  e009              B        |L21.130|
                  |L21.110|
00006e  482a              LDR      r0,|L21.280|
000070  7d80              LDRB     r0,[r0,#0x16]         ;295  ; dut_info
000072  2801              CMP      r0,#1                 ;295
000074  d00c              BEQ      |L21.144|
000076  2805              CMP      r0,#5                 ;295
000078  d00a              BEQ      |L21.144|
00007a  f88d6008          STRB     r6,[sp,#8]            ;308
00007e  2001              MOVS     r0,#1                 ;309
000080  9000              STR      r0,[sp,#0]            ;310
                  |L21.130|
000082  1aa8              SUBS     r0,r5,r2              ;317
000084  2808              CMP      r0,#8                 ;317
000086  db08              BLT      |L21.154|
000088  2008              MOVS     r0,#8                 ;319
00008a  f88d000a          STRB     r0,[sp,#0xa]          ;319
00008e  e006              B        |L21.158|
                  |L21.144|
000090  f88d1008          STRB     r1,[sp,#8]            ;301
000094  6818              LDR      r0,[r3,#0]            ;302
000096  9001              STR      r0,[sp,#4]            ;303
000098  e7f3              B        |L21.130|
                  |L21.154|
00009a  f88d000a          STRB     r0,[sp,#0xa]          ;323
                  |L21.158|
00009e  2000              MOVS     r0,#0                 ;327
0000a0  4669              MOV      r1,sp                 ;259
0000a2  e006              B        |L21.178|
                  |L21.164|
0000a4  1814              ADDS     r4,r2,r0              ;329
0000a6  441c              ADD      r4,r4,r3              ;329
0000a8  180d              ADDS     r5,r1,r0              ;329
0000aa  7924              LDRB     r4,[r4,#4]            ;329
0000ac  72ec              STRB     r4,[r5,#0xb]          ;329
0000ae  1c40              ADDS     r0,r0,#1              ;327
0000b0  b2c0              UXTB     r0,r0                 ;327
                  |L21.178|
0000b2  f89d400a          LDRB     r4,[sp,#0xa]          ;327
0000b6  4284              CMP      r4,r0                 ;327
0000b8  d8f4              BHI      |L21.164|
0000ba  4c18              LDR      r4,|L21.284|
0000bc  4669              MOV      r1,sp                 ;333
0000be  4620              MOV      r0,r4                 ;333
0000c0  f7fffffe          BL       can_message_transmit
0000c4  2804              CMP      r0,#4                 ;333
0000c6  d005              BEQ      |L21.212|
0000c8  2101              MOVS     r1,#1                 ;339
0000ca  4620              MOV      r0,r4                 ;339
0000cc  f7fffffe          BL       can_interrupt_enable
0000d0  2001              MOVS     r0,#1                 ;341
0000d2  e7ba              B        |L21.74|
                  |L21.212|
0000d4  2000              MOVS     r0,#0                 ;335
0000d6  e7b8              B        |L21.74|
                  |L21.216|
0000d8  eb040284          ADD      r2,r4,r4,LSL #2       ;346
0000dc  eb021244          ADD      r2,r2,r4,LSL #5       ;346
0000e0  eb000082          ADD      r0,r0,r2,LSL #2       ;346
0000e4  f5005000          ADD      r0,r0,#0x2000         ;346
0000e8  f8a06f2c          STRH     r6,[r0,#0xf2c]        ;346
0000ec  f60141dc          ADD      r1,r1,#0xcdc          ;347
0000f0  8808              LDRH     r0,[r1,#0]            ;347
0000f2  1c40              ADDS     r0,r0,#1              ;347
0000f4  8008              STRH     r0,[r1,#0]            ;347
0000f6  8808              LDRH     r0,[r1,#0]            ;348
0000f8  2250              MOVS     r2,#0x50              ;348
0000fa  fbb0f3f2          UDIV     r3,r0,r2              ;348
0000fe  fb020013          MLS      r0,r2,r3,r0           ;348
000102  8008              STRH     r0,[r1,#0]            ;348
000104  808e              STRH     r6,[r1,#4]            ;349
000106  2002              MOVS     r0,#2                 ;352
000108  f7fffffe          BL       CAN_TEST_TxEnterState
00010c  2000              MOVS     r0,#0                 ;354
00010e  e79c              B        |L21.74|
;;;357    
                          ENDP

                  |L21.272|
                          DCD      testFlag
                  |L21.276|
                          DCD      0x1801fff4
                  |L21.280|
                          DCD      dut_info
                  |L21.284|
                          DCD      0x40006400

                          AREA ||i.CAN_TEST_Tx_NextFram||, CODE, READONLY, ALIGN=1

                  CAN_TEST_Tx_NextFram PROC
;;;358    // 发送成功启动下一帧:TRUE,启动下一帧；FALSE，发送完成.
;;;359    BOOL CAN_TEST_Tx_NextFram(CAN_TEST_CB *pCB)
000000  b510              PUSH     {r4,lr}
;;;360    {
;;;361        uint16 index = pCB->tx.index;                          // 当前发送数据的索引号
000002  f50041a0          ADD      r1,r0,#0x5000
000006  f8b13ce0          LDRH     r3,[r1,#0xce0]
;;;362        uint16 length = pCB->tx.cmdQueue[pCB->tx.head].length; // 当前发送的命令帧的长度
00000a  f8b12cdc          LDRH     r2,[r1,#0xcdc]
00000e  eb020482          ADD      r4,r2,r2,LSL #2
000012  eb041242          ADD      r2,r4,r2,LSL #5
000016  eb000282          ADD      r2,r0,r2,LSL #2
00001a  f5025200          ADD      r2,r2,#0x2000
00001e  f8b22f2c          LDRH     r2,[r2,#0xf2c]
;;;363        uint8 txBnDLC = 0;
;;;364    
;;;365        // 参数合法性检验
;;;366        if (NULL == pCB)
000022  2800              CMP      r0,#0
000024  d004              BEQ      |L22.48|
;;;367        {
;;;368            return FALSE;
;;;369        }
;;;370    
;;;371        // 判断上一次成功发送的字节数.
;;;372        if (length - index >= CAN_ONCEMESSAGE_MAX_SIZE)
000026  1ad0              SUBS     r0,r2,r3
000028  2808              CMP      r0,#8
00002a  db03              BLT      |L22.52|
;;;373        {
;;;374            txBnDLC = CAN_ONCEMESSAGE_MAX_SIZE;
00002c  2008              MOVS     r0,#8
00002e  e002              B        |L22.54|
                  |L22.48|
000030  2000              MOVS     r0,#0                 ;368
;;;375        }
;;;376        else
;;;377        {
;;;378            txBnDLC = length - index;
;;;379        }
;;;380        pCB->tx.index += txBnDLC;
;;;381    
;;;382        // 启动下一帧
;;;383        if (pCB->tx.index < length)
;;;384        {
;;;385            // 进入CAN消息下一帧发送状态
;;;386            return TRUE;
;;;387        }
;;;388        else
;;;389        {
;;;390            // 发送完成
;;;391            return FALSE;
;;;392        }
;;;393    }
000032  bd10              POP      {r4,pc}
                  |L22.52|
000034  b2c0              UXTB     r0,r0                 ;378
                  |L22.54|
000036  f501614e          ADD      r1,r1,#0xce0          ;380
00003a  880b              LDRH     r3,[r1,#0]            ;380
00003c  4418              ADD      r0,r0,r3              ;380
00003e  8008              STRH     r0,[r1,#0]            ;380
000040  8808              LDRH     r0,[r1,#0]            ;383
000042  4290              CMP      r0,r2                 ;383
000044  d201              BCS      |L22.74|
000046  2001              MOVS     r0,#1                 ;386
000048  bd10              POP      {r4,pc}
                  |L22.74|
00004a  2000              MOVS     r0,#0                 ;391
00004c  bd10              POP      {r4,pc}
;;;394    
                          ENDP


                          AREA ||i.USBD_HP_CAN0_TX_IRQHandler||, CODE, READONLY, ALIGN=2

                  USBD_HP_CAN0_TX_IRQHandler PROC
;;;1488   //// ISR for CAN TX Interrupt
;;;1489   void USBD_HP_CAN0_TX_IRQHandler(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1490   {
;;;1491       uint16 head = testCanCB.tx.head;
000004  4810              LDR      r0,|L23.72|
000006  f8b04cdc          LDRH     r4,[r0,#0xcdc]  ; testCanCB
;;;1492       uint16 end = testCanCB.tx.end;
00000a  f8b05cde          LDRH     r5,[r0,#0xcde]  ; testCanCB
;;;1493       uint16 head1 = sysCanCB.tx.head;
00000e  480f              LDR      r0,|L23.76|
000010  f8b064d4          LDRH     r6,[r0,#0x4d4]  ; sysCanCB
;;;1494   	uint16 end1 = sysCanCB.tx.end;
000014  f8b074d6          LDRH     r7,[r0,#0x4d6]  ; sysCanCB
;;;1495       
;;;1496       // 清空邮箱空中断标志位
;;;1497       can_interrupt_disable(CAN0, CAN_INT_TME);
000018  2101              MOVS     r1,#1
00001a  480d              LDR      r0,|L23.80|
00001c  f7fffffe          BL       can_interrupt_disable
;;;1498   
;;;1499       // 检测是否有Tx请求
;;;1500       if (head != end)
000020  42ac              CMP      r4,r5
000022  d005              BEQ      |L23.48|
;;;1501       {
;;;1502           // Tx成功，判断是否有下一帧
;;;1503           CAN_TEST_Tx_NextFram(&testCanCB);
000024  480b              LDR      r0,|L23.84|
000026  f7fffffe          BL       CAN_TEST_Tx_NextFram
;;;1504   
;;;1505           // 进入CAN消息下一帧发送状态
;;;1506           CAN_TEST_Tx_FillAndSend(&testCanCB);
00002a  480a              LDR      r0,|L23.84|
00002c  f7fffffe          BL       CAN_TEST_Tx_FillAndSend
                  |L23.48|
;;;1507       }
;;;1508   
;;;1509   	// 检测是否有Tx请求
;;;1510   	if (head1 != end1)
000030  42be              CMP      r6,r7
000032  d007              BEQ      |L23.68|
;;;1511   	{
;;;1512   		// Tx成功，判断是否有下一帧
;;;1513   		CAN_Tx_NextFram(&sysCanCB);
000034  4808              LDR      r0,|L23.88|
000036  f7fffffe          BL       CAN_Tx_NextFram
;;;1514   
;;;1515   		// 进入CAN消息下一帧发送状态
;;;1516   		CAN_Tx_FillAndSend(&sysCanCB);
00003a  e8bd41f0          POP      {r4-r8,lr}
00003e  4806              LDR      r0,|L23.88|
000040  f7ffbffe          B.W      CAN_Tx_FillAndSend
                  |L23.68|
;;;1517           
;;;1518   	}
;;;1519   }
000044  e8bd81f0          POP      {r4-r8,pc}
;;;1520   
                          ENDP

                  |L23.72|
                          DCD      ||.bss||+0x5000
                  |L23.76|
                          DCD      sysCanCB+0x1000
                  |L23.80|
                          DCD      0x40006400
                  |L23.84|
                          DCD      ||.bss||
                  |L23.88|
                          DCD      sysCanCB

                          AREA ||i.USBD_LP_CAN0_RX0_IRQHandler||, CODE, READONLY, ALIGN=2

                  USBD_LP_CAN0_RX0_IRQHandler PROC
;;;1442   // ISR for CAN RX Interrupt
;;;1443   void USBD_LP_CAN0_RX0_IRQHandler(void)
000000  b570              PUSH     {r4-r6,lr}
;;;1444   {
000002  b086              SUB      sp,sp,#0x18
;;;1445     can_receive_message_struct rxMessage1;
;;;1446   
;;;1447     // 读出FIFO中所有的数据
;;;1448     while (can_receive_message_length_get(CAN0, CAN_FIFO0))
;;;1449     {
;;;1450           if(dut_info.passThroughControl)           
000004  4c27              LDR      r4,|L24.164|
;;;1451           {
;;;1452               dut_info.online_dete_cnt++;            
;;;1453               TIMER_ResetTimer(TIMER_ID_ONLINE_DETECT);
;;;1454               
;;;1455   //            // 防止累加越界
;;;1456   //            if(2 < dut_info.online_dete_cnt)
;;;1457   //            {
;;;1458   //                dut_info.online_dete_cnt = 2;
;;;1459   //            }
;;;1460               
;;;1461               if(1 == dut_info.online_dete_cnt)
;;;1462               {
;;;1463                  // 上报仪表启动状态
;;;1464                  STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_ONLINE_DETECTION,TRUE);
;;;1465               }
;;;1466           }
;;;1467           
;;;1468         can_message_receive(CAN0, CAN_FIFO0, &rxMessage1);
000006  4d28              LDR      r5,|L24.168|
;;;1469   
;;;1470         switch (dut_info.ID)
;;;1471         {
;;;1472             case DUT_TYPE_GB:
;;;1473                 CAN_MacProcess(rxMessage1.rx_efid, &rxMessage1.rx_data[0], rxMessage1.rx_dlen);
000008  f10d060f          ADD      r6,sp,#0xf
00000c  e02d              B        |L24.106|
                  |L24.14|
00000e  f8940120          LDRB     r0,[r4,#0x120]        ;1450  ; dut_info
000012  b178              CBZ      r0,|L24.52|
000014  f8d41124          LDR      r1,[r4,#0x124]        ;1452  ; dut_info
000018  1c49              ADDS     r1,r1,#1              ;1452
00001a  f8c41124          STR      r1,[r4,#0x124]        ;1452  ; dut_info
00001e  2011              MOVS     r0,#0x11              ;1453
000020  f7fffffe          BL       TIMER_ResetTimer
000024  f8d40124          LDR      r0,[r4,#0x124]        ;1461  ; dut_info
000028  2801              CMP      r0,#1                 ;1461
00002a  d103              BNE      |L24.52|
00002c  2101              MOVS     r1,#1                 ;1464
00002e  2018              MOVS     r0,#0x18              ;1464
000030  f7fffffe          BL       STS_PROTOCOL_SendCmdParamAck
                  |L24.52|
000034  aa01              ADD      r2,sp,#4              ;1468
000036  2100              MOVS     r1,#0                 ;1468
000038  4628              MOV      r0,r5                 ;1468
00003a  f7fffffe          BL       can_message_receive
00003e  7da0              LDRB     r0,[r4,#0x16]         ;1470  ; dut_info
000040  2801              CMP      r0,#1                 ;1470
000042  d01a              BEQ      |L24.122|
;;;1474                 CAN_PROTOCOL_MacProcess(rxMessage1.rx_efid, &rxMessage1.rx_data[0], rxMessage1.rx_dlen);
;;;1475                 CAN_TEST_MacProcess(rxMessage1.rx_sfid, &rxMessage1.rx_data[0], rxMessage1.rx_dlen);
;;;1476                 break;
;;;1477                 
;;;1478             default:
;;;1479                 CAN_PROTOCOL1_MacProcess(rxMessage1.rx_sfid, &rxMessage1.rx_data[0], rxMessage1.rx_dlen); // 升级config
000044  f89d200e          LDRB     r2,[sp,#0xe]
000048  4631              MOV      r1,r6
00004a  9801              LDR      r0,[sp,#4]
00004c  f7fffffe          BL       CAN_PROTOCOL1_MacProcess
;;;1480                 CAN_MacProcess(rxMessage1.rx_sfid, &rxMessage1.rx_data[0], rxMessage1.rx_dlen);           // 55升级协议
000050  f89d200e          LDRB     r2,[sp,#0xe]
000054  4631              MOV      r1,r6
000056  9801              LDR      r0,[sp,#4]
000058  f7fffffe          BL       CAN_MacProcess
;;;1481                 CAN_TEST_MacProcess(rxMessage1.rx_sfid, &rxMessage1.rx_data[0], rxMessage1.rx_dlen);
00005c  9801              LDR      r0,[sp,#4]
00005e  f89d200e          LDRB     r2,[sp,#0xe]
000062  b280              UXTH     r0,r0
000064  4631              MOV      r1,r6
000066  f7fffffe          BL       CAN_TEST_MacProcess
                  |L24.106|
00006a  2100              MOVS     r1,#0                 ;1448
00006c  4628              MOV      r0,r5                 ;1448
00006e  f7fffffe          BL       can_receive_message_length_get
000072  2800              CMP      r0,#0                 ;1448
000074  d1cb              BNE      |L24.14|
;;;1482                 break;
;;;1483         }
;;;1484     }
;;;1485   }
000076  b006              ADD      sp,sp,#0x18
000078  bd70              POP      {r4-r6,pc}
                  |L24.122|
00007a  f89d200e          LDRB     r2,[sp,#0xe]          ;1473
00007e  4631              MOV      r1,r6                 ;1473
000080  9802              LDR      r0,[sp,#8]            ;1473
000082  f7fffffe          BL       CAN_MacProcess
000086  f89d200e          LDRB     r2,[sp,#0xe]          ;1474
00008a  4631              MOV      r1,r6                 ;1474
00008c  9802              LDR      r0,[sp,#8]            ;1474
00008e  f7fffffe          BL       CAN_PROTOCOL_MacProcess
000092  9801              LDR      r0,[sp,#4]            ;1475
000094  f89d200e          LDRB     r2,[sp,#0xe]          ;1475
000098  b280              UXTH     r0,r0                 ;1475
00009a  4631              MOV      r1,r6                 ;1475
00009c  f7fffffe          BL       CAN_TEST_MacProcess
0000a0  e7e3              B        |L24.106|
;;;1486   
                          ENDP

0000a2  0000              DCW      0x0000
                  |L24.164|
                          DCD      dut_info
                  |L24.168|
                          DCD      0x40006400

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  testCanCB
                          %        23780

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

000000  ff000000          DCB      0xff,0x00,0x00,0x00

                          AREA ||.data||, DATA, ALIGN=0

                  can_light_cnt
000000  00                DCB      0x00
                  can_left_light_cnt
000001  00                DCB      0x00
                  can_right_light_cnt
000002  00                DCB      0x00
                  can_brake_cnt
000003  00                DCB      0x00
                  can_throttleAd_cnt
000004  00                DCB      0x00
                  can_derailleurAd_cnt
000005  00                DCB      0x00
                  canTestTxStateCB
000006  0000              DCB      0x00,0x00
                          DCDU     0x00000000
00000c  00                DCB      0x00
                  ptUpMsgBuff
00000d  502d54            DCB      0x50,0x2d,0x54
000010  20436f6d          DCB      0x20,0x43,0x6f,0x6d
000014  706c6574          DCB      0x70,0x6c,0x65,0x74
000018  696f6e00          DCB      0x69,0x6f,0x6e,0x00
                          DCDU     0x00000000
000020  00000000          DCB      0x00,0x00,0x00,0x00
                          %        16
000034  00000000          DCB      0x00,0x00,0x00,0x00
                          %        16
000048  00000000          DCB      0x00,0x00,0x00,0x00
                          %        16
00005c  00                DCB      0x00

                          AREA ||area_number.30||, DATA, ALIGN=0

                          EXPORTAS ||area_number.30||, ||.data||
                  can_cnt
000000  00                DCB      0x00

                          AREA ||area_number.31||, DATA, ALIGN=0

                          EXPORTAS ||area_number.31||, ||.data||
                  can_cali_cnt
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "User\\CanProtocolTest.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___17_CanProtocolTest_c_e3f9597c____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___17_CanProtocolTest_c_e3f9597c____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___17_CanProtocolTest_c_e3f9597c____REVSH|
#line 128
|__asm___17_CanProtocolTest_c_e3f9597c____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
