; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\dutcanprotocol.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\dutcanprotocol.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -I.\User\qrencode -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.3\Device\Include -D__MICROLIB -D__UVISION_VERSION=539 -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\dutcanprotocol.crf User\DutCanProtocol.c]
                          THUMB

                          AREA ||i.CAN_PROTOCOL1_CALLBACK_UartBusError||, CODE, READONLY, ALIGN=1

                  CAN_PROTOCOL1_CALLBACK_UartBusError PROC
;;;754    //  UART总线超时错误处理
;;;755    void CAN_PROTOCOL1_CALLBACK_UartBusError(uint32 param)
000000  4770              BX       lr
;;;756    {
;;;757    }
;;;758    
                          ENDP


                          AREA ||i.CAN_PROTOCOL1_CheckSUM||, CODE, READONLY, ALIGN=1

                  CAN_PROTOCOL1_CheckSUM PROC
;;;478    // 对传入的命令帧进行校验，返回校验结果
;;;479    BOOL CAN_PROTOCOL1_CheckSUM(CAN_PROTOCOL1_RX_CMD_FRAME *pCmdFrame)
000000  b530              PUSH     {r4,r5,lr}
;;;480    {
;;;481        uint16 checkSum = 0;
000002  2200              MOVS     r2,#0
;;;482        uint16 sumTemp;
;;;483        uint16 i = 0;
;;;484    
;;;485        if (NULL == pCmdFrame)
000004  2800              CMP      r0,#0
000006  d004              BEQ      |L2.18|
;;;486        {
;;;487            return FALSE;
;;;488        }
;;;489    
;;;490        // 从设备地址开始，到校验码之前的一个字节，依次进行累加运算
;;;491        for (i = 1; i < pCmdFrame->length - 4; i++)
000008  2101              MOVS     r1,#1
00000a  f8b05098          LDRH     r5,[r0,#0x98]
00000e  1f2b              SUBS     r3,r5,#4
000010  e007              B        |L2.34|
                  |L2.18|
000012  2000              MOVS     r0,#0                 ;487
;;;492        {
;;;493            checkSum += pCmdFrame->buff[i];
;;;494        }
;;;495    
;;;496        // 累加和，低字节在前，高字节在后
;;;497        sumTemp = pCmdFrame->buff[pCmdFrame->length - 3]; // 高字节
;;;498        sumTemp <<= 8;
;;;499        sumTemp += pCmdFrame->buff[pCmdFrame->length - 4]; // 低字节
;;;500    
;;;501        // 判断计算得到的校验码与命令帧中的校验码是否相同
;;;502        if (sumTemp != checkSum)
;;;503        {
;;;504            return FALSE;
;;;505        }
;;;506    
;;;507        return TRUE;
;;;508    }
000014  bd30              POP      {r4,r5,pc}
                  |L2.22|
000016  1844              ADDS     r4,r0,r1              ;493
000018  78a4              LDRB     r4,[r4,#2]            ;493
00001a  4422              ADD      r2,r2,r4              ;493
00001c  b292              UXTH     r2,r2                 ;493
00001e  1c49              ADDS     r1,r1,#1              ;491
000020  b289              UXTH     r1,r1                 ;491
                  |L2.34|
000022  428b              CMP      r3,r1                 ;491
000024  dcf7              BGT      |L2.22|
000026  1e41              SUBS     r1,r0,#1              ;497
000028  5c69              LDRB     r1,[r5,r1]            ;497
00002a  f64f73ff          MOV      r3,#0xffff            ;498
00002e  ea032101          AND      r1,r3,r1,LSL #8       ;498
000032  1e80              SUBS     r0,r0,#2              ;499
000034  5c28              LDRB     r0,[r5,r0]            ;499
000036  4408              ADD      r0,r0,r1              ;499
000038  b280              UXTH     r0,r0                 ;499
00003a  4290              CMP      r0,r2                 ;502
00003c  d001              BEQ      |L2.66|
00003e  2000              MOVS     r0,#0                 ;504
000040  bd30              POP      {r4,r5,pc}
                  |L2.66|
000042  2001              MOVS     r0,#1                 ;507
000044  bd30              POP      {r4,r5,pc}
;;;509    
                          ENDP


                          AREA ||i.CAN_PROTOCOL1_CmdFrameProcess||, CODE, READONLY, ALIGN=2

                  CAN_PROTOCOL1_CmdFrameProcess PROC
;;;510    // CAN命令帧缓冲区处理
;;;511    void CAN_PROTOCOL1_CmdFrameProcess(CAN_PROTOCOL1_CB *pCB)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;512    {
000004  4605              MOV      r5,r0
;;;513        CAN_PROTOCOL1_CMD cmd = CAN_PROTOCOL1_CMD_NULL;
;;;514        CAN_PROTOCOL1_RX_CMD_FRAME *pCmdFrame = NULL;
;;;515    
;;;516        uint8 switch_state = 0;
;;;517        uint8 Peripheral_type = 0;
;;;518        uint8 calibration_result = 0;
;;;519        uint8 turn_item = 0;
;;;520        uint8 turn_state = 0;
;;;521    
;;;522        // 参数合法性检验
;;;523        if (NULL == pCB)
000006  2d00              CMP      r5,#0
000008  d017              BEQ      |L3.58|
;;;524        {
;;;525            return;
;;;526        }
;;;527    
;;;528        // 命令帧缓冲区为空，退出
;;;529        if (pCB->rx.head == pCB->rx.end)
00000a  f8b503d0          LDRH     r0,[r5,#0x3d0]
00000e  f8b513d2          LDRH     r1,[r5,#0x3d2]
000012  4288              CMP      r0,r1
000014  d011              BEQ      |L3.58|
;;;530        {
;;;531            return;
;;;532        }
;;;533    
;;;534        // 获取当前要处理的命令帧指针
;;;535        pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.head];
000016  214d              MOVS     r1,#0x4d
000018  4341              MULS     r1,r0,r1
00001a  eb050441          ADD      r4,r5,r1,LSL #1
00001e  34ce              ADDS     r4,r4,#0xce
;;;536    
;;;537        // 命令头非法，退出
;;;538        if (CAN_PROTOCOL1_CMD_HEAD != pCmdFrame->buff[CAN_PROTOCOL1_CMD_HEAD_INDEX])
;;;539        {
;;;540            // 删除命令帧
;;;541            pCB->rx.head++;
;;;542            pCB->rx.head %= CAN_PROTOCOL1_RX_QUEUE_SIZE;
000020  f04f0905          MOV      r9,#5
000024  78a1              LDRB     r1,[r4,#2]            ;538
000026  293a              CMP      r1,#0x3a              ;538
000028  d009              BEQ      |L3.62|
00002a  1c40              ADDS     r0,r0,#1              ;541
00002c  b280              UXTH     r0,r0                 ;541
00002e  fbb0f1f9          UDIV     r1,r0,r9
000032  fb090011          MLS      r0,r9,r1,r0
000036  f8a503d0          STRH     r0,[r5,#0x3d0]
                  |L3.58|
;;;543            return;
;;;544        }
;;;545    
;;;546        // 命令头合法，则提取命令
;;;547        cmd = (CAN_PROTOCOL1_CMD)pCmdFrame->buff[CAN_PROTOCOL1_CMD_CMD_INDEX];
;;;548    
;;;549        // 执行命令帧
;;;550        switch (cmd)
;;;551        {
;;;552        // 空命令，不予执行
;;;553        case CAN_PROTOCOL1_CMD_NULL:
;;;554            break;
;;;555    
;;;556        // 大灯控制
;;;557        case CAN_PROTOCOL1_CMD_HEADLIGHT_CONTROL:
;;;558            switch_state = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA1_INDEX];   // 执行结果
;;;559    				
;;;560            // 执行失败
;;;561            if (0x00 == (switch_state & 0x00))
;;;562            {
;;;563    #if DEBUG_ENABLE
;;;564                Clear_All_Lines();
;;;565                Display_Centered(1, "Headlights fail to turn on");
;;;566                Delayms(1000);
;;;567    #endif
;;;568                can_light_cnt = 0;
;;;569                STS_PROTOCOL_SendCmdParamAck(UART_STS_CMD_MULTIPLE_TEST, FALSE);
;;;570            }
;;;571    				
;;;572            // 执行成功
;;;573            if (0x01 == (switch_state & 0x01))
;;;574            {
;;;575                can_light_cnt++;
;;;576                if (can_light_cnt == 1)
;;;577                {
;;;578                    STATE_SwitchStep(STEP_HEADLIGHT_CAN_TEST_OPEN);
;;;579                }
;;;580                if (can_light_cnt == 2)
;;;581                {
;;;582                    STATE_SwitchStep(STEP_HEADLIGHT_CAN_TEST_COMPLETE);
;;;583                    can_light_cnt = 0;
;;;584                }
;;;585            }
;;;586            break;
;;;587    
;;;588        // 获取油门/刹车的模拟数字值
;;;589        case CAN_PROTOCOL1_CMD_GET_THROTTLE_BRAKE_AD:
;;;590    		
;;;591            // 获取AD值并且比对
;;;592            Peripheral_type = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA1_INDEX];   // 外设类型
;;;593    
;;;594            if (0x01 == (Peripheral_type & 0x01))  // 油门
;;;595            {
;;;596                dut_info.throttleAd = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA2_INDEX] << 8;
;;;597                dut_info.throttleAd = dut_info.throttleAd | pCmdFrame->buff[STS_PROTOCOL_CMD_DATA3_INDEX];
;;;598                can_throttleAd_cnt++;
;;;599                switch (can_throttleAd_cnt)
;;;600                {
;;;601                    case 0:
;;;602                        break;
;;;603                    case 1:
;;;604                        STATE_SwitchStep(STEP_THROTTLE_CAN_TEST_CHECK_DAC1_VALUE);
;;;605                        break;
;;;606                    case 2:
;;;607                        STATE_SwitchStep(STEP_THROTTLE_CAN_TEST_CHECK_DAC3_VALUE);
;;;608                        break;
;;;609                    case 3:
;;;610                        STATE_SwitchStep(STEP_THROTTLE_CAN_TEST_CHECK_DAC4_VALUE);
;;;611                        can_throttleAd_cnt = 0;
;;;612                        break;
;;;613                    default:
;;;614                        break;
;;;615                }
;;;616            }
;;;617    
;;;618            if (0x02 == (Peripheral_type & 0x02))  // 刹把
;;;619            {
;;;620                dut_info.brakeAd = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA2_INDEX] << 8;
;;;621                dut_info.brakeAd = dut_info.brakeAd | pCmdFrame->buff[STS_PROTOCOL_CMD_DATA3_INDEX];
;;;622                can_brake_cnt++;
;;;623                switch (can_brake_cnt)
;;;624                {
;;;625                    case 0:
;;;626                        break;
;;;627                    case 1:
;;;628                        STATE_SwitchStep(STEP_BRAKE_CAN_TEST_CHECK_DAC1_VALUE);
;;;629                        break;
;;;630                    case 2:
;;;631                        STATE_SwitchStep(STEP_BRAKE_CAN_TEST_CHECK_DAC3_VALUE);
;;;632                        break;
;;;633                    case 3:
;;;634                        STATE_SwitchStep(STEP_BRAKE_CAN_TEST_CHECK_DAC4_VALUE);
;;;635                        can_brake_cnt = 0;
;;;636                        break;
;;;637                    default:
;;;638                        break;
;;;639                }
;;;640            }
;;;641    
;;;642            break;
;;;643    
;;;644        // 转向灯控制
;;;645        case CAN_PROTOCOL1_CMD_TURN_SIGNAL_CONTROL:
;;;646            turn_item = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA1_INDEX];  // 转向灯类型
;;;647            turn_state = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA2_INDEX]; // 执行结果
;;;648    				
;;;649            // 执行失败
;;;650            if (0x00 == (switch_state & 0x00))
;;;651            {
;;;652    #if DEBUG_ENABLE
;;;653                Clear_All_Lines();
;;;654                Display_Centered(1, "TURN SIGNAL fail to turn on");
;;;655    #endif
;;;656                can_left_light_cnt = 0;
;;;657                can_right_light_cnt = 0;
;;;658                STS_PROTOCOL_SendCmdParamAck(UART_STS_CMD_MULTIPLE_TEST, FALSE);
;;;659            }
;;;660    				
;;;661            // 左转向灯打开成功
;;;662            if ((turn_item == 0) && (turn_state == 1))
;;;663            {
;;;664                can_left_light_cnt++;
;;;665                STATE_SwitchStep(STEP_LEFT_TURN_SIGNAL_CAN_TEST_OPEN);
;;;666                if (can_left_light_cnt == 2)
;;;667                {
;;;668                    STATE_SwitchStep(STEP_LEFT_TURN_SIGNAL_CAN_TEST_COMPLETE);
;;;669                    can_left_light_cnt = 0;
;;;670                }
;;;671            }
;;;672    				
;;;673            // 右转向灯打开成功
;;;674            if ((turn_item == 1) && (turn_state == 1))
;;;675            {
;;;676                can_right_light_cnt++;
;;;677                STATE_SwitchStep(STEP_RIGHT_TURN_SIGNAL_CAN_TEST_OPEN);
;;;678                if (can_right_light_cnt == 2)
;;;679                {
;;;680                    STATE_SwitchStep(STEP_RIGHT_TURN_SIGNAL_CAN_TEST_COMPLETE);
;;;681                    can_right_light_cnt = 0;
;;;682                }
;;;683            }
;;;684    
;;;685            break;
;;;686    
;;;687    
;;;688        // 获取光敏传感器数值命令
;;;689        case CAN_PROTOCOL1_CMD_GET_PHOTORESISTOR_VALUE:
;;;690            break;
;;;691    
;;;692        // 进行电压校准命令
;;;693        case CAN_PROTOCOL1_CMD_VOLTAGE_CALIBRATION:
;;;694            can_cali_cnt++;
;;;695            calibration_result = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA1_INDEX];
;;;696    				
;;;697            // 一级校准
;;;698            if ((calibration_result) && (dut_info.cali_cnt == 1))
;;;699            {
;;;700                STATE_SwitchStep(STEP_CALIBRATION_UART_TEST_COMPLETE);
;;;701            }
;;;702    				
;;;703            // 二级校准
;;;704            if ((calibration_result) && (dut_info.cali_cnt == 2))
;;;705            {
;;;706                if (can_cali_cnt == 1)
;;;707                {
;;;708                    STATE_SwitchStep(STEP_CALIBRATION_UART_TEST_TWO_NOTIFY_POWER_BOARD);
;;;709                }
;;;710                if (can_cali_cnt == 2)
;;;711                {
;;;712                    STATE_SwitchStep(STEP_CALIBRATION_UART_TEST_COMPLETE);
;;;713                    can_cali_cnt = 0;
;;;714                }
;;;715            }
;;;716    				
;;;717            // 三级校准
;;;718            if ((calibration_result) && (dut_info.cali_cnt == 3))
;;;719            {
;;;720                if (can_cali_cnt == 1)
;;;721                {
;;;722                    STATE_SwitchStep(STEP_CALIBRATION_UART_TEST_TWO_NOTIFY_POWER_BOARD);
;;;723                }
;;;724                if (can_cali_cnt == 2)
;;;725                {
;;;726                    STATE_SwitchStep(STEP_CALIBRATION_UART_TEST_THREE_NOTIFY_POWER_BOARD);
;;;727    
;;;728                }
;;;729                if (can_cali_cnt == 3)
;;;730                {
;;;731                    STATE_SwitchStep(STEP_CALIBRATION_UART_TEST_COMPLETE);
;;;732                    can_cali_cnt = 0;
;;;733                }
;;;734            }
;;;735            if (!calibration_result)
;;;736            {
;;;737    #if DEBUG_ENABLE
;;;738                Clear_All_Lines();
;;;739                Display_Centered(1, "Calibration failure");
;;;740    #endif				     
;;;741                can_cali_cnt = 0;
;;;742                STS_PROTOCOL_SendCmdParamAck(UART_STS_CMD_VOLTAGE_CALIBRATION, FALSE);
;;;743            }
;;;744            break;
;;;745    
;;;746        default:
;;;747            break;
;;;748        }
;;;749        // 删除命令帧
;;;750        pCB->rx.head++;
;;;751        pCB->rx.head %= CAN_PROTOCOL1_RX_QUEUE_SIZE;
;;;752    }
00003a  e8bd87f0          POP      {r4-r10,pc}
                  |L3.62|
00003e  7920              LDRB     r0,[r4,#4]            ;547
000040  f8df8200          LDR      r8,|L3.580|
000044  2600              MOVS     r6,#0                 ;596
000046  4f80              LDR      r7,|L3.584|
000048  28ea              CMP      r0,#0xea              ;550
00004a  d00c              BEQ      |L3.102|
00004c  dc06              BGT      |L3.92|
00004e  2800              CMP      r0,#0                 ;550
                  |L3.80|
000050  d02b              BEQ      |L3.170|
000052  2890              CMP      r0,#0x90              ;550
000054  d0fc              BEQ      |L3.80|
000056  2891              CMP      r0,#0x91              ;550
                  |L3.88|
000058  d127              BNE      |L3.170|
00005a  e0a5              B        |L3.424|
                  |L3.92|
00005c  28eb              CMP      r0,#0xeb              ;550
00005e  d025              BEQ      |L3.172|
000060  28ec              CMP      r0,#0xec              ;550
000062  d1f9              BNE      |L3.88|
000064  e06c              B        |L3.320|
                  |L3.102|
000066  7964              LDRB     r4,[r4,#5]            ;558
000068  f7fffffe          BL       Clear_All_Lines
00006c  a177              ADR      r1,|L3.588|
00006e  2001              MOVS     r0,#1                 ;565
000070  f7fffffe          BL       Display_Centered
000074  f44f707a          MOV      r0,#0x3e8             ;566
000078  f7fffffe          BL       Delayms
00007c  703e              STRB     r6,[r7,#0]            ;568
00007e  2100              MOVS     r1,#0                 ;569
000080  200b              MOVS     r0,#0xb               ;569
000082  f7fffffe          BL       STS_PROTOCOL_SendCmdParamAck
000086  07e0              LSLS     r0,r4,#31             ;573
000088  d0e2              BEQ      |L3.80|
00008a  7838              LDRB     r0,[r7,#0]            ;575  ; can_light_cnt
00008c  1c40              ADDS     r0,r0,#1              ;575
00008e  b2c0              UXTB     r0,r0                 ;575
000090  7038              STRB     r0,[r7,#0]            ;575
000092  2801              CMP      r0,#1                 ;576
000094  d102              BNE      |L3.156|
000096  2060              MOVS     r0,#0x60              ;578
000098  f7fffffe          BL       STATE_SwitchStep
                  |L3.156|
00009c  7838              LDRB     r0,[r7,#0]            ;580  ; can_light_cnt
00009e  2802              CMP      r0,#2                 ;580
0000a0  d1da              BNE      |L3.88|
0000a2  2064              MOVS     r0,#0x64              ;582
0000a4  f7fffffe          BL       STATE_SwitchStep
0000a8  703e              STRB     r6,[r7,#0]            ;583
                  |L3.170|
0000aa  e0bf              B        |L3.556|
                  |L3.172|
0000ac  f894a005          LDRB     r10,[r4,#5]           ;592
0000b0  ea5f70ca          LSLS     r0,r10,#31            ;594
0000b4  d01f              BEQ      |L3.246|
0000b6  79a0              LDRB     r0,[r4,#6]            ;596
0000b8  0200              LSLS     r0,r0,#8              ;596
0000ba  f8a80040          STRH     r0,[r8,#0x40]         ;596
0000be  79e1              LDRB     r1,[r4,#7]            ;597
0000c0  4308              ORRS     r0,r0,r1              ;597
0000c2  f8a80040          STRH     r0,[r8,#0x40]         ;597
0000c6  7978              LDRB     r0,[r7,#5]            ;598  ; can_throttleAd_cnt
0000c8  1c40              ADDS     r0,r0,#1              ;598
0000ca  b2c0              UXTB     r0,r0                 ;598
0000cc  7178              STRB     r0,[r7,#5]            ;598
0000ce  b190              CBZ      r0,|L3.246|
0000d0  2801              CMP      r0,#1                 ;599
0000d2  d004              BEQ      |L3.222|
0000d4  2802              CMP      r0,#2                 ;599
0000d6  d006              BEQ      |L3.230|
0000d8  2803              CMP      r0,#3                 ;599
0000da  d10c              BNE      |L3.246|
0000dc  e007              B        |L3.238|
                  |L3.222|
0000de  208d              MOVS     r0,#0x8d              ;604
0000e0  f7fffffe          BL       STATE_SwitchStep
0000e4  e007              B        |L3.246|
                  |L3.230|
0000e6  208e              MOVS     r0,#0x8e              ;607
0000e8  f7fffffe          BL       STATE_SwitchStep
0000ec  e003              B        |L3.246|
                  |L3.238|
0000ee  208f              MOVS     r0,#0x8f              ;610
0000f0  f7fffffe          BL       STATE_SwitchStep
0000f4  717e              STRB     r6,[r7,#5]            ;611
                  |L3.246|
0000f6  ea5f708a          LSLS     r0,r10,#30            ;618
0000fa  d517              BPL      |L3.300|
0000fc  79a0              LDRB     r0,[r4,#6]            ;620
0000fe  0200              LSLS     r0,r0,#8              ;620
000100  f8a80042          STRH     r0,[r8,#0x42]         ;620
000104  79e1              LDRB     r1,[r4,#7]            ;621
000106  4308              ORRS     r0,r0,r1              ;621
000108  f8a80042          STRH     r0,[r8,#0x42]         ;621
00010c  7938              LDRB     r0,[r7,#4]            ;622  ; can_brake_cnt
00010e  1c40              ADDS     r0,r0,#1              ;622
000110  b2c0              UXTB     r0,r0                 ;622
000112  7138              STRB     r0,[r7,#4]            ;622
000114  2800              CMP      r0,#0                 ;623
000116  d009              BEQ      |L3.300|
000118  2801              CMP      r0,#1                 ;623
00011a  d004              BEQ      |L3.294|
00011c  2802              CMP      r0,#2                 ;623
00011e  d006              BEQ      |L3.302|
000120  2803              CMP      r0,#3                 ;623
000122  d103              BNE      |L3.300|
000124  e007              B        |L3.310|
                  |L3.294|
000126  2097              MOVS     r0,#0x97              ;628
000128  f7fffffe          BL       STATE_SwitchStep
                  |L3.300|
00012c  e07e              B        |L3.556|
                  |L3.302|
00012e  2098              MOVS     r0,#0x98              ;631
000130  f7fffffe          BL       STATE_SwitchStep
000134  e07a              B        |L3.556|
                  |L3.310|
000136  2099              MOVS     r0,#0x99              ;634
000138  f7fffffe          BL       STATE_SwitchStep
00013c  713e              STRB     r6,[r7,#4]            ;635
00013e  e075              B        |L3.556|
                  |L3.320|
000140  f8948005          LDRB     r8,[r4,#5]            ;646
000144  79a4              LDRB     r4,[r4,#6]            ;647
000146  f7fffffe          BL       Clear_All_Lines
00014a  a147              ADR      r1,|L3.616|
00014c  2001              MOVS     r0,#1                 ;654
00014e  f7fffffe          BL       Display_Centered
000152  707e              STRB     r6,[r7,#1]            ;656
000154  70be              STRB     r6,[r7,#2]            ;657
000156  2100              MOVS     r1,#0                 ;658
000158  200b              MOVS     r0,#0xb               ;658
00015a  f7fffffe          BL       STS_PROTOCOL_SendCmdParamAck
00015e  f1b80f00          CMP      r8,#0                 ;662
000162  d10e              BNE      |L3.386|
000164  2c01              CMP      r4,#1                 ;662
000166  d10c              BNE      |L3.386|
000168  7878              LDRB     r0,[r7,#1]            ;664  ; can_left_light_cnt
00016a  1c40              ADDS     r0,r0,#1              ;664
00016c  7078              STRB     r0,[r7,#1]            ;664
00016e  2079              MOVS     r0,#0x79              ;665
000170  f7fffffe          BL       STATE_SwitchStep
000174  7878              LDRB     r0,[r7,#1]            ;666  ; can_left_light_cnt
000176  2802              CMP      r0,#2                 ;666
000178  d103              BNE      |L3.386|
00017a  207d              MOVS     r0,#0x7d              ;668
00017c  f7fffffe          BL       STATE_SwitchStep
000180  707e              STRB     r6,[r7,#1]            ;669
                  |L3.386|
000182  f1b80f01          CMP      r8,#1                 ;674
000186  d151              BNE      |L3.556|
000188  2c01              CMP      r4,#1                 ;674
00018a  d14f              BNE      |L3.556|
00018c  78b8              LDRB     r0,[r7,#2]            ;676  ; can_right_light_cnt
00018e  1c40              ADDS     r0,r0,#1              ;676
000190  70b8              STRB     r0,[r7,#2]            ;676
000192  2082              MOVS     r0,#0x82              ;677
000194  f7fffffe          BL       STATE_SwitchStep
000198  78b8              LDRB     r0,[r7,#2]            ;678  ; can_right_light_cnt
00019a  2802              CMP      r0,#2                 ;678
00019c  d146              BNE      |L3.556|
00019e  2086              MOVS     r0,#0x86              ;680
0001a0  f7fffffe          BL       STATE_SwitchStep
0001a4  70be              STRB     r6,[r7,#2]            ;681
0001a6  e041              B        |L3.556|
                  |L3.424|
0001a8  78f8              LDRB     r0,[r7,#3]            ;694  ; can_cali_cnt
0001aa  1c40              ADDS     r0,r0,#1              ;694
0001ac  70f8              STRB     r0,[r7,#3]            ;694
0001ae  7964              LDRB     r4,[r4,#5]            ;695
0001b0  b134              CBZ      r4,|L3.448|
0001b2  f8980031          LDRB     r0,[r8,#0x31]         ;698  ; dut_info
0001b6  2801              CMP      r0,#1                 ;698
0001b8  d102              BNE      |L3.448|
0001ba  2059              MOVS     r0,#0x59              ;700
0001bc  f7fffffe          BL       STATE_SwitchStep
                  |L3.448|
0001c0  b184              CBZ      r4,|L3.484|
0001c2  f8980031          LDRB     r0,[r8,#0x31]         ;704  ; dut_info
0001c6  2802              CMP      r0,#2                 ;704
0001c8  d10c              BNE      |L3.484|
0001ca  78f8              LDRB     r0,[r7,#3]            ;706  ; can_cali_cnt
0001cc  2801              CMP      r0,#1                 ;706
0001ce  d102              BNE      |L3.470|
0001d0  2054              MOVS     r0,#0x54              ;708
0001d2  f7fffffe          BL       STATE_SwitchStep
                  |L3.470|
0001d6  78f8              LDRB     r0,[r7,#3]            ;710  ; can_cali_cnt
0001d8  2802              CMP      r0,#2                 ;710
0001da  d103              BNE      |L3.484|
0001dc  2059              MOVS     r0,#0x59              ;712
0001de  f7fffffe          BL       STATE_SwitchStep
0001e2  70fe              STRB     r6,[r7,#3]            ;713
                  |L3.484|
0001e4  b1b4              CBZ      r4,|L3.532|
0001e6  f8980031          LDRB     r0,[r8,#0x31]         ;718  ; dut_info
0001ea  2803              CMP      r0,#3                 ;718
0001ec  d112              BNE      |L3.532|
0001ee  78f8              LDRB     r0,[r7,#3]            ;720  ; can_cali_cnt
0001f0  2801              CMP      r0,#1                 ;720
0001f2  d102              BNE      |L3.506|
0001f4  2054              MOVS     r0,#0x54              ;722
0001f6  f7fffffe          BL       STATE_SwitchStep
                  |L3.506|
0001fa  78f8              LDRB     r0,[r7,#3]            ;724  ; can_cali_cnt
0001fc  2802              CMP      r0,#2                 ;724
0001fe  d102              BNE      |L3.518|
000200  2056              MOVS     r0,#0x56              ;726
000202  f7fffffe          BL       STATE_SwitchStep
                  |L3.518|
000206  78f8              LDRB     r0,[r7,#3]            ;729  ; can_cali_cnt
000208  2803              CMP      r0,#3                 ;729
00020a  d103              BNE      |L3.532|
00020c  2059              MOVS     r0,#0x59              ;731
00020e  f7fffffe          BL       STATE_SwitchStep
000212  70fe              STRB     r6,[r7,#3]            ;732
                  |L3.532|
000214  b954              CBNZ     r4,|L3.556|
000216  f7fffffe          BL       Clear_All_Lines
00021a  a11a              ADR      r1,|L3.644|
00021c  2001              MOVS     r0,#1                 ;739
00021e  f7fffffe          BL       Display_Centered
000222  70fe              STRB     r6,[r7,#3]            ;741
000224  2100              MOVS     r1,#0                 ;742
000226  2015              MOVS     r0,#0x15              ;742
000228  f7fffffe          BL       STS_PROTOCOL_SendCmdParamAck
                  |L3.556|
00022c  f8b503d0          LDRH     r0,[r5,#0x3d0]        ;750
000230  1c40              ADDS     r0,r0,#1              ;750
000232  b280              UXTH     r0,r0                 ;750
000234  fbb0f1f9          UDIV     r1,r0,r9              ;751
000238  fb090011          MLS      r0,r9,r1,r0           ;751
00023c  f8a503d0          STRH     r0,[r5,#0x3d0]        ;751
000240  e6fb              B        |L3.58|
;;;753    
                          ENDP

000242  0000              DCW      0x0000
                  |L3.580|
                          DCD      dut_info
                  |L3.584|
                          DCD      ||.data||
                  |L3.588|
00024c  48656164          DCB      "Headlights fail to turn on",0
000250  6c696768
000254  74732066
000258  61696c20
00025c  746f2074
000260  75726e20
000264  6f6e00  
000267  00                DCB      0
                  |L3.616|
000268  5455524e          DCB      "TURN SIGNAL fail to turn on",0
00026c  20534947
000270  4e414c20
000274  6661696c
000278  20746f20
00027c  7475726e
000280  206f6e00
                  |L3.644|
000284  43616c69          DCB      "Calibration failure",0
000288  62726174
00028c  696f6e20
000290  6661696c
000294  75726500

                          AREA ||i.CAN_PROTOCOL1_ConfirmTempCmdFrameBuff||, CODE, READONLY, ALIGN=1

                  CAN_PROTOCOL1_ConfirmTempCmdFrameBuff PROC
;;;259    // 将临时缓冲区添加到命令帧缓冲区中，其本质操作是承认临时缓冲区数据有效
;;;260    BOOL CAN_PROTOCOL1_ConfirmTempCmdFrameBuff(CAN_PROTOCOL1_CB *pCB)
000000  2800              CMP      r0,#0
;;;261    {
000002  d01a              BEQ      |L4.58|
;;;262        CAN_PROTOCOL1_RX_CMD_FRAME *pCmdFrame = NULL;
;;;263    
;;;264        // 参数合法性检验
;;;265        if (NULL == pCB)
;;;266        {
;;;267            return FALSE;
;;;268        }
;;;269    
;;;270        // 临时缓冲区为空，不予添加
;;;271        pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.end];
000004  f8b013d2          LDRH     r1,[r0,#0x3d2]
000008  224d              MOVS     r2,#0x4d
00000a  434a              MULS     r2,r1,r2
00000c  eb000242          ADD      r2,r0,r2,LSL #1
;;;272        if (0 == pCmdFrame->length)
000010  f8b22166          LDRH     r2,[r2,#0x166]
000014  b19a              CBZ      r2,|L4.62|
;;;273        {
;;;274            return FALSE;
;;;275        }
;;;276    
;;;277        // 添加
;;;278        pCB->rx.end++;
000016  1c49              ADDS     r1,r1,#1
000018  b289              UXTH     r1,r1
;;;279        pCB->rx.end %= CAN_PROTOCOL1_RX_QUEUE_SIZE;
00001a  2205              MOVS     r2,#5
00001c  fbb1f3f2          UDIV     r3,r1,r2
000020  fb021113          MLS      r1,r2,r3,r1
000024  f8a013d2          STRH     r1,[r0,#0x3d2]
;;;280        pCB->rx.cmdQueue[pCB->rx.end].length = 0; // 该行的作用是将新的添加位置有效数据个数清零，以便将这个位置当做临时帧缓冲区
000028  2200              MOVS     r2,#0
00002a  234d              MOVS     r3,#0x4d
00002c  4359              MULS     r1,r3,r1
00002e  eb000041          ADD      r0,r0,r1,LSL #1
000032  f8a02166          STRH     r2,[r0,#0x166]
;;;281    
;;;282        return TRUE;
000036  2001              MOVS     r0,#1
;;;283    }
000038  4770              BX       lr
                  |L4.58|
00003a  2000              MOVS     r0,#0                 ;267
00003c  4770              BX       lr
                  |L4.62|
00003e  2000              MOVS     r0,#0                 ;274
000040  4770              BX       lr
;;;284    
                          ENDP


                          AREA ||i.CAN_PROTOCOL1_DataStructInit||, CODE, READONLY, ALIGN=1

                  CAN_PROTOCOL1_DataStructInit PROC
;;;189    // 数据结构初始化
;;;190    void CAN_PROTOCOL1_DataStructInit(CAN_PROTOCOL1_CB *pCB)
000000  2800              CMP      r0,#0
;;;191    {
000002  d027              BEQ      |L5.84|
;;;192        uint16 i;
;;;193    
;;;194        // 参数合法性检验
;;;195        if (NULL == pCB)
;;;196        {
;;;197            return;
;;;198        }
;;;199    
;;;200        pCB->tx.txBusy = FALSE;
000004  2200              MOVS     r2,#0
000006  f88026dc          STRB     r2,[r0,#0x6dc]
;;;201        pCB->tx.index = 0;
00000a  f8a026da          STRH     r2,[r0,#0x6da]
;;;202        pCB->tx.head = 0;
00000e  f8a026d6          STRH     r2,[r0,#0x6d6]
;;;203        pCB->tx.end = 0;
000012  f8a026d8          STRH     r2,[r0,#0x6d8]
;;;204        for (i = 0; i < CAN_PROTOCOL1_TX_QUEUE_SIZE; i++)
000016  2100              MOVS     r1,#0
                  |L5.24|
;;;205        {
;;;206            pCB->tx.cmdQueue[i].length = 0;
000018  234d              MOVS     r3,#0x4d
00001a  434b              MULS     r3,r1,r3
00001c  eb000343          ADD      r3,r0,r3,LSL #1
000020  f8a3246c          STRH     r2,[r3,#0x46c]
000024  1c49              ADDS     r1,r1,#1              ;204
000026  b289              UXTH     r1,r1                 ;204
000028  2905              CMP      r1,#5                 ;204
00002a  d3f5              BCC      |L5.24|
;;;207        }
;;;208    
;;;209        pCB->rxFIFO.head = 0;
00002c  f8202fc8          STRH     r2,[r0,#0xc8]!
;;;210        pCB->rxFIFO.end = 0;
000030  8042              STRH     r2,[r0,#2]
;;;211        pCB->rxFIFO.currentProcessIndex = 0;
000032  8082              STRH     r2,[r0,#4]
;;;212    
;;;213        pCB->rx.head = 0;
000034  f8a02308          STRH     r2,[r0,#0x308]
;;;214        pCB->rx.end = 0;
000038  f8a0230a          STRH     r2,[r0,#0x30a]
00003c  38c8              SUBS     r0,r0,#0xc8
;;;215        for (i = 0; i < CAN_PROTOCOL1_RX_QUEUE_SIZE; i++)
00003e  2100              MOVS     r1,#0
                  |L5.64|
;;;216        {
;;;217            pCB->rx.cmdQueue[i].length = 0;
000040  234d              MOVS     r3,#0x4d
000042  434b              MULS     r3,r1,r3
000044  eb000343          ADD      r3,r0,r3,LSL #1
000048  f8a32166          STRH     r2,[r3,#0x166]
00004c  1c49              ADDS     r1,r1,#1              ;215
00004e  b289              UXTH     r1,r1                 ;215
000050  2905              CMP      r1,#5                 ;215
000052  d3f5              BCC      |L5.64|
                  |L5.84|
;;;218        }
;;;219    }
000054  4770              BX       lr
;;;220    
                          ENDP


                          AREA ||i.CAN_PROTOCOL1_Init||, CODE, READONLY, ALIGN=2

                  CAN_PROTOCOL1_Init PROC
;;;91     // 协议初始化
;;;92     void CAN_PROTOCOL1_Init(void)
000000  b500              PUSH     {lr}
;;;93     {
;;;94         // 协议层数据结构初始化
;;;95         CAN_PROTOCOL1_DataStructInit(&canProtocol1CB);
000002  4804              LDR      r0,|L6.20|
000004  f7fffffe          BL       CAN_PROTOCOL1_DataStructInit
;;;96     
;;;97         // 向驱动层注册数据接收接口
;;;98         // CAN_DRIVE_RegisterDataSendService(CAN_PROTOCOL1_MacProcess);
;;;99     
;;;100        // 向驱动层注册数据发送接口
;;;101        CAN_PROTOCOL1_RegisterDataSendService(CAN_DRIVE_AddTxArray);
000008  4803              LDR      r0,|L6.24|
00000a  f85deb04          POP      {lr}
00000e  f7ffbffe          B.W      CAN_PROTOCOL1_RegisterDataSendService
;;;102    }
;;;103    
                          ENDP

000012  0000              DCW      0x0000
                  |L6.20|
                          DCD      ||.bss||
                  |L6.24|
                          DCD      CAN_DRIVE_AddTxArray

                          AREA ||i.CAN_PROTOCOL1_MacProcess||, CODE, READONLY, ALIGN=2

                  CAN_PROTOCOL1_MacProcess PROC
;;;221    // UART报文接收处理函数(注意根据具体模块修改)
;;;222    void CAN_PROTOCOL1_MacProcess(uint32 standarID, uint8 *pData, uint16 length)
000000  b5f0              PUSH     {r4-r7,lr}
;;;223    {
;;;224        uint16 end = canProtocol1CB.rxFIFO.end;
000002  4b17              LDR      r3,|L7.96|
000004  f8b350ca          LDRH     r5,[r3,#0xca]  ; canProtocol1CB
;;;225        uint16 head = canProtocol1CB.rxFIFO.head;
000008  f8b360c8          LDRH     r6,[r3,#0xc8]  ; canProtocol1CB
;;;226        uint16 i = 0;
00000c  2000              MOVS     r0,#0
;;;227        uint8 *rxdata = pData;
;;;228    
;;;229        // ■■环形列队，入队■■
;;;230        //  一级缓冲区已满，不予接收
;;;231        if ((end + 1) % CAN_PROTOCOL1_RX_FIFO_SIZE == head)
00000e  1c6d              ADDS     r5,r5,#1
000010  24c8              MOVS     r4,#0xc8
000012  fbb5f7f4          UDIV     r7,r5,r4
000016  fb045517          MLS      r5,r4,r7,r5
00001a  42b5              CMP      r5,r6
00001c  d01e              BEQ      |L7.92|
00001e  e01b              B        |L7.88|
                  |L7.32|
;;;232        {
;;;233            return;
;;;234        }
;;;235    
;;;236        for (i = 0; i < length; i++)
;;;237        {
;;;238            // 单个字节读取，并放入FIFO中
;;;239            canProtocol1CB.rxFIFO.buff[canProtocol1CB.rxFIFO.end] = *rxdata++;
000020  f8115b01          LDRB     r5,[r1],#1
000024  f8b370ca          LDRH     r7,[r3,#0xca]  ; canProtocol1CB
000028  55dd              STRB     r5,[r3,r7]
;;;240    
;;;241            canProtocol1CB.rxFIFO.end++;
00002a  f8335fca          LDRH     r5,[r3,#0xca]!  ; canProtocol1CB
00002e  1c6d              ADDS     r5,r5,#1
000030  801d              STRH     r5,[r3,#0]
;;;242    
;;;243            // 一级缓冲区已满，不予接收
;;;244            if ((canProtocol1CB.rxFIFO.end + 1) % CAN_PROTOCOL1_RX_FIFO_SIZE == head)
000032  f83359ca          LDRH     r5,[r3],#-0xca  ; canProtocol1CB
000036  1c6d              ADDS     r5,r5,#1
000038  fbb5f7f4          UDIV     r7,r5,r4
00003c  fb045517          MLS      r5,r4,r7,r5
000040  42b5              CMP      r5,r6
000042  d00b              BEQ      |L7.92|
;;;245            {
;;;246                break;
;;;247            }
;;;248    
;;;249            canProtocol1CB.rxFIFO.end %= CAN_PROTOCOL1_RX_FIFO_SIZE;
000044  f8b350ca          LDRH     r5,[r3,#0xca]  ; canProtocol1CB
000048  fbb5f7f4          UDIV     r7,r5,r4
00004c  fb045517          MLS      r5,r4,r7,r5
000050  f8a350ca          STRH     r5,[r3,#0xca]
000054  1c40              ADDS     r0,r0,#1              ;236
000056  b280              UXTH     r0,r0                 ;236
                  |L7.88|
000058  4290              CMP      r0,r2                 ;236
00005a  d3e1              BCC      |L7.32|
                  |L7.92|
;;;250        }
;;;251    }
00005c  bdf0              POP      {r4-r7,pc}
;;;252    
                          ENDP

00005e  0000              DCW      0x0000
                  |L7.96|
                          DCD      ||.bss||

                          AREA ||i.CAN_PROTOCOL1_RegisterDataSendService||, CODE, READONLY, ALIGN=2

                  CAN_PROTOCOL1_RegisterDataSendService PROC
;;;253    // UART协议层向驱动层注册数据发送接口
;;;254    void CAN_PROTOCOL1_RegisterDataSendService(BOOL (*service)(uint32 id, uint8 *pData, uint8 length))
000000  4901              LDR      r1,|L8.8|
;;;255    {
;;;256        canProtocol1CB.sendDataThrowService = service;
000002  f8c106e0          STR      r0,[r1,#0x6e0]  ; canProtocol1CB
;;;257    }
000006  4770              BX       lr
;;;258    
                          ENDP

                  |L8.8|
                          DCD      ||.bss||

                          AREA ||i.CAN_PROTOCOL1_RxFIFOProcess||, CODE, READONLY, ALIGN=1

                  CAN_PROTOCOL1_RxFIFOProcess PROC
;;;318    // 一级接收缓冲区处理，从一级接收缓冲区中取出一个字节添加到命令帧缓冲区中
;;;319    void CAN_PROTOCOL1_RxFIFOProcess(CAN_PROTOCOL1_CB *pCB)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;320    {
000004  4604              MOV      r4,r0
;;;321        uint16 end = pCB->rxFIFO.end;
000006  f8b410ca          LDRH     r1,[r4,#0xca]
;;;322        uint16 head = pCB->rxFIFO.head;
00000a  f8b400c8          LDRH     r0,[r4,#0xc8]
;;;323        CAN_PROTOCOL1_RX_CMD_FRAME *pCmdFrame = NULL;
;;;324        uint16 length = 0;
;;;325        uint8 currentData = 0;
;;;326    
;;;327        // 参数合法性检验
;;;328        if (NULL == pCB)
00000e  2c00              CMP      r4,#0
000010  d021              BEQ      |L9.86|
;;;329        {
;;;330            return;
;;;331        }
;;;332    
;;;333        // 一级缓冲区为空，退出
;;;334        if (head == end)
000012  4288              CMP      r0,r1
000014  d01f              BEQ      |L9.86|
;;;335        {
;;;336            return;
;;;337        }
;;;338    
;;;339        // 获取临时缓冲区指针
;;;340        pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.end];
000016  f8b423d2          LDRH     r2,[r4,#0x3d2]
00001a  204d              MOVS     r0,#0x4d
00001c  4350              MULS     r0,r2,r0
00001e  eb040540          ADD      r5,r4,r0,LSL #1
000022  35ce              ADDS     r5,r5,#0xce
;;;341        // 取出当前要处理的字节
;;;342        currentData = pCB->rxFIFO.buff[pCB->rxFIFO.currentProcessIndex];
000024  f8b400cc          LDRH     r0,[r4,#0xcc]
000028  5c20              LDRB     r0,[r4,r0]
;;;343    
;;;344        // 临时缓冲区长度为0时，搜索首字节
;;;345        if (0 == pCmdFrame->length)
00002a  f8b53098          LDRH     r3,[r5,#0x98]
;;;346        {
;;;347            // 命令头错误，删除当前字节并退出
;;;348            if (CAN_PROTOCOL1_CMD_HEAD != currentData)
;;;349            {
;;;350                pCB->rxFIFO.head++;
;;;351                pCB->rxFIFO.head %= CAN_PROTOCOL1_RX_FIFO_SIZE;
00002e  27c8              MOVS     r7,#0xc8
000030  b19b              CBZ      r3,|L9.90|
;;;352                pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;353    
;;;354                return;
;;;355            }
;;;356    
;;;357            // 命令头正确，但无临时缓冲区可用，退出
;;;358            if ((pCB->rx.end + 1) % CAN_PROTOCOL1_RX_QUEUE_SIZE == pCB->rx.head)
;;;359            {
;;;360                return;
;;;361            }
;;;362    
;;;363            // 添加UART通讯超时时间设置-2016.1.5增加
;;;364    #if CAN_PROTOCOL1_RX_TIME_OUT_CHECK_ENABLE
;;;365            TIMER_AddTask(TIMER_ID_UART_RX_TIME_OUT_CONTROL,
;;;366                          CAN_PROTOCOL1_BUS_UNIDIRECTIONAL_TIME_OUT,
;;;367                          CAN_PROTOCOL1_CALLBACK_RxTimeOut,
;;;368                          0,
;;;369                          1,
;;;370                          ACTION_MODE_ADD_TO_QUEUE);
;;;371    #endif
;;;372    
;;;373            // 命令头正确，有临时缓冲区可用，则将其添加到命令帧临时缓冲区中
;;;374            pCmdFrame->buff[pCmdFrame->length++] = currentData;
;;;375            pCB->rxFIFO.currentProcessIndex++;
;;;376            pCB->rxFIFO.currentProcessIndex %= CAN_PROTOCOL1_RX_FIFO_SIZE;
;;;377        }
;;;378        // 非首字节，将数据添加到命令帧临时缓冲区中，但暂不删除当前数据
;;;379        else
;;;380        {
;;;381            // 临时缓冲区溢出，说明当前正在接收的命令帧是错误的，正确的命令帧不会出现长度溢出的情况
;;;382            if (pCmdFrame->length >= CAN_PROTOCOL1_RX_CMD_FRAME_LENGTH_MAX)
000032  f04f0800          MOV      r8,#0
000036  2b96              CMP      r3,#0x96
000038  d37e              BCC      |L9.312|
;;;383            {
;;;384    #if CAN_PROTOCOL1_RX_TIME_OUT_CHECK_ENABLE
;;;385                // 停止RX通讯超时检测
;;;386                CAN_PROTOCOL1_StopRxTimeOutCheck();
;;;387    #endif
;;;388    
;;;389                // 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;390                pCmdFrame->length = 0; // 2016.1.5增加
00003a  f8a58098          STRH     r8,[r5,#0x98]
;;;391                // 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;392                pCB->rxFIFO.head++;
00003e  f8340fc8          LDRH     r0,[r4,#0xc8]!
000042  1c40              ADDS     r0,r0,#1
000044  8020              STRH     r0,[r4,#0]
;;;393                pCB->rxFIFO.head %= CAN_PROTOCOL1_RX_FIFO_SIZE;
000046  8820              LDRH     r0,[r4,#0]
000048  fbb0f1f7          UDIV     r1,r0,r7
00004c  fb070011          MLS      r0,r7,r1,r0
000050  8020              STRH     r0,[r4,#0]
;;;394                pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
000052  8820              LDRH     r0,[r4,#0]
000054  80a0              STRH     r0,[r4,#4]
                  |L9.86|
;;;395    
;;;396                return;
;;;397            }
;;;398    
;;;399            // 一直取到末尾
;;;400            while (end != pCB->rxFIFO.currentProcessIndex)
;;;401            {
;;;402                // 取出当前要处理的字节
;;;403                currentData = pCB->rxFIFO.buff[pCB->rxFIFO.currentProcessIndex];
;;;404                // 缓冲区未溢出，正常接收，将数据添加到临时缓冲区中
;;;405                pCmdFrame->buff[pCmdFrame->length++] = currentData;
;;;406                pCB->rxFIFO.currentProcessIndex++;
;;;407                pCB->rxFIFO.currentProcessIndex %= CAN_PROTOCOL1_RX_FIFO_SIZE;
;;;408    
;;;409                // ■■接下来，需要检查命令帧是否完整，如果完整，则将命令帧临时缓冲区扶正■■
;;;410    
;;;411                // 首先判断命令帧最小长度，一个完整的命令字至少包括8个字节: 命令头、设备地址、命令字、数据长度、校验和L、校验和H、结束标识0xD、结束标识OxA，因此不足8个字节的必定不完整
;;;412                if (pCmdFrame->length < CAN_PROTOCOL1_CMD_FRAME_LENGTH_MIN)
;;;413                {
;;;414                    // 继续接收
;;;415                    continue;
;;;416                }
;;;417    
;;;418                // 命令帧长度数值越界，说明当前命令帧错误，停止接收
;;;419                if (pCmdFrame->buff[CAN_PROTOCOL1_CMD_LENGTH_INDEX] > CAN_PROTOCOL1_RX_CMD_FRAME_LENGTH_MAX - CAN_PROTOCOL1_CMD_FRAME_LENGTH_MIN)
;;;420                {
;;;421    #if CAN_PROTOCOL1_RX_TIME_OUT_CHECK_ENABLE
;;;422                    // 停止RX通讯超时检测
;;;423                    CAN_PROTOCOL1_StopRxTimeOutCheck();
;;;424    #endif
;;;425    
;;;426                    // 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;427                    pCmdFrame->length = 0;
;;;428                    // 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;429                    pCB->rxFIFO.head++;
;;;430                    pCB->rxFIFO.head %= CAN_PROTOCOL1_RX_FIFO_SIZE;
;;;431                    pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;432    
;;;433                    return;
;;;434                }
;;;435    
;;;436                // 命令帧长度校验，在命令长度描述字的数值上，增加命令头、设备地址、命令字、数据长度、校验和L、校验和H、结束标识0xD、结束标识OxA，即为命令帧实际长度
;;;437                length = pCmdFrame->length;
;;;438                if (length < pCmdFrame->buff[CAN_PROTOCOL1_CMD_LENGTH_INDEX] + CAN_PROTOCOL1_CMD_FRAME_LENGTH_MIN)
;;;439                {
;;;440                    // 长度要求不一致，说明未接收完毕，退出继续
;;;441                    continue;
;;;442                }
;;;443    
;;;444                // 命令帧长度OK，则进行校验，失败时删除命令头
;;;445                if (!CAN_PROTOCOL1_CheckSUM(pCmdFrame))
;;;446                {
;;;447    #if CAN_PROTOCOL1_RX_TIME_OUT_CHECK_ENABLE
;;;448                    // 停止RX通讯超时检测
;;;449                    CAN_PROTOCOL1_StopRxTimeOutCheck();
;;;450    #endif
;;;451    
;;;452                    // 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;453                    pCmdFrame->length = 0;
;;;454                    // 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;455                    pCB->rxFIFO.head++;
;;;456                    pCB->rxFIFO.head %= CAN_PROTOCOL1_RX_FIFO_SIZE;
;;;457                    pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;458    
;;;459                    return;
;;;460                }
;;;461    
;;;462    #if CAN_PROTOCOL1_RX_TIME_OUT_CHECK_ENABLE
;;;463                // 停止RX通讯超时检测
;;;464                CAN_PROTOCOL1_StopRxTimeOutCheck();
;;;465    #endif
;;;466    
;;;467                // 执行到这里，即说明接收到了一个完整并且正确的命令帧，此时需将处理过的数据从一级缓冲区中删除，并将该命令帧扶正
;;;468                pCB->rxFIFO.head += length;
;;;469                pCB->rxFIFO.head %= CAN_PROTOCOL1_RX_FIFO_SIZE;
;;;470                pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;471                CAN_PROTOCOL1_ConfirmTempCmdFrameBuff(pCB);
;;;472    
;;;473                return;
;;;474            }
;;;475        }
;;;476    }
000056  e8bd81f0          POP      {r4-r8,pc}
                  |L9.90|
00005a  283a              CMP      r0,#0x3a              ;348
00005c  d00c              BEQ      |L9.120|
00005e  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;350
000062  1c40              ADDS     r0,r0,#1              ;350
000064  8020              STRH     r0,[r4,#0]            ;350
000066  8820              LDRH     r0,[r4,#0]            ;351
000068  fbb0f1f7          UDIV     r1,r0,r7              ;351
00006c  fb070011          MLS      r0,r7,r1,r0           ;351
000070  8020              STRH     r0,[r4,#0]            ;351
000072  8820              LDRH     r0,[r4,#0]            ;352
000074  80a0              STRH     r0,[r4,#4]            ;352
000076  e7ee              B        |L9.86|
                  |L9.120|
000078  1c52              ADDS     r2,r2,#1              ;358
00007a  2105              MOVS     r1,#5                 ;358
00007c  fbb2f3f1          UDIV     r3,r2,r1              ;358
000080  fb012113          MLS      r1,r1,r3,r2           ;358
000084  f8b423d0          LDRH     r2,[r4,#0x3d0]        ;358
000088  4291              CMP      r1,r2                 ;358
00008a  d0e4              BEQ      |L9.86|
00008c  2101              MOVS     r1,#1                 ;374
00008e  f8a51098          STRH     r1,[r5,#0x98]         ;374
000092  70a8              STRB     r0,[r5,#2]            ;374
000094  f8340fcc          LDRH     r0,[r4,#0xcc]!        ;375
000098  1c40              ADDS     r0,r0,#1              ;375
00009a  b280              UXTH     r0,r0                 ;375
00009c  fbb0f1f7          UDIV     r1,r0,r7              ;376
0000a0  fb070011          MLS      r0,r7,r1,r0           ;376
0000a4  8020              STRH     r0,[r4,#0]            ;376
0000a6  e7d6              B        |L9.86|
                  |L9.168|
0000a8  5c22              LDRB     r2,[r4,r0]            ;403
0000aa  f8b50098          LDRH     r0,[r5,#0x98]         ;405
0000ae  1c43              ADDS     r3,r0,#1              ;405
0000b0  4428              ADD      r0,r0,r5              ;405
0000b2  f8a53098          STRH     r3,[r5,#0x98]         ;405
0000b6  7082              STRB     r2,[r0,#2]            ;405
0000b8  f8b400cc          LDRH     r0,[r4,#0xcc]         ;406
0000bc  1c40              ADDS     r0,r0,#1              ;406
0000be  b280              UXTH     r0,r0                 ;406
0000c0  fbb0f2f7          UDIV     r2,r0,r7              ;407
0000c4  fb070012          MLS      r0,r7,r2,r0           ;407
0000c8  f8a400cc          STRH     r0,[r4,#0xcc]         ;407
0000cc  f8b56098          LDRH     r6,[r5,#0x98]         ;412
0000d0  2e08              CMP      r6,#8                 ;412
0000d2  d33b              BCC      |L9.332|
0000d4  7968              LDRB     r0,[r5,#5]            ;419
0000d6  288e              CMP      r0,#0x8e              ;419
0000d8  d90e              BLS      |L9.248|
0000da  f8a58098          STRH     r8,[r5,#0x98]         ;427
0000de  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;429
0000e2  1c40              ADDS     r0,r0,#1              ;429
0000e4  8020              STRH     r0,[r4,#0]            ;429
0000e6  8820              LDRH     r0,[r4,#0]            ;430
0000e8  fbb0f1f7          UDIV     r1,r0,r7              ;430
0000ec  fb070011          MLS      r0,r7,r1,r0           ;430
0000f0  8020              STRH     r0,[r4,#0]            ;430
0000f2  8820              LDRH     r0,[r4,#0]            ;431
0000f4  80a0              STRH     r0,[r4,#4]            ;431
0000f6  e7ae              B        |L9.86|
                  |L9.248|
0000f8  3008              ADDS     r0,r0,#8              ;438
0000fa  42b0              CMP      r0,r6                 ;438
0000fc  d826              BHI      |L9.332|
0000fe  4628              MOV      r0,r5                 ;445
000100  f7fffffe          BL       CAN_PROTOCOL1_CheckSUM
000104  b188              CBZ      r0,|L9.298|
000106  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;468
00010a  4430              ADD      r0,r0,r6              ;468
00010c  8020              STRH     r0,[r4,#0]            ;468
00010e  8820              LDRH     r0,[r4,#0]            ;469
000110  fbb0f1f7          UDIV     r1,r0,r7              ;469
000114  fb070011          MLS      r0,r7,r1,r0           ;469
000118  8020              STRH     r0,[r4,#0]            ;469
00011a  8820              LDRH     r0,[r4,#0]            ;470
00011c  80a0              STRH     r0,[r4,#4]            ;470
00011e  3cc8              SUBS     r4,r4,#0xc8           ;470
000120  4620              MOV      r0,r4                 ;471
000122  e8bd41f0          POP      {r4-r8,lr}            ;471
000126  f7ffbffe          B.W      CAN_PROTOCOL1_ConfirmTempCmdFrameBuff
                  |L9.298|
00012a  f8a58098          STRH     r8,[r5,#0x98]         ;453
00012e  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;455
000132  1c40              ADDS     r0,r0,#1              ;455
000134  8020              STRH     r0,[r4,#0]            ;455
000136  e000              B        |L9.314|
                  |L9.312|
000138  e008              B        |L9.332|
                  |L9.314|
00013a  8820              LDRH     r0,[r4,#0]            ;456
00013c  fbb0f1f7          UDIV     r1,r0,r7              ;456
000140  fb070011          MLS      r0,r7,r1,r0           ;456
000144  8020              STRH     r0,[r4,#0]            ;456
000146  8820              LDRH     r0,[r4,#0]            ;457
000148  80a0              STRH     r0,[r4,#4]            ;457
00014a  e784              B        |L9.86|
                  |L9.332|
00014c  f8b400cc          LDRH     r0,[r4,#0xcc]         ;400
000150  4288              CMP      r0,r1                 ;400
000152  d1a9              BNE      |L9.168|
000154  e77f              B        |L9.86|
;;;477    
                          ENDP


                          AREA ||i.CAN_PROTOCOL1_SendCmdNoResult||, CODE, READONLY, ALIGN=1

                  CAN_PROTOCOL1_SendCmdNoResult PROC
;;;847    // 发送命令无结果
;;;848    void CAN_PROTOCOL1_SendCmdNoResult(uint8 cmdWord)
000000  b510              PUSH     {r4,lr}
;;;849    {
000002  4604              MOV      r4,r0
;;;850        // 添加命令头
;;;851        CAN_PROTOCOL1_TxAddData(CAN_PROTOCOL1_CMD_HEAD);
000004  203a              MOVS     r0,#0x3a
000006  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;852    
;;;853        // 添加设备地址
;;;854        CAN_PROTOCOL1_TxAddData(CAN_PROTOCOL1_CMD_DEVICE_ADDR);
00000a  201a              MOVS     r0,#0x1a
00000c  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;855    
;;;856        // 添加命令字
;;;857        CAN_PROTOCOL1_TxAddData(cmdWord);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;858    
;;;859        CAN_PROTOCOL1_TxAddData(0); // 数据长度
000016  2000              MOVS     r0,#0
000018  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;860    
;;;861        CAN_PROTOCOL1_TxAddFrame();
00001c  e8bd4010          POP      {r4,lr}
000020  f7ffbffe          B.W      CAN_PROTOCOL1_TxAddFrame
;;;862    }
;;;863    
                          ENDP


                          AREA ||i.CAN_PROTOCOL1_SendCmdWithResult||, CODE, READONLY, ALIGN=1

                  CAN_PROTOCOL1_SendCmdWithResult PROC
;;;804    // 发送命令带结果
;;;805    void CAN_PROTOCOL1_SendCmdWithResult(uint8 cmdWord, uint8 result)
000000  b530              PUSH     {r4,r5,lr}
;;;806    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;807        // 添加命令头
;;;808        CAN_PROTOCOL1_TxAddData(CAN_PROTOCOL1_CMD_HEAD);
000006  203a              MOVS     r0,#0x3a
000008  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;809    
;;;810        // 添加设备地址
;;;811        CAN_PROTOCOL1_TxAddData(CAN_PROTOCOL1_CMD_DEVICE_ADDR);
00000c  201a              MOVS     r0,#0x1a
00000e  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;812    
;;;813        // 添加命令字
;;;814        CAN_PROTOCOL1_TxAddData(cmdWord);
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;815    
;;;816        // 添加数据长度
;;;817        CAN_PROTOCOL1_TxAddData(1);
000018  2001              MOVS     r0,#1
00001a  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;818    
;;;819        CAN_PROTOCOL1_TxAddData(result);
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;820    
;;;821        CAN_PROTOCOL1_TxAddFrame();
000024  e8bd4030          POP      {r4,r5,lr}
000028  f7ffbffe          B.W      CAN_PROTOCOL1_TxAddFrame
;;;822    }
;;;823    
                          ENDP


                          AREA ||i.CAN_PROTOCOL1_SendCmdWith_TwoResult||, CODE, READONLY, ALIGN=1

                  CAN_PROTOCOL1_SendCmdWith_TwoResult PROC
;;;824    // 发送命令带两个结果
;;;825    void CAN_PROTOCOL1_SendCmdWith_TwoResult(uint8 cmdWord, uint8 result, uint8 two_result)
000000  b570              PUSH     {r4-r6,lr}
;;;826    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;827        // 添加命令头
;;;828        CAN_PROTOCOL1_TxAddData(CAN_PROTOCOL1_CMD_HEAD);
000008  203a              MOVS     r0,#0x3a
00000a  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;829    
;;;830        // 添加设备地址
;;;831        CAN_PROTOCOL1_TxAddData(CAN_PROTOCOL1_CMD_DEVICE_ADDR);
00000e  201a              MOVS     r0,#0x1a
000010  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;832    
;;;833        // 添加命令字
;;;834        CAN_PROTOCOL1_TxAddData(cmdWord);
000014  4630              MOV      r0,r6
000016  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;835    
;;;836        // 添加数据长度
;;;837        CAN_PROTOCOL1_TxAddData(2);
00001a  2002              MOVS     r0,#2
00001c  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;838    
;;;839        CAN_PROTOCOL1_TxAddData(result);
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;840    
;;;841        CAN_PROTOCOL1_TxAddData(two_result);
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;842    
;;;843        CAN_PROTOCOL1_TxAddFrame();
00002c  e8bd4070          POP      {r4-r6,lr}
000030  f7ffbffe          B.W      CAN_PROTOCOL1_TxAddFrame
;;;844    }
;;;845    
                          ENDP


                          AREA ||i.CAN_PROTOCOL1_SendLdoV||, CODE, READONLY, ALIGN=1

                  CAN_PROTOCOL1_SendLdoV PROC
;;;781    // 发送命令带结果
;;;782    void CAN_PROTOCOL1_SendLdoV(uint8 cmdWord, uint32 result)
000000  b530              PUSH     {r4,r5,lr}
;;;783    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;784        // 添加命令头
;;;785        CAN_PROTOCOL1_TxAddData(CAN_PROTOCOL1_CMD_HEAD);
000006  203a              MOVS     r0,#0x3a
000008  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;786    
;;;787        // 添加设备地址
;;;788        CAN_PROTOCOL1_TxAddData(CAN_PROTOCOL1_CMD_DEVICE_ADDR);
00000c  201a              MOVS     r0,#0x1a
00000e  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;789    
;;;790        // 添加命令字
;;;791        CAN_PROTOCOL1_TxAddData(cmdWord);
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;792    
;;;793        // 添加数据长度
;;;794        CAN_PROTOCOL1_TxAddData(4);
000018  2004              MOVS     r0,#4
00001a  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;795    
;;;796        CAN_PROTOCOL1_TxAddData((result >> 24) & 0xFF);
00001e  0e20              LSRS     r0,r4,#24
000020  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;797        CAN_PROTOCOL1_TxAddData((result >> 16) & 0xFF);
000024  f3c44007          UBFX     r0,r4,#16,#8
000028  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;798        CAN_PROTOCOL1_TxAddData((result >> 8) & 0xFF);
00002c  f3c42007          UBFX     r0,r4,#8,#8
000030  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;799        CAN_PROTOCOL1_TxAddData((result >> 0) & 0xFF);
000034  b2e0              UXTB     r0,r4
000036  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;800    
;;;801        CAN_PROTOCOL1_TxAddFrame();
00003a  e8bd4030          POP      {r4,r5,lr}
00003e  f7ffbffe          B.W      CAN_PROTOCOL1_TxAddFrame
;;;802    }
;;;803    
                          ENDP


                          AREA ||i.CAN_PROTOCOL1_StartTimeoutCheckTask||, CODE, READONLY, ALIGN=1

                  CAN_PROTOCOL1_StartTimeoutCheckTask PROC
;;;81     // 启动通讯超时判断任务
;;;82     void CAN_PROTOCOL1_StartTimeoutCheckTask(void)
000000  4770              BX       lr
;;;83     {
;;;84     }
;;;85     
                          ENDP


                          AREA ||i.CAN_PROTOCOL1_TxAddData||, CODE, READONLY, ALIGN=2

                  CAN_PROTOCOL1_TxAddData PROC
;;;117    // 向发送命令帧队列中添加数据
;;;118    void CAN_PROTOCOL1_TxAddData(uint8 data)
000000  b530              PUSH     {r4,r5,lr}
;;;119    {
;;;120        uint16 head = canProtocol1CB.tx.head;
000002  490f              LDR      r1,|L15.64|
000004  f8b146d6          LDRH     r4,[r1,#0x6d6]  ; canProtocol1CB
;;;121        uint16 end = canProtocol1CB.tx.end;
000008  f8b126d8          LDRH     r2,[r1,#0x6d8]  ; canProtocol1CB
;;;122        CAN_PROTOCOL1_TX_CMD_FRAME *pCmdFrame = &canProtocol1CB.tx.cmdQueue[canProtocol1CB.tx.end];
00000c  234d              MOVS     r3,#0x4d
00000e  4353              MULS     r3,r2,r3
000010  eb010143          ADD      r1,r1,r3,LSL #1
000014  f5017175          ADD      r1,r1,#0x3d4
;;;123    
;;;124        // 发送缓冲区已满，不予接收
;;;125        if ((end + 1) % CAN_PROTOCOL1_TX_QUEUE_SIZE == head)
000018  1c52              ADDS     r2,r2,#1
00001a  2305              MOVS     r3,#5
00001c  fbb2f5f3          UDIV     r5,r2,r3
000020  fb032215          MLS      r2,r3,r5,r2
000024  42a2              CMP      r2,r4
000026  d009              BEQ      |L15.60|
;;;126        {
;;;127            return;
;;;128        }
;;;129    
;;;130        // 队尾命令帧已满，退出
;;;131        if (pCmdFrame->length >= CAN_PROTOCOL1_TX_CMD_FRAME_LENGTH_MAX)
000028  f8b12098          LDRH     r2,[r1,#0x98]
00002c  2a96              CMP      r2,#0x96
00002e  d205              BCS      |L15.60|
;;;132        {
;;;133            return;
;;;134        }
;;;135    
;;;136        // 数据添加到帧末尾，并更新帧长度
;;;137        pCmdFrame->buff[pCmdFrame->length] = data;
000030  1c8b              ADDS     r3,r1,#2
000032  54d0              STRB     r0,[r2,r3]
;;;138        pCmdFrame->length++;
000034  f8310f98          LDRH     r0,[r1,#0x98]!
000038  1c40              ADDS     r0,r0,#1
00003a  8008              STRH     r0,[r1,#0]
                  |L15.60|
;;;139    }
00003c  bd30              POP      {r4,r5,pc}
;;;140    
                          ENDP

00003e  0000              DCW      0x0000
                  |L15.64|
                          DCD      ||.bss||

                          AREA ||i.CAN_PROTOCOL1_TxAddFrame||, CODE, READONLY, ALIGN=2

                  CAN_PROTOCOL1_TxAddFrame PROC
;;;141    // 确认添加命令帧，即承认之前填充的数据为命令帧，将其添加到发送队列中，由main进行调度发送，本函数内会自动校正命令长度，并添加校验码
;;;142    void CAN_PROTOCOL1_TxAddFrame(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;143    {
;;;144        uint16 checkSum = 0;
000002  2300              MOVS     r3,#0
;;;145        uint16 i = 0;
;;;146        uint16 head = canProtocol1CB.tx.head;
000004  4c2d              LDR      r4,|L16.188|
000006  f8b466d6          LDRH     r6,[r4,#0x6d6]  ; canProtocol1CB
;;;147        uint16 end = canProtocol1CB.tx.end;
00000a  f8b426d8          LDRH     r2,[r4,#0x6d8]  ; canProtocol1CB
;;;148        CAN_PROTOCOL1_TX_CMD_FRAME *pCmdFrame = &canProtocol1CB.tx.cmdQueue[canProtocol1CB.tx.end];
00000e  204d              MOVS     r0,#0x4d
000010  4350              MULS     r0,r2,r0
000012  eb040040          ADD      r0,r4,r0,LSL #1
000016  f5007075          ADD      r0,r0,#0x3d4
;;;149        uint16 length = pCmdFrame->length;
00001a  f8b01098          LDRH     r1,[r0,#0x98]
;;;150    
;;;151        // 发送缓冲区已满，不予接收
;;;152        if ((end + 1) % CAN_PROTOCOL1_TX_QUEUE_SIZE == head)
00001e  1c52              ADDS     r2,r2,#1
000020  2505              MOVS     r5,#5
000022  fbb2f7f5          UDIV     r7,r2,r5
000026  fb052217          MLS      r2,r5,r7,r2
00002a  42b2              CMP      r2,r6
00002c  d004              BEQ      |L16.56|
;;;153        {
;;;154            return;
;;;155        }
;;;156    
;;;157        // 命令帧长度不足，清除已填充的数据，退出
;;;158        if (CAN_PROTOCOL1_CMD_FRAME_LENGTH_MIN - 4 > length) // 减去"校验和L、校验和H、结束标识0xD、结束标识OxA"4个字节
00002e  2904              CMP      r1,#4
000030  d203              BCS      |L16.58|
;;;159        {
;;;160            pCmdFrame->length = 0;
000032  2100              MOVS     r1,#0
000034  f8a01098          STRH     r1,[r0,#0x98]
                  |L16.56|
;;;161    
;;;162            return;
;;;163        }
;;;164    
;;;165        // 队尾命令帧已满，退出
;;;166        if ((length >= CAN_PROTOCOL1_TX_CMD_FRAME_LENGTH_MAX) || (length + 1 >= CAN_PROTOCOL1_TX_CMD_FRAME_LENGTH_MAX) || (length + 2 >= CAN_PROTOCOL1_TX_CMD_FRAME_LENGTH_MAX) || (length + 3 >= CAN_PROTOCOL1_TX_CMD_FRAME_LENGTH_MAX))
;;;167        {
;;;168            return;
;;;169        }
;;;170    
;;;171        // 重新设置数据长度，系统在准备数据时，填充的"数据长度"可以为任意值，并且不需要添加校验码，在这里重新设置为正确的值
;;;172        pCmdFrame->buff[CAN_PROTOCOL1_CMD_LENGTH_INDEX] = length - 4; // 重设数据长度，减去"命令头、设备地址、命令字、数据长度"4个字节
;;;173        for (i = 1; i < length; i++)
;;;174        {
;;;175            checkSum += pCmdFrame->buff[i];
;;;176        }
;;;177        pCmdFrame->buff[pCmdFrame->length++] = (checkSum & 0x00FF);        // 低字节在前
;;;178        pCmdFrame->buff[pCmdFrame->length++] = ((checkSum >> 8) & 0x00FF); // 高字节在后
;;;179    
;;;180        // 结束标识
;;;181        pCmdFrame->buff[pCmdFrame->length++] = 0x0D;
;;;182        pCmdFrame->buff[pCmdFrame->length++] = 0x0A;
;;;183    
;;;184        canProtocol1CB.tx.end++;
;;;185        canProtocol1CB.tx.end %= CAN_PROTOCOL1_TX_QUEUE_SIZE;
;;;186        // pCB->tx.cmdQueue[pCB->tx.end].length = 0;   //2015.12.2修改
;;;187    }
000038  bdf0              POP      {r4-r7,pc}
                  |L16.58|
00003a  2996              CMP      r1,#0x96              ;166
00003c  d2fc              BCS      |L16.56|
00003e  1c4a              ADDS     r2,r1,#1              ;166
000040  2a96              CMP      r2,#0x96              ;166
000042  d2f9              BCS      |L16.56|
000044  1c8a              ADDS     r2,r1,#2              ;166
000046  2a96              CMP      r2,#0x96              ;166
000048  d2f6              BCS      |L16.56|
00004a  1cca              ADDS     r2,r1,#3              ;166
00004c  2a96              CMP      r2,#0x96              ;166
00004e  d2f3              BCS      |L16.56|
000050  1f0a              SUBS     r2,r1,#4              ;172
000052  7142              STRB     r2,[r0,#5]            ;172
000054  2201              MOVS     r2,#1                 ;173
000056  e005              B        |L16.100|
                  |L16.88|
000058  1886              ADDS     r6,r0,r2              ;175
00005a  78b6              LDRB     r6,[r6,#2]            ;175
00005c  4433              ADD      r3,r3,r6              ;175
00005e  b29b              UXTH     r3,r3                 ;175
000060  1c52              ADDS     r2,r2,#1              ;173
000062  b292              UXTH     r2,r2                 ;173
                  |L16.100|
000064  428a              CMP      r2,r1                 ;173
000066  d3f7              BCC      |L16.88|
000068  f8b01098          LDRH     r1,[r0,#0x98]         ;177
00006c  1c4a              ADDS     r2,r1,#1              ;177
00006e  4401              ADD      r1,r1,r0              ;177
000070  f8a02098          STRH     r2,[r0,#0x98]         ;177
000074  708b              STRB     r3,[r1,#2]            ;177
000076  f8b01098          LDRH     r1,[r0,#0x98]         ;178
00007a  0a1b              LSRS     r3,r3,#8              ;178
00007c  1c4a              ADDS     r2,r1,#1              ;178
00007e  4401              ADD      r1,r1,r0              ;178
000080  f8a02098          STRH     r2,[r0,#0x98]         ;178
000084  708b              STRB     r3,[r1,#2]            ;178
000086  f8b01098          LDRH     r1,[r0,#0x98]         ;181
00008a  230d              MOVS     r3,#0xd               ;181
00008c  1c4a              ADDS     r2,r1,#1              ;181
00008e  4401              ADD      r1,r1,r0              ;181
000090  f8a02098          STRH     r2,[r0,#0x98]         ;181
000094  708b              STRB     r3,[r1,#2]            ;181
000096  f8b01098          LDRH     r1,[r0,#0x98]         ;182
00009a  230a              MOVS     r3,#0xa               ;182
00009c  1c4a              ADDS     r2,r1,#1              ;182
00009e  f8a02098          STRH     r2,[r0,#0x98]         ;182
0000a2  4408              ADD      r0,r0,r1              ;182
0000a4  7083              STRB     r3,[r0,#2]            ;182
0000a6  f8b406d8          LDRH     r0,[r4,#0x6d8]        ;184  ; canProtocol1CB
0000aa  1c40              ADDS     r0,r0,#1              ;184
0000ac  b280              UXTH     r0,r0                 ;184
0000ae  fbb0f1f5          UDIV     r1,r0,r5              ;185
0000b2  fb050011          MLS      r0,r5,r1,r0           ;185
0000b6  f8a406d8          STRH     r0,[r4,#0x6d8]        ;185
0000ba  bdf0              POP      {r4-r7,pc}
;;;188    
                          ENDP

                  |L16.188|
                          DCD      ||.bss||

                          AREA ||i.CAN_PROTOCOL1_TxStateProcess||, CODE, READONLY, ALIGN=2

                  CAN_PROTOCOL1_TxStateProcess PROC
;;;285    // 协议层发送处理过程
;;;286    void CAN_PROTOCOL1_TxStateProcess(void)
000000  b570              PUSH     {r4-r6,lr}
;;;287    {
;;;288        uint16 head = canProtocol1CB.tx.head;
000002  4c14              LDR      r4,|L17.84|
000004  f8b426d6          LDRH     r2,[r4,#0x6d6]  ; canProtocol1CB
;;;289        uint16 end = canProtocol1CB.tx.end;
000008  f8b436d8          LDRH     r3,[r4,#0x6d8]  ; canProtocol1CB
;;;290        uint16 length = canProtocol1CB.tx.cmdQueue[head].length;
00000c  204d              MOVS     r0,#0x4d
00000e  4350              MULS     r0,r2,r0
000010  eb040040          ADD      r0,r4,r0,LSL #1
000014  4605              MOV      r5,r0
000016  f8b0646c          LDRH     r6,[r0,#0x46c]
;;;291        uint8 *pCmd = canProtocol1CB.tx.cmdQueue[head].buff;
00001a  f20031d6          ADD      r1,r0,#0x3d6
;;;292        uint16 localDeviceID = canProtocol1CB.tx.cmdQueue[head].deviceID;
00001e  f8b003d4          LDRH     r0,[r0,#0x3d4]
;;;293    
;;;294        // 发送缓冲区为空，说明无数据
;;;295        if (head == end)
000022  429a              CMP      r2,r3
000024  d015              BEQ      |L17.82|
;;;296        {
;;;297            return;
;;;298        }
;;;299    
;;;300        // 发送函数没有注册直接返回
;;;301        if (NULL == canProtocol1CB.sendDataThrowService)
000026  f8d436e0          LDR      r3,[r4,#0x6e0]  ; canProtocol1CB
00002a  2b00              CMP      r3,#0
00002c  d011              BEQ      |L17.82|
;;;302        {
;;;303            return;
;;;304        }
;;;305    
;;;306        // 协议层有数据需要发送到驱动层
;;;307        if (!(*canProtocol1CB.sendDataThrowService)(localDeviceID, pCmd, length))
00002e  b2f2              UXTB     r2,r6
000030  4798              BLX      r3
000032  2800              CMP      r0,#0
000034  d00d              BEQ      |L17.82|
;;;308        {
;;;309            return;
;;;310        }
;;;311    
;;;312        // 发送环形队列更新位置
;;;313        canProtocol1CB.tx.cmdQueue[head].length = 0;
000036  2000              MOVS     r0,#0
000038  f8a5046c          STRH     r0,[r5,#0x46c]
;;;314        canProtocol1CB.tx.head++;
00003c  f8b406d6          LDRH     r0,[r4,#0x6d6]  ; canProtocol1CB
000040  1c40              ADDS     r0,r0,#1
000042  b280              UXTH     r0,r0
;;;315        canProtocol1CB.tx.head %= CAN_PROTOCOL1_TX_QUEUE_SIZE;
000044  2105              MOVS     r1,#5
000046  fbb0f2f1          UDIV     r2,r0,r1
00004a  fb010012          MLS      r0,r1,r2,r0
00004e  f8a406d6          STRH     r0,[r4,#0x6d6]
                  |L17.82|
;;;316    }
000052  bd70              POP      {r4-r6,pc}
;;;317    
                          ENDP

                  |L17.84|
                          DCD      ||.bss||

                          AREA ||i.CAN_PROTOCOL_Process||, CODE, READONLY, ALIGN=2

                  CAN_PROTOCOL_Process PROC
;;;104    // UART协议层过程处理
;;;105    void CAN_PROTOCOL_Process(void)
000000  b510              PUSH     {r4,lr}
;;;106    {
;;;107        // UART接收FIFO缓冲区处理
;;;108        CAN_PROTOCOL1_RxFIFOProcess(&canProtocol1CB);
000002  4805              LDR      r0,|L18.24|
000004  f7fffffe          BL       CAN_PROTOCOL1_RxFIFOProcess
;;;109    
;;;110        // UART接收命令缓冲区处理
;;;111        CAN_PROTOCOL1_CmdFrameProcess(&canProtocol1CB);
000008  4803              LDR      r0,|L18.24|
00000a  f7fffffe          BL       CAN_PROTOCOL1_CmdFrameProcess
;;;112    
;;;113        // UART协议层发送处理过程
;;;114        CAN_PROTOCOL1_TxStateProcess();
00000e  e8bd4010          POP      {r4,lr}
000012  f7ffbffe          B.W      CAN_PROTOCOL1_TxStateProcess
;;;115    }
;;;116    
                          ENDP

000016  0000              DCW      0x0000
                  |L18.24|
                          DCD      ||.bss||

                          AREA ||i.CanRxFrame_ToSts_Transmit||, CODE, READONLY, ALIGN=1

                  CanRxFrame_ToSts_Transmit PROC
;;;864    // 将来自CAN的数据帧通过DTA转发给STS
;;;865    void CanRxFrame_ToSts_Transmit(CAN_PROTOCOL1_RX_CMD_FRAME *pCmdFrame)
000000  b570              PUSH     {r4-r6,lr}
;;;866    {
000002  4605              MOV      r5,r0
;;;867        CAN_PROTOCOL1_RX_CMD_FRAME *pF = pCmdFrame;
;;;868        uint8 i = 0;
000004  2400              MOVS     r4,#0
000006  e005              B        |L19.20|
                  |L19.8|
;;;869        
;;;870    		//  写入数据
;;;871        for (i = 0; i < (pF->length - 1); i++)
;;;872        {
;;;873            STS_PROTOCOL_TxAddData(pF->buff[i]);
000008  1928              ADDS     r0,r5,r4
00000a  7880              LDRB     r0,[r0,#2]
00000c  f7fffffe          BL       STS_PROTOCOL_TxAddData
000010  1c64              ADDS     r4,r4,#1              ;871
000012  b2e4              UXTB     r4,r4                 ;871
                  |L19.20|
000014  f8b50098          LDRH     r0,[r5,#0x98]         ;871
000018  1e40              SUBS     r0,r0,#1              ;871
00001a  42a0              CMP      r0,r4                 ;871
00001c  dcf4              BGT      |L19.8|
;;;874        }
;;;875        
;;;876    		// 组装命令帧
;;;877        STS_PROTOCOL_TxAddFrame();
00001e  e8bd4070          POP      {r4-r6,lr}
000022  f7ffbffe          B.W      STS_PROTOCOL_TxAddFrame
;;;878    
;;;879    }
;;;880    
                          ENDP


                          AREA ||i.can_test||, CODE, READONLY, ALIGN=1

                  can_test PROC
;;;85     
;;;86     void can_test(uint32 temp)
000000  2100              MOVS     r1,#0
;;;87     {
;;;88         CAN_PROTOCOL1_SendCmdWithResult(0x88, FALSE);
000002  2088              MOVS     r0,#0x88
000004  f7ffbffe          B.W      CAN_PROTOCOL1_SendCmdWithResult
;;;89     }
;;;90     
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  canProtocol1CB
                          %        1764

                          AREA ||.data||, DATA, ALIGN=0

                  can_light_cnt
000000  00                DCB      0x00
                  can_left_light_cnt
000001  00                DCB      0x00
                  can_right_light_cnt
000002  00                DCB      0x00
                  can_cali_cnt
000003  00                DCB      0x00
                  can_brake_cnt
000004  00                DCB      0x00
                  can_throttleAd_cnt
000005  00                DCB      0x00

                          AREA ||area_number.25||, DATA, ALIGN=0

                          EXPORTAS ||area_number.25||, ||.data||
                  can_cnt
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "User\\DutCanProtocol.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_DutCanProtocol_c_e3f9597c____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___16_DutCanProtocol_c_e3f9597c____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_DutCanProtocol_c_e3f9597c____REVSH|
#line 128
|__asm___16_DutCanProtocol_c_e3f9597c____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
