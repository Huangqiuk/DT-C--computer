; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\dutcandrive.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\dutcandrive.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -I.\User\qrencode -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.3\Device\Include -D__MICROLIB -D__UVISION_VERSION=539 -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\dutcandrive.crf User\DutCanDrive.c]
                          THUMB

                          AREA ||i.CAN_AddSum||, CODE, READONLY, ALIGN=1

                  CAN_AddSum PROC
;;;664    // 对传入的命令帧进行校验，返回校验结果
;;;665    BOOL CAN_AddSum(uint8 *buff, uint32 len)
000000  b510              PUSH     {r4,lr}
;;;666    {
;;;667        uint8 cc = 0;
000002  2300              MOVS     r3,#0
;;;668        uint16 i = 0;
000004  2200              MOVS     r2,#0
;;;669    
;;;670        if (NULL == buff)
000006  2800              CMP      r0,#0
000008  d104              BNE      |L1.20|
;;;671        {
;;;672            return FALSE;
;;;673        }
;;;674    
;;;675        // 从命令头开始，到校验码之前的一个字节，依次进行异或运算
;;;676        for (i = 0; i < len; i++)
;;;677        {
;;;678            cc ^= buff[i];
;;;679        }
;;;680    
;;;681        cc = ~cc;
;;;682    
;;;683        // 添加校验码
;;;684        buff[len] = cc;
;;;685    
;;;686        return TRUE;
;;;687    }
00000a  bd10              POP      {r4,pc}
                  |L1.12|
00000c  5c84              LDRB     r4,[r0,r2]            ;678
00000e  4063              EORS     r3,r3,r4              ;678
000010  1c52              ADDS     r2,r2,#1              ;676
000012  b292              UXTH     r2,r2                 ;676
                  |L1.20|
000014  428a              CMP      r2,r1                 ;676
000016  d3f9              BCC      |L1.12|
000018  43da              MVNS     r2,r3                 ;681
00001a  5442              STRB     r2,[r0,r1]            ;684
00001c  2001              MOVS     r0,#1                 ;686
00001e  bd10              POP      {r4,pc}
;;;688    
                          ENDP


                          AREA ||i.CAN_CheckSum||, CODE, READONLY, ALIGN=1

                  CAN_CheckSum PROC
;;;636    // 对传入的命令帧进行校验，返回校验结果
;;;637    BOOL CAN_CheckSum(uint8 *buff, uint32 len)
000000  b530              PUSH     {r4,r5,lr}
;;;638    {
;;;639        uint8 cc = 0;
000002  2300              MOVS     r3,#0
;;;640        uint16 i = 0;
000004  2200              MOVS     r2,#0
;;;641    
;;;642        if (NULL == buff)
000006  2800              CMP      r0,#0
000008  d001              BEQ      |L2.14|
;;;643        {
;;;644            return FALSE;
;;;645        }
;;;646    
;;;647        // 从命令头开始，到校验码之前的一个字节，依次进行异或运算
;;;648        for (i = 0; i < (len - CAN_CHECK_BYTE_SIZE); i++)
00000a  1e4c              SUBS     r4,r1,#1
00000c  e005              B        |L2.26|
                  |L2.14|
00000e  2000              MOVS     r0,#0                 ;644
;;;649        {
;;;650            cc ^= buff[i];
;;;651        }
;;;652    
;;;653        cc = ~cc;
;;;654    
;;;655        // 判断计算得到的校验码与命令帧中的校验码是否相同
;;;656        if (buff[len - 1] != cc)
;;;657        {
;;;658            return FALSE;
;;;659        }
;;;660    
;;;661        return TRUE;
;;;662    }
000010  bd30              POP      {r4,r5,pc}
                  |L2.18|
000012  5c85              LDRB     r5,[r0,r2]            ;650
000014  406b              EORS     r3,r3,r5              ;650
000016  1c52              ADDS     r2,r2,#1              ;648
000018  b292              UXTH     r2,r2                 ;648
                  |L2.26|
00001a  42a2              CMP      r2,r4                 ;648
00001c  d3f9              BCC      |L2.18|
00001e  43da              MVNS     r2,r3                 ;653
000020  b2d2              UXTB     r2,r2                 ;653
000022  4408              ADD      r0,r0,r1              ;656
000024  f8100c01          LDRB     r0,[r0,#-1]           ;656
000028  4290              CMP      r0,r2                 ;656
00002a  d001              BEQ      |L2.48|
00002c  2000              MOVS     r0,#0                 ;658
00002e  bd30              POP      {r4,r5,pc}
                  |L2.48|
000030  2001              MOVS     r0,#1                 ;661
000032  bd30              POP      {r4,r5,pc}
;;;663    
                          ENDP


                          AREA ||i.CAN_CmdFrameProcess||, CODE, READONLY, ALIGN=1

                  CAN_CmdFrameProcess PROC
;;;566    // CAN命令帧缓冲区处理
;;;567    void CAN_CmdFrameProcess(CAN_CB *pCB)
000000  b578              PUSH     {r3-r6,lr}
;;;568    {
;;;569        CAN_CMD cmd = IAP_CTRL_CAN_CMD_EMPTY;
;;;570        CAN_CMD_FRAME *pCmdFrame = NULL;
;;;571        uint8 sourceBuffSelect = CAN_DEVICE_SOURCE_ID_MAX;
;;;572        volatile uint32 temp = 0;
000002  2100              MOVS     r1,#0
000004  9100              STR      r1,[sp,#0]
;;;573        volatile uint16 length;
;;;574        volatile uint8 errStatus;
;;;575        volatile uint16 i;
;;;576    
;;;577        // 参数合法性检验
;;;578        if (NULL == pCB)
000006  2800              CMP      r0,#0
000008  d02e              BEQ      |L3.104|
;;;579        {
;;;580            return;
;;;581        }
;;;582    
;;;583        // 循环判断是否有数据需要处理
;;;584        for (sourceBuffSelect = 0; sourceBuffSelect < CAN_DEVICE_SOURCE_ID_MAX; sourceBuffSelect++)
;;;585        {
;;;586            // 命令帧缓冲区为空，退出
;;;587            if (pCB->rx.rxEachNode[sourceBuffSelect].head == pCB->rx.rxEachNode[sourceBuffSelect].end)
;;;588            {
;;;589                continue;
;;;590            }
;;;591    
;;;592            // 获取当前要处理的命令帧指针
;;;593            pCmdFrame = &pCB->rx.rxEachNode[sourceBuffSelect].cmdQueue[pCB->rx.rxEachNode[sourceBuffSelect].head];
;;;594    
;;;595            // 命令头非法，退出
;;;596            if (CAN_CMD_HEAD != pCmdFrame->buff[CAN_CMD_HEAD_INDEX])
;;;597            {
;;;598                // 删除命令帧
;;;599                pCB->rx.rxEachNode[sourceBuffSelect].head++;
;;;600                pCB->rx.rxEachNode[sourceBuffSelect].head %= CAN_RX_QUEUE_SIZE;
00000a  2528              MOVS     r5,#0x28
                  |L3.12|
00000c  f24052c9          MOV      r2,#0x5c9             ;587
000010  434a              MULS     r2,r1,r2              ;587
000012  eb000382          ADD      r3,r0,r2,LSL #2       ;587
000016  461c              MOV      r4,r3                 ;587
000018  f5035380          ADD      r3,r3,#0x1000         ;587
00001c  f8b327b4          LDRH     r2,[r3,#0x7b4]        ;587
000020  f8b367b6          LDRH     r6,[r3,#0x7b6]        ;587
000024  42b2              CMP      r2,r6                 ;587
000026  d01b              BEQ      |L3.96|
000028  eb020682          ADD      r6,r2,r2,LSL #2       ;593
00002c  eb061642          ADD      r6,r6,r2,LSL #5       ;593
000030  eb040486          ADD      r4,r4,r6,LSL #2       ;593
000034  3494              ADDS     r4,r4,#0x94           ;593
000036  7926              LDRB     r6,[r4,#4]            ;596
000038  2e3a              CMP      r6,#0x3a              ;596
00003a  d008              BEQ      |L3.78|
00003c  1c52              ADDS     r2,r2,#1              ;599
00003e  b292              UXTH     r2,r2                 ;599
000040  fbb2f4f5          UDIV     r4,r2,r5
000044  fb052214          MLS      r2,r5,r4,r2
000048  f8a327b4          STRH     r2,[r3,#0x7b4]
;;;601                continue;
00004c  e008              B        |L3.96|
                  |L3.78|
;;;602            }
;;;603    
;;;604            // 命令头合法，则提取命令
;;;605            cmd = (CAN_CMD)(pCmdFrame->buff[CAN_CMD_CMD_INDEX]);
00004e  7964              LDRB     r4,[r4,#5]
;;;606    
;;;607            switch (cmd)
;;;608            {
;;;609            case DUT_TYPE_NULL:
;;;610                break;
;;;611    
;;;612    
;;;613    
;;;614            default:
;;;615                break;
;;;616            }
;;;617            // 删除命令帧
;;;618            pCB->rx.rxEachNode[sourceBuffSelect].head++;
000050  1c52              ADDS     r2,r2,#1
000052  b292              UXTH     r2,r2
;;;619            pCB->rx.rxEachNode[sourceBuffSelect].head %= CAN_RX_QUEUE_SIZE;
000054  fbb2f4f5          UDIV     r4,r2,r5
000058  fb052214          MLS      r2,r5,r4,r2
00005c  f8a327b4          STRH     r2,[r3,#0x7b4]
                  |L3.96|
000060  1c49              ADDS     r1,r1,#1              ;584
000062  b2c9              UXTB     r1,r1                 ;584
000064  2900              CMP      r1,#0                 ;584
000066  d0d1              BEQ      |L3.12|
                  |L3.104|
;;;620        }
;;;621    }
000068  bd78              POP      {r3-r6,pc}
;;;622    
                          ENDP


                          AREA ||i.CAN_ConfirmTempCmdFrameBuff||, CODE, READONLY, ALIGN=1

                  CAN_ConfirmTempCmdFrameBuff PROC
;;;689    // 将临时缓冲区添加到命令帧缓冲区中，其本质操作是承认临时缓冲区数据有效
;;;690    BOOL CAN_ConfirmTempCmdFrameBuff(CAN_CB *pCB, uint8 sourceSelect)
000000  b510              PUSH     {r4,lr}
;;;691    {
;;;692        CAN_CMD_FRAME *pCmdFrame = NULL;
;;;693    
;;;694        // 参数合法性检验
;;;695        if (NULL == pCB)
000002  2800              CMP      r0,#0
000004  d026              BEQ      |L4.84|
;;;696        {
;;;697            return FALSE;
;;;698        }
;;;699    
;;;700        // 临时缓冲区为空，不予添加
;;;701        pCmdFrame = &pCB->rx.rxEachNode[sourceSelect].cmdQueue[pCB->rx.rxEachNode[sourceSelect].end];
000006  f24052c9          MOV      r2,#0x5c9
00000a  4351              MULS     r1,r2,r1
00000c  eb000181          ADD      r1,r0,r1,LSL #2
000010  f5015280          ADD      r2,r1,#0x1000
000014  4613              MOV      r3,r2
000016  f8b207b6          LDRH     r0,[r2,#0x7b6]
00001a  eb000280          ADD      r2,r0,r0,LSL #2
00001e  eb021240          ADD      r2,r2,r0,LSL #5
000022  eb010282          ADD      r2,r1,r2,LSL #2
;;;702    
;;;703        if (0 == pCmdFrame->length)
000026  f8b22124          LDRH     r2,[r2,#0x124]
00002a  b1aa              CBZ      r2,|L4.88|
;;;704        {
;;;705            return FALSE;
;;;706        }
;;;707    
;;;708        // 添加
;;;709        pCB->rx.rxEachNode[sourceSelect].end++;
00002c  1c40              ADDS     r0,r0,#1
00002e  b280              UXTH     r0,r0
;;;710        pCB->rx.rxEachNode[sourceSelect].end %= CAN_RX_QUEUE_SIZE;
000030  2228              MOVS     r2,#0x28
000032  fbb0f4f2          UDIV     r4,r0,r2
000036  fb020014          MLS      r0,r2,r4,r0
00003a  f8a307b6          STRH     r0,[r3,#0x7b6]
;;;711        // 该行的作用是将新的添加位置有效数据个数清零，以便将这个位置当做临时帧缓冲区
;;;712        pCB->rx.rxEachNode[sourceSelect].cmdQueue[pCB->rx.rxEachNode[sourceSelect].end].length = 0;
00003e  eb000380          ADD      r3,r0,r0,LSL #2
000042  eb031040          ADD      r0,r3,r0,LSL #5
000046  eb010080          ADD      r0,r1,r0,LSL #2
00004a  2200              MOVS     r2,#0
00004c  f8a02124          STRH     r2,[r0,#0x124]
;;;713    
;;;714        return TRUE;
000050  2001              MOVS     r0,#1
;;;715    }
000052  bd10              POP      {r4,pc}
                  |L4.84|
000054  2000              MOVS     r0,#0                 ;697
000056  bd10              POP      {r4,pc}
                  |L4.88|
000058  2000              MOVS     r0,#0                 ;705
00005a  bd10              POP      {r4,pc}
;;;716    
                          ENDP


                          AREA ||i.CAN_DRIVE_AddTxArray||, CODE, READONLY, ALIGN=2

                  CAN_DRIVE_AddTxArray PROC
;;;759    // 向发送缓冲区中添加一条待发送序列
;;;760    BOOL CAN_DRIVE_AddTxArray(uint32 id, uint8 *pArray, uint8 length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;761    {
;;;762        uint16 i;
;;;763        uint16 head = sysCanCB.tx.head;
000004  4b24              LDR      r3,|L5.152|
000006  f8b37910          LDRH     r7,[r3,#0x910]  ; sysCanCB
;;;764        uint16 end = sysCanCB.tx.end;
00000a  f8b34912          LDRH     r4,[r3,#0x912]  ; sysCanCB
;;;765    
;;;766        // 参数检验
;;;767        if ((NULL == pArray) || (0 == length))
00000e  2900              CMP      r1,#0
000010  d00b              BEQ      |L5.42|
000012  b152              CBZ      r2,|L5.42|
;;;768        {
;;;769            return FALSE;
;;;770        }
;;;771    
;;;772        // 发送缓冲区已满，不予接收
;;;773        if ((end + 1) % CAN_TX_QUEUE_SIZE == head)
000014  1c65              ADDS     r5,r4,#1
000016  261e              MOVS     r6,#0x1e
000018  fbb5fcf6          UDIV     r12,r5,r6
00001c  fb06551c          MLS      r5,r6,r12,r5
000020  42bd              CMP      r5,r7
000022  d104              BNE      |L5.46|
;;;774        {
;;;775            return FALSE;
000024  2000              MOVS     r0,#0
                  |L5.38|
;;;776        }
;;;777    
;;;778        sysCanCB.tx.cmdQueue[end].deviceID = id;
;;;779    
;;;780        for (i = 0; i < length; i++)
;;;781        {
;;;782            sysCanCB.tx.cmdQueue[end].buff[i] = *pArray++;
;;;783        }
;;;784        sysCanCB.tx.cmdQueue[end].length = length;
;;;785    
;;;786        // 发送环形队列更新位置
;;;787        sysCanCB.tx.end++;
;;;788        sysCanCB.tx.end %= CAN_TX_QUEUE_SIZE;
;;;789        sysCanCB.tx.cmdQueue[sysCanCB.tx.end].length = 0;
;;;790    
;;;791        return TRUE;
;;;792    }
000026  e8bd81f0          POP      {r4-r8,pc}
                  |L5.42|
00002a  2000              MOVS     r0,#0                 ;769
00002c  e7fb              B        |L5.38|
                  |L5.46|
00002e  eb040584          ADD      r5,r4,r4,LSL #2       ;778
000032  4f1a              LDR      r7,|L5.156|
000034  eb051444          ADD      r4,r5,r4,LSL #5       ;778
000038  eb070484          ADD      r4,r7,r4,LSL #2       ;778
00003c  f5045580          ADD      r5,r4,#0x1000         ;778
000040  f8c507b8          STR      r0,[r5,#0x7b8]        ;778
000044  2000              MOVS     r0,#0                 ;780
000046  e009              B        |L5.92|
                  |L5.72|
000048  eb040c00          ADD      r12,r4,r0             ;782
00004c  f50c5c80          ADD      r12,r12,#0x1000       ;782
000050  f8118b01          LDRB     r8,[r1],#1            ;782
000054  f88c87bc          STRB     r8,[r12,#0x7bc]       ;782
000058  1c40              ADDS     r0,r0,#1              ;780
00005a  b280              UXTH     r0,r0                 ;780
                  |L5.92|
00005c  4290              CMP      r0,r2                 ;780
00005e  d3f3              BCC      |L5.72|
000060  f8a52848          STRH     r2,[r5,#0x848]        ;784
000064  f6031312          ADD      r3,r3,#0x912          ;787
000068  8818              LDRH     r0,[r3,#0]            ;787  ; sysCanCB
00006a  1c40              ADDS     r0,r0,#1              ;787
00006c  8018              STRH     r0,[r3,#0]            ;787
00006e  8818              LDRH     r0,[r3,#0]            ;788  ; sysCanCB
000070  fbb0f1f6          UDIV     r1,r0,r6              ;788
000074  fb060011          MLS      r0,r6,r1,r0           ;788
000078  8018              STRH     r0,[r3,#0]            ;788
00007a  8818              LDRH     r0,[r3,#0]            ;789  ; sysCanCB
00007c  2100              MOVS     r1,#0                 ;789
00007e  eb000280          ADD      r2,r0,r0,LSL #2       ;789
000082  eb021040          ADD      r0,r2,r0,LSL #5       ;789
000086  eb070080          ADD      r0,r7,r0,LSL #2       ;789
00008a  f5005080          ADD      r0,r0,#0x1000         ;789
00008e  f8a01848          STRH     r1,[r0,#0x848]        ;789
000092  2001              MOVS     r0,#1                 ;791
000094  e7c7              B        |L5.38|
;;;793    
                          ENDP

000096  0000              DCW      0x0000
                  |L5.152|
                          DCD      ||.bss||+0x2000
                  |L5.156|
                          DCD      ||.bss||

                          AREA ||i.CAN_DataStructureInit||, CODE, READONLY, ALIGN=1

                  CAN_DataStructureInit PROC
;;;111    // 数据结构初始化
;;;112    void CAN_DataStructureInit(CAN_CB *pCB)
000000  b530              PUSH     {r4,r5,lr}
;;;113    {
;;;114        uint8 i;
;;;115        uint8 j;
;;;116    
;;;117        // 参数合法性检验
;;;118        if (NULL == pCB)
000002  2800              CMP      r0,#0
000004  d043              BEQ      |L6.142|
;;;119        {
;;;120            return;
;;;121        }
;;;122    
;;;123        pCB->tx.txBusy = FALSE;
000006  f5005100          ADD      r1,r0,#0x2000
00000a  f5016111          ADD      r1,r1,#0x910
00000e  2400              MOVS     r4,#0
000010  718c              STRB     r4,[r1,#6]
;;;124        pCB->tx.index = 0;
000012  808c              STRH     r4,[r1,#4]
;;;125        pCB->tx.head = 0;
000014  800c              STRH     r4,[r1,#0]
;;;126        pCB->tx.end = 0;
000016  804c              STRH     r4,[r1,#2]
;;;127        for (i = 0; i < CAN_TX_QUEUE_SIZE; i++)
000018  2100              MOVS     r1,#0
                  |L6.26|
;;;128        {
;;;129            pCB->tx.cmdQueue[i].length = 0;
00001a  eb010281          ADD      r2,r1,r1,LSL #2
00001e  eb021241          ADD      r2,r2,r1,LSL #5
000022  eb000282          ADD      r2,r0,r2,LSL #2
000026  f5025280          ADD      r2,r2,#0x1000
00002a  f8a24848          STRH     r4,[r2,#0x848]
00002e  1c49              ADDS     r1,r1,#1              ;127
000030  b2c9              UXTB     r1,r1                 ;127
000032  291e              CMP      r1,#0x1e              ;127
000034  d3f1              BCC      |L6.26|
;;;130        }
;;;131    
;;;132        for (i = 0; i < CAN_DEVICE_SOURCE_ID_MAX; i++)
000036  2100              MOVS     r1,#0
                  |L6.56|
;;;133        {
;;;134            pCB->rxFIFO.rxFIFOEachNode[i].head = 0;
000038  eb0102c1          ADD      r2,r1,r1,LSL #3
00003c  eb021281          ADD      r2,r2,r1,LSL #6
000040  eb000242          ADD      r2,r0,r2,LSL #1
000044  f8224f8c          STRH     r4,[r2,#0x8c]!
;;;135            pCB->rxFIFO.rxFIFOEachNode[i].end = 0;
000048  8054              STRH     r4,[r2,#2]
;;;136            pCB->rxFIFO.rxFIFOEachNode[i].currentProcessIndex = 0;
00004a  8094              STRH     r4,[r2,#4]
00004c  1c49              ADDS     r1,r1,#1              ;132
00004e  b2c9              UXTB     r1,r1                 ;132
000050  2900              CMP      r1,#0                 ;132
000052  d0f1              BEQ      |L6.56|
;;;137        }
;;;138    
;;;139        for (i = 0; i < CAN_DEVICE_SOURCE_ID_MAX; i++)
000054  2200              MOVS     r2,#0
                  |L6.86|
;;;140        {
;;;141            for (j = 0; j < CAN_RX_QUEUE_SIZE; j++)
000056  2100              MOVS     r1,#0
;;;142            {
;;;143                pCB->rx.rxEachNode[i].cmdQueue[j].length = 0;
000058  f24053c9          MOV      r3,#0x5c9
00005c  4353              MULS     r3,r2,r3
00005e  eb000383          ADD      r3,r0,r3,LSL #2
                  |L6.98|
000062  eb010581          ADD      r5,r1,r1,LSL #2
000066  eb051541          ADD      r5,r5,r1,LSL #5
00006a  eb030585          ADD      r5,r3,r5,LSL #2
00006e  f8a54124          STRH     r4,[r5,#0x124]
000072  1c49              ADDS     r1,r1,#1              ;141
000074  b2c9              UXTB     r1,r1                 ;141
000076  2928              CMP      r1,#0x28              ;141
000078  d3f3              BCC      |L6.98|
;;;144            }
;;;145            pCB->rx.rxEachNode[i].head = 0;
00007a  f5035380          ADD      r3,r3,#0x1000
00007e  f8a347b4          STRH     r4,[r3,#0x7b4]
;;;146            pCB->rx.rxEachNode[i].end = 0;
000082  f8a347b6          STRH     r4,[r3,#0x7b6]
000086  1c52              ADDS     r2,r2,#1              ;139
000088  b2d2              UXTB     r2,r2                 ;139
00008a  2a00              CMP      r2,#0                 ;139
00008c  d0e3              BEQ      |L6.86|
                  |L6.142|
;;;147        }
;;;148    }
00008e  bd30              POP      {r4,r5,pc}
;;;149    
                          ENDP


                          AREA ||i.CAN_HW_Init||, CODE, READONLY, ALIGN=2

                  CAN_HW_Init PROC
;;;846    // 功能函数：CAN初始化
;;;847    void CAN_HW_Init(uint16 bund)
000000  b5f0              PUSH     {r4-r7,lr}
;;;848    {
000002  b089              SUB      sp,sp,#0x24
000004  4605              MOV      r5,r0
;;;849        can_parameter_struct can_parameter;
;;;850        can_filter_parameter_struct can_filter;
;;;851    
;;;852        // 时钟分配与使能
;;;853        rcu_periph_clock_enable(RCU_CAN0);
000006  f2407019          MOV      r0,#0x719
00000a  f7fffffe          BL       rcu_periph_clock_enable
;;;854        rcu_periph_clock_enable(RCU_GPIOB);
00000e  f2406003          MOV      r0,#0x603
000012  f7fffffe          BL       rcu_periph_clock_enable
;;;855        // rcu_periph_clock_enable(RCU_GPIOA); // 后加
;;;856        rcu_periph_clock_enable(RCU_AF);
000016  f44f60c0          MOV      r0,#0x600
00001a  f7fffffe          BL       rcu_periph_clock_enable
;;;857    
;;;858        // 配置CAN的接收中断
;;;859        nvic_irq_enable(USBD_LP_CAN0_RX0_IRQn, 1, 0);
00001e  2200              MOVS     r2,#0
000020  2101              MOVS     r1,#1
000022  2014              MOVS     r0,#0x14
000024  f7fffffe          BL       nvic_irq_enable
;;;860    
;;;861        // 配置CAN邮箱空中断
;;;862        nvic_irq_enable(USBD_HP_CAN0_TX_IRQn, 2, 0);
000028  2200              MOVS     r2,#0
00002a  2102              MOVS     r1,#2
00002c  2013              MOVS     r0,#0x13
00002e  f7fffffe          BL       nvic_irq_enable
;;;863    
;;;864        // CAN管脚重映射到PB8-9
;;;865          gpio_pin_remap_config(GPIO_CAN_PARTIAL_REMAP,ENABLE);
000032  2101              MOVS     r1,#1
000034  f44f10ea          MOV      r0,#0x1d4000
000038  f7fffffe          BL       gpio_pin_remap_config
;;;866    
;;;867        /* configure CAN0 GPIO */
;;;868        gpio_init(GPIOB, GPIO_MODE_IPU, GPIO_OSPEED_50MHZ, GPIO_PIN_8);
00003c  4c32              LDR      r4,|L7.264|
00003e  f44f7380          MOV      r3,#0x100
000042  2203              MOVS     r2,#3
000044  2148              MOVS     r1,#0x48
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       gpio_init
;;;869        gpio_init(GPIOB, GPIO_MODE_AF_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_9);
00004c  1563              ASRS     r3,r4,#21
00004e  2203              MOVS     r2,#3
000050  2118              MOVS     r1,#0x18
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       gpio_init
;;;870    
;;;871        can_struct_para_init(CAN_INIT_STRUCT, &can_parameter);
000058  a906              ADD      r1,sp,#0x18
00005a  2000              MOVS     r0,#0
00005c  f7fffffe          BL       can_struct_para_init
;;;872        can_struct_para_init(CAN_INIT_STRUCT, &can_filter);
000060  a901              ADD      r1,sp,#4
000062  2000              MOVS     r0,#0
000064  f7fffffe          BL       can_struct_para_init
;;;873    
;;;874        /* initialize CAN register */
;;;875        can_deinit(CAN0);
000068  4f28              LDR      r7,|L7.268|
00006a  4638              MOV      r0,r7
00006c  f7fffffe          BL       can_deinit
;;;876    
;;;877        /* initialize CAN parameters */
;;;878        can_parameter.time_triggered = DISABLE;
000070  2400              MOVS     r4,#0
000072  f88d401c          STRB     r4,[sp,#0x1c]
;;;879        can_parameter.auto_bus_off_recovery = ENABLE;
000076  2601              MOVS     r6,#1
000078  f88d601d          STRB     r6,[sp,#0x1d]
;;;880        can_parameter.auto_wake_up = DISABLE;
00007c  f88d401e          STRB     r4,[sp,#0x1e]
;;;881        can_parameter.no_auto_retrans = DISABLE;
000080  f88d401f          STRB     r4,[sp,#0x1f]
;;;882        can_parameter.rec_fifo_overwrite = DISABLE;
000084  f88d4020          STRB     r4,[sp,#0x20]
;;;883        can_parameter.trans_fifo_order = DISABLE;
000088  f88d4021          STRB     r4,[sp,#0x21]
;;;884        can_parameter.working_mode = CAN_NORMAL_MODE;
00008c  f88d4018          STRB     r4,[sp,#0x18]
;;;885    
;;;886        // 波特率计算：36MHz / (1+6+1) / 36 = 125K bit
;;;887        can_parameter.resync_jump_width = CAN_BT_SJW_1TQ;
000090  f88d4019          STRB     r4,[sp,#0x19]
;;;888        can_parameter.time_segment_1 = CAN_BT_BS1_6TQ;// 6
000094  2005              MOVS     r0,#5
000096  f88d001a          STRB     r0,[sp,#0x1a]
;;;889        can_parameter.time_segment_2 = CAN_BT_BS2_1TQ;// 1
00009a  f88d401b          STRB     r4,[sp,#0x1b]
;;;890        if (CAN_BAUD_RATE_125K == bund)
;;;891        {
;;;892            can_parameter.prescaler = 36;
00009e  2024              MOVS     r0,#0x24
0000a0  2d7d              CMP      r5,#0x7d              ;890
0000a2  d025              BEQ      |L7.240|
;;;893        }
;;;894        else if (CAN_BAUD_RATE_250K == bund)
0000a4  2dfa              CMP      r5,#0xfa
0000a6  d026              BEQ      |L7.246|
;;;895        {
;;;896            can_parameter.prescaler = 18;
;;;897        }
;;;898        else if (CAN_BAUD_RATE_500K == bund)
0000a8  f5b57ffa          CMP      r5,#0x1f4
0000ac  d027              BEQ      |L7.254|
;;;899        {
;;;900            can_parameter.prescaler = 9;
;;;901        }
;;;902        else
;;;903        {
;;;904            can_parameter.prescaler = 36;
0000ae  f8ad0022          STRH     r0,[sp,#0x22]
                  |L7.178|
;;;905        }
;;;906    
;;;907        /* initialize CAN */
;;;908        can_init(CAN0, &can_parameter);
0000b2  a906              ADD      r1,sp,#0x18
0000b4  4638              MOV      r0,r7
0000b6  f7fffffe          BL       can_init
;;;909    
;;;910        /* initialize filter */
;;;911        can_filter.filter_number = 1;
0000ba  f8ad600e          STRH     r6,[sp,#0xe]
;;;912        can_filter.filter_mode = CAN_FILTERMODE_MASK;
0000be  f8ad4010          STRH     r4,[sp,#0x10]
;;;913        can_filter.filter_bits = CAN_FILTERBITS_32BIT;
0000c2  f8ad6012          STRH     r6,[sp,#0x12]
;;;914        can_filter.filter_list_high = 0x0000;
0000c6  f8ad4004          STRH     r4,[sp,#4]
;;;915        can_filter.filter_list_low = 0x0000;
0000ca  f8ad4006          STRH     r4,[sp,#6]
;;;916        can_filter.filter_mask_high = 0x0000;
0000ce  f8ad4008          STRH     r4,[sp,#8]
;;;917        can_filter.filter_mask_low = 0x0000;
0000d2  f8ad400a          STRH     r4,[sp,#0xa]
;;;918        can_filter.filter_fifo_number = CAN_FIFO0;
0000d6  f8ad400c          STRH     r4,[sp,#0xc]
;;;919        can_filter.filter_enable = ENABLE;
0000da  f88d6014          STRB     r6,[sp,#0x14]
;;;920    
;;;921        can_filter_init(&can_filter);
0000de  a801              ADD      r0,sp,#4
0000e0  f7fffffe          BL       can_filter_init
;;;922    
;;;923        /* enable can receive FIFO0 not empty interrupt */
;;;924        can_interrupt_enable(CAN0, CAN_INT_RFNE0);
0000e4  2102              MOVS     r1,#2
0000e6  4638              MOV      r0,r7
0000e8  f7fffffe          BL       can_interrupt_enable
;;;925    }
0000ec  b009              ADD      sp,sp,#0x24
0000ee  bdf0              POP      {r4-r7,pc}
                  |L7.240|
0000f0  f8ad0022          STRH     r0,[sp,#0x22]         ;892
0000f4  e7dd              B        |L7.178|
                  |L7.246|
0000f6  2012              MOVS     r0,#0x12              ;896
0000f8  f8ad0022          STRH     r0,[sp,#0x22]         ;896
0000fc  e7d9              B        |L7.178|
                  |L7.254|
0000fe  2009              MOVS     r0,#9                 ;900
000100  f8ad0022          STRH     r0,[sp,#0x22]         ;900
000104  e7d5              B        |L7.178|
;;;926    
                          ENDP

000106  0000              DCW      0x0000
                  |L7.264|
                          DCD      0x40010c00
                  |L7.268|
                          DCD      0x40006400

                          AREA ||i.CAN_MacProcess||, CODE, READONLY, ALIGN=2

                  CAN_MacProcess PROC
;;;352    // CAN 报文接收处理函数(注意根据具体模块修改)
;;;353    void CAN_MacProcess(uint16 standarID, uint8 *data, uint8 length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;354    {
;;;355        uint16 end;
;;;356        uint16 head;
;;;357        uint8 i;
;;;358        int8 sourceBuffSelect = CAN_DEVICE_SOURCE_ID_MAX; // 节点缓存区编号选择
;;;359    
;;;360        // 参数合法性判断
;;;361        if (NULL == data)
000004  2900              CMP      r1,#0
000006  d037              BEQ      |L8.120|
;;;362        {
;;;363            return;
;;;364        }
;;;365    
;;;366        // 标准帧判断
;;;367        if (standarID > 0x7FF)
000008  f5b06f00          CMP      r0,#0x800
00000c  d234              BCS      |L8.120|
;;;368        {
;;;369            return;
;;;370        }
;;;371    
;;;372        // 取出目标节点
;;;373        //  destinationID = standarID & 0x07FF;
;;;374    
;;;375        // 不是发给自身ID的数据直接丢掉
;;;376        //  if (CAN_DEVICE_ID_HMI != destinationID)
;;;377        //  {
;;;378        //      return;
;;;379        //  }
;;;380    
;;;381        // 已经使能
;;;382        if (CAN_RX_DEVICE_PUC)
;;;383        {
;;;384            sourceBuffSelect = CAN_RX_DEVICE_PUC - 1;
00000e  2300              MOVS     r3,#0
;;;385        }
;;;386    
;;;387        // 没有合适的源节点
;;;388        if ((sourceBuffSelect >= CAN_DEVICE_SOURCE_ID_MAX) || (sourceBuffSelect < 0))
;;;389        {
;;;390            return;
;;;391        }
;;;392    
;;;393        // 取相应缓存区结构体数据
;;;394        end = sysCanCB.rxFIFO.rxFIFOEachNode[sourceBuffSelect].end;
000010  f8dfc068          LDR      r12,|L8.124|
000014  f8bc008e          LDRH     r0,[r12,#0x8e]
;;;395        head = sysCanCB.rxFIFO.rxFIFOEachNode[sourceBuffSelect].head;
000018  f8bc708c          LDRH     r7,[r12,#0x8c]
;;;396    
;;;397        // ■■环形列队，入队■■
;;;398        //  一级缓冲区已满，不予接收
;;;399        if ((end + 1) % CAN_RX_FIFO_SIZE == head)
00001c  1c40              ADDS     r0,r0,#1
00001e  258c              MOVS     r5,#0x8c
000020  fbb0f4f5          UDIV     r4,r0,r5
000024  fb050014          MLS      r0,r5,r4,r0
000028  42b8              CMP      r0,r7
00002a  d025              BEQ      |L8.120|
;;;400        {
;;;401            return;
;;;402        }
;;;403    
;;;404        for (i = 0; i < length; i++)
00002c  2400              MOVS     r4,#0
00002e  e021              B        |L8.116|
                  |L8.48|
;;;405        {
;;;406            // 单个字节读取，并放入FIFO中
;;;407            sysCanCB.rxFIFO.rxFIFOEachNode[sourceBuffSelect].buff[sysCanCB.rxFIFO.rxFIFOEachNode[sourceBuffSelect].end] = *data++;
000030  eb0300c3          ADD      r0,r3,r3,LSL #3
000034  eb001083          ADD      r0,r0,r3,LSL #6
000038  eb0c0040          ADD      r0,r12,r0,LSL #1
00003c  f8116b01          LDRB     r6,[r1],#1
000040  f8b0808e          LDRH     r8,[r0,#0x8e]
000044  f8086000          STRB     r6,[r8,r0]
;;;408    
;;;409            sysCanCB.rxFIFO.rxFIFOEachNode[sourceBuffSelect].end++;
000048  f8306f8e          LDRH     r6,[r0,#0x8e]!
00004c  1c76              ADDS     r6,r6,#1
00004e  8006              STRH     r6,[r0,#0]
;;;410    
;;;411            // 一级缓冲区已满，不予接收
;;;412            if ((sysCanCB.rxFIFO.rxFIFOEachNode[sourceBuffSelect].end + 1) % CAN_RX_FIFO_SIZE == head)
000050  f830698e          LDRH     r6,[r0],#-0x8e
000054  1c76              ADDS     r6,r6,#1
000056  fbb6f8f5          UDIV     r8,r6,r5
00005a  fb056618          MLS      r6,r5,r8,r6
00005e  42be              CMP      r6,r7
000060  d00a              BEQ      |L8.120|
;;;413            {
;;;414                break;
;;;415            }
;;;416    
;;;417            sysCanCB.rxFIFO.rxFIFOEachNode[sourceBuffSelect].end %= CAN_RX_FIFO_SIZE;
000062  f8306f8e          LDRH     r6,[r0,#0x8e]!
000066  fbb6f8f5          UDIV     r8,r6,r5
00006a  fb056618          MLS      r6,r5,r8,r6
00006e  8006              STRH     r6,[r0,#0]
000070  1c64              ADDS     r4,r4,#1              ;404
000072  b2e4              UXTB     r4,r4                 ;404
                  |L8.116|
000074  4294              CMP      r4,r2                 ;404
000076  d3db              BCC      |L8.48|
                  |L8.120|
;;;418        }
;;;419    }
000078  e8bd81f0          POP      {r4-r8,pc}
;;;420    
                          ENDP

                  |L8.124|
                          DCD      ||.bss||

                          AREA ||i.CAN_PROTOCOL_Process_DT||, CODE, READONLY, ALIGN=1

                  CAN_PROTOCOL_Process_DT PROC
;;;623    // CAN处理测试过程函数
;;;624    void CAN_PROTOCOL_Process_DT(void)
000000  f7ffbffe          B.W      CAN_TxStateProcess
;;;625    {
;;;626        // CAN接收FIFO缓冲区处理
;;;627        //CAN_RxFIFOProcess(&sysCanCB);
;;;628    
;;;629        // CAN接收命令缓冲区处理
;;;630        //CAN_CmdFrameProcess(&sysCanCB);
;;;631    
;;;632        // CAN发送状态机处理过程
;;;633        CAN_TxStateProcess();
;;;634    }
;;;635    
                          ENDP


                          AREA ||i.CAN_RxFIFOProcess||, CODE, READONLY, ALIGN=1

                  CAN_RxFIFOProcess PROC
;;;421    // 一级报文接收缓冲区处理，从一级接收缓冲区中取出一个字节添加到命令帧缓冲区中
;;;422    void CAN_RxFIFOProcess(CAN_CB *pCB)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;423    {
000004  4680              MOV      r8,r0
;;;424        uint16 end;
;;;425        uint16 head;
;;;426        CAN_CMD_FRAME *pCmdFrame = NULL;
;;;427        CAN_RX_FIFO *pRxFIFO = NULL;
;;;428        uint16 length = 0;
;;;429        uint8 currentData = 0;
;;;430        uint8 sourceBuffSelect;
;;;431    
;;;432        // 参数合法性检验
;;;433        if (NULL == pCB)
000006  f1b80f00          CMP      r8,#0
00000a  d07d              BEQ      |L10.264|
;;;434        {
;;;435            return;
;;;436        }
;;;437    
;;;438        // 循环判断是否有数据需要处理
;;;439        for (sourceBuffSelect = 0; sourceBuffSelect < CAN_DEVICE_SOURCE_ID_MAX; sourceBuffSelect++)
00000c  2600              MOVS     r6,#0
00000e  46b1              MOV      r9,r6
;;;440        {
;;;441            // 获取接收一级缓冲区节点临时缓冲区指针
;;;442            pRxFIFO = &pCB->rxFIFO.rxFIFOEachNode[sourceBuffSelect];
;;;443    
;;;444            end = pRxFIFO->end;
;;;445            head = pRxFIFO->head;
;;;446    
;;;447            // 一级缓冲区为空，继续
;;;448            if (head == end)
;;;449            {
;;;450                continue;
;;;451            }
;;;452    
;;;453            // 获取接收命令临时缓冲区指针
;;;454            pCmdFrame = &pCB->rx.rxEachNode[sourceBuffSelect].cmdQueue[pCB->rx.rxEachNode[sourceBuffSelect].end];
;;;455    
;;;456            // 取出当前要处理的字节
;;;457            currentData = pRxFIFO->buff[pRxFIFO->currentProcessIndex];
;;;458    
;;;459            // 临时缓冲区长度为0时，搜索首字节
;;;460            if (0 == pCmdFrame->length)
;;;461            {
;;;462                // 命令头错误，删除当前字节并退出
;;;463                if (CAN_CMD_HEAD != currentData)
;;;464                {
;;;465                    pRxFIFO->head++;
;;;466                    pRxFIFO->head %= CAN_RX_FIFO_SIZE;
000010  278c              MOVS     r7,#0x8c
                  |L10.18|
000012  eb0600c6          ADD      r0,r6,r6,LSL #3       ;442
000016  eb001086          ADD      r0,r0,r6,LSL #6       ;442
00001a  eb080440          ADD      r4,r8,r0,LSL #1       ;442
00001e  f8b4108e          LDRH     r1,[r4,#0x8e]         ;444
000022  f8b4008c          LDRH     r0,[r4,#0x8c]         ;445
000026  4288              CMP      r0,r1                 ;448
000028  d024              BEQ      |L10.116|
00002a  f24050c9          MOV      r0,#0x5c9             ;454
00002e  4370              MULS     r0,r6,r0              ;454
000030  eb080380          ADD      r3,r8,r0,LSL #2       ;454
000034  f5035280          ADD      r2,r3,#0x1000         ;454
000038  4694              MOV      r12,r2                ;454
00003a  f8b207b6          LDRH     r0,[r2,#0x7b6]        ;454
00003e  eb000280          ADD      r2,r0,r0,LSL #2       ;454
000042  eb021240          ADD      r2,r2,r0,LSL #5       ;454
000046  eb030582          ADD      r5,r3,r2,LSL #2       ;454
00004a  3594              ADDS     r5,r5,#0x94           ;454
00004c  f8b42090          LDRH     r2,[r4,#0x90]         ;457
000050  5ca2              LDRB     r2,[r4,r2]            ;457
000052  f8b53090          LDRH     r3,[r5,#0x90]         ;460
000056  b173              CBZ      r3,|L10.118|
;;;467                    pRxFIFO->currentProcessIndex = pRxFIFO->head;
;;;468    
;;;469                    continue;
;;;470                }
;;;471    
;;;472                // 命令头正确，但无命令临时缓冲区可用，退出
;;;473                if ((pCB->rx.rxEachNode[sourceBuffSelect].end + 1) % CAN_RX_QUEUE_SIZE == pCB->rx.rxEachNode[sourceBuffSelect].head)
;;;474                {
;;;475                    continue;
;;;476                }
;;;477    
;;;478                // 命令头正确，有临时缓冲区可用，则将其添加到命令帧临时缓冲区中
;;;479                pCmdFrame->buff[pCmdFrame->length++] = currentData;
;;;480                pRxFIFO->currentProcessIndex++;
;;;481                pRxFIFO->currentProcessIndex %= CAN_RX_FIFO_SIZE;
;;;482            }
;;;483            // 非首字节，将数据添加到命令帧临时缓冲区中，但暂不删除当前数据
;;;484            else
;;;485            {
;;;486                // 临时缓冲区溢出，说明当前正在接收的命令帧是错误的，正确的命令帧不会出现长度溢出的情况
;;;487                if (pCmdFrame->length >= CAN_CMD_FRAME_LENGTH_MAX)
000058  2b8c              CMP      r3,#0x8c
00005a  d377              BCC      |L10.332|
;;;488                {
;;;489                    // 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;490                    pRxFIFO->head++;
00005c  f8340f8c          LDRH     r0,[r4,#0x8c]!
000060  1c40              ADDS     r0,r0,#1
000062  8020              STRH     r0,[r4,#0]
;;;491                    pRxFIFO->head %= CAN_RX_FIFO_SIZE;
000064  8820              LDRH     r0,[r4,#0]
000066  fbb0f1f7          UDIV     r1,r0,r7
00006a  fb070011          MLS      r0,r7,r1,r0
00006e  8020              STRH     r0,[r4,#0]
;;;492                    pRxFIFO->currentProcessIndex = pRxFIFO->head;
000070  8820              LDRH     r0,[r4,#0]
000072  80a0              STRH     r0,[r4,#4]
                  |L10.116|
;;;493    
;;;494                    continue;
000074  e07e              B        |L10.372|
                  |L10.118|
000076  2a3a              CMP      r2,#0x3a              ;463
000078  d00c              BEQ      |L10.148|
00007a  f8340f8c          LDRH     r0,[r4,#0x8c]!        ;465
00007e  1c40              ADDS     r0,r0,#1              ;465
000080  8020              STRH     r0,[r4,#0]            ;465
000082  8820              LDRH     r0,[r4,#0]            ;466
000084  fbb0f1f7          UDIV     r1,r0,r7              ;466
000088  fb070011          MLS      r0,r7,r1,r0           ;466
00008c  8020              STRH     r0,[r4,#0]            ;466
00008e  8820              LDRH     r0,[r4,#0]            ;467
000090  80a0              STRH     r0,[r4,#4]            ;467
000092  e06f              B        |L10.372|
                  |L10.148|
000094  1c40              ADDS     r0,r0,#1              ;473
000096  2128              MOVS     r1,#0x28              ;473
000098  fbb0f3f1          UDIV     r3,r0,r1              ;473
00009c  fb010013          MLS      r0,r1,r3,r0           ;473
0000a0  f8bc17b4          LDRH     r1,[r12,#0x7b4]       ;473
0000a4  4288              CMP      r0,r1                 ;473
0000a6  d065              BEQ      |L10.372|
0000a8  2001              MOVS     r0,#1                 ;479
0000aa  f8a50090          STRH     r0,[r5,#0x90]         ;479
0000ae  712a              STRB     r2,[r5,#4]            ;479
0000b0  f8340f90          LDRH     r0,[r4,#0x90]!        ;480
0000b4  1c40              ADDS     r0,r0,#1              ;480
0000b6  b280              UXTH     r0,r0                 ;480
0000b8  fbb0f1f7          UDIV     r1,r0,r7              ;481
0000bc  fb070011          MLS      r0,r7,r1,r0           ;481
0000c0  8020              STRH     r0,[r4,#0]            ;481
0000c2  e057              B        |L10.372|
                  |L10.196|
;;;495                }
;;;496    
;;;497                // 一直取到末尾
;;;498                while (end != pRxFIFO->currentProcessIndex)
;;;499                {
;;;500                    // 取出当前要处理的字节
;;;501                    currentData = pRxFIFO->buff[pRxFIFO->currentProcessIndex];
0000c4  5c22              LDRB     r2,[r4,r0]
;;;502                    // 缓冲区未溢出，正常接收，将数据添加到临时缓冲区中
;;;503                    pCmdFrame->buff[pCmdFrame->length++] = currentData;
0000c6  f8b50090          LDRH     r0,[r5,#0x90]
0000ca  1c43              ADDS     r3,r0,#1
0000cc  4428              ADD      r0,r0,r5
0000ce  f8a53090          STRH     r3,[r5,#0x90]
0000d2  7102              STRB     r2,[r0,#4]
;;;504                    pRxFIFO->currentProcessIndex++;
0000d4  f8b40090          LDRH     r0,[r4,#0x90]
0000d8  1c40              ADDS     r0,r0,#1
0000da  b280              UXTH     r0,r0
;;;505                    pRxFIFO->currentProcessIndex %= CAN_RX_FIFO_SIZE;
0000dc  fbb0f2f7          UDIV     r2,r0,r7
0000e0  fb070012          MLS      r0,r7,r2,r0
0000e4  f8a40090          STRH     r0,[r4,#0x90]
;;;506    
;;;507                    // ■■接下来，需要检查命令帧是否完整，如果完整，则将命令帧临时缓冲区扶正■■
;;;508    
;;;509                    // 首先判断命令帧最小长度，一个完整的命令字至少包括4个字节: 命令头(1Byte)+命令字(1Byte)+数据长度(1Byte)+校验码(1Byte) ，因此不足4个字节的必定不完整
;;;510                    if (pCmdFrame->length < CAN_CMD_FRAME_LENGTH_MIN)
0000e8  f8b5a090          LDRH     r10,[r5,#0x90]
0000ec  f1ba0f04          CMP      r10,#4
0000f0  d33c              BCC      |L10.364|
;;;511                    {
;;;512                        // 继续接收
;;;513                        continue;
;;;514                    }
;;;515    
;;;516                    // 命令帧长度数值越界，说明当前命令帧错误，停止接收
;;;517                    if (pCmdFrame->buff[CAN_CMD_LENGTH_INDEX] > (CAN_CMD_FRAME_LENGTH_MAX - CAN_CMD_FRAME_LENGTH_MIN))
0000f2  79a8              LDRB     r0,[r5,#6]
0000f4  2888              CMP      r0,#0x88
0000f6  d910              BLS      |L10.282|
;;;518                    {
;;;519                        // 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;520                        pCmdFrame->length = 0;
0000f8  f8a59090          STRH     r9,[r5,#0x90]
;;;521                        // 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;522                        pRxFIFO->head++;
0000fc  f8340f8c          LDRH     r0,[r4,#0x8c]!
000100  1c40              ADDS     r0,r0,#1
000102  8020              STRH     r0,[r4,#0]
;;;523                        pRxFIFO->head %= CAN_RX_FIFO_SIZE;
000104  8820              LDRH     r0,[r4,#0]
000106  e000              B        |L10.266|
                  |L10.264|
000108  e039              B        |L10.382|
                  |L10.266|
00010a  fbb0f1f7          UDIV     r1,r0,r7
00010e  fb070011          MLS      r0,r7,r1,r0
000112  8020              STRH     r0,[r4,#0]
;;;524                        pRxFIFO->currentProcessIndex = pRxFIFO->head;
000114  8820              LDRH     r0,[r4,#0]
000116  80a0              STRH     r0,[r4,#4]
;;;525    
;;;526                        break;
000118  e02c              B        |L10.372|
                  |L10.282|
;;;527                    }
;;;528    
;;;529                    // 命令帧长度校验，在命令长度描述字的数值上，增加命令头、命令字、...、数据长度、校验码，即为命令帧实际长度
;;;530                    length = pCmdFrame->length;
;;;531                    if (length < (pCmdFrame->buff[CAN_CMD_LENGTH_INDEX] + CAN_CMD_FRAME_LENGTH_MIN))
00011a  1d00              ADDS     r0,r0,#4
00011c  4550              CMP      r0,r10
00011e  d825              BHI      |L10.364|
;;;532                    {
;;;533                        // 长度要求不一致，说明未接收完毕，继续
;;;534                        continue;
;;;535                    }
;;;536    
;;;537                    // 命令帧长度OK，则进行校验，失败时删除命令头
;;;538                    if (!CAN_CheckSum(pCmdFrame->buff, pCmdFrame->length))
000120  4651              MOV      r1,r10
000122  1d28              ADDS     r0,r5,#4
000124  f7fffffe          BL       CAN_CheckSum
000128  b188              CBZ      r0,|L10.334|
;;;539                    {
;;;540                        // 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;541                        pCmdFrame->length = 0;
;;;542                        // 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;543                        pRxFIFO->head++;
;;;544                        pRxFIFO->head %= CAN_RX_FIFO_SIZE;
;;;545                        pRxFIFO->currentProcessIndex = pRxFIFO->head;
;;;546    
;;;547                        break;
;;;548                    }
;;;549    
;;;550                    // 执行到这里，即说明接收到了一个完整并且正确的命令帧，此时需将处理过的数据从一级缓冲区中删除，并将该命令帧扶正
;;;551                    pRxFIFO->head += length;
00012a  f8340f8c          LDRH     r0,[r4,#0x8c]!
00012e  4450              ADD      r0,r0,r10
000130  8020              STRH     r0,[r4,#0]
;;;552                    pRxFIFO->head %= CAN_RX_FIFO_SIZE;
000132  8820              LDRH     r0,[r4,#0]
000134  fbb0f1f7          UDIV     r1,r0,r7
000138  fb070011          MLS      r0,r7,r1,r0
00013c  8020              STRH     r0,[r4,#0]
;;;553                    pRxFIFO->currentProcessIndex = pRxFIFO->head;
00013e  8820              LDRH     r0,[r4,#0]
000140  80a0              STRH     r0,[r4,#4]
;;;554    
;;;555                    CAN_ConfirmTempCmdFrameBuff(pCB, sourceBuffSelect);
000142  4631              MOV      r1,r6
000144  4640              MOV      r0,r8
000146  f7fffffe          BL       CAN_ConfirmTempCmdFrameBuff
;;;556    
;;;557                    break;
00014a  e013              B        |L10.372|
                  |L10.332|
00014c  e00e              B        |L10.364|
                  |L10.334|
00014e  f8a59090          STRH     r9,[r5,#0x90]         ;541
000152  f8340f8c          LDRH     r0,[r4,#0x8c]!        ;543
000156  1c40              ADDS     r0,r0,#1              ;543
000158  8020              STRH     r0,[r4,#0]            ;543
00015a  8820              LDRH     r0,[r4,#0]            ;544
00015c  fbb0f1f7          UDIV     r1,r0,r7              ;544
000160  fb070011          MLS      r0,r7,r1,r0           ;544
000164  8020              STRH     r0,[r4,#0]            ;544
000166  8820              LDRH     r0,[r4,#0]            ;545
000168  80a0              STRH     r0,[r4,#4]            ;545
00016a  e003              B        |L10.372|
                  |L10.364|
00016c  f8b40090          LDRH     r0,[r4,#0x90]         ;498
000170  4288              CMP      r0,r1                 ;498
000172  d1a7              BNE      |L10.196|
                  |L10.372|
000174  1c76              ADDS     r6,r6,#1              ;439
000176  b2f6              UXTB     r6,r6                 ;439
000178  2e00              CMP      r6,#0                 ;439
00017a  f43faf4a          BEQ      |L10.18|
                  |L10.382|
;;;558                }
;;;559            }
;;;560        }
;;;561    
;;;562        return;
;;;563    }
00017e  e8bd87f0          POP      {r4-r10,pc}
;;;564    
                          ENDP


                          AREA ||i.CAN_TEST||, CODE, READONLY, ALIGN=1

                  CAN_TEST PROC
;;;84     
;;;85     void CAN_TEST(uint32 temp)
000000  b500              PUSH     {lr}
;;;86     {
;;;87         IAP_CTRL_CAN_TxAddData(CAN_CMD_HEAD);
000002  203a              MOVS     r0,#0x3a
000004  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;88         IAP_CTRL_CAN_TxAddData(IAP_CTRL_CAN_CMD_DOWN_PROJECT_APPLY_ACK);
000008  2002              MOVS     r0,#2
00000a  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;89         IAP_CTRL_CAN_TxAddData(2); // 数据长度
00000e  2002              MOVS     r0,#2
000010  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;90         IAP_CTRL_CAN_TxAddData(55);
000014  2037              MOVS     r0,#0x37
000016  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;91         IAP_CTRL_CAN_TxAddData(55);
00001a  2037              MOVS     r0,#0x37
00001c  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;92         IAP_CTRL_CAN_TxAddFrame();
000020  f85deb04          POP      {lr}
000024  f7ffbffe          B.W      IAP_CTRL_CAN_TxAddFrame
;;;93     }
;;;94     /*********************************************************
                          ENDP


                          AREA ||i.CAN_TxEnterState||, CODE, READONLY, ALIGN=2

                  CAN_TxEnterState PROC
;;;723    // CANTX状态迁移函数
;;;724    void CAN_TxEnterState(uint32 state)
000000  4902              LDR      r1,|L12.12|
;;;725    {
;;;726        // 让当前的状态成为历史
;;;727        canTxStateCB.preState = canTxStateCB.state;
000002  780a              LDRB     r2,[r1,#0]  ; canTxStateCB
000004  704a              STRB     r2,[r1,#1]
;;;728    
;;;729        // 设置新的状态
;;;730        canTxStateCB.state = (CAN_TX_STATE_E)state;
000006  7008              STRB     r0,[r1,#0]
;;;731    
;;;732        switch (state)
;;;733        {
;;;734        // ■■状态的入口处理■■
;;;735        case CAN_TX_STATE_NULL:
;;;736    
;;;737            break;
;;;738    
;;;739        // ■■入口状态的入口处理■■
;;;740        case CAN_TX_STATE_ENTRY:
;;;741    
;;;742            break;
;;;743    
;;;744        // ■■待机状态状态的入口处理■■
;;;745        case CAN_TX_STATE_STANDBY:
;;;746    
;;;747            break;
;;;748    
;;;749        // ■■CAN消息发送中■■
;;;750        case CAN_TX_STATE_SENDING:
;;;751    
;;;752            break;
;;;753    
;;;754        default:
;;;755            break;
;;;756        }
;;;757    }
000008  4770              BX       lr
;;;758    
                          ENDP

00000a  0000              DCW      0x0000
                  |L12.12|
                          DCD      ||.data||

                          AREA ||i.CAN_TxStateInit||, CODE, READONLY, ALIGN=1

                  CAN_TxStateInit PROC
;;;717    // CANTX状态机初始化
;;;718    void CAN_TxStateInit(void)
000000  2002              MOVS     r0,#2
;;;719    {
;;;720        CAN_TxEnterState(CAN_TX_STATE_STANDBY);
000002  f7ffbffe          B.W      CAN_TxEnterState
;;;721    }
;;;722    
                          ENDP


                          AREA ||i.CAN_TxStateProcess||, CODE, READONLY, ALIGN=2

                  CAN_TxStateProcess PROC
;;;794    // CANTX过程处理函数
;;;795    void CAN_TxStateProcess(void)
000000  b510              PUSH     {r4,lr}
;;;796    {
;;;797        uint16 head = sysCanCB.tx.head;
000002  480f              LDR      r0,|L14.64|
000004  f8b01910          LDRH     r1,[r0,#0x910]  ; sysCanCB
;;;798        uint16 end = sysCanCB.tx.end;
000008  f8b02912          LDRH     r2,[r0,#0x912]  ; sysCanCB
;;;799    
;;;800        switch (canTxStateCB.state)
00000c  480d              LDR      r0,|L14.68|
00000e  7800              LDRB     r0,[r0,#0]  ; canTxStateCB
000010  2800              CMP      r0,#0
000012  d013              BEQ      |L14.60|
000014  2801              CMP      r0,#1
000016  d011              BEQ      |L14.60|
000018  2802              CMP      r0,#2
00001a  d10f              BNE      |L14.60|
;;;801        {
;;;802        // ■■状态的入口处理■■
;;;803        case CAN_TX_STATE_NULL:
;;;804    
;;;805            break;
;;;806    
;;;807        // ■■入口状态的入口处理■■
;;;808        case CAN_TX_STATE_ENTRY:
;;;809    
;;;810            break;
;;;811    
;;;812        // ■■待机状态状态的入口处理■■
;;;813        case CAN_TX_STATE_STANDBY:
;;;814            // 检测是否有Tx请求
;;;815            if (head != end)
00001c  4291              CMP      r1,r2
00001e  d00d              BEQ      |L14.60|
;;;816            {
;;;817                // 调用此函数填充与启动发送can消息
;;;818                if (CAN_Tx_FillAndSend(&sysCanCB))
000020  4809              LDR      r0,|L14.72|
000022  f7fffffe          BL       CAN_Tx_FillAndSend
000026  b120              CBZ      r0,|L14.50|
;;;819                {
;;;820                    // 进入CAN消息发送中状态
;;;821                    CAN_TxEnterState(CAN_TX_STATE_SENDING);
000028  e8bd4010          POP      {r4,lr}
00002c  2004              MOVS     r0,#4
00002e  f7ffbffe          B.W      CAN_TxEnterState
                  |L14.50|
;;;822                }
;;;823                else
;;;824                {
;;;825                    // 进入CAN消息发送待机状态
;;;826                    CAN_TxEnterState(CAN_TX_STATE_STANDBY);
000032  e8bd4010          POP      {r4,lr}
000036  2002              MOVS     r0,#2
000038  f7ffbffe          B.W      CAN_TxEnterState
                  |L14.60|
;;;827                }
;;;828            }
;;;829            else
;;;830            {
;;;831                // 否则什么也不处理
;;;832            }
;;;833    
;;;834            break;
;;;835    
;;;836        // ■■CAN消息发送中■■
;;;837        case CAN_TX_STATE_SENDING:
;;;838    
;;;839            break;
;;;840    
;;;841        default:
;;;842            break;
;;;843        }
;;;844    }
00003c  bd10              POP      {r4,pc}
;;;845    
                          ENDP

00003e  0000              DCW      0x0000
                  |L14.64|
                          DCD      ||.bss||+0x2000
                  |L14.68|
                          DCD      ||.data||
                  |L14.72|
                          DCD      ||.bss||

                          AREA ||i.CAN_Tx_FillAndSend||, CODE, READONLY, ALIGN=2

                  CAN_Tx_FillAndSend PROC
;;;222    // 填充与发送处理:TRUE,填充与发送；FALSE，环形队列向前滑移.
;;;223    BOOL CAN_Tx_FillAndSend(CAN_CB *pCB)
000000  b5f0              PUSH     {r4-r7,lr}
;;;224    {
000002  b085              SUB      sp,sp,#0x14
;;;225        uint16 index = pCB->tx.index;                          // 当前发送数据的索引号
000004  f5005100          ADD      r1,r0,#0x2000
000008  f5016111          ADD      r1,r1,#0x910
00000c  888a              LDRH     r2,[r1,#4]
;;;226        uint16 length = pCB->tx.cmdQueue[pCB->tx.head].length; // 当前发送的命令帧的长度
00000e  880b              LDRH     r3,[r1,#0]
000010  eb030483          ADD      r4,r3,r3,LSL #2
000014  eb041343          ADD      r3,r4,r3,LSL #5
000018  eb000383          ADD      r3,r0,r3,LSL #2
00001c  f5035380          ADD      r3,r3,#0x1000
000020  f8b35848          LDRH     r5,[r3,#0x848]
;;;227        uint16 head = pCB->tx.head;                            // 发送命令帧队列头索引号
000024  880c              LDRH     r4,[r1,#0]
;;;228        uint16 end = pCB->tx.end;                              // 发送命令帧队列尾索引号
000026  884e              LDRH     r6,[r1,#2]
;;;229        CAN_CMD_FRAME *pCmd = &pCB->tx.cmdQueue[pCB->tx.head]; // 取当前发送缓冲区地址
000028  880b              LDRH     r3,[r1,#0]
00002a  f5a16111          SUB      r1,r1,#0x910
00002e  eb030783          ADD      r7,r3,r3,LSL #2
000032  eb071343          ADD      r3,r7,r3,LSL #5
000036  eb000383          ADD      r3,r0,r3,LSL #2
00003a  f24177b8          MOV      r7,#0x17b8
00003e  443b              ADD      r3,r3,r7
;;;230        can_trasnmit_message_struct canTxMsgCB;
;;;231        uint16 standardID = 0x000;
;;;232        uint8 i; // 内部赋值用
;;;233        uint32 extendedID;
;;;234    
;;;235        // 参数合法性检验
;;;236        if (NULL == pCB)
000040  2800              CMP      r0,#0
000042  d004              BEQ      |L15.78|
;;;237        {
;;;238            return FALSE;
;;;239        }
;;;240    
;;;241        // 队列为空，不处理
;;;242        if (head == end)
000044  42b4              CMP      r4,r6
000046  d104              BNE      |L15.82|
;;;243        {
;;;244            return FALSE;
000048  2000              MOVS     r0,#0
                  |L15.74|
;;;245        }
;;;246    
;;;247        // ■■执行到这里，说明队列非空■■
;;;248    
;;;249        // 当前命令帧未发送完时，根据长度的变化取出命令帧中的数据放到发送寄存器中
;;;250        if (index < length)
;;;251        {
;;;252            // 配置为标准帧
;;;253            // 配置为数据帧
;;;254            canTxMsgCB.tx_ft = CAN_FT_DATA;
;;;255            switch (dut_info.ID)
;;;256            {
;;;257    						case DUT_TYPE_GB:
;;;258    						case DUT_TYPE_KAIYANG:
;;;259    							// 扩展帧
;;;260    							canTxMsgCB.tx_ff = CAN_FF_EXTENDED;
;;;261    							extendedID = pCmd->deviceID;
;;;262    							canTxMsgCB.tx_efid = extendedID;
;;;263    							break;
;;;264    						default:
;;;265    							// 标准帧
;;;266    							canTxMsgCB.tx_ff = CAN_FF_STANDARD;
;;;267    							standardID = (uint16)CAN_DEVICE_ID_HMI; // id：001
;;;268    							canTxMsgCB.tx_sfid = standardID;
;;;269    							break;
;;;270            }
;;;271            // ■■标准数据帧CAN消息格式■■
;;;272    
;;;273            // 填充 DLC，最大8字节.当前长度>8字节，先发8字节。
;;;274            if ((length - index) >= CAN_ONCEMESSAGE_MAX_SIZE)
;;;275            {
;;;276                canTxMsgCB.tx_dlen = CAN_ONCEMESSAGE_MAX_SIZE;
;;;277            }
;;;278            else
;;;279            {
;;;280                canTxMsgCB.tx_dlen = length - index;
;;;281            }
;;;282    
;;;283            // 填充数据
;;;284            for (i = 0; i < canTxMsgCB.tx_dlen; i++)
;;;285            {
;;;286                canTxMsgCB.tx_data[i] = pCmd->buff[index + i];
;;;287            }
;;;288    
;;;289            // 发送数据
;;;290            if (can_message_transmit(CAN0, &canTxMsgCB) == CAN_TRANSMIT_NOMAILBOX)
;;;291            {
;;;292                return FALSE;
;;;293            }
;;;294    
;;;295            // 开启邮箱空中断
;;;296            can_interrupt_enable(CAN0, CAN_INT_TME);
;;;297    
;;;298            return TRUE;
;;;299        }
;;;300        // 当前命令帧发送完时，删除之
;;;301        else
;;;302        {
;;;303            pCB->tx.cmdQueue[head].length = 0;
;;;304            pCB->tx.head++;
;;;305            pCB->tx.head %= CAN_TX_QUEUE_SIZE;
;;;306            pCB->tx.index = 0;
;;;307    
;;;308            // 进入CAN消息发送待机状态
;;;309            CAN_TxEnterState(CAN_TX_STATE_STANDBY);
;;;310    
;;;311            return FALSE;
;;;312        }
;;;313    }
00004a  b005              ADD      sp,sp,#0x14
00004c  bdf0              POP      {r4-r7,pc}
                  |L15.78|
00004e  2000              MOVS     r0,#0                 ;238
000050  e7fb              B        |L15.74|
                  |L15.82|
000052  2600              MOVS     r6,#0                 ;250
000054  42aa              CMP      r2,r5                 ;250
000056  d237              BCS      |L15.200|
000058  f88d6009          STRB     r6,[sp,#9]            ;254
00005c  4828              LDR      r0,|L15.256|
00005e  7d80              LDRB     r0,[r0,#0x16]         ;255  ; dut_info
000060  2803              CMP      r0,#3                 ;255
000062  d00c              BEQ      |L15.126|
000064  2807              CMP      r0,#7                 ;255
000066  d00a              BEQ      |L15.126|
000068  f88d6008          STRB     r6,[sp,#8]            ;266
00006c  2001              MOVS     r0,#1                 ;267
00006e  9000              STR      r0,[sp,#0]            ;268
                  |L15.112|
000070  1aa8              SUBS     r0,r5,r2              ;274
000072  2808              CMP      r0,#8                 ;274
000074  db09              BLT      |L15.138|
000076  2008              MOVS     r0,#8                 ;276
000078  f88d000a          STRB     r0,[sp,#0xa]          ;276
00007c  e007              B        |L15.142|
                  |L15.126|
00007e  2004              MOVS     r0,#4                 ;260
000080  f88d0008          STRB     r0,[sp,#8]            ;260
000084  6818              LDR      r0,[r3,#0]            ;261
000086  9001              STR      r0,[sp,#4]            ;262
000088  e7f2              B        |L15.112|
                  |L15.138|
00008a  f88d000a          STRB     r0,[sp,#0xa]          ;280
                  |L15.142|
00008e  2000              MOVS     r0,#0                 ;284
000090  4669              MOV      r1,sp                 ;230
000092  e006              B        |L15.162|
                  |L15.148|
000094  1814              ADDS     r4,r2,r0              ;286
000096  441c              ADD      r4,r4,r3              ;286
000098  180d              ADDS     r5,r1,r0              ;286
00009a  7924              LDRB     r4,[r4,#4]            ;286
00009c  72ec              STRB     r4,[r5,#0xb]          ;286
00009e  1c40              ADDS     r0,r0,#1              ;284
0000a0  b2c0              UXTB     r0,r0                 ;284
                  |L15.162|
0000a2  f89d400a          LDRB     r4,[sp,#0xa]          ;284
0000a6  4284              CMP      r4,r0                 ;284
0000a8  d8f4              BHI      |L15.148|
0000aa  4c16              LDR      r4,|L15.260|
0000ac  4669              MOV      r1,sp                 ;290
0000ae  4620              MOV      r0,r4                 ;290
0000b0  f7fffffe          BL       can_message_transmit
0000b4  2804              CMP      r0,#4                 ;290
0000b6  d005              BEQ      |L15.196|
0000b8  2101              MOVS     r1,#1                 ;296
0000ba  4620              MOV      r0,r4                 ;296
0000bc  f7fffffe          BL       can_interrupt_enable
0000c0  2001              MOVS     r0,#1                 ;298
0000c2  e7c2              B        |L15.74|
                  |L15.196|
0000c4  2000              MOVS     r0,#0                 ;292
0000c6  e7c0              B        |L15.74|
                  |L15.200|
0000c8  eb040284          ADD      r2,r4,r4,LSL #2       ;303
0000cc  eb021244          ADD      r2,r2,r4,LSL #5       ;303
0000d0  eb000082          ADD      r0,r0,r2,LSL #2       ;303
0000d4  f5005080          ADD      r0,r0,#0x1000         ;303
0000d8  f8a06848          STRH     r6,[r0,#0x848]        ;303
0000dc  f5016111          ADD      r1,r1,#0x910          ;304
0000e0  8808              LDRH     r0,[r1,#0]            ;304
0000e2  1c40              ADDS     r0,r0,#1              ;304
0000e4  8008              STRH     r0,[r1,#0]            ;304
0000e6  8808              LDRH     r0,[r1,#0]            ;305
0000e8  221e              MOVS     r2,#0x1e              ;305
0000ea  fbb0f3f2          UDIV     r3,r0,r2              ;305
0000ee  fb020013          MLS      r0,r2,r3,r0           ;305
0000f2  8008              STRH     r0,[r1,#0]            ;305
0000f4  808e              STRH     r6,[r1,#4]            ;306
0000f6  2002              MOVS     r0,#2                 ;309
0000f8  f7fffffe          BL       CAN_TxEnterState
0000fc  2000              MOVS     r0,#0                 ;311
0000fe  e7a4              B        |L15.74|
;;;314    
                          ENDP

                  |L15.256|
                          DCD      dut_info
                  |L15.260|
                          DCD      0x40006400

                          AREA ||i.CAN_Tx_NextFram||, CODE, READONLY, ALIGN=1

                  CAN_Tx_NextFram PROC
;;;315    // 发送成功启动下一帧:TRUE,启动下一帧；FALSE，发送完成.
;;;316    BOOL CAN_Tx_NextFram(CAN_CB *pCB)
000000  b510              PUSH     {r4,lr}
;;;317    {
;;;318        uint16 index = pCB->tx.index;                          // 当前发送数据的索引号
000002  f5005100          ADD      r1,r0,#0x2000
000006  f8b13914          LDRH     r3,[r1,#0x914]
;;;319        uint16 length = pCB->tx.cmdQueue[pCB->tx.head].length; // 当前发送的命令帧的长度
00000a  f8b12910          LDRH     r2,[r1,#0x910]
00000e  eb020482          ADD      r4,r2,r2,LSL #2
000012  eb041242          ADD      r2,r4,r2,LSL #5
000016  eb000282          ADD      r2,r0,r2,LSL #2
00001a  f5025280          ADD      r2,r2,#0x1000
00001e  f8b22848          LDRH     r2,[r2,#0x848]
;;;320        uint8 txBnDLC = 0;
;;;321    
;;;322        // 参数合法性检验
;;;323        if (NULL == pCB)
000022  2800              CMP      r0,#0
000024  d004              BEQ      |L16.48|
;;;324        {
;;;325            return FALSE;
;;;326        }
;;;327    
;;;328        // 判断上一次成功发送的字节数.
;;;329        if (length - index >= CAN_ONCEMESSAGE_MAX_SIZE)
000026  1ad0              SUBS     r0,r2,r3
000028  2808              CMP      r0,#8
00002a  db03              BLT      |L16.52|
;;;330        {
;;;331            txBnDLC = CAN_ONCEMESSAGE_MAX_SIZE;
00002c  2008              MOVS     r0,#8
00002e  e002              B        |L16.54|
                  |L16.48|
000030  2000              MOVS     r0,#0                 ;325
;;;332        }
;;;333        else
;;;334        {
;;;335            txBnDLC = length - index;
;;;336        }
;;;337        pCB->tx.index += txBnDLC;
;;;338    
;;;339        // 启动下一帧
;;;340        if (pCB->tx.index < length)
;;;341        {
;;;342            // 进入CAN消息下一帧发送状态
;;;343            return TRUE;
;;;344        }
;;;345        else
;;;346        {
;;;347            // 发送完成
;;;348            return FALSE;
;;;349        }
;;;350    }
000032  bd10              POP      {r4,pc}
                  |L16.52|
000034  b2c0              UXTB     r0,r0                 ;335
                  |L16.54|
000036  f6011114          ADD      r1,r1,#0x914          ;337
00003a  880b              LDRH     r3,[r1,#0]            ;337
00003c  4418              ADD      r0,r0,r3              ;337
00003e  8008              STRH     r0,[r1,#0]            ;337
000040  8808              LDRH     r0,[r1,#0]            ;340
000042  4290              CMP      r0,r2                 ;340
000044  d201              BCS      |L16.74|
000046  2001              MOVS     r0,#1                 ;343
000048  bd10              POP      {r4,pc}
                  |L16.74|
00004a  2000              MOVS     r0,#0                 ;348
00004c  bd10              POP      {r4,pc}
;;;351    
                          ENDP


                          AREA ||i.IAP_CTRL_CAN_Init||, CODE, READONLY, ALIGN=2

                  IAP_CTRL_CAN_Init PROC
;;;98     // CAN 初始化
;;;99     void IAP_CTRL_CAN_Init(uint16 bund)
000000  b510              PUSH     {r4,lr}
;;;100    {
;;;101        // 初始化硬件配置
;;;102        CAN_HW_Init(bund);
000002  f7fffffe          BL       CAN_HW_Init
;;;103    
;;;104        // 初始化结构体
;;;105        CAN_DataStructureInit(&sysCanCB);
000006  4803              LDR      r0,|L17.20|
000008  f7fffffe          BL       CAN_DataStructureInit
;;;106    
;;;107        // CAN发送状态机初始化
;;;108        CAN_TxStateInit();
00000c  e8bd4010          POP      {r4,lr}
000010  f7ffbffe          B.W      CAN_TxStateInit
;;;109    }
;;;110    
                          ENDP

                  |L17.20|
                          DCD      ||.bss||

                          AREA ||i.IAP_CTRL_CAN_SendCmdCheckFlashBlankResult||, CODE, READONLY, ALIGN=1

                  IAP_CTRL_CAN_SendCmdCheckFlashBlankResult PROC
;;;1075   // 查空结果上报
;;;1076   void IAP_CTRL_CAN_SendCmdCheckFlashBlankResult(uint8 param)
000000  b510              PUSH     {r4,lr}
;;;1077   {
000002  4604              MOV      r4,r0
;;;1078       IAP_CTRL_CAN_TxAddData(CAN_CMD_HEAD);
000004  203a              MOVS     r0,#0x3a
000006  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1079       IAP_CTRL_CAN_TxAddData(IAP_CTRL_CAN_CMD_UP_CHECK_FLASH_BLANK_RESULT);
00000a  2029              MOVS     r0,#0x29
00000c  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1080       IAP_CTRL_CAN_TxAddData(1); // 数据长度
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1081       IAP_CTRL_CAN_TxAddData(param);
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1082       IAP_CTRL_CAN_TxAddFrame();
00001c  e8bd4010          POP      {r4,lr}
000020  f7ffbffe          B.W      IAP_CTRL_CAN_TxAddFrame
;;;1083   }
;;;1084   
                          ENDP


                          AREA ||i.IAP_CTRL_CAN_SendCmdEraseFlashResult||, CODE, READONLY, ALIGN=1

                  IAP_CTRL_CAN_SendCmdEraseFlashResult PROC
;;;1055   // 擦除FLASH结果上报
;;;1056   void IAP_CTRL_CAN_SendCmdEraseFlashResult(uint8 param)
000000  b510              PUSH     {r4,lr}
;;;1057   {
000002  4604              MOV      r4,r0
;;;1058       IAP_CTRL_CAN_TxAddData(CAN_CMD_HEAD);
000004  203a              MOVS     r0,#0x3a
000006  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1059       IAP_CTRL_CAN_TxAddData(IAP_CTRL_CAN_CMD_UP_IAP_ERASE_FLASH_RESULT);
00000a  2025              MOVS     r0,#0x25
00000c  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1060       IAP_CTRL_CAN_TxAddData(1); // 数据长度
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1061       IAP_CTRL_CAN_TxAddData(param);
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1062       IAP_CTRL_CAN_TxAddFrame();
00001c  e8bd4010          POP      {r4,lr}
000020  f7ffbffe          B.W      IAP_CTRL_CAN_TxAddFrame
;;;1063   }
;;;1064   
                          ENDP


                          AREA ||i.IAP_CTRL_CAN_SendCmdNoAck||, CODE, READONLY, ALIGN=1

                  IAP_CTRL_CAN_SendCmdNoAck PROC
;;;975    // 发送命令不带应答
;;;976    void IAP_CTRL_CAN_SendCmdNoAck(uint8 param)
000000  b510              PUSH     {r4,lr}
;;;977    {
000002  4604              MOV      r4,r0
;;;978        IAP_CTRL_CAN_TxAddData(CAN_CMD_HEAD);
000004  203a              MOVS     r0,#0x3a
000006  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;979        IAP_CTRL_CAN_TxAddData(param);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;980        IAP_CTRL_CAN_TxAddData(0);
000010  2000              MOVS     r0,#0
000012  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;981        IAP_CTRL_CAN_TxAddData(1); // 段码屏工程允许
000016  2001              MOVS     r0,#1
000018  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;982        IAP_CTRL_CAN_TxAddFrame();
00001c  e8bd4010          POP      {r4,lr}
000020  f7ffbffe          B.W      IAP_CTRL_CAN_TxAddFrame
;;;983    }
;;;984    
                          ENDP


                          AREA ||i.IAP_CTRL_CAN_SendCmdProjectApply||, CODE, READONLY, ALIGN=1

                  IAP_CTRL_CAN_SendCmdProjectApply PROC
;;;1027   // 工程模式启用
;;;1028   void IAP_CTRL_CAN_SendCmdProjectApply(uint8 *param)
000000  b570              PUSH     {r4-r6,lr}
;;;1029   {
000002  4605              MOV      r5,r0
;;;1030       uint8 len = strlen((char *)param);
000004  4628              MOV      r0,r5
000006  f7fffffe          BL       strlen
00000a  b2c6              UXTB     r6,r0
;;;1031       uint8 i;
;;;1032   
;;;1033       IAP_CTRL_CAN_TxAddData(CAN_CMD_HEAD);
00000c  203a              MOVS     r0,#0x3a
00000e  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1034       IAP_CTRL_CAN_TxAddData(IAP_CTRL_CAN_CMD_UP_PROJECT_APPLY);
000012  2001              MOVS     r0,#1
000014  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1035       IAP_CTRL_CAN_TxAddData(len); // 数据长度
000018  4630              MOV      r0,r6
00001a  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1036   
;;;1037       for (i = 0; i < len; i++)
00001e  2400              MOVS     r4,#0
000020  e004              B        |L21.44|
                  |L21.34|
;;;1038       {
;;;1039           IAP_CTRL_CAN_TxAddData(param[i]);
000022  5d28              LDRB     r0,[r5,r4]
000024  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
000028  1c64              ADDS     r4,r4,#1              ;1037
00002a  b2e4              UXTB     r4,r4                 ;1037
                  |L21.44|
00002c  42b4              CMP      r4,r6                 ;1037
00002e  d3f8              BCC      |L21.34|
;;;1040       }
;;;1041   
;;;1042       IAP_CTRL_CAN_TxAddFrame();
000030  e8bd4070          POP      {r4-r6,lr}
000034  f7ffbffe          B.W      IAP_CTRL_CAN_TxAddFrame
;;;1043   }
;;;1044   
                          ENDP


                          AREA ||i.IAP_CTRL_CAN_SendCmdProjectReady||, CODE, READONLY, ALIGN=1

                  IAP_CTRL_CAN_SendCmdProjectReady PROC
;;;1045   // 工程模式准备就绪报告
;;;1046   void IAP_CTRL_CAN_SendCmdProjectReady(uint8 param)
000000  b510              PUSH     {r4,lr}
;;;1047   {
000002  4604              MOV      r4,r0
;;;1048       IAP_CTRL_CAN_TxAddData(CAN_CMD_HEAD);
000004  203a              MOVS     r0,#0x3a
000006  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1049       IAP_CTRL_CAN_TxAddData(IAP_CTRL_CAN_CMD_UP_PROJECT_READY);
00000a  2003              MOVS     r0,#3
00000c  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1050       IAP_CTRL_CAN_TxAddData(1); // 数据长度
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1051       IAP_CTRL_CAN_TxAddData(param);
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1052       IAP_CTRL_CAN_TxAddFrame();
00001c  e8bd4010          POP      {r4,lr}
000020  f7ffbffe          B.W      IAP_CTRL_CAN_TxAddFrame
;;;1053   }
;;;1054   
                          ENDP


                          AREA ||i.IAP_CTRL_CAN_SendCmdTest||, CODE, READONLY, ALIGN=1

                  IAP_CTRL_CAN_SendCmdTest PROC
;;;1114   // 发送命令测试
;;;1115   void IAP_CTRL_CAN_SendCmdTest(uint32 param)
000000  b500              PUSH     {lr}
;;;1116   {
;;;1117       IAP_CTRL_CAN_TxAddData(CAN_CMD_HEAD);
000002  203a              MOVS     r0,#0x3a
000004  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1118       IAP_CTRL_CAN_TxAddData(1);
000008  2001              MOVS     r0,#1
00000a  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1119       IAP_CTRL_CAN_TxAddData(0);
00000e  2000              MOVS     r0,#0
000010  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1120       IAP_CTRL_CAN_TxAddData(1); // 段码屏工程允许
000014  2001              MOVS     r0,#1
000016  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1121       IAP_CTRL_CAN_TxAddFrame();
00001a  f85deb04          POP      {lr}
00001e  f7ffbffe          B.W      IAP_CTRL_CAN_TxAddFrame
;;;1122   }
                          ENDP


                          AREA ||i.IAP_CTRL_CAN_SendCmdUpdataFinishResult||, CODE, READONLY, ALIGN=1

                  IAP_CTRL_CAN_SendCmdUpdataFinishResult PROC
;;;1085   //// 系统升级结束确认
;;;1086   void IAP_CTRL_CAN_SendCmdUpdataFinishResult(uint8 param)
000000  b500              PUSH     {lr}
;;;1087   {
;;;1088     IAP_CTRL_CAN_TxAddData(CAN_CMD_HEAD);
000002  203a              MOVS     r0,#0x3a
000004  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1089     IAP_CTRL_CAN_TxAddData(IAP_CTRL_CAN_CMD_UP_UPDATA_FINISH_RESULT);
000008  202b              MOVS     r0,#0x2b
00000a  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1090     IAP_CTRL_CAN_TxAddData(0); // 数据长度
00000e  2000              MOVS     r0,#0
000010  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1091     IAP_CTRL_CAN_TxAddFrame();
000014  f85deb04          POP      {lr}
000018  f7ffbffe          B.W      IAP_CTRL_CAN_TxAddFrame
;;;1092   }
;;;1093   
                          ENDP


                          AREA ||i.IAP_CTRL_CAN_SendCmdWriteFlashResult||, CODE, READONLY, ALIGN=1

                  IAP_CTRL_CAN_SendCmdWriteFlashResult PROC
;;;1065   // IAP数据写入结果上报
;;;1066   void IAP_CTRL_CAN_SendCmdWriteFlashResult(uint8 param)
000000  b510              PUSH     {r4,lr}
;;;1067   {
000002  4604              MOV      r4,r0
;;;1068       IAP_CTRL_CAN_TxAddData(CAN_CMD_HEAD);
000004  203a              MOVS     r0,#0x3a
000006  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1069       IAP_CTRL_CAN_TxAddData(IAP_CTRL_CAN_CMD_UP_IAP_WRITE_FLASH_RESULT);
00000a  2027              MOVS     r0,#0x27
00000c  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1070       IAP_CTRL_CAN_TxAddData(1); // 数据长度
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1071       IAP_CTRL_CAN_TxAddData(param);
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1072       IAP_CTRL_CAN_TxAddFrame();
00001c  e8bd4010          POP      {r4,lr}
000020  f7ffbffe          B.W      IAP_CTRL_CAN_TxAddFrame
;;;1073   }
;;;1074   
                          ENDP


                          AREA ||i.IAP_CTRL_CAN_SendUpDataPacket||, CODE, READONLY, ALIGN=2

                  IAP_CTRL_CAN_SendUpDataPacket PROC
;;;985    // 发送升级数据
;;;986    void IAP_CTRL_CAN_SendUpDataPacket(DUT_FILE_TYPE upDataType, CAN_CMD cmd, uint32 flashAddr, uint32 addr)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;987    {
000004  460f              MOV      r7,r1
;;;988        uint8 i = 0;
000006  2400              MOVS     r4,#0
;;;989        switch (upDataType)
000008  2600              MOVS     r6,#0
;;;990        {
;;;991        case DUT_FILE_TYPE_HEX:                          // hex
;;;992            dut_info.reconnectionRepeatContent[0] = 121; // 总长度
;;;993            dut_info.reconnectionRepeatContent[1] = CAN_CMD_HEAD;
;;;994            dut_info.reconnectionRepeatContent[2] = cmd;
;;;995            dut_info.reconnectionRepeatContent[3] = 0;                                            // 数据长度
;;;996            dut_info.reconnectionRepeatContent[4] = 0;                                            // 添加是否加密
;;;997            dut_info.reconnectionRepeatContent[5] = 0;                                            // 添加密钥
;;;998            SPI_FLASH_ReadArray(&dut_info.reconnectionRepeatContent[6], flashAddr + (addr), 116); // 工具读取 4+112 个字节
00000a  18d1              ADDS     r1,r2,r3
00000c  4d20              LDR      r5,|L26.144|
00000e  f04f0c3a          MOV      r12,#0x3a             ;993
000012  2801              CMP      r0,#1                 ;989
000014  d01a              BEQ      |L26.76|
000016  2804              CMP      r0,#4                 ;989
000018  d135              BNE      |L26.134|
00001a  2079              MOVS     r0,#0x79              ;992
00001c  f8050f73          STRB     r0,[r5,#0x73]!        ;992
000020  f885c001          STRB     r12,[r5,#1]           ;993
000024  70af              STRB     r7,[r5,#2]            ;994
000026  70ee              STRB     r6,[r5,#3]            ;995
000028  712e              STRB     r6,[r5,#4]            ;996
00002a  716e              STRB     r6,[r5,#5]            ;997
00002c  3d73              SUBS     r5,r5,#0x73           ;997
00002e  4818              LDR      r0,|L26.144|
000030  2274              MOVS     r2,#0x74
000032  3079              ADDS     r0,r0,#0x79
000034  f7fffffe          BL       SPI_FLASH_ReadArray
                  |L26.56|
;;;999            for (i = 0; i < 121; i++)                                                             // 添加数据
;;;1000           {
;;;1001               IAP_CTRL_CAN_TxAddData(dut_info.reconnectionRepeatContent[i + 1]);
000038  1928              ADDS     r0,r5,r4
00003a  f8900074          LDRB     r0,[r0,#0x74]
00003e  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
000042  1c64              ADDS     r4,r4,#1              ;999
000044  b2e4              UXTB     r4,r4                 ;999
000046  2c79              CMP      r4,#0x79              ;999
000048  d3f6              BCC      |L26.56|
00004a  e01c              B        |L26.134|
                  |L26.76|
;;;1002           }
;;;1003           break;
;;;1004   
;;;1005       case DUT_FILE_TYPE_BIN:                          // bin
;;;1006           dut_info.reconnectionRepeatContent[0] = 135; // 总长度
00004c  2087              MOVS     r0,#0x87
00004e  f8050f73          STRB     r0,[r5,#0x73]!
;;;1007           dut_info.reconnectionRepeatContent[1] = CAN_CMD_HEAD;
000052  f885c001          STRB     r12,[r5,#1]
;;;1008           dut_info.reconnectionRepeatContent[2] = cmd;
000056  70af              STRB     r7,[r5,#2]
;;;1009           dut_info.reconnectionRepeatContent[3] = 0;                                            // 数据长度
000058  70ee              STRB     r6,[r5,#3]
;;;1010           dut_info.reconnectionRepeatContent[4] = ((addr) & 0xFF000000) >> 24;                  // 数据长度
00005a  0e18              LSRS     r0,r3,#24
00005c  7128              STRB     r0,[r5,#4]
;;;1011           dut_info.reconnectionRepeatContent[5] = ((addr) & 0x00FF0000) >> 16;                  // 数据长度
00005e  0c18              LSRS     r0,r3,#16
000060  7168              STRB     r0,[r5,#5]
;;;1012           dut_info.reconnectionRepeatContent[6] = ((addr) & 0x0000FF00) >> 8;                   // 数据长度
000062  0a18              LSRS     r0,r3,#8
000064  71a8              STRB     r0,[r5,#6]
;;;1013           dut_info.reconnectionRepeatContent[7] = ((addr) & 0x000000FF);                        // 数据长度
000066  71eb              STRB     r3,[r5,#7]
000068  3d73              SUBS     r5,r5,#0x73
;;;1014           SPI_FLASH_ReadArray(&dut_info.reconnectionRepeatContent[8], flashAddr + (addr), 128); // 工具读取128字节
00006a  4809              LDR      r0,|L26.144|
00006c  2280              MOVS     r2,#0x80
00006e  307b              ADDS     r0,r0,#0x7b
000070  f7fffffe          BL       SPI_FLASH_ReadArray
                  |L26.116|
;;;1015           for (i = 0; i < 135; i++)                                                             // 添加数据
;;;1016           {
;;;1017               IAP_CTRL_CAN_TxAddData(dut_info.reconnectionRepeatContent[i + 1]);
000074  1928              ADDS     r0,r5,r4
000076  f8900074          LDRB     r0,[r0,#0x74]
00007a  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
00007e  1c64              ADDS     r4,r4,#1              ;1015
000080  b2e4              UXTB     r4,r4                 ;1015
000082  2c87              CMP      r4,#0x87              ;1015
000084  d3f6              BCC      |L26.116|
                  |L26.134|
;;;1018           }
;;;1019           break;
;;;1020       default:
;;;1021           break;
;;;1022       }
;;;1023   
;;;1024       IAP_CTRL_CAN_TxAddFrame(); // 调整帧格式,修改长度和添加校验
000086  e8bd41f0          POP      {r4-r8,lr}
00008a  f7ffbffe          B.W      IAP_CTRL_CAN_TxAddFrame
;;;1025   }
;;;1026   
                          ENDP

00008e  0000              DCW      0x0000
                  |L26.144|
                          DCD      dut_info

                          AREA ||i.IAP_CTRL_CAN_TxAddData||, CODE, READONLY, ALIGN=2

                  IAP_CTRL_CAN_TxAddData PROC
;;;150    // 向发送命令帧队列中添加数据
;;;151    void IAP_CTRL_CAN_TxAddData(uint8 data)
000000  b530              PUSH     {r4,r5,lr}
;;;152    {
;;;153        uint16 head = sysCanCB.tx.head;
000002  4910              LDR      r1,|L27.68|
000004  880c              LDRH     r4,[r1,#0]  ; sysCanCB
;;;154        uint16 end = sysCanCB.tx.end;
000006  884a              LDRH     r2,[r1,#2]  ; sysCanCB
;;;155        CAN_CMD_FRAME *pCmdFrame = &sysCanCB.tx.cmdQueue[sysCanCB.tx.end];
000008  8849              LDRH     r1,[r1,#2]  ; sysCanCB
00000a  eb010381          ADD      r3,r1,r1,LSL #2
00000e  eb031141          ADD      r1,r3,r1,LSL #5
000012  4b0d              LDR      r3,|L27.72|
000014  eb030181          ADD      r1,r3,r1,LSL #2
000018  f24173b8          MOV      r3,#0x17b8
00001c  4419              ADD      r1,r1,r3
;;;156    
;;;157        // 发送缓冲区已满，不予接收
;;;158        if ((end + 1) % CAN_TX_QUEUE_SIZE == head)
00001e  1c52              ADDS     r2,r2,#1
000020  231e              MOVS     r3,#0x1e
000022  fbb2f5f3          UDIV     r5,r2,r3
000026  fb032215          MLS      r2,r3,r5,r2
00002a  42a2              CMP      r2,r4
00002c  d009              BEQ      |L27.66|
;;;159        {
;;;160            return;
;;;161        }
;;;162    
;;;163        // 队尾命令帧已满，退出
;;;164        if (pCmdFrame->length >= CAN_CMD_FRAME_LENGTH_MAX)
00002e  f8b12090          LDRH     r2,[r1,#0x90]
000032  2a8c              CMP      r2,#0x8c
000034  d205              BCS      |L27.66|
;;;165        {
;;;166            return;
;;;167        }
;;;168    
;;;169        // 数据添加到帧末尾，并更新帧长度
;;;170        pCmdFrame->buff[pCmdFrame->length] = data;
000036  1d0b              ADDS     r3,r1,#4
000038  54d0              STRB     r0,[r2,r3]
;;;171        pCmdFrame->length++;
00003a  f8310f90          LDRH     r0,[r1,#0x90]!
00003e  1c40              ADDS     r0,r0,#1
000040  8008              STRH     r0,[r1,#0]
                  |L27.66|
;;;172    }
000042  bd30              POP      {r4,r5,pc}
;;;173    
                          ENDP

                  |L27.68|
                          DCD      ||.bss||+0x2910
                  |L27.72|
                          DCD      ||.bss||

                          AREA ||i.IAP_CTRL_CAN_TxAddFrame||, CODE, READONLY, ALIGN=2

                  IAP_CTRL_CAN_TxAddFrame PROC
;;;174    // 发送命令帧处理,自动扶正帧长度以及检验码
;;;175    void IAP_CTRL_CAN_TxAddFrame(void)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;176    {
;;;177        uint16 head = sysCanCB.tx.head;
000004  4c25              LDR      r4,|L28.156|
000006  f8b41910          LDRH     r1,[r4,#0x910]  ; sysCanCB
;;;178        uint16 end = sysCanCB.tx.end;
00000a  f8b42912          LDRH     r2,[r4,#0x912]  ; sysCanCB
;;;179        uint8 *buff = sysCanCB.tx.cmdQueue[end].buff;
00000e  f5a45700          SUB      r7,r4,#0x2000
000012  eb020082          ADD      r0,r2,r2,LSL #2
000016  eb001042          ADD      r0,r0,r2,LSL #5
00001a  eb070580          ADD      r5,r7,r0,LSL #2
00001e  f24170bc          MOV      r0,#0x17bc
000022  4428              ADD      r0,r0,r5
;;;180        uint16 length = sysCanCB.tx.cmdQueue[end].length;
000024  f5055580          ADD      r5,r5,#0x1000
000028  f8b56848          LDRH     r6,[r5,#0x848]
;;;181        uint8 cmdHead = buff[CAN_CMD_HEAD_INDEX]; // 帧头
00002c  7803              LDRB     r3,[r0,#0]
;;;182    
;;;183        // 发送缓冲区已满，不予接收
;;;184        if ((end + 1) % CAN_TX_QUEUE_SIZE == head)
00002e  1c52              ADDS     r2,r2,#1
000030  f04f081e          MOV      r8,#0x1e
000034  fbb2fcf8          UDIV     r12,r2,r8
000038  fb08221c          MLS      r2,r8,r12,r2
00003c  428a              CMP      r2,r1
00003e  d005              BEQ      |L28.76|
;;;185        {
;;;186            return;
;;;187        }
;;;188    
;;;189        // 命令头错误
;;;190        if (CAN_CMD_HEAD != cmdHead)
000040  f04f0900          MOV      r9,#0
000044  2b3a              CMP      r3,#0x3a
000046  d003              BEQ      |L28.80|
;;;191        {
;;;192            // 把帧数据索引放在最开始位置
;;;193            sysCanCB.tx.cmdQueue[end].length = 0;
000048  f8a59848          STRH     r9,[r5,#0x848]
                  |L28.76|
;;;194            return;
;;;195        }
;;;196    
;;;197        // 命令头正确，但数据长度不对(数据长度减去CRC的长度)
;;;198        if ((CAN_CMD_FRAME_LENGTH_MAX - CAN_CHECK_BYTE_SIZE < length) || (CAN_CMD_FRAME_LENGTH_MIN - CAN_CHECK_BYTE_SIZE > length))
;;;199        {
;;;200            // 把帧数据索引放在最开始位置
;;;201            sysCanCB.tx.cmdQueue[end].length = 0;
;;;202            buff[CAN_CMD_HEAD_INDEX] = CAN_CMD_NONHEAD; // 避免数据没更新时，再次进入
;;;203            return;
;;;204        }
;;;205    
;;;206        // 执行到此，命令头正确，数据长度正确,发送缓冲区未满
;;;207        // 长度扶正
;;;208        buff[CAN_CMD_LENGTH_INDEX] = length - CAN_CMD_FRAME_LENGTH_MIN + CAN_CHECK_BYTE_SIZE;
;;;209    
;;;210        // 填充CRC校验码
;;;211        CAN_AddSum(buff, length);
;;;212    
;;;213        // 将数据长度填到待发送缓冲器
;;;214        sysCanCB.tx.cmdQueue[end].length = length + CAN_CHECK_BYTE_SIZE;
;;;215    
;;;216        // 发送环形队列更新位置
;;;217        sysCanCB.tx.end++;
;;;218        sysCanCB.tx.end %= CAN_TX_QUEUE_SIZE;
;;;219        sysCanCB.tx.cmdQueue[sysCanCB.tx.end].length = 0; // 2015.12.2修改
;;;220    }
00004c  e8bd83f0          POP      {r4-r9,pc}
                  |L28.80|
000050  1ef1              SUBS     r1,r6,#3              ;198
000052  2989              CMP      r1,#0x89              ;198
000054  d304              BCC      |L28.96|
000056  f8a59848          STRH     r9,[r5,#0x848]        ;201
00005a  21ff              MOVS     r1,#0xff              ;202
00005c  7001              STRB     r1,[r0,#0]            ;202
00005e  e7f5              B        |L28.76|
                  |L28.96|
000060  7081              STRB     r1,[r0,#2]            ;208
000062  4631              MOV      r1,r6                 ;211
000064  f7fffffe          BL       CAN_AddSum
000068  1c76              ADDS     r6,r6,#1              ;214
00006a  f8a56848          STRH     r6,[r5,#0x848]        ;214
00006e  f6041412          ADD      r4,r4,#0x912          ;217
000072  8820              LDRH     r0,[r4,#0]            ;217  ; sysCanCB
000074  1c40              ADDS     r0,r0,#1              ;217
000076  8020              STRH     r0,[r4,#0]            ;217
000078  8820              LDRH     r0,[r4,#0]            ;218  ; sysCanCB
00007a  fbb0f1f8          UDIV     r1,r0,r8              ;218
00007e  fb080011          MLS      r0,r8,r1,r0           ;218
000082  8020              STRH     r0,[r4,#0]            ;218
000084  8820              LDRH     r0,[r4,#0]            ;219  ; sysCanCB
000086  eb000180          ADD      r1,r0,r0,LSL #2       ;219
00008a  eb011040          ADD      r0,r1,r0,LSL #5       ;219
00008e  eb070080          ADD      r0,r7,r0,LSL #2       ;219
000092  f5005080          ADD      r0,r0,#0x1000         ;219
000096  f8a09848          STRH     r9,[r0,#0x848]        ;219
00009a  e7d7              B        |L28.76|
;;;221    
                          ENDP

                  |L28.156|
                          DCD      ||.bss||+0x2000

                          AREA ||i.USBD_HP_CAN0_TX_IRQHandler||, CODE, READONLY, ALIGN=2

                  USBD_HP_CAN0_TX_IRQHandler PROC
;;;951    // ISR for CAN TX Interrupt
;;;952    void USBD_HP_CAN0_TX_IRQHandler(void)
000000  b570              PUSH     {r4-r6,lr}
;;;953    {
;;;954        uint16 head = sysCanCB.tx.head;
000002  480a              LDR      r0,|L29.44|
000004  f8b04910          LDRH     r4,[r0,#0x910]  ; sysCanCB
;;;955        uint16 end = sysCanCB.tx.end;
000008  f8b05912          LDRH     r5,[r0,#0x912]  ; sysCanCB
;;;956    
;;;957        // 清空邮箱空中断标志位
;;;958        can_interrupt_disable(CAN0, CAN_INT_TME);
00000c  2101              MOVS     r1,#1
00000e  4808              LDR      r0,|L29.48|
000010  f7fffffe          BL       can_interrupt_disable
;;;959    
;;;960        // 检测是否有Tx请求
;;;961        if (head != end)
000014  42ac              CMP      r4,r5
000016  d007              BEQ      |L29.40|
;;;962        {
;;;963            // Tx成功，判断是否有下一帧
;;;964            CAN_Tx_NextFram(&sysCanCB);
000018  4806              LDR      r0,|L29.52|
00001a  f7fffffe          BL       CAN_Tx_NextFram
;;;965    
;;;966            // 进入CAN消息下一帧发送状态
;;;967            CAN_Tx_FillAndSend(&sysCanCB);
00001e  e8bd4070          POP      {r4-r6,lr}
000022  4804              LDR      r0,|L29.52|
000024  f7ffbffe          B.W      CAN_Tx_FillAndSend
                  |L29.40|
;;;968        }
;;;969    }
000028  bd70              POP      {r4-r6,pc}
;;;970    
                          ENDP

00002a  0000              DCW      0x0000
                  |L29.44|
                          DCD      ||.bss||+0x2000
                  |L29.48|
                          DCD      0x40006400
                  |L29.52|
                          DCD      ||.bss||

                          AREA ||i.USBD_LP_CAN0_RX0_IRQHandler||, CODE, READONLY, ALIGN=2

                  USBD_LP_CAN0_RX0_IRQHandler PROC
;;;927    // ISR for CAN RX Interrupt
;;;928    void USBD_LP_CAN0_RX0_IRQHandler(void)
000000  b530              PUSH     {r4,r5,lr}
;;;929    {
000002  b085              SUB      sp,sp,#0x14
;;;930        can_receive_message_struct rxMessage1;
;;;931    
;;;932        // 读出FIFO中所有的数据
;;;933        while (can_receive_message_length_get(CAN0, CAN_FIFO0))
;;;934        {
;;;935            can_message_receive(CAN0, CAN_FIFO0, &rxMessage1);
000004  4c0b              LDR      r4,|L30.52|
;;;936    
;;;937            //switch (dut_info.ID)
;;;938            //{
;;;939            //case DUT_TYPE_GB:
;;;940            //  CAN_MacProcess(rxMessage1.rx_efid, &rxMessage1.rx_data[0], rxMessage1.rx_dlen);
;;;941            //  CAN_PROTOCOL_MacProcess(rxMessage1.rx_efid, &rxMessage1.rx_data[0], rxMessage1.rx_dlen);
;;;942            //  break;
;;;943            //default:
;;;944            CAN_PROTOCOL1_MacProcess(rxMessage1.rx_sfid, &rxMessage1.rx_data[0], rxMessage1.rx_dlen); // 升级config
000006  f10d050b          ADD      r5,sp,#0xb
00000a  e00a              B        |L30.34|
                  |L30.12|
00000c  466a              MOV      r2,sp                 ;935
00000e  2100              MOVS     r1,#0                 ;935
000010  4620              MOV      r0,r4                 ;935
000012  f7fffffe          BL       can_message_receive
000016  f89d200a          LDRB     r2,[sp,#0xa]
00001a  4629              MOV      r1,r5
00001c  9800              LDR      r0,[sp,#0]
00001e  f7fffffe          BL       CAN_PROTOCOL1_MacProcess
                  |L30.34|
000022  2100              MOVS     r1,#0                 ;933
000024  4620              MOV      r0,r4                 ;933
000026  f7fffffe          BL       can_receive_message_length_get
00002a  2800              CMP      r0,#0                 ;933
00002c  d1ee              BNE      |L30.12|
;;;945            //  CAN_MacProcess(rxMessage1.rx_sfid, &rxMessage1.rx_data[0], rxMessage1.rx_dlen);           // 55升级协议
;;;946            //  break;
;;;947            //}
;;;948        }
;;;949    }
00002e  b005              ADD      sp,sp,#0x14
000030  bd30              POP      {r4,r5,pc}
;;;950    
                          ENDP

000032  0000              DCW      0x0000
                  |L30.52|
                          DCD      0x40006400

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  sysCanCB
                          %        10520

                          AREA ||.data||, DATA, ALIGN=0

                  canTxStateCB
                          DCDU     0x00000000
000004  000000            DCB      0x00,0x00,0x00

;*** Start embedded assembler ***

#line 1 "User\\DutCanDrive.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_DutCanDrive_c_CAN_TEST____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___13_DutCanDrive_c_CAN_TEST____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_DutCanDrive_c_CAN_TEST____REVSH|
#line 128
|__asm___13_DutCanDrive_c_CAN_TEST____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
