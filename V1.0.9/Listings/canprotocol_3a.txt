; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\canprotocol_3a.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\canprotocol_3a.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -I.\User\qrencode -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.3\Device\Include -D__MICROLIB -D__UVISION_VERSION=539 -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\canprotocol_3a.crf User\CanProtocol_3A.c]
                          THUMB

                          AREA ||i.CAN_PROTOCOL1_CALLBACK_UartBusError||, CODE, READONLY, ALIGN=1

                  CAN_PROTOCOL1_CALLBACK_UartBusError PROC
;;;616    //  UART总线超时错误处理
;;;617    void CAN_PROTOCOL1_CALLBACK_UartBusError(uint32 param)
000000  4770              BX       lr
;;;618    {
;;;619    }
;;;620    
                          ENDP


                          AREA ||i.CAN_PROTOCOL1_CheckSUM||, CODE, READONLY, ALIGN=1

                  CAN_PROTOCOL1_CheckSUM PROC
;;;477    // 对传入的命令帧进行校验，返回校验结果
;;;478    BOOL CAN_PROTOCOL1_CheckSUM(CAN_PROTOCOL1_RX_CMD_FRAME *pCmdFrame)
000000  b530              PUSH     {r4,r5,lr}
;;;479    {
;;;480        uint16 checkSum = 0;
000002  2200              MOVS     r2,#0
;;;481        uint16 sumTemp;
;;;482        uint16 i = 0;
;;;483    
;;;484        if (NULL == pCmdFrame)
000004  2800              CMP      r0,#0
000006  d004              BEQ      |L2.18|
;;;485        {
;;;486            return FALSE;
;;;487        }
;;;488    
;;;489        // 从设备地址开始，到校验码之前的一个字节，依次进行累加运算
;;;490        for (i = 1; i < pCmdFrame->length - 4; i++)
000008  2101              MOVS     r1,#1
00000a  f8b05098          LDRH     r5,[r0,#0x98]
00000e  1f2b              SUBS     r3,r5,#4
000010  e007              B        |L2.34|
                  |L2.18|
000012  2000              MOVS     r0,#0                 ;486
;;;491        {
;;;492            checkSum += pCmdFrame->buff[i];
;;;493        }
;;;494    
;;;495        // 累加和，低字节在前，高字节在后
;;;496        sumTemp = pCmdFrame->buff[pCmdFrame->length - 3]; // 高字节
;;;497        sumTemp <<= 8;
;;;498        sumTemp += pCmdFrame->buff[pCmdFrame->length - 4]; // 低字节
;;;499    
;;;500        // 判断计算得到的校验码与命令帧中的校验码是否相同
;;;501        if (sumTemp != checkSum)
;;;502        {
;;;503            return FALSE;
;;;504        }
;;;505    
;;;506        return TRUE;
;;;507    }
000014  bd30              POP      {r4,r5,pc}
                  |L2.22|
000016  1844              ADDS     r4,r0,r1              ;492
000018  78a4              LDRB     r4,[r4,#2]            ;492
00001a  4422              ADD      r2,r2,r4              ;492
00001c  b292              UXTH     r2,r2                 ;492
00001e  1c49              ADDS     r1,r1,#1              ;490
000020  b289              UXTH     r1,r1                 ;490
                  |L2.34|
000022  428b              CMP      r3,r1                 ;490
000024  dcf7              BGT      |L2.22|
000026  1e41              SUBS     r1,r0,#1              ;496
000028  5c69              LDRB     r1,[r5,r1]            ;496
00002a  f64f73ff          MOV      r3,#0xffff            ;497
00002e  ea032101          AND      r1,r3,r1,LSL #8       ;497
000032  1e80              SUBS     r0,r0,#2              ;498
000034  5c28              LDRB     r0,[r5,r0]            ;498
000036  4408              ADD      r0,r0,r1              ;498
000038  b280              UXTH     r0,r0                 ;498
00003a  4290              CMP      r0,r2                 ;501
00003c  d001              BEQ      |L2.66|
00003e  2000              MOVS     r0,#0                 ;503
000040  bd30              POP      {r4,r5,pc}
                  |L2.66|
000042  2001              MOVS     r0,#1                 ;506
000044  bd30              POP      {r4,r5,pc}
;;;508    
                          ENDP


                          AREA ||i.CAN_PROTOCOL1_CmdFrameProcess||, CODE, READONLY, ALIGN=2

                  CAN_PROTOCOL1_CmdFrameProcess PROC
;;;510    // UART命令帧缓冲区处理
;;;511    void CAN_PROTOCOL1_CmdFrameProcess(CAN_PROTOCOL1_CB *pCB)
000000  b570              PUSH     {r4-r6,lr}
;;;512    {
000002  4604              MOV      r4,r0
;;;513        CAN_PROTOCOL1_CMD cmd = CAN_PROTOCOL1_CMD_NULL;
;;;514        CAN_PROTOCOL1_RX_CMD_FRAME *pCmdFrame = NULL;
;;;515    
;;;516        uint8_t i = 0;
;;;517    //    uint8_t j = 0;
;;;518    //    uint8_t skipBytes = 0;
;;;519        BOOL checkMark;
;;;520    
;;;521        // 参数合法性检验
;;;522        if (NULL == pCB)
000004  2c00              CMP      r4,#0
000006  d016              BEQ      |L3.54|
;;;523        {
;;;524            return;
;;;525        }
;;;526    
;;;527        // 命令帧缓冲区为空，退出
;;;528        if (pCB->rx.head == pCB->rx.end)
000008  f8b403d0          LDRH     r0,[r4,#0x3d0]
00000c  f8b413d2          LDRH     r1,[r4,#0x3d2]
000010  4288              CMP      r0,r1
000012  d010              BEQ      |L3.54|
;;;529        {
;;;530            return;
;;;531        }
;;;532    
;;;533        // 获取当前要处理的命令帧指针
;;;534        pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.head];
000014  214d              MOVS     r1,#0x4d
000016  4341              MULS     r1,r0,r1
000018  eb040141          ADD      r1,r4,r1,LSL #1
00001c  31ce              ADDS     r1,r1,#0xce
;;;535    
;;;536        // 命令头非法，退出
;;;537        if (CAN_PROTOCOL1_CMD_HEAD != pCmdFrame->buff[CAN_PROTOCOL1_CMD_HEAD_INDEX])
;;;538        {
;;;539            // 删除命令帧
;;;540            pCB->rx.head++;
;;;541            pCB->rx.head %= CAN_PROTOCOL1_RX_QUEUE_SIZE;
00001e  2505              MOVS     r5,#5
000020  788a              LDRB     r2,[r1,#2]            ;537
000022  2a3a              CMP      r2,#0x3a              ;537
000024  d008              BEQ      |L3.56|
000026  1c40              ADDS     r0,r0,#1              ;540
000028  b280              UXTH     r0,r0                 ;540
00002a  fbb0f1f5          UDIV     r1,r0,r5
00002e  fb050011          MLS      r0,r5,r1,r0
000032  f8a403d0          STRH     r0,[r4,#0x3d0]
                  |L3.54|
;;;542            return;
;;;543        }
;;;544    
;;;545        // 命令头合法，则提取命令
;;;546        cmd = (CAN_PROTOCOL1_CMD)pCmdFrame->buff[CAN_PROTOCOL1_CMD_CMD_INDEX];
;;;547    
;;;548        // 执行命令帧
;;;549        switch (cmd)
;;;550        {
;;;551            // 空命令，不予执行
;;;552            case CAN_PROTOCOL1_CMD_NULL:
;;;553                break;
;;;554    
;;;555    //        // 0x31,写配置信息应答
;;;556    //        case CAN_PROTOCOL1_CMD_WRITE_CONTROL_PARAM_RESULT:
;;;557    
;;;558    //            // 有应答代表配置信息升级成功
;;;559    //            STATE_SwitchStep(STEP_CAN_SET_CONFIG_SUCCESS);
;;;560    //            break;
;;;561    
;;;562    //        case CAN_PROTOCOL1_CMD_NEW_WRITE_CONTROL_PARAM: // 0x50
;;;563    
;;;564    //            // dut_config升级成功
;;;565    //            STATE_SwitchStep(STEP_CAN_READ_CONFIG);
;;;566    //            break;
;;;567    
;;;568    //        // 校验配置参数
;;;569    //        case CAN_PROTOCOL1_CMD_READ_CONTROL_PARAM_REPORT: // 0xc3
;;;570    
;;;571    //            for (i = 0; i < pCmdFrame->buff[CAN_PROTOCOL1_CMD_LENGTH_INDEX]; i++)
;;;572    //            {
;;;573    //                if (verifiedBuff[i] == pCmdFrame->buff[CAN_PROTOCOL1_CMD_DATA1_INDEX + i])
;;;574    //                {
;;;575    //                    checkMark = TRUE;
;;;576    //                }
;;;577    //                else
;;;578    //                {
;;;579    //                    checkMark = FALSE;
;;;580    //                }
;;;581    //            }
;;;582    
;;;583    //            if (checkMark)
;;;584    //            {
;;;585    //                STATE_SwitchStep(STEP_CAN_SET_CONFIG_SUCCESS);
;;;586    //            }
;;;587    //            else
;;;588    //            {
;;;589    //                STATE_SwitchStep(STEP_CM_CAN_UPGRADE_ITEM_FINISH);
;;;590    //            }
;;;591    //            break;
;;;592    
;;;593    //        // LCD
;;;594    //        case CAN_PROTOCOL1_CMD_TEST_LCD:
;;;595    //            TIMER_KillTask(TIMER_ID_CHANGE_LCD_COLOR);                              
;;;596    //            STATE_SwitchStep(STEP_CM_CAN_UPGRADE_ITEM_FINISH);
;;;597    //            break;
;;;598    
;;;599            default:
;;;600                if(dut_info.passThroughControl)
;;;601                {
;;;602                    testFlag = FALSE;
;;;603                    STS_UART_AddTxArray(0, pCmdFrame->buff, pCmdFrame->length);            
;;;604                }
;;;605    
;;;606                // LCD显示
;;;607    //            Vertical_Scrolling_Display(ptUpMsgBuff, 4, 0);
;;;608                break;
;;;609        }
;;;610    
;;;611        // 删除命令帧
;;;612        pCB->rx.head++;
;;;613        pCB->rx.head %= CAN_PROTOCOL1_RX_QUEUE_SIZE;
;;;614    }
000036  bd70              POP      {r4-r6,pc}
                  |L3.56|
000038  7908              LDRB     r0,[r1,#4]            ;546
00003a  b158              CBZ      r0,|L3.84|
00003c  480b              LDR      r0,|L3.108|
00003e  f8900120          LDRB     r0,[r0,#0x120]        ;600  ; dut_info
000042  b138              CBZ      r0,|L3.84|
000044  4a0a              LDR      r2,|L3.112|
000046  2000              MOVS     r0,#0                 ;602
000048  7010              STRB     r0,[r2,#0]            ;602
00004a  f8b12098          LDRH     r2,[r1,#0x98]         ;603
00004e  1c89              ADDS     r1,r1,#2              ;603
000050  f7fffffe          BL       STS_UART_AddTxArray
                  |L3.84|
000054  f8b403d0          LDRH     r0,[r4,#0x3d0]        ;612
000058  1c40              ADDS     r0,r0,#1              ;612
00005a  b280              UXTH     r0,r0                 ;612
00005c  fbb0f1f5          UDIV     r1,r0,r5              ;613
000060  fb050011          MLS      r0,r5,r1,r0           ;613
000064  f8a403d0          STRH     r0,[r4,#0x3d0]        ;613
000068  bd70              POP      {r4-r6,pc}
;;;615    
                          ENDP

00006a  0000              DCW      0x0000
                  |L3.108|
                          DCD      dut_info
                  |L3.112|
                          DCD      testFlag

                          AREA ||i.CAN_PROTOCOL1_ConfirmTempCmdFrameBuff||, CODE, READONLY, ALIGN=1

                  CAN_PROTOCOL1_ConfirmTempCmdFrameBuff PROC
;;;258    // 将临时缓冲区添加到命令帧缓冲区中，其本质操作是承认临时缓冲区数据有效
;;;259    BOOL CAN_PROTOCOL1_ConfirmTempCmdFrameBuff(CAN_PROTOCOL1_CB *pCB)
000000  2800              CMP      r0,#0
;;;260    {
000002  d01a              BEQ      |L4.58|
;;;261        CAN_PROTOCOL1_RX_CMD_FRAME *pCmdFrame = NULL;
;;;262    
;;;263        // 参数合法性检验
;;;264        if (NULL == pCB)
;;;265        {
;;;266            return FALSE;
;;;267        }
;;;268    
;;;269        // 临时缓冲区为空，不予添加
;;;270        pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.end];
000004  f8b013d2          LDRH     r1,[r0,#0x3d2]
000008  224d              MOVS     r2,#0x4d
00000a  434a              MULS     r2,r1,r2
00000c  eb000242          ADD      r2,r0,r2,LSL #1
;;;271        if (0 == pCmdFrame->length)
000010  f8b22166          LDRH     r2,[r2,#0x166]
000014  b19a              CBZ      r2,|L4.62|
;;;272        {
;;;273            return FALSE;
;;;274        }
;;;275    
;;;276        // 添加
;;;277        pCB->rx.end++;
000016  1c49              ADDS     r1,r1,#1
000018  b289              UXTH     r1,r1
;;;278        pCB->rx.end %= CAN_PROTOCOL1_RX_QUEUE_SIZE;
00001a  2205              MOVS     r2,#5
00001c  fbb1f3f2          UDIV     r3,r1,r2
000020  fb021113          MLS      r1,r2,r3,r1
000024  f8a013d2          STRH     r1,[r0,#0x3d2]
;;;279        pCB->rx.cmdQueue[pCB->rx.end].length = 0; // 该行的作用是将新的添加位置有效数据个数清零，以便将这个位置当做临时帧缓冲区
000028  2200              MOVS     r2,#0
00002a  234d              MOVS     r3,#0x4d
00002c  4359              MULS     r1,r3,r1
00002e  eb000041          ADD      r0,r0,r1,LSL #1
000032  f8a02166          STRH     r2,[r0,#0x166]
;;;280    
;;;281        return TRUE;
000036  2001              MOVS     r0,#1
;;;282    }
000038  4770              BX       lr
                  |L4.58|
00003a  2000              MOVS     r0,#0                 ;266
00003c  4770              BX       lr
                  |L4.62|
00003e  2000              MOVS     r0,#0                 ;273
000040  4770              BX       lr
;;;283    
                          ENDP


                          AREA ||i.CAN_PROTOCOL1_DataStructInit||, CODE, READONLY, ALIGN=1

                  CAN_PROTOCOL1_DataStructInit PROC
;;;188    // 数据结构初始化
;;;189    void CAN_PROTOCOL1_DataStructInit(CAN_PROTOCOL1_CB *pCB)
000000  2800              CMP      r0,#0
;;;190    {
000002  d027              BEQ      |L5.84|
;;;191        uint16 i;
;;;192    
;;;193        // 参数合法性检验
;;;194        if (NULL == pCB)
;;;195        {
;;;196            return;
;;;197        }
;;;198    
;;;199        pCB->tx.txBusy = FALSE;
000004  2200              MOVS     r2,#0
000006  f88026dc          STRB     r2,[r0,#0x6dc]
;;;200        pCB->tx.index = 0;
00000a  f8a026da          STRH     r2,[r0,#0x6da]
;;;201        pCB->tx.head = 0;
00000e  f8a026d6          STRH     r2,[r0,#0x6d6]
;;;202        pCB->tx.end = 0;
000012  f8a026d8          STRH     r2,[r0,#0x6d8]
;;;203        for (i = 0; i < CAN_PROTOCOL1_TX_QUEUE_SIZE; i++)
000016  2100              MOVS     r1,#0
                  |L5.24|
;;;204        {
;;;205            pCB->tx.cmdQueue[i].length = 0;
000018  234d              MOVS     r3,#0x4d
00001a  434b              MULS     r3,r1,r3
00001c  eb000343          ADD      r3,r0,r3,LSL #1
000020  f8a3246c          STRH     r2,[r3,#0x46c]
000024  1c49              ADDS     r1,r1,#1              ;203
000026  b289              UXTH     r1,r1                 ;203
000028  2905              CMP      r1,#5                 ;203
00002a  d3f5              BCC      |L5.24|
;;;206        }
;;;207    
;;;208        pCB->rxFIFO.head = 0;
00002c  f8202fc8          STRH     r2,[r0,#0xc8]!
;;;209        pCB->rxFIFO.end = 0;
000030  8042              STRH     r2,[r0,#2]
;;;210        pCB->rxFIFO.currentProcessIndex = 0;
000032  8082              STRH     r2,[r0,#4]
;;;211    
;;;212        pCB->rx.head = 0;
000034  f8a02308          STRH     r2,[r0,#0x308]
;;;213        pCB->rx.end = 0;
000038  f8a0230a          STRH     r2,[r0,#0x30a]
00003c  38c8              SUBS     r0,r0,#0xc8
;;;214        for (i = 0; i < CAN_PROTOCOL1_RX_QUEUE_SIZE; i++)
00003e  2100              MOVS     r1,#0
                  |L5.64|
;;;215        {
;;;216            pCB->rx.cmdQueue[i].length = 0;
000040  234d              MOVS     r3,#0x4d
000042  434b              MULS     r3,r1,r3
000044  eb000343          ADD      r3,r0,r3,LSL #1
000048  f8a32166          STRH     r2,[r3,#0x166]
00004c  1c49              ADDS     r1,r1,#1              ;214
00004e  b289              UXTH     r1,r1                 ;214
000050  2905              CMP      r1,#5                 ;214
000052  d3f5              BCC      |L5.64|
                  |L5.84|
;;;217        }
;;;218    }
000054  4770              BX       lr
;;;219    
                          ENDP


                          AREA ||i.CAN_PROTOCOL1_Init||, CODE, READONLY, ALIGN=2

                  CAN_PROTOCOL1_Init PROC
;;;83     // 协议初始化
;;;84     void CAN_PROTOCOL1_Init(void)
000000  b500              PUSH     {lr}
;;;85     {
;;;86         // 协议层数据结构初始化
;;;87         CAN_PROTOCOL1_DataStructInit(&canProtocol1CB);
000002  4804              LDR      r0,|L6.20|
000004  f7fffffe          BL       CAN_PROTOCOL1_DataStructInit
;;;88     
;;;89         // 向驱动层注册数据接收接口
;;;90         // CAN_DRIVE_RegisterDataSendService(CAN_PROTOCOL1_MacProcess);
;;;91     
;;;92         // 向驱动层注册数据发送接口
;;;93         CAN_PROTOCOL1_RegisterDataSendService(CAN_DRIVE_AddTxArray);
000008  4803              LDR      r0,|L6.24|
00000a  f85deb04          POP      {lr}
00000e  f7ffbffe          B.W      CAN_PROTOCOL1_RegisterDataSendService
;;;94         //
;;;95         //  TIMER_AddTask(TIMER_ID_CAN_TEST,
;;;96         //              1500,
;;;97         //              can_test,
;;;98         //              TRUE,
;;;99         //              4,
;;;100        //              ACTION_MODE_ADD_TO_QUEUE);
;;;101    }
;;;102    
                          ENDP

000012  0000              DCW      0x0000
                  |L6.20|
                          DCD      ||.bss||
                  |L6.24|
                          DCD      CAN_DRIVE_AddTxArray

                          AREA ||i.CAN_PROTOCOL1_MacProcess||, CODE, READONLY, ALIGN=2

                  CAN_PROTOCOL1_MacProcess PROC
;;;220    // UART报文接收处理函数(注意根据具体模块修改)
;;;221    void CAN_PROTOCOL1_MacProcess(uint32 standarID, uint8 *pData, uint16 length)
000000  b5f0              PUSH     {r4-r7,lr}
;;;222    {
;;;223        uint16 end = canProtocol1CB.rxFIFO.end;
000002  4b17              LDR      r3,|L7.96|
000004  f8b350ca          LDRH     r5,[r3,#0xca]  ; canProtocol1CB
;;;224        uint16 head = canProtocol1CB.rxFIFO.head;
000008  f8b360c8          LDRH     r6,[r3,#0xc8]  ; canProtocol1CB
;;;225        uint16 i = 0;
00000c  2000              MOVS     r0,#0
;;;226        uint8 *rxdata = pData;
;;;227    
;;;228        // ■■环形列队，入队■■
;;;229        //  一级缓冲区已满，不予接收
;;;230        if ((end + 1) % CAN_PROTOCOL1_RX_FIFO_SIZE == head)
00000e  1c6d              ADDS     r5,r5,#1
000010  24c8              MOVS     r4,#0xc8
000012  fbb5f7f4          UDIV     r7,r5,r4
000016  fb045517          MLS      r5,r4,r7,r5
00001a  42b5              CMP      r5,r6
00001c  d01e              BEQ      |L7.92|
00001e  e01b              B        |L7.88|
                  |L7.32|
;;;231        {
;;;232            return;
;;;233        }
;;;234    
;;;235        for (i = 0; i < length; i++)
;;;236        {
;;;237            // 单个字节读取，并放入FIFO中
;;;238            canProtocol1CB.rxFIFO.buff[canProtocol1CB.rxFIFO.end] = *rxdata++;
000020  f8115b01          LDRB     r5,[r1],#1
000024  f8b370ca          LDRH     r7,[r3,#0xca]  ; canProtocol1CB
000028  55dd              STRB     r5,[r3,r7]
;;;239    
;;;240            canProtocol1CB.rxFIFO.end++;
00002a  f8335fca          LDRH     r5,[r3,#0xca]!  ; canProtocol1CB
00002e  1c6d              ADDS     r5,r5,#1
000030  801d              STRH     r5,[r3,#0]
;;;241    
;;;242            // 一级缓冲区已满，不予接收
;;;243            if ((canProtocol1CB.rxFIFO.end + 1) % CAN_PROTOCOL1_RX_FIFO_SIZE == head)
000032  f83359ca          LDRH     r5,[r3],#-0xca  ; canProtocol1CB
000036  1c6d              ADDS     r5,r5,#1
000038  fbb5f7f4          UDIV     r7,r5,r4
00003c  fb045517          MLS      r5,r4,r7,r5
000040  42b5              CMP      r5,r6
000042  d00b              BEQ      |L7.92|
;;;244            {
;;;245                break;
;;;246            }
;;;247    
;;;248            canProtocol1CB.rxFIFO.end %= CAN_PROTOCOL1_RX_FIFO_SIZE;
000044  f8b350ca          LDRH     r5,[r3,#0xca]  ; canProtocol1CB
000048  fbb5f7f4          UDIV     r7,r5,r4
00004c  fb045517          MLS      r5,r4,r7,r5
000050  f8a350ca          STRH     r5,[r3,#0xca]
000054  1c40              ADDS     r0,r0,#1              ;235
000056  b280              UXTH     r0,r0                 ;235
                  |L7.88|
000058  4290              CMP      r0,r2                 ;235
00005a  d3e1              BCC      |L7.32|
                  |L7.92|
;;;249        }
;;;250    }
00005c  bdf0              POP      {r4-r7,pc}
;;;251    
                          ENDP

00005e  0000              DCW      0x0000
                  |L7.96|
                          DCD      ||.bss||

                          AREA ||i.CAN_PROTOCOL1_RegisterDataSendService||, CODE, READONLY, ALIGN=2

                  CAN_PROTOCOL1_RegisterDataSendService PROC
;;;252    // UART协议层向驱动层注册数据发送接口
;;;253    void CAN_PROTOCOL1_RegisterDataSendService(BOOL (*service)(uint32 id, uint8 *pData, uint8 length))
000000  4901              LDR      r1,|L8.8|
;;;254    {
;;;255        canProtocol1CB.sendDataThrowService = service;
000002  f8c106e0          STR      r0,[r1,#0x6e0]  ; canProtocol1CB
;;;256    }
000006  4770              BX       lr
;;;257    
                          ENDP

                  |L8.8|
                          DCD      ||.bss||

                          AREA ||i.CAN_PROTOCOL1_ReportWriteParamResult||, CODE, READONLY, ALIGN=1

                  CAN_PROTOCOL1_ReportWriteParamResult PROC
;;;621    // 上报写配置参数结果
;;;622    void CAN_PROTOCOL1_ReportWriteParamResult(uint32 param)
000000  b510              PUSH     {r4,lr}
;;;623    {
000002  4604              MOV      r4,r0
;;;624        // 添加命令头
;;;625        CAN_PROTOCOL1_TxAddData(CAN_PROTOCOL1_CMD_HEAD);
000004  203a              MOVS     r0,#0x3a
000006  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;626    
;;;627        // 添加设备地址
;;;628        CAN_PROTOCOL1_TxAddData(CAN_PROTOCOL1_CMD_DEVICE_ADDR);
00000a  201a              MOVS     r0,#0x1a
00000c  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;629    
;;;630        // 添加命令字
;;;631        CAN_PROTOCOL1_TxAddData(CAN_PROTOCOL1_CMD_WRITE_CONTROL_PARAM_RESULT);
000010  20c1              MOVS     r0,#0xc1
000012  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;632    
;;;633        // 添加数据长度
;;;634        CAN_PROTOCOL1_TxAddData(1);
000016  2001              MOVS     r0,#1
000018  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;635    
;;;636        // 写入结果
;;;637        CAN_PROTOCOL1_TxAddData(param);
00001c  b2e0              UXTB     r0,r4
00001e  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;638    
;;;639        // 添加检验和与结束符，并添加至发送
;;;640        CAN_PROTOCOL1_TxAddFrame();
000022  e8bd4010          POP      {r4,lr}
000026  f7ffbffe          B.W      CAN_PROTOCOL1_TxAddFrame
;;;641    }
;;;642    
                          ENDP


                          AREA ||i.CAN_PROTOCOL1_RxFIFOProcess||, CODE, READONLY, ALIGN=1

                  CAN_PROTOCOL1_RxFIFOProcess PROC
;;;317    // 一级接收缓冲区处理，从一级接收缓冲区中取出一个字节添加到命令帧缓冲区中
;;;318    void CAN_PROTOCOL1_RxFIFOProcess(CAN_PROTOCOL1_CB *pCB)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;319    {
000004  4604              MOV      r4,r0
;;;320        uint16 end = pCB->rxFIFO.end;
000006  f8b410ca          LDRH     r1,[r4,#0xca]
;;;321        uint16 head = pCB->rxFIFO.head;
00000a  f8b400c8          LDRH     r0,[r4,#0xc8]
;;;322        CAN_PROTOCOL1_RX_CMD_FRAME *pCmdFrame = NULL;
;;;323        uint16 length = 0;
;;;324        uint8 currentData = 0;
;;;325    
;;;326        // 参数合法性检验
;;;327        if (NULL == pCB)
00000e  2c00              CMP      r4,#0
000010  d021              BEQ      |L10.86|
;;;328        {
;;;329            return;
;;;330        }
;;;331    
;;;332        // 一级缓冲区为空，退出
;;;333        if (head == end)
000012  4288              CMP      r0,r1
000014  d01f              BEQ      |L10.86|
;;;334        {
;;;335            return;
;;;336        }
;;;337    
;;;338        // 获取临时缓冲区指针
;;;339        pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.end];
000016  f8b423d2          LDRH     r2,[r4,#0x3d2]
00001a  204d              MOVS     r0,#0x4d
00001c  4350              MULS     r0,r2,r0
00001e  eb040540          ADD      r5,r4,r0,LSL #1
000022  35ce              ADDS     r5,r5,#0xce
;;;340        // 取出当前要处理的字节
;;;341        currentData = pCB->rxFIFO.buff[pCB->rxFIFO.currentProcessIndex];
000024  f8b400cc          LDRH     r0,[r4,#0xcc]
000028  5c20              LDRB     r0,[r4,r0]
;;;342    
;;;343        // 临时缓冲区长度为0时，搜索首字节
;;;344        if (0 == pCmdFrame->length)
00002a  f8b53098          LDRH     r3,[r5,#0x98]
;;;345        {
;;;346            // 命令头错误，删除当前字节并退出
;;;347            if (CAN_PROTOCOL1_CMD_HEAD != currentData)
;;;348            {
;;;349                pCB->rxFIFO.head++;
;;;350                pCB->rxFIFO.head %= CAN_PROTOCOL1_RX_FIFO_SIZE;
00002e  27c8              MOVS     r7,#0xc8
000030  b19b              CBZ      r3,|L10.90|
;;;351                pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;352    
;;;353                return;
;;;354            }
;;;355    
;;;356            // 命令头正确，但无临时缓冲区可用，退出
;;;357            if ((pCB->rx.end + 1) % CAN_PROTOCOL1_RX_QUEUE_SIZE == pCB->rx.head)
;;;358            {
;;;359                return;
;;;360            }
;;;361    
;;;362            // 添加UART通讯超时时间设置-2016.1.5增加
;;;363    #if CAN_PROTOCOL1_RX_TIME_OUT_CHECK_ENABLE
;;;364            TIMER_AddTask(TIMER_ID_UART_RX_TIME_OUT_CONTROL,
;;;365                          CAN_PROTOCOL1_BUS_UNIDIRECTIONAL_TIME_OUT,
;;;366                          CAN_PROTOCOL1_CALLBACK_RxTimeOut,
;;;367                          0,
;;;368                          1,
;;;369                          ACTION_MODE_ADD_TO_QUEUE);
;;;370    #endif
;;;371    
;;;372            // 命令头正确，有临时缓冲区可用，则将其添加到命令帧临时缓冲区中
;;;373            pCmdFrame->buff[pCmdFrame->length++] = currentData;
;;;374            pCB->rxFIFO.currentProcessIndex++;
;;;375            pCB->rxFIFO.currentProcessIndex %= CAN_PROTOCOL1_RX_FIFO_SIZE;
;;;376        }
;;;377        // 非首字节，将数据添加到命令帧临时缓冲区中，但暂不删除当前数据
;;;378        else
;;;379        {
;;;380            // 临时缓冲区溢出，说明当前正在接收的命令帧是错误的，正确的命令帧不会出现长度溢出的情况
;;;381            if (pCmdFrame->length >= CAN_PROTOCOL1_RX_CMD_FRAME_LENGTH_MAX)
000032  f04f0800          MOV      r8,#0
000036  2b96              CMP      r3,#0x96
000038  d37e              BCC      |L10.312|
;;;382            {
;;;383    #if CAN_PROTOCOL1_RX_TIME_OUT_CHECK_ENABLE
;;;384                // 停止RX通讯超时检测
;;;385                CAN_PROTOCOL1_StopRxTimeOutCheck();
;;;386    #endif
;;;387    
;;;388                // 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;389                pCmdFrame->length = 0; // 2016.1.5增加
00003a  f8a58098          STRH     r8,[r5,#0x98]
;;;390                // 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;391                pCB->rxFIFO.head++;
00003e  f8340fc8          LDRH     r0,[r4,#0xc8]!
000042  1c40              ADDS     r0,r0,#1
000044  8020              STRH     r0,[r4,#0]
;;;392                pCB->rxFIFO.head %= CAN_PROTOCOL1_RX_FIFO_SIZE;
000046  8820              LDRH     r0,[r4,#0]
000048  fbb0f1f7          UDIV     r1,r0,r7
00004c  fb070011          MLS      r0,r7,r1,r0
000050  8020              STRH     r0,[r4,#0]
;;;393                pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
000052  8820              LDRH     r0,[r4,#0]
000054  80a0              STRH     r0,[r4,#4]
                  |L10.86|
;;;394    
;;;395                return;
;;;396            }
;;;397    
;;;398            // 一直取到末尾
;;;399            while (end != pCB->rxFIFO.currentProcessIndex)
;;;400            {
;;;401                // 取出当前要处理的字节
;;;402                currentData = pCB->rxFIFO.buff[pCB->rxFIFO.currentProcessIndex];
;;;403                // 缓冲区未溢出，正常接收，将数据添加到临时缓冲区中
;;;404                pCmdFrame->buff[pCmdFrame->length++] = currentData;
;;;405                pCB->rxFIFO.currentProcessIndex++;
;;;406                pCB->rxFIFO.currentProcessIndex %= CAN_PROTOCOL1_RX_FIFO_SIZE;
;;;407    
;;;408                // ■■接下来，需要检查命令帧是否完整，如果完整，则将命令帧临时缓冲区扶正■■
;;;409    
;;;410                // 首先判断命令帧最小长度，一个完整的命令字至少包括8个字节: 命令头、设备地址、命令字、数据长度、校验和L、校验和H、结束标识0xD、结束标识OxA，因此不足8个字节的必定不完整
;;;411                if (pCmdFrame->length < CAN_PROTOCOL1_CMD_FRAME_LENGTH_MIN)
;;;412                {
;;;413                    // 继续接收
;;;414                    continue;
;;;415                }
;;;416    
;;;417                // 命令帧长度数值越界，说明当前命令帧错误，停止接收
;;;418                if (pCmdFrame->buff[CAN_PROTOCOL1_CMD_LENGTH_INDEX] > CAN_PROTOCOL1_RX_CMD_FRAME_LENGTH_MAX - CAN_PROTOCOL1_CMD_FRAME_LENGTH_MIN)
;;;419                {
;;;420    #if CAN_PROTOCOL1_RX_TIME_OUT_CHECK_ENABLE
;;;421                    // 停止RX通讯超时检测
;;;422                    CAN_PROTOCOL1_StopRxTimeOutCheck();
;;;423    #endif
;;;424    
;;;425                    // 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;426                    pCmdFrame->length = 0;
;;;427                    // 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;428                    pCB->rxFIFO.head++;
;;;429                    pCB->rxFIFO.head %= CAN_PROTOCOL1_RX_FIFO_SIZE;
;;;430                    pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;431    
;;;432                    return;
;;;433                }
;;;434    
;;;435                // 命令帧长度校验，在命令长度描述字的数值上，增加命令头、设备地址、命令字、数据长度、校验和L、校验和H、结束标识0xD、结束标识OxA，即为命令帧实际长度
;;;436                length = pCmdFrame->length;
;;;437                if (length < pCmdFrame->buff[CAN_PROTOCOL1_CMD_LENGTH_INDEX] + CAN_PROTOCOL1_CMD_FRAME_LENGTH_MIN)
;;;438                {
;;;439                    // 长度要求不一致，说明未接收完毕，退出继续
;;;440                    continue;
;;;441                }
;;;442    
;;;443                // 命令帧长度OK，则进行校验，失败时删除命令头
;;;444                if (!CAN_PROTOCOL1_CheckSUM(pCmdFrame))
;;;445                {
;;;446    #if CAN_PROTOCOL1_RX_TIME_OUT_CHECK_ENABLE
;;;447                    // 停止RX通讯超时检测
;;;448                    CAN_PROTOCOL1_StopRxTimeOutCheck();
;;;449    #endif
;;;450    
;;;451                    // 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;452                    pCmdFrame->length = 0;
;;;453                    // 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;454                    pCB->rxFIFO.head++;
;;;455                    pCB->rxFIFO.head %= CAN_PROTOCOL1_RX_FIFO_SIZE;
;;;456                    pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;457    
;;;458                    return;
;;;459                }
;;;460    
;;;461    #if CAN_PROTOCOL1_RX_TIME_OUT_CHECK_ENABLE
;;;462                // 停止RX通讯超时检测
;;;463                CAN_PROTOCOL1_StopRxTimeOutCheck();
;;;464    #endif
;;;465    
;;;466                // 执行到这里，即说明接收到了一个完整并且正确的命令帧，此时需将处理过的数据从一级缓冲区中删除，并将该命令帧扶正
;;;467                pCB->rxFIFO.head += length;
;;;468                pCB->rxFIFO.head %= CAN_PROTOCOL1_RX_FIFO_SIZE;
;;;469                pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;470                CAN_PROTOCOL1_ConfirmTempCmdFrameBuff(pCB);
;;;471    
;;;472                return;
;;;473            }
;;;474        }
;;;475    }
000056  e8bd81f0          POP      {r4-r8,pc}
                  |L10.90|
00005a  283a              CMP      r0,#0x3a              ;347
00005c  d00c              BEQ      |L10.120|
00005e  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;349
000062  1c40              ADDS     r0,r0,#1              ;349
000064  8020              STRH     r0,[r4,#0]            ;349
000066  8820              LDRH     r0,[r4,#0]            ;350
000068  fbb0f1f7          UDIV     r1,r0,r7              ;350
00006c  fb070011          MLS      r0,r7,r1,r0           ;350
000070  8020              STRH     r0,[r4,#0]            ;350
000072  8820              LDRH     r0,[r4,#0]            ;351
000074  80a0              STRH     r0,[r4,#4]            ;351
000076  e7ee              B        |L10.86|
                  |L10.120|
000078  1c52              ADDS     r2,r2,#1              ;357
00007a  2105              MOVS     r1,#5                 ;357
00007c  fbb2f3f1          UDIV     r3,r2,r1              ;357
000080  fb012113          MLS      r1,r1,r3,r2           ;357
000084  f8b423d0          LDRH     r2,[r4,#0x3d0]        ;357
000088  4291              CMP      r1,r2                 ;357
00008a  d0e4              BEQ      |L10.86|
00008c  2101              MOVS     r1,#1                 ;373
00008e  f8a51098          STRH     r1,[r5,#0x98]         ;373
000092  70a8              STRB     r0,[r5,#2]            ;373
000094  f8340fcc          LDRH     r0,[r4,#0xcc]!        ;374
000098  1c40              ADDS     r0,r0,#1              ;374
00009a  b280              UXTH     r0,r0                 ;374
00009c  fbb0f1f7          UDIV     r1,r0,r7              ;375
0000a0  fb070011          MLS      r0,r7,r1,r0           ;375
0000a4  8020              STRH     r0,[r4,#0]            ;375
0000a6  e7d6              B        |L10.86|
                  |L10.168|
0000a8  5c22              LDRB     r2,[r4,r0]            ;402
0000aa  f8b50098          LDRH     r0,[r5,#0x98]         ;404
0000ae  1c43              ADDS     r3,r0,#1              ;404
0000b0  4428              ADD      r0,r0,r5              ;404
0000b2  f8a53098          STRH     r3,[r5,#0x98]         ;404
0000b6  7082              STRB     r2,[r0,#2]            ;404
0000b8  f8b400cc          LDRH     r0,[r4,#0xcc]         ;405
0000bc  1c40              ADDS     r0,r0,#1              ;405
0000be  b280              UXTH     r0,r0                 ;405
0000c0  fbb0f2f7          UDIV     r2,r0,r7              ;406
0000c4  fb070012          MLS      r0,r7,r2,r0           ;406
0000c8  f8a400cc          STRH     r0,[r4,#0xcc]         ;406
0000cc  f8b56098          LDRH     r6,[r5,#0x98]         ;411
0000d0  2e08              CMP      r6,#8                 ;411
0000d2  d33b              BCC      |L10.332|
0000d4  7968              LDRB     r0,[r5,#5]            ;418
0000d6  288e              CMP      r0,#0x8e              ;418
0000d8  d90e              BLS      |L10.248|
0000da  f8a58098          STRH     r8,[r5,#0x98]         ;426
0000de  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;428
0000e2  1c40              ADDS     r0,r0,#1              ;428
0000e4  8020              STRH     r0,[r4,#0]            ;428
0000e6  8820              LDRH     r0,[r4,#0]            ;429
0000e8  fbb0f1f7          UDIV     r1,r0,r7              ;429
0000ec  fb070011          MLS      r0,r7,r1,r0           ;429
0000f0  8020              STRH     r0,[r4,#0]            ;429
0000f2  8820              LDRH     r0,[r4,#0]            ;430
0000f4  80a0              STRH     r0,[r4,#4]            ;430
0000f6  e7ae              B        |L10.86|
                  |L10.248|
0000f8  3008              ADDS     r0,r0,#8              ;437
0000fa  42b0              CMP      r0,r6                 ;437
0000fc  d826              BHI      |L10.332|
0000fe  4628              MOV      r0,r5                 ;444
000100  f7fffffe          BL       CAN_PROTOCOL1_CheckSUM
000104  b188              CBZ      r0,|L10.298|
000106  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;467
00010a  4430              ADD      r0,r0,r6              ;467
00010c  8020              STRH     r0,[r4,#0]            ;467
00010e  8820              LDRH     r0,[r4,#0]            ;468
000110  fbb0f1f7          UDIV     r1,r0,r7              ;468
000114  fb070011          MLS      r0,r7,r1,r0           ;468
000118  8020              STRH     r0,[r4,#0]            ;468
00011a  8820              LDRH     r0,[r4,#0]            ;469
00011c  80a0              STRH     r0,[r4,#4]            ;469
00011e  3cc8              SUBS     r4,r4,#0xc8           ;469
000120  4620              MOV      r0,r4                 ;470
000122  e8bd41f0          POP      {r4-r8,lr}            ;470
000126  f7ffbffe          B.W      CAN_PROTOCOL1_ConfirmTempCmdFrameBuff
                  |L10.298|
00012a  f8a58098          STRH     r8,[r5,#0x98]         ;452
00012e  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;454
000132  1c40              ADDS     r0,r0,#1              ;454
000134  8020              STRH     r0,[r4,#0]            ;454
000136  e000              B        |L10.314|
                  |L10.312|
000138  e008              B        |L10.332|
                  |L10.314|
00013a  8820              LDRH     r0,[r4,#0]            ;455
00013c  fbb0f1f7          UDIV     r1,r0,r7              ;455
000140  fb070011          MLS      r0,r7,r1,r0           ;455
000144  8020              STRH     r0,[r4,#0]            ;455
000146  8820              LDRH     r0,[r4,#0]            ;456
000148  80a0              STRH     r0,[r4,#4]            ;456
00014a  e784              B        |L10.86|
                  |L10.332|
00014c  f8b400cc          LDRH     r0,[r4,#0xcc]         ;399
000150  4288              CMP      r0,r1                 ;399
000152  d1a9              BNE      |L10.168|
000154  e77f              B        |L10.86|
;;;476    
                          ENDP


                          AREA ||i.CAN_PROTOCOL1_SendCmdChangeColor||, CODE, READONLY, ALIGN=1

                  CAN_PROTOCOL1_SendCmdChangeColor PROC
;;;703    // 升级成功变换屏幕颜色
;;;704    void CAN_PROTOCOL1_SendCmdChangeColor(uint32 param)
000000  b500              PUSH     {lr}
;;;705    {
;;;706        // 发送LCD颜色测试命令显示黄色
;;;707        CAN_PROTOCOL1_TxAddData(CAN_PROTOCOL1_CMD_HEAD);                 // 添加命令头
000002  203a              MOVS     r0,#0x3a
000004  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;708        CAN_PROTOCOL1_TxAddData(CAN_PROTOCOL1_CMD_DEVICE_ADDR);          // 添加设备地址
000008  201a              MOVS     r0,#0x1a
00000a  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;709        CAN_PROTOCOL1_TxAddData(CAN_PROTOCOL1_CMD_TEST_LCD);             // LCD颜色显示控制
00000e  20aa              MOVS     r0,#0xaa
000010  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;710        CAN_PROTOCOL1_TxAddData(1);                                      // 添加数据长度
000014  2001              MOVS     r0,#1
000016  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;711        CAN_PROTOCOL1_TxAddData(0x06);                                   // LCD显示控制字（黄色）
00001a  2006              MOVS     r0,#6
00001c  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;712    
;;;713        // 添加检验和与结束符，并添加至发送
;;;714        CAN_PROTOCOL1_TxAddFrame();
000020  f85deb04          POP      {lr}
000024  f7ffbffe          B.W      CAN_PROTOCOL1_TxAddFrame
;;;715    }
                          ENDP


                          AREA ||i.CAN_PROTOCOL1_SendCmdNoResult||, CODE, READONLY, ALIGN=1

                  CAN_PROTOCOL1_SendCmdNoResult PROC
;;;686    // 发送命令无结果
;;;687    void CAN_PROTOCOL1_SendCmdNoResult(uint8 cmdWord)
000000  b510              PUSH     {r4,lr}
;;;688    {
000002  4604              MOV      r4,r0
;;;689        // 添加命令头
;;;690        CAN_PROTOCOL1_TxAddData(CAN_PROTOCOL1_CMD_HEAD);
000004  203a              MOVS     r0,#0x3a
000006  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;691    
;;;692        // 添加设备地址
;;;693        CAN_PROTOCOL1_TxAddData(CAN_PROTOCOL1_CMD_DEVICE_ADDR);
00000a  201a              MOVS     r0,#0x1a
00000c  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;694    
;;;695        // 添加命令字
;;;696        CAN_PROTOCOL1_TxAddData(cmdWord);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;697    
;;;698        CAN_PROTOCOL1_TxAddData(0); // 数据长度
000016  2000              MOVS     r0,#0
000018  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;699    
;;;700        CAN_PROTOCOL1_TxAddFrame();
00001c  e8bd4010          POP      {r4,lr}
000020  f7ffbffe          B.W      CAN_PROTOCOL1_TxAddFrame
;;;701    }
;;;702    
                          ENDP


                          AREA ||i.CAN_PROTOCOL1_SendCmdWithResult||, CODE, READONLY, ALIGN=1

                  CAN_PROTOCOL1_SendCmdWithResult PROC
;;;666    // 发送命令带结果
;;;667    void CAN_PROTOCOL1_SendCmdWithResult(uint8 cmdWord, uint8 result)
000000  b530              PUSH     {r4,r5,lr}
;;;668    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;669        // 添加命令头
;;;670        CAN_PROTOCOL1_TxAddData(CAN_PROTOCOL1_CMD_HEAD);
000006  203a              MOVS     r0,#0x3a
000008  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;671    
;;;672        // 添加设备地址
;;;673        CAN_PROTOCOL1_TxAddData(CAN_PROTOCOL1_CMD_DEVICE_ADDR);
00000c  201a              MOVS     r0,#0x1a
00000e  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;674    
;;;675        // 添加命令字
;;;676        CAN_PROTOCOL1_TxAddData(cmdWord);
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;677    
;;;678        // 添加数据长度
;;;679        CAN_PROTOCOL1_TxAddData(1);
000018  2001              MOVS     r0,#1
00001a  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;680    
;;;681        CAN_PROTOCOL1_TxAddData(result);
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;682    
;;;683        CAN_PROTOCOL1_TxAddFrame();
000024  e8bd4030          POP      {r4,r5,lr}
000028  f7ffbffe          B.W      CAN_PROTOCOL1_TxAddFrame
;;;684    }
;;;685    
                          ENDP


                          AREA ||i.CAN_PROTOCOL1_SendLdoV||, CODE, READONLY, ALIGN=1

                  CAN_PROTOCOL1_SendLdoV PROC
;;;643    // 发送命令带结果
;;;644    void CAN_PROTOCOL1_SendLdoV(uint8 cmdWord, uint32 result)
000000  b530              PUSH     {r4,r5,lr}
;;;645    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;646        // 添加命令头
;;;647        CAN_PROTOCOL1_TxAddData(CAN_PROTOCOL1_CMD_HEAD);
000006  203a              MOVS     r0,#0x3a
000008  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;648    
;;;649        // 添加设备地址
;;;650        CAN_PROTOCOL1_TxAddData(CAN_PROTOCOL1_CMD_DEVICE_ADDR);
00000c  201a              MOVS     r0,#0x1a
00000e  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;651    
;;;652        // 添加命令字
;;;653        CAN_PROTOCOL1_TxAddData(cmdWord);
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;654    
;;;655        // 添加数据长度
;;;656        CAN_PROTOCOL1_TxAddData(4);
000018  2004              MOVS     r0,#4
00001a  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;657    
;;;658        CAN_PROTOCOL1_TxAddData((result >> 24) & 0xFF);
00001e  0e20              LSRS     r0,r4,#24
000020  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;659        CAN_PROTOCOL1_TxAddData((result >> 16) & 0xFF);
000024  f3c44007          UBFX     r0,r4,#16,#8
000028  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;660        CAN_PROTOCOL1_TxAddData((result >> 8) & 0xFF);
00002c  f3c42007          UBFX     r0,r4,#8,#8
000030  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;661        CAN_PROTOCOL1_TxAddData((result >> 0) & 0xFF);
000034  b2e0              UXTB     r0,r4
000036  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;662    
;;;663        CAN_PROTOCOL1_TxAddFrame();
00003a  e8bd4030          POP      {r4,r5,lr}
00003e  f7ffbffe          B.W      CAN_PROTOCOL1_TxAddFrame
;;;664    }
;;;665    
                          ENDP


                          AREA ||i.CAN_PROTOCOL1_StartTimeoutCheckTask||, CODE, READONLY, ALIGN=1

                  CAN_PROTOCOL1_StartTimeoutCheckTask PROC
;;;73     // 启动通讯超时判断任务
;;;74     void CAN_PROTOCOL1_StartTimeoutCheckTask(void)
000000  4770              BX       lr
;;;75     {
;;;76     }
;;;77     
                          ENDP


                          AREA ||i.CAN_PROTOCOL1_TxAddData||, CODE, READONLY, ALIGN=2

                  CAN_PROTOCOL1_TxAddData PROC
;;;116    // 向发送命令帧队列中添加数据
;;;117    void CAN_PROTOCOL1_TxAddData(uint8 data)
000000  b530              PUSH     {r4,r5,lr}
;;;118    {
;;;119        uint16 head = canProtocol1CB.tx.head;
000002  490f              LDR      r1,|L16.64|
000004  f8b146d6          LDRH     r4,[r1,#0x6d6]  ; canProtocol1CB
;;;120        uint16 end = canProtocol1CB.tx.end;
000008  f8b126d8          LDRH     r2,[r1,#0x6d8]  ; canProtocol1CB
;;;121        CAN_PROTOCOL1_TX_CMD_FRAME *pCmdFrame = &canProtocol1CB.tx.cmdQueue[canProtocol1CB.tx.end];
00000c  234d              MOVS     r3,#0x4d
00000e  4353              MULS     r3,r2,r3
000010  eb010143          ADD      r1,r1,r3,LSL #1
000014  f5017175          ADD      r1,r1,#0x3d4
;;;122    
;;;123        // 发送缓冲区已满，不予接收
;;;124        if ((end + 1) % CAN_PROTOCOL1_TX_QUEUE_SIZE == head)
000018  1c52              ADDS     r2,r2,#1
00001a  2305              MOVS     r3,#5
00001c  fbb2f5f3          UDIV     r5,r2,r3
000020  fb032215          MLS      r2,r3,r5,r2
000024  42a2              CMP      r2,r4
000026  d009              BEQ      |L16.60|
;;;125        {
;;;126            return;
;;;127        }
;;;128    
;;;129        // 队尾命令帧已满，退出
;;;130        if (pCmdFrame->length >= CAN_PROTOCOL1_TX_CMD_FRAME_LENGTH_MAX)
000028  f8b12098          LDRH     r2,[r1,#0x98]
00002c  2a96              CMP      r2,#0x96
00002e  d205              BCS      |L16.60|
;;;131        {
;;;132            return;
;;;133        }
;;;134    
;;;135        // 数据添加到帧末尾，并更新帧长度
;;;136        pCmdFrame->buff[pCmdFrame->length] = data;
000030  1c8b              ADDS     r3,r1,#2
000032  54d0              STRB     r0,[r2,r3]
;;;137        pCmdFrame->length++;
000034  f8310f98          LDRH     r0,[r1,#0x98]!
000038  1c40              ADDS     r0,r0,#1
00003a  8008              STRH     r0,[r1,#0]
                  |L16.60|
;;;138    }
00003c  bd30              POP      {r4,r5,pc}
;;;139    
                          ENDP

00003e  0000              DCW      0x0000
                  |L16.64|
                          DCD      ||.bss||

                          AREA ||i.CAN_PROTOCOL1_TxAddFrame||, CODE, READONLY, ALIGN=2

                  CAN_PROTOCOL1_TxAddFrame PROC
;;;140    // 确认添加命令帧，即承认之前填充的数据为命令帧，将其添加到发送队列中，由main进行调度发送，本函数内会自动校正命令长度，并添加校验码
;;;141    void CAN_PROTOCOL1_TxAddFrame(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;142    {
;;;143        uint16 checkSum = 0;
000002  2300              MOVS     r3,#0
;;;144        uint16 i = 0;
;;;145        uint16 head = canProtocol1CB.tx.head;
000004  4c2d              LDR      r4,|L17.188|
000006  f8b466d6          LDRH     r6,[r4,#0x6d6]  ; canProtocol1CB
;;;146        uint16 end = canProtocol1CB.tx.end;
00000a  f8b426d8          LDRH     r2,[r4,#0x6d8]  ; canProtocol1CB
;;;147        CAN_PROTOCOL1_TX_CMD_FRAME *pCmdFrame = &canProtocol1CB.tx.cmdQueue[canProtocol1CB.tx.end];
00000e  204d              MOVS     r0,#0x4d
000010  4350              MULS     r0,r2,r0
000012  eb040040          ADD      r0,r4,r0,LSL #1
000016  f5007075          ADD      r0,r0,#0x3d4
;;;148        uint16 length = pCmdFrame->length;
00001a  f8b01098          LDRH     r1,[r0,#0x98]
;;;149    
;;;150        // 发送缓冲区已满，不予接收
;;;151        if ((end + 1) % CAN_PROTOCOL1_TX_QUEUE_SIZE == head)
00001e  1c52              ADDS     r2,r2,#1
000020  2505              MOVS     r5,#5
000022  fbb2f7f5          UDIV     r7,r2,r5
000026  fb052217          MLS      r2,r5,r7,r2
00002a  42b2              CMP      r2,r6
00002c  d004              BEQ      |L17.56|
;;;152        {
;;;153            return;
;;;154        }
;;;155    
;;;156        // 命令帧长度不足，清除已填充的数据，退出
;;;157        if (CAN_PROTOCOL1_CMD_FRAME_LENGTH_MIN - 4 > length) // 减去"校验和L、校验和H、结束标识0xD、结束标识OxA"4个字节
00002e  2904              CMP      r1,#4
000030  d203              BCS      |L17.58|
;;;158        {
;;;159            pCmdFrame->length = 0;
000032  2100              MOVS     r1,#0
000034  f8a01098          STRH     r1,[r0,#0x98]
                  |L17.56|
;;;160    
;;;161            return;
;;;162        }
;;;163    
;;;164        // 队尾命令帧已满，退出
;;;165        if ((length >= CAN_PROTOCOL1_TX_CMD_FRAME_LENGTH_MAX) || (length + 1 >= CAN_PROTOCOL1_TX_CMD_FRAME_LENGTH_MAX) || (length + 2 >= CAN_PROTOCOL1_TX_CMD_FRAME_LENGTH_MAX) || (length + 3 >= CAN_PROTOCOL1_TX_CMD_FRAME_LENGTH_MAX))
;;;166        {
;;;167            return;
;;;168        }
;;;169    
;;;170        // 重新设置数据长度，系统在准备数据时，填充的"数据长度"可以为任意值，并且不需要添加校验码，在这里重新设置为正确的值
;;;171        pCmdFrame->buff[CAN_PROTOCOL1_CMD_LENGTH_INDEX] = length - 4; // 重设数据长度，减去"命令头、设备地址、命令字、数据长度"4个字节
;;;172        for (i = 1; i < length; i++)
;;;173        {
;;;174            checkSum += pCmdFrame->buff[i];
;;;175        }
;;;176        pCmdFrame->buff[pCmdFrame->length++] = (checkSum & 0x00FF);        // 低字节在前
;;;177        pCmdFrame->buff[pCmdFrame->length++] = ((checkSum >> 8) & 0x00FF); // 高字节在后
;;;178    
;;;179        // 结束标识
;;;180        pCmdFrame->buff[pCmdFrame->length++] = 0x0D;
;;;181        pCmdFrame->buff[pCmdFrame->length++] = 0x0A;
;;;182    
;;;183        canProtocol1CB.tx.end++;
;;;184        canProtocol1CB.tx.end %= CAN_PROTOCOL1_TX_QUEUE_SIZE;
;;;185        // pCB->tx.cmdQueue[pCB->tx.end].length = 0;   //2015.12.2修改
;;;186    }
000038  bdf0              POP      {r4-r7,pc}
                  |L17.58|
00003a  2996              CMP      r1,#0x96              ;165
00003c  d2fc              BCS      |L17.56|
00003e  1c4a              ADDS     r2,r1,#1              ;165
000040  2a96              CMP      r2,#0x96              ;165
000042  d2f9              BCS      |L17.56|
000044  1c8a              ADDS     r2,r1,#2              ;165
000046  2a96              CMP      r2,#0x96              ;165
000048  d2f6              BCS      |L17.56|
00004a  1cca              ADDS     r2,r1,#3              ;165
00004c  2a96              CMP      r2,#0x96              ;165
00004e  d2f3              BCS      |L17.56|
000050  1f0a              SUBS     r2,r1,#4              ;171
000052  7142              STRB     r2,[r0,#5]            ;171
000054  2201              MOVS     r2,#1                 ;172
000056  e005              B        |L17.100|
                  |L17.88|
000058  1886              ADDS     r6,r0,r2              ;174
00005a  78b6              LDRB     r6,[r6,#2]            ;174
00005c  4433              ADD      r3,r3,r6              ;174
00005e  b29b              UXTH     r3,r3                 ;174
000060  1c52              ADDS     r2,r2,#1              ;172
000062  b292              UXTH     r2,r2                 ;172
                  |L17.100|
000064  428a              CMP      r2,r1                 ;172
000066  d3f7              BCC      |L17.88|
000068  f8b01098          LDRH     r1,[r0,#0x98]         ;176
00006c  1c4a              ADDS     r2,r1,#1              ;176
00006e  4401              ADD      r1,r1,r0              ;176
000070  f8a02098          STRH     r2,[r0,#0x98]         ;176
000074  708b              STRB     r3,[r1,#2]            ;176
000076  f8b01098          LDRH     r1,[r0,#0x98]         ;177
00007a  0a1b              LSRS     r3,r3,#8              ;177
00007c  1c4a              ADDS     r2,r1,#1              ;177
00007e  4401              ADD      r1,r1,r0              ;177
000080  f8a02098          STRH     r2,[r0,#0x98]         ;177
000084  708b              STRB     r3,[r1,#2]            ;177
000086  f8b01098          LDRH     r1,[r0,#0x98]         ;180
00008a  230d              MOVS     r3,#0xd               ;180
00008c  1c4a              ADDS     r2,r1,#1              ;180
00008e  4401              ADD      r1,r1,r0              ;180
000090  f8a02098          STRH     r2,[r0,#0x98]         ;180
000094  708b              STRB     r3,[r1,#2]            ;180
000096  f8b01098          LDRH     r1,[r0,#0x98]         ;181
00009a  230a              MOVS     r3,#0xa               ;181
00009c  1c4a              ADDS     r2,r1,#1              ;181
00009e  f8a02098          STRH     r2,[r0,#0x98]         ;181
0000a2  4408              ADD      r0,r0,r1              ;181
0000a4  7083              STRB     r3,[r0,#2]            ;181
0000a6  f8b406d8          LDRH     r0,[r4,#0x6d8]        ;183  ; canProtocol1CB
0000aa  1c40              ADDS     r0,r0,#1              ;183
0000ac  b280              UXTH     r0,r0                 ;183
0000ae  fbb0f1f5          UDIV     r1,r0,r5              ;184
0000b2  fb050011          MLS      r0,r5,r1,r0           ;184
0000b6  f8a406d8          STRH     r0,[r4,#0x6d8]        ;184
0000ba  bdf0              POP      {r4-r7,pc}
;;;187    
                          ENDP

                  |L17.188|
                          DCD      ||.bss||

                          AREA ||i.CAN_PROTOCOL1_TxStateProcess||, CODE, READONLY, ALIGN=2

                  CAN_PROTOCOL1_TxStateProcess PROC
;;;284    // 协议层发送处理过程
;;;285    void CAN_PROTOCOL1_TxStateProcess(void)
000000  b570              PUSH     {r4-r6,lr}
;;;286    {
;;;287        uint16 head = canProtocol1CB.tx.head;
000002  4c14              LDR      r4,|L18.84|
000004  f8b426d6          LDRH     r2,[r4,#0x6d6]  ; canProtocol1CB
;;;288        uint16 end = canProtocol1CB.tx.end;
000008  f8b436d8          LDRH     r3,[r4,#0x6d8]  ; canProtocol1CB
;;;289        uint16 length = canProtocol1CB.tx.cmdQueue[head].length;
00000c  204d              MOVS     r0,#0x4d
00000e  4350              MULS     r0,r2,r0
000010  eb040040          ADD      r0,r4,r0,LSL #1
000014  4605              MOV      r5,r0
000016  f8b0646c          LDRH     r6,[r0,#0x46c]
;;;290        uint8 *pCmd = canProtocol1CB.tx.cmdQueue[head].buff;
00001a  f20031d6          ADD      r1,r0,#0x3d6
;;;291        uint16 localDeviceID = canProtocol1CB.tx.cmdQueue[head].deviceID;
00001e  f8b003d4          LDRH     r0,[r0,#0x3d4]
;;;292    
;;;293        // 发送缓冲区为空，说明无数据
;;;294        if (head == end)
000022  429a              CMP      r2,r3
000024  d015              BEQ      |L18.82|
;;;295        {
;;;296            return;
;;;297        }
;;;298    
;;;299        // 发送函数没有注册直接返回
;;;300        if (NULL == canProtocol1CB.sendDataThrowService)
000026  f8d436e0          LDR      r3,[r4,#0x6e0]  ; canProtocol1CB
00002a  2b00              CMP      r3,#0
00002c  d011              BEQ      |L18.82|
;;;301        {
;;;302            return;
;;;303        }
;;;304    
;;;305        // 协议层有数据需要发送到驱动层
;;;306        if (!(*canProtocol1CB.sendDataThrowService)(localDeviceID, pCmd, length))
00002e  b2f2              UXTB     r2,r6
000030  4798              BLX      r3
000032  2800              CMP      r0,#0
000034  d00d              BEQ      |L18.82|
;;;307        {
;;;308            return;
;;;309        }
;;;310    
;;;311        // 发送环形队列更新位置
;;;312        canProtocol1CB.tx.cmdQueue[head].length = 0;
000036  2000              MOVS     r0,#0
000038  f8a5046c          STRH     r0,[r5,#0x46c]
;;;313        canProtocol1CB.tx.head++;
00003c  f8b406d6          LDRH     r0,[r4,#0x6d6]  ; canProtocol1CB
000040  1c40              ADDS     r0,r0,#1
000042  b280              UXTH     r0,r0
;;;314        canProtocol1CB.tx.head %= CAN_PROTOCOL1_TX_QUEUE_SIZE;
000044  2105              MOVS     r1,#5
000046  fbb0f2f1          UDIV     r2,r0,r1
00004a  fb010012          MLS      r0,r1,r2,r0
00004e  f8a406d6          STRH     r0,[r4,#0x6d6]
                  |L18.82|
;;;315    }
000052  bd70              POP      {r4-r6,pc}
;;;316    
                          ENDP

                  |L18.84|
                          DCD      ||.bss||

                          AREA ||i.CAN_PROTOCOL_Process_3A||, CODE, READONLY, ALIGN=2

                  CAN_PROTOCOL_Process_3A PROC
;;;103    // UART协议层过程处理
;;;104    void CAN_PROTOCOL_Process_3A(void)
000000  b510              PUSH     {r4,lr}
;;;105    {
;;;106        // UART接收FIFO缓冲区处理
;;;107        CAN_PROTOCOL1_RxFIFOProcess(&canProtocol1CB);
000002  4805              LDR      r0,|L19.24|
000004  f7fffffe          BL       CAN_PROTOCOL1_RxFIFOProcess
;;;108    
;;;109        // UART接收命令缓冲区处理
;;;110        CAN_PROTOCOL1_CmdFrameProcess(&canProtocol1CB);
000008  4803              LDR      r0,|L19.24|
00000a  f7fffffe          BL       CAN_PROTOCOL1_CmdFrameProcess
;;;111    
;;;112        // UART协议层发送处理过程
;;;113        CAN_PROTOCOL1_TxStateProcess();
00000e  e8bd4010          POP      {r4,lr}
000012  f7ffbffe          B.W      CAN_PROTOCOL1_TxStateProcess
;;;114    }
;;;115    
                          ENDP

000016  0000              DCW      0x0000
                  |L19.24|
                          DCD      ||.bss||

                          AREA ||i.can_test||, CODE, READONLY, ALIGN=1

                  can_test PROC
;;;77     
;;;78     void can_test(uint32 temp)
000000  2100              MOVS     r1,#0
;;;79     {
;;;80         CAN_PROTOCOL1_SendCmdWithResult(0x88, FALSE);
000002  2088              MOVS     r0,#0x88
000004  f7ffbffe          B.W      CAN_PROTOCOL1_SendCmdWithResult
;;;81     }
;;;82     
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  canProtocol1CB
                          %        1764

;*** Start embedded assembler ***

#line 1 "User\\CanProtocol_3A.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_CanProtocol_3A_c_a6b80008____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___16_CanProtocol_3A_c_a6b80008____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_CanProtocol_3A_c_a6b80008____REVSH|
#line 128
|__asm___16_CanProtocol_3A_c_a6b80008____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
