L 1 "User\key.c"
N#include "common.h"
L 1 "User\common.h" 1
N#ifndef __COMMON_H__
N#define __COMMON_H__
N
N#include "gd32f10x.h"
L 1 ".\CMSIS\gd32f10x.h" 1
N/*!
N    \file    gd32f10x.h
N    \brief   general definitions for GD32F10x
N
N    \version 2014-12-26, V1.0.0, firmware for GD32F10x
N    \version 2017-06-20, V2.0.0, firmware for GD32F10x
N    \version 2018-07-31, V2.1.0, firmware for GD32F10x
N*/
N
N/*
N    Copyright (c) 2018, GigaDevice Semiconductor Inc.
N
N    All rights reserved.
N
N    Redistribution and use in source and binary forms, with or without modification, 
Nare permitted provided that the following conditions are met:
N
N    1. Redistributions of source code must retain the above copyright notice, this 
N       list of conditions and the following disclaimer.
N    2. Redistributions in binary form must reproduce the above copyright notice, 
N       this list of conditions and the following disclaimer in the documentation 
N       and/or other materials provided with the distribution.
N    3. Neither the name of the copyright holder nor the names of its contributors 
N       may be used to endorse or promote products derived from this software without 
N       specific prior written permission.
N
N    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
NAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
NWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
NIN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
NINDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
NNOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
NPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
NWHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
NARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
NOF SUCH DAMAGE.
N*/
N
N#ifndef GD32F10X_H
N#define GD32F10X_H
N
N#ifdef cplusplus
S extern "C" {
N#endif 
N
N/* define GD32F10x */
N#if !defined (GD32F10X_MD) && !defined (GD32F10X_HD) && !defined (GD32F10X_XD) && !defined (GD32F10X_CL)
X#if !0L && !0L && !1L && !0L
S  /* #define GD32F10X_MD */     /*!< GD32F10X_MD: GD32 Medium density devices */
S  /* #define GD32F10X_HD */     /*!< GD32F10X_HD: GD32 High density Value Line devices */  
S  /* #define GD32F10X_XD */     /*!< GD32F10X_XD: GD32 Extra density devices */
S  /* #define GD32F10X_CL */     /*!< GD32F10X_CL: GD32 Connectivity line devices */  
N#endif /* define GD32F10x */
N   
N#if !defined (GD32F10X_MD) && !defined (GD32F10X_HD) && !defined (GD32F10X_XD) && !defined (GD32F10X_CL)
X#if !0L && !0L && !1L && !0L
S #error "Please select the target GD32F10x device in gd32f10x.h file"
N#endif /* undefine GD32F10x tip */
N
N/* define value of high speed crystal oscillator (HXTAL) in Hz */
N#if !defined  HXTAL_VALUE    
X#if !0L    
N#ifdef GD32F10X_CL   
S#define HXTAL_VALUE    ((uint32_t)25000000) /*!< value of the external oscillator in Hz */
N#else 
N#define HXTAL_VALUE    ((uint32_t)8000000) /* !< from 4M to 16M *!< value of the external oscillator in Hz*/
N#endif /* HXTAL_VALUE */
N#endif /* high speed crystal oscillator value */
N
N/* define startup timeout value of high speed crystal oscillator (HXTAL) */
N#if !defined  (HXTAL_STARTUP_TIMEOUT)
X#if !0L
N#define HXTAL_STARTUP_TIMEOUT   ((uint16_t)0xFFFF)
N#endif /* high speed crystal oscillator startup timeout */
N
N/* define value of internal 8MHz RC oscillator (IRC8M) in Hz */
N#if !defined  (IRC8M_VALUE) 
X#if !0L 
N#define IRC8M_VALUE  ((uint32_t)8000000)
N#endif /* internal 8MHz RC oscillator value */
N
N/* define startup timeout value of internal 8MHz RC oscillator (IRC8M) */
N#if !defined  (IRC8M_STARTUP_TIMEOUT)
X#if !0L
N#define IRC8M_STARTUP_TIMEOUT   ((uint16_t)0x0500)
N#endif /* internal 8MHz RC oscillator startup timeout */
N
N/* define value of internal 40KHz RC oscillator(IRC40K) in Hz */
N#if !defined  (IRC40K_VALUE) 
X#if !0L 
N#define IRC40K_VALUE  ((uint32_t)40000)
N#endif /* internal 40KHz RC oscillator value */
N
N/* define value of low speed crystal oscillator (LXTAL)in Hz */
N#if !defined  (LXTAL_VALUE) 
X#if !0L 
N#define LXTAL_VALUE  ((uint32_t)32768)
N#endif /* low speed crystal oscillator value */
N
N/* GD32F10x firmware library version number V2.0 */
N#define __GD32F10x_STDPERIPH_VERSION_MAIN   (0x01) /*!< [31:24] main version     */
N#define __GD32F10x_STDPERIPH_VERSION_SUB1   (0x00) /*!< [23:16] sub1 version     */
N#define __GD32F10x_STDPERIPH_VERSION_SUB2   (0x00) /*!< [15:8]  sub2 version     */
N#define __GD32F10x_STDPERIPH_VERSION_RC     (0x00) /*!< [7:0]  release candidate */ 
N#define __GD32F10x_STDPERIPH_VERSION        ((__GD32F10x_STDPERIPH_VERSION_MAIN << 24)\
N                                            |(__GD32F10x_STDPERIPH_VERSION_SUB1 << 16)\
N                                            |(__GD32F10x_STDPERIPH_VERSION_SUB2 << 8)\
N                                            |(__GD32F10x_STDPERIPH_VERSION_RC))
X#define __GD32F10x_STDPERIPH_VERSION        ((__GD32F10x_STDPERIPH_VERSION_MAIN << 24)                                            |(__GD32F10x_STDPERIPH_VERSION_SUB1 << 16)                                            |(__GD32F10x_STDPERIPH_VERSION_SUB2 << 8)                                            |(__GD32F10x_STDPERIPH_VERSION_RC))
N
N/* configuration of the Cortex-M3 processor and core peripherals */
N#define __MPU_PRESENT             0        /*!< GD32F10x do not provide MPU                              */
N#define __NVIC_PRIO_BITS          4        /*!< GD32F10x uses 4 bits for the priority levels             */
N#define __Vendor_SysTickConfig    0        /*!< set to 1 if different sysTick config is used             */
N/* define interrupt number */
Ntypedef enum IRQn
N{
N    /* Cortex-M3 processor exceptions numbers */
N    NonMaskableInt_IRQn          = -14,    /*!< 2 non maskable interrupt                                 */
N    MemoryManagement_IRQn        = -12,    /*!< 4 Cortex-M3 memory management interrupt                  */
N    BusFault_IRQn                = -11,    /*!< 5 Cortex-M3 bus fault interrupt                          */
N    UsageFault_IRQn              = -10,    /*!< 6 Cortex-M3 usage fault interrupt                        */
N    SVCall_IRQn                  = -5,     /*!< 11 Cortex-M3 SV call interrupt                           */
N    DebugMonitor_IRQn            = -4,     /*!< 12 Cortex-M3 debug monitor interrupt                     */
N    PendSV_IRQn                  = -2,     /*!< 14 Cortex-M3 pend SV interrupt                           */
N    SysTick_IRQn                 = -1,     /*!< 15 Cortex-M3 system tick interrupt                       */
N
N    /* interruput numbers */
N    WWDGT_IRQn                   = 0,      /*!< window watchDog timer interrupt                          */
N    LVD_IRQn                     = 1,      /*!< LVD through EXTI line detect interrupt                   */
N    TAMPER_IRQn                  = 2,      /*!< tamper through EXTI line detect                          */
N    RTC_IRQn                     = 3,      /*!< RTC through EXTI line interrupt                          */
N    FMC_IRQn                     = 4,      /*!< FMC interrupt                                            */
N    RCU_CTC_IRQn                 = 5,      /*!< RCU and CTC interrupt                                    */
N    EXTI0_IRQn                   = 6,      /*!< EXTI line 0 interrupts                                   */
N    EXTI1_IRQn                   = 7,      /*!< EXTI line 1 interrupts                                   */
N    EXTI2_IRQn                   = 8,      /*!< EXTI line 2 interrupts                                   */
N    EXTI3_IRQn                   = 9,      /*!< EXTI line 3 interrupts                                   */
N    EXTI4_IRQn                   = 10,     /*!< EXTI line 4 interrupts                                   */
N    DMA0_Channel0_IRQn           = 11,     /*!< DMA0 channel0 interrupt                                  */
N    DMA0_Channel1_IRQn           = 12,     /*!< DMA0 channel1 interrupt                                  */
N    DMA0_Channel2_IRQn           = 13,     /*!< DMA0 channel2 interrupt                                  */
N    DMA0_Channel3_IRQn           = 14,     /*!< DMA0 channel3 interrupt                                  */
N    DMA0_Channel4_IRQn           = 15,     /*!< DMA0 channel4 interrupt                                  */
N    DMA0_Channel5_IRQn           = 16,     /*!< DMA0 channel5 interrupt                                  */
N    DMA0_Channel6_IRQn           = 17,     /*!< DMA0 channel6 interrupt                                  */
N    ADC0_1_IRQn                  = 18,     /*!< ADC0 and ADC1 interrupt                                  */
N
N#ifdef GD32F10X_MD
S    USBD_HP_CAN0_TX_IRQn         = 19,     /*!< CAN0 TX interrupts                                       */
S    USBD_LP_CAN0_RX0_IRQn        = 20,     /*!< CAN0 RX0 interrupts                                      */
S    CAN0_RX1_IRQn                = 21,     /*!< CAN0 RX1 interrupts                                      */
S    CAN0_EWMC_IRQn               = 22,     /*!< CAN0 EWMC interrupts                                     */
S    EXTI5_9_IRQn                 = 23,     /*!< EXTI[9:5] interrupts                                     */
S    TIMER0_BRK_IRQn              = 24,     /*!< TIMER0 break interrupts                                  */
S    TIMER0_UP_IRQn               = 25,     /*!< TIMER0 update interrupts                                 */
S    TIMER0_TRG_CMT_IRQn          = 26,     /*!< TIMER0 trigger and commutation interrupts                */
S    TIMER0_Channel_IRQn          = 27,     /*!< TIMER0 channel capture compare interrupts                */
S    TIMER1_IRQn                  = 28,     /*!< TIMER1 interrupt                                         */
S    TIMER2_IRQn                  = 29,     /*!< TIMER2 interrupt                                         */
S    TIMER3_IRQn                  = 30,     /*!< TIMER3 interrupts                                        */
S    I2C0_EV_IRQn                 = 31,     /*!< I2C0 event interrupt                                     */
S    I2C0_ER_IRQn                 = 32,     /*!< I2C0 error interrupt                                     */
S    I2C1_EV_IRQn                 = 33,     /*!< I2C1 event interrupt                                     */
S    I2C1_ER_IRQn                 = 34,     /*!< I2C1 error interrupt                                     */
S    SPI0_IRQn                    = 35,     /*!< SPI0 interrupt                                           */
S    SPI1_IRQn                    = 36,     /*!< SPI1 interrupt                                           */
S    USART0_IRQn                  = 37,     /*!< USART0 interrupt                                         */
S    USART1_IRQn                  = 38,     /*!< USART1 interrupt                                         */
S    USART2_IRQn                  = 39,     /*!< USART2 interrupt                                         */
S    EXTI10_15_IRQn               = 40,     /*!< EXTI[15:10] interrupts                                   */
S    RTC_Alarm_IRQn               = 41,     /*!< RTC alarm interrupt                                      */
S    USBD_WKUP_IRQn               = 42,     /*!< USBD Wakeup interrupt                                    */
S    EXMC_IRQn                    = 48,     /*!< EXMC global interrupt                                    */
N#endif /* GD32F10X_MD */
N
N#ifdef GD32F10X_HD
S    USBD_HP_CAN0_TX_IRQn         = 19,     /*!< CAN0 TX interrupts                                       */
S    USBD_LP_CAN0_RX0_IRQn        = 20,     /*!< CAN0 RX0 interrupts                                      */
S    CAN0_RX1_IRQn                = 21,     /*!< CAN0 RX1 interrupts                                      */
S    CAN0_EWMC_IRQn               = 22,     /*!< CAN0 EWMC interrupts                                     */
S    EXTI5_9_IRQn                 = 23,     /*!< EXTI[9:5] interrupts                                     */
S    TIMER0_BRK_IRQn              = 24,     /*!< TIMER0 break interrupts                                  */
S    TIMER0_UP_IRQn               = 25,     /*!< TIMER0 update interrupts                                 */
S    TIMER0_TRG_CMT_IRQn          = 26,     /*!< TIMER0 trigger and commutation interrupts                */
S    TIMER0_Channel_IRQn          = 27,     /*!< TIMER0 channel capture compare interrupts                */
S    TIMER1_IRQn                  = 28,     /*!< TIMER1 interrupt                                         */
S    TIMER2_IRQn                  = 29,     /*!< TIMER2 interrupt                                         */
S    TIMER3_IRQn                  = 30,     /*!< TIMER3 interrupts                                        */
S    I2C0_EV_IRQn                 = 31,     /*!< I2C0 event interrupt                                     */
S    I2C0_ER_IRQn                 = 32,     /*!< I2C0 error interrupt                                     */
S    I2C1_EV_IRQn                 = 33,     /*!< I2C1 event interrupt                                     */
S    I2C1_ER_IRQn                 = 34,     /*!< I2C1 error interrupt                                     */
S    SPI0_IRQn                    = 35,     /*!< SPI0 interrupt                                           */
S    SPI1_IRQn                    = 36,     /*!< SPI1 interrupt                                           */
S    USART0_IRQn                  = 37,     /*!< USART0 interrupt                                         */
S    USART1_IRQn                  = 38,     /*!< USART1 interrupt                                         */
S    USART2_IRQn                  = 39,     /*!< USART2 interrupt                                         */
S    EXTI10_15_IRQn               = 40,     /*!< EXTI[15:10] interrupts                                   */
S    RTC_Alarm_IRQn               = 41,     /*!< RTC alarm interrupt                                      */
S    USBD_WKUP_IRQn               = 42,     /*!< USBD Wakeup interrupt                                    */
S    TIMER7_BRK_IRQn              = 43,     /*!< TIMER7 break interrupts                                  */
S    TIMER7_UP_IRQn               = 44,     /*!< TIMER7 update interrupts                                 */
S    TIMER7_TRG_CMT_IRQn          = 45,     /*!< TIMER7 trigger and commutation interrupts                */
S    TIMER7_Channel_IRQn          = 46,     /*!< TIMER7 channel capture compare interrupts                */
S    ADC2_IRQn                    = 47,     /*!< ADC2 global interrupt                                    */
S    EXMC_IRQn                    = 48,     /*!< EXMC global interrupt                                    */
S    SDIO_IRQn                    = 49,     /*!< SDIO global interrupt                                    */
S    TIMER4_IRQn                  = 50,     /*!< TIMER4 global interrupt                                  */
S    SPI2_IRQn                    = 51,     /*!< SPI2 global interrupt                                    */
S    UART3_IRQn                   = 52,     /*!< UART3 global interrupt                                   */
S    UART4_IRQn                   = 53,     /*!< UART4 global interrupt                                   */
S    TIMER5_IRQn                  = 54,     /*!< TIMER5 global interrupt                                  */
S    TIMER6_IRQn                  = 55,     /*!< TIMER6 global interrupt                                  */
S    DMA1_Channel0_IRQn           = 56,     /*!< DMA1 channel0 global interrupt                           */
S    DMA1_Channel1_IRQn           = 57,     /*!< DMA1 channel1 global interrupt                           */
S    DMA1_Channel2_IRQn           = 58,     /*!< DMA1 channel2 global interrupt                           */
S    DMA1_Channel3_Channel4_IRQn  = 59,     /*!< DMA1 channel3 and channel4 global Interrupt              */
N#endif /* GD32F10X_HD */
N
N#ifdef GD32F10X_XD
N    USBD_HP_CAN0_TX_IRQn         = 19,     /*!< CAN0 TX interrupts                                       */
N    USBD_LP_CAN0_RX0_IRQn        = 20,     /*!< CAN0 RX0 interrupts                                      */
N    CAN0_RX1_IRQn                = 21,     /*!< CAN0 RX1 interrupts                                      */
N    CAN0_EWMC_IRQn               = 22,     /*!< CAN0 EWMC interrupts                                     */
N    EXTI5_9_IRQn                 = 23,     /*!< EXTI[9:5] interrupts                                     */
N    TIMER0_BRK_TIMER8_IRQn       = 24,     /*!< TIMER0 break and TIMER8 interrupts                       */
N    TIMER0_UP_TIMER9_IRQn        = 25,     /*!< TIMER0 update and TIMER9 interrupts                      */
N    TIMER0_TRG_CMT_TIMER10_IRQn  = 26,     /*!< TIMER0 trigger and commutation and TIMER10 interrupts    */
N    TIMER0_Channel_IRQn          = 27,     /*!< TIMER0 channel capture compare interrupts                */
N    TIMER1_IRQn                  = 28,     /*!< TIMER1 interrupt                                         */
N    TIMER2_IRQn                  = 29,     /*!< TIMER2 interrupt                                         */
N    TIMER3_IRQn                  = 30,     /*!< TIMER3 interrupts                                        */
N    I2C0_EV_IRQn                 = 31,     /*!< I2C0 event interrupt                                     */
N    I2C0_ER_IRQn                 = 32,     /*!< I2C0 error interrupt                                     */
N    I2C1_EV_IRQn                 = 33,     /*!< I2C1 event interrupt                                     */
N    I2C1_ER_IRQn                 = 34,     /*!< I2C1 error interrupt                                     */
N    SPI0_IRQn                    = 35,     /*!< SPI0 interrupt                                           */
N    SPI1_IRQn                    = 36,     /*!< SPI1 interrupt                                           */
N    USART0_IRQn                  = 37,     /*!< USART0 interrupt                                         */
N    USART1_IRQn                  = 38,     /*!< USART1 interrupt                                         */
N    USART2_IRQn                  = 39,     /*!< USART2 interrupt                                         */
N    EXTI10_15_IRQn               = 40,     /*!< EXTI[15:10] interrupts                                   */
N    RTC_Alarm_IRQn               = 41,     /*!< RTC alarm interrupt                                      */
N    USBD_WKUP_IRQn               = 42,     /*!< USBD wakeup interrupt                                    */
N    TIMER7_BRK_TIMER11_IRQn      = 43,     /*!< TIMER7 break and TIMER11 interrupts                      */
N    TIMER7_UP_TIMER12_IRQn       = 44,     /*!< TIMER7 update and TIMER12 interrupts                     */
N    TIMER7_TRG_CMT_TIMER13_IRQn  = 45,     /*!< TIMER7 trigger and commutation and TIMER13 interrupts    */
N    TIMER7_Channel_IRQn          = 46,     /*!< TIMER7 channel capture compare interrupts                */
N    ADC2_IRQn                    = 47,     /*!< ADC2 global interrupt                                    */
N    EXMC_IRQn                    = 48,     /*!< EXMC global interrupt                                    */
N    SDIO_IRQn                    = 49,     /*!< SDIO global interrupt                                    */
N    TIMER4_IRQn                  = 50,     /*!< TIMER4 global interrupt                                  */
N    SPI2_IRQn                    = 51,     /*!< SPI2 global interrupt                                    */
N    UART3_IRQn                   = 52,     /*!< UART3 global interrupt                                   */
N    UART4_IRQn                   = 53,     /*!< UART4 global interrupt                                   */
N    TIMER5_IRQn                  = 54,     /*!< TIMER5 global interrupt                                  */
N    TIMER6_IRQn                  = 55,     /*!< TIMER6 global interrupt                                  */
N    DMA1_Channel0_IRQn           = 56,     /*!< DMA1 channel0 global interrupt                           */
N    DMA1_Channel1_IRQn           = 57,     /*!< DMA1 channel1 global interrupt                           */
N    DMA1_Channel2_IRQn           = 58,     /*!< DMA1 channel2 global interrupt                           */
N    DMA1_Channel3_Channel4_IRQn  = 59,     /*!< DMA1 channel3 and channel4 global interrupt              */
N#endif /* GD32F10X_XD */
N
N#ifdef GD32F10X_CL
S    CAN0_TX_IRQn                 = 19,     /*!< CAN0 TX interrupts                                       */
S    CAN0_RX0_IRQn                = 20,     /*!< CAN0 RX0 interrupts                                      */
S    CAN0_RX1_IRQn                = 21,     /*!< CAN0 RX1 interrupts                                      */
S    CAN0_EWMC_IRQn               = 22,     /*!< CAN0 EWMC interrupts                                     */
S    EXTI5_9_IRQn                 = 23,     /*!< EXTI[9:5] interrupts                                     */
S    TIMER0_BRK_IRQn              = 24,     /*!< TIMER0 break interrupts                                  */
S    TIMER0_UP_IRQn               = 25,     /*!< TIMER0 update interrupts                                 */
S    TIMER0_TRG_CMT_IRQn          = 26,     /*!< TIMER0 trigger and commutation interrupts                */
S    TIMER0_Channel_IRQn          = 27,     /*!< TIMER0 channel capture compare interrupts                */
S    TIMER1_IRQn                  = 28,     /*!< TIMER1 interrupt                                         */
S    TIMER2_IRQn                  = 29,     /*!< TIMER2 interrupt                                         */
S    TIMER3_IRQn                  = 30,     /*!< TIMER3 interrupts                                        */
S    I2C0_EV_IRQn                 = 31,     /*!< I2C0 event interrupt                                     */
S    I2C0_ER_IRQn                 = 32,     /*!< I2C0 error interrupt                                     */
S    I2C1_EV_IRQn                 = 33,     /*!< I2C1 event interrupt                                     */
S    I2C1_ER_IRQn                 = 34,     /*!< I2C1 error interrupt                                     */
S    SPI0_IRQn                    = 35,     /*!< SPI0 interrupt                                           */
S    SPI1_IRQn                    = 36,     /*!< SPI1 interrupt                                           */
S    USART0_IRQn                  = 37,     /*!< USART0 interrupt                                         */
S    USART1_IRQn                  = 38,     /*!< USART1 interrupt                                         */
S    USART2_IRQn                  = 39,     /*!< USART2 interrupt                                         */
S    EXTI10_15_IRQn               = 40,     /*!< EXTI[15:10] interrupts                                   */
S    RTC_ALARM_IRQn               = 41,     /*!< RTC alarm interrupt                                      */
S    USBFS_WKUP_IRQn              = 42,     /*!< USBFS wakeup interrupt                                   */
S    TIMER7_BRK_IRQn              = 43,     /*!< TIMER7 break interrupts                                  */
S    TIMER7_UP_IRQn               = 44,     /*!< TIMER7 update interrupts                                 */
S    TIMER7_TRG_CMT_IRQn          = 45,     /*!< TIMER7 trigger and commutation interrupts                */
S    TIMER7_Channel_IRQn          = 46,     /*!< TIMER7 channel capture compare interrupts                */
S    EXMC_IRQn                    = 48,     /*!< EXMC global interrupt                                    */
S    TIMER4_IRQn                  = 50,     /*!< TIMER4 global interrupt                                  */
S    SPI2_IRQn                    = 51,     /*!< SPI2 global interrupt                                    */
S    UART3_IRQn                   = 52,     /*!< UART3 global interrupt                                   */
S    UART4_IRQn                   = 53,     /*!< UART4 global interrupt                                   */
S    TIMER5_IRQn                  = 54,     /*!< TIMER5 global interrupt                                  */
S    TIMER6_IRQn                  = 55,     /*!< TIMER6 global interrupt                                  */
S    DMA1_Channel0_IRQn           = 56,     /*!< DMA1 channel0 global interrupt                           */
S    DMA1_Channel1_IRQn           = 57,     /*!< DMA1 channel1 global interrupt                           */
S    DMA1_Channel2_IRQn           = 58,     /*!< DMA1 channel2 global interrupt                           */
S    DMA1_Channel3_IRQn           = 59,     /*!< DMA1 channel3 global interrupt                           */
S    DMA1_Channel4_IRQn           = 60,     /*!< DMA1 channel3 global interrupt                           */
S    ENET_IRQn                    = 61,     /*!< ENET global interrupt                                    */
S    ENET_WKUP_IRQn               = 62,     /*!< ENET Wakeup interrupt                                    */
S    CAN1_TX_IRQn                 = 63,     /*!< CAN1 TX interrupt                                        */
S    CAN1_RX0_IRQn                = 64,     /*!< CAN1 RX0 interrupt                                       */
S    CAN1_RX1_IRQn                = 65,     /*!< CAN1 RX1 interrupt                                       */
S    CAN1_EWMC_IRQn               = 66,     /*!< CAN1 EWMC interrupt                                      */
S    USBFS_IRQn                   = 67,     /*!< USBFS global interrupt                                   */
N#endif /* GD32F10X_CL */
N
N} IRQn_Type;
N
N/* includes */
N#include "core_cm3.h"
L 1 ".\CMSIS\core_cm3.h" 1
N/**************************************************************************//**
N * @file     core_cm3.h
N * @brief    CMSIS Cortex-M3 Core Peripheral Access Layer Header File
N * @version  V3.30
N * @date     17. February 2014
N *
N * @note
N *
N ******************************************************************************/
N/* Copyright (c) 2009 - 2014 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if defined ( __ICCARM__ )
X#if 0L
S #pragma system_include  /* treat file as system include file for MISRA check */
N#endif
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N#ifndef __CORE_CM3_H_GENERIC
N#define __CORE_CM3_H_GENERIC
N
N/** \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/** \ingroup Cortex_M3
N  @{
N */
N
N/*  CMSIS CM3 definitions */
N#define __CM3_CMSIS_VERSION_MAIN  (0x03)                                   /*!< [31:16] CMSIS HAL main version   */
N#define __CM3_CMSIS_VERSION_SUB   (0x20)                                   /*!< [15:0]  CMSIS HAL sub version    */
N#define __CM3_CMSIS_VERSION       ((__CM3_CMSIS_VERSION_MAIN << 16) | \
N                                    __CM3_CMSIS_VERSION_SUB          )     /*!< CMSIS HAL version number         */
X#define __CM3_CMSIS_VERSION       ((__CM3_CMSIS_VERSION_MAIN << 16) |                                     __CM3_CMSIS_VERSION_SUB          )      
N
N#define __CORTEX_M                (0x03)                                   /*!< Cortex-M Core                    */
N
N
N#if   defined ( __CC_ARM )
X#if   1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
N  #define __STATIC_INLINE  static __inline
N
N#elif defined ( __GNUC__ )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __ICCARM__ )
S  #define __ASM            __asm                                      /*!< asm keyword for IAR Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TMS470__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TI CCS Compiler       */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TASKING__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __CSMC__ )  /* Cosmic */
S  #define __packed
S  #define __ASM            _asm                                      /*!< asm keyword for COSMIC Compiler      */
S  #define __INLINE         inline                                    /*use -pc99 on compile line !< inline keyword for COSMIC Compiler   */
S  #define __STATIC_INLINE  static inline
S
N#endif
N
N/** __FPU_USED indicates whether an FPU is used or not. This core does not support an FPU at all
N*/
N#define __FPU_USED       0
N
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 0L
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
N  #endif
N
N#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TMS470__ )
S  #if defined __TI__VFP_SUPPORT____
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __CSMC__ )    /* Cosmic */
S  #if ( __CSMC__ & 0x400)    // FPU present for parser
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
N#endif
N
N#include <stdint.h>                      /* standard types definitions                      */
L 1 "D:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) STS Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __STSCLIB_VERSION 5060044
N
N  #ifdef __INT64_TYPE__
S    /* STSclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* STScc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__STSCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (0L && !0L)
S    /* STSclang and non-strict STScc allow 'long long' in system headers */
S    #define __LONGLONG long long
N  #else
N    /* strict STScc has '__int64' */
N    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     __int64 intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     __int64 uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__STS_SIZEOF_WCHAR_T) && __STS_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __STS_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 147 ".\CMSIS\core_cm3.h" 2
N#include <core_cmInstr.h>                /* Core Instruction Access                         */
L 1 ".\CMSIS\core_cmInstr.h" 1
N/**************************************************************************//**
N * @file     core_cmInstr.h
N * @brief    CMSIS Cortex-M Core Instruction Access Header File
N * @version  V3.01
N * @date     06. March 2012
N *
N * @note
N * Copyright (C) 2009-2012 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M
N * processor based microcontrollers.  This file can be freely distributed
N * within development tools that are supporting such ARM based processors.
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N#ifndef __CORE_CMINSTR_H
N#define __CORE_CMINSTR_H
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
X#if   1L  
N/* ARM armcc specific functions */
N
N#if (__ARMCC_VERSION < 400677)
X#if (5060960 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N
N/** \brief  No Operation
N
N    No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/** \brief  Wait For Interrupt
N
N    Wait For Interrupt is a hint instruction that suspends execution
N    until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/** \brief  Wait For Event
N
N    Wait For Event is a hint instruction that permits the processor to enter
N    a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/** \brief  Send Event
N
N    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/** \brief  Instruction Synchronization Barrier
N
N    Instruction Synchronization Barrier flushes the pipeline in the processor,
N    so that all instructions following the ISB are fetched from cache or
N    memory, after the instruction has been completed.
N */
N#define __ISB()                           __isb(0xF)
N
N
N/** \brief  Data Synchronization Barrier
N
N    This function acts as a special kind of Data Memory Barrier.
N    It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB()                           __dsb(0xF)
N
N
N/** \brief  Data Memory Barrier
N
N    This function ensures the apparent order of the explicit memory operations before
N    and after the instruction, without ensuring their completion.
N */
N#define __DMB()                           __dmb(0xF)
N
N
N/** \brief  Reverse byte order (32 bit)
N
N    This function reverses the byte order in integer value.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/** \brief  Reverse byte order (16 bit)
N
N    This function reverses the byte order in two unsigned short values.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N
N
N/** \brief  Reverse byte order in signed short value
N
N    This function reverses the byte order in a signed short value with sign extension to integer.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int32_t __REVSH(int32_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N
N
N/** \brief  Rotate Right in unsigned value (32 bit)
N
N    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N
N    \param [in]    value  Value to rotate
N    \param [in]    value  Number of Bits to rotate
N    \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N#if       (__CORTEX_M >= 0x03)
X#if       ((0x03) >= 0x03)
N
N/** \brief  Reverse bit order of value
N
N    This function reverses the bit order of the given value.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#define __RBIT                            __rbit
N
N
N/** \brief  LDR Exclusive (8 bit)
N
N    This function performs a exclusive LDR command for 8 bit value.
N
N    \param [in]    ptr  Pointer to data
N    \return             value of type uint8_t at (*ptr)
N */
N#define __LDREXB(ptr)                     ((uint8_t ) __ldrex(ptr))
N
N
N/** \brief  LDR Exclusive (16 bit)
N
N    This function performs a exclusive LDR command for 16 bit values.
N
N    \param [in]    ptr  Pointer to data
N    \return        value of type uint16_t at (*ptr)
N */
N#define __LDREXH(ptr)                     ((uint16_t) __ldrex(ptr))
N
N
N/** \brief  LDR Exclusive (32 bit)
N
N    This function performs a exclusive LDR command for 32 bit values.
N
N    \param [in]    ptr  Pointer to data
N    \return        value of type uint32_t at (*ptr)
N */
N#define __LDREXW(ptr)                     ((uint32_t ) __ldrex(ptr))
N
N
N/** \brief  STR Exclusive (8 bit)
N
N    This function performs a exclusive STR command for 8 bit values.
N
N    \param [in]  value  Value to store
N    \param [in]    ptr  Pointer to location
N    \return          0  Function succeeded
N    \return          1  Function failed
N */
N#define __STREXB(value, ptr)              __strex(value, ptr)
N
N
N/** \brief  STR Exclusive (16 bit)
N
N    This function performs a exclusive STR command for 16 bit values.
N
N    \param [in]  value  Value to store
N    \param [in]    ptr  Pointer to location
N    \return          0  Function succeeded
N    \return          1  Function failed
N */
N#define __STREXH(value, ptr)              __strex(value, ptr)
N
N
N/** \brief  STR Exclusive (32 bit)
N
N    This function performs a exclusive STR command for 32 bit values.
N
N    \param [in]  value  Value to store
N    \param [in]    ptr  Pointer to location
N    \return          0  Function succeeded
N    \return          1  Function failed
N */
N#define __STREXW(value, ptr)              __strex(value, ptr)
N
N
N/** \brief  Remove the exclusive lock
N
N    This function removes the exclusive lock which is created by LDREX.
N
N */
N#define __CLREX                           __clrex
N
N
N/** \brief  Signed Saturate
N
N    This function saturates a signed value.
N
N    \param [in]  value  Value to be saturated
N    \param [in]    sat  Bit position to saturate to (1..32)
N    \return             Saturated value
N */
N#define __SSAT                            __ssat
N
N
N/** \brief  Unsigned Saturate
N
N    This function saturates an unsigned value.
N
N    \param [in]  value  Value to be saturated
N    \param [in]    sat  Bit position to saturate to (0..31)
N    \return             Saturated value
N */
N#define __USAT                            __usat
N
N
N/** \brief  Count leading zeros
N
N    This function counts the number of leading zeros of a data value.
N
N    \param [in]  value  Value to count the leading zeros
N    \return             number of leading zeros in value
N */
N#define __CLZ                             __clz
N
N#endif /* (__CORTEX_M >= 0x03) */
N
N
N
N#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S
S#include <cmsis_iar.h>
S
S
S#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
S/* TI CCS specific functions */
S
S#include <cmsis_ccs.h>
S
S
S#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
S/** \brief  No Operation
S
S    No Operation does nothing. This instruction can be used for code alignment purposes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __NOP(void)
S{
S  __ASM volatile ("nop");
S}
S
S
S/** \brief  Wait For Interrupt
S
S    Wait For Interrupt is a hint instruction that suspends execution
S    until one of a number of events occurs.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFI(void)
S{
S  __ASM volatile ("wfi");
S}
S
S
S/** \brief  Wait For Event
S
S    Wait For Event is a hint instruction that permits the processor to enter
S    a low-power state until one of a number of events occurs.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFE(void)
S{
S  __ASM volatile ("wfe");
S}
S
S
S/** \brief  Send Event
S
S    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __SEV(void)
S{
S  __ASM volatile ("sev");
S}
S
S
S/** \brief  Instruction Synchronization Barrier
S
S    Instruction Synchronization Barrier flushes the pipeline in the processor,
S    so that all instructions following the ISB are fetched from cache or
S    memory, after the instruction has been completed.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __ISB(void)
S{
S  __ASM volatile ("isb");
S}
S
S
S/** \brief  Data Synchronization Barrier
S
S    This function acts as a special kind of Data Memory Barrier.
S    It completes when all explicit memory accesses before this instruction complete.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __DSB(void)
S{
S  __ASM volatile ("dsb");
S}
S
S
S/** \brief  Data Memory Barrier
S
S    This function ensures the apparent order of the explicit memory operations before
S    and after the instruction, without ensuring their completion.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
S{
S  __ASM volatile ("dmb");
S}
S
S
S/** \brief  Reverse byte order (32 bit)
S
S    This function reverses the byte order in integer value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __REV(uint32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S
S/** \brief  Reverse byte order (16 bit)
S
S    This function reverses the byte order in two unsigned short values.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __REV16(uint32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("rev16 %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S
S/** \brief  Reverse byte order in signed short value
S
S    This function reverses the byte order in a signed short value with sign extension to integer.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE int32_t __REVSH(int32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("revsh %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S
S/** \brief  Rotate Right in unsigned value (32 bit)
S
S    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
S
S    \param [in]    value  Value to rotate
S    \param [in]    value  Number of Bits to rotate
S    \return               Rotated value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __ROR(uint32_t op1, uint32_t op2)
S{
S
S  __ASM volatile ("ror %0, %0, %1" : "+r" (op1) : "r" (op2) );
S  return(op1);
S}
S
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Reverse bit order of value
S
S    This function reverses the bit order of the given value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
S{
S  uint32_t result;
S
S   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (8 bit)
S
S    This function performs a exclusive LDR command for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __LDREXB(volatile uint8_t *addr)
S{
S    uint8_t result;
S
S   __ASM volatile ("ldrexb %0, [%1]" : "=r" (result) : "r" (addr) );
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (16 bit)
S
S    This function performs a exclusive LDR command for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint16_t __LDREXH(volatile uint16_t *addr)
S{
S    uint16_t result;
S
S   __ASM volatile ("ldrexh %0, [%1]" : "=r" (result) : "r" (addr) );
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (32 bit)
S
S    This function performs a exclusive LDR command for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __LDREXW(volatile uint32_t *addr)
S{
S    uint32_t result;
S
S   __ASM volatile ("ldrex %0, [%1]" : "=r" (result) : "r" (addr) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (8 bit)
S
S    This function performs a exclusive STR command for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXB(uint8_t value, volatile uint8_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strexb %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (16 bit)
S
S    This function performs a exclusive STR command for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXH(uint16_t value, volatile uint16_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strexh %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (32 bit)
S
S    This function performs a exclusive STR command for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strex %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
S   return(result);
S}
S
S
S/** \brief  Remove the exclusive lock
S
S    This function removes the exclusive lock which is created by LDREX.
S
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __CLREX(void)
S{
S  __ASM volatile ("clrex");
S}
S
S
S/** \brief  Signed Saturate
S
S    This function saturates a signed value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (1..32)
S    \return             Saturated value
S */
S#define __SSAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __SSAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Unsigned Saturate
S
S    This function saturates an unsigned value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (0..31)
S    \return             Saturated value
S */
S#define __USAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __USAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Count leading zeros
S
S    This function counts the number of leading zeros of a data value.
S
S    \param [in]  value  Value to count the leading zeros
S    \return             number of leading zeros in value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
S{
S  uint8_t result;
S
S  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S
S
S
S#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
S/* TASKING carm specific functions */
S
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all intrinsics,
S * Including the CMSIS ones.
S */
S
N#endif
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N#endif /* __CORE_CMINSTR_H */
L 148 ".\CMSIS\core_cm3.h" 2
N#include <core_cmFunc.h>                 /* Core Function Access                            */
L 1 ".\CMSIS\core_cmFunc.h" 1
N/**************************************************************************//**
N * @file     core_cmFunc.h
N * @brief    CMSIS Cortex-M Core Function Access Header File
N * @version  V3.01
N * @date     06. March 2012
N *
N * @note
N * Copyright (C) 2009-2012 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M
N * processor based microcontrollers.  This file can be freely distributed
N * within development tools that are supporting such ARM based processors.
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N#ifndef __CORE_CMFUNC_H
N#define __CORE_CMFUNC_H
N
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
X#if   1L  
N/* ARM armcc specific functions */
N
N#if (__ARMCC_VERSION < 400677)
X#if (5060960 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* intrinsic void __enable_irq();     */
N/* intrinsic void __disable_irq();    */
N
N/** \brief  Get Control Register
N
N    This function returns the content of the Control Register.
N
N    \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/** \brief  Set Control Register
N
N    This function writes the given value to the Control Register.
N
N    \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N
N/** \brief  Get IPSR Register
N
N    This function returns the content of the IPSR Register.
N
N    \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/** \brief  Get APSR Register
N
N    This function returns the content of the APSR Register.
N
N    \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/** \brief  Get xPSR Register
N
N    This function returns the content of the xPSR Register.
N
N    \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/** \brief  Get Process Stack Pointer
N
N    This function returns the current value of the Process Stack Pointer (PSP).
N
N    \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/** \brief  Set Process Stack Pointer
N
N    This function assigns the given value to the Process Stack Pointer (PSP).
N
N    \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/** \brief  Get Main Stack Pointer
N
N    This function returns the current value of the Main Stack Pointer (MSP).
N
N    \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/** \brief  Set Main Stack Pointer
N
N    This function assigns the given value to the Main Stack Pointer (MSP).
N
N    \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/** \brief  Get Priority Mask
N
N    This function returns the current state of the priority mask bit from the Priority Mask Register.
N
N    \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/** \brief  Set Priority Mask
N
N    This function assigns the given value to the Priority Mask Register.
N
N    \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N
N#if       (__CORTEX_M >= 0x03)
X#if       ((0x03) >= 0x03)
N
N/** \brief  Enable FIQ
N
N    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
N    Can only be executed in Privileged modes.
N */
N#define __enable_fault_irq                __enable_fiq
N
N
N/** \brief  Disable FIQ
N
N    This function disables FIQ interrupts by setting the F-bit in the CPSR.
N    Can only be executed in Privileged modes.
N */
N#define __disable_fault_irq               __disable_fiq
N
N
N/** \brief  Get Base Priority
N
N    This function returns the current value of the Base Priority register.
N
N    \return               Base Priority register value
N */
N__STATIC_INLINE uint32_t  __get_BASEPRI(void)
Xstatic __inline uint32_t  __get_BASEPRI(void)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  return(__regBasePri);
N}
N
N
N/** \brief  Set Base Priority
N
N    This function assigns the given value to the Base Priority register.
N
N    \param [in]    basePri  Base Priority value to set
N */
N__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
Xstatic __inline void __set_BASEPRI(uint32_t basePri)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  __regBasePri = (basePri & 0xff);
N}
N
N
N/** \brief  Get Fault Mask
N
N    This function returns the current value of the Fault Mask register.
N
N    \return               Fault Mask register value
N */
N__STATIC_INLINE uint32_t __get_FAULTMASK(void)
Xstatic __inline uint32_t __get_FAULTMASK(void)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  return(__regFaultMask);
N}
N
N
N/** \brief  Set Fault Mask
N
N    This function assigns the given value to the Fault Mask register.
N
N    \param [in]    faultMask  Fault Mask value to set
N */
N__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
Xstatic __inline void __set_FAULTMASK(uint32_t faultMask)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  __regFaultMask = (faultMask & (uint32_t)1);
N}
N
N#endif /* (__CORTEX_M >= 0x03) */
N
N
N#if       (__CORTEX_M == 0x04)
X#if       ((0x03) == 0x04)
S
S/** \brief  Get FPSCR
S
S    This function returns the current value of the Floating Point Status/Control register.
S
S    \return               Floating Point Status/Control register value
S */
S__STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  return(__regfpscr);
S#else
S   return(0);
S#endif
S}
S
S
S/** \brief  Set FPSCR
S
S    This function assigns the given value to the Floating Point Status/Control register.
S
S    \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  __regfpscr = (fpscr);
S#endif
S}
S
N#endif /* (__CORTEX_M == 0x04) */
N
N
N#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S
S#include <cmsis_iar.h>
S
S
S#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
S/* TI CCS specific functions */
S
S#include <cmsis_ccs.h>
S
S
S#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
S/** \brief  Enable IRQ Interrupts
S
S  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
S{
S  __ASM volatile ("cpsie i");
S}
S
S
S/** \brief  Disable IRQ Interrupts
S
S  This function disables IRQ interrupts by setting the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
S{
S  __ASM volatile ("cpsid i");
S}
S
S
S/** \brief  Get Control Register
S
S    This function returns the content of the Control Register.
S
S    \return               Control Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_CONTROL(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, control" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Control Register
S
S    This function writes the given value to the Control Register.
S
S    \param [in]    control  Control Register value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_CONTROL(uint32_t control)
S{
S  __ASM volatile ("MSR control, %0" : : "r" (control) );
S}
S
S
S/** \brief  Get IPSR Register
S
S    This function returns the content of the IPSR Register.
S
S    \return               IPSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get APSR Register
S
S    This function returns the content of the APSR Register.
S
S    \return               APSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_APSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, apsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get xPSR Register
S
S    This function returns the content of the xPSR Register.
S
S    \return               xPSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_xPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get Process Stack Pointer
S
S    This function returns the current value of the Process Stack Pointer (PSP).
S
S    \return               PSP Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Process Stack Pointer
S
S    This function assigns the given value to the Process Stack Pointer (PSP).
S
S    \param [in]    topOfProcStack  Process Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
S{
S  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) );
S}
S
S
S/** \brief  Get Main Stack Pointer
S
S    This function returns the current value of the Main Stack Pointer (MSP).
S
S    \return               MSP Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_MSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, msp\n" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Main Stack Pointer
S
S    This function assigns the given value to the Main Stack Pointer (MSP).
S
S    \param [in]    topOfMainStack  Main Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
S{
S  __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) );
S}
S
S
S/** \brief  Get Priority Mask
S
S    This function returns the current state of the priority mask bit from the Priority Mask Register.
S
S    \return               Priority Mask value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, primask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Priority Mask
S
S    This function assigns the given value to the Priority Mask Register.
S
S    \param [in]    priMask  Priority Mask
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
S{
S  __ASM volatile ("MSR primask, %0" : : "r" (priMask) );
S}
S
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Enable FIQ
S
S    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_fault_irq(void)
S{
S  __ASM volatile ("cpsie f");
S}
S
S
S/** \brief  Disable FIQ
S
S    This function disables FIQ interrupts by setting the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_fault_irq(void)
S{
S  __ASM volatile ("cpsid f");
S}
S
S
S/** \brief  Get Base Priority
S
S    This function returns the current value of the Base Priority register.
S
S    \return               Base Priority register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, basepri_max" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Base Priority
S
S    This function assigns the given value to the Base Priority register.
S
S    \param [in]    basePri  Base Priority value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
S{
S  __ASM volatile ("MSR basepri, %0" : : "r" (value) );
S}
S
S
S/** \brief  Get Fault Mask
S
S    This function returns the current value of the Fault Mask register.
S
S    \return               Fault Mask register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FAULTMASK(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Fault Mask
S
S    This function assigns the given value to the Fault Mask register.
S
S    \param [in]    faultMask  Fault Mask value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) );
S}
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S
S#if       (__CORTEX_M == 0x04)
S
S/** \brief  Get FPSCR
S
S    This function returns the current value of the Floating Point Status/Control register.
S
S    \return               Floating Point Status/Control register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  uint32_t result;
S
S  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
S  return(result);
S#else
S   return(0);
S#endif
S}
S
S
S/** \brief  Set FPSCR
S
S    This function assigns the given value to the Floating Point Status/Control register.
S
S    \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) );
S#endif
S}
S
S#endif /* (__CORTEX_M == 0x04) */
S
S
S#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
S/* TASKING carm specific functions */
S
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all instrinsics,
S * Including the CMSIS ones.
S */
S
N#endif
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N
N#endif /* __CORE_CMFUNC_H */
L 149 ".\CMSIS\core_cm3.h" 2
N
N#endif /* __CORE_CM3_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM3_H_DEPENDANT
N#define __CORE_CM3_H_DEPENDANT
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S  #ifndef __CM3_REV
S    #define __CM3_REV               0x0200
S    #warning "__CM3_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __MPU_PRESENT
S    #define __MPU_PRESENT             0
S    #warning "__MPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          4
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions                 */
N#else
N  #define   __I     volatile const       /*!< Defines 'read only' permissions                 */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions                */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions              */
N
N/*@} end of group Cortex_M3 */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N  - Core Debug Register
N  - Core MPU Register
N ******************************************************************************/
N/** \defgroup CMSIS_core_register Defines and Type Definitions
N    \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_CORE  Status and Control Registers
N    \brief  Core Register type definitions.
N  @{
N */
N
N/** \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N#if (__CORTEX_M != 0x04)
X#if ((0x03) != 0x04)
N    uint32_t _reserved0:27;              /*!< bit:  0..26  Reserved                           */
N#else
S    uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved                           */
S    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
S    uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved                           */
N#endif
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} APSR_Type;
N
N
N/** \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved                           */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} IPSR_Type;
N
N
N/** \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
N#if (__CORTEX_M != 0x04)
X#if ((0x03) != 0x04)
N    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved                           */
N#else
S    uint32_t _reserved0:7;               /*!< bit:  9..15  Reserved                           */
S    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
S    uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved                           */
N#endif
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0)          */
N    uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0)          */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} xPSR_Type;
N
N
N/** \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used                   */
N    uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag           */
N    uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved                           */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} CONTROL_Type;
N
N/*@} end of group CMSIS_CORE */
N
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N    \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/** \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IO uint32_t ISER[8];                 /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register           */
X  volatile uint32_t ISER[8];                  
N       uint32_t RESERVED0[24];
N  __IO uint32_t ICER[8];                 /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register         */
X  volatile uint32_t ICER[8];                  
N       uint32_t RSERVED1[24];
N  __IO uint32_t ISPR[8];                 /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register          */
X  volatile uint32_t ISPR[8];                  
N       uint32_t RESERVED2[24];
N  __IO uint32_t ICPR[8];                 /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register        */
X  volatile uint32_t ICPR[8];                  
N       uint32_t RESERVED3[24];
N  __IO uint32_t IABR[8];                 /*!< Offset: 0x200 (R/W)  Interrupt Active bit Register           */
X  volatile uint32_t IABR[8];                  
N       uint32_t RESERVED4[56];
N  __IO uint8_t  IP[240];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register (8Bit wide) */
X  volatile uint8_t  IP[240];                  
N       uint32_t RESERVED5[644];
N  __O  uint32_t STIR;                    /*!< Offset: 0xE00 ( /W)  Software Trigger Interrupt Register     */
X  volatile  uint32_t STIR;                     
N}  NVIC_Type;
N
N/* Software Triggered Interrupt Register Definitions */
N#define NVIC_STIR_INTID_Pos                 0                                          /*!< STIR: INTLINESNUM Position */
N#define NVIC_STIR_INTID_Msk                (0x1FFUL << NVIC_STIR_INTID_Pos)            /*!< STIR: INTLINESNUM Mask */
N
N/*@} end of group CMSIS_NVIC */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SCB     System Control Block (SCB)
N    \brief      Type definitions for the System Control Block Registers
N  @{
N */
N
N/** \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __I  uint32_t CPUID;                   /*!< Offset: 0x000 (R/ )  CPUID Base Register                                   */
X  volatile const  uint32_t CPUID;                    
N  __IO uint32_t ICSR;                    /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register                  */
X  volatile uint32_t ICSR;                     
N  __IO uint32_t VTOR;                    /*!< Offset: 0x008 (R/W)  Vector Table Offset Register                          */
X  volatile uint32_t VTOR;                     
N  __IO uint32_t AIRCR;                   /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register      */
X  volatile uint32_t AIRCR;                    
N  __IO uint32_t SCR;                     /*!< Offset: 0x010 (R/W)  System Control Register                               */
X  volatile uint32_t SCR;                      
N  __IO uint32_t CCR;                     /*!< Offset: 0x014 (R/W)  Configuration Control Register                        */
X  volatile uint32_t CCR;                      
N  __IO uint8_t  SHP[12];                 /*!< Offset: 0x018 (R/W)  System Handlers Priority Registers (4-7, 8-11, 12-15) */
X  volatile uint8_t  SHP[12];                  
N  __IO uint32_t SHCSR;                   /*!< Offset: 0x024 (R/W)  System Handler Control and State Register             */
X  volatile uint32_t SHCSR;                    
N  __IO uint32_t CFSR;                    /*!< Offset: 0x028 (R/W)  Configurable Fault Status Register                    */
X  volatile uint32_t CFSR;                     
N  __IO uint32_t HFSR;                    /*!< Offset: 0x02C (R/W)  HardFault Status Register                             */
X  volatile uint32_t HFSR;                     
N  __IO uint32_t DFSR;                    /*!< Offset: 0x030 (R/W)  Debug Fault Status Register                           */
X  volatile uint32_t DFSR;                     
N  __IO uint32_t MMFAR;                   /*!< Offset: 0x034 (R/W)  MemManage Fault Address Register                      */
X  volatile uint32_t MMFAR;                    
N  __IO uint32_t BFAR;                    /*!< Offset: 0x038 (R/W)  BusFault Address Register                             */
X  volatile uint32_t BFAR;                     
N  __IO uint32_t AFSR;                    /*!< Offset: 0x03C (R/W)  Auxiliary Fault Status Register                       */
X  volatile uint32_t AFSR;                     
N  __I  uint32_t PFR[2];                  /*!< Offset: 0x040 (R/ )  Processor Feature Register                            */
X  volatile const  uint32_t PFR[2];                   
N  __I  uint32_t DFR;                     /*!< Offset: 0x048 (R/ )  Debug Feature Register                                */
X  volatile const  uint32_t DFR;                      
N  __I  uint32_t ADR;                     /*!< Offset: 0x04C (R/ )  Auxiliary Feature Register                            */
X  volatile const  uint32_t ADR;                      
N  __I  uint32_t MMFR[4];                 /*!< Offset: 0x050 (R/ )  Memory Model Feature Register                         */
X  volatile const  uint32_t MMFR[4];                  
N  __I  uint32_t ISAR[5];                 /*!< Offset: 0x060 (R/ )  Instruction Set Attributes Register                   */
X  volatile const  uint32_t ISAR[5];                  
N       uint32_t RESERVED0[5];
N  __IO uint32_t CPACR;                   /*!< Offset: 0x088 (R/W)  Coprocessor Access Control Register                   */
X  volatile uint32_t CPACR;                    
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16                                             /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL << SCB_CPUID_REVISION_Pos)              /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_RETTOBASE_Pos             11                                             /*!< SCB ICSR: RETTOBASE Position */
N#define SCB_ICSR_RETTOBASE_Msk             (1UL << SCB_ICSR_RETTOBASE_Pos)                /*!< SCB ICSR: RETTOBASE Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL << SCB_ICSR_VECTACTIVE_Pos)           /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Vector Table Offset Register Definitions */
N#if (__CM3_REV < 0x0201)                   /* core r2p1 */
N#define SCB_VTOR_TBLBASE_Pos               29                                             /*!< SCB VTOR: TBLBASE Position */
N#define SCB_VTOR_TBLBASE_Msk               (1UL << SCB_VTOR_TBLBASE_Pos)                  /*!< SCB VTOR: TBLBASE Mask */
N
N#define SCB_VTOR_TBLOFF_Pos                 7                                             /*!< SCB VTOR: TBLOFF Position */
N#define SCB_VTOR_TBLOFF_Msk                (0x3FFFFFUL << SCB_VTOR_TBLOFF_Pos)            /*!< SCB VTOR: TBLOFF Mask */
N#else
S#define SCB_VTOR_TBLOFF_Pos                 7                                             /*!< SCB VTOR: TBLOFF Position */
S#define SCB_VTOR_TBLOFF_Msk                (0x1FFFFFFUL << SCB_VTOR_TBLOFF_Pos)           /*!< SCB VTOR: TBLOFF Mask */
N#endif
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_PRIGROUP_Pos              8                                             /*!< SCB AIRCR: PRIGROUP Position */
N#define SCB_AIRCR_PRIGROUP_Msk             (7UL << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB AIRCR: PRIGROUP Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N#define SCB_AIRCR_VECTRESET_Pos             0                                             /*!< SCB AIRCR: VECTRESET Position */
N#define SCB_AIRCR_VECTRESET_Msk            (1UL << SCB_AIRCR_VECTRESET_Pos)               /*!< SCB AIRCR: VECTRESET Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_BFHFNMIGN_Pos               8                                             /*!< SCB CCR: BFHFNMIGN Position */
N#define SCB_CCR_BFHFNMIGN_Msk              (1UL << SCB_CCR_BFHFNMIGN_Pos)                 /*!< SCB CCR: BFHFNMIGN Mask */
N
N#define SCB_CCR_DIV_0_TRP_Pos               4                                             /*!< SCB CCR: DIV_0_TRP Position */
N#define SCB_CCR_DIV_0_TRP_Msk              (1UL << SCB_CCR_DIV_0_TRP_Pos)                 /*!< SCB CCR: DIV_0_TRP Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N#define SCB_CCR_USERSETMPEND_Pos            1                                             /*!< SCB CCR: USERSETMPEND Position */
N#define SCB_CCR_USERSETMPEND_Msk           (1UL << SCB_CCR_USERSETMPEND_Pos)              /*!< SCB CCR: USERSETMPEND Mask */
N
N#define SCB_CCR_NONBASETHRDENA_Pos          0                                             /*!< SCB CCR: NONBASETHRDENA Position */
N#define SCB_CCR_NONBASETHRDENA_Msk         (1UL << SCB_CCR_NONBASETHRDENA_Pos)            /*!< SCB CCR: NONBASETHRDENA Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_USGFAULTENA_Pos          18                                             /*!< SCB SHCSR: USGFAULTENA Position */
N#define SCB_SHCSR_USGFAULTENA_Msk          (1UL << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB SHCSR: USGFAULTENA Mask */
N
N#define SCB_SHCSR_BUSFAULTENA_Pos          17                                             /*!< SCB SHCSR: BUSFAULTENA Position */
N#define SCB_SHCSR_BUSFAULTENA_Msk          (1UL << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB SHCSR: BUSFAULTENA Mask */
N
N#define SCB_SHCSR_MEMFAULTENA_Pos          16                                             /*!< SCB SHCSR: MEMFAULTENA Position */
N#define SCB_SHCSR_MEMFAULTENA_Msk          (1UL << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB SHCSR: MEMFAULTENA Mask */
N
N#define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N#define SCB_SHCSR_BUSFAULTPENDED_Pos       14                                             /*!< SCB SHCSR: BUSFAULTPENDED Position */
N#define SCB_SHCSR_BUSFAULTPENDED_Msk       (1UL << SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!< SCB SHCSR: BUSFAULTPENDED Mask */
N
N#define SCB_SHCSR_MEMFAULTPENDED_Pos       13                                             /*!< SCB SHCSR: MEMFAULTPENDED Position */
N#define SCB_SHCSR_MEMFAULTPENDED_Msk       (1UL << SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!< SCB SHCSR: MEMFAULTPENDED Mask */
N
N#define SCB_SHCSR_USGFAULTPENDED_Pos       12                                             /*!< SCB SHCSR: USGFAULTPENDED Position */
N#define SCB_SHCSR_USGFAULTPENDED_Msk       (1UL << SCB_SHCSR_USGFAULTPENDED_Pos)          /*!< SCB SHCSR: USGFAULTPENDED Mask */
N
N#define SCB_SHCSR_SYSTICKACT_Pos           11                                             /*!< SCB SHCSR: SYSTICKACT Position */
N#define SCB_SHCSR_SYSTICKACT_Msk           (1UL << SCB_SHCSR_SYSTICKACT_Pos)              /*!< SCB SHCSR: SYSTICKACT Mask */
N
N#define SCB_SHCSR_PENDSVACT_Pos            10                                             /*!< SCB SHCSR: PENDSVACT Position */
N#define SCB_SHCSR_PENDSVACT_Msk            (1UL << SCB_SHCSR_PENDSVACT_Pos)               /*!< SCB SHCSR: PENDSVACT Mask */
N
N#define SCB_SHCSR_MONITORACT_Pos            8                                             /*!< SCB SHCSR: MONITORACT Position */
N#define SCB_SHCSR_MONITORACT_Msk           (1UL << SCB_SHCSR_MONITORACT_Pos)              /*!< SCB SHCSR: MONITORACT Mask */
N
N#define SCB_SHCSR_SVCALLACT_Pos             7                                             /*!< SCB SHCSR: SVCALLACT Position */
N#define SCB_SHCSR_SVCALLACT_Msk            (1UL << SCB_SHCSR_SVCALLACT_Pos)               /*!< SCB SHCSR: SVCALLACT Mask */
N
N#define SCB_SHCSR_USGFAULTACT_Pos           3                                             /*!< SCB SHCSR: USGFAULTACT Position */
N#define SCB_SHCSR_USGFAULTACT_Msk          (1UL << SCB_SHCSR_USGFAULTACT_Pos)             /*!< SCB SHCSR: USGFAULTACT Mask */
N
N#define SCB_SHCSR_BUSFAULTACT_Pos           1                                             /*!< SCB SHCSR: BUSFAULTACT Position */
N#define SCB_SHCSR_BUSFAULTACT_Msk          (1UL << SCB_SHCSR_BUSFAULTACT_Pos)             /*!< SCB SHCSR: BUSFAULTACT Mask */
N
N#define SCB_SHCSR_MEMFAULTACT_Pos           0                                             /*!< SCB SHCSR: MEMFAULTACT Position */
N#define SCB_SHCSR_MEMFAULTACT_Msk          (1UL << SCB_SHCSR_MEMFAULTACT_Pos)             /*!< SCB SHCSR: MEMFAULTACT Mask */
N
N/* SCB Configurable Fault Status Registers Definitions */
N#define SCB_CFSR_USGFAULTSR_Pos            16                                             /*!< SCB CFSR: Usage Fault Status Register Position */
N#define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos)          /*!< SCB CFSR: Usage Fault Status Register Mask */
N
N#define SCB_CFSR_BUSFAULTSR_Pos             8                                             /*!< SCB CFSR: Bus Fault Status Register Position */
N#define SCB_CFSR_BUSFAULTSR_Msk            (0xFFUL << SCB_CFSR_BUSFAULTSR_Pos)            /*!< SCB CFSR: Bus Fault Status Register Mask */
N
N#define SCB_CFSR_MEMFAULTSR_Pos             0                                             /*!< SCB CFSR: Memory Manage Fault Status Register Position */
N#define SCB_CFSR_MEMFAULTSR_Msk            (0xFFUL << SCB_CFSR_MEMFAULTSR_Pos)            /*!< SCB CFSR: Memory Manage Fault Status Register Mask */
N
N/* SCB Hard Fault Status Registers Definitions */
N#define SCB_HFSR_DEBUGEVT_Pos              31                                             /*!< SCB HFSR: DEBUGEVT Position */
N#define SCB_HFSR_DEBUGEVT_Msk              (1UL << SCB_HFSR_DEBUGEVT_Pos)                 /*!< SCB HFSR: DEBUGEVT Mask */
N
N#define SCB_HFSR_FORCED_Pos                30                                             /*!< SCB HFSR: FORCED Position */
N#define SCB_HFSR_FORCED_Msk                (1UL << SCB_HFSR_FORCED_Pos)                   /*!< SCB HFSR: FORCED Mask */
N
N#define SCB_HFSR_VECTTBL_Pos                1                                             /*!< SCB HFSR: VECTTBL Position */
N#define SCB_HFSR_VECTTBL_Msk               (1UL << SCB_HFSR_VECTTBL_Pos)                  /*!< SCB HFSR: VECTTBL Mask */
N
N/* SCB Debug Fault Status Register Definitions */
N#define SCB_DFSR_EXTERNAL_Pos               4                                             /*!< SCB DFSR: EXTERNAL Position */
N#define SCB_DFSR_EXTERNAL_Msk              (1UL << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB DFSR: EXTERNAL Mask */
N
N#define SCB_DFSR_VCATCH_Pos                 3                                             /*!< SCB DFSR: VCATCH Position */
N#define SCB_DFSR_VCATCH_Msk                (1UL << SCB_DFSR_VCATCH_Pos)                   /*!< SCB DFSR: VCATCH Mask */
N
N#define SCB_DFSR_DWTTRAP_Pos                2                                             /*!< SCB DFSR: DWTTRAP Position */
N#define SCB_DFSR_DWTTRAP_Msk               (1UL << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB DFSR: DWTTRAP Mask */
N
N#define SCB_DFSR_BKPT_Pos                   1                                             /*!< SCB DFSR: BKPT Position */
N#define SCB_DFSR_BKPT_Msk                  (1UL << SCB_DFSR_BKPT_Pos)                     /*!< SCB DFSR: BKPT Mask */
N
N#define SCB_DFSR_HALTED_Pos                 0                                             /*!< SCB DFSR: HALTED Position */
N#define SCB_DFSR_HALTED_Msk                (1UL << SCB_DFSR_HALTED_Pos)                   /*!< SCB DFSR: HALTED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SCnSCB System Controls not in SCB (SCnSCB)
N    \brief      Type definitions for the System Control and ID Register not in the SCB
N  @{
N */
N
N/** \brief  Structure type to access the System Control and ID Register not in the SCB.
N */
Ntypedef struct
N{
N       uint32_t RESERVED0[1];
N  __I  uint32_t ICTR;                    /*!< Offset: 0x004 (R/ )  Interrupt Controller Type Register      */
X  volatile const  uint32_t ICTR;                     
N#if ((defined __CM3_REV) && (__CM3_REV >= 0x200))
X#if ((0L) && (__CM3_REV >= 0x200))
S  __IO uint32_t ACTLR;                   /*!< Offset: 0x008 (R/W)  Auxiliary Control Register      */
N#else
N       uint32_t RESERVED1[1];
N#endif
N} SCnSCB_Type;
N
N/* Interrupt Controller Type Register Definitions */
N#define SCnSCB_ICTR_INTLINESNUM_Pos         0                                          /*!< ICTR: INTLINESNUM Position */
N#define SCnSCB_ICTR_INTLINESNUM_Msk        (0xFUL << SCnSCB_ICTR_INTLINESNUM_Pos)      /*!< ICTR: INTLINESNUM Mask */
N
N/* Auxiliary Control Register Definitions */
N
N#define SCnSCB_ACTLR_DISFOLD_Pos            2                                          /*!< ACTLR: DISFOLD Position */
N#define SCnSCB_ACTLR_DISFOLD_Msk           (1UL << SCnSCB_ACTLR_DISFOLD_Pos)           /*!< ACTLR: DISFOLD Mask */
N
N#define SCnSCB_ACTLR_DISDEFWBUF_Pos         1                                          /*!< ACTLR: DISDEFWBUF Position */
N#define SCnSCB_ACTLR_DISDEFWBUF_Msk        (1UL << SCnSCB_ACTLR_DISDEFWBUF_Pos)        /*!< ACTLR: DISDEFWBUF Mask */
N
N#define SCnSCB_ACTLR_DISMCYCINT_Pos         0                                          /*!< ACTLR: DISMCYCINT Position */
N#define SCnSCB_ACTLR_DISMCYCINT_Msk        (1UL << SCnSCB_ACTLR_DISMCYCINT_Pos)        /*!< ACTLR: DISMCYCINT Mask */
N
N/*@} end of group CMSIS_SCnotSCB */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N    \brief      Type definitions for the System Timer Registers.
N  @{
N */
N
N/** \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                     
N  __IO uint32_t LOAD;                    /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register       */
X  volatile uint32_t LOAD;                     
N  __IO uint32_t VAL;                     /*!< Offset: 0x008 (R/W)  SysTick Current Value Register      */
X  volatile uint32_t VAL;                      
N  __I  uint32_t CALIB;                   /*!< Offset: 0x00C (R/ )  SysTick Calibration Register        */
X  volatile const  uint32_t CALIB;                    
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL << SysTick_CTRL_ENABLE_Pos)               /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL << SysTick_LOAD_RELOAD_Pos)        /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_ITM     Instrumentation Trace Macrocell (ITM)
N    \brief      Type definitions for the Instrumentation Trace Macrocell (ITM)
N  @{
N */
N
N/** \brief  Structure type to access the Instrumentation Trace Macrocell Register (ITM).
N */
Ntypedef struct
N{
N  __O  union
X  volatile  union
N  {
N    __O  uint8_t    u8;                  /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 8-bit                   */
X    volatile  uint8_t    u8;                   
N    __O  uint16_t   u16;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 16-bit                  */
X    volatile  uint16_t   u16;                  
N    __O  uint32_t   u32;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 32-bit                  */
X    volatile  uint32_t   u32;                  
N  }  PORT [32];                          /*!< Offset: 0x000 ( /W)  ITM Stimulus Port Registers               */
N       uint32_t RESERVED0[864];
N  __IO uint32_t TER;                     /*!< Offset: 0xE00 (R/W)  ITM Trace Enable Register                 */
X  volatile uint32_t TER;                      
N       uint32_t RESERVED1[15];
N  __IO uint32_t TPR;                     /*!< Offset: 0xE40 (R/W)  ITM Trace Privilege Register              */
X  volatile uint32_t TPR;                      
N       uint32_t RESERVED2[15];
N  __IO uint32_t TCR;                     /*!< Offset: 0xE80 (R/W)  ITM Trace Control Register                */
X  volatile uint32_t TCR;                      
N       uint32_t RESERVED3[29];
N  __O  uint32_t IWR;                     /*!< Offset: 0xEF8 ( /W)  ITM Integration Write Register            */
X  volatile  uint32_t IWR;                      
N  __I  uint32_t IRR;                     /*!< Offset: 0xEFC (R/ )  ITM Integration Read Register             */
X  volatile const  uint32_t IRR;                      
N  __IO uint32_t IMCR;                    /*!< Offset: 0xF00 (R/W)  ITM Integration Mode Control Register     */
X  volatile uint32_t IMCR;                     
N       uint32_t RESERVED4[43];
N  __O  uint32_t LAR;                     /*!< Offset: 0xFB0 ( /W)  ITM Lock Access Register                  */
X  volatile  uint32_t LAR;                      
N  __I  uint32_t LSR;                     /*!< Offset: 0xFB4 (R/ )  ITM Lock Status Register                  */
X  volatile const  uint32_t LSR;                      
N       uint32_t RESERVED5[6];
N  __I  uint32_t PID4;                    /*!< Offset: 0xFD0 (R/ )  ITM Peripheral Identification Register #4 */
X  volatile const  uint32_t PID4;                     
N  __I  uint32_t PID5;                    /*!< Offset: 0xFD4 (R/ )  ITM Peripheral Identification Register #5 */
X  volatile const  uint32_t PID5;                     
N  __I  uint32_t PID6;                    /*!< Offset: 0xFD8 (R/ )  ITM Peripheral Identification Register #6 */
X  volatile const  uint32_t PID6;                     
N  __I  uint32_t PID7;                    /*!< Offset: 0xFDC (R/ )  ITM Peripheral Identification Register #7 */
X  volatile const  uint32_t PID7;                     
N  __I  uint32_t PID0;                    /*!< Offset: 0xFE0 (R/ )  ITM Peripheral Identification Register #0 */
X  volatile const  uint32_t PID0;                     
N  __I  uint32_t PID1;                    /*!< Offset: 0xFE4 (R/ )  ITM Peripheral Identification Register #1 */
X  volatile const  uint32_t PID1;                     
N  __I  uint32_t PID2;                    /*!< Offset: 0xFE8 (R/ )  ITM Peripheral Identification Register #2 */
X  volatile const  uint32_t PID2;                     
N  __I  uint32_t PID3;                    /*!< Offset: 0xFEC (R/ )  ITM Peripheral Identification Register #3 */
X  volatile const  uint32_t PID3;                     
N  __I  uint32_t CID0;                    /*!< Offset: 0xFF0 (R/ )  ITM Component  Identification Register #0 */
X  volatile const  uint32_t CID0;                     
N  __I  uint32_t CID1;                    /*!< Offset: 0xFF4 (R/ )  ITM Component  Identification Register #1 */
X  volatile const  uint32_t CID1;                     
N  __I  uint32_t CID2;                    /*!< Offset: 0xFF8 (R/ )  ITM Component  Identification Register #2 */
X  volatile const  uint32_t CID2;                     
N  __I  uint32_t CID3;                    /*!< Offset: 0xFFC (R/ )  ITM Component  Identification Register #3 */
X  volatile const  uint32_t CID3;                     
N} ITM_Type;
N
N/* ITM Trace Privilege Register Definitions */
N#define ITM_TPR_PRIVMASK_Pos                0                                             /*!< ITM TPR: PRIVMASK Position */
N#define ITM_TPR_PRIVMASK_Msk               (0xFUL << ITM_TPR_PRIVMASK_Pos)                /*!< ITM TPR: PRIVMASK Mask */
N
N/* ITM Trace Control Register Definitions */
N#define ITM_TCR_BUSY_Pos                   23                                             /*!< ITM TCR: BUSY Position */
N#define ITM_TCR_BUSY_Msk                   (1UL << ITM_TCR_BUSY_Pos)                      /*!< ITM TCR: BUSY Mask */
N
N#define ITM_TCR_TraceBusID_Pos             16                                             /*!< ITM TCR: ATBID Position */
N#define ITM_TCR_TraceBusID_Msk             (0x7FUL << ITM_TCR_TraceBusID_Pos)             /*!< ITM TCR: ATBID Mask */
N
N#define ITM_TCR_GTSFREQ_Pos                10                                             /*!< ITM TCR: Global timestamp frequency Position */
N#define ITM_TCR_GTSFREQ_Msk                (3UL << ITM_TCR_GTSFREQ_Pos)                   /*!< ITM TCR: Global timestamp frequency Mask */
N
N#define ITM_TCR_TSPrescale_Pos              8                                             /*!< ITM TCR: TSPrescale Position */
N#define ITM_TCR_TSPrescale_Msk             (3UL << ITM_TCR_TSPrescale_Pos)                /*!< ITM TCR: TSPrescale Mask */
N
N#define ITM_TCR_SWOENA_Pos                  4                                             /*!< ITM TCR: SWOENA Position */
N#define ITM_TCR_SWOENA_Msk                 (1UL << ITM_TCR_SWOENA_Pos)                    /*!< ITM TCR: SWOENA Mask */
N
N#define ITM_TCR_DWTENA_Pos                  3                                             /*!< ITM TCR: DWTENA Position */
N#define ITM_TCR_DWTENA_Msk                 (1UL << ITM_TCR_DWTENA_Pos)                    /*!< ITM TCR: DWTENA Mask */
N
N#define ITM_TCR_SYNCENA_Pos                 2                                             /*!< ITM TCR: SYNCENA Position */
N#define ITM_TCR_SYNCENA_Msk                (1UL << ITM_TCR_SYNCENA_Pos)                   /*!< ITM TCR: SYNCENA Mask */
N
N#define ITM_TCR_TSENA_Pos                   1                                             /*!< ITM TCR: TSENA Position */
N#define ITM_TCR_TSENA_Msk                  (1UL << ITM_TCR_TSENA_Pos)                     /*!< ITM TCR: TSENA Mask */
N
N#define ITM_TCR_ITMENA_Pos                  0                                             /*!< ITM TCR: ITM Enable bit Position */
N#define ITM_TCR_ITMENA_Msk                 (1UL << ITM_TCR_ITMENA_Pos)                    /*!< ITM TCR: ITM Enable bit Mask */
N
N/* ITM Integration Write Register Definitions */
N#define ITM_IWR_ATVALIDM_Pos                0                                             /*!< ITM IWR: ATVALIDM Position */
N#define ITM_IWR_ATVALIDM_Msk               (1UL << ITM_IWR_ATVALIDM_Pos)                  /*!< ITM IWR: ATVALIDM Mask */
N
N/* ITM Integration Read Register Definitions */
N#define ITM_IRR_ATREADYM_Pos                0                                             /*!< ITM IRR: ATREADYM Position */
N#define ITM_IRR_ATREADYM_Msk               (1UL << ITM_IRR_ATREADYM_Pos)                  /*!< ITM IRR: ATREADYM Mask */
N
N/* ITM Integration Mode Control Register Definitions */
N#define ITM_IMCR_INTEGRATION_Pos            0                                             /*!< ITM IMCR: INTEGRATION Position */
N#define ITM_IMCR_INTEGRATION_Msk           (1UL << ITM_IMCR_INTEGRATION_Pos)              /*!< ITM IMCR: INTEGRATION Mask */
N
N/* ITM Lock Status Register Definitions */
N#define ITM_LSR_ByteAcc_Pos                 2                                             /*!< ITM LSR: ByteAcc Position */
N#define ITM_LSR_ByteAcc_Msk                (1UL << ITM_LSR_ByteAcc_Pos)                   /*!< ITM LSR: ByteAcc Mask */
N
N#define ITM_LSR_Access_Pos                  1                                             /*!< ITM LSR: Access Position */
N#define ITM_LSR_Access_Msk                 (1UL << ITM_LSR_Access_Pos)                    /*!< ITM LSR: Access Mask */
N
N#define ITM_LSR_Present_Pos                 0                                             /*!< ITM LSR: Present Position */
N#define ITM_LSR_Present_Msk                (1UL << ITM_LSR_Present_Pos)                   /*!< ITM LSR: Present Mask */
N
N/*@}*/ /* end of group CMSIS_ITM */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_DWT     Data Watchpoint and Trace (DWT)
N    \brief      Type definitions for the Data Watchpoint and Trace (DWT)
N  @{
N */
N
N/** \brief  Structure type to access the Data Watchpoint and Trace Register (DWT).
N */
Ntypedef struct
N{
N  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  Control Register                          */
X  volatile uint32_t CTRL;                     
N  __IO uint32_t CYCCNT;                  /*!< Offset: 0x004 (R/W)  Cycle Count Register                      */
X  volatile uint32_t CYCCNT;                   
N  __IO uint32_t CPICNT;                  /*!< Offset: 0x008 (R/W)  CPI Count Register                        */
X  volatile uint32_t CPICNT;                   
N  __IO uint32_t EXCCNT;                  /*!< Offset: 0x00C (R/W)  Exception Overhead Count Register         */
X  volatile uint32_t EXCCNT;                   
N  __IO uint32_t SLEEPCNT;                /*!< Offset: 0x010 (R/W)  Sleep Count Register                      */
X  volatile uint32_t SLEEPCNT;                 
N  __IO uint32_t LSUCNT;                  /*!< Offset: 0x014 (R/W)  LSU Count Register                        */
X  volatile uint32_t LSUCNT;                   
N  __IO uint32_t FOLDCNT;                 /*!< Offset: 0x018 (R/W)  Folded-instruction Count Register         */
X  volatile uint32_t FOLDCNT;                  
N  __I  uint32_t PCSR;                    /*!< Offset: 0x01C (R/ )  Program Counter Sample Register           */
X  volatile const  uint32_t PCSR;                     
N  __IO uint32_t COMP0;                   /*!< Offset: 0x020 (R/W)  Comparator Register 0                     */
X  volatile uint32_t COMP0;                    
N  __IO uint32_t MASK0;                   /*!< Offset: 0x024 (R/W)  Mask Register 0                           */
X  volatile uint32_t MASK0;                    
N  __IO uint32_t FUNCTION0;               /*!< Offset: 0x028 (R/W)  Function Register 0                       */
X  volatile uint32_t FUNCTION0;                
N       uint32_t RESERVED0[1];
N  __IO uint32_t COMP1;                   /*!< Offset: 0x030 (R/W)  Comparator Register 1                     */
X  volatile uint32_t COMP1;                    
N  __IO uint32_t MASK1;                   /*!< Offset: 0x034 (R/W)  Mask Register 1                           */
X  volatile uint32_t MASK1;                    
N  __IO uint32_t FUNCTION1;               /*!< Offset: 0x038 (R/W)  Function Register 1                       */
X  volatile uint32_t FUNCTION1;                
N       uint32_t RESERVED1[1];
N  __IO uint32_t COMP2;                   /*!< Offset: 0x040 (R/W)  Comparator Register 2                     */
X  volatile uint32_t COMP2;                    
N  __IO uint32_t MASK2;                   /*!< Offset: 0x044 (R/W)  Mask Register 2                           */
X  volatile uint32_t MASK2;                    
N  __IO uint32_t FUNCTION2;               /*!< Offset: 0x048 (R/W)  Function Register 2                       */
X  volatile uint32_t FUNCTION2;                
N       uint32_t RESERVED2[1];
N  __IO uint32_t COMP3;                   /*!< Offset: 0x050 (R/W)  Comparator Register 3                     */
X  volatile uint32_t COMP3;                    
N  __IO uint32_t MASK3;                   /*!< Offset: 0x054 (R/W)  Mask Register 3                           */
X  volatile uint32_t MASK3;                    
N  __IO uint32_t FUNCTION3;               /*!< Offset: 0x058 (R/W)  Function Register 3                       */
X  volatile uint32_t FUNCTION3;                
N} DWT_Type;
N
N/* DWT Control Register Definitions */
N#define DWT_CTRL_NUMCOMP_Pos               28                                          /*!< DWT CTRL: NUMCOMP Position */
N#define DWT_CTRL_NUMCOMP_Msk               (0xFUL << DWT_CTRL_NUMCOMP_Pos)             /*!< DWT CTRL: NUMCOMP Mask */
N
N#define DWT_CTRL_NOTRCPKT_Pos              27                                          /*!< DWT CTRL: NOTRCPKT Position */
N#define DWT_CTRL_NOTRCPKT_Msk              (0x1UL << DWT_CTRL_NOTRCPKT_Pos)            /*!< DWT CTRL: NOTRCPKT Mask */
N
N#define DWT_CTRL_NOEXTTRIG_Pos             26                                          /*!< DWT CTRL: NOEXTTRIG Position */
N#define DWT_CTRL_NOEXTTRIG_Msk             (0x1UL << DWT_CTRL_NOEXTTRIG_Pos)           /*!< DWT CTRL: NOEXTTRIG Mask */
N
N#define DWT_CTRL_NOCYCCNT_Pos              25                                          /*!< DWT CTRL: NOCYCCNT Position */
N#define DWT_CTRL_NOCYCCNT_Msk              (0x1UL << DWT_CTRL_NOCYCCNT_Pos)            /*!< DWT CTRL: NOCYCCNT Mask */
N
N#define DWT_CTRL_NOPRFCNT_Pos              24                                          /*!< DWT CTRL: NOPRFCNT Position */
N#define DWT_CTRL_NOPRFCNT_Msk              (0x1UL << DWT_CTRL_NOPRFCNT_Pos)            /*!< DWT CTRL: NOPRFCNT Mask */
N
N#define DWT_CTRL_CYCEVTENA_Pos             22                                          /*!< DWT CTRL: CYCEVTENA Position */
N#define DWT_CTRL_CYCEVTENA_Msk             (0x1UL << DWT_CTRL_CYCEVTENA_Pos)           /*!< DWT CTRL: CYCEVTENA Mask */
N
N#define DWT_CTRL_FOLDEVTENA_Pos            21                                          /*!< DWT CTRL: FOLDEVTENA Position */
N#define DWT_CTRL_FOLDEVTENA_Msk            (0x1UL << DWT_CTRL_FOLDEVTENA_Pos)          /*!< DWT CTRL: FOLDEVTENA Mask */
N
N#define DWT_CTRL_LSUEVTENA_Pos             20                                          /*!< DWT CTRL: LSUEVTENA Position */
N#define DWT_CTRL_LSUEVTENA_Msk             (0x1UL << DWT_CTRL_LSUEVTENA_Pos)           /*!< DWT CTRL: LSUEVTENA Mask */
N
N#define DWT_CTRL_SLEEPEVTENA_Pos           19                                          /*!< DWT CTRL: SLEEPEVTENA Position */
N#define DWT_CTRL_SLEEPEVTENA_Msk           (0x1UL << DWT_CTRL_SLEEPEVTENA_Pos)         /*!< DWT CTRL: SLEEPEVTENA Mask */
N
N#define DWT_CTRL_EXCEVTENA_Pos             18                                          /*!< DWT CTRL: EXCEVTENA Position */
N#define DWT_CTRL_EXCEVTENA_Msk             (0x1UL << DWT_CTRL_EXCEVTENA_Pos)           /*!< DWT CTRL: EXCEVTENA Mask */
N
N#define DWT_CTRL_CPIEVTENA_Pos             17                                          /*!< DWT CTRL: CPIEVTENA Position */
N#define DWT_CTRL_CPIEVTENA_Msk             (0x1UL << DWT_CTRL_CPIEVTENA_Pos)           /*!< DWT CTRL: CPIEVTENA Mask */
N
N#define DWT_CTRL_EXCTRCENA_Pos             16                                          /*!< DWT CTRL: EXCTRCENA Position */
N#define DWT_CTRL_EXCTRCENA_Msk             (0x1UL << DWT_CTRL_EXCTRCENA_Pos)           /*!< DWT CTRL: EXCTRCENA Mask */
N
N#define DWT_CTRL_PCSAMPLENA_Pos            12                                          /*!< DWT CTRL: PCSAMPLENA Position */
N#define DWT_CTRL_PCSAMPLENA_Msk            (0x1UL << DWT_CTRL_PCSAMPLENA_Pos)          /*!< DWT CTRL: PCSAMPLENA Mask */
N
N#define DWT_CTRL_SYNCTAP_Pos               10                                          /*!< DWT CTRL: SYNCTAP Position */
N#define DWT_CTRL_SYNCTAP_Msk               (0x3UL << DWT_CTRL_SYNCTAP_Pos)             /*!< DWT CTRL: SYNCTAP Mask */
N
N#define DWT_CTRL_CYCTAP_Pos                 9                                          /*!< DWT CTRL: CYCTAP Position */
N#define DWT_CTRL_CYCTAP_Msk                (0x1UL << DWT_CTRL_CYCTAP_Pos)              /*!< DWT CTRL: CYCTAP Mask */
N
N#define DWT_CTRL_POSTINIT_Pos               5                                          /*!< DWT CTRL: POSTINIT Position */
N#define DWT_CTRL_POSTINIT_Msk              (0xFUL << DWT_CTRL_POSTINIT_Pos)            /*!< DWT CTRL: POSTINIT Mask */
N
N#define DWT_CTRL_POSTPRESET_Pos             1                                          /*!< DWT CTRL: POSTPRESET Position */
N#define DWT_CTRL_POSTPRESET_Msk            (0xFUL << DWT_CTRL_POSTPRESET_Pos)          /*!< DWT CTRL: POSTPRESET Mask */
N
N#define DWT_CTRL_CYCCNTENA_Pos              0                                          /*!< DWT CTRL: CYCCNTENA Position */
N#define DWT_CTRL_CYCCNTENA_Msk             (0x1UL << DWT_CTRL_CYCCNTENA_Pos)           /*!< DWT CTRL: CYCCNTENA Mask */
N
N/* DWT CPI Count Register Definitions */
N#define DWT_CPICNT_CPICNT_Pos               0                                          /*!< DWT CPICNT: CPICNT Position */
N#define DWT_CPICNT_CPICNT_Msk              (0xFFUL << DWT_CPICNT_CPICNT_Pos)           /*!< DWT CPICNT: CPICNT Mask */
N
N/* DWT Exception Overhead Count Register Definitions */
N#define DWT_EXCCNT_EXCCNT_Pos               0                                          /*!< DWT EXCCNT: EXCCNT Position */
N#define DWT_EXCCNT_EXCCNT_Msk              (0xFFUL << DWT_EXCCNT_EXCCNT_Pos)           /*!< DWT EXCCNT: EXCCNT Mask */
N
N/* DWT Sleep Count Register Definitions */
N#define DWT_SLEEPCNT_SLEEPCNT_Pos           0                                          /*!< DWT SLEEPCNT: SLEEPCNT Position */
N#define DWT_SLEEPCNT_SLEEPCNT_Msk          (0xFFUL << DWT_SLEEPCNT_SLEEPCNT_Pos)       /*!< DWT SLEEPCNT: SLEEPCNT Mask */
N
N/* DWT LSU Count Register Definitions */
N#define DWT_LSUCNT_LSUCNT_Pos               0                                          /*!< DWT LSUCNT: LSUCNT Position */
N#define DWT_LSUCNT_LSUCNT_Msk              (0xFFUL << DWT_LSUCNT_LSUCNT_Pos)           /*!< DWT LSUCNT: LSUCNT Mask */
N
N/* DWT Folded-instruction Count Register Definitions */
N#define DWT_FOLDCNT_FOLDCNT_Pos             0                                          /*!< DWT FOLDCNT: FOLDCNT Position */
N#define DWT_FOLDCNT_FOLDCNT_Msk            (0xFFUL << DWT_FOLDCNT_FOLDCNT_Pos)         /*!< DWT FOLDCNT: FOLDCNT Mask */
N
N/* DWT Comparator Mask Register Definitions */
N#define DWT_MASK_MASK_Pos                   0                                          /*!< DWT MASK: MASK Position */
N#define DWT_MASK_MASK_Msk                  (0x1FUL << DWT_MASK_MASK_Pos)               /*!< DWT MASK: MASK Mask */
N
N/* DWT Comparator Function Register Definitions */
N#define DWT_FUNCTION_MATCHED_Pos           24                                          /*!< DWT FUNCTION: MATCHED Position */
N#define DWT_FUNCTION_MATCHED_Msk           (0x1UL << DWT_FUNCTION_MATCHED_Pos)         /*!< DWT FUNCTION: MATCHED Mask */
N
N#define DWT_FUNCTION_DATAVADDR1_Pos        16                                          /*!< DWT FUNCTION: DATAVADDR1 Position */
N#define DWT_FUNCTION_DATAVADDR1_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR1_Pos)      /*!< DWT FUNCTION: DATAVADDR1 Mask */
N
N#define DWT_FUNCTION_DATAVADDR0_Pos        12                                          /*!< DWT FUNCTION: DATAVADDR0 Position */
N#define DWT_FUNCTION_DATAVADDR0_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR0_Pos)      /*!< DWT FUNCTION: DATAVADDR0 Mask */
N
N#define DWT_FUNCTION_DATAVSIZE_Pos         10                                          /*!< DWT FUNCTION: DATAVSIZE Position */
N#define DWT_FUNCTION_DATAVSIZE_Msk         (0x3UL << DWT_FUNCTION_DATAVSIZE_Pos)       /*!< DWT FUNCTION: DATAVSIZE Mask */
N
N#define DWT_FUNCTION_LNK1ENA_Pos            9                                          /*!< DWT FUNCTION: LNK1ENA Position */
N#define DWT_FUNCTION_LNK1ENA_Msk           (0x1UL << DWT_FUNCTION_LNK1ENA_Pos)         /*!< DWT FUNCTION: LNK1ENA Mask */
N
N#define DWT_FUNCTION_DATAVMATCH_Pos         8                                          /*!< DWT FUNCTION: DATAVMATCH Position */
N#define DWT_FUNCTION_DATAVMATCH_Msk        (0x1UL << DWT_FUNCTION_DATAVMATCH_Pos)      /*!< DWT FUNCTION: DATAVMATCH Mask */
N
N#define DWT_FUNCTION_CYCMATCH_Pos           7                                          /*!< DWT FUNCTION: CYCMATCH Position */
N#define DWT_FUNCTION_CYCMATCH_Msk          (0x1UL << DWT_FUNCTION_CYCMATCH_Pos)        /*!< DWT FUNCTION: CYCMATCH Mask */
N
N#define DWT_FUNCTION_EMITRANGE_Pos          5                                          /*!< DWT FUNCTION: EMITRANGE Position */
N#define DWT_FUNCTION_EMITRANGE_Msk         (0x1UL << DWT_FUNCTION_EMITRANGE_Pos)       /*!< DWT FUNCTION: EMITRANGE Mask */
N
N#define DWT_FUNCTION_FUNCTION_Pos           0                                          /*!< DWT FUNCTION: FUNCTION Position */
N#define DWT_FUNCTION_FUNCTION_Msk          (0xFUL << DWT_FUNCTION_FUNCTION_Pos)        /*!< DWT FUNCTION: FUNCTION Mask */
N
N/*@}*/ /* end of group CMSIS_DWT */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_TPI     Trace Port Interface (TPI)
N    \brief      Type definitions for the Trace Port Interface (TPI)
N  @{
N */
N
N/** \brief  Structure type to access the Trace Port Interface Register (TPI).
N */
Ntypedef struct
N{
N  __IO uint32_t SSPSR;                   /*!< Offset: 0x000 (R/ )  Supported Parallel Port Size Register     */
X  volatile uint32_t SSPSR;                    
N  __IO uint32_t CSPSR;                   /*!< Offset: 0x004 (R/W)  Current Parallel Port Size Register */
X  volatile uint32_t CSPSR;                    
N       uint32_t RESERVED0[2];
N  __IO uint32_t ACPR;                    /*!< Offset: 0x010 (R/W)  Asynchronous Clock Prescaler Register */
X  volatile uint32_t ACPR;                     
N       uint32_t RESERVED1[55];
N  __IO uint32_t SPPR;                    /*!< Offset: 0x0F0 (R/W)  Selected Pin Protocol Register */
X  volatile uint32_t SPPR;                     
N       uint32_t RESERVED2[131];
N  __I  uint32_t FFSR;                    /*!< Offset: 0x300 (R/ )  Formatter and Flush Status Register */
X  volatile const  uint32_t FFSR;                     
N  __IO uint32_t FFCR;                    /*!< Offset: 0x304 (R/W)  Formatter and Flush Control Register */
X  volatile uint32_t FFCR;                     
N  __I  uint32_t FSCR;                    /*!< Offset: 0x308 (R/ )  Formatter Synchronization Counter Register */
X  volatile const  uint32_t FSCR;                     
N       uint32_t RESERVED3[759];
N  __I  uint32_t TRIGGER;                 /*!< Offset: 0xEE8 (R/ )  TRIGGER */
X  volatile const  uint32_t TRIGGER;                  
N  __I  uint32_t FIFO0;                   /*!< Offset: 0xEEC (R/ )  Integration ETM Data */
X  volatile const  uint32_t FIFO0;                    
N  __I  uint32_t ITATBCTR2;               /*!< Offset: 0xEF0 (R/ )  ITATBCTR2 */
X  volatile const  uint32_t ITATBCTR2;                
N       uint32_t RESERVED4[1];
N  __I  uint32_t ITATBCTR0;               /*!< Offset: 0xEF8 (R/ )  ITATBCTR0 */
X  volatile const  uint32_t ITATBCTR0;                
N  __I  uint32_t FIFO1;                   /*!< Offset: 0xEFC (R/ )  Integration ITM Data */
X  volatile const  uint32_t FIFO1;                    
N  __IO uint32_t ITCTRL;                  /*!< Offset: 0xF00 (R/W)  Integration Mode Control */
X  volatile uint32_t ITCTRL;                   
N       uint32_t RESERVED5[39];
N  __IO uint32_t CLAIMSET;                /*!< Offset: 0xFA0 (R/W)  Claim tag set */
X  volatile uint32_t CLAIMSET;                 
N  __IO uint32_t CLAIMCLR;                /*!< Offset: 0xFA4 (R/W)  Claim tag clear */
X  volatile uint32_t CLAIMCLR;                 
N       uint32_t RESERVED7[8];
N  __I  uint32_t DEVID;                   /*!< Offset: 0xFC8 (R/ )  TPIU_DEVID */
X  volatile const  uint32_t DEVID;                    
N  __I  uint32_t DEVTYPE;                 /*!< Offset: 0xFCC (R/ )  TPIU_DEVTYPE */
X  volatile const  uint32_t DEVTYPE;                  
N} TPI_Type;
N
N/* TPI Asynchronous Clock Prescaler Register Definitions */
N#define TPI_ACPR_PRESCALER_Pos              0                                          /*!< TPI ACPR: PRESCALER Position */
N#define TPI_ACPR_PRESCALER_Msk             (0x1FFFUL << TPI_ACPR_PRESCALER_Pos)        /*!< TPI ACPR: PRESCALER Mask */
N
N/* TPI Selected Pin Protocol Register Definitions */
N#define TPI_SPPR_TXMODE_Pos                 0                                          /*!< TPI SPPR: TXMODE Position */
N#define TPI_SPPR_TXMODE_Msk                (0x3UL << TPI_SPPR_TXMODE_Pos)              /*!< TPI SPPR: TXMODE Mask */
N
N/* TPI Formatter and Flush Status Register Definitions */
N#define TPI_FFSR_FtNonStop_Pos              3                                          /*!< TPI FFSR: FtNonStop Position */
N#define TPI_FFSR_FtNonStop_Msk             (0x1UL << TPI_FFSR_FtNonStop_Pos)           /*!< TPI FFSR: FtNonStop Mask */
N
N#define TPI_FFSR_TCPresent_Pos              2                                          /*!< TPI FFSR: TCPresent Position */
N#define TPI_FFSR_TCPresent_Msk             (0x1UL << TPI_FFSR_TCPresent_Pos)           /*!< TPI FFSR: TCPresent Mask */
N
N#define TPI_FFSR_FtStopped_Pos              1                                          /*!< TPI FFSR: FtStopped Position */
N#define TPI_FFSR_FtStopped_Msk             (0x1UL << TPI_FFSR_FtStopped_Pos)           /*!< TPI FFSR: FtStopped Mask */
N
N#define TPI_FFSR_FlInProg_Pos               0                                          /*!< TPI FFSR: FlInProg Position */
N#define TPI_FFSR_FlInProg_Msk              (0x1UL << TPI_FFSR_FlInProg_Pos)            /*!< TPI FFSR: FlInProg Mask */
N
N/* TPI Formatter and Flush Control Register Definitions */
N#define TPI_FFCR_TrigIn_Pos                 8                                          /*!< TPI FFCR: TrigIn Position */
N#define TPI_FFCR_TrigIn_Msk                (0x1UL << TPI_FFCR_TrigIn_Pos)              /*!< TPI FFCR: TrigIn Mask */
N
N#define TPI_FFCR_EnFCont_Pos                1                                          /*!< TPI FFCR: EnFCont Position */
N#define TPI_FFCR_EnFCont_Msk               (0x1UL << TPI_FFCR_EnFCont_Pos)             /*!< TPI FFCR: EnFCont Mask */
N
N/* TPI TRIGGER Register Definitions */
N#define TPI_TRIGGER_TRIGGER_Pos             0                                          /*!< TPI TRIGGER: TRIGGER Position */
N#define TPI_TRIGGER_TRIGGER_Msk            (0x1UL << TPI_TRIGGER_TRIGGER_Pos)          /*!< TPI TRIGGER: TRIGGER Mask */
N
N/* TPI Integration ETM Data Register Definitions (FIFO0) */
N#define TPI_FIFO0_ITM_ATVALID_Pos          29                                          /*!< TPI FIFO0: ITM_ATVALID Position */
N#define TPI_FIFO0_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ITM_ATVALID_Pos)        /*!< TPI FIFO0: ITM_ATVALID Mask */
N
N#define TPI_FIFO0_ITM_bytecount_Pos        27                                          /*!< TPI FIFO0: ITM_bytecount Position */
N#define TPI_FIFO0_ITM_bytecount_Msk        (0x3UL << TPI_FIFO0_ITM_bytecount_Pos)      /*!< TPI FIFO0: ITM_bytecount Mask */
N
N#define TPI_FIFO0_ETM_ATVALID_Pos          26                                          /*!< TPI FIFO0: ETM_ATVALID Position */
N#define TPI_FIFO0_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ETM_ATVALID_Pos)        /*!< TPI FIFO0: ETM_ATVALID Mask */
N
N#define TPI_FIFO0_ETM_bytecount_Pos        24                                          /*!< TPI FIFO0: ETM_bytecount Position */
N#define TPI_FIFO0_ETM_bytecount_Msk        (0x3UL << TPI_FIFO0_ETM_bytecount_Pos)      /*!< TPI FIFO0: ETM_bytecount Mask */
N
N#define TPI_FIFO0_ETM2_Pos                 16                                          /*!< TPI FIFO0: ETM2 Position */
N#define TPI_FIFO0_ETM2_Msk                 (0xFFUL << TPI_FIFO0_ETM2_Pos)              /*!< TPI FIFO0: ETM2 Mask */
N
N#define TPI_FIFO0_ETM1_Pos                  8                                          /*!< TPI FIFO0: ETM1 Position */
N#define TPI_FIFO0_ETM1_Msk                 (0xFFUL << TPI_FIFO0_ETM1_Pos)              /*!< TPI FIFO0: ETM1 Mask */
N
N#define TPI_FIFO0_ETM0_Pos                  0                                          /*!< TPI FIFO0: ETM0 Position */
N#define TPI_FIFO0_ETM0_Msk                 (0xFFUL << TPI_FIFO0_ETM0_Pos)              /*!< TPI FIFO0: ETM0 Mask */
N
N/* TPI ITATBCTR2 Register Definitions */
N#define TPI_ITATBCTR2_ATREADY_Pos           0                                          /*!< TPI ITATBCTR2: ATREADY Position */
N#define TPI_ITATBCTR2_ATREADY_Msk          (0x1UL << TPI_ITATBCTR2_ATREADY_Pos)        /*!< TPI ITATBCTR2: ATREADY Mask */
N
N/* TPI Integration ITM Data Register Definitions (FIFO1) */
N#define TPI_FIFO1_ITM_ATVALID_Pos          29                                          /*!< TPI FIFO1: ITM_ATVALID Position */
N#define TPI_FIFO1_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ITM_ATVALID_Pos)        /*!< TPI FIFO1: ITM_ATVALID Mask */
N
N#define TPI_FIFO1_ITM_bytecount_Pos        27                                          /*!< TPI FIFO1: ITM_bytecount Position */
N#define TPI_FIFO1_ITM_bytecount_Msk        (0x3UL << TPI_FIFO1_ITM_bytecount_Pos)      /*!< TPI FIFO1: ITM_bytecount Mask */
N
N#define TPI_FIFO1_ETM_ATVALID_Pos          26                                          /*!< TPI FIFO1: ETM_ATVALID Position */
N#define TPI_FIFO1_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ETM_ATVALID_Pos)        /*!< TPI FIFO1: ETM_ATVALID Mask */
N
N#define TPI_FIFO1_ETM_bytecount_Pos        24                                          /*!< TPI FIFO1: ETM_bytecount Position */
N#define TPI_FIFO1_ETM_bytecount_Msk        (0x3UL << TPI_FIFO1_ETM_bytecount_Pos)      /*!< TPI FIFO1: ETM_bytecount Mask */
N
N#define TPI_FIFO1_ITM2_Pos                 16                                          /*!< TPI FIFO1: ITM2 Position */
N#define TPI_FIFO1_ITM2_Msk                 (0xFFUL << TPI_FIFO1_ITM2_Pos)              /*!< TPI FIFO1: ITM2 Mask */
N
N#define TPI_FIFO1_ITM1_Pos                  8                                          /*!< TPI FIFO1: ITM1 Position */
N#define TPI_FIFO1_ITM1_Msk                 (0xFFUL << TPI_FIFO1_ITM1_Pos)              /*!< TPI FIFO1: ITM1 Mask */
N
N#define TPI_FIFO1_ITM0_Pos                  0                                          /*!< TPI FIFO1: ITM0 Position */
N#define TPI_FIFO1_ITM0_Msk                 (0xFFUL << TPI_FIFO1_ITM0_Pos)              /*!< TPI FIFO1: ITM0 Mask */
N
N/* TPI ITATBCTR0 Register Definitions */
N#define TPI_ITATBCTR0_ATREADY_Pos           0                                          /*!< TPI ITATBCTR0: ATREADY Position */
N#define TPI_ITATBCTR0_ATREADY_Msk          (0x1UL << TPI_ITATBCTR0_ATREADY_Pos)        /*!< TPI ITATBCTR0: ATREADY Mask */
N
N/* TPI Integration Mode Control Register Definitions */
N#define TPI_ITCTRL_Mode_Pos                 0                                          /*!< TPI ITCTRL: Mode Position */
N#define TPI_ITCTRL_Mode_Msk                (0x1UL << TPI_ITCTRL_Mode_Pos)              /*!< TPI ITCTRL: Mode Mask */
N
N/* TPI DEVID Register Definitions */
N#define TPI_DEVID_NRZVALID_Pos             11                                          /*!< TPI DEVID: NRZVALID Position */
N#define TPI_DEVID_NRZVALID_Msk             (0x1UL << TPI_DEVID_NRZVALID_Pos)           /*!< TPI DEVID: NRZVALID Mask */
N
N#define TPI_DEVID_MANCVALID_Pos            10                                          /*!< TPI DEVID: MANCVALID Position */
N#define TPI_DEVID_MANCVALID_Msk            (0x1UL << TPI_DEVID_MANCVALID_Pos)          /*!< TPI DEVID: MANCVALID Mask */
N
N#define TPI_DEVID_PTINVALID_Pos             9                                          /*!< TPI DEVID: PTINVALID Position */
N#define TPI_DEVID_PTINVALID_Msk            (0x1UL << TPI_DEVID_PTINVALID_Pos)          /*!< TPI DEVID: PTINVALID Mask */
N
N#define TPI_DEVID_MinBufSz_Pos              6                                          /*!< TPI DEVID: MinBufSz Position */
N#define TPI_DEVID_MinBufSz_Msk             (0x7UL << TPI_DEVID_MinBufSz_Pos)           /*!< TPI DEVID: MinBufSz Mask */
N
N#define TPI_DEVID_AsynClkIn_Pos             5                                          /*!< TPI DEVID: AsynClkIn Position */
N#define TPI_DEVID_AsynClkIn_Msk            (0x1UL << TPI_DEVID_AsynClkIn_Pos)          /*!< TPI DEVID: AsynClkIn Mask */
N
N#define TPI_DEVID_NrTraceInput_Pos          0                                          /*!< TPI DEVID: NrTraceInput Position */
N#define TPI_DEVID_NrTraceInput_Msk         (0x1FUL << TPI_DEVID_NrTraceInput_Pos)      /*!< TPI DEVID: NrTraceInput Mask */
N
N/* TPI DEVTYPE Register Definitions */
N#define TPI_DEVTYPE_SubType_Pos             0                                          /*!< TPI DEVTYPE: SubType Position */
N#define TPI_DEVTYPE_SubType_Msk            (0xFUL << TPI_DEVTYPE_SubType_Pos)          /*!< TPI DEVTYPE: SubType Mask */
N
N#define TPI_DEVTYPE_MajorType_Pos           4                                          /*!< TPI DEVTYPE: MajorType Position */
N#define TPI_DEVTYPE_MajorType_Msk          (0xFUL << TPI_DEVTYPE_MajorType_Pos)        /*!< TPI DEVTYPE: MajorType Mask */
N
N/*@}*/ /* end of group CMSIS_TPI */
N
N
N#if (__MPU_PRESENT == 1)
X#if (0 == 1)
S/** \ingroup  CMSIS_core_register
S    \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
S    \brief      Type definitions for the Memory Protection Unit (MPU)
S  @{
S */
S
S/** \brief  Structure type to access the Memory Protection Unit (MPU).
S */
Stypedef struct
S{
S  __I  uint32_t TYPE;                    /*!< Offset: 0x000 (R/ )  MPU Type Register                              */
S  __IO uint32_t CTRL;                    /*!< Offset: 0x004 (R/W)  MPU Control Register                           */
S  __IO uint32_t RNR;                     /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register                     */
S  __IO uint32_t RBAR;                    /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register               */
S  __IO uint32_t RASR;                    /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register         */
S  __IO uint32_t RBAR_A1;                 /*!< Offset: 0x014 (R/W)  MPU Alias 1 Region Base Address Register       */
S  __IO uint32_t RASR_A1;                 /*!< Offset: 0x018 (R/W)  MPU Alias 1 Region Attribute and Size Register */
S  __IO uint32_t RBAR_A2;                 /*!< Offset: 0x01C (R/W)  MPU Alias 2 Region Base Address Register       */
S  __IO uint32_t RASR_A2;                 /*!< Offset: 0x020 (R/W)  MPU Alias 2 Region Attribute and Size Register */
S  __IO uint32_t RBAR_A3;                 /*!< Offset: 0x024 (R/W)  MPU Alias 3 Region Base Address Register       */
S  __IO uint32_t RASR_A3;                 /*!< Offset: 0x028 (R/W)  MPU Alias 3 Region Attribute and Size Register */
S} MPU_Type;
S
S/* MPU Type Register */
S#define MPU_TYPE_IREGION_Pos               16                                             /*!< MPU TYPE: IREGION Position */
S#define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
S
S#define MPU_TYPE_DREGION_Pos                8                                             /*!< MPU TYPE: DREGION Position */
S#define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
S
S#define MPU_TYPE_SEPARATE_Pos               0                                             /*!< MPU TYPE: SEPARATE Position */
S#define MPU_TYPE_SEPARATE_Msk              (1UL << MPU_TYPE_SEPARATE_Pos)                 /*!< MPU TYPE: SEPARATE Mask */
S
S/* MPU Control Register */
S#define MPU_CTRL_PRIVDEFENA_Pos             2                                             /*!< MPU CTRL: PRIVDEFENA Position */
S#define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
S
S#define MPU_CTRL_HFNMIENA_Pos               1                                             /*!< MPU CTRL: HFNMIENA Position */
S#define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
S
S#define MPU_CTRL_ENABLE_Pos                 0                                             /*!< MPU CTRL: ENABLE Position */
S#define MPU_CTRL_ENABLE_Msk                (1UL << MPU_CTRL_ENABLE_Pos)                   /*!< MPU CTRL: ENABLE Mask */
S
S/* MPU Region Number Register */
S#define MPU_RNR_REGION_Pos                  0                                             /*!< MPU RNR: REGION Position */
S#define MPU_RNR_REGION_Msk                 (0xFFUL << MPU_RNR_REGION_Pos)                 /*!< MPU RNR: REGION Mask */
S
S/* MPU Region Base Address Register */
S#define MPU_RBAR_ADDR_Pos                   5                                             /*!< MPU RBAR: ADDR Position */
S#define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFUL << MPU_RBAR_ADDR_Pos)             /*!< MPU RBAR: ADDR Mask */
S
S#define MPU_RBAR_VALID_Pos                  4                                             /*!< MPU RBAR: VALID Position */
S#define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
S
S#define MPU_RBAR_REGION_Pos                 0                                             /*!< MPU RBAR: REGION Position */
S#define MPU_RBAR_REGION_Msk                (0xFUL << MPU_RBAR_REGION_Pos)                 /*!< MPU RBAR: REGION Mask */
S
S/* MPU Region Attribute and Size Register */
S#define MPU_RASR_ATTRS_Pos                 16                                             /*!< MPU RASR: MPU Region Attribute field Position */
S#define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU RASR: MPU Region Attribute field Mask */
S
S#define MPU_RASR_XN_Pos                    28                                             /*!< MPU RASR: ATTRS.XN Position */
S#define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU RASR: ATTRS.XN Mask */
S
S#define MPU_RASR_AP_Pos                    24                                             /*!< MPU RASR: ATTRS.AP Position */
S#define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU RASR: ATTRS.AP Mask */
S
S#define MPU_RASR_TEX_Pos                   19                                             /*!< MPU RASR: ATTRS.TEX Position */
S#define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU RASR: ATTRS.TEX Mask */
S
S#define MPU_RASR_S_Pos                     18                                             /*!< MPU RASR: ATTRS.S Position */
S#define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU RASR: ATTRS.S Mask */
S
S#define MPU_RASR_C_Pos                     17                                             /*!< MPU RASR: ATTRS.C Position */
S#define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU RASR: ATTRS.C Mask */
S
S#define MPU_RASR_B_Pos                     16                                             /*!< MPU RASR: ATTRS.B Position */
S#define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU RASR: ATTRS.B Mask */
S
S#define MPU_RASR_SRD_Pos                    8                                             /*!< MPU RASR: Sub-Region Disable Position */
S#define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
S
S#define MPU_RASR_SIZE_Pos                   1                                             /*!< MPU RASR: Region Size Field Position */
S#define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
S
S#define MPU_RASR_ENABLE_Pos                 0                                             /*!< MPU RASR: Region enable bit Position */
S#define MPU_RASR_ENABLE_Msk                (1UL << MPU_RASR_ENABLE_Pos)                   /*!< MPU RASR: Region enable bit Disable Mask */
S
S/*@} end of group CMSIS_MPU */
N#endif
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N    \brief      Type definitions for the Core Debug Registers
N  @{
N */
N
N/** \brief  Structure type to access the Core Debug Register (CoreDebug).
N */
Ntypedef struct
N{
N  __IO uint32_t DHCSR;                   /*!< Offset: 0x000 (R/W)  Debug Halting Control and Status Register    */
X  volatile uint32_t DHCSR;                    
N  __O  uint32_t DCRSR;                   /*!< Offset: 0x004 ( /W)  Debug Core Register Selector Register        */
X  volatile  uint32_t DCRSR;                    
N  __IO uint32_t DCRDR;                   /*!< Offset: 0x008 (R/W)  Debug Core Register Data Register            */
X  volatile uint32_t DCRDR;                    
N  __IO uint32_t DEMCR;                   /*!< Offset: 0x00C (R/W)  Debug Exception and Monitor Control Register */
X  volatile uint32_t DEMCR;                    
N} CoreDebug_Type;
N
N/* Debug Halting Control and Status Register */
N#define CoreDebug_DHCSR_DBGKEY_Pos         16                                             /*!< CoreDebug DHCSR: DBGKEY Position */
N#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< CoreDebug DHCSR: DBGKEY Mask */
N
N#define CoreDebug_DHCSR_S_RESET_ST_Pos     25                                             /*!< CoreDebug DHCSR: S_RESET_ST Position */
N#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< CoreDebug DHCSR: S_RESET_ST Mask */
N
N#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24                                             /*!< CoreDebug DHCSR: S_RETIRE_ST Position */
N#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */
N
N#define CoreDebug_DHCSR_S_LOCKUP_Pos       19                                             /*!< CoreDebug DHCSR: S_LOCKUP Position */
N#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< CoreDebug DHCSR: S_LOCKUP Mask */
N
N#define CoreDebug_DHCSR_S_SLEEP_Pos        18                                             /*!< CoreDebug DHCSR: S_SLEEP Position */
N#define CoreDebug_DHCSR_S_SLEEP_Msk        (1UL << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< CoreDebug DHCSR: S_SLEEP Mask */
N
N#define CoreDebug_DHCSR_S_HALT_Pos         17                                             /*!< CoreDebug DHCSR: S_HALT Position */
N#define CoreDebug_DHCSR_S_HALT_Msk         (1UL << CoreDebug_DHCSR_S_HALT_Pos)            /*!< CoreDebug DHCSR: S_HALT Mask */
N
N#define CoreDebug_DHCSR_S_REGRDY_Pos       16                                             /*!< CoreDebug DHCSR: S_REGRDY Position */
N#define CoreDebug_DHCSR_S_REGRDY_Msk       (1UL << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< CoreDebug DHCSR: S_REGRDY Mask */
N
N#define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5                                             /*!< CoreDebug DHCSR: C_SNAPSTALL Position */
N#define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!< CoreDebug DHCSR: C_SNAPSTALL Mask */
N
N#define CoreDebug_DHCSR_C_MASKINTS_Pos      3                                             /*!< CoreDebug DHCSR: C_MASKINTS Position */
N#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< CoreDebug DHCSR: C_MASKINTS Mask */
N
N#define CoreDebug_DHCSR_C_STEP_Pos          2                                             /*!< CoreDebug DHCSR: C_STEP Position */
N#define CoreDebug_DHCSR_C_STEP_Msk         (1UL << CoreDebug_DHCSR_C_STEP_Pos)            /*!< CoreDebug DHCSR: C_STEP Mask */
N
N#define CoreDebug_DHCSR_C_HALT_Pos          1                                             /*!< CoreDebug DHCSR: C_HALT Position */
N#define CoreDebug_DHCSR_C_HALT_Msk         (1UL << CoreDebug_DHCSR_C_HALT_Pos)            /*!< CoreDebug DHCSR: C_HALT Mask */
N
N#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0                                             /*!< CoreDebug DHCSR: C_DEBUGEN Position */
N#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1UL << CoreDebug_DHCSR_C_DEBUGEN_Pos)         /*!< CoreDebug DHCSR: C_DEBUGEN Mask */
N
N/* Debug Core Register Selector Register */
N#define CoreDebug_DCRSR_REGWnR_Pos         16                                             /*!< CoreDebug DCRSR: REGWnR Position */
N#define CoreDebug_DCRSR_REGWnR_Msk         (1UL << CoreDebug_DCRSR_REGWnR_Pos)            /*!< CoreDebug DCRSR: REGWnR Mask */
N
N#define CoreDebug_DCRSR_REGSEL_Pos          0                                             /*!< CoreDebug DCRSR: REGSEL Position */
N#define CoreDebug_DCRSR_REGSEL_Msk         (0x1FUL << CoreDebug_DCRSR_REGSEL_Pos)         /*!< CoreDebug DCRSR: REGSEL Mask */
N
N/* Debug Exception and Monitor Control Register */
N#define CoreDebug_DEMCR_TRCENA_Pos         24                                             /*!< CoreDebug DEMCR: TRCENA Position */
N#define CoreDebug_DEMCR_TRCENA_Msk         (1UL << CoreDebug_DEMCR_TRCENA_Pos)            /*!< CoreDebug DEMCR: TRCENA Mask */
N
N#define CoreDebug_DEMCR_MON_REQ_Pos        19                                             /*!< CoreDebug DEMCR: MON_REQ Position */
N#define CoreDebug_DEMCR_MON_REQ_Msk        (1UL << CoreDebug_DEMCR_MON_REQ_Pos)           /*!< CoreDebug DEMCR: MON_REQ Mask */
N
N#define CoreDebug_DEMCR_MON_STEP_Pos       18                                             /*!< CoreDebug DEMCR: MON_STEP Position */
N#define CoreDebug_DEMCR_MON_STEP_Msk       (1UL << CoreDebug_DEMCR_MON_STEP_Pos)          /*!< CoreDebug DEMCR: MON_STEP Mask */
N
N#define CoreDebug_DEMCR_MON_PEND_Pos       17                                             /*!< CoreDebug DEMCR: MON_PEND Position */
N#define CoreDebug_DEMCR_MON_PEND_Msk       (1UL << CoreDebug_DEMCR_MON_PEND_Pos)          /*!< CoreDebug DEMCR: MON_PEND Mask */
N
N#define CoreDebug_DEMCR_MON_EN_Pos         16                                             /*!< CoreDebug DEMCR: MON_EN Position */
N#define CoreDebug_DEMCR_MON_EN_Msk         (1UL << CoreDebug_DEMCR_MON_EN_Pos)            /*!< CoreDebug DEMCR: MON_EN Mask */
N
N#define CoreDebug_DEMCR_VC_HARDERR_Pos     10                                             /*!< CoreDebug DEMCR: VC_HARDERR Position */
N#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< CoreDebug DEMCR: VC_HARDERR Mask */
N
N#define CoreDebug_DEMCR_VC_INTERR_Pos       9                                             /*!< CoreDebug DEMCR: VC_INTERR Position */
N#define CoreDebug_DEMCR_VC_INTERR_Msk      (1UL << CoreDebug_DEMCR_VC_INTERR_Pos)         /*!< CoreDebug DEMCR: VC_INTERR Mask */
N
N#define CoreDebug_DEMCR_VC_BUSERR_Pos       8                                             /*!< CoreDebug DEMCR: VC_BUSERR Position */
N#define CoreDebug_DEMCR_VC_BUSERR_Msk      (1UL << CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!< CoreDebug DEMCR: VC_BUSERR Mask */
N
N#define CoreDebug_DEMCR_VC_STATERR_Pos      7                                             /*!< CoreDebug DEMCR: VC_STATERR Position */
N#define CoreDebug_DEMCR_VC_STATERR_Msk     (1UL << CoreDebug_DEMCR_VC_STATERR_Pos)        /*!< CoreDebug DEMCR: VC_STATERR Mask */
N
N#define CoreDebug_DEMCR_VC_CHKERR_Pos       6                                             /*!< CoreDebug DEMCR: VC_CHKERR Position */
N#define CoreDebug_DEMCR_VC_CHKERR_Msk      (1UL << CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!< CoreDebug DEMCR: VC_CHKERR Mask */
N
N#define CoreDebug_DEMCR_VC_NOCPERR_Pos      5                                             /*!< CoreDebug DEMCR: VC_NOCPERR Position */
N#define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!< CoreDebug DEMCR: VC_NOCPERR Mask */
N
N#define CoreDebug_DEMCR_VC_MMERR_Pos        4                                             /*!< CoreDebug DEMCR: VC_MMERR Position */
N#define CoreDebug_DEMCR_VC_MMERR_Msk       (1UL << CoreDebug_DEMCR_VC_MMERR_Pos)          /*!< CoreDebug DEMCR: VC_MMERR Mask */
N
N#define CoreDebug_DEMCR_VC_CORERESET_Pos    0                                             /*!< CoreDebug DEMCR: VC_CORERESET Position */
N#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1UL << CoreDebug_DEMCR_VC_CORERESET_Pos)      /*!< CoreDebug DEMCR: VC_CORERESET Mask */
N
N/*@} end of group CMSIS_CoreDebug */
N
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_core_base     Core Definitions
N    \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Cortex-M3 Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address  */
N#define ITM_BASE            (0xE0000000UL)                            /*!< ITM Base Address                   */
N#define DWT_BASE            (0xE0001000UL)                            /*!< DWT Base Address                   */
N#define TPI_BASE            (0xE0040000UL)                            /*!< TPI Base Address                   */
N#define CoreDebug_BASE      (0xE000EDF0UL)                            /*!< Core Debug Base Address            */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address               */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address                  */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address  */
N
N#define SCnSCB              ((SCnSCB_Type    *)     SCS_BASE      )   /*!< System control Register not in SCB */
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct           */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct       */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct          */
N#define ITM                 ((ITM_Type       *)     ITM_BASE      )   /*!< ITM configuration struct           */
N#define DWT                 ((DWT_Type       *)     DWT_BASE      )   /*!< DWT configuration struct           */
N#define TPI                 ((TPI_Type       *)     TPI_BASE      )   /*!< TPI configuration struct           */
N#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct    */
N
N#if (__MPU_PRESENT == 1)
X#if (0 == 1)
S  #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit             */
S  #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit             */
N#endif
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Debug Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/** \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N    \brief      Functions that manage interrupts and exceptions via the NVIC.
N    @{
N */
N
N/** \brief  Set Priority Grouping
N
N  The function sets the priority grouping field using the required unlock sequence.
N  The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.
N  Only values from 0..7 are used.
N  In case of a conflict between priority grouping and available
N  priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
N
N    \param [in]      PriorityGroup  Priority grouping field.
N */
N__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
Xstatic __inline void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
N{
N  uint32_t reg_value;
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */
N
N  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
X  reg_value  =  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR;                                                    
N  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
X  reg_value &= ~((0xFFFFUL << 16) | (7UL << 8));              
N  reg_value  =  (reg_value                                 |
N                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
X                ((uint32_t)0x5FA << 16) |
N                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
N  SCB->AIRCR =  reg_value;
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR =  reg_value;
N}
N
N
N/** \brief  Get Priority Grouping
N
N  The function reads the priority grouping field from the NVIC Interrupt Controller.
N
N    \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
N */
N__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
Xstatic __inline uint32_t NVIC_GetPriorityGrouping(void)
N{
N  return ((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos);   /* read priority grouping field */
X  return ((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8)) >> 8);    
N}
N
N
N/** \brief  Enable External Interrupt
N
N    The function enables a device-specific interrupt in the NVIC interrupt controller.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N
N/** \brief  Disable External Interrupt
N
N    The function disables a device-specific interrupt in the NVIC interrupt controller.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N
N/** \brief  Get Pending Interrupt
N
N    The function reads the pending register in the NVIC and returns the pending bit
N    for the specified interrupt.
N
N    \param [in]      IRQn  Interrupt number.
N
N    \return             0  Interrupt status is not pending.
N    \return             1  Interrupt status is pending.
N */
N__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  return((uint32_t) ((NVIC->ISPR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if pending else 0 */
X  return((uint32_t) ((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));  
N}
N
N
N/** \brief  Set Pending Interrupt
N
N    The function sets the pending bit of an external interrupt.
N
N    \param [in]      IRQn  Interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* set interrupt pending */
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N
N/** \brief  Clear Pending Interrupt
N
N    The function clears the pending bit of an external interrupt.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N
N/** \brief  Get Active Interrupt
N
N    The function reads the active register in NVIC and returns the active bit.
N
N    \param [in]      IRQn  Interrupt number.
N
N    \return             0  Interrupt status is not active.
N    \return             1  Interrupt status is active.
N */
N__STATIC_INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetActive(IRQn_Type IRQn)
N{
N  return((uint32_t)((NVIC->IABR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if active else 0 */
X  return((uint32_t)((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IABR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));  
N}
N
N
N/** \brief  Set Interrupt Priority
N
N    The function sets the priority of an interrupt.
N
N    \note The priority cannot be set for every core interrupt.
N
N    \param [in]      IRQn  Interrupt number.
N    \param [in]  priority  Priority to set.
N */
N__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if(IRQn < 0) {
N    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - 4)) & 0xff); }  
N  else {
N    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[(uint32_t)(IRQn)] = ((priority << (8 - 4)) & 0xff);    }         
N}
N
N
N/** \brief  Get Interrupt Priority
N
N    The function reads the priority of an interrupt. The interrupt
N    number can be positive to specify an external (device specific)
N    interrupt, or negative to specify an internal (core) interrupt.
N
N
N    \param [in]   IRQn  Interrupt number.
N    \return             Interrupt Priority. Value is aligned automatically to the implemented
N                        priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if(IRQn < 0) {
N    return((uint32_t)(SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M  system interrupts */
X    return((uint32_t)(((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[((uint32_t)(IRQn) & 0xF)-4] >> (8 - 4)));  }  
N  else {
N    return((uint32_t)(NVIC->IP[(uint32_t)(IRQn)]           >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */
X    return((uint32_t)(((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[(uint32_t)(IRQn)]           >> (8 - 4)));  }  
N}
N
N
N/** \brief  Encode Priority
N
N    The function encodes the priority for an interrupt with the given priority group,
N    preemptive priority value, and subpriority value.
N    In case of a conflict between priority grouping and available
N    priority bits (__NVIC_PRIO_BITS), the samllest possible priority group is set.
N
N    \param [in]     PriorityGroup  Used priority group.
N    \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
N    \param [in]       SubPriority  Subpriority value (starting from 0).
N    \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
N */
N__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
Xstatic __inline uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);          /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
X  PreemptPriorityBits = ((7 - PriorityGroupTmp) > 4) ? 4 : 7 - PriorityGroupTmp;
N  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
X  SubPriorityBits     = ((PriorityGroupTmp + 4) < 7) ? 0 : PriorityGroupTmp - 7 + 4;
N
N  return (
N           ((PreemptPriority & ((1 << (PreemptPriorityBits)) - 1)) << SubPriorityBits) |
N           ((SubPriority     & ((1 << (SubPriorityBits    )) - 1)))
N         );
N}
N
N
N/** \brief  Decode Priority
N
N    The function decodes an interrupt priority value with a given priority group to
N    preemptive priority value and subpriority value.
N    In case of a conflict between priority grouping and available
N    priority bits (__NVIC_PRIO_BITS) the samllest possible priority group is set.
N
N    \param [in]         Priority   Priority value, which can be retrieved with the function \ref NVIC_GetPriority().
N    \param [in]     PriorityGroup  Used priority group.
N    \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
N    \param [out]     pSubPriority  Subpriority value (starting from 0).
N */
N__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
Xstatic __inline void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);          /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
X  PreemptPriorityBits = ((7 - PriorityGroupTmp) > 4) ? 4 : 7 - PriorityGroupTmp;
N  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
X  SubPriorityBits     = ((PriorityGroupTmp + 4) < 7) ? 0 : PriorityGroupTmp - 7 + 4;
N
N  *pPreemptPriority = (Priority >> SubPriorityBits) & ((1 << (PreemptPriorityBits)) - 1);
N  *pSubPriority     = (Priority                   ) & ((1 << (SubPriorityBits    )) - 1);
N}
N
N
N/** \brief  System Reset
N
N    The function initiates a system reset request to reset the MCU.
N */
N__STATIC_INLINE void NVIC_SystemReset(void)
Xstatic __inline void NVIC_SystemReset(void)
N{
N  __DSB();                                                     /* Ensure all outstanding memory accesses included
X  __dsb(0xF);                                                     
N                                                                  buffered write are completed before reset */
N  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = ((0x5FA << 16)      |
N                 (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
X                 (((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8)) |
N                 SCB_AIRCR_SYSRESETREQ_Msk);                   /* Keep priority group unchanged */
X                 (1UL << 2));                    
N  __DSB();                                                     /* Ensure completion of memory access */
X  __dsb(0xF);                                                      
N  while(1);                                                    /* wait until reset */
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N    \brief      Functions that configure the System.
N  @{
N */
N
N#if (__Vendor_SysTickConfig == 0)
X#if (0 == 0)
N
N/** \brief  System Tick Configuration
N
N    The function initializes the System Timer and its interrupt, and starts the System Tick Timer.
N    Counter is in free running mode to generate periodic interrupts.
N
N    \param [in]  ticks  Number of ticks between two interrupts.
N
N    \return          0  Function succeeded.
N    \return          1  Function failed.
N
N    \note     When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
N    function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
N    must contain a vendor-specific implementation of this function.
N
N */
N__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if ((ticks - 1) > SysTick_LOAD_RELOAD_Msk)  return (1);      /* Reload value impossible */
X  if ((ticks - 1) > (0xFFFFFFUL << 0))  return (1);       
N
N  SysTick->LOAD  = ticks - 1;                                  /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = ticks - 1;                                   
N  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
X  NVIC_SetPriority (SysTick_IRQn, (1<<4) - 1);   
N  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0;                                           
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1UL << 1)   |
N                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL << 0);                     
N  return (0);                                                  /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N/* ##################################### Debug In/Output function ########################################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_core_DebugFunctions ITM Functions
N    \brief   Functions that access the ITM debug interface.
N  @{
N */
N
Nextern volatile int32_t ITM_RxBuffer;                    /*!< External variable to receive characters.                         */
N#define                 ITM_RXBUFFER_EMPTY    0x5AA55AA5 /*!< Value identifying \ref ITM_RxBuffer is ready for next character. */
N
N
N/** \brief  ITM Send Character
N
N    The function transmits a character via the ITM channel 0, and
N    \li Just returns when no debugger is connected that has booked the output.
N    \li Is blocking when a debugger is connected, but the previous character sent has not been transmitted.
N
N    \param [in]     ch  Character to transmit.
N
N    \returns            Character to transmit.
N */
N__STATIC_INLINE uint32_t ITM_SendChar (uint32_t ch)
Xstatic __inline uint32_t ITM_SendChar (uint32_t ch)
N{
N  if ((ITM->TCR & ITM_TCR_ITMENA_Msk)                  &&      /* ITM enabled */
X  if ((((ITM_Type *) (0xE0000000UL) )->TCR & (1UL << 0))                  &&       
N      (ITM->TER & (1UL << 0)        )                    )     /* ITM Port #0 enabled */
X      (((ITM_Type *) (0xE0000000UL) )->TER & (1UL << 0)        )                    )      
N  {
N    while (ITM->PORT[0].u32 == 0);
X    while (((ITM_Type *) (0xE0000000UL) )->PORT[0].u32 == 0);
N    ITM->PORT[0].u8 = (uint8_t) ch;
X    ((ITM_Type *) (0xE0000000UL) )->PORT[0].u8 = (uint8_t) ch;
N  }
N  return (ch);
N}
N
N
N/** \brief  ITM Receive Character
N
N    The function inputs a character via the external variable \ref ITM_RxBuffer.
N
N    \return             Received character.
N    \return         -1  No character pending.
N */
N__STATIC_INLINE int32_t ITM_ReceiveChar (void) {
Xstatic __inline int32_t ITM_ReceiveChar (void) {
N  int32_t ch = -1;                           /* no character available */
N
N  if (ITM_RxBuffer != ITM_RXBUFFER_EMPTY) {
X  if (ITM_RxBuffer != 0x5AA55AA5) {
N    ch = ITM_RxBuffer;
N    ITM_RxBuffer = ITM_RXBUFFER_EMPTY;       /* ready for next character */
X    ITM_RxBuffer = 0x5AA55AA5;        
N  }
N
N  return (ch);
N}
N
N
N/** \brief  ITM Check Character
N
N    The function checks whether a character is pending for reading in the variable \ref ITM_RxBuffer.
N
N    \return          0  No character available.
N    \return          1  Character available.
N */
N__STATIC_INLINE int32_t ITM_CheckChar (void) {
Xstatic __inline int32_t ITM_CheckChar (void) {
N
N  if (ITM_RxBuffer == ITM_RXBUFFER_EMPTY) {
X  if (ITM_RxBuffer == 0x5AA55AA5) {
N    return (0);                                 /* no character available */
N  } else {
N    return (1);                                 /*    character available */
N  }
N}
N
N/*@} end of CMSIS_core_DebugFunctions */
N
N#endif /* __CORE_CM3_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
N
N#ifdef __cplusplus
S}
N#endif
L 310 ".\CMSIS\gd32f10x.h" 2
N#include "system_gd32f10x.h"
L 1 ".\CMSIS\system_gd32f10x.h" 1
N/*!
N    \file    system_gd32f10x.h
N    \brief   CMSIS Cortex-M3 Device Peripheral Access Layer Header File for
N             GD32F10x Device Series
N*/
N
N/*
N    Copyright (c) 2012 ARM LIMITED
N
N    All rights reserved.
N
N    Redistribution and use in source and binary forms, with or without modification, 
Nare permitted provided that the following conditions are met:
N
N    1. Redistributions of source code must retain the above copyright notice, this 
N       list of conditions and the following disclaimer.
N    2. Redistributions in binary form must reproduce the above copyright notice, 
N       this list of conditions and the following disclaimer in the documentation 
N       and/or other materials provided with the distribution.
N    3. Neither the name of the copyright holder nor the names of its contributors 
N       may be used to endorse or promote products derived from this software without 
N       specific prior written permission.
N
N    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
NAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
NWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
NIN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
NINDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
NNOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
NPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
NWHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
NARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
NOF SUCH DAMAGE.
N*/
N
N/* This file refers the CMSIS standard, some adjustments are made according to GigaDevice chips */
N
N#ifndef SYSTEM_GD32F10X_H
N#define SYSTEM_GD32F10X_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include <stdint.h>
N
N/* system clock frequency (core clock) */
Nextern uint32_t SystemCoreClock;
N
N/* function declarations */
N/* initialize the system and update the SystemCoreClock variable */
Nextern void SystemInit(void);
N/* update the SystemCoreClock with current core clock retrieved from cpu registers */
Nextern void SystemCoreClockUpdate(void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* SYSTEM_GD32F10X_H */
L 311 ".\CMSIS\gd32f10x.h" 2
N#include <stdint.h>
N
N/* enum definitions */
Ntypedef enum {DISABLE = 0, ENABLE = !DISABLE} EventStatus, ControlStatus;
N//typedef enum {FALSE = 0, TRUE = !FALSE} bool;
Ntypedef enum {RESET = 0, SET = !RESET} FlagStatus;
Ntypedef enum {ERROR = 0, SUCCESS = !ERROR} ErrStatus;
N
N/* bit operations */
N#define REG32(addr)                  (*(volatile uint32_t *)(uint32_t)(addr))
N#define REG16(addr)                  (*(volatile uint16_t *)(uint32_t)(addr))
N#define REG8(addr)                   (*(volatile uint8_t *)(uint32_t)(addr))
N#define BIT(x)                       ((uint32_t)((uint32_t)0x01U<<(x)))
N#define BITS(start, end)             ((0xFFFFFFFFUL << (start)) & (0xFFFFFFFFUL >> (31U - (uint32_t)(end)))) 
N#define GET_BITS(regval, start, end) (((regval) & BITS((start),(end))) >> (start))
N
N/* main flash and SRAM memory map */
N#define FLASH_BASE            ((uint32_t)0x08000000U)        /*!< main FLASH base address          */
N#define SRAM_BASE             ((uint32_t)0x20000000U)        /*!< SRAM0 base address               */
N#define OB_BASE               ((uint32_t)0x1FFFF800U)        /*!< OB base address                  */
N#define DBG_BASE              ((uint32_t)0xE0042000U)        /*!< DBG base address                 */
N#define EXMC_BASE             ((uint32_t)0xA0000000U)        /*!< EXMC register base address       */
N
N/* peripheral memory map */
N#define APB1_BUS_BASE         ((uint32_t)0x40000000U)        /*!< apb1 base address                */
N#define APB2_BUS_BASE         ((uint32_t)0x40010000U)        /*!< apb2 base address                */
N#define AHB1_BUS_BASE         ((uint32_t)0x40018000U)        /*!< ahb1 base address                */
N#define AHB3_BUS_BASE         ((uint32_t)0x60000000U)        /*!< ahb3 base address                */
N
N/* advanced peripheral bus 1 memory map */
N#define TIMER_BASE            (APB1_BUS_BASE + 0x00000000U)  /*!< TIMER base address               */
N#define RTC_BASE              (APB1_BUS_BASE + 0x00002800U)  /*!< RTC base address                 */
N#define WWDGT_BASE            (APB1_BUS_BASE + 0x00002C00U)  /*!< WWDGT base address               */
N#define FWDGT_BASE            (APB1_BUS_BASE + 0x00003000U)  /*!< FWDGT base address               */
N#define SPI_BASE              (APB1_BUS_BASE + 0x00003800U)  /*!< SPI base address                 */
N#define USART_BASE            (APB1_BUS_BASE + 0x00004400U)  /*!< USART base address               */
N#define I2C_BASE              (APB1_BUS_BASE + 0x00005400U)  /*!< I2C base address                 */
N#define USBD_BASE             (APB1_BUS_BASE + 0x00005C00U)  /*!< USBD base address                */
N#define USBD_RAM_BASE         (APB1_BUS_BASE + 0x00006000U)  /*!< USBD RAM base address            */
N#define CAN_BASE              (APB1_BUS_BASE + 0x00006400U)  /*!< CAN base address                 */
N#define BKP_BASE              (APB1_BUS_BASE + 0x00006C00U)  /*!< BKP base address                 */
N#define PMU_BASE              (APB1_BUS_BASE + 0x00007000U)  /*!< PMU base address                 */
N#define DAC_BASE              (APB1_BUS_BASE + 0x00007400U)  /*!< DAC base address                 */
N
N/* advanced peripheral bus 2 memory map */
N#define AFIO_BASE             (APB2_BUS_BASE + 0x00000000U)  /*!< AFIO base address                */
N#define EXTI_BASE             (APB2_BUS_BASE + 0x00000400U)  /*!< EXTI base address                */
N#define GPIO_BASE             (APB2_BUS_BASE + 0x00000800U)  /*!< GPIO base address                */
N#define ADC_BASE              (APB2_BUS_BASE + 0x00002400U)  /*!< ADC base address                 */
N
N/* advanced high performance bus 1 memory map */
N#define SDIO_BASE             (AHB1_BUS_BASE + 0x00000000U)  /*!< SDIO base address                */
N#define DMA_BASE              (AHB1_BUS_BASE + 0x00008000U)  /*!< DMA base address                 */
N#define RCU_BASE              (AHB1_BUS_BASE + 0x00009000U)  /*!< RCU base address                 */
N#define FMC_BASE              (AHB1_BUS_BASE + 0x0000A000U)  /*!< FMC base address                 */
N#define CRC_BASE              (AHB1_BUS_BASE + 0x0000B000U)  /*!< CRC base address                 */
N#define ENET_BASE             (AHB1_BUS_BASE + 0x00010000U)  /*!< ENET base address                */
N#define USBFS_BASE            (AHB1_BUS_BASE + 0x0FFE8000U)  /*!< USBFS base address               */
N
N/* define marco USE_STDPERIPH_DRIVER */
N#if !defined  USE_STDPERIPH_DRIVER
X#if !1L
S#define USE_STDPERIPH_DRIVER
N#endif 
N#ifdef USE_STDPERIPH_DRIVER
N#include "gd32f10x_libopt.h"
L 1 ".\User\gd32f10x_libopt.h" 1
N/*!
N    \file    gd32f10x_libopt.h
N    \brief   library optional for gd32f10x
N
N    \version 2014-12-26, V1.0.0, firmware for GD32F10x
N    \version 2017-06-20, V2.0.0, firmware for GD32F10x
N    \version 2018-07-31, V2.1.0, firmware for GD32F10x
N*/
N
N/*
N    Copyright (c) 2018, GigaDevice Semiconductor Inc.
N
N    All rights reserved.
N
N    Redistribution and use in source and binary forms, with or without modification, 
Nare permitted provided that the following conditions are met:
N
N    1. Redistributions of source code must retain the above copyright notice, this 
N       list of conditions and the following disclaimer.
N    2. Redistributions in binary form must reproduce the above copyright notice, 
N       this list of conditions and the following disclaimer in the documentation 
N       and/or other materials provided with the distribution.
N    3. Neither the name of the copyright holder nor the names of its contributors 
N       may be used to endorse or promote products derived from this software without 
N       specific prior written permission.
N
N    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
NAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
NWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
NIN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
NINDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
NNOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
NPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
NWHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
NARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
NOF SUCH DAMAGE.
N*/
N
N#ifndef GD32F10X_LIBOPT_H
N#define GD32F10X_LIBOPT_H
N
N#include "gd32f10x_fmc.h"
L 1 ".\Libraries\inc\gd32f10x_fmc.h" 1
N/*!
N    \file  gd32f10x_fmc.h
N    \brief definitions for the FMC
N
N    \version 2014-12-26, V1.0.0, firmware for GD32F10x
N    \version 2017-06-20, V2.0.0, firmware for GD32F10x
N    \version 2018-07-31, V2.1.0, firmware for GD32F10x
N*/
N
N/*
N    Copyright (c) 2018, GigaDevice Semiconductor Inc.
N
N    All rights reserved.
N
N    Redistribution and use in source and binary forms, with or without modification, 
Nare permitted provided that the following conditions are met:
N
N    1. Redistributions of source code must retain the above copyright notice, this 
N       list of conditions and the following disclaimer.
N    2. Redistributions in binary form must reproduce the above copyright notice, 
N       this list of conditions and the following disclaimer in the documentation 
N       and/or other materials provided with the distribution.
N    3. Neither the name of the copyright holder nor the names of its contributors 
N       may be used to endorse or promote products derived from this software without 
N       specific prior written permission.
N
N    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
NAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
NWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
NIN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
NINDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
NNOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
NPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
NWHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
NARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
NOF SUCH DAMAGE.
N*/
N
N#ifndef GD32F10X_FMC_H
N#define GD32F10X_FMC_H
N
N#include "gd32f10x.h"
L 1 ".\CMSIS\gd32f10x.h" 1
N/*!
N    \file    gd32f10x.h
N    \brief   general definitions for GD32F10x
N
N    \version 2014-12-26, V1.0.0, firmware for GD32F10x
N    \version 2017-06-20, V2.0.0, firmware for GD32F10x
N    \version 2018-07-31, V2.1.0, firmware for GD32F10x
N*/
N
N/*
N    Copyright (c) 2018, GigaDevice Semiconductor Inc.
N
N    All rights reserved.
N
N    Redistribution and use in source and binary forms, with or without modification, 
Nare permitted provided that the following conditions are met:
N
N    1. Redistributions of source code must retain the above copyright notice, this 
N       list of conditions and the following disclaimer.
N    2. Redistributions in binary form must reproduce the above copyright notice, 
N       this list of conditions and the following disclaimer in the documentation 
N       and/or other materials provided with the distribution.
N    3. Neither the name of the copyright holder nor the names of its contributors 
N       may be used to endorse or promote products derived from this software without 
N       specific prior written permission.
N
N    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
NAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
NWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
NIN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
NINDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
NNOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
NPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
NWHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
NARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
NOF SUCH DAMAGE.
N*/
N
N#ifndef GD32F10X_H
S#define GD32F10X_H
S
S#ifdef cplusplus
S extern "C" {
S#endif 
S
S/* define GD32F10x */
S#if !defined (GD32F10X_MD) && !defined (GD32F10X_HD) && !defined (GD32F10X_XD) && !defined (GD32F10X_CL)
S  /* #define GD32F10X_MD */     /*!< GD32F10X_MD: GD32 Medium density devices */
S  /* #define GD32F10X_HD */     /*!< GD32F10X_HD: GD32 High density Value Line devices */  
S  /* #define GD32F10X_XD */     /*!< GD32F10X_XD: GD32 Extra density devices */
S  /* #define GD32F10X_CL */     /*!< GD32F10X_CL: GD32 Connectivity line devices */  
S#endif /* define GD32F10x */
S   
S#if !defined (GD32F10X_MD) && !defined (GD32F10X_HD) && !defined (GD32F10X_XD) && !defined (GD32F10X_CL)
S #error "Please select the target GD32F10x device in gd32f10x.h file"
S#endif /* undefine GD32F10x tip */
S
S/* define value of high speed crystal oscillator (HXTAL) in Hz */
S#if !defined  HXTAL_VALUE    
S#ifdef GD32F10X_CL   
S#define HXTAL_VALUE    ((uint32_t)25000000) /*!< value of the external oscillator in Hz */
S#else 
S#define HXTAL_VALUE    ((uint32_t)8000000) /* !< from 4M to 16M *!< value of the external oscillator in Hz*/
S#endif /* HXTAL_VALUE */
S#endif /* high speed crystal oscillator value */
S
S/* define startup timeout value of high speed crystal oscillator (HXTAL) */
S#if !defined  (HXTAL_STARTUP_TIMEOUT)
S#define HXTAL_STARTUP_TIMEOUT   ((uint16_t)0xFFFF)
S#endif /* high speed crystal oscillator startup timeout */
S
S/* define value of internal 8MHz RC oscillator (IRC8M) in Hz */
S#if !defined  (IRC8M_VALUE) 
S#define IRC8M_VALUE  ((uint32_t)8000000)
S#endif /* internal 8MHz RC oscillator value */
S
S/* define startup timeout value of internal 8MHz RC oscillator (IRC8M) */
S#if !defined  (IRC8M_STARTUP_TIMEOUT)
S#define IRC8M_STARTUP_TIMEOUT   ((uint16_t)0x0500)
S#endif /* internal 8MHz RC oscillator startup timeout */
S
S/* define value of internal 40KHz RC oscillator(IRC40K) in Hz */
S#if !defined  (IRC40K_VALUE) 
S#define IRC40K_VALUE  ((uint32_t)40000)
S#endif /* internal 40KHz RC oscillator value */
S
S/* define value of low speed crystal oscillator (LXTAL)in Hz */
S#if !defined  (LXTAL_VALUE) 
S#define LXTAL_VALUE  ((uint32_t)32768)
S#endif /* low speed crystal oscillator value */
S
S/* GD32F10x firmware library version number V2.0 */
S#define __GD32F10x_STDPERIPH_VERSION_MAIN   (0x01) /*!< [31:24] main version     */
S#define __GD32F10x_STDPERIPH_VERSION_SUB1   (0x00) /*!< [23:16] sub1 version     */
S#define __GD32F10x_STDPERIPH_VERSION_SUB2   (0x00) /*!< [15:8]  sub2 version     */
S#define __GD32F10x_STDPERIPH_VERSION_RC     (0x00) /*!< [7:0]  release candidate */ 
S#define __GD32F10x_STDPERIPH_VERSION        ((__GD32F10x_STDPERIPH_VERSION_MAIN << 24)\
S                                            |(__GD32F10x_STDPERIPH_VERSION_SUB1 << 16)\
S                                            |(__GD32F10x_STDPERIPH_VERSION_SUB2 << 8)\
S                                            |(__GD32F10x_STDPERIPH_VERSION_RC))
X#define __GD32F10x_STDPERIPH_VERSION        ((__GD32F10x_STDPERIPH_VERSION_MAIN << 24)                                            |(__GD32F10x_STDPERIPH_VERSION_SUB1 << 16)                                            |(__GD32F10x_STDPERIPH_VERSION_SUB2 << 8)                                            |(__GD32F10x_STDPERIPH_VERSION_RC))
S
S/* configuration of the Cortex-M3 processor and core peripherals */
S#define __MPU_PRESENT             0        /*!< GD32F10x do not provide MPU                              */
S#define __NVIC_PRIO_BITS          4        /*!< GD32F10x uses 4 bits for the priority levels             */
S#define __Vendor_SysTickConfig    0        /*!< set to 1 if different sysTick config is used             */
S/* define interrupt number */
Stypedef enum IRQn
S{
S    /* Cortex-M3 processor exceptions numbers */
S    NonMaskableInt_IRQn          = -14,    /*!< 2 non maskable interrupt                                 */
S    MemoryManagement_IRQn        = -12,    /*!< 4 Cortex-M3 memory management interrupt                  */
S    BusFault_IRQn                = -11,    /*!< 5 Cortex-M3 bus fault interrupt                          */
S    UsageFault_IRQn              = -10,    /*!< 6 Cortex-M3 usage fault interrupt                        */
S    SVCall_IRQn                  = -5,     /*!< 11 Cortex-M3 SV call interrupt                           */
S    DebugMonitor_IRQn            = -4,     /*!< 12 Cortex-M3 debug monitor interrupt                     */
S    PendSV_IRQn                  = -2,     /*!< 14 Cortex-M3 pend SV interrupt                           */
S    SysTick_IRQn                 = -1,     /*!< 15 Cortex-M3 system tick interrupt                       */
S
S    /* interruput numbers */
S    WWDGT_IRQn                   = 0,      /*!< window watchDog timer interrupt                          */
S    LVD_IRQn                     = 1,      /*!< LVD through EXTI line detect interrupt                   */
S    TAMPER_IRQn                  = 2,      /*!< tamper through EXTI line detect                          */
S    RTC_IRQn                     = 3,      /*!< RTC through EXTI line interrupt                          */
S    FMC_IRQn                     = 4,      /*!< FMC interrupt                                            */
S    RCU_CTC_IRQn                 = 5,      /*!< RCU and CTC interrupt                                    */
S    EXTI0_IRQn                   = 6,      /*!< EXTI line 0 interrupts                                   */
S    EXTI1_IRQn                   = 7,      /*!< EXTI line 1 interrupts                                   */
S    EXTI2_IRQn                   = 8,      /*!< EXTI line 2 interrupts                                   */
S    EXTI3_IRQn                   = 9,      /*!< EXTI line 3 interrupts                                   */
S    EXTI4_IRQn                   = 10,     /*!< EXTI line 4 interrupts                                   */
S    DMA0_Channel0_IRQn           = 11,     /*!< DMA0 channel0 interrupt                                  */
S    DMA0_Channel1_IRQn           = 12,     /*!< DMA0 channel1 interrupt                                  */
S    DMA0_Channel2_IRQn           = 13,     /*!< DMA0 channel2 interrupt                                  */
S    DMA0_Channel3_IRQn           = 14,     /*!< DMA0 channel3 interrupt                                  */
S    DMA0_Channel4_IRQn           = 15,     /*!< DMA0 channel4 interrupt                                  */
S    DMA0_Channel5_IRQn           = 16,     /*!< DMA0 channel5 interrupt                                  */
S    DMA0_Channel6_IRQn           = 17,     /*!< DMA0 channel6 interrupt                                  */
S    ADC0_1_IRQn                  = 18,     /*!< ADC0 and ADC1 interrupt                                  */
S
S#ifdef GD32F10X_MD
S    USBD_HP_CAN0_TX_IRQn         = 19,     /*!< CAN0 TX interrupts                                       */
S    USBD_LP_CAN0_RX0_IRQn        = 20,     /*!< CAN0 RX0 interrupts                                      */
S    CAN0_RX1_IRQn                = 21,     /*!< CAN0 RX1 interrupts                                      */
S    CAN0_EWMC_IRQn               = 22,     /*!< CAN0 EWMC interrupts                                     */
S    EXTI5_9_IRQn                 = 23,     /*!< EXTI[9:5] interrupts                                     */
S    TIMER0_BRK_IRQn              = 24,     /*!< TIMER0 break interrupts                                  */
S    TIMER0_UP_IRQn               = 25,     /*!< TIMER0 update interrupts                                 */
S    TIMER0_TRG_CMT_IRQn          = 26,     /*!< TIMER0 trigger and commutation interrupts                */
S    TIMER0_Channel_IRQn          = 27,     /*!< TIMER0 channel capture compare interrupts                */
S    TIMER1_IRQn                  = 28,     /*!< TIMER1 interrupt                                         */
S    TIMER2_IRQn                  = 29,     /*!< TIMER2 interrupt                                         */
S    TIMER3_IRQn                  = 30,     /*!< TIMER3 interrupts                                        */
S    I2C0_EV_IRQn                 = 31,     /*!< I2C0 event interrupt                                     */
S    I2C0_ER_IRQn                 = 32,     /*!< I2C0 error interrupt                                     */
S    I2C1_EV_IRQn                 = 33,     /*!< I2C1 event interrupt                                     */
S    I2C1_ER_IRQn                 = 34,     /*!< I2C1 error interrupt                                     */
S    SPI0_IRQn                    = 35,     /*!< SPI0 interrupt                                           */
S    SPI1_IRQn                    = 36,     /*!< SPI1 interrupt                                           */
S    USART0_IRQn                  = 37,     /*!< USART0 interrupt                                         */
S    USART1_IRQn                  = 38,     /*!< USART1 interrupt                                         */
S    USART2_IRQn                  = 39,     /*!< USART2 interrupt                                         */
S    EXTI10_15_IRQn               = 40,     /*!< EXTI[15:10] interrupts                                   */
S    RTC_Alarm_IRQn               = 41,     /*!< RTC alarm interrupt                                      */
S    USBD_WKUP_IRQn               = 42,     /*!< USBD Wakeup interrupt                                    */
S    EXMC_IRQn                    = 48,     /*!< EXMC global interrupt                                    */
S#endif /* GD32F10X_MD */
S
S#ifdef GD32F10X_HD
S    USBD_HP_CAN0_TX_IRQn         = 19,     /*!< CAN0 TX interrupts                                       */
S    USBD_LP_CAN0_RX0_IRQn        = 20,     /*!< CAN0 RX0 interrupts                                      */
S    CAN0_RX1_IRQn                = 21,     /*!< CAN0 RX1 interrupts                                      */
S    CAN0_EWMC_IRQn               = 22,     /*!< CAN0 EWMC interrupts                                     */
S    EXTI5_9_IRQn                 = 23,     /*!< EXTI[9:5] interrupts                                     */
S    TIMER0_BRK_IRQn              = 24,     /*!< TIMER0 break interrupts                                  */
S    TIMER0_UP_IRQn               = 25,     /*!< TIMER0 update interrupts                                 */
S    TIMER0_TRG_CMT_IRQn          = 26,     /*!< TIMER0 trigger and commutation interrupts                */
S    TIMER0_Channel_IRQn          = 27,     /*!< TIMER0 channel capture compare interrupts                */
S    TIMER1_IRQn                  = 28,     /*!< TIMER1 interrupt                                         */
S    TIMER2_IRQn                  = 29,     /*!< TIMER2 interrupt                                         */
S    TIMER3_IRQn                  = 30,     /*!< TIMER3 interrupts                                        */
S    I2C0_EV_IRQn                 = 31,     /*!< I2C0 event interrupt                                     */
S    I2C0_ER_IRQn                 = 32,     /*!< I2C0 error interrupt                                     */
S    I2C1_EV_IRQn                 = 33,     /*!< I2C1 event interrupt                                     */
S    I2C1_ER_IRQn                 = 34,     /*!< I2C1 error interrupt                                     */
S    SPI0_IRQn                    = 35,     /*!< SPI0 interrupt                                           */
S    SPI1_IRQn                    = 36,     /*!< SPI1 interrupt                                           */
S    USART0_IRQn                  = 37,     /*!< USART0 interrupt                                         */
S    USART1_IRQn                  = 38,     /*!< USART1 interrupt                                         */
S    USART2_IRQn                  = 39,     /*!< USART2 interrupt                                         */
S    EXTI10_15_IRQn               = 40,     /*!< EXTI[15:10] interrupts                                   */
S    RTC_Alarm_IRQn               = 41,     /*!< RTC alarm interrupt                                      */
S    USBD_WKUP_IRQn               = 42,     /*!< USBD Wakeup interrupt                                    */
S    TIMER7_BRK_IRQn              = 43,     /*!< TIMER7 break interrupts                                  */
S    TIMER7_UP_IRQn               = 44,     /*!< TIMER7 update interrupts                                 */
S    TIMER7_TRG_CMT_IRQn          = 45,     /*!< TIMER7 trigger and commutation interrupts                */
S    TIMER7_Channel_IRQn          = 46,     /*!< TIMER7 channel capture compare interrupts                */
S    ADC2_IRQn                    = 47,     /*!< ADC2 global interrupt                                    */
S    EXMC_IRQn                    = 48,     /*!< EXMC global interrupt                                    */
S    SDIO_IRQn                    = 49,     /*!< SDIO global interrupt                                    */
S    TIMER4_IRQn                  = 50,     /*!< TIMER4 global interrupt                                  */
S    SPI2_IRQn                    = 51,     /*!< SPI2 global interrupt                                    */
S    UART3_IRQn                   = 52,     /*!< UART3 global interrupt                                   */
S    UART4_IRQn                   = 53,     /*!< UART4 global interrupt                                   */
S    TIMER5_IRQn                  = 54,     /*!< TIMER5 global interrupt                                  */
S    TIMER6_IRQn                  = 55,     /*!< TIMER6 global interrupt                                  */
S    DMA1_Channel0_IRQn           = 56,     /*!< DMA1 channel0 global interrupt                           */
S    DMA1_Channel1_IRQn           = 57,     /*!< DMA1 channel1 global interrupt                           */
S    DMA1_Channel2_IRQn           = 58,     /*!< DMA1 channel2 global interrupt                           */
S    DMA1_Channel3_Channel4_IRQn  = 59,     /*!< DMA1 channel3 and channel4 global Interrupt              */
S#endif /* GD32F10X_HD */
S
S#ifdef GD32F10X_XD
S    USBD_HP_CAN0_TX_IRQn         = 19,     /*!< CAN0 TX interrupts                                       */
S    USBD_LP_CAN0_RX0_IRQn        = 20,     /*!< CAN0 RX0 interrupts                                      */
S    CAN0_RX1_IRQn                = 21,     /*!< CAN0 RX1 interrupts                                      */
S    CAN0_EWMC_IRQn               = 22,     /*!< CAN0 EWMC interrupts                                     */
S    EXTI5_9_IRQn                 = 23,     /*!< EXTI[9:5] interrupts                                     */
S    TIMER0_BRK_TIMER8_IRQn       = 24,     /*!< TIMER0 break and TIMER8 interrupts                       */
S    TIMER0_UP_TIMER9_IRQn        = 25,     /*!< TIMER0 update and TIMER9 interrupts                      */
S    TIMER0_TRG_CMT_TIMER10_IRQn  = 26,     /*!< TIMER0 trigger and commutation and TIMER10 interrupts    */
S    TIMER0_Channel_IRQn          = 27,     /*!< TIMER0 channel capture compare interrupts                */
S    TIMER1_IRQn                  = 28,     /*!< TIMER1 interrupt                                         */
S    TIMER2_IRQn                  = 29,     /*!< TIMER2 interrupt                                         */
S    TIMER3_IRQn                  = 30,     /*!< TIMER3 interrupts                                        */
S    I2C0_EV_IRQn                 = 31,     /*!< I2C0 event interrupt                                     */
S    I2C0_ER_IRQn                 = 32,     /*!< I2C0 error interrupt                                     */
S    I2C1_EV_IRQn                 = 33,     /*!< I2C1 event interrupt                                     */
S    I2C1_ER_IRQn                 = 34,     /*!< I2C1 error interrupt                                     */
S    SPI0_IRQn                    = 35,     /*!< SPI0 interrupt                                           */
S    SPI1_IRQn                    = 36,     /*!< SPI1 interrupt                                           */
S    USART0_IRQn                  = 37,     /*!< USART0 interrupt                                         */
S    USART1_IRQn                  = 38,     /*!< USART1 interrupt                                         */
S    USART2_IRQn                  = 39,     /*!< USART2 interrupt                                         */
S    EXTI10_15_IRQn               = 40,     /*!< EXTI[15:10] interrupts                                   */
S    RTC_Alarm_IRQn               = 41,     /*!< RTC alarm interrupt                                      */
S    USBD_WKUP_IRQn               = 42,     /*!< USBD wakeup interrupt                                    */
S    TIMER7_BRK_TIMER11_IRQn      = 43,     /*!< TIMER7 break and TIMER11 interrupts                      */
S    TIMER7_UP_TIMER12_IRQn       = 44,     /*!< TIMER7 update and TIMER12 interrupts                     */
S    TIMER7_TRG_CMT_TIMER13_IRQn  = 45,     /*!< TIMER7 trigger and commutation and TIMER13 interrupts    */
S    TIMER7_Channel_IRQn          = 46,     /*!< TIMER7 channel capture compare interrupts                */
S    ADC2_IRQn                    = 47,     /*!< ADC2 global interrupt                                    */
S    EXMC_IRQn                    = 48,     /*!< EXMC global interrupt                                    */
S    SDIO_IRQn                    = 49,     /*!< SDIO global interrupt                                    */
S    TIMER4_IRQn                  = 50,     /*!< TIMER4 global interrupt                                  */
S    SPI2_IRQn                    = 51,     /*!< SPI2 global interrupt                                    */
S    UART3_IRQn                   = 52,     /*!< UART3 global interrupt                                   */
S    UART4_IRQn                   = 53,     /*!< UART4 global interrupt                                   */
S    TIMER5_IRQn                  = 54,     /*!< TIMER5 global interrupt                                  */
S    TIMER6_IRQn                  = 55,     /*!< TIMER6 global interrupt                                  */
S    DMA1_Channel0_IRQn           = 56,     /*!< DMA1 channel0 global interrupt                           */
S    DMA1_Channel1_IRQn           = 57,     /*!< DMA1 channel1 global interrupt                           */
S    DMA1_Channel2_IRQn           = 58,     /*!< DMA1 channel2 global interrupt                           */
S    DMA1_Channel3_Channel4_IRQn  = 59,     /*!< DMA1 channel3 and channel4 global interrupt              */
S#endif /* GD32F10X_XD */
S
S#ifdef GD32F10X_CL
S    CAN0_TX_IRQn                 = 19,     /*!< CAN0 TX interrupts                                       */
S    CAN0_RX0_IRQn                = 20,     /*!< CAN0 RX0 interrupts                                      */
S    CAN0_RX1_IRQn                = 21,     /*!< CAN0 RX1 interrupts                                      */
S    CAN0_EWMC_IRQn               = 22,     /*!< CAN0 EWMC interrupts                                     */
S    EXTI5_9_IRQn                 = 23,     /*!< EXTI[9:5] interrupts                                     */
S    TIMER0_BRK_IRQn              = 24,     /*!< TIMER0 break interrupts                                  */
S    TIMER0_UP_IRQn               = 25,     /*!< TIMER0 update interrupts                                 */
S    TIMER0_TRG_CMT_IRQn          = 26,     /*!< TIMER0 trigger and commutation interrupts                */
S    TIMER0_Channel_IRQn          = 27,     /*!< TIMER0 channel capture compare interrupts                */
S    TIMER1_IRQn                  = 28,     /*!< TIMER1 interrupt                                         */
S    TIMER2_IRQn                  = 29,     /*!< TIMER2 interrupt                                         */
S    TIMER3_IRQn                  = 30,     /*!< TIMER3 interrupts                                        */
S    I2C0_EV_IRQn                 = 31,     /*!< I2C0 event interrupt                                     */
S    I2C0_ER_IRQn                 = 32,     /*!< I2C0 error interrupt                                     */
S    I2C1_EV_IRQn                 = 33,     /*!< I2C1 event interrupt                                     */
S    I2C1_ER_IRQn                 = 34,     /*!< I2C1 error interrupt                                     */
S    SPI0_IRQn                    = 35,     /*!< SPI0 interrupt                                           */
S    SPI1_IRQn                    = 36,     /*!< SPI1 interrupt                                           */
S    USART0_IRQn                  = 37,     /*!< USART0 interrupt                                         */
S    USART1_IRQn                  = 38,     /*!< USART1 interrupt                                         */
S    USART2_IRQn                  = 39,     /*!< USART2 interrupt                                         */
S    EXTI10_15_IRQn               = 40,     /*!< EXTI[15:10] interrupts                                   */
S    RTC_ALARM_IRQn               = 41,     /*!< RTC alarm interrupt                                      */
S    USBFS_WKUP_IRQn              = 42,     /*!< USBFS wakeup interrupt                                   */
S    TIMER7_BRK_IRQn              = 43,     /*!< TIMER7 break interrupts                                  */
S    TIMER7_UP_IRQn               = 44,     /*!< TIMER7 update interrupts                                 */
S    TIMER7_TRG_CMT_IRQn          = 45,     /*!< TIMER7 trigger and commutation interrupts                */
S    TIMER7_Channel_IRQn          = 46,     /*!< TIMER7 channel capture compare interrupts                */
S    EXMC_IRQn                    = 48,     /*!< EXMC global interrupt                                    */
S    TIMER4_IRQn                  = 50,     /*!< TIMER4 global interrupt                                  */
S    SPI2_IRQn                    = 51,     /*!< SPI2 global interrupt                                    */
S    UART3_IRQn                   = 52,     /*!< UART3 global interrupt                                   */
S    UART4_IRQn                   = 53,     /*!< UART4 global interrupt                                   */
S    TIMER5_IRQn                  = 54,     /*!< TIMER5 global interrupt                                  */
S    TIMER6_IRQn                  = 55,     /*!< TIMER6 global interrupt                                  */
S    DMA1_Channel0_IRQn           = 56,     /*!< DMA1 channel0 global interrupt                           */
S    DMA1_Channel1_IRQn           = 57,     /*!< DMA1 channel1 global interrupt                           */
S    DMA1_Channel2_IRQn           = 58,     /*!< DMA1 channel2 global interrupt                           */
S    DMA1_Channel3_IRQn           = 59,     /*!< DMA1 channel3 global interrupt                           */
S    DMA1_Channel4_IRQn           = 60,     /*!< DMA1 channel3 global interrupt                           */
S    ENET_IRQn                    = 61,     /*!< ENET global interrupt                                    */
S    ENET_WKUP_IRQn               = 62,     /*!< ENET Wakeup interrupt                                    */
S    CAN1_TX_IRQn                 = 63,     /*!< CAN1 TX interrupt                                        */
S    CAN1_RX0_IRQn                = 64,     /*!< CAN1 RX0 interrupt                                       */
S    CAN1_RX1_IRQn                = 65,     /*!< CAN1 RX1 interrupt                                       */
S    CAN1_EWMC_IRQn               = 66,     /*!< CAN1 EWMC interrupt                                      */
S    USBFS_IRQn                   = 67,     /*!< USBFS global interrupt                                   */
S#endif /* GD32F10X_CL */
S
S} IRQn_Type;
S
S/* includes */
S#include "core_cm3.h"
S#include "system_gd32f10x.h"
S#include <stdint.h>
S
S/* enum definitions */
Stypedef enum {DISABLE = 0, ENABLE = !DISABLE} EventStatus, ControlStatus;
S//typedef enum {FALSE = 0, TRUE = !FALSE} bool;
Stypedef enum {RESET = 0, SET = !RESET} FlagStatus;
Stypedef enum {ERROR = 0, SUCCESS = !ERROR} ErrStatus;
S
S/* bit operations */
S#define REG32(addr)                  (*(volatile uint32_t *)(uint32_t)(addr))
S#define REG16(addr)                  (*(volatile uint16_t *)(uint32_t)(addr))
S#define REG8(addr)                   (*(volatile uint8_t *)(uint32_t)(addr))
S#define BIT(x)                       ((uint32_t)((uint32_t)0x01U<<(x)))
S#define BITS(start, end)             ((0xFFFFFFFFUL << (start)) & (0xFFFFFFFFUL >> (31U - (uint32_t)(end)))) 
S#define GET_BITS(regval, start, end) (((regval) & BITS((start),(end))) >> (start))
S
S/* main flash and SRAM memory map */
S#define FLASH_BASE            ((uint32_t)0x08000000U)        /*!< main FLASH base address          */
S#define SRAM_BASE             ((uint32_t)0x20000000U)        /*!< SRAM0 base address               */
S#define OB_BASE               ((uint32_t)0x1FFFF800U)        /*!< OB base address                  */
S#define DBG_BASE              ((uint32_t)0xE0042000U)        /*!< DBG base address                 */
S#define EXMC_BASE             ((uint32_t)0xA0000000U)        /*!< EXMC register base address       */
S
S/* peripheral memory map */
S#define APB1_BUS_BASE         ((uint32_t)0x40000000U)        /*!< apb1 base address                */
S#define APB2_BUS_BASE         ((uint32_t)0x40010000U)        /*!< apb2 base address                */
S#define AHB1_BUS_BASE         ((uint32_t)0x40018000U)        /*!< ahb1 base address                */
S#define AHB3_BUS_BASE         ((uint32_t)0x60000000U)        /*!< ahb3 base address                */
S
S/* advanced peripheral bus 1 memory map */
S#define TIMER_BASE            (APB1_BUS_BASE + 0x00000000U)  /*!< TIMER base address               */
S#define RTC_BASE              (APB1_BUS_BASE + 0x00002800U)  /*!< RTC base address                 */
S#define WWDGT_BASE            (APB1_BUS_BASE + 0x00002C00U)  /*!< WWDGT base address               */
S#define FWDGT_BASE            (APB1_BUS_BASE + 0x00003000U)  /*!< FWDGT base address               */
S#define SPI_BASE              (APB1_BUS_BASE + 0x00003800U)  /*!< SPI base address                 */
S#define USART_BASE            (APB1_BUS_BASE + 0x00004400U)  /*!< USART base address               */
S#define I2C_BASE              (APB1_BUS_BASE + 0x00005400U)  /*!< I2C base address                 */
S#define USBD_BASE             (APB1_BUS_BASE + 0x00005C00U)  /*!< USBD base address                */
S#define USBD_RAM_BASE         (APB1_BUS_BASE + 0x00006000U)  /*!< USBD RAM base address            */
S#define CAN_BASE              (APB1_BUS_BASE + 0x00006400U)  /*!< CAN base address                 */
S#define BKP_BASE              (APB1_BUS_BASE + 0x00006C00U)  /*!< BKP base address                 */
S#define PMU_BASE              (APB1_BUS_BASE + 0x00007000U)  /*!< PMU base address                 */
S#define DAC_BASE              (APB1_BUS_BASE + 0x00007400U)  /*!< DAC base address                 */
S
S/* advanced peripheral bus 2 memory map */
S#define AFIO_BASE             (APB2_BUS_BASE + 0x00000000U)  /*!< AFIO base address                */
S#define EXTI_BASE             (APB2_BUS_BASE + 0x00000400U)  /*!< EXTI base address                */
S#define GPIO_BASE             (APB2_BUS_BASE + 0x00000800U)  /*!< GPIO base address                */
S#define ADC_BASE              (APB2_BUS_BASE + 0x00002400U)  /*!< ADC base address                 */
S
S/* advanced high performance bus 1 memory map */
S#define SDIO_BASE             (AHB1_BUS_BASE + 0x00000000U)  /*!< SDIO base address                */
S#define DMA_BASE              (AHB1_BUS_BASE + 0x00008000U)  /*!< DMA base address                 */
S#define RCU_BASE              (AHB1_BUS_BASE + 0x00009000U)  /*!< RCU base address                 */
S#define FMC_BASE              (AHB1_BUS_BASE + 0x0000A000U)  /*!< FMC base address                 */
S#define CRC_BASE              (AHB1_BUS_BASE + 0x0000B000U)  /*!< CRC base address                 */
S#define ENET_BASE             (AHB1_BUS_BASE + 0x00010000U)  /*!< ENET base address                */
S#define USBFS_BASE            (AHB1_BUS_BASE + 0x0FFE8000U)  /*!< USBFS base address               */
S
S/* define marco USE_STDPERIPH_DRIVER */
S#if !defined  USE_STDPERIPH_DRIVER
S#define USE_STDPERIPH_DRIVER
S#endif 
S#ifdef USE_STDPERIPH_DRIVER
S#include "gd32f10x_libopt.h"
S#endif /* USE_STDPERIPH_DRIVER */
S
S#ifdef cplusplus
S}
S#endif
N#endif 
L 43 ".\Libraries\inc\gd32f10x_fmc.h" 2
N
N/* FMC and option byte definition */
N#define FMC                        FMC_BASE                       /*!< FMC register base address */
N#define OB                         OB_BASE                        /*!< option bytes base address */
N
N/* registers definitions */
N#define FMC_WS                     REG32((FMC) + 0x00U)                          /*!< FMC wait state register */
N#define FMC_KEY0                   REG32((FMC) + 0x04U)                          /*!< FMC unlock key register 0 */
N#define FMC_OBKEY                  REG32((FMC) + 0x08U)                          /*!< FMC option bytes unlock key register */
N#define FMC_STAT0                  REG32((FMC) + 0x0CU)                          /*!< FMC status register 0 */
N#define FMC_CTL0                   REG32((FMC) + 0x10U)                          /*!< FMC control register 0 */
N#define FMC_ADDR0                  REG32((FMC) + 0x14U)                          /*!< FMC address register 0 */
N#define FMC_OBSTAT                 REG32((FMC) + 0x1CU)                          /*!< FMC option bytes status register */
N#define FMC_WP                     REG32((FMC) + 0x20U)                          /*!< FMC erase/program protection register */
N#define FMC_KEY1                   REG32((FMC) + 0x44U)                          /*!< FMC unlock key register 1 */
N#define FMC_STAT1                  REG32((FMC) + 0x4CU)                          /*!< FMC status register 1 */
N#define FMC_CTL1                   REG32((FMC) + 0x50U)                          /*!< FMC control register 1 */
N#define FMC_ADDR1                  REG32((FMC) + 0x54U)                          /*!< FMC address register 1 */
N#define FMC_WSEN                   REG32((FMC) + 0xFCU)                          /*!< FMC wait state enable register */
N#define FMC_PID                    REG32((FMC) + 0x100U)                         /*!< FMC product ID register */
N
N#define OB_SPC                     REG16((OB) + 0x00U)                           /*!< option byte security protection value */
N#define OB_USER                    REG16((OB) + 0x02U)                           /*!< option byte user value*/
N#define OB_WP0                     REG16((OB) + 0x08U)                           /*!< option byte write protection 0 */
N#define OB_WP1                     REG16((OB) + 0x0AU)                           /*!< option byte write protection 1 */
N#define OB_WP2                     REG16((OB) + 0x0CU)                           /*!< option byte write protection 2 */
N#define OB_WP3                     REG16((OB) + 0x0EU)                           /*!< option byte write protection 3 */
N
N/* bits definitions */
N/* FMC_WS */
N#define FMC_WS_WSCNT               BITS(0,2)                                     /*!< wait state counter */
N
N/* FMC_KEY0 */
N#define FMC_KEY0_KEY               BITS(0,31)                                    /*!< FMC_CTL0 unlock key bits */
N
N/* FMC_OBKEY */
N#define FMC_OBKEY_OBKEY            BITS(0,31)                                    /*!< option bytes unlock key bits */
N
N/* FMC_STAT0 */
N#define FMC_STAT0_BUSY             BIT(0)                                        /*!< flash busy flag bit */
N#define FMC_STAT0_PGERR            BIT(2)                                        /*!< flash program error flag bit */
N#define FMC_STAT0_WPERR            BIT(4)                                        /*!< erase/program protection error flag bit */
N#define FMC_STAT0_ENDF             BIT(5)                                        /*!< end of operation flag bit */
N
N/* FMC_CTL0 */
N#define FMC_CTL0_PG                BIT(0)                                        /*!< main flash program for bank0 command bit */
N#define FMC_CTL0_PER               BIT(1)                                        /*!< main flash page erase for bank0 command bit */
N#define FMC_CTL0_MER               BIT(2)                                        /*!< main flash mass erase for bank0 command bit */
N#define FMC_CTL0_OBPG              BIT(4)                                        /*!< option bytes program command bit */
N#define FMC_CTL0_OBER              BIT(5)                                        /*!< option bytes erase command bit */
N#define FMC_CTL0_START             BIT(6)                                        /*!< send erase command to FMC bit */
N#define FMC_CTL0_LK                BIT(7)                                        /*!< FMC_CTL0 lock bit */
N#define FMC_CTL0_OBWEN             BIT(9)                                        /*!< option bytes erase/program enable bit */
N#define FMC_CTL0_ERRIE             BIT(10)                                       /*!< error interrupt enable bit */
N#define FMC_CTL0_ENDIE             BIT(12)                                       /*!< end of operation interrupt enable bit */
N
N/* FMC_ADDR0 */
N#define FMC_ADDR0_ADDR             BITS(0,31)                                    /*!< flash erase/program command address bits */
N
N/* FMC_OBSTAT */
N#define FMC_OBSTAT_OBERR           BIT(0)                                        /*!< option bytes read error bit. */
N#define FMC_OBSTAT_SPC             BIT(1)                                        /*!< option bytes security protection code */
N#define FMC_OBSTAT_USER            BITS(2,9)                                     /*!< store USER of option bytes block after system reset */
N#define FMC_OBSTAT_DATA            BITS(10,25)                                   /*!< store DATA of option bytes block after system reset. */
N
N/* FMC_WP */
N#define FMC_WP_WP                  BITS(0,31)                                    /*!< store WP of option bytes block after system reset */
N
N/* FMC_KEY1 */
N#define FMC_KEY1_KEY               BITS(0,31)                                    /*!< FMC_CTL1 unlock key bits */
N
N/* FMC_STAT1 */
N#define FMC_STAT1_BUSY             BIT(0)                                        /*!< flash busy flag bit */
N#define FMC_STAT1_PGERR            BIT(2)                                        /*!< flash program error flag bit */
N#define FMC_STAT1_WPERR            BIT(4)                                        /*!< erase/program protection error flag bit */
N#define FMC_STAT1_ENDF             BIT(5)                                        /*!< end of operation flag bit */
N
N/* FMC_CTL1 */
N#define FMC_CTL1_PG                BIT(0)                                        /*!< main flash program for bank1 command bit */
N#define FMC_CTL1_PER               BIT(1)                                        /*!< main flash page erase for bank1 command bit */
N#define FMC_CTL1_MER               BIT(2)                                        /*!< main flash mass erase for bank1 command bit */
N#define FMC_CTL1_START             BIT(6)                                        /*!< send erase command to FMC bit */
N#define FMC_CTL1_LK                BIT(7)                                        /*!< FMC_CTL1 lock bit */
N#define FMC_CTL1_ERRIE             BIT(10)                                       /*!< error interrupt enable bit */
N#define FMC_CTL1_ENDIE             BIT(12)                                       /*!< end of operation interrupt enable bit */
N
N/* FMC_ADDR1 */
N#define FMC_ADDR1_ADDR             BITS(0,31)                                    /*!< flash erase/program command address bits */
N
N/* FMC_WSEN */
N#define FMC_WSEN_WSEN              BIT(0)                                        /*!< FMC wait state enable bit */
N
N/* FMC_PID */
N#define FMC_PID_PID                BITS(0,31)                                    /*!< product ID bits */
N
N/* constants definitions */
N/* define the FMC bit position and its register index offset */
N#define FMC_REGIDX_BIT(regidx, bitpos)              (((uint32_t)(regidx) << 6) | (uint32_t)(bitpos))
N#define FMC_REG_VAL(offset)                         (REG32(FMC + ((uint32_t)(offset) >> 6)))
N#define FMC_BIT_POS(val)                            ((uint32_t)(val) & 0x1FU)
N#define FMC_REGIDX_BITS(regidx, bitpos0, bitpos1)   (((uint32_t)(regidx) << 12) | ((uint32_t)(bitpos0) << 6) | (uint32_t)(bitpos1))
N#define FMC_REG_VALS(offset)                        (REG32(FMC + ((uint32_t)(offset) >> 12)))
N#define FMC_BIT_POS0(val)                           (((uint32_t)(val) >> 6) & 0x1FU)
N#define FMC_BIT_POS1(val)                           ((uint32_t)(val) & 0x1FU)
N#define FMC_REG_OFFSET_GET(flag)                    ((uint32_t)(flag) >> 12)
N
N/* configuration register */
N#define FMC_STAT0_REG_OFFSET             0x0CU                                   /*!< status register 0 offset */
N#define FMC_CTL0_REG_OFFSET              0x10U                                   /*!< control register 0 offset */
N#define FMC_STAT1_REG_OFFSET             0x4CU                                   /*!< status register 1 offset */
N#define FMC_CTL1_REG_OFFSET              0x50U                                   /*!< control register 1 offset */
N#define FMC_OBSTAT_REG_OFFSET            0x1CU                                   /*!< option byte status register offset */
N
N/* fmc state */
Ntypedef enum
N{
N    FMC_READY,                                                                   /*!< the operation has been completed */
N    FMC_BUSY,                                                                    /*!< the operation is in progress */
N    FMC_PGERR,                                                                   /*!< program error */
N    FMC_WPERR,                                                                   /*!< erase/program protection error */
N    FMC_TOERR,                                                                   /*!< timeout error */
N}fmc_state_enum;
N
N/* FMC interrupt enable */
Ntypedef enum
N{
N    FMC_INT_BANK0_END     = FMC_REGIDX_BIT(FMC_CTL0_REG_OFFSET, 12U),            /*!< enable FMC end of program interrupt */
X    FMC_INT_BANK0_END     = (((uint32_t)(0x10U) << 6) | (uint32_t)(12U)),             
N    FMC_INT_BANK0_ERR     = FMC_REGIDX_BIT(FMC_CTL0_REG_OFFSET, 10U),            /*!< enable FMC error interrupt */
X    FMC_INT_BANK0_ERR     = (((uint32_t)(0x10U) << 6) | (uint32_t)(10U)),             
N    FMC_INT_BANK1_END     = FMC_REGIDX_BIT(FMC_CTL1_REG_OFFSET, 12U),            /*!< enable FMC bank1 end of program interrupt */
X    FMC_INT_BANK1_END     = (((uint32_t)(0x50U) << 6) | (uint32_t)(12U)),             
N    FMC_INT_BANK1_ERR     = FMC_REGIDX_BIT(FMC_CTL1_REG_OFFSET, 10U),            /*!< enable FMC bank1 error interrupt */
X    FMC_INT_BANK1_ERR     = (((uint32_t)(0x50U) << 6) | (uint32_t)(10U)),             
N}fmc_int_enum;
N
N/* FMC flags */
Ntypedef enum
N{
N    FMC_FLAG_BANK0_BUSY   = FMC_REGIDX_BIT(FMC_STAT0_REG_OFFSET, 0U),            /*!< FMC bank0 busy flag */
X    FMC_FLAG_BANK0_BUSY   = (((uint32_t)(0x0CU) << 6) | (uint32_t)(0U)),             
N    FMC_FLAG_BANK0_PGERR  = FMC_REGIDX_BIT(FMC_STAT0_REG_OFFSET, 2U),            /*!< FMC bank0 operation error flag bit */
X    FMC_FLAG_BANK0_PGERR  = (((uint32_t)(0x0CU) << 6) | (uint32_t)(2U)),             
N    FMC_FLAG_BANK0_WPERR  = FMC_REGIDX_BIT(FMC_STAT0_REG_OFFSET, 4U),            /*!< FMC bank0 erase/program protection error flag bit */
X    FMC_FLAG_BANK0_WPERR  = (((uint32_t)(0x0CU) << 6) | (uint32_t)(4U)),             
N    FMC_FLAG_BANK0_END    = FMC_REGIDX_BIT(FMC_STAT0_REG_OFFSET, 5U),            /*!< FMC bank0 end of operation flag bit */
X    FMC_FLAG_BANK0_END    = (((uint32_t)(0x0CU) << 6) | (uint32_t)(5U)),             
N    FMC_FLAG_OBERR        = FMC_REGIDX_BIT(FMC_OBSTAT_REG_OFFSET, 0U),           /*!< FMC option bytes read error flag */
X    FMC_FLAG_OBERR        = (((uint32_t)(0x1CU) << 6) | (uint32_t)(0U)),            
N    FMC_FLAG_BANK1_BUSY   = FMC_REGIDX_BIT(FMC_STAT1_REG_OFFSET, 0U),            /*!< FMC bank1 busy flag */
X    FMC_FLAG_BANK1_BUSY   = (((uint32_t)(0x4CU) << 6) | (uint32_t)(0U)),             
N    FMC_FLAG_BANK1_PGERR  = FMC_REGIDX_BIT(FMC_STAT1_REG_OFFSET, 2U),            /*!< FMC bank1 operation error flag bit */
X    FMC_FLAG_BANK1_PGERR  = (((uint32_t)(0x4CU) << 6) | (uint32_t)(2U)),             
N    FMC_FLAG_BANK1_WPERR  = FMC_REGIDX_BIT(FMC_STAT1_REG_OFFSET, 4U),            /*!< FMC bank1 erase/program protection error flag bit */
X    FMC_FLAG_BANK1_WPERR  = (((uint32_t)(0x4CU) << 6) | (uint32_t)(4U)),             
N    FMC_FLAG_BANK1_END    = FMC_REGIDX_BIT(FMC_STAT1_REG_OFFSET, 5U),            /*!< FMC bank1 end of operation flag bit */
X    FMC_FLAG_BANK1_END    = (((uint32_t)(0x4CU) << 6) | (uint32_t)(5U)),             
N}fmc_flag_enum;
N
N/* FMC interrupt flags */
Ntypedef enum
N{
N    FMC_INT_FLAG_BANK0_PGERR  = FMC_REGIDX_BITS(FMC_STAT0_REG_OFFSET, 2U, 10U),  /*!< FMC bank0 operation error interrupt flag bit */
X    FMC_INT_FLAG_BANK0_PGERR  = (((uint32_t)(0x0CU) << 12) | ((uint32_t)(2U) << 6) | (uint32_t)(10U)),   
N    FMC_INT_FLAG_BANK0_WPERR  = FMC_REGIDX_BITS(FMC_STAT0_REG_OFFSET, 4U, 10U),  /*!< FMC bank0 erase/program protection error interrupt flag bit */
X    FMC_INT_FLAG_BANK0_WPERR  = (((uint32_t)(0x0CU) << 12) | ((uint32_t)(4U) << 6) | (uint32_t)(10U)),   
N    FMC_INT_FLAG_BANK0_END    = FMC_REGIDX_BITS(FMC_STAT0_REG_OFFSET, 5U, 12U),  /*!< FMC bank0 end of operation interrupt flag bit */
X    FMC_INT_FLAG_BANK0_END    = (((uint32_t)(0x0CU) << 12) | ((uint32_t)(5U) << 6) | (uint32_t)(12U)),   
N    FMC_INT_FLAG_BANK1_PGERR  = FMC_REGIDX_BITS(FMC_STAT1_REG_OFFSET, 2U, 10U),  /*!< FMC bank1 operation error interrupt flag bit */
X    FMC_INT_FLAG_BANK1_PGERR  = (((uint32_t)(0x4CU) << 12) | ((uint32_t)(2U) << 6) | (uint32_t)(10U)),   
N    FMC_INT_FLAG_BANK1_WPERR  = FMC_REGIDX_BITS(FMC_STAT1_REG_OFFSET, 4U, 10U),  /*!< FMC bank1 erase/program protection error interrupt flag bit */
X    FMC_INT_FLAG_BANK1_WPERR  = (((uint32_t)(0x4CU) << 12) | ((uint32_t)(4U) << 6) | (uint32_t)(10U)),   
N    FMC_INT_FLAG_BANK1_END    = FMC_REGIDX_BITS(FMC_STAT1_REG_OFFSET, 5U, 12U),  /*!< FMC bank1 end of operation interrupt flag bit */
X    FMC_INT_FLAG_BANK1_END    = (((uint32_t)(0x4CU) << 12) | ((uint32_t)(5U) << 6) | (uint32_t)(12U)),   
N}fmc_interrupt_flag_enum;
N
N/* unlock key */
N#define UNLOCK_KEY0                ((uint32_t)0x45670123U)                       /*!< unlock key 0 */
N#define UNLOCK_KEY1                ((uint32_t)0xCDEF89ABU)                       /*!< unlock key 1 */
N
N/* FMC wait state counter */
N#define WS_WSCNT(regval)           (BITS(0,2) & ((uint32_t)(regval)))
N#define WS_WSCNT_0                 WS_WSCNT(0)                                   /*!< FMC 0 wait */
N#define WS_WSCNT_1                 WS_WSCNT(1)                                   /*!< FMC 1 wait */
N#define WS_WSCNT_2                 WS_WSCNT(2)                                   /*!< FMC 2 wait */
N
N/* option bytes software/hardware free watch dog timer */  
N#define OB_FWDGT_SW                ((uint8_t)0x01U)                              /*!< software free watchdog */
N#define OB_FWDGT_HW                ((uint8_t)0x00U)                              /*!< hardware free watchdog */
N
N/* option bytes reset or not entering deep sleep mode */
N#define OB_DEEPSLEEP_NRST          ((uint8_t)0x02U)                              /*!< no reset when entering deepsleep mode */
N#define OB_DEEPSLEEP_RST           ((uint8_t)0x00U)                              /*!< generate a reset instead of entering deepsleep mode */
N
N/* option bytes reset or not entering standby mode */
N#define OB_STDBY_NRST              ((uint8_t)0x04U)                              /*!< no reset when entering deepsleep mode */
N#define OB_STDBY_RST               ((uint8_t)0x00U)                              /*!< generate a reset instead of entering standby mode */
N
N/* option bytes boot bank value */
N#define OB_BOOT_B0                 ((uint8_t)0x08U)                              /*!< boot from bank0 */
N#define OB_BOOT_B1                 ((uint8_t)0x00U)                              /*!< boot from bank1 */
N
N#define OB_USER_MASK               ((uint8_t)0xF0U)                              /*!< MASK value */
N
N/* read protect configure */
N#define FMC_NSPC                   ((uint8_t)0xA5U)                              /*!< no security protection */
N#define FMC_USPC                   ((uint8_t)0xBBU)                              /*!< under security protection */
N
N/* OB_SPC */
N#define OB_SPC_SPC                 ((uint32_t)0x000000FFU)                       /*!< option byte security protection value */
N#define OB_SPC_SPC_N               ((uint32_t)0x0000FF00U)                       /*!< option byte security protection complement value */
N
N/* OB_USER */
N#define OB_USER_USER               ((uint32_t)0x00FF0000U)                       /*!< user option value */
N#define OB_USER_USER_N             ((uint32_t)0xFF000000U)                       /*!< user option complement value */
N
N/* OB_WP0 */
N#define OB_WP0_WP0                 ((uint32_t)0x000000FFU)                       /*!< FMC write protection option value */
N
N/* OB_WP1 */
N#define OB_WP1_WP1                 ((uint32_t)0x0000FF00U)                       /*!< FMC write protection option complement value */
N
N/* OB_WP2 */
N#define OB_WP2_WP2                 ((uint32_t)0x00FF0000U)                       /*!< FMC write protection option value */
N
N/* OB_WP3 */
N#define OB_WP3_WP3                 ((uint32_t)0xFF000000U)                       /*!< FMC write protection option complement value */
N
N/* option bytes write protection */
N#define OB_WP_0                    ((uint32_t)0x00000001U)                       /*!< erase/program protection of sector 0  */
N#define OB_WP_1                    ((uint32_t)0x00000002U)                       /*!< erase/program protection of sector 1  */
N#define OB_WP_2                    ((uint32_t)0x00000004U)                       /*!< erase/program protection of sector 2  */
N#define OB_WP_3                    ((uint32_t)0x00000008U)                       /*!< erase/program protection of sector 3  */
N#define OB_WP_4                    ((uint32_t)0x00000010U)                       /*!< erase/program protection of sector 4  */
N#define OB_WP_5                    ((uint32_t)0x00000020U)                       /*!< erase/program protection of sector 5  */
N#define OB_WP_6                    ((uint32_t)0x00000040U)                       /*!< erase/program protection of sector 6  */
N#define OB_WP_7                    ((uint32_t)0x00000080U)                       /*!< erase/program protection of sector 7  */
N#define OB_WP_8                    ((uint32_t)0x00000100U)                       /*!< erase/program protection of sector 8  */
N#define OB_WP_9                    ((uint32_t)0x00000200U)                       /*!< erase/program protection of sector 9  */
N#define OB_WP_10                   ((uint32_t)0x00000400U)                       /*!< erase/program protection of sector 10 */
N#define OB_WP_11                   ((uint32_t)0x00000800U)                       /*!< erase/program protection of sector 11 */
N#define OB_WP_12                   ((uint32_t)0x00001000U)                       /*!< erase/program protection of sector 12 */
N#define OB_WP_13                   ((uint32_t)0x00002000U)                       /*!< erase/program protection of sector 13 */
N#define OB_WP_14                   ((uint32_t)0x00004000U)                       /*!< erase/program protection of sector 14 */
N#define OB_WP_15                   ((uint32_t)0x00008000U)                       /*!< erase/program protection of sector 15 */
N#define OB_WP_16                   ((uint32_t)0x00010000U)                       /*!< erase/program protection of sector 16 */
N#define OB_WP_17                   ((uint32_t)0x00020000U)                       /*!< erase/program protection of sector 17 */
N#define OB_WP_18                   ((uint32_t)0x00040000U)                       /*!< erase/program protection of sector 18 */
N#define OB_WP_19                   ((uint32_t)0x00080000U)                       /*!< erase/program protection of sector 19 */
N#define OB_WP_20                   ((uint32_t)0x00100000U)                       /*!< erase/program protection of sector 20 */
N#define OB_WP_21                   ((uint32_t)0x00200000U)                       /*!< erase/program protection of sector 21 */
N#define OB_WP_22                   ((uint32_t)0x00400000U)                       /*!< erase/program protection of sector 22 */
N#define OB_WP_23                   ((uint32_t)0x00800000U)                       /*!< erase/program protection of sector 23 */
N#define OB_WP_24                   ((uint32_t)0x01000000U)                       /*!< erase/program protection of sector 24 */
N#define OB_WP_25                   ((uint32_t)0x02000000U)                       /*!< erase/program protection of sector 25 */
N#define OB_WP_26                   ((uint32_t)0x04000000U)                       /*!< erase/program protection of sector 26 */
N#define OB_WP_27                   ((uint32_t)0x08000000U)                       /*!< erase/program protection of sector 27 */
N#define OB_WP_28                   ((uint32_t)0x10000000U)                       /*!< erase/program protection of sector 28 */
N#define OB_WP_29                   ((uint32_t)0x20000000U)                       /*!< erase/program protection of sector 29 */
N#define OB_WP_30                   ((uint32_t)0x40000000U)                       /*!< erase/program protection of sector 30 */
N#define OB_WP_31                   ((uint32_t)0x80000000U)                       /*!< erase/program protection of sector 31 */
N#define OB_WP_ALL                  ((uint32_t)0xFFFFFFFFU)                       /*!< erase/program protection of all sectors */
N
N/* FMC timeout */
N#define FMC_TIMEOUT_COUNT          ((uint32_t)0x000F0000U)                       /*!< FMC timeout count value */
N
N/* FMC BANK address */
N#define FMC_BANK0_END_ADDRESS      ((uint32_t)0x0807FFFFU)                       /*!< FMC bank0 end address */
N#define FMC_BANK0_SIZE             ((uint32_t)0x00000200U)                       /*!< FMC bank0 size */
N#define FMC_SIZE                   (*(uint16_t *)0x1FFFF7E0U)                    /*!< FMC size */
N
N/* function declarations */
N/* FMC main memory programming functions */
N/* set the FMC wait state counter */
Nvoid fmc_wscnt_set(uint32_t wscnt);
N/* unlock the main FMC operation */
Nvoid fmc_unlock(void);
N/* unlock the FMC bank0 operation */
Nvoid fmc_bank0_unlock(void);
N/* unlock the FMC bank1 operation */
Nvoid fmc_bank1_unlock(void);
N/* lock the main FMC operation */
Nvoid fmc_lock(void);
N/* lock the bank0 FMC operation */
Nvoid fmc_bank0_lock(void);
N/* lock the bank1 FMC operation */
Nvoid fmc_bank1_lock(void);
N/* FMC erase page */
Nfmc_state_enum fmc_page_erase(uint32_t page_address);
N/* FMC erase whole chip */
Nfmc_state_enum fmc_mass_erase(void);
N/* FMC erase whole bank0 */
Nfmc_state_enum fmc_bank0_erase(void);
N/* FMC erase whole bank1 */
Nfmc_state_enum fmc_bank1_erase(void);
N/* FMC program a word at the corresponding address */
Nfmc_state_enum fmc_word_program(uint32_t address, uint32_t data);
N/* FMC program a half word at the corresponding address */
Nfmc_state_enum fmc_halfword_program(uint32_t address, uint16_t data);
N
N/* FMC option bytes programming functions */
N/* unlock the option byte operation */
Nvoid ob_unlock(void);
N/* lock the option byte operation */
Nvoid ob_lock(void);
N/* erase the option byte */
Nfmc_state_enum ob_erase(void);
N/* enable write protect */
Nfmc_state_enum ob_write_protection_enable(uint32_t ob_wp);
N/* configure the option byte security protection */
Nfmc_state_enum ob_security_protection_config(uint8_t ob_spc);
N/* write the FMC option byte */
Nfmc_state_enum ob_user_write(uint8_t ob_fwdgt, uint8_t ob_deepsleep, uint8_t ob_stdby, uint8_t ob_boot);
N/* program option bytes data */
Nfmc_state_enum ob_data_program(uint32_t address, uint8_t data);
N/* get the FMC option byte user */
Nuint8_t ob_user_get(void);
N/* get OB_DATA in register FMC_OBSTAT */
Nuint16_t ob_data_get(void);
N/* get the FMC option byte write protection */
Nuint32_t ob_write_protection_get(void);
N/* get option byte security protection code value */
NFlagStatus ob_spc_get(void);
N
N/* FMC interrupts and flags management functions */
N/* enable FMC interrupt */
Nvoid fmc_interrupt_enable(uint32_t interrupt);
N/* disable FMC interrupt */
Nvoid fmc_interrupt_disable(uint32_t interrupt);
N/* check flag is set or not */
NFlagStatus fmc_flag_get(uint32_t flag);
N/* clear the FMC flag */
Nvoid fmc_flag_clear(uint32_t flag);
N/* get FMC interrupt flag state */
NFlagStatus fmc_interrupt_flag_get(fmc_interrupt_flag_enum flag);
N/* clear FMC interrupt flag state */
Nvoid fmc_interrupt_flag_clear(fmc_interrupt_flag_enum flag);
N/* return the  FMC bank0 state */
Nfmc_state_enum fmc_bank0_state_get(void);
N/* return the  FMC bank1 state */
Nfmc_state_enum fmc_bank1_state_get(void);
N/* check FMC bank0 ready or not */
Nfmc_state_enum fmc_bank0_ready_wait(uint32_t timeout);
N/* check FMC bank1 ready or not */
Nfmc_state_enum fmc_bank1_ready_wait(uint32_t timeout);
N
N#endif /* GD32F10X_FMC_H */
L 43 ".\User\gd32f10x_libopt.h" 2
N#include "gd32f10x_pmu.h"
L 1 ".\Libraries\inc\gd32f10x_pmu.h" 1
N/*!
N    \file  gd32f10x_pmu.h
N    \brief definitions for the PMU
N
N    \version 2014-12-26, V1.0.0, firmware for GD32F10x
N    \version 2017-06-20, V2.0.0, firmware for GD32F10x
N    \version 2018-07-31, V2.1.0, firmware for GD32F10x
N*/
N
N/*
N    Copyright (c) 2018, GigaDevice Semiconductor Inc.
N
N    All rights reserved.
N
N    Redistribution and use in source and binary forms, with or without modification, 
Nare permitted provided that the following conditions are met:
N
N    1. Redistributions of source code must retain the above copyright notice, this 
N       list of conditions and the following disclaimer.
N    2. Redistributions in binary form must reproduce the above copyright notice, 
N       this list of conditions and the following disclaimer in the documentation 
N       and/or other materials provided with the distribution.
N    3. Neither the name of the copyright holder nor the names of its contributors 
N       may be used to endorse or promote products derived from this software without 
N       specific prior written permission.
N
N    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
NAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
NWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
NIN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
NINDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
NNOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
NPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
NWHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
NARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
NOF SUCH DAMAGE.
N*/
N
N#ifndef GD32F10X_PMU_H
N#define GD32F10X_PMU_H
N
N#include "gd32f10x.h"
N
N/* PMU definitions */
N#define PMU                           PMU_BASE                 /*!< PMU base address */
N
N/* registers definitions */
N#define PMU_CTL                       REG32((PMU) + 0x00U)     /*!< PMU control register */
N#define PMU_CS                        REG32((PMU) + 0x04U)     /*!< PMU control and status register */
N
N/* bits definitions */
N/* PMU_CTL */
N#define PMU_CTL_LDOLP                 BIT(0)                   /*!< LDO low power mode */
N#define PMU_CTL_STBMOD                BIT(1)                   /*!< standby mode */
N#define PMU_CTL_WURST                 BIT(2)                   /*!< wakeup flag reset */
N#define PMU_CTL_STBRST                BIT(3)                   /*!< standby flag reset */
N#define PMU_CTL_LVDEN                 BIT(4)                   /*!< low voltage detector enable */
N#define PMU_CTL_LVDT                  BITS(5,7)                /*!< low voltage detector threshold */
N#define PMU_CTL_BKPWEN                BIT(8)                   /*!< backup domain write enable */
N
N/* PMU_CS */
N#define PMU_CS_WUF                    BIT(0)                   /*!< wakeup flag */
N#define PMU_CS_STBF                   BIT(1)                   /*!< standby flag */
N#define PMU_CS_LVDF                   BIT(2)                   /*!< low voltage detector status flag */
N#define PMU_CS_WUPEN                  BIT(8)                   /*!< wakeup pin enable */
N
N/* constants definitions */
N/* PMU low voltage detector threshold definitions */
N#define CTL_LVDT(regval)              (BITS(5,7)&((uint32_t)(regval) << 5))
N#define PMU_LVDT_0                    CTL_LVDT(0)              /*!< voltage threshold is 2.2V */
N#define PMU_LVDT_1                    CTL_LVDT(1)              /*!< voltage threshold is 2.3V */
N#define PMU_LVDT_2                    CTL_LVDT(2)              /*!< voltage threshold is 2.4V */
N#define PMU_LVDT_3                    CTL_LVDT(3)              /*!< voltage threshold is 2.5V */
N#define PMU_LVDT_4                    CTL_LVDT(4)              /*!< voltage threshold is 2.6V */
N#define PMU_LVDT_5                    CTL_LVDT(5)              /*!< voltage threshold is 2.7V */
N#define PMU_LVDT_6                    CTL_LVDT(6)              /*!< voltage threshold is 2.8V */
N#define PMU_LVDT_7                    CTL_LVDT(7)              /*!< voltage threshold is 2.9V */
N
N/* PMU flag definitions */
N#define PMU_FLAG_WAKEUP               PMU_CS_WUF               /*!< wakeup flag status */
N#define PMU_FLAG_STANDBY              PMU_CS_STBF              /*!< standby flag status */
N#define PMU_FLAG_LVD                  PMU_CS_LVDF              /*!< lvd flag status */
N
N/* PMU ldo definitions */
N#define PMU_LDO_NORMAL                ((uint32_t)0x00000000U)  /*!< LDO normal work when PMU enter deepsleep mode */
N#define PMU_LDO_LOWPOWER              PMU_CTL_LDOLP            /*!< LDO work at low power status when PMU enter deepsleep mode */
N
N/* PMU flag reset definitions */
N#define PMU_FLAG_RESET_WAKEUP         ((uint8_t)0x00U)         /*!< wakeup flag reset */
N#define PMU_FLAG_RESET_STANDBY        ((uint8_t)0x01U)         /*!< standby flag reset */
N
N/* PMU command constants definitions */
N#define WFI_CMD                       ((uint8_t)0x00U)         /*!< use WFI command */
N#define WFE_CMD                       ((uint8_t)0x01U)         /*!< use WFE command */
N
N/* function declarations */
N/* reset PMU registers */
Nvoid pmu_deinit(void);
N
N/* select low voltage detector threshold */
Nvoid pmu_lvd_select(uint32_t lvdt_n);
N/* disable PMU lvd */
Nvoid pmu_lvd_disable(void);
N
N/* set PMU mode */
N/* PMU work at sleep mode */
Nvoid pmu_to_sleepmode(uint8_t sleepmodecmd);
N/* PMU work at deepsleep mode */
Nvoid pmu_to_deepsleepmode(uint32_t ldo, uint8_t deepsleepmodecmd);
N/* PMU work at standby mode */
Nvoid pmu_to_standbymode(uint8_t standbymodecmd);
N/* enable PMU wakeup pin */
Nvoid pmu_wakeup_pin_enable(void);
N/* disable PMU wakeup pin */
Nvoid pmu_wakeup_pin_disable(void);
N
N/* backup related functions */
N/* enable write access to the registers in backup domain */
Nvoid pmu_backup_write_enable(void);
N/* disable write access to the registers in backup domain */
Nvoid pmu_backup_write_disable(void);
N
N/* flag functions */
N/* get flag state */
NFlagStatus pmu_flag_get(uint32_t flag);
N/* clear flag bit */
Nvoid pmu_flag_clear(uint32_t flag_reset);
N
N#endif /* GD32F10X_PMU_H */
L 44 ".\User\gd32f10x_libopt.h" 2
N#include "gd32f10x_bkp.h"
L 1 ".\Libraries\inc\gd32f10x_bkp.h" 1
N/*!
N    \file  gd32f10x_bkp.h
N    \brief definitions for the BKP
N
N    \version 2014-12-26, V1.0.0, firmware for GD32F10x
N    \version 2017-06-20, V2.0.0, firmware for GD32F10x
N    \version 2018-07-31, V2.1.0, firmware for GD32F10x
N*/
N
N/*
N    Copyright (c) 2018, GigaDevice Semiconductor Inc.
N
N    All rights reserved.
N
N    Redistribution and use in source and binary forms, with or without modification, 
Nare permitted provided that the following conditions are met:
N
N    1. Redistributions of source code must retain the above copyright notice, this 
N       list of conditions and the following disclaimer.
N    2. Redistributions in binary form must reproduce the above copyright notice, 
N       this list of conditions and the following disclaimer in the documentation 
N       and/or other materials provided with the distribution.
N    3. Neither the name of the copyright holder nor the names of its contributors 
N       may be used to endorse or promote products derived from this software without 
N       specific prior written permission.
N
N    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
NAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
NWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
NIN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
NINDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
NNOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
NPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
NWHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
NARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
NOF SUCH DAMAGE.
N*/
N
N#ifndef GD32F10X_BKP_H
N#define GD32F10X_BKP_H
N
N#include "gd32f10x.h"
N
N/* BKP definitions */
N#define BKP                             BKP_BASE                 /*!< BKP base address */
N
N/* registers definitions */
N#define BKP_DATA0                       REG16((BKP) + 0x04U)     /*!< BKP data register 0 */
N#define BKP_DATA1                       REG16((BKP) + 0x08U)     /*!< BKP data register 1 */
N#define BKP_DATA2                       REG16((BKP) + 0x0CU)     /*!< BKP data register 2 */
N#define BKP_DATA3                       REG16((BKP) + 0x10U)     /*!< BKP data register 3 */
N#define BKP_DATA4                       REG16((BKP) + 0x14U)     /*!< BKP data register 4 */
N#define BKP_DATA5                       REG16((BKP) + 0x18U)     /*!< BKP data register 5 */
N#define BKP_DATA6                       REG16((BKP) + 0x1CU)     /*!< BKP data register 6 */
N#define BKP_DATA7                       REG16((BKP) + 0x20U)     /*!< BKP data register 7 */
N#define BKP_DATA8                       REG16((BKP) + 0x24U)     /*!< BKP data register 8 */
N#define BKP_DATA9                       REG16((BKP) + 0x28U)     /*!< BKP data register 9 */
N#define BKP_DATA10                      REG16((BKP) + 0x40U)     /*!< BKP data register 10 */
N#define BKP_DATA11                      REG16((BKP) + 0x44U)     /*!< BKP data register 11 */
N#define BKP_DATA12                      REG16((BKP) + 0x48U)     /*!< BKP data register 12 */
N#define BKP_DATA13                      REG16((BKP) + 0x4CU)     /*!< BKP data register 13 */
N#define BKP_DATA14                      REG16((BKP) + 0x50U)     /*!< BKP data register 14 */
N#define BKP_DATA15                      REG16((BKP) + 0x54U)     /*!< BKP data register 15 */
N#define BKP_DATA16                      REG16((BKP) + 0x58U)     /*!< BKP data register 16 */
N#define BKP_DATA17                      REG16((BKP) + 0x5CU)     /*!< BKP data register 17 */
N#define BKP_DATA18                      REG16((BKP) + 0x60U)     /*!< BKP data register 18 */
N#define BKP_DATA19                      REG16((BKP) + 0x64U)     /*!< BKP data register 19 */
N#define BKP_DATA20                      REG16((BKP) + 0x68U)     /*!< BKP data register 20 */
N#define BKP_DATA21                      REG16((BKP) + 0x6CU)     /*!< BKP data register 21 */
N#define BKP_DATA22                      REG16((BKP) + 0x70U)     /*!< BKP data register 22 */
N#define BKP_DATA23                      REG16((BKP) + 0x74U)     /*!< BKP data register 23 */
N#define BKP_DATA24                      REG16((BKP) + 0x78U)     /*!< BKP data register 24 */
N#define BKP_DATA25                      REG16((BKP) + 0x7CU)     /*!< BKP data register 25 */
N#define BKP_DATA26                      REG16((BKP) + 0x80U)     /*!< BKP data register 26 */
N#define BKP_DATA27                      REG16((BKP) + 0x84U)     /*!< BKP data register 27 */
N#define BKP_DATA28                      REG16((BKP) + 0x88U)     /*!< BKP data register 28 */
N#define BKP_DATA29                      REG16((BKP) + 0x8CU)     /*!< BKP data register 29 */
N#define BKP_DATA30                      REG16((BKP) + 0x90U)     /*!< BKP data register 30 */
N#define BKP_DATA31                      REG16((BKP) + 0x94U)     /*!< BKP data register 31 */
N#define BKP_DATA32                      REG16((BKP) + 0x98U)     /*!< BKP data register 32 */
N#define BKP_DATA33                      REG16((BKP) + 0x9CU)     /*!< BKP data register 33 */
N#define BKP_DATA34                      REG16((BKP) + 0xA0U)     /*!< BKP data register 34 */
N#define BKP_DATA35                      REG16((BKP) + 0xA4U)     /*!< BKP data register 35 */
N#define BKP_DATA36                      REG16((BKP) + 0xA8U)     /*!< BKP data register 36 */
N#define BKP_DATA37                      REG16((BKP) + 0xACU)     /*!< BKP data register 37 */
N#define BKP_DATA38                      REG16((BKP) + 0xB0U)     /*!< BKP data register 38 */
N#define BKP_DATA39                      REG16((BKP) + 0xB4U)     /*!< BKP data register 39 */
N#define BKP_DATA40                      REG16((BKP) + 0xB8U)     /*!< BKP data register 40 */
N#define BKP_DATA41                      REG16((BKP) + 0xBCU)     /*!< BKP data register 41 */
N#define BKP_OCTL                        REG16((BKP) + 0x2CU)     /*!< RTC signal output control register */
N#define BKP_TPCTL                       REG16((BKP) + 0x30U)     /*!< tamper pin control register */
N#define BKP_TPCS                        REG16((BKP) + 0x34U)     /*!< tamper control and status register */
N
N/* bits definitions */
N/* BKP_DATA */
N#define BKP_DATA                        BITS(0,15)               /*!< backup data */
N
N/* BKP_OCTL */
N#define BKP_OCTL_RCCV                   BITS(0,6)                /*!< RTC clock calibration value */
N#define BKP_OCTL_COEN                   BIT(7)                   /*!< RTC clock calibration output enable */
N#define BKP_OCTL_ASOEN                  BIT(8)                   /*!< RTC alarm or second signal output enable */
N#define BKP_OCTL_ROSEL                  BIT(9)                   /*!< RTC output selection */
N
N/* BKP_TPCTL */
N#define BKP_TPCTL_TPEN                  BIT(0)                   /*!< tamper detection enable */
N#define BKP_TPCTL_TPAL                  BIT(1)                   /*!< tamper pin active level */
N
N/* BKP_TPCS */
N#define BKP_TPCS_TER                    BIT(0)                   /*!< tamper event reset */
N#define BKP_TPCS_TIR                    BIT(1)                   /*!< tamper interrupt reset */
N#define BKP_TPCS_TPIE                   BIT(2)                   /*!< tamper interrupt enable */
N#define BKP_TPCS_TEF                    BIT(8)                   /*!< tamper event flag */
N#define BKP_TPCS_TIF                    BIT(9)                   /*!< tamper interrupt flag */
N
N/* constants definitions */
N/* BKP data register number */
Ntypedef enum 
N{
N    BKP_DATA_0 = 1,                                              /*!< BKP data register 0 */
N    BKP_DATA_1,                                                  /*!< BKP data register 1 */
N    BKP_DATA_2,                                                  /*!< BKP data register 2 */
N    BKP_DATA_3,                                                  /*!< BKP data register 3 */
N    BKP_DATA_4,                                                  /*!< BKP data register 4 */
N    BKP_DATA_5,                                                  /*!< BKP data register 5 */
N    BKP_DATA_6,                                                  /*!< BKP data register 6 */
N    BKP_DATA_7,                                                  /*!< BKP data register 7 */
N    BKP_DATA_8,                                                  /*!< BKP data register 8 */
N    BKP_DATA_9,                                                  /*!< BKP data register 9 */
N    BKP_DATA_10,                                                 /*!< BKP data register 10 */
N    BKP_DATA_11,                                                 /*!< BKP data register 11 */
N    BKP_DATA_12,                                                 /*!< BKP data register 12 */
N    BKP_DATA_13,                                                 /*!< BKP data register 13 */
N    BKP_DATA_14,                                                 /*!< BKP data register 14 */
N    BKP_DATA_15,                                                 /*!< BKP data register 15 */
N    BKP_DATA_16,                                                 /*!< BKP data register 16 */
N    BKP_DATA_17,                                                 /*!< BKP data register 17 */
N    BKP_DATA_18,                                                 /*!< BKP data register 18 */
N    BKP_DATA_19,                                                 /*!< BKP data register 19 */
N    BKP_DATA_20,                                                 /*!< BKP data register 20 */
N    BKP_DATA_21,                                                 /*!< BKP data register 21 */
N    BKP_DATA_22,                                                 /*!< BKP data register 22 */
N    BKP_DATA_23,                                                 /*!< BKP data register 23 */
N    BKP_DATA_24,                                                 /*!< BKP data register 24 */
N    BKP_DATA_25,                                                 /*!< BKP data register 25 */
N    BKP_DATA_26,                                                 /*!< BKP data register 26 */
N    BKP_DATA_27,                                                 /*!< BKP data register 27 */
N    BKP_DATA_28,                                                 /*!< BKP data register 28 */
N    BKP_DATA_29,                                                 /*!< BKP data register 29 */
N    BKP_DATA_30,                                                 /*!< BKP data register 30 */
N    BKP_DATA_31,                                                 /*!< BKP data register 31 */
N    BKP_DATA_32,                                                 /*!< BKP data register 32 */
N    BKP_DATA_33,                                                 /*!< BKP data register 33 */
N    BKP_DATA_34,                                                 /*!< BKP data register 34 */
N    BKP_DATA_35,                                                 /*!< BKP data register 35 */
N    BKP_DATA_36,                                                 /*!< BKP data register 36 */
N    BKP_DATA_37,                                                 /*!< BKP data register 37 */
N    BKP_DATA_38,                                                 /*!< BKP data register 38 */
N    BKP_DATA_39,                                                 /*!< BKP data register 39 */
N    BKP_DATA_40,                                                 /*!< BKP data register 40 */
N    BKP_DATA_41,                                                 /*!< BKP data register 41 */
N}bkp_data_register_enum;
N
N/* BKP register */
N#define BKP_DATA0_9(number)             REG16((BKP) + 0x04U + (number) * 0x04U)
N#define BKP_DATA10_41(number)           REG16((BKP) + 0x40U + ((number)-10U) * 0x04U)
N
N/* get data of BKP data register */
N#define BKP_DATA_GET(regval)            GET_BITS((uint32_t)(regval), 0, 15)
N
N/* RTC clock calibration value */
N#define OCTL_RCCV(regval)               (BITS(0,6) & ((uint32_t)(regval) << 0))
N
N/* RTC output selection */
N#define RTC_OUTPUT_ALARM_PULSE          ((uint16_t)0x0000U)      /*!< RTC alarm pulse is selected as the RTC output */
N#define RTC_OUTPUT_SECOND_PULSE         ((uint16_t)0x0200U)      /*!< RTC second pulse is selected as the RTC output */
N
N/* tamper pin active level */
N#define TAMPER_PIN_ACTIVE_HIGH          ((uint16_t)0x0000U)      /*!< the tamper pin is active high */
N#define TAMPER_PIN_ACTIVE_LOW           ((uint16_t)0x0002U)      /*!< the tamper pin is active low */
N
N/* tamper flag */
N#define BKP_FLAG_TAMPER                 BKP_TPCS_TEF             /*!< tamper event flag */
N
N/* tamper interrupt flag */
N#define BKP_INT_FLAG_TAMPER             BKP_TPCS_TIF             /*!< tamper interrupt flag */
N/* function declarations */
N/* reset BKP registers */
Nvoid bkp_deinit(void);
N/* write BKP data register */
Nvoid bkp_data_write(bkp_data_register_enum register_number, uint16_t data);
N/* read BKP data register */
Nuint16_t bkp_data_read(bkp_data_register_enum register_number);
N
N/* RTC related functions */
N/* enable RTC clock calibration output */
Nvoid bkp_rtc_calibration_output_enable(void);
N/* disable RTC clock calibration output */
Nvoid bkp_rtc_calibration_output_disable(void);
N/* enable RTC alarm or second signal output */
Nvoid bkp_rtc_signal_output_enable(void);
N/* disable RTC alarm or second signal output */
Nvoid bkp_rtc_signal_output_disable(void);
N/* select RTC output */
Nvoid bkp_rtc_output_select(uint16_t outputsel);
N/* set RTC clock calibration value */
Nvoid bkp_rtc_calibration_value_set(uint8_t value);
N
N/* tamper pin related functions */
N/* enable tamper pin detection */
Nvoid bkp_tamper_detection_enable(void);
N/* disable tamper pin detection */
Nvoid bkp_tamper_detection_disable(void);
N/* set tamper pin active level */
Nvoid bkp_tamper_active_level_set(uint16_t level);
N
N/* interrupt & flag functions */
N/* enable tamper interrupt */
Nvoid bkp_interrupt_enable(void);
N/* disable tamper interrupt */
Nvoid bkp_interrupt_disable(void);
N/* get tamper flag state */
NFlagStatus bkp_flag_get(void);
N/* clear tamper flag state */
Nvoid bkp_flag_clear(void);
N/* get tamper interrupt flag state */
NFlagStatus bkp_interrupt_flag_get(void);
N/* clear tamper interrupt flag state */
Nvoid bkp_interrupt_flag_clear(void);
N
N#endif /* GD32F10X_BKP_H */
L 45 ".\User\gd32f10x_libopt.h" 2
N#include "gd32f10x_rcu.h"
L 1 ".\Libraries\inc\gd32f10x_rcu.h" 1
N/*!
N    \file    gd32f10x_rcu.h
N    \brief   definitions for the RCU
N    
N    \version 2014-12-26, V1.0.0, firmware for GD32F10x
N    \version 2017-06-20, V2.0.0, firmware for GD32F10x
N    \version 2018-07-31, V2.1.0, firmware for GD32F10x
N*/
N
N/*
N    Copyright (c) 2018, GigaDevice Semiconductor Inc.
N
N    All rights reserved.
N
N    Redistribution and use in source and binary forms, with or without modification, 
Nare permitted provided that the following conditions are met:
N
N    1. Redistributions of source code must retain the above copyright notice, this 
N       list of conditions and the following disclaimer.
N    2. Redistributions in binary form must reproduce the above copyright notice, 
N       this list of conditions and the following disclaimer in the documentation 
N       and/or other materials provided with the distribution.
N    3. Neither the name of the copyright holder nor the names of its contributors 
N       may be used to endorse or promote products derived from this software without 
N       specific prior written permission.
N
N    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
NAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
NWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
NIN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
NINDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
NNOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
NPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
NWHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
NARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
NOF SUCH DAMAGE.
N*/
N
N#ifndef GD32F10X_RCU_H
N#define GD32F10X_RCU_H
N
N#include "gd32f10x.h"
N
N/* RCU definitions */
N#define RCU                             RCU_BASE
N
N/* registers definitions */
N#if (defined(GD32F10X_MD) || defined(GD32F10X_HD) || defined(GD32F10X_XD))
X#if (0L || 0L || 1L)
N#define RCU_CTL                         REG32(RCU + 0x00U)        /*!< control register */
N#define RCU_CFG0                        REG32(RCU + 0x04U)        /*!< clock configuration register 0 */
N#define RCU_INT                         REG32(RCU + 0x08U)        /*!< clock interrupt register */
N#define RCU_APB2RST                     REG32(RCU + 0x0CU)        /*!< APB2 reset register */
N#define RCU_APB1RST                     REG32(RCU + 0x10U)        /*!< APB1 reset register */
N#define RCU_AHBEN                       REG32(RCU + 0x14U)        /*!< AHB enable register */
N#define RCU_APB2EN                      REG32(RCU + 0x18U)        /*!< APB2 enable register */
N#define RCU_APB1EN                      REG32(RCU + 0x1CU)        /*!< APB1 enable register */
N#define RCU_BDCTL                       REG32(RCU + 0x20U)        /*!< backup domain control register */
N#define RCU_RSTSCK                      REG32(RCU + 0x24U)        /*!< reset source / clock register */
N#define RCU_DSV                         REG32(RCU + 0x34U)        /*!< deep-sleep mode voltage register */
N#elif defined(GD32F10X_CL)
S#define RCU_CTL                         REG32(RCU + 0x00U)        /*!< control register */
S#define RCU_CFG0                        REG32(RCU + 0x04U)        /*!< clock configuration register 0 */
S#define RCU_INT                         REG32(RCU + 0x08U)        /*!< clock interrupt register */
S#define RCU_APB2RST                     REG32(RCU + 0x0CU)        /*!< APB2 reset register */
S#define RCU_APB1RST                     REG32(RCU + 0x10U)        /*!< APB1 reset register */
S#define RCU_AHBEN                       REG32(RCU + 0x14U)        /*!< AHB1 enable register */
S#define RCU_APB2EN                      REG32(RCU + 0x18U)        /*!< APB2 enable register */
S#define RCU_APB1EN                      REG32(RCU + 0x1CU)        /*!< APB1 enable register */
S#define RCU_BDCTL                       REG32(RCU + 0x20U)        /*!< backup domain control register */
S#define RCU_RSTSCK                      REG32(RCU + 0x24U)        /*!< reset source / clock register */
S#define RCU_AHBRST                      REG32(RCU + 0x28U)        /*!< AHB reset register */
S#define RCU_CFG1                        REG32(RCU + 0x2CU)        /*!< clock configuration register 1 */
S#define RCU_DSV                         REG32(RCU + 0x34U)        /*!< deep-sleep mode voltage register */
N#endif /* GD32F10X_MD and GD32F10X_HD and GD32F10X_XD */
N
N/* bits definitions */
N/* RCU_CTL */
N#if (defined(GD32F10X_MD) || defined(GD32F10X_HD) || defined(GD32F10X_XD))
X#if (0L || 0L || 1L)
N#define RCU_CTL_IRC8MEN                 BIT(0)                    /*!< internal high speed oscillator enable */
N#define RCU_CTL_IRC8MSTB                BIT(1)                    /*!< IRC8M high speed internal oscillator stabilization flag */
N#define RCU_CTL_IRC8MADJ                BITS(3,7)                 /*!< high speed internal oscillator clock trim adjust value */
N#define RCU_CTL_IRC8MCALIB              BITS(8,15)                /*!< high speed internal oscillator calibration value register */
N#define RCU_CTL_HXTALEN                 BIT(16)                   /*!< external high speed oscillator enable */
N#define RCU_CTL_HXTALSTB                BIT(17)                   /*!< external crystal oscillator clock stabilization flag */
N#define RCU_CTL_HXTALBPS                BIT(18)                   /*!< external crystal oscillator clock bypass mode enable */
N#define RCU_CTL_CKMEN                   BIT(19)                   /*!< HXTAL clock monitor enable */
N#define RCU_CTL_PLLEN                   BIT(24)                   /*!< PLL enable */
N#define RCU_CTL_PLLSTB                  BIT(25)                   /*!< PLL clock stabilization flag */
N#elif defined(GD32F10X_CL)
S#define RCU_CTL_IRC8MEN                 BIT(0)                    /*!< internal high speed oscillator enable */
S#define RCU_CTL_IRC8MSTB                BIT(1)                    /*!< IRC8M high speed internal oscillator stabilization flag */
S#define RCU_CTL_IRC8MADJ                BITS(3,7)                 /*!< high speed internal oscillator clock trim adjust value */
S#define RCU_CTL_IRC8MCALIB              BITS(8,15)                /*!< high speed internal oscillator calibration value register */
S#define RCU_CTL_HXTALEN                 BIT(16)                   /*!< external high speed oscillator enable */
S#define RCU_CTL_HXTALSTB                BIT(17)                   /*!< external crystal oscillator clock stabilization flag */
S#define RCU_CTL_HXTALBPS                BIT(18)                   /*!< external crystal oscillator clock bypass mode enable */
S#define RCU_CTL_CKMEN                   BIT(19)                   /*!< HXTAL clock monitor enable */
S#define RCU_CTL_PLLEN                   BIT(24)                   /*!< PLL enable */
S#define RCU_CTL_PLLSTB                  BIT(25)                   /*!< PLL clock stabilization flag */
S#define RCU_CTL_PLL1EN                  BIT(26)                   /*!< PLL1 enable */
S#define RCU_CTL_PLL1STB                 BIT(27)                   /*!< PLL1 clock stabilization flag */
S#define RCU_CTL_PLL2EN                  BIT(28)                   /*!< PLL2 enable */
S#define RCU_CTL_PLL2STB                 BIT(29)                   /*!< PLL2 clock stabilization flag */
N#endif /* GD32F10X_MD and GD32F10X_HD and GD32F10X_XD */
N
N/* RCU_CFG0 */
N#if (defined(GD32F10X_MD) || defined(GD32F10X_HD) || defined(GD32F10X_XD))
X#if (0L || 0L || 1L)
N#define RCU_CFG0_SCS                    BITS(0,1)                 /*!< system clock switch */
N#define RCU_CFG0_SCSS                   BITS(2,3)                 /*!< system clock switch status */
N#define RCU_CFG0_AHBPSC                 BITS(4,7)                 /*!< AHB prescaler selection */
N#define RCU_CFG0_APB1PSC                BITS(8,10)                /*!< APB1 prescaler selection */
N#define RCU_CFG0_APB2PSC                BITS(11,13)               /*!< APB2 prescaler selection */
N#define RCU_CFG0_ADCPSC                 BITS(14,15)               /*!< ADC prescaler selection */
N#define RCU_CFG0_PLLSEL                 BIT(16)                   /*!< PLL clock source selection */
N#define RCU_CFG0_PREDV0                 BIT(17)                   /*!< PREDV0 division factor */
N#define RCU_CFG0_PLLMF                  BITS(18,21)               /*!< PLL clock multiplication factor */
N#define RCU_CFG0_USBDPSC                BITS(22,23)               /*!< USBD clock prescaler selection */
N#define RCU_CFG0_CKOUT0SEL              BITS(24,26)               /*!< CKOUT0 clock source selection */
N#define RCU_CFG0_PLLMF_4                BIT(27)                   /*!< bit 4 of PLLMF */
N#define RCU_CFG0_ADCPSC_2               BIT(28)                   /*!< bit 2 of ADCPSC */
N#elif defined(GD32F10X_CL)
S#define RCU_CFG0_SCS                    BITS(0,1)                 /*!< system clock switch */
S#define RCU_CFG0_SCSS                   BITS(2,3)                 /*!< system clock switch status */
S#define RCU_CFG0_AHBPSC                 BITS(4,7)                 /*!< AHB prescaler selection */
S#define RCU_CFG0_APB1PSC                BITS(8,10)                /*!< APB1 prescaler selection */
S#define RCU_CFG0_APB2PSC                BITS(11,13)               /*!< APB2 prescaler selection */
S#define RCU_CFG0_ADCPSC                 BITS(14,15)               /*!< ADC prescaler selection */
S#define RCU_CFG0_PLLSEL                 BIT(16)                   /*!< PLL clock source selection */
S#define RCU_CFG0_PREDV0_LSB             BIT(17)                   /*!< the LSB of PREDV0 division factor */
S#define RCU_CFG0_PLLMF                  BITS(18,21)               /*!< PLL clock multiplication factor */
S#define RCU_CFG0_USBFSPSC               BITS(22,23)               /*!< USBFS clock prescaler selection */
S#define RCU_CFG0_CKOUT0SEL              BITS(24,27)               /*!< CKOUT0 clock source selection */
S#define RCU_CFG0_ADCPSC_2               BIT(28)                   /*!< bit 2 of ADCPSC */
S#define RCU_CFG0_PLLMF_4                BIT(29)                   /*!< bit 4 of PLLMF */
N#endif /* GD32F10X_MD and GD32F10X_HD and GD32F10X_XD */
N
N/* RCU_INT */
N#if (defined(GD32F10X_MD) || defined(GD32F10X_HD) || defined(GD32F10X_XD))
X#if (0L || 0L || 1L)
N#define RCU_INT_IRC40KSTBIF             BIT(0)                    /*!< IRC40K stabilization interrupt flag */
N#define RCU_INT_LXTALSTBIF              BIT(1)                    /*!< LXTAL stabilization interrupt flag */
N#define RCU_INT_IRC8MSTBIF              BIT(2)                    /*!< IRC8M stabilization interrupt flag */
N#define RCU_INT_HXTALSTBIF              BIT(3)                    /*!< HXTAL stabilization interrupt flag */
N#define RCU_INT_PLLSTBIF                BIT(4)                    /*!< PLL stabilization interrupt flag */
N#define RCU_INT_CKMIF                   BIT(7)                    /*!< HXTAL clock stuck interrupt flag */
N#define RCU_INT_IRC40KSTBIE             BIT(8)                    /*!< IRC40K stabilization interrupt enable */
N#define RCU_INT_LXTALSTBIE              BIT(9)                    /*!< LXTAL stabilization interrupt enable */
N#define RCU_INT_IRC8MSTBIE              BIT(10)                   /*!< IRC8M stabilization interrupt enable */
N#define RCU_INT_HXTALSTBIE              BIT(11)                   /*!< HXTAL stabilization interrupt enable */
N#define RCU_INT_PLLSTBIE                BIT(12)                   /*!< PLL stabilization interrupt enable */
N#define RCU_INT_IRC40KSTBIC             BIT(16)                   /*!< IRC40K Stabilization interrupt clear */
N#define RCU_INT_LXTALSTBIC              BIT(17)                   /*!< LXTAL Stabilization interrupt clear */
N#define RCU_INT_IRC8MSTBIC              BIT(18)                   /*!< IRC8M Stabilization interrupt clear */
N#define RCU_INT_HXTALSTBIC              BIT(19)                   /*!< HXTAL Stabilization interrupt clear */
N#define RCU_INT_PLLSTBIC                BIT(20)                   /*!< PLL stabilization interrupt clear */
N#define RCU_INT_CKMIC                   BIT(23)                   /*!< HXTAL clock stuck interrupt clear */
N#elif defined(GD32F10X_CL)
S#define RCU_INT_IRC40KSTBIF             BIT(0)                    /*!< IRC40K stabilization interrupt flag */
S#define RCU_INT_LXTALSTBIF              BIT(1)                    /*!< LXTAL stabilization interrupt flag */
S#define RCU_INT_IRC8MSTBIF              BIT(2)                    /*!< IRC8M stabilization interrupt flag */
S#define RCU_INT_HXTALSTBIF              BIT(3)                    /*!< HXTAL stabilization interrupt flag */
S#define RCU_INT_PLLSTBIF                BIT(4)                    /*!< PLL stabilization interrupt flag */
S#define RCU_INT_PLL1STBIF               BIT(5)                    /*!< PLL1 stabilization interrupt flag */
S#define RCU_INT_PLL2STBIF               BIT(6)                    /*!< PLL2 stabilization interrupt flag */
S#define RCU_INT_CKMIF                   BIT(7)                    /*!< HXTAL clock stuck interrupt flag */
S#define RCU_INT_IRC40KSTBIE             BIT(8)                    /*!< IRC40K stabilization interrupt enable */
S#define RCU_INT_LXTALSTBIE              BIT(9)                    /*!< LXTAL stabilization interrupt enable */
S#define RCU_INT_IRC8MSTBIE              BIT(10)                   /*!< IRC8M stabilization interrupt enable */
S#define RCU_INT_HXTALSTBIE              BIT(11)                   /*!< HXTAL stabilization interrupt enable */
S#define RCU_INT_PLLSTBIE                BIT(12)                   /*!< PLL stabilization interrupt enable */
S#define RCU_INT_PLL1STBIE               BIT(13)                   /*!< PLL1 stabilization interrupt enable */
S#define RCU_INT_PLL2STBIE               BIT(14)                   /*!< PLL2 stabilization interrupt enable */
S#define RCU_INT_IRC40KSTBIC             BIT(16)                   /*!< IRC40K stabilization interrupt clear */
S#define RCU_INT_LXTALSTBIC              BIT(17)                   /*!< LXTAL stabilization interrupt clear */
S#define RCU_INT_IRC8MSTBIC              BIT(18)                   /*!< IRC8M stabilization interrupt clear */
S#define RCU_INT_HXTALSTBIC              BIT(19)                   /*!< HXTAL stabilization interrupt clear */
S#define RCU_INT_PLLSTBIC                BIT(20)                   /*!< PLL stabilization interrupt clear */
S#define RCU_INT_PLL1STBIC               BIT(21)                   /*!< PLL1 stabilization interrupt clear */
S#define RCU_INT_PLL2STBIC               BIT(22)                   /*!< PLL2 stabilization interrupt clear */
S#define RCU_INT_CKMIC                   BIT(23)                   /*!< HXTAL clock stuck interrupt clear */
N#endif /* GD32F10X_MD and GD32F10X_HD and GD32F10X_XD */
N
N/* RCU_APB2RST */
N#define RCU_APB2RST_AFRST               BIT(0)                    /*!< alternate function I/O reset */
N#define RCU_APB2RST_PARST               BIT(2)                    /*!< GPIO port A reset */
N#define RCU_APB2RST_PBRST               BIT(3)                    /*!< GPIO port B reset */
N#define RCU_APB2RST_PCRST               BIT(4)                    /*!< GPIO port C reset */
N#define RCU_APB2RST_PDRST               BIT(5)                    /*!< GPIO port D reset */
N#define RCU_APB2RST_PERST               BIT(6)                    /*!< GPIO port E reset */
N#define RCU_APB2RST_PFRST               BIT(7)                    /*!< GPIO port F reset */
N#define RCU_APB2RST_PGRST               BIT(8)                    /*!< GPIO port G reset */
N#define RCU_APB2RST_ADC0RST             BIT(9)                    /*!< ADC0 reset */
N#define RCU_APB2RST_ADC1RST             BIT(10)                   /*!< ADC1 reset */
N#define RCU_APB2RST_TIMER0RST           BIT(11)                   /*!< TIMER0 reset */
N#define RCU_APB2RST_SPI0RST             BIT(12)                   /*!< SPI0 reset */
N#define RCU_APB2RST_TIMER7RST           BIT(13)                   /*!< TIMER7 reset */
N#define RCU_APB2RST_USART0RST           BIT(14)                   /*!< USART0 reset */
N#ifndef GD32F10X_CL
N#define RCU_APB2RST_ADC2RST             BIT(15)                   /*!< ADC2 reset */
N#endif /* GD32F10X_CL */
N#ifdef GD32F10X_XD
N#define RCU_APB2RST_TIMER8RST           BIT(19)                   /*!< TIMER8 reset */
N#define RCU_APB2RST_TIMER9RST           BIT(20)                   /*!< TIMER9 reset */
N#define RCU_APB2RST_TIMER10RST          BIT(21)                   /*!< TIMER10 reset */
N#endif /* GD32F10X_XD */
N
N/* RCU_APB1RST */
N#define RCU_APB1RST_TIMER1RST           BIT(0)                    /*!< TIMER1 reset */
N#define RCU_APB1RST_TIMER2RST           BIT(1)                    /*!< TIMER2 reset */
N#define RCU_APB1RST_TIMER3RST           BIT(2)                    /*!< TIMER3 reset */
N#define RCU_APB1RST_TIMER4RST           BIT(3)                    /*!< TIMER4 reset */
N#define RCU_APB1RST_TIMER5RST           BIT(4)                    /*!< TIMER5 reset */
N#define RCU_APB1RST_TIMER6RST           BIT(5)                    /*!< TIMER6 reset */
N#ifdef GD32F10X_XD
N#define RCU_APB1RST_TIMER11RST          BIT(6)                    /*!< TIMER11 reset */
N#define RCU_APB1RST_TIMER12RST          BIT(7)                    /*!< TIMER12 reset */
N#define RCU_APB1RST_TIMER13RST          BIT(8)                    /*!< TIMER13 reset */
N#endif /* GD32F10X_XD */
N#define RCU_APB1RST_WWDGTRST            BIT(11)                   /*!< WWDGT reset */
N#define RCU_APB1RST_SPI1RST             BIT(14)                   /*!< SPI1 reset */
N#define RCU_APB1RST_SPI2RST             BIT(15)                   /*!< SPI2 reset */
N#define RCU_APB1RST_USART1RST           BIT(17)                   /*!< USART1 reset */
N#define RCU_APB1RST_USART2RST           BIT(18)                   /*!< USART2 reset */
N#define RCU_APB1RST_UART3RST            BIT(19)                   /*!< UART3 reset */
N#define RCU_APB1RST_UART4RST            BIT(20)                   /*!< UART4 reset */
N#define RCU_APB1RST_I2C0RST             BIT(21)                   /*!< I2C0 reset */
N#define RCU_APB1RST_I2C1RST             BIT(22)                   /*!< I2C1 reset */
N#if (defined(GD32F10X_MD) || defined(GD32F10X_HD) || defined(GD32F10X_XD))
X#if (0L || 0L || 1L)
N#define RCU_APB1RST_USBDRST             BIT(23)                   /*!< USBD reset */
N#endif /* GD32F10X_MD and GD32F10X_HD and GD32F10X_XD */
N#define RCU_APB1RST_CAN0RST             BIT(25)                   /*!< CAN0 reset */
N#ifdef GD32F10X_CL
S#define RCU_APB1RST_CAN1RST             BIT(26)                   /*!< CAN1 reset */
N#endif /* GD32F10X_CL */
N#define RCU_APB1RST_BKPIRST             BIT(27)                   /*!< backup interface reset */
N#define RCU_APB1RST_PMURST              BIT(28)                   /*!< PMU reset */
N#define RCU_APB1RST_DACRST              BIT(29)                   /*!< DAC reset */
N
N/* RCU_AHBEN */
N#define RCU_AHBEN_DMA0EN                BIT(0)                    /*!< DMA0 clock enable */
N#define RCU_AHBEN_DMA1EN                BIT(1)                    /*!< DMA1 clock enable */
N#define RCU_AHBEN_SRAMSPEN              BIT(2)                    /*!< SRAM clock enable when sleep mode */
N#define RCU_AHBEN_FMCSPEN               BIT(4)                    /*!< FMC clock enable when sleep mode */
N#define RCU_AHBEN_CRCEN                 BIT(6)                    /*!< CRC clock enable */
N#define RCU_AHBEN_EXMCEN                BIT(8)                    /*!< EXMC clock enable */
N#if (defined(GD32F10X_MD) || defined(GD32F10X_HD) || defined(GD32F10X_XD))
X#if (0L || 0L || 1L)
N#define RCU_AHBEN_SDIOEN                BIT(10)                   /*!< SDIO clock enable */
N#elif defined(GD32F10X_CL)
S#define RCU_AHBEN_USBFSEN               BIT(12)                   /*!< USBFS clock enable */
S#define RCU_AHBEN_ENETEN                BIT(14)                   /*!< ENET clock enable */
S#define RCU_AHBEN_ENETTXEN              BIT(15)                   /*!< Ethernet TX clock enable */
S#define RCU_AHBEN_ENETRXEN              BIT(16)                   /*!< Ethernet RX clock enable */
N#endif /* GD32F10X_MD and GD32F10X_HD and GD32F10X_XD */
N
N/* RCU_APB2EN */
N#define RCU_APB2EN_AFEN                 BIT(0)                    /*!< alternate function IO clock enable */
N#define RCU_APB2EN_PAEN                 BIT(2)                    /*!< GPIO port A clock enable */
N#define RCU_APB2EN_PBEN                 BIT(3)                    /*!< GPIO port B clock enable */
N#define RCU_APB2EN_PCEN                 BIT(4)                    /*!< GPIO port C clock enable */
N#define RCU_APB2EN_PDEN                 BIT(5)                    /*!< GPIO port D clock enable */
N#define RCU_APB2EN_PEEN                 BIT(6)                    /*!< GPIO port E clock enable */
N#define RCU_APB2EN_PFEN                 BIT(7)                    /*!< GPIO port F clock enable */
N#define RCU_APB2EN_PGEN                 BIT(8)                    /*!< GPIO port G clock enable */
N#define RCU_APB2EN_ADC0EN               BIT(9)                    /*!< ADC0 clock enable */
N#define RCU_APB2EN_ADC1EN               BIT(10)                   /*!< ADC1 clock enable */
N#define RCU_APB2EN_TIMER0EN             BIT(11)                   /*!< TIMER0 clock enable */
N#define RCU_APB2EN_SPI0EN               BIT(12)                   /*!< SPI0 clock enable */
N#define RCU_APB2EN_TIMER7EN             BIT(13)                   /*!< TIMER7 clock enable */
N#define RCU_APB2EN_USART0EN             BIT(14)                   /*!< USART0 clock enable */
N#ifndef GD32F10X_CL
N#define RCU_APB2EN_ADC2EN               BIT(15)                   /*!< ADC2 clock enable */
N#endif /* GD32F10X_CL */
N#ifdef GD32F10X_XD
N#define RCU_APB2EN_TIMER8EN             BIT(19)                   /*!< TIMER8 clock enable */
N#define RCU_APB2EN_TIMER9EN             BIT(20)                   /*!< TIMER9 clock enable */
N#define RCU_APB2EN_TIMER10EN            BIT(21)                   /*!< TIMER10 clock enable */
N#endif /* GD32F10X_XD */
N
N/* RCU_APB1EN */
N#define RCU_APB1EN_TIMER1EN             BIT(0)                    /*!< TIMER1 clock enable */
N#define RCU_APB1EN_TIMER2EN             BIT(1)                    /*!< TIMER2 clock enable */
N#define RCU_APB1EN_TIMER3EN             BIT(2)                    /*!< TIMER3 clock enable */
N#define RCU_APB1EN_TIMER4EN             BIT(3)                    /*!< TIMER4 clock enable */
N#define RCU_APB1EN_TIMER5EN             BIT(4)                    /*!< TIMER5 clock enable */
N#define RCU_APB1EN_TIMER6EN             BIT(5)                    /*!< TIMER6 clock enable */
N#ifdef GD32F10X_XD
N#define RCU_APB1EN_TIMER11EN            BIT(6)                    /*!< TIMER11 clock enable */
N#define RCU_APB1EN_TIMER12EN            BIT(7)                    /*!< TIMER12 clock enable */
N#define RCU_APB1EN_TIMER13EN            BIT(8)                    /*!< TIMER13 clock enable */
N#endif /* GD32F10X_XD */
N#define RCU_APB1EN_WWDGTEN              BIT(11)                   /*!< WWDGT clock enable */
N#define RCU_APB1EN_SPI1EN               BIT(14)                   /*!< SPI1 clock enable */
N#define RCU_APB1EN_SPI2EN               BIT(15)                   /*!< SPI2 clock enable */
N#define RCU_APB1EN_USART1EN             BIT(17)                   /*!< USART1 clock enable */
N#define RCU_APB1EN_USART2EN             BIT(18)                   /*!< USART2 clock enable */
N#define RCU_APB1EN_UART3EN              BIT(19)                   /*!< UART3 clock enable */
N#define RCU_APB1EN_UART4EN              BIT(20)                   /*!< UART4 clock enable */
N#define RCU_APB1EN_I2C0EN               BIT(21)                   /*!< I2C0 clock enable */
N#define RCU_APB1EN_I2C1EN               BIT(22)                   /*!< I2C1 clock enable */
N#if (defined(GD32F10X_MD) || defined(GD32F10X_HD) || defined(GD32F10X_XD))
X#if (0L || 0L || 1L)
N#define RCU_APB1EN_USBDEN               BIT(23)                   /*!< USBD clock enable */
N#endif /* GD32F10X_MD and GD32F10X_HD and GD32F10X_XD */
N#define RCU_APB1EN_CAN0EN               BIT(25)                   /*!< CAN0 clock enable */
N#ifdef GD32F10X_CL
S#define RCU_APB1EN_CAN1EN               BIT(26)                   /*!< CAN1 clock enable */
N#endif /* GD32F10X_CL */
N#define RCU_APB1EN_BKPIEN               BIT(27)                   /*!< backup interface clock enable */
N#define RCU_APB1EN_PMUEN                BIT(28)                   /*!< PMU clock enable */
N#define RCU_APB1EN_DACEN                BIT(29)                   /*!< DAC clock enable */
N
N/* RCU_BDCTL */
N#define RCU_BDCTL_LXTALEN               BIT(0)                    /*!< LXTAL enable */
N#define RCU_BDCTL_LXTALSTB              BIT(1)                    /*!< low speed crystal oscillator stabilization flag */
N#define RCU_BDCTL_LXTALBPS              BIT(2)                    /*!< LXTAL bypass mode enable */
N#define RCU_BDCTL_RTCSRC                BITS(8,9)                 /*!< RTC clock entry selection */
N#define RCU_BDCTL_RTCEN                 BIT(15)                   /*!< RTC clock enable */
N#define RCU_BDCTL_BKPRST                BIT(16)                   /*!< backup domain reset */
N
N/* RCU_RSTSCK */
N#define RCU_RSTSCK_IRC40KEN             BIT(0)                    /*!< IRC40K enable */
N#define RCU_RSTSCK_IRC40KSTB            BIT(1)                    /*!< IRC40K stabilization flag */
N#define RCU_RSTSCK_RSTFC                BIT(24)                   /*!< reset flag clear */
N#define RCU_RSTSCK_EPRSTF               BIT(26)                   /*!< external pin reset flag */
N#define RCU_RSTSCK_PORRSTF              BIT(27)                   /*!< power reset flag */
N#define RCU_RSTSCK_SWRSTF               BIT(28)                   /*!< software reset flag */
N#define RCU_RSTSCK_FWDGTRSTF            BIT(29)                   /*!< free watchdog timer reset flag */
N#define RCU_RSTSCK_WWDGTRSTF            BIT(30)                   /*!< window watchdog timer reset flag */
N#define RCU_RSTSCK_LPRSTF               BIT(31)                   /*!< low-power reset flag */
N
N#ifdef GD32F10X_CL
S/* RCU_AHBRST */
S#define RCU_AHBRST_USBFSRST             BIT(12)                   /*!< USBFS reset */
S#define RCU_AHBRST_ENETRST              BIT(14)                   /*!< ENET reset */
N#endif /* GD32F10X_CL */
N
N#if defined(GD32F10X_CL)
X#if 0L
S/* RCU_CFG1 */
S#define RCU_CFG1_PREDV0                 BITS(0,3)                 /*!< PREDV0 division factor */
S#define RCU_CFG1_PREDV1                 BITS(4,7)                 /*!< PREDV1 division factor */
S#define RCU_CFG1_PLL1MF                 BITS(8,11)                /*!< PLL1 clock multiplication factor */
S#define RCU_CFG1_PLL2MF                 BITS(12,15)               /*!< PLL2 clock multiplication factor */
S#define RCU_CFG1_PREDV0SEL              BIT(16)                   /*!< PREDV0 input clock source selection */
S#define RCU_CFG1_I2S1SEL                BIT(17)                   /*!< I2S1 clock source selection */
S#define RCU_CFG1_I2S2SEL                BIT(18)                   /*!< I2S2 clock source selection  */
N#endif /* GD32F10X_CL */
N
N/* RCU_DSV */
N#define RCU_DSV_DSLPVS                  BITS(0,2)                 /*!< deep-sleep mode voltage select */
N
N/* constants definitions */
N/* define the peripheral clock enable bit position and its register index offset */
N#define RCU_REGIDX_BIT(regidx, bitpos)      (((uint32_t)(regidx) << 6) | (uint32_t)(bitpos))
N#define RCU_REG_VAL(periph)                 (REG32(RCU + ((uint32_t)(periph) >> 6)))
N#define RCU_BIT_POS(val)                    ((uint32_t)(val) & 0x1FU)
N
N/* register offset */
N/* peripherals enable */
N#define AHBEN_REG_OFFSET                0x14U                     /*!< AHB enable register offset */
N#define APB1EN_REG_OFFSET               0x1CU                     /*!< APB1 enable register offset */
N#define APB2EN_REG_OFFSET               0x18U                     /*!< APB2 enable register offset */
N
N/* peripherals reset */
N#define AHBRST_REG_OFFSET               0x28U                     /*!< AHB reset register offset */
N#define APB1RST_REG_OFFSET              0x10U                     /*!< APB1 reset register offset */
N#define APB2RST_REG_OFFSET              0x0CU                     /*!< APB2 reset register offset */
N#define RSTSCK_REG_OFFSET               0x24U                     /*!< reset source/clock register offset */
N
N/* clock control */
N#define CTL_REG_OFFSET                  0x00U                     /*!< control register offset */
N#define BDCTL_REG_OFFSET                0x20U                     /*!< backup domain control register offset */
N
N/* clock stabilization and stuck interrupt */
N#define INT_REG_OFFSET                  0x08U                     /*!< clock interrupt register offset */
N
N/* configuration register */
N#define CFG0_REG_OFFSET                 0x04U                     /*!< clock configuration register 0 offset */
N#define CFG1_REG_OFFSET                 0x2CU                     /*!< clock configuration register 1 offset */
N
N/* peripheral clock enable */
Ntypedef enum
N{
N    /* AHB peripherals */
N    RCU_DMA0      = RCU_REGIDX_BIT(AHBEN_REG_OFFSET, 0U),                   /*!< DMA0 clock */
X    RCU_DMA0      = (((uint32_t)(0x14U) << 6) | (uint32_t)(0U)),                    
N    RCU_DMA1      = RCU_REGIDX_BIT(AHBEN_REG_OFFSET, 1U),                   /*!< DMA1 clock */
X    RCU_DMA1      = (((uint32_t)(0x14U) << 6) | (uint32_t)(1U)),                    
N    RCU_CRC       = RCU_REGIDX_BIT(AHBEN_REG_OFFSET, 6U),                   /*!< CRC clock */
X    RCU_CRC       = (((uint32_t)(0x14U) << 6) | (uint32_t)(6U)),                    
N    RCU_EXMC      = RCU_REGIDX_BIT(AHBEN_REG_OFFSET, 8U),                   /*!< EXMC clock */
X    RCU_EXMC      = (((uint32_t)(0x14U) << 6) | (uint32_t)(8U)),                    
N#if (defined(GD32F10X_MD) || defined(GD32F10X_HD) || defined(GD32F10X_XD))
X#if (0L || 0L || 1L)
N    RCU_SDIO      = RCU_REGIDX_BIT(AHBEN_REG_OFFSET, 10U),                  /*!< SDIO clock */
X    RCU_SDIO      = (((uint32_t)(0x14U) << 6) | (uint32_t)(10U)),                   
N#elif defined(GD32F10X_CL)
S    RCU_USBFS     = RCU_REGIDX_BIT(AHBEN_REG_OFFSET, 12U),                  /*!< USBFS clock */
S    RCU_ENET      = RCU_REGIDX_BIT(AHBEN_REG_OFFSET, 14U),                  /*!< ENET clock */
S    RCU_ENETTX    = RCU_REGIDX_BIT(AHBEN_REG_OFFSET, 15U),                  /*!< ENETTX clock */
S    RCU_ENETRX    = RCU_REGIDX_BIT(AHBEN_REG_OFFSET, 16U),                  /*!< ENETRX clock */
N#endif /* GD32F10X_MD and GD32F10X_HD and GD32F10X_XD */
N    
N    /* APB1 peripherals */
N    RCU_TIMER1    = RCU_REGIDX_BIT(APB1EN_REG_OFFSET, 0U),                  /*!< TIMER1 clock */
X    RCU_TIMER1    = (((uint32_t)(0x1CU) << 6) | (uint32_t)(0U)),                   
N    RCU_TIMER2    = RCU_REGIDX_BIT(APB1EN_REG_OFFSET, 1U),                  /*!< TIMER2 clock */
X    RCU_TIMER2    = (((uint32_t)(0x1CU) << 6) | (uint32_t)(1U)),                   
N    RCU_TIMER3    = RCU_REGIDX_BIT(APB1EN_REG_OFFSET, 2U),                  /*!< TIMER3 clock */
X    RCU_TIMER3    = (((uint32_t)(0x1CU) << 6) | (uint32_t)(2U)),                   
N    RCU_TIMER4    = RCU_REGIDX_BIT(APB1EN_REG_OFFSET, 3U),                  /*!< TIMER4 clock */
X    RCU_TIMER4    = (((uint32_t)(0x1CU) << 6) | (uint32_t)(3U)),                   
N    RCU_TIMER5    = RCU_REGIDX_BIT(APB1EN_REG_OFFSET, 4U),                  /*!< TIMER5 clock */
X    RCU_TIMER5    = (((uint32_t)(0x1CU) << 6) | (uint32_t)(4U)),                   
N    RCU_TIMER6    = RCU_REGIDX_BIT(APB1EN_REG_OFFSET, 5U),                  /*!< TIMER6 clock */
X    RCU_TIMER6    = (((uint32_t)(0x1CU) << 6) | (uint32_t)(5U)),                   
N#if defined(GD32F10X_XD)
X#if 1L
N    RCU_TIMER11   = RCU_REGIDX_BIT(APB1EN_REG_OFFSET, 6U),                  /*!< TIMER11 clock */
X    RCU_TIMER11   = (((uint32_t)(0x1CU) << 6) | (uint32_t)(6U)),                   
N    RCU_TIMER12   = RCU_REGIDX_BIT(APB1EN_REG_OFFSET, 7U),                  /*!< TIMER12 clock */
X    RCU_TIMER12   = (((uint32_t)(0x1CU) << 6) | (uint32_t)(7U)),                   
N    RCU_TIMER13   = RCU_REGIDX_BIT(APB1EN_REG_OFFSET, 8U),                  /*!< TIMER13 clock */
X    RCU_TIMER13   = (((uint32_t)(0x1CU) << 6) | (uint32_t)(8U)),                   
N#endif /* GD32F10X_XD */
N    RCU_WWDGT     = RCU_REGIDX_BIT(APB1EN_REG_OFFSET, 11U),                 /*!< WWDGT clock */
X    RCU_WWDGT     = (((uint32_t)(0x1CU) << 6) | (uint32_t)(11U)),                  
N    RCU_SPI1      = RCU_REGIDX_BIT(APB1EN_REG_OFFSET, 14U),                 /*!< SPI1 clock */
X    RCU_SPI1      = (((uint32_t)(0x1CU) << 6) | (uint32_t)(14U)),                  
N    RCU_SPI2      = RCU_REGIDX_BIT(APB1EN_REG_OFFSET, 15U),                 /*!< SPI2 clock */
X    RCU_SPI2      = (((uint32_t)(0x1CU) << 6) | (uint32_t)(15U)),                  
N    RCU_USART1    = RCU_REGIDX_BIT(APB1EN_REG_OFFSET, 17U),                 /*!< USART1 clock */
X    RCU_USART1    = (((uint32_t)(0x1CU) << 6) | (uint32_t)(17U)),                  
N    RCU_USART2    = RCU_REGIDX_BIT(APB1EN_REG_OFFSET, 18U),                 /*!< USART2 clock */
X    RCU_USART2    = (((uint32_t)(0x1CU) << 6) | (uint32_t)(18U)),                  
N    RCU_UART3     = RCU_REGIDX_BIT(APB1EN_REG_OFFSET, 19U),                 /*!< UART3 clock */
X    RCU_UART3     = (((uint32_t)(0x1CU) << 6) | (uint32_t)(19U)),                  
N    RCU_UART4     = RCU_REGIDX_BIT(APB1EN_REG_OFFSET, 20U),                 /*!< UART4 clock */
X    RCU_UART4     = (((uint32_t)(0x1CU) << 6) | (uint32_t)(20U)),                  
N    RCU_I2C0      = RCU_REGIDX_BIT(APB1EN_REG_OFFSET, 21U),                 /*!< I2C0 clock */
X    RCU_I2C0      = (((uint32_t)(0x1CU) << 6) | (uint32_t)(21U)),                  
N    RCU_I2C1      = RCU_REGIDX_BIT(APB1EN_REG_OFFSET, 22U),                 /*!< I2C1 clock */
X    RCU_I2C1      = (((uint32_t)(0x1CU) << 6) | (uint32_t)(22U)),                  
N#if (defined(GD32F10X_MD) || defined(GD32F10X_HD) || defined(GD32F10X_XD))
X#if (0L || 0L || 1L)
N    RCU_USBD      = RCU_REGIDX_BIT(APB1EN_REG_OFFSET, 23U),                 /*!< USBD clock */
X    RCU_USBD      = (((uint32_t)(0x1CU) << 6) | (uint32_t)(23U)),                  
N#endif /* GD32F10X_MD and GD32F10X_HD and GD32F10X_XD */
N    RCU_CAN0      = RCU_REGIDX_BIT(APB1EN_REG_OFFSET, 25U),                 /*!< CAN0 clock */
X    RCU_CAN0      = (((uint32_t)(0x1CU) << 6) | (uint32_t)(25U)),                  
N#ifdef GD32F10X_CL
S    RCU_CAN1      = RCU_REGIDX_BIT(APB1EN_REG_OFFSET, 26U),                 /*!< CAN1 clock */
N#endif /* GD32F10X_CL */
N    RCU_BKPI      = RCU_REGIDX_BIT(APB1EN_REG_OFFSET, 27U),                 /*!< BKPI clock */
X    RCU_BKPI      = (((uint32_t)(0x1CU) << 6) | (uint32_t)(27U)),                  
N    RCU_PMU       = RCU_REGIDX_BIT(APB1EN_REG_OFFSET, 28U),                 /*!< PMU clock */
X    RCU_PMU       = (((uint32_t)(0x1CU) << 6) | (uint32_t)(28U)),                  
N    RCU_DAC       = RCU_REGIDX_BIT(APB1EN_REG_OFFSET, 29U),                 /*!< DAC clock */
X    RCU_DAC       = (((uint32_t)(0x1CU) << 6) | (uint32_t)(29U)),                  
N    RCU_RTC       = RCU_REGIDX_BIT(BDCTL_REG_OFFSET, 15U),                  /*!< RTC clock */
X    RCU_RTC       = (((uint32_t)(0x20U) << 6) | (uint32_t)(15U)),                   
N    
N    /* APB2 peripherals */
N    RCU_AF        = RCU_REGIDX_BIT(APB2EN_REG_OFFSET, 0U),                  /*!< alternate function clock */
X    RCU_AF        = (((uint32_t)(0x18U) << 6) | (uint32_t)(0U)),                   
N    RCU_GPIOA     = RCU_REGIDX_BIT(APB2EN_REG_OFFSET, 2U),                  /*!< GPIOA clock */
X    RCU_GPIOA     = (((uint32_t)(0x18U) << 6) | (uint32_t)(2U)),                   
N    RCU_GPIOB     = RCU_REGIDX_BIT(APB2EN_REG_OFFSET, 3U),                  /*!< GPIOB clock */
X    RCU_GPIOB     = (((uint32_t)(0x18U) << 6) | (uint32_t)(3U)),                   
N    RCU_GPIOC     = RCU_REGIDX_BIT(APB2EN_REG_OFFSET, 4U),                  /*!< GPIOC clock */
X    RCU_GPIOC     = (((uint32_t)(0x18U) << 6) | (uint32_t)(4U)),                   
N    RCU_GPIOD     = RCU_REGIDX_BIT(APB2EN_REG_OFFSET, 5U),                  /*!< GPIOD clock */
X    RCU_GPIOD     = (((uint32_t)(0x18U) << 6) | (uint32_t)(5U)),                   
N    RCU_GPIOE     = RCU_REGIDX_BIT(APB2EN_REG_OFFSET, 6U),                  /*!< GPIOE clock */
X    RCU_GPIOE     = (((uint32_t)(0x18U) << 6) | (uint32_t)(6U)),                   
N    RCU_GPIOF     = RCU_REGIDX_BIT(APB2EN_REG_OFFSET, 7U),                  /*!< GPIOF clock */
X    RCU_GPIOF     = (((uint32_t)(0x18U) << 6) | (uint32_t)(7U)),                   
N    RCU_GPIOG     = RCU_REGIDX_BIT(APB2EN_REG_OFFSET, 8U),                  /*!< GPIOG clock */
X    RCU_GPIOG     = (((uint32_t)(0x18U) << 6) | (uint32_t)(8U)),                   
N    RCU_ADC0      = RCU_REGIDX_BIT(APB2EN_REG_OFFSET, 9U),                  /*!< ADC0 clock */
X    RCU_ADC0      = (((uint32_t)(0x18U) << 6) | (uint32_t)(9U)),                   
N    RCU_ADC1      = RCU_REGIDX_BIT(APB2EN_REG_OFFSET, 10U),                 /*!< ADC1 clock */
X    RCU_ADC1      = (((uint32_t)(0x18U) << 6) | (uint32_t)(10U)),                  
N    RCU_TIMER0    = RCU_REGIDX_BIT(APB2EN_REG_OFFSET, 11U),                 /*!< TIMER0 clock */
X    RCU_TIMER0    = (((uint32_t)(0x18U) << 6) | (uint32_t)(11U)),                  
N    RCU_SPI0      = RCU_REGIDX_BIT(APB2EN_REG_OFFSET, 12U),                 /*!< SPI0 clock */
X    RCU_SPI0      = (((uint32_t)(0x18U) << 6) | (uint32_t)(12U)),                  
N    RCU_TIMER7    = RCU_REGIDX_BIT(APB2EN_REG_OFFSET, 13U),                 /*!< TIMER7 clock */
X    RCU_TIMER7    = (((uint32_t)(0x18U) << 6) | (uint32_t)(13U)),                  
N    RCU_USART0    = RCU_REGIDX_BIT(APB2EN_REG_OFFSET, 14U),                 /*!< USART0 clock */
X    RCU_USART0    = (((uint32_t)(0x18U) << 6) | (uint32_t)(14U)),                  
N#ifndef GD32F10X_CL
N    RCU_ADC2      = RCU_REGIDX_BIT(APB2EN_REG_OFFSET, 15U),                 /*!< ADC2 clock */
X    RCU_ADC2      = (((uint32_t)(0x18U) << 6) | (uint32_t)(15U)),                  
N#endif /* GD32F10X_CL */
N#ifdef GD32F10X_XD
N    RCU_TIMER8    = RCU_REGIDX_BIT(APB2EN_REG_OFFSET, 19U),                 /*!< TIMER8 clock */
X    RCU_TIMER8    = (((uint32_t)(0x18U) << 6) | (uint32_t)(19U)),                  
N    RCU_TIMER9    = RCU_REGIDX_BIT(APB2EN_REG_OFFSET, 20U),                 /*!< TIMER9 clock */
X    RCU_TIMER9    = (((uint32_t)(0x18U) << 6) | (uint32_t)(20U)),                  
N    RCU_TIMER10   = RCU_REGIDX_BIT(APB2EN_REG_OFFSET, 21U),                 /*!< TIMER10 clock */
X    RCU_TIMER10   = (((uint32_t)(0x18U) << 6) | (uint32_t)(21U)),                  
N#endif /* GD32F10X_XD */
N}rcu_periph_enum;
N
N/* peripheral clock enable when sleep mode*/
Ntypedef enum
N{
N    /* AHB peripherals */
N    RCU_SRAM_SLP     = RCU_REGIDX_BIT(AHBEN_REG_OFFSET, 2U),                /*!< SRAM clock */
X    RCU_SRAM_SLP     = (((uint32_t)(0x14U) << 6) | (uint32_t)(2U)),                 
N    RCU_FMC_SLP      = RCU_REGIDX_BIT(AHBEN_REG_OFFSET, 4U),                /*!< FMC clock */
X    RCU_FMC_SLP      = (((uint32_t)(0x14U) << 6) | (uint32_t)(4U)),                 
N}rcu_periph_sleep_enum;
N
N/* peripherals reset */
Ntypedef enum
N{
N    /* AHB peripherals */
N#ifdef GD32F10X_CL
S    RCU_USBFSRST     = RCU_REGIDX_BIT(AHBRST_REG_OFFSET, 12U),              /*!< USBFS clock reset */
S    RCU_ENETRST      = RCU_REGIDX_BIT(AHBRST_REG_OFFSET, 14U),              /*!< ENET clock reset */
N#endif /* GD32F10X_CL */
N    
N    /* APB1 peripherals */
N    RCU_TIMER1RST    = RCU_REGIDX_BIT(APB1RST_REG_OFFSET, 0U),              /*!< TIMER1 clock reset */
X    RCU_TIMER1RST    = (((uint32_t)(0x10U) << 6) | (uint32_t)(0U)),               
N    RCU_TIMER2RST    = RCU_REGIDX_BIT(APB1RST_REG_OFFSET, 1U),              /*!< TIMER2 clock reset */
X    RCU_TIMER2RST    = (((uint32_t)(0x10U) << 6) | (uint32_t)(1U)),               
N    RCU_TIMER3RST    = RCU_REGIDX_BIT(APB1RST_REG_OFFSET, 2U),              /*!< TIMER3 clock reset */
X    RCU_TIMER3RST    = (((uint32_t)(0x10U) << 6) | (uint32_t)(2U)),               
N    RCU_TIMER4RST    = RCU_REGIDX_BIT(APB1RST_REG_OFFSET, 3U),              /*!< TIMER4 clock reset */
X    RCU_TIMER4RST    = (((uint32_t)(0x10U) << 6) | (uint32_t)(3U)),               
N    RCU_TIMER5RST    = RCU_REGIDX_BIT(APB1RST_REG_OFFSET, 4U),              /*!< TIMER5 clock reset */
X    RCU_TIMER5RST    = (((uint32_t)(0x10U) << 6) | (uint32_t)(4U)),               
N    RCU_TIMER6RST    = RCU_REGIDX_BIT(APB1RST_REG_OFFSET, 5U),              /*!< TIMER6 clock reset */
X    RCU_TIMER6RST    = (((uint32_t)(0x10U) << 6) | (uint32_t)(5U)),               
N#ifdef GD32F10X_XD
N    RCU_TIMER11RST   = RCU_REGIDX_BIT(APB1RST_REG_OFFSET, 6U),              /*!< TIMER11 clock reset */
X    RCU_TIMER11RST   = (((uint32_t)(0x10U) << 6) | (uint32_t)(6U)),               
N    RCU_TIMER12RST   = RCU_REGIDX_BIT(APB1RST_REG_OFFSET, 7U),              /*!< TIMER12 clock reset */
X    RCU_TIMER12RST   = (((uint32_t)(0x10U) << 6) | (uint32_t)(7U)),               
N    RCU_TIMER13RST   = RCU_REGIDX_BIT(APB1RST_REG_OFFSET, 8U),              /*!< TIMER13 clock reset */
X    RCU_TIMER13RST   = (((uint32_t)(0x10U) << 6) | (uint32_t)(8U)),               
N#endif /* GD32F10X_XD */
N    RCU_WWDGTRST     = RCU_REGIDX_BIT(APB1RST_REG_OFFSET, 11U),             /*!< WWDGT clock reset */
X    RCU_WWDGTRST     = (((uint32_t)(0x10U) << 6) | (uint32_t)(11U)),              
N    RCU_SPI1RST      = RCU_REGIDX_BIT(APB1RST_REG_OFFSET, 14U),             /*!< SPI1 clock reset */
X    RCU_SPI1RST      = (((uint32_t)(0x10U) << 6) | (uint32_t)(14U)),              
N    RCU_SPI2RST      = RCU_REGIDX_BIT(APB1RST_REG_OFFSET, 15U),             /*!< SPI2 clock reset */
X    RCU_SPI2RST      = (((uint32_t)(0x10U) << 6) | (uint32_t)(15U)),              
N    RCU_USART1RST    = RCU_REGIDX_BIT(APB1RST_REG_OFFSET, 17U),             /*!< USART1 clock reset */
X    RCU_USART1RST    = (((uint32_t)(0x10U) << 6) | (uint32_t)(17U)),              
N    RCU_USART2RST    = RCU_REGIDX_BIT(APB1RST_REG_OFFSET, 18U),             /*!< USART2 clock reset */
X    RCU_USART2RST    = (((uint32_t)(0x10U) << 6) | (uint32_t)(18U)),              
N    RCU_UART3RST     = RCU_REGIDX_BIT(APB1RST_REG_OFFSET, 19U),             /*!< UART3 clock reset */
X    RCU_UART3RST     = (((uint32_t)(0x10U) << 6) | (uint32_t)(19U)),              
N    RCU_UART4RST     = RCU_REGIDX_BIT(APB1RST_REG_OFFSET, 20U),             /*!< UART4 clock reset */
X    RCU_UART4RST     = (((uint32_t)(0x10U) << 6) | (uint32_t)(20U)),              
N    RCU_I2C0RST      = RCU_REGIDX_BIT(APB1RST_REG_OFFSET, 21U),             /*!< I2C0 clock reset */
X    RCU_I2C0RST      = (((uint32_t)(0x10U) << 6) | (uint32_t)(21U)),              
N    RCU_I2C1RST      = RCU_REGIDX_BIT(APB1RST_REG_OFFSET, 22U),             /*!< I2C1 clock reset */
X    RCU_I2C1RST      = (((uint32_t)(0x10U) << 6) | (uint32_t)(22U)),              
N#if (defined(GD32F10X_MD) || defined(GD32F10X_HD) || defined(GD32F10X_XD))
X#if (0L || 0L || 1L)
N    RCU_USBDRST      = RCU_REGIDX_BIT(APB1RST_REG_OFFSET, 23U),             /*!< USBD clock reset */
X    RCU_USBDRST      = (((uint32_t)(0x10U) << 6) | (uint32_t)(23U)),              
N#endif /* GD32F10X_MD and GD32F10X_HD and GD32F10X_XD */
N    RCU_CAN0RST      = RCU_REGIDX_BIT(APB1RST_REG_OFFSET, 25U),             /*!< CAN0 clock reset */
X    RCU_CAN0RST      = (((uint32_t)(0x10U) << 6) | (uint32_t)(25U)),              
N#ifdef GD32F10X_CL
S    RCU_CAN1RST      = RCU_REGIDX_BIT(APB1RST_REG_OFFSET, 26U),             /*!< CAN1 clock reset */
N#endif /* GD32F10X_CL */
N    RCU_BKPIRST      = RCU_REGIDX_BIT(APB1RST_REG_OFFSET, 27U),             /*!< BKPI clock reset */
X    RCU_BKPIRST      = (((uint32_t)(0x10U) << 6) | (uint32_t)(27U)),              
N    RCU_PMURST       = RCU_REGIDX_BIT(APB1RST_REG_OFFSET, 28U),             /*!< PMU clock reset */
X    RCU_PMURST       = (((uint32_t)(0x10U) << 6) | (uint32_t)(28U)),              
N    RCU_DACRST       = RCU_REGIDX_BIT(APB1RST_REG_OFFSET, 29U),             /*!< DAC clock reset */
X    RCU_DACRST       = (((uint32_t)(0x10U) << 6) | (uint32_t)(29U)),              
N    
N    /* APB2 peripherals */
N    RCU_AFRST        = RCU_REGIDX_BIT(APB2RST_REG_OFFSET, 0U),              /*!< alternate function clock reset */
X    RCU_AFRST        = (((uint32_t)(0x0CU) << 6) | (uint32_t)(0U)),               
N    RCU_GPIOARST     = RCU_REGIDX_BIT(APB2RST_REG_OFFSET, 2U),              /*!< GPIOA clock reset */
X    RCU_GPIOARST     = (((uint32_t)(0x0CU) << 6) | (uint32_t)(2U)),               
N    RCU_GPIOBRST     = RCU_REGIDX_BIT(APB2RST_REG_OFFSET, 3U),              /*!< GPIOB clock reset */
X    RCU_GPIOBRST     = (((uint32_t)(0x0CU) << 6) | (uint32_t)(3U)),               
N    RCU_GPIOCRST     = RCU_REGIDX_BIT(APB2RST_REG_OFFSET, 4U),              /*!< GPIOC clock reset */
X    RCU_GPIOCRST     = (((uint32_t)(0x0CU) << 6) | (uint32_t)(4U)),               
N    RCU_GPIODRST     = RCU_REGIDX_BIT(APB2RST_REG_OFFSET, 5U),              /*!< GPIOD clock reset */
X    RCU_GPIODRST     = (((uint32_t)(0x0CU) << 6) | (uint32_t)(5U)),               
N    RCU_GPIOERST     = RCU_REGIDX_BIT(APB2RST_REG_OFFSET, 6U),              /*!< GPIOE clock reset */
X    RCU_GPIOERST     = (((uint32_t)(0x0CU) << 6) | (uint32_t)(6U)),               
N    RCU_GPIOFRST     = RCU_REGIDX_BIT(APB2RST_REG_OFFSET, 7U),              /*!< GPIOF clock reset */
X    RCU_GPIOFRST     = (((uint32_t)(0x0CU) << 6) | (uint32_t)(7U)),               
N    RCU_GPIOGRST     = RCU_REGIDX_BIT(APB2RST_REG_OFFSET, 8U),              /*!< GPIOG clock reset */
X    RCU_GPIOGRST     = (((uint32_t)(0x0CU) << 6) | (uint32_t)(8U)),               
N    RCU_ADC0RST      = RCU_REGIDX_BIT(APB2RST_REG_OFFSET, 9U),              /*!< ADC0 clock reset */
X    RCU_ADC0RST      = (((uint32_t)(0x0CU) << 6) | (uint32_t)(9U)),               
N    RCU_ADC1RST      = RCU_REGIDX_BIT(APB2RST_REG_OFFSET, 10U),             /*!< ADC1 clock reset */
X    RCU_ADC1RST      = (((uint32_t)(0x0CU) << 6) | (uint32_t)(10U)),              
N    RCU_TIMER0RST    = RCU_REGIDX_BIT(APB2RST_REG_OFFSET, 11U),             /*!< TIMER0 clock reset */
X    RCU_TIMER0RST    = (((uint32_t)(0x0CU) << 6) | (uint32_t)(11U)),              
N    RCU_SPI0RST      = RCU_REGIDX_BIT(APB2RST_REG_OFFSET, 12U),             /*!< SPI0 clock reset */
X    RCU_SPI0RST      = (((uint32_t)(0x0CU) << 6) | (uint32_t)(12U)),              
N    RCU_TIMER7RST    = RCU_REGIDX_BIT(APB2RST_REG_OFFSET, 13U),             /*!< TIMER7 clock reset */
X    RCU_TIMER7RST    = (((uint32_t)(0x0CU) << 6) | (uint32_t)(13U)),              
N    RCU_USART0RST    = RCU_REGIDX_BIT(APB2RST_REG_OFFSET, 14U),             /*!< USART0 clock reset */
X    RCU_USART0RST    = (((uint32_t)(0x0CU) << 6) | (uint32_t)(14U)),              
N#ifndef GD32F10X_CL
N    RCU_ADC2RST      = RCU_REGIDX_BIT(APB2RST_REG_OFFSET, 15U),             /*!< ADC2 clock reset */
X    RCU_ADC2RST      = (((uint32_t)(0x0CU) << 6) | (uint32_t)(15U)),              
N#endif /* GD32F10X_CL */
N#ifdef GD32F10X_XD
N    RCU_TIMER8RST    = RCU_REGIDX_BIT(APB2RST_REG_OFFSET, 19U),             /*!< TIMER8 clock reset */
X    RCU_TIMER8RST    = (((uint32_t)(0x0CU) << 6) | (uint32_t)(19U)),              
N    RCU_TIMER9RST    = RCU_REGIDX_BIT(APB2RST_REG_OFFSET, 20U),             /*!< TIMER9 clock reset */
X    RCU_TIMER9RST    = (((uint32_t)(0x0CU) << 6) | (uint32_t)(20U)),              
N    RCU_TIMER10RST   = RCU_REGIDX_BIT(APB2RST_REG_OFFSET, 21U),             /*!< TIMER10 clock reset */
X    RCU_TIMER10RST   = (((uint32_t)(0x0CU) << 6) | (uint32_t)(21U)),              
N#endif /* GD32F10X_XD */
N}rcu_periph_reset_enum;
N
N/* clock stabilization and peripheral reset flags */
Ntypedef enum
N{
N    /* clock stabilization flags */
N    RCU_FLAG_IRC8MSTB      = RCU_REGIDX_BIT(CTL_REG_OFFSET, 1U),            /*!< IRC8M stabilization flags */
X    RCU_FLAG_IRC8MSTB      = (((uint32_t)(0x00U) << 6) | (uint32_t)(1U)),             
N    RCU_FLAG_HXTALSTB      = RCU_REGIDX_BIT(CTL_REG_OFFSET, 17U),           /*!< HXTAL stabilization flags */
X    RCU_FLAG_HXTALSTB      = (((uint32_t)(0x00U) << 6) | (uint32_t)(17U)),            
N    RCU_FLAG_PLLSTB        = RCU_REGIDX_BIT(CTL_REG_OFFSET, 25U),           /*!< PLL stabilization flags */
X    RCU_FLAG_PLLSTB        = (((uint32_t)(0x00U) << 6) | (uint32_t)(25U)),            
N#ifdef GD32F10X_CL
S    RCU_FLAG_PLL1STB       = RCU_REGIDX_BIT(CTL_REG_OFFSET, 27U),           /*!< PLL1 stabilization flags */
S    RCU_FLAG_PLL2STB       = RCU_REGIDX_BIT(CTL_REG_OFFSET, 29U),           /*!< PLL2 stabilization flags */
N#endif /* GD32F10X_CL */
N    RCU_FLAG_LXTALSTB      = RCU_REGIDX_BIT(BDCTL_REG_OFFSET, 1U),          /*!< LXTAL stabilization flags */
X    RCU_FLAG_LXTALSTB      = (((uint32_t)(0x20U) << 6) | (uint32_t)(1U)),           
N    RCU_FLAG_IRC40KSTB     = RCU_REGIDX_BIT(RSTSCK_REG_OFFSET, 1U),         /*!< IRC40K stabilization flags */
X    RCU_FLAG_IRC40KSTB     = (((uint32_t)(0x24U) << 6) | (uint32_t)(1U)),          
N    /* reset source flags */
N    RCU_FLAG_EPRST         = RCU_REGIDX_BIT(RSTSCK_REG_OFFSET, 26U),        /*!< external PIN reset flags */
X    RCU_FLAG_EPRST         = (((uint32_t)(0x24U) << 6) | (uint32_t)(26U)),         
N    RCU_FLAG_PORRST        = RCU_REGIDX_BIT(RSTSCK_REG_OFFSET, 27U),        /*!< power reset flags */
X    RCU_FLAG_PORRST        = (((uint32_t)(0x24U) << 6) | (uint32_t)(27U)),         
N    RCU_FLAG_SWRST         = RCU_REGIDX_BIT(RSTSCK_REG_OFFSET, 28U),        /*!< software reset flags */
X    RCU_FLAG_SWRST         = (((uint32_t)(0x24U) << 6) | (uint32_t)(28U)),         
N    RCU_FLAG_FWDGTRST      = RCU_REGIDX_BIT(RSTSCK_REG_OFFSET, 29U),        /*!< FWDGT reset flags */
X    RCU_FLAG_FWDGTRST      = (((uint32_t)(0x24U) << 6) | (uint32_t)(29U)),         
N    RCU_FLAG_WWDGTRST      = RCU_REGIDX_BIT(RSTSCK_REG_OFFSET, 30U),        /*!< WWDGT reset flags */
X    RCU_FLAG_WWDGTRST      = (((uint32_t)(0x24U) << 6) | (uint32_t)(30U)),         
N    RCU_FLAG_LPRST         = RCU_REGIDX_BIT(RSTSCK_REG_OFFSET, 31U),        /*!< low-power reset flags */
X    RCU_FLAG_LPRST         = (((uint32_t)(0x24U) << 6) | (uint32_t)(31U)),         
N}rcu_flag_enum;
N
N/* clock stabilization and ckm interrupt flags */
Ntypedef enum
N{
N    RCU_INT_FLAG_IRC40KSTB = RCU_REGIDX_BIT(INT_REG_OFFSET, 0U),            /*!< IRC40K stabilization interrupt flag */
X    RCU_INT_FLAG_IRC40KSTB = (((uint32_t)(0x08U) << 6) | (uint32_t)(0U)),             
N    RCU_INT_FLAG_LXTALSTB  = RCU_REGIDX_BIT(INT_REG_OFFSET, 1U),            /*!< LXTAL stabilization interrupt flag */
X    RCU_INT_FLAG_LXTALSTB  = (((uint32_t)(0x08U) << 6) | (uint32_t)(1U)),             
N    RCU_INT_FLAG_IRC8MSTB  = RCU_REGIDX_BIT(INT_REG_OFFSET, 2U),            /*!< IRC8M stabilization interrupt flag */
X    RCU_INT_FLAG_IRC8MSTB  = (((uint32_t)(0x08U) << 6) | (uint32_t)(2U)),             
N    RCU_INT_FLAG_HXTALSTB  = RCU_REGIDX_BIT(INT_REG_OFFSET, 3U),            /*!< HXTAL stabilization interrupt flag */
X    RCU_INT_FLAG_HXTALSTB  = (((uint32_t)(0x08U) << 6) | (uint32_t)(3U)),             
N    RCU_INT_FLAG_PLLSTB    = RCU_REGIDX_BIT(INT_REG_OFFSET, 4U),            /*!< PLL stabilization interrupt flag */
X    RCU_INT_FLAG_PLLSTB    = (((uint32_t)(0x08U) << 6) | (uint32_t)(4U)),             
N#ifdef GD32F10X_CL
S    RCU_INT_FLAG_PLL1STB   = RCU_REGIDX_BIT(INT_REG_OFFSET, 5U),            /*!< PLL1 stabilization interrupt flag */
S    RCU_INT_FLAG_PLL2STB   = RCU_REGIDX_BIT(INT_REG_OFFSET, 6U),            /*!< PLL2 stabilization interrupt flag */
N#endif /* GD32F10X_CL */
N    RCU_INT_FLAG_CKM       = RCU_REGIDX_BIT(INT_REG_OFFSET, 7U),            /*!< HXTAL clock stuck interrupt flag */
X    RCU_INT_FLAG_CKM       = (((uint32_t)(0x08U) << 6) | (uint32_t)(7U)),             
N}rcu_int_flag_enum;
N
N/* clock stabilization and stuck interrupt flags clear */
Ntypedef enum
N{
N    RCU_INT_FLAG_IRC40KSTB_CLR = RCU_REGIDX_BIT(INT_REG_OFFSET, 16U),       /*!< IRC40K stabilization interrupt flags clear */
X    RCU_INT_FLAG_IRC40KSTB_CLR = (((uint32_t)(0x08U) << 6) | (uint32_t)(16U)),        
N    RCU_INT_FLAG_LXTALSTB_CLR  = RCU_REGIDX_BIT(INT_REG_OFFSET, 17U),       /*!< LXTAL stabilization interrupt flags clear */
X    RCU_INT_FLAG_LXTALSTB_CLR  = (((uint32_t)(0x08U) << 6) | (uint32_t)(17U)),        
N    RCU_INT_FLAG_IRC8MSTB_CLR  = RCU_REGIDX_BIT(INT_REG_OFFSET, 18U),       /*!< IRC8M stabilization interrupt flags clear */
X    RCU_INT_FLAG_IRC8MSTB_CLR  = (((uint32_t)(0x08U) << 6) | (uint32_t)(18U)),        
N    RCU_INT_FLAG_HXTALSTB_CLR  = RCU_REGIDX_BIT(INT_REG_OFFSET, 19U),       /*!< HXTAL stabilization interrupt flags clear */
X    RCU_INT_FLAG_HXTALSTB_CLR  = (((uint32_t)(0x08U) << 6) | (uint32_t)(19U)),        
N    RCU_INT_FLAG_PLLSTB_CLR    = RCU_REGIDX_BIT(INT_REG_OFFSET, 20U),       /*!< PLL stabilization interrupt flags clear */
X    RCU_INT_FLAG_PLLSTB_CLR    = (((uint32_t)(0x08U) << 6) | (uint32_t)(20U)),        
N#ifdef GD32F10X_CL
S    RCU_INT_FLAG_PLL1STB_CLR   = RCU_REGIDX_BIT(INT_REG_OFFSET, 21U),       /*!< PLL1 stabilization interrupt flags clear */
S    RCU_INT_FLAG_PLL2STB_CLR   = RCU_REGIDX_BIT(INT_REG_OFFSET, 22U),       /*!< PLL2 stabilization interrupt flags clear */
N#endif /* GD32F10X_CL */
N    RCU_INT_FLAG_CKM_CLR       = RCU_REGIDX_BIT(INT_REG_OFFSET, 23U),       /*!< CKM interrupt flags clear */
X    RCU_INT_FLAG_CKM_CLR       = (((uint32_t)(0x08U) << 6) | (uint32_t)(23U)),        
N}rcu_int_flag_clear_enum;
N
N/* clock stabilization interrupt enable or disable */
Ntypedef enum
N{
N    RCU_INT_IRC40KSTB       = RCU_REGIDX_BIT(INT_REG_OFFSET, 8U),           /*!< IRC40K stabilization interrupt */
X    RCU_INT_IRC40KSTB       = (((uint32_t)(0x08U) << 6) | (uint32_t)(8U)),            
N    RCU_INT_LXTALSTB        = RCU_REGIDX_BIT(INT_REG_OFFSET, 9U),           /*!< LXTAL stabilization interrupt */
X    RCU_INT_LXTALSTB        = (((uint32_t)(0x08U) << 6) | (uint32_t)(9U)),            
N    RCU_INT_IRC8MSTB        = RCU_REGIDX_BIT(INT_REG_OFFSET, 10U),          /*!< IRC8M stabilization interrupt */
X    RCU_INT_IRC8MSTB        = (((uint32_t)(0x08U) << 6) | (uint32_t)(10U)),           
N    RCU_INT_HXTALSTB        = RCU_REGIDX_BIT(INT_REG_OFFSET, 11U),          /*!< HXTAL stabilization interrupt */
X    RCU_INT_HXTALSTB        = (((uint32_t)(0x08U) << 6) | (uint32_t)(11U)),           
N    RCU_INT_PLLSTB          = RCU_REGIDX_BIT(INT_REG_OFFSET, 12U),          /*!< PLL stabilization interrupt */
X    RCU_INT_PLLSTB          = (((uint32_t)(0x08U) << 6) | (uint32_t)(12U)),           
N#ifdef GD32F10X_CL
S    RCU_INT_PLL1STB         = RCU_REGIDX_BIT(INT_REG_OFFSET, 13U),          /*!< PLL1 stabilization interrupt */
S    RCU_INT_PLL2STB         = RCU_REGIDX_BIT(INT_REG_OFFSET, 14U),          /*!< PLL2 stabilization interrupt */
N#endif /* GD32F10X_CL */
N}rcu_int_enum;
N
N/* oscillator types */
Ntypedef enum
N{
N    RCU_HXTAL      = RCU_REGIDX_BIT(CTL_REG_OFFSET, 16U),                   /*!< HXTAL */
X    RCU_HXTAL      = (((uint32_t)(0x00U) << 6) | (uint32_t)(16U)),                    
N    RCU_LXTAL      = RCU_REGIDX_BIT(BDCTL_REG_OFFSET, 0U),                  /*!< LXTAL */
X    RCU_LXTAL      = (((uint32_t)(0x20U) << 6) | (uint32_t)(0U)),                   
N    RCU_IRC8M      = RCU_REGIDX_BIT(CTL_REG_OFFSET, 0U),                    /*!< IRC8M */
X    RCU_IRC8M      = (((uint32_t)(0x00U) << 6) | (uint32_t)(0U)),                     
N    RCU_IRC40K     = RCU_REGIDX_BIT(RSTSCK_REG_OFFSET, 0U),                 /*!< IRC40K */
X    RCU_IRC40K     = (((uint32_t)(0x24U) << 6) | (uint32_t)(0U)),                  
N    RCU_PLL_CK     = RCU_REGIDX_BIT(CTL_REG_OFFSET, 24U),                   /*!< PLL */
X    RCU_PLL_CK     = (((uint32_t)(0x00U) << 6) | (uint32_t)(24U)),                    
N#ifdef GD32F10X_CL
S    RCU_PLL1_CK    = RCU_REGIDX_BIT(CTL_REG_OFFSET, 26U),                   /*!< PLL1 */
S    RCU_PLL2_CK    = RCU_REGIDX_BIT(CTL_REG_OFFSET, 28U),                   /*!< PLL2 */
N#endif /* GD32F10X_CL */
N}rcu_osci_type_enum;
N
N/* rcu clock frequency */
Ntypedef enum
N{
N    CK_SYS      = 0,                                                        /*!< system clock */
N    CK_AHB,                                                                 /*!< AHB clock */
N    CK_APB1,                                                                /*!< APB1 clock */
N    CK_APB2,                                                                /*!< APB2 clock */
N}rcu_clock_freq_enum;
N
N/* RCU_CFG0 register bit define */
N/* system clock source select */
N#define CFG0_SCS(regval)                (BITS(0,1) & ((uint32_t)(regval) << 0))
N#define RCU_CKSYSSRC_IRC8M              CFG0_SCS(0)                         /*!< system clock source select IRC8M */
N#define RCU_CKSYSSRC_HXTAL              CFG0_SCS(1)                         /*!< system clock source select HXTAL */
N#define RCU_CKSYSSRC_PLL                CFG0_SCS(2)                         /*!< system clock source select PLL */
N
N/* system clock source select status */
N#define CFG0_SCSS(regval)               (BITS(2,3) & ((uint32_t)(regval) << 2))
N#define RCU_SCSS_IRC8M                  CFG0_SCSS(0)                        /*!< system clock source select IRC8M */
N#define RCU_SCSS_HXTAL                  CFG0_SCSS(1)                        /*!< system clock source select HXTAL */
N#define RCU_SCSS_PLL                    CFG0_SCSS(2)                        /*!< system clock source select PLLP */
N
N/* AHB prescaler selection */
N#define CFG0_AHBPSC(regval)             (BITS(4,7) & ((uint32_t)(regval) << 4))
N#define RCU_AHB_CKSYS_DIV1              CFG0_AHBPSC(0)                      /*!< AHB prescaler select CK_SYS */
N#define RCU_AHB_CKSYS_DIV2              CFG0_AHBPSC(8)                      /*!< AHB prescaler select CK_SYS/2 */
N#define RCU_AHB_CKSYS_DIV4              CFG0_AHBPSC(9)                      /*!< AHB prescaler select CK_SYS/4 */
N#define RCU_AHB_CKSYS_DIV8              CFG0_AHBPSC(10)                     /*!< AHB prescaler select CK_SYS/8 */
N#define RCU_AHB_CKSYS_DIV16             CFG0_AHBPSC(11)                     /*!< AHB prescaler select CK_SYS/16 */
N#define RCU_AHB_CKSYS_DIV64             CFG0_AHBPSC(12)                     /*!< AHB prescaler select CK_SYS/64 */
N#define RCU_AHB_CKSYS_DIV128            CFG0_AHBPSC(13)                     /*!< AHB prescaler select CK_SYS/128 */
N#define RCU_AHB_CKSYS_DIV256            CFG0_AHBPSC(14)                     /*!< AHB prescaler select CK_SYS/256 */
N#define RCU_AHB_CKSYS_DIV512            CFG0_AHBPSC(15)                     /*!< AHB prescaler select CK_SYS/512 */
N
N/* APB1 prescaler selection */
N#define CFG0_APB1PSC(regval)            (BITS(8,10) & ((uint32_t)(regval) << 8))
N#define RCU_APB1_CKAHB_DIV1             CFG0_APB1PSC(0)                     /*!< APB1 prescaler select CK_AHB */
N#define RCU_APB1_CKAHB_DIV2             CFG0_APB1PSC(4)                     /*!< APB1 prescaler select CK_AHB/2 */
N#define RCU_APB1_CKAHB_DIV4             CFG0_APB1PSC(5)                     /*!< APB1 prescaler select CK_AHB/4 */
N#define RCU_APB1_CKAHB_DIV8             CFG0_APB1PSC(6)                     /*!< APB1 prescaler select CK_AHB/8 */
N#define RCU_APB1_CKAHB_DIV16            CFG0_APB1PSC(7)                     /*!< APB1 prescaler select CK_AHB/16 */
N
N/* APB2 prescaler selection */
N#define CFG0_APB2PSC(regval)            (BITS(11,13) & ((uint32_t)(regval) << 11))
N#define RCU_APB2_CKAHB_DIV1             CFG0_APB2PSC(0)                     /*!< APB2 prescaler select CK_AHB */
N#define RCU_APB2_CKAHB_DIV2             CFG0_APB2PSC(4)                     /*!< APB2 prescaler select CK_AHB/2 */
N#define RCU_APB2_CKAHB_DIV4             CFG0_APB2PSC(5)                     /*!< APB2 prescaler select CK_AHB/4 */
N#define RCU_APB2_CKAHB_DIV8             CFG0_APB2PSC(6)                     /*!< APB2 prescaler select CK_AHB/8 */
N#define RCU_APB2_CKAHB_DIV16            CFG0_APB2PSC(7)                     /*!< APB2 prescaler select CK_AHB/16 */
N
N/* ADC prescaler select */
N#define RCU_CKADC_CKAPB2_DIV2           ((uint32_t)0x00000000U)             /*!< ADC prescaler select CK_APB2/2 */
N#define RCU_CKADC_CKAPB2_DIV4           ((uint32_t)0x00000001U)             /*!< ADC prescaler select CK_APB2/4 */
N#define RCU_CKADC_CKAPB2_DIV6           ((uint32_t)0x00000002U)             /*!< ADC prescaler select CK_APB2/6 */
N#define RCU_CKADC_CKAPB2_DIV8           ((uint32_t)0x00000003U)             /*!< ADC prescaler select CK_APB2/8 */
N#define RCU_CKADC_CKAPB2_DIV12          ((uint32_t)0x00000005U)             /*!< ADC prescaler select CK_APB2/12 */
N#define RCU_CKADC_CKAPB2_DIV16          ((uint32_t)0x00000007U)             /*!< ADC prescaler select CK_APB2/16 */
N
N/* PLL clock source selection */
N#define RCU_PLLSRC_IRC8M_DIV2           ((uint32_t)0x00000000U)             /*!< IRC8M/2 clock selected as source clock of PLL */
N#define RCU_PLLSRC_HXTAL                RCU_CFG0_PLLSEL                     /*!< HXTAL clock selected as source clock of PLL */
N
N/* PLL clock multiplication factor */
N#define PLLMF_4                         RCU_CFG0_PLLMF_4                    /* bit 4 of PLLMF */
N
N#define CFG0_PLLMF(regval)              (BITS(18,21) & ((uint32_t)(regval) << 18))
N#define RCU_PLL_MUL2                    CFG0_PLLMF(0)                       /*!< PLL source clock multiply by 2 */
N#define RCU_PLL_MUL3                    CFG0_PLLMF(1)                       /*!< PLL source clock multiply by 3 */
N#define RCU_PLL_MUL4                    CFG0_PLLMF(2)                       /*!< PLL source clock multiply by 4 */
N#define RCU_PLL_MUL5                    CFG0_PLLMF(3)                       /*!< PLL source clock multiply by 5 */
N#define RCU_PLL_MUL6                    CFG0_PLLMF(4)                       /*!< PLL source clock multiply by 6 */
N#define RCU_PLL_MUL7                    CFG0_PLLMF(5)                       /*!< PLL source clock multiply by 7 */
N#define RCU_PLL_MUL8                    CFG0_PLLMF(6)                       /*!< PLL source clock multiply by 8 */
N#define RCU_PLL_MUL9                    CFG0_PLLMF(7)                       /*!< PLL source clock multiply by 9 */
N#define RCU_PLL_MUL10                   CFG0_PLLMF(8)                       /*!< PLL source clock multiply by 10 */
N#define RCU_PLL_MUL11                   CFG0_PLLMF(9)                       /*!< PLL source clock multiply by 11 */
N#define RCU_PLL_MUL12                   CFG0_PLLMF(10)                      /*!< PLL source clock multiply by 12 */
N#define RCU_PLL_MUL13                   CFG0_PLLMF(11)                      /*!< PLL source clock multiply by 13 */
N#define RCU_PLL_MUL14                   CFG0_PLLMF(12)                      /*!< PLL source clock multiply by 14 */
N#if (defined(GD32F10X_MD) || defined(GD32F10X_HD) || defined(GD32F10X_XD))
X#if (0L || 0L || 1L)
N#define RCU_PLL_MUL15                   CFG0_PLLMF(13)                      /*!< PLL source clock multiply by 15 */
N#elif defined(GD32F10X_CL)
S#define RCU_PLL_MUL6_5                  CFG0_PLLMF(13)                      /*!< PLL source clock multiply by 6.5 */
N#endif /* GD32F10X_MD and GD32F10X_HD and GD32F10X_XD */
N#define RCU_PLL_MUL16                   CFG0_PLLMF(14)                      /*!< PLL source clock multiply by 16 */
N#define RCU_PLL_MUL17                   (PLLMF_4 | CFG0_PLLMF(0))           /*!< PLL source clock multiply by 17 */
N#define RCU_PLL_MUL18                   (PLLMF_4 | CFG0_PLLMF(1))           /*!< PLL source clock multiply by 18 */
N#define RCU_PLL_MUL19                   (PLLMF_4 | CFG0_PLLMF(2))           /*!< PLL source clock multiply by 19 */
N#define RCU_PLL_MUL20                   (PLLMF_4 | CFG0_PLLMF(3))           /*!< PLL source clock multiply by 20 */
N#define RCU_PLL_MUL21                   (PLLMF_4 | CFG0_PLLMF(4))           /*!< PLL source clock multiply by 21 */
N#define RCU_PLL_MUL22                   (PLLMF_4 | CFG0_PLLMF(5))           /*!< PLL source clock multiply by 22 */
N#define RCU_PLL_MUL23                   (PLLMF_4 | CFG0_PLLMF(6))           /*!< PLL source clock multiply by 23 */
N#define RCU_PLL_MUL24                   (PLLMF_4 | CFG0_PLLMF(7))           /*!< PLL source clock multiply by 24 */
N#define RCU_PLL_MUL25                   (PLLMF_4 | CFG0_PLLMF(8))           /*!< PLL source clock multiply by 25 */
N#define RCU_PLL_MUL26                   (PLLMF_4 | CFG0_PLLMF(9))           /*!< PLL source clock multiply by 26 */
N#define RCU_PLL_MUL27                   (PLLMF_4 | CFG0_PLLMF(10))          /*!< PLL source clock multiply by 27 */
N#define RCU_PLL_MUL28                   (PLLMF_4 | CFG0_PLLMF(11))          /*!< PLL source clock multiply by 28 */
N#define RCU_PLL_MUL29                   (PLLMF_4 | CFG0_PLLMF(12))          /*!< PLL source clock multiply by 29 */
N#define RCU_PLL_MUL30                   (PLLMF_4 | CFG0_PLLMF(13))          /*!< PLL source clock multiply by 30 */
N#define RCU_PLL_MUL31                   (PLLMF_4 | CFG0_PLLMF(14))          /*!< PLL source clock multiply by 31 */
N#define RCU_PLL_MUL32                   (PLLMF_4 | CFG0_PLLMF(15))          /*!< PLL source clock multiply by 32 */
N
N/* USBD/USBFS prescaler select */
N#define CFG0_USBPSC(regval)             (BITS(22,23) & ((uint32_t)(regval) << 22))
N#define RCU_CKUSB_CKPLL_DIV1_5          CFG0_USBPSC(0)                      /*!< USBD/USBFS prescaler select CK_PLL/1.5 */
N#define RCU_CKUSB_CKPLL_DIV1            CFG0_USBPSC(1)                      /*!< USBD/USBFS prescaler select CK_PLL/1 */
N#define RCU_CKUSB_CKPLL_DIV2_5          CFG0_USBPSC(2)                      /*!< USBD/USBFS prescaler select CK_PLL/2.5 */
N#define RCU_CKUSB_CKPLL_DIV2            CFG0_USBPSC(3)                      /*!< USBD/USBFS prescaler select CK_PLL/2 */
N
N/* CKOUT0 clock source selection */
N#define CFG0_CKOUT0SEL(regval)          (BITS(24,27) & ((uint32_t)(regval) << 24))
N#define RCU_CKOUT0SRC_NONE              CFG0_CKOUT0SEL(0)                   /*!< no clock selected */
N#define RCU_CKOUT0SRC_CKSYS             CFG0_CKOUT0SEL(4)                   /*!< system clock selected */
N#define RCU_CKOUT0SRC_IRC8M             CFG0_CKOUT0SEL(5)                   /*!< internal 8M RC oscillator clock selected */
N#define RCU_CKOUT0SRC_HXTAL             CFG0_CKOUT0SEL(6)                   /*!< high speed crystal oscillator clock (HXTAL) selected */
N#define RCU_CKOUT0SRC_CKPLL_DIV2        CFG0_CKOUT0SEL(7)                   /*!< CK_PLL/2 clock selected */
N#ifdef GD32F10X_CL
S#define RCU_CKOUT0SRC_CKPLL1            CFG0_CKOUT0SEL(8)                   /*!< CK_PLL1 clock selected */
S#define RCU_CKOUT0SRC_CKPLL2_DIV2       CFG0_CKOUT0SEL(9)                   /*!< CK_PLL2/2 clock selected */
S#define RCU_CKOUT0SRC_EXT1              CFG0_CKOUT0SEL(10)                  /*!< EXT1 selected, to provide the external clock for ENET */
S#define RCU_CKOUT0SRC_CKPLL2            CFG0_CKOUT0SEL(11)                  /*!< CK_PLL2 clock selected */
N#endif /* GD32F10X_CL */
N
N/* RTC clock entry selection */
N#define BDCTL_RTCSRC(regval)            (BITS(8,9) & ((uint32_t)(regval) << 8))
N#define RCU_RTCSRC_NONE                 BDCTL_RTCSRC(0)                     /*!< no clock selected */
N#define RCU_RTCSRC_LXTAL                BDCTL_RTCSRC(1)                     /*!< RTC source clock select LXTAL  */
N#define RCU_RTCSRC_IRC40K               BDCTL_RTCSRC(2)                     /*!< RTC source clock select IRC40K */
N#define RCU_RTCSRC_HXTAL_DIV_128        BDCTL_RTCSRC(3)                     /*!< RTC source clock select HXTAL/128 */
N
N/* PREDV0 division factor */
N#define CFG1_PREDV0(regval)             (BITS(0,3) & ((uint32_t)(regval) << 0))
N#define RCU_PREDV0_DIV1                CFG1_PREDV0(0)                       /*!< PREDV0 input source clock not divided */
N#define RCU_PREDV0_DIV2                CFG1_PREDV0(1)                       /*!< PREDV0 input source clock divided by 2 */
N#define RCU_PREDV0_DIV3                CFG1_PREDV0(2)                       /*!< PREDV0 input source clock divided by 3 */
N#define RCU_PREDV0_DIV4                CFG1_PREDV0(3)                       /*!< PREDV0 input source clock divided by 4 */
N#define RCU_PREDV0_DIV5                CFG1_PREDV0(4)                       /*!< PREDV0 input source clock divided by 5 */
N#define RCU_PREDV0_DIV6                CFG1_PREDV0(5)                       /*!< PREDV0 input source clock divided by 6 */
N#define RCU_PREDV0_DIV7                CFG1_PREDV0(6)                       /*!< PREDV0 input source clock divided by 7 */
N#define RCU_PREDV0_DIV8                CFG1_PREDV0(7)                       /*!< PREDV0 input source clock divided by 8 */
N#define RCU_PREDV0_DIV9                CFG1_PREDV0(8)                       /*!< PREDV0 input source clock divided by 9 */
N#define RCU_PREDV0_DIV10               CFG1_PREDV0(9)                       /*!< PREDV0 input source clock divided by 10 */
N#define RCU_PREDV0_DIV11               CFG1_PREDV0(10)                      /*!< PREDV0 input source clock divided by 11 */
N#define RCU_PREDV0_DIV12               CFG1_PREDV0(11)                      /*!< PREDV0 input source clock divided by 12 */
N#define RCU_PREDV0_DIV13               CFG1_PREDV0(12)                      /*!< PREDV0 input source clock divided by 13 */
N#define RCU_PREDV0_DIV14               CFG1_PREDV0(13)                      /*!< PREDV0 input source clock divided by 14 */
N#define RCU_PREDV0_DIV15               CFG1_PREDV0(14)                      /*!< PREDV0 input source clock divided by 15 */
N#define RCU_PREDV0_DIV16               CFG1_PREDV0(15)                      /*!< PREDV0 input source clock divided by 16 */
N
N/* PREDV1 division factor */
N#define CFG1_PREDV1(regval)             (BITS(4,7) & ((uint32_t)(regval) << 4))
N#define RCU_PREDV1_DIV1                CFG1_PREDV1(0)                       /*!< PREDV1 input source clock not divided */
N#define RCU_PREDV1_DIV2                CFG1_PREDV1(1)                       /*!< PREDV1 input source clock divided by 2 */
N#define RCU_PREDV1_DIV3                CFG1_PREDV1(2)                       /*!< PREDV1 input source clock divided by 3 */
N#define RCU_PREDV1_DIV4                CFG1_PREDV1(3)                       /*!< PREDV1 input source clock divided by 4 */
N#define RCU_PREDV1_DIV5                CFG1_PREDV1(4)                       /*!< PREDV1 input source clock divided by 5 */
N#define RCU_PREDV1_DIV6                CFG1_PREDV1(5)                       /*!< PREDV1 input source clock divided by 6 */
N#define RCU_PREDV1_DIV7                CFG1_PREDV1(6)                       /*!< PREDV1 input source clock divided by 7 */
N#define RCU_PREDV1_DIV8                CFG1_PREDV1(7)                       /*!< PREDV1 input source clock divided by 8 */
N#define RCU_PREDV1_DIV9                CFG1_PREDV1(8)                       /*!< PREDV1 input source clock divided by 9 */
N#define RCU_PREDV1_DIV10               CFG1_PREDV1(9)                       /*!< PREDV1 input source clock divided by 10 */
N#define RCU_PREDV1_DIV11               CFG1_PREDV1(10)                      /*!< PREDV1 input source clock divided by 11 */
N#define RCU_PREDV1_DIV12               CFG1_PREDV1(11)                      /*!< PREDV1 input source clock divided by 12 */
N#define RCU_PREDV1_DIV13               CFG1_PREDV1(12)                      /*!< PREDV1 input source clock divided by 13 */
N#define RCU_PREDV1_DIV14               CFG1_PREDV1(13)                      /*!< PREDV1 input source clock divided by 14 */
N#define RCU_PREDV1_DIV15               CFG1_PREDV1(14)                      /*!< PREDV1 input source clock divided by 15 */
N#define RCU_PREDV1_DIV16               CFG1_PREDV1(15)                      /*!< PREDV1 input source clock divided by 16 */
N
N/* PLL1 clock multiplication factor */
N#define CFG1_PLL1MF(regval)             (BITS(8,11) & ((uint32_t)(regval) << 8))
N#define RCU_PLL1_MUL8                   CFG1_PLL1MF(6)                      /*!< PLL1 source clock multiply by 8 */
N#define RCU_PLL1_MUL9                   CFG1_PLL1MF(7)                      /*!< PLL1 source clock multiply by 9 */
N#define RCU_PLL1_MUL10                  CFG1_PLL1MF(8)                      /*!< PLL1 source clock multiply by 10 */
N#define RCU_PLL1_MUL11                  CFG1_PLL1MF(9)                      /*!< PLL1 source clock multiply by 11 */
N#define RCU_PLL1_MUL12                  CFG1_PLL1MF(10)                     /*!< PLL1 source clock multiply by 12 */
N#define RCU_PLL1_MUL13                  CFG1_PLL1MF(11)                     /*!< PLL1 source clock multiply by 13 */
N#define RCU_PLL1_MUL14                  CFG1_PLL1MF(12)                     /*!< PLL1 source clock multiply by 14 */
N#define RCU_PLL1_MUL15                  CFG1_PLL1MF(13)                     /*!< PLL1 source clock multiply by 15 */
N#define RCU_PLL1_MUL16                  CFG1_PLL1MF(14)                     /*!< PLL1 source clock multiply by 16 */
N#define RCU_PLL1_MUL20                  CFG1_PLL1MF(15)                     /*!< PLL1 source clock multiply by 20 */
N
N/* PLL2 clock multiplication factor */
N#define CFG1_PLL2MF(regval)             (BITS(12,15) & ((uint32_t)(regval) << 12))
N#define RCU_PLL2_MUL8                   CFG1_PLL2MF(6)                      /*!< PLL2 source clock multiply by 8 */
N#define RCU_PLL2_MUL9                   CFG1_PLL2MF(7)                      /*!< PLL2 source clock multiply by 9 */
N#define RCU_PLL2_MUL10                  CFG1_PLL2MF(8)                      /*!< PLL2 source clock multiply by 10 */
N#define RCU_PLL2_MUL11                  CFG1_PLL2MF(9)                      /*!< PLL2 source clock multiply by 11 */
N#define RCU_PLL2_MUL12                  CFG1_PLL2MF(10)                     /*!< PLL2 source clock multiply by 12 */
N#define RCU_PLL2_MUL13                  CFG1_PLL2MF(11)                     /*!< PLL2 source clock multiply by 13 */
N#define RCU_PLL2_MUL14                  CFG1_PLL2MF(12)                     /*!< PLL2 source clock multiply by 14 */
N#define RCU_PLL2_MUL15                  CFG1_PLL2MF(13)                     /*!< PLL2 source clock multiply by 15 */
N#define RCU_PLL2_MUL16                  CFG1_PLL2MF(14)                     /*!< PLL2 source clock multiply by 16 */
N#define RCU_PLL2_MUL20                  CFG1_PLL2MF(15)                     /*!< PLL2 source clock multiply by 20 */
N
N#ifdef GD32F10X_CL
S/* PREDV0 input clock source selection */
S#define RCU_PREDV0SRC_HXTAL             ((uint32_t)0x00000000U)             /*!< HXTAL selected as PREDV0 input source clock */
S#define RCU_PREDV0SRC_CKPLL1            RCU_CFG1_PREDV0SEL                  /*!< CK_PLL1 selected as PREDV0 input source clock */
S
S/* I2S1 clock source selection */
S#define RCU_I2S1SRC_CKSYS               ((uint32_t)0x00000000U)             /*!< system clock selected as I2S1 source clock */
S#define RCU_I2S1SRC_CKPLL2_MUL2         RCU_CFG1_I2S1SEL                    /*!< (CK_PLL2 x 2) selected as I2S1 source clock */
S
S/* I2S2 clock source selection */
S#define RCU_I2S2SRC_CKSYS               ((uint32_t)0x00000000U)             /*!< system clock selected as I2S2 source clock */
S#define RCU_I2S2SRC_CKPLL2_MUL2         RCU_CFG1_I2S2SEL                    /*!< (CK_PLL2 x 2) selected as I2S2 source clock */
N#endif /* GD32F10X_CL */
N
N/* deep-sleep mode voltage */
N#define DSV_DSLPVS(regval)              (BITS(0,2) & ((uint32_t)(regval) << 0))
N#define RCU_DEEPSLEEP_V_1_2             DSV_DSLPVS(0)                       /*!< core voltage is 1.2V in deep-sleep mode */
N#define RCU_DEEPSLEEP_V_1_1             DSV_DSLPVS(1)                       /*!< core voltage is 1.1V in deep-sleep mode */
N#define RCU_DEEPSLEEP_V_1_0             DSV_DSLPVS(2)                       /*!< core voltage is 1.0V in deep-sleep mode */
N#define RCU_DEEPSLEEP_V_0_9             DSV_DSLPVS(3)                       /*!< core voltage is 0.9V in deep-sleep mode */
N
N/* function declarations */
N/* initialization, peripheral clock enable/disable functions */
N/* deinitialize the RCU */
Nvoid rcu_deinit(void);
N/* enable the peripherals clock */
Nvoid rcu_periph_clock_enable(rcu_periph_enum periph);
N/* disable the peripherals clock */
Nvoid rcu_periph_clock_disable(rcu_periph_enum periph);
N/* enable the peripherals clock when sleep mode */
Nvoid rcu_periph_clock_sleep_enable(rcu_periph_sleep_enum periph);
N/* disable the peripherals clock when sleep mode */
Nvoid rcu_periph_clock_sleep_disable(rcu_periph_sleep_enum periph);
N/* reset the peripherals */
Nvoid rcu_periph_reset_enable(rcu_periph_reset_enum periph_reset);
N/* disable reset the peripheral */
Nvoid rcu_periph_reset_disable(rcu_periph_reset_enum periph_reset);
N/* reset the BKP domain */
Nvoid rcu_bkp_reset_enable(void);
N/* disable the BKP domain reset */
Nvoid rcu_bkp_reset_disable(void);
N
N/* clock configuration functions */
N/* configure the system clock source */
Nvoid rcu_system_clock_source_config(uint32_t ck_sys);
N/* get the system clock source */
Nuint32_t rcu_system_clock_source_get(void);
N/* configure the AHB prescaler selection */
Nvoid rcu_ahb_clock_config(uint32_t ck_ahb);
N/* configure the APB1 prescaler selection */
Nvoid rcu_apb1_clock_config(uint32_t ck_apb1);
N/* configure the APB2 prescaler selection */
Nvoid rcu_apb2_clock_config(uint32_t ck_apb2);
N/* configure the CK_OUT0 clock source and divider */
Nvoid rcu_ckout0_config(uint32_t ckout0_src);
N/* configure the PLL clock source selection and PLL multiply factor */
Nvoid rcu_pll_config(uint32_t pll_src, uint32_t pll_mul);
N#if (defined(GD32F10X_MD) || defined(GD32F10X_HD) || defined(GD32F10X_XD))
X#if (0L || 0L || 1L)
N/* configure the PREDV0 division factor and clock source */
Nvoid rcu_predv0_config(uint32_t predv0_div);
N#elif defined(GD32F10X_CL)
S/* configure the PREDV0 division factor and clock source */
Svoid rcu_predv0_config(uint32_t predv0_source, uint32_t predv0_div);
S/* configure the PREDV1 division factor */
Svoid rcu_predv1_config(uint32_t predv1_div);
S/* configure the PLL1 clock */
Svoid rcu_pll1_config(uint32_t pll_mul);
S/* configure the PLL2 clock */
Svoid rcu_pll2_config(uint32_t pll_mul);
N#endif /* GD32F10X_MD and GD32F10X_HD and GD32F10X_XD */
N
N/* peripheral clock configuration functions */
N/* configure the ADC division factor */
Nvoid rcu_adc_clock_config(uint32_t adc_psc);
N/* configure the USBD/USBFS prescaler factor */
Nvoid rcu_usb_clock_config(uint32_t usb_psc);
N/* configure the RTC clock source selection */
Nvoid rcu_rtc_clock_config(uint32_t rtc_clock_source);
N#ifdef GD32F10X_CL
S/* configure the I2S1 clock source selection */
Svoid rcu_i2s1_clock_config(uint32_t i2s_clock_source);
S/* configure the I2S2 clock source selection */
Svoid rcu_i2s2_clock_config(uint32_t i2s_clock_source);
N#endif /* GD32F10X_CL */
N
N/* interrupt & flag functions */
N/* get the clock stabilization and periphral reset flags */
NFlagStatus rcu_flag_get(rcu_flag_enum flag);
N/* clear the reset flag */
Nvoid rcu_all_reset_flag_clear(void);
N/* get the clock stabilization interrupt and ckm flags */
NFlagStatus rcu_interrupt_flag_get(rcu_int_flag_enum int_flag);
N/* clear the interrupt flags */
Nvoid rcu_interrupt_flag_clear(rcu_int_flag_clear_enum int_flag_clear);
N/* enable the stabilization interrupt */
Nvoid rcu_interrupt_enable(rcu_int_enum stab_int);
N/* disable the stabilization interrupt */
Nvoid rcu_interrupt_disable(rcu_int_enum stab_int);
N
N/* oscillator configuration functions */
N/* wait for oscillator stabilization flags is SET or oscillator startup is timeout */
NErrStatus rcu_osci_stab_wait(rcu_osci_type_enum osci);
N/* turn on the oscillator */
Nvoid rcu_osci_on(rcu_osci_type_enum osci);
N/* turn off the oscillator */
Nvoid rcu_osci_off(rcu_osci_type_enum osci);
N/* enable the oscillator bypass mode, HXTALEN or LXTALEN must be reset before it */
Nvoid rcu_osci_bypass_mode_enable(rcu_osci_type_enum osci);
N/* disable the oscillator bypass mode, HXTALEN or LXTALEN must be reset before it */
Nvoid rcu_osci_bypass_mode_disable(rcu_osci_type_enum osci);
N/* enable the HXTAL clock monitor */
Nvoid rcu_hxtal_clock_monitor_enable(void);
N/* disable the HXTAL clock monitor */
Nvoid rcu_hxtal_clock_monitor_disable(void);
N
N/* set the IRC8M adjust value */
Nvoid rcu_irc8m_adjust_value_set(uint8_t irc8m_adjval);
N/* set the deep sleep mode voltage */
Nvoid rcu_deepsleep_voltage_set(uint32_t dsvol);
N
N/* get the system clock, bus and peripheral clock frequency */
Nuint32_t rcu_clock_freq_get(rcu_clock_freq_enum clock);
N
N#endif /* GD32F10X_RCU_H */
L 46 ".\User\gd32f10x_libopt.h" 2
N#include "gd32f10x_exti.h"
L 1 ".\Libraries\inc\gd32f10x_exti.h" 1
N/*!
N    \file    gd32f10x_exti.h
N    \brief   definitions for the EXTI
N
N    \version 2014-12-26, V1.0.0, firmware for GD32F10x
N    \version 2017-06-20, V2.0.0, firmware for GD32F10x
N    \version 2018-07-31, V2.1.0, firmware for GD32F10x
N*/
N
N/*
N    Copyright (c) 2018, GigaDevice Semiconductor Inc.
N
N    All rights reserved.
N
N    Redistribution and use in source and binary forms, with or without modification, 
Nare permitted provided that the following conditions are met:
N
N    1. Redistributions of source code must retain the above copyright notice, this 
N       list of conditions and the following disclaimer.
N    2. Redistributions in binary form must reproduce the above copyright notice, 
N       this list of conditions and the following disclaimer in the documentation 
N       and/or other materials provided with the distribution.
N    3. Neither the name of the copyright holder nor the names of its contributors 
N       may be used to endorse or promote products derived from this software without 
N       specific prior written permission.
N
N    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
NAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
NWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
NIN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
NINDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
NNOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
NPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
NWHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
NARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
NOF SUCH DAMAGE.
N*/
N
N#ifndef GD32F10X_EXTI_H
N#define GD32F10X_EXTI_H
N
N#include "gd32f10x.h"
N
N/* EXTI definitions */
N#define EXTI                         EXTI_BASE
N
N/* registers definitions */
N#define EXTI_INTEN                   REG32(EXTI + 0x00U)      /*!< interrupt enable register */
N#define EXTI_EVEN                    REG32(EXTI + 0x04U)      /*!< event enable register */
N#define EXTI_RTEN                    REG32(EXTI + 0x08U)      /*!< rising edge trigger enable register */
N#define EXTI_FTEN                    REG32(EXTI + 0x0CU)      /*!< falling trigger enable register */
N#define EXTI_SWIEV                   REG32(EXTI + 0x10U)      /*!< software interrupt event register */
N#define EXTI_PD                      REG32(EXTI + 0x14U)      /*!< pending register */
N
N/* bits definitions */
N/* EXTI_INTEN */
N#define EXTI_INTEN_INTEN0            BIT(0)                   /*!< interrupt from line 0 */
N#define EXTI_INTEN_INTEN1            BIT(1)                   /*!< interrupt from line 1 */
N#define EXTI_INTEN_INTEN2            BIT(2)                   /*!< interrupt from line 2 */
N#define EXTI_INTEN_INTEN3            BIT(3)                   /*!< interrupt from line 3 */
N#define EXTI_INTEN_INTEN4            BIT(4)                   /*!< interrupt from line 4 */
N#define EXTI_INTEN_INTEN5            BIT(5)                   /*!< interrupt from line 5 */
N#define EXTI_INTEN_INTEN6            BIT(6)                   /*!< interrupt from line 6 */
N#define EXTI_INTEN_INTEN7            BIT(7)                   /*!< interrupt from line 7 */
N#define EXTI_INTEN_INTEN8            BIT(8)                   /*!< interrupt from line 8 */
N#define EXTI_INTEN_INTEN9            BIT(9)                   /*!< interrupt from line 9 */
N#define EXTI_INTEN_INTEN10           BIT(10)                  /*!< interrupt from line 10 */
N#define EXTI_INTEN_INTEN11           BIT(11)                  /*!< interrupt from line 11 */
N#define EXTI_INTEN_INTEN12           BIT(12)                  /*!< interrupt from line 12 */
N#define EXTI_INTEN_INTEN13           BIT(13)                  /*!< interrupt from line 13 */
N#define EXTI_INTEN_INTEN14           BIT(14)                  /*!< interrupt from line 14 */
N#define EXTI_INTEN_INTEN15           BIT(15)                  /*!< interrupt from line 15 */
N#define EXTI_INTEN_INTEN16           BIT(16)                  /*!< interrupt from line 16 */
N#define EXTI_INTEN_INTEN17           BIT(17)                  /*!< interrupt from line 17 */
N#define EXTI_INTEN_INTEN18           BIT(18)                  /*!< interrupt from line 18 */
N#define EXTI_INTEN_INTEN19           BIT(19)                  /*!< interrupt from line 19 */
N
N/* EXTI_EVEN */
N#define EXTI_EVEN_EVEN0              BIT(0)                   /*!< event from line 0 */
N#define EXTI_EVEN_EVEN1              BIT(1)                   /*!< event from line 1 */
N#define EXTI_EVEN_EVEN2              BIT(2)                   /*!< event from line 2 */
N#define EXTI_EVEN_EVEN3              BIT(3)                   /*!< event from line 3 */
N#define EXTI_EVEN_EVEN4              BIT(4)                   /*!< event from line 4 */
N#define EXTI_EVEN_EVEN5              BIT(5)                   /*!< event from line 5 */
N#define EXTI_EVEN_EVEN6              BIT(6)                   /*!< event from line 6 */
N#define EXTI_EVEN_EVEN7              BIT(7)                   /*!< event from line 7 */
N#define EXTI_EVEN_EVEN8              BIT(8)                   /*!< event from line 8 */
N#define EXTI_EVEN_EVEN9              BIT(9)                   /*!< event from line 9 */
N#define EXTI_EVEN_EVEN10             BIT(10)                  /*!< event from line 10 */
N#define EXTI_EVEN_EVEN11             BIT(11)                  /*!< event from line 11 */
N#define EXTI_EVEN_EVEN12             BIT(12)                  /*!< event from line 12 */
N#define EXTI_EVEN_EVEN13             BIT(13)                  /*!< event from line 13 */
N#define EXTI_EVEN_EVEN14             BIT(14)                  /*!< event from line 14 */
N#define EXTI_EVEN_EVEN15             BIT(15)                  /*!< event from line 15 */
N#define EXTI_EVEN_EVEN16             BIT(16)                  /*!< event from line 16 */
N#define EXTI_EVEN_EVEN17             BIT(17)                  /*!< event from line 17 */
N#define EXTI_EVEN_EVEN18             BIT(18)                  /*!< event from line 18 */
N#define EXTI_EVEN_EVEN19             BIT(19)                  /*!< event from line 19 */
N
N/* EXTI_RTEN */
N#define EXTI_RTEN_RTEN0              BIT(0)                   /*!< rising edge from line 0 */
N#define EXTI_RTEN_RTEN1              BIT(1)                   /*!< rising edge from line 1 */
N#define EXTI_RTEN_RTEN2              BIT(2)                   /*!< rising edge from line 2 */
N#define EXTI_RTEN_RTEN3              BIT(3)                   /*!< rising edge from line 3 */
N#define EXTI_RTEN_RTEN4              BIT(4)                   /*!< rising edge from line 4 */
N#define EXTI_RTEN_RTEN5              BIT(5)                   /*!< rising edge from line 5 */
N#define EXTI_RTEN_RTEN6              BIT(6)                   /*!< rising edge from line 6 */
N#define EXTI_RTEN_RTEN7              BIT(7)                   /*!< rising edge from line 7 */
N#define EXTI_RTEN_RTEN8              BIT(8)                   /*!< rising edge from line 8 */
N#define EXTI_RTEN_RTEN9              BIT(9)                   /*!< rising edge from line 9 */
N#define EXTI_RTEN_RTEN10             BIT(10)                  /*!< rising edge from line 10 */
N#define EXTI_RTEN_RTEN11             BIT(11)                  /*!< rising edge from line 11 */
N#define EXTI_RTEN_RTEN12             BIT(12)                  /*!< rising edge from line 12 */
N#define EXTI_RTEN_RTEN13             BIT(13)                  /*!< rising edge from line 13 */
N#define EXTI_RTEN_RTEN14             BIT(14)                  /*!< rising edge from line 14 */
N#define EXTI_RTEN_RTEN15             BIT(15)                  /*!< rising edge from line 15 */
N#define EXTI_RTEN_RTEN16             BIT(16)                  /*!< rising edge from line 16 */
N#define EXTI_RTEN_RTEN17             BIT(17)                  /*!< rising edge from line 17 */
N#define EXTI_RTEN_RTEN18             BIT(18)                  /*!< rising edge from line 18 */
N#define EXTI_RTEN_RTEN19             BIT(19)                  /*!< rising edge from line 19 */
N
N/* EXTI_FTEN */
N#define EXTI_FTEN_FTEN0              BIT(0)                   /*!< falling edge from line 0 */
N#define EXTI_FTEN_FTEN1              BIT(1)                   /*!< falling edge from line 1 */
N#define EXTI_FTEN_FTEN2              BIT(2)                   /*!< falling edge from line 2 */
N#define EXTI_FTEN_FTEN3              BIT(3)                   /*!< falling edge from line 3 */
N#define EXTI_FTEN_FTEN4              BIT(4)                   /*!< falling edge from line 4 */
N#define EXTI_FTEN_FTEN5              BIT(5)                   /*!< falling edge from line 5 */
N#define EXTI_FTEN_FTEN6              BIT(6)                   /*!< falling edge from line 6 */
N#define EXTI_FTEN_FTEN7              BIT(7)                   /*!< falling edge from line 7 */
N#define EXTI_FTEN_FTEN8              BIT(8)                   /*!< falling edge from line 8 */
N#define EXTI_FTEN_FTEN9              BIT(9)                   /*!< falling edge from line 9 */
N#define EXTI_FTEN_FTEN10             BIT(10)                  /*!< falling edge from line 10 */
N#define EXTI_FTEN_FTEN11             BIT(11)                  /*!< falling edge from line 11 */
N#define EXTI_FTEN_FTEN12             BIT(12)                  /*!< falling edge from line 12 */
N#define EXTI_FTEN_FTEN13             BIT(13)                  /*!< falling edge from line 13 */
N#define EXTI_FTEN_FTEN14             BIT(14)                  /*!< falling edge from line 14 */
N#define EXTI_FTEN_FTEN15             BIT(15)                  /*!< falling edge from line 15 */
N#define EXTI_FTEN_FTEN16             BIT(16)                  /*!< falling edge from line 16 */
N#define EXTI_FTEN_FTEN17             BIT(17)                  /*!< falling edge from line 17 */
N#define EXTI_FTEN_FTEN18             BIT(18)                  /*!< falling edge from line 18 */
N#define EXTI_FTEN_FTEN19             BIT(19)                  /*!< falling edge from line 19 */
N
N/* EXTI_SWIEV */
N#define EXTI_SWIEV_SWIEV0            BIT(0)                   /*!< software interrupt/event request from line 0 */
N#define EXTI_SWIEV_SWIEV1            BIT(1)                   /*!< software interrupt/event request from line 1 */
N#define EXTI_SWIEV_SWIEV2            BIT(2)                   /*!< software interrupt/event request from line 2 */
N#define EXTI_SWIEV_SWIEV3            BIT(3)                   /*!< software interrupt/event request from line 3 */
N#define EXTI_SWIEV_SWIEV4            BIT(4)                   /*!< software interrupt/event request from line 4 */
N#define EXTI_SWIEV_SWIEV5            BIT(5)                   /*!< software interrupt/event request from line 5 */
N#define EXTI_SWIEV_SWIEV6            BIT(6)                   /*!< software interrupt/event request from line 6 */
N#define EXTI_SWIEV_SWIEV7            BIT(7)                   /*!< software interrupt/event request from line 7 */
N#define EXTI_SWIEV_SWIEV8            BIT(8)                   /*!< software interrupt/event request from line 8 */
N#define EXTI_SWIEV_SWIEV9            BIT(9)                   /*!< software interrupt/event request from line 9 */
N#define EXTI_SWIEV_SWIEV10           BIT(10)                  /*!< software interrupt/event request from line 10 */
N#define EXTI_SWIEV_SWIEV11           BIT(11)                  /*!< software interrupt/event request from line 11 */
N#define EXTI_SWIEV_SWIEV12           BIT(12)                  /*!< software interrupt/event request from line 12 */
N#define EXTI_SWIEV_SWIEV13           BIT(13)                  /*!< software interrupt/event request from line 13 */
N#define EXTI_SWIEV_SWIEV14           BIT(14)                  /*!< software interrupt/event request from line 14 */
N#define EXTI_SWIEV_SWIEV15           BIT(15)                  /*!< software interrupt/event request from line 15 */
N#define EXTI_SWIEV_SWIEV16           BIT(16)                  /*!< software interrupt/event request from line 16 */
N#define EXTI_SWIEV_SWIEV17           BIT(17)                  /*!< software interrupt/event request from line 17 */
N#define EXTI_SWIEV_SWIEV18           BIT(18)                  /*!< software interrupt/event request from line 18 */
N#define EXTI_SWIEV_SWIEV19           BIT(19)                  /*!< software interrupt/event request from line 19 */
N
N/* EXTI_PD */
N#define EXTI_PD_PD0                  BIT(0)                   /*!< interrupt/event pending status from line 0 */
N#define EXTI_PD_PD1                  BIT(1)                   /*!< interrupt/event pending status from line 1 */
N#define EXTI_PD_PD2                  BIT(2)                   /*!< interrupt/event pending status from line 2 */
N#define EXTI_PD_PD3                  BIT(3)                   /*!< interrupt/event pending status from line 3 */
N#define EXTI_PD_PD4                  BIT(4)                   /*!< interrupt/event pending status from line 4 */
N#define EXTI_PD_PD5                  BIT(5)                   /*!< interrupt/event pending status from line 5 */
N#define EXTI_PD_PD6                  BIT(6)                   /*!< interrupt/event pending status from line 6 */
N#define EXTI_PD_PD7                  BIT(7)                   /*!< interrupt/event pending status from line 7 */
N#define EXTI_PD_PD8                  BIT(8)                   /*!< interrupt/event pending status from line 8 */
N#define EXTI_PD_PD9                  BIT(9)                   /*!< interrupt/event pending status from line 9 */
N#define EXTI_PD_PD10                 BIT(10)                  /*!< interrupt/event pending status from line 10 */
N#define EXTI_PD_PD11                 BIT(11)                  /*!< interrupt/event pending status from line 11 */
N#define EXTI_PD_PD12                 BIT(12)                  /*!< interrupt/event pending status from line 12 */
N#define EXTI_PD_PD13                 BIT(13)                  /*!< interrupt/event pending status from line 13 */
N#define EXTI_PD_PD14                 BIT(14)                  /*!< interrupt/event pending status from line 14 */
N#define EXTI_PD_PD15                 BIT(15)                  /*!< interrupt/event pending status from line 15 */
N#define EXTI_PD_PD16                 BIT(16)                  /*!< interrupt/event pending status from line 16 */
N#define EXTI_PD_PD17                 BIT(17)                  /*!< interrupt/event pending status from line 17 */
N#define EXTI_PD_PD18                 BIT(18)                  /*!< interrupt/event pending status from line 18 */
N#define EXTI_PD_PD19                 BIT(19)                  /*!< interrupt/event pending status from line 19 */
N
N/* constants definitions */
N/* EXTI line number */
Ntypedef enum
N{ 
N    EXTI_0      = BIT(0),                                     /*!< EXTI line 0 */
X    EXTI_0      = ((uint32_t)((uint32_t)0x01U<<(0))),                                      
N    EXTI_1      = BIT(1),                                     /*!< EXTI line 1 */
X    EXTI_1      = ((uint32_t)((uint32_t)0x01U<<(1))),                                      
N    EXTI_2      = BIT(2),                                     /*!< EXTI line 2 */
X    EXTI_2      = ((uint32_t)((uint32_t)0x01U<<(2))),                                      
N    EXTI_3      = BIT(3),                                     /*!< EXTI line 3 */
X    EXTI_3      = ((uint32_t)((uint32_t)0x01U<<(3))),                                      
N    EXTI_4      = BIT(4),                                     /*!< EXTI line 4 */
X    EXTI_4      = ((uint32_t)((uint32_t)0x01U<<(4))),                                      
N    EXTI_5      = BIT(5),                                     /*!< EXTI line 5 */
X    EXTI_5      = ((uint32_t)((uint32_t)0x01U<<(5))),                                      
N    EXTI_6      = BIT(6),                                     /*!< EXTI line 6 */
X    EXTI_6      = ((uint32_t)((uint32_t)0x01U<<(6))),                                      
N    EXTI_7      = BIT(7),                                     /*!< EXTI line 7 */
X    EXTI_7      = ((uint32_t)((uint32_t)0x01U<<(7))),                                      
N    EXTI_8      = BIT(8),                                     /*!< EXTI line 8 */
X    EXTI_8      = ((uint32_t)((uint32_t)0x01U<<(8))),                                      
N    EXTI_9      = BIT(9),                                     /*!< EXTI line 9 */
X    EXTI_9      = ((uint32_t)((uint32_t)0x01U<<(9))),                                      
N    EXTI_10     = BIT(10),                                    /*!< EXTI line 10 */
X    EXTI_10     = ((uint32_t)((uint32_t)0x01U<<(10))),                                     
N    EXTI_11     = BIT(11),                                    /*!< EXTI line 11 */
X    EXTI_11     = ((uint32_t)((uint32_t)0x01U<<(11))),                                     
N    EXTI_12     = BIT(12),                                    /*!< EXTI line 12 */
X    EXTI_12     = ((uint32_t)((uint32_t)0x01U<<(12))),                                     
N    EXTI_13     = BIT(13),                                    /*!< EXTI line 13 */
X    EXTI_13     = ((uint32_t)((uint32_t)0x01U<<(13))),                                     
N    EXTI_14     = BIT(14),                                    /*!< EXTI line 14 */
X    EXTI_14     = ((uint32_t)((uint32_t)0x01U<<(14))),                                     
N    EXTI_15     = BIT(15),                                    /*!< EXTI line 15 */
X    EXTI_15     = ((uint32_t)((uint32_t)0x01U<<(15))),                                     
N    EXTI_16     = BIT(16),                                    /*!< EXTI line 16 */
X    EXTI_16     = ((uint32_t)((uint32_t)0x01U<<(16))),                                     
N    EXTI_17     = BIT(17),                                    /*!< EXTI line 17 */
X    EXTI_17     = ((uint32_t)((uint32_t)0x01U<<(17))),                                     
N    EXTI_18     = BIT(18),                                    /*!< EXTI line 18 */
X    EXTI_18     = ((uint32_t)((uint32_t)0x01U<<(18))),                                     
N    EXTI_19     = BIT(19),                                    /*!< EXTI line 19 */
X    EXTI_19     = ((uint32_t)((uint32_t)0x01U<<(19))),                                     
N}exti_line_enum;
N
N/* external interrupt and event  */
Ntypedef enum
N{
N    EXTI_INTERRUPT   = 0,                                     /*!< EXTI interrupt mode */
N    EXTI_EVENT                                                /*!< EXTI event mode */
N}exti_mode_enum;
N
N/* interrupt trigger mode */
Ntypedef enum
N{ 
N    EXTI_TRIG_RISING = 0,                                     /*!< EXTI rising edge trigger */
N    EXTI_TRIG_FALLING,                                        /*!< EXTI falling edge trigger */
N    EXTI_TRIG_BOTH                                            /*!< EXTI rising edge and falling edge trigger */
N}exti_trig_type_enum;
N
N/* function declarations */
N/* initialization, EXTI lines configuration functions */
N/* deinitialize the EXTI */
Nvoid exti_deinit(void);
N/* enable the configuration of EXTI initialize */
Nvoid exti_init(exti_line_enum linex, exti_mode_enum mode, exti_trig_type_enum trig_type);
N/* enable the interrupts from EXTI line x */
Nvoid exti_interrupt_enable(exti_line_enum linex);
N/* enable the events from EXTI line x */
Nvoid exti_event_enable(exti_line_enum linex);
N/* disable the interrupts from EXTI line x */
Nvoid exti_interrupt_disable(exti_line_enum linex);
N/* disable the events from EXTI line x */
Nvoid exti_event_disable(exti_line_enum linex);
N
N/* interrupt & flag functions */
N/* get EXTI lines pending flag */
NFlagStatus exti_flag_get(exti_line_enum linex);
N/* clear EXTI lines pending flag */
Nvoid exti_flag_clear(exti_line_enum linex);
N/* get EXTI lines flag when the interrupt flag is set */
NFlagStatus exti_interrupt_flag_get(exti_line_enum linex);
N/* clear EXTI lines pending flag */
Nvoid exti_interrupt_flag_clear(exti_line_enum linex);
N/* enable the EXTI software interrupt event  */
Nvoid exti_software_interrupt_enable(exti_line_enum linex);
N/* disable the EXTI software interrupt event  */
Nvoid exti_software_interrupt_disable(exti_line_enum linex);
N
N#endif /* GD32F10X_EXTI_H */
L 47 ".\User\gd32f10x_libopt.h" 2
N#include "gd32f10x_gpio.h"
L 1 ".\Libraries\inc\gd32f10x_gpio.h" 1
N/*!
N    \file  gd32f10x_gpio.h
N    \brief definitions for the GPIO
N    
N    \version 2014-12-26, V1.0.0, firmware for GD32F10x
N    \version 2017-06-20, V2.0.0, firmware for GD32F10x
N    \version 2018-07-31, V2.1.0, firmware for GD32F10x
N*/
N
N/*
N    Copyright (c) 2018, GigaDevice Semiconductor Inc.
N
N    All rights reserved.
N
N    Redistribution and use in source and binary forms, with or without modification, 
Nare permitted provided that the following conditions are met:
N
N    1. Redistributions of source code must retain the above copyright notice, this 
N       list of conditions and the following disclaimer.
N    2. Redistributions in binary form must reproduce the above copyright notice, 
N       this list of conditions and the following disclaimer in the documentation 
N       and/or other materials provided with the distribution.
N    3. Neither the name of the copyright holder nor the names of its contributors 
N       may be used to endorse or promote products derived from this software without 
N       specific prior written permission.
N
N    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
NAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
NWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
NIN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
NINDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
NNOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
NPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
NWHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
NARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
NOF SUCH DAMAGE.
N*/
N
N#ifndef GD32F10x_GPIO_H
N#define GD32F10x_GPIO_H
N
N#include "gd32f10x.h"
N
N/* GPIOx(x=A,B,C,D,E,F,G) definitions */
N#define GPIOA                      (GPIO_BASE + 0x00000000U)
N#define GPIOB                      (GPIO_BASE + 0x00000400U)
N#define GPIOC                      (GPIO_BASE + 0x00000800U)
N#define GPIOD                      (GPIO_BASE + 0x00000C00U)
N#define GPIOE                      (GPIO_BASE + 0x00001000U)
N#define GPIOF                      (GPIO_BASE + 0x00001400U)
N#define GPIOG                      (GPIO_BASE + 0x00001800U)
N
N/* AFIO definitions */
N#define AFIO                       AFIO_BASE
N
N/* registers definitions */
N
N/* GPIO registers definitions */
N#define GPIO_CTL0(gpiox)           REG32((gpiox) + 0x00U)    /*!< GPIO port control register 0 */
N#define GPIO_CTL1(gpiox)           REG32((gpiox) + 0x04U)    /*!< GPIO port control register 1 */
N#define GPIO_ISTAT(gpiox)          REG32((gpiox) + 0x08U)    /*!< GPIO port input status register */
N#define GPIO_OCTL(gpiox)           REG32((gpiox) + 0x0CU)    /*!< GPIO port output control register */
N#define GPIO_BOP(gpiox)            REG32((gpiox) + 0x10U)    /*!< GPIO port bit operation register */
N#define GPIO_BC(gpiox)             REG32((gpiox) + 0x14U)    /*!< GPIO bit clear register */
N#define GPIO_LOCK(gpiox)           REG32((gpiox) + 0x18U)    /*!< GPIO port configuration lock register */
N
N/* AFIO registers definitions */
N#define AFIO_EC                    REG32(AFIO + 0x00U)       /*!< AFIO event control register */
N#define AFIO_PCF0                  REG32(AFIO + 0x04U)       /*!< AFIO port configuration register 0 */
N#define AFIO_EXTISS0               REG32(AFIO + 0x08U)       /*!< AFIO port EXTI sources selection register 0 */
N#define AFIO_EXTISS1               REG32(AFIO + 0x0CU)       /*!< AFIO port EXTI sources selection register 1 */
N#define AFIO_EXTISS2               REG32(AFIO + 0x10U)       /*!< AFIO port EXTI sources selection register 2 */
N#define AFIO_EXTISS3               REG32(AFIO + 0x14U)       /*!< AFIO port EXTI sources selection register 3 */
N#define AFIO_PCF1                  REG32(AFIO + 0x1CU)       /*!< AFIO port configuration register 1 */
N
N/* bits definitions */
N/* GPIO_CTL0 */
N#define GPIO_CTL0_MD0              BITS(0,1)                 /*!< port 0 mode bits */ 
N#define GPIO_CTL0_CTL0             BITS(2,3)                 /*!< pin 0 configuration bits */
N#define GPIO_CTL0_MD1              BITS(4,5)                 /*!< port 1 mode bits */
N#define GPIO_CTL0_CTL1             BITS(6,7)                 /*!< pin 1 configuration bits */
N#define GPIO_CTL0_MD2              BITS(8,9)                 /*!< port 2 mode bits */
N#define GPIO_CTL0_CTL2             BITS(10,11)               /*!< pin 2 configuration bits */
N#define GPIO_CTL0_MD3              BITS(12,13)               /*!< port 3 mode bits */
N#define GPIO_CTL0_CTL3             BITS(14,15)               /*!< pin 3 configuration bits */
N#define GPIO_CTL0_MD4              BITS(16,17)               /*!< port 4 mode bits */
N#define GPIO_CTL0_CTL4             BITS(18,19)               /*!< pin 4 configuration bits */
N#define GPIO_CTL0_MD5              BITS(20,21)               /*!< port 5 mode bits */
N#define GPIO_CTL0_CTL5             BITS(22,23)               /*!< pin 5 configuration bits */
N#define GPIO_CTL0_MD6              BITS(24,25)               /*!< port 6 mode bits */
N#define GPIO_CTL0_CTL6             BITS(26,27)               /*!< pin 6 configuration bits */
N#define GPIO_CTL0_MD7              BITS(28,29)               /*!< port 7 mode bits */
N#define GPIO_CTL0_CTL7             BITS(30,31)               /*!< pin 7 configuration bits */
N
N/* GPIO_CTL1 */
N#define GPIO_CTL1_MD8              BITS(0,1)                 /*!< port 8 mode bits */ 
N#define GPIO_CTL1_CTL8             BITS(2,3)                 /*!< pin 8 configuration bits */
N#define GPIO_CTL1_MD9              BITS(4,5)                 /*!< port 9 mode bits */
N#define GPIO_CTL1_CTL9             BITS(6,7)                 /*!< pin 9 configuration bits */
N#define GPIO_CTL1_MD10             BITS(8,9)                 /*!< port 10 mode bits */
N#define GPIO_CTL1_CTL10            BITS(10,11)               /*!< pin 10 configuration bits */
N#define GPIO_CTL1_MD11             BITS(12,13)               /*!< port 11 mode bits */
N#define GPIO_CTL1_CTL11            BITS(14,15)               /*!< pin 11 configuration bits */
N#define GPIO_CTL1_MD12             BITS(16,17)               /*!< port 12 mode bits */
N#define GPIO_CTL1_CTL12            BITS(18,19)               /*!< pin 12 configuration bits */
N#define GPIO_CTL1_MD13             BITS(20,21)               /*!< port 13 mode bits */
N#define GPIO_CTL1_CTL13            BITS(22,23)               /*!< pin 13 configuration bits */
N#define GPIO_CTL1_MD14             BITS(24,25)               /*!< port 14 mode bits */
N#define GPIO_CTL1_CTL14            BITS(26,27)               /*!< pin 14 configuration bits */
N#define GPIO_CTL1_MD15             BITS(28,29)               /*!< port 15 mode bits */
N#define GPIO_CTL1_CTL15            BITS(30,31)               /*!< pin 15 configuration bits */
N
N/* GPIO_ISTAT */
N#define GPIO_ISTAT_ISTAT0          BIT(0)                    /*!< pin 0 input status */
N#define GPIO_ISTAT_ISTAT1          BIT(1)                    /*!< pin 1 input status */
N#define GPIO_ISTAT_ISTAT2          BIT(2)                    /*!< pin 2 input status */
N#define GPIO_ISTAT_ISTAT3          BIT(3)                    /*!< pin 3 input status */
N#define GPIO_ISTAT_ISTAT4          BIT(4)                    /*!< pin 4 input status */
N#define GPIO_ISTAT_ISTAT5          BIT(5)                    /*!< pin 5 input status */
N#define GPIO_ISTAT_ISTAT6          BIT(6)                    /*!< pin 6 input status */
N#define GPIO_ISTAT_ISTAT7          BIT(7)                    /*!< pin 7 input status */
N#define GPIO_ISTAT_ISTAT8          BIT(8)                    /*!< pin 8 input status */
N#define GPIO_ISTAT_ISTAT9          BIT(9)                    /*!< pin 9 input status */
N#define GPIO_ISTAT_ISTAT10         BIT(10)                   /*!< pin 10 input status */
N#define GPIO_ISTAT_ISTAT11         BIT(11)                   /*!< pin 11 input status */
N#define GPIO_ISTAT_ISTAT12         BIT(12)                   /*!< pin 12 input status */
N#define GPIO_ISTAT_ISTAT13         BIT(13)                   /*!< pin 13 input status */
N#define GPIO_ISTAT_ISTAT14         BIT(14)                   /*!< pin 14 input status */
N#define GPIO_ISTAT_ISTAT15         BIT(15)                   /*!< pin 15 input status */
N
N/* GPIO_OCTL */
N#define GPIO_OCTL_OCTL0            BIT(0)                    /*!< pin 0 output bit */
N#define GPIO_OCTL_OCTL1            BIT(1)                    /*!< pin 1 output bit */
N#define GPIO_OCTL_OCTL2            BIT(2)                    /*!< pin 2 output bit */
N#define GPIO_OCTL_OCTL3            BIT(3)                    /*!< pin 3 output bit */
N#define GPIO_OCTL_OCTL4            BIT(4)                    /*!< pin 4 output bit */
N#define GPIO_OCTL_OCTL5            BIT(5)                    /*!< pin 5 output bit */
N#define GPIO_OCTL_OCTL6            BIT(6)                    /*!< pin 6 output bit */
N#define GPIO_OCTL_OCTL7            BIT(7)                    /*!< pin 7 output bit */
N#define GPIO_OCTL_OCTL8            BIT(8)                    /*!< pin 8 output bit */
N#define GPIO_OCTL_OCTL9            BIT(9)                    /*!< pin 9 output bit */
N#define GPIO_OCTL_OCTL10           BIT(10)                   /*!< pin 10 output bit */
N#define GPIO_OCTL_OCTL11           BIT(11)                   /*!< pin 11 output bit */
N#define GPIO_OCTL_OCTL12           BIT(12)                   /*!< pin 12 output bit */
N#define GPIO_OCTL_OCTL13           BIT(13)                   /*!< pin 13 output bit */
N#define GPIO_OCTL_OCTL14           BIT(14)                   /*!< pin 14 output bit */
N#define GPIO_OCTL_OCTL15           BIT(15)                   /*!< pin 15 output bit */
N
N/* GPIO_BOP */
N#define GPIO_BOP_BOP0              BIT(0)                    /*!< pin 0 set bit */
N#define GPIO_BOP_BOP1              BIT(1)                    /*!< pin 1 set bit */
N#define GPIO_BOP_BOP2              BIT(2)                    /*!< pin 2 set bit */
N#define GPIO_BOP_BOP3              BIT(3)                    /*!< pin 3 set bit */
N#define GPIO_BOP_BOP4              BIT(4)                    /*!< pin 4 set bit */
N#define GPIO_BOP_BOP5              BIT(5)                    /*!< pin 5 set bit */
N#define GPIO_BOP_BOP6              BIT(6)                    /*!< pin 6 set bit */
N#define GPIO_BOP_BOP7              BIT(7)                    /*!< pin 7 set bit */
N#define GPIO_BOP_BOP8              BIT(8)                    /*!< pin 8 set bit */
N#define GPIO_BOP_BOP9              BIT(9)                    /*!< pin 9 set bit */
N#define GPIO_BOP_BOP10             BIT(10)                   /*!< pin 10 set bit */
N#define GPIO_BOP_BOP11             BIT(11)                   /*!< pin 11 set bit */
N#define GPIO_BOP_BOP12             BIT(12)                   /*!< pin 12 set bit */
N#define GPIO_BOP_BOP13             BIT(13)                   /*!< pin 13 set bit */
N#define GPIO_BOP_BOP14             BIT(14)                   /*!< pin 14 set bit */
N#define GPIO_BOP_BOP15             BIT(15)                   /*!< pin 15 set bit */
N#define GPIO_BOP_CR0               BIT(16)                   /*!< pin 0 clear bit */
N#define GPIO_BOP_CR1               BIT(17)                   /*!< pin 1 clear bit */
N#define GPIO_BOP_CR2               BIT(18)                   /*!< pin 2 clear bit */
N#define GPIO_BOP_CR3               BIT(19)                   /*!< pin 3 clear bit */
N#define GPIO_BOP_CR4               BIT(20)                   /*!< pin 4 clear bit */
N#define GPIO_BOP_CR5               BIT(21)                   /*!< pin 5 clear bit */
N#define GPIO_BOP_CR6               BIT(22)                   /*!< pin 6 clear bit */
N#define GPIO_BOP_CR7               BIT(23)                   /*!< pin 7 clear bit */
N#define GPIO_BOP_CR8               BIT(24)                   /*!< pin 8 clear bit */
N#define GPIO_BOP_CR9               BIT(25)                   /*!< pin 9 clear bit */
N#define GPIO_BOP_CR10              BIT(26)                   /*!< pin 10 clear bit */
N#define GPIO_BOP_CR11              BIT(27)                   /*!< pin 11 clear bit */
N#define GPIO_BOP_CR12              BIT(28)                   /*!< pin 12 clear bit */
N#define GPIO_BOP_CR13              BIT(29)                   /*!< pin 13 clear bit */
N#define GPIO_BOP_CR14              BIT(30)                   /*!< pin 14 clear bit */
N#define GPIO_BOP_CR15              BIT(31)                   /*!< pin 15 clear bit */
N
N/* GPIO_BC */
N#define GPIO_BC_CR0                BIT(0)                    /*!< pin 0 clear bit */
N#define GPIO_BC_CR1                BIT(1)                    /*!< pin 1 clear bit */
N#define GPIO_BC_CR2                BIT(2)                    /*!< pin 2 clear bit */
N#define GPIO_BC_CR3                BIT(3)                    /*!< pin 3 clear bit */
N#define GPIO_BC_CR4                BIT(4)                    /*!< pin 4 clear bit */
N#define GPIO_BC_CR5                BIT(5)                    /*!< pin 5 clear bit */
N#define GPIO_BC_CR6                BIT(6)                    /*!< pin 6 clear bit */
N#define GPIO_BC_CR7                BIT(7)                    /*!< pin 7 clear bit */
N#define GPIO_BC_CR8                BIT(8)                    /*!< pin 8 clear bit */
N#define GPIO_BC_CR9                BIT(9)                    /*!< pin 9 clear bit */
N#define GPIO_BC_CR10               BIT(10)                   /*!< pin 10 clear bit */
N#define GPIO_BC_CR11               BIT(11)                   /*!< pin 11 clear bit */
N#define GPIO_BC_CR12               BIT(12)                   /*!< pin 12 clear bit */
N#define GPIO_BC_CR13               BIT(13)                   /*!< pin 13 clear bit */
N#define GPIO_BC_CR14               BIT(14)                   /*!< pin 14 clear bit */
N#define GPIO_BC_CR15               BIT(15)                   /*!< pin 15 clear bit */
N
N/* GPIO_LOCK */
N#define GPIO_LOCK_LK0              BIT(0)                    /*!< pin 0 lock bit */
N#define GPIO_LOCK_LK1              BIT(1)                    /*!< pin 1 lock bit */
N#define GPIO_LOCK_LK2              BIT(2)                    /*!< pin 2 lock bit */
N#define GPIO_LOCK_LK3              BIT(3)                    /*!< pin 3 lock bit */
N#define GPIO_LOCK_LK4              BIT(4)                    /*!< pin 4 lock bit */
N#define GPIO_LOCK_LK5              BIT(5)                    /*!< pin 5 lock bit */
N#define GPIO_LOCK_LK6              BIT(6)                    /*!< pin 6 lock bit */
N#define GPIO_LOCK_LK7              BIT(7)                    /*!< pin 7 lock bit */
N#define GPIO_LOCK_LK8              BIT(8)                    /*!< pin 8 lock bit */
N#define GPIO_LOCK_LK9              BIT(9)                    /*!< pin 9 lock bit */
N#define GPIO_LOCK_LK10             BIT(10)                   /*!< pin 10 lock bit */
N#define GPIO_LOCK_LK11             BIT(11)                   /*!< pin 11 lock bit */
N#define GPIO_LOCK_LK12             BIT(12)                   /*!< pin 12 lock bit */
N#define GPIO_LOCK_LK13             BIT(13)                   /*!< pin 13 lock bit */
N#define GPIO_LOCK_LK14             BIT(14)                   /*!< pin 14 lock bit */
N#define GPIO_LOCK_LK15             BIT(15)                   /*!< pin 15 lock bit */
N#define GPIO_LOCK_LKK              BIT(16)                   /*!< pin sequence lock key */
N
N/* AFIO_EC */
N#define AFIO_EC_PIN                BITS(0,3)                 /*!< event output pin selection */
N#define AFIO_EC_PORT               BITS(4,6)                 /*!< event output port selection */
N#define AFIO_EC_EOE                BIT(7)                    /*!< event output enable */
N
N/* AFIO_PCF0 */
N#ifdef GD32F10X_CL
S/* memory map and bit definitions for GD32F10X_CL devices */
S#define AFIO_PCF0_SPI0_REMAP             BIT(0)              /*!< SPI0 remapping */
S#define AFIO_PCF0_I2C0_REMAP             BIT(1)              /*!< I2C0 remapping */
S#define AFIO_PCF0_USART0_REMAP           BIT(2)              /*!< USART0 remapping */
S#define AFIO_PCF0_USART1_REMAP           BIT(3)              /*!< USART1 remapping */
S#define AFIO_PCF0_USART2_REMAP           BITS(4,5)           /*!< USART2 remapping */
S#define AFIO_PCF0_TIMER0_REMAP           BITS(6,7)           /*!< TIMER0 remapping */
S#define AFIO_PCF0_TIMER1_REMAP           BITS(8,9)           /*!< TIMER1 remapping */
S#define AFIO_PCF0_TIMER2_REMAP           BITS(10,11)         /*!< TIMER2 remapping */
S#define AFIO_PCF0_TIMER3_REMAP           BIT(12)             /*!< TIMER3 remapping */
S#define AFIO_PCF0_CAN0_REMAP             BITS(13,14)         /*!< CAN0 remapping */
S#define AFIO_PCF0_PD01_REMAP             BIT(15)             /*!< port D0/port D1 mapping on OSC_IN/OSC_OUT */
S#define AFIO_PCF0_TIMER4CH3_IREMAP       BIT(16)             /*!< TIMER3 channel3 internal remapping */
S#define AFIO_PCF0_ENET_REMAP             BIT(21)             /*!< ethernet MAC I/O remapping */
S#define AFIO_PCF0_CAN1_REMAP             BIT(22)             /*!< CAN1 remapping */
S#define AFIO_PCF0_ENET_PHY_SEL           BIT(23)             /*!< ethernet MII or RMII PHY selection */
S#define AFIO_PCF0_SWJ_CFG                BITS(24,26)         /*!< serial wire JTAG configuration */
S#define AFIO_PCF0_SPI2_REMAP             BIT(28)             /*!< SPI2/I2S2 remapping */
S#define AFIO_PCF0_TIMER1ITI1_REMAP       BIT(29)             /*!< TIMER1 internal trigger 1 remapping */
S#define AFIO_PCF0_PTP_PPS_REMAP          BIT(30)             /*!< ethernet PTP PPS remapping */
S
N#else 
N/* memory map and bit definitions for GD32F10X_MD, GD32F10X_HD devices and GD32F10X_XD devices */
N#define AFIO_PCF0_SPI0_REMAP             BIT(0)              /*!< SPI0 remapping */
N#define AFIO_PCF0_I2C0_REMAP             BIT(1)              /*!< I2C0 remapping */
N#define AFIO_PCF0_USART0_REMAP           BIT(2)              /*!< USART0 remapping */
N#define AFIO_PCF0_USART1_REMAP           BIT(3)              /*!< USART1 remapping */
N#define AFIO_PCF0_USART2_REMAP           BITS(4,5)           /*!< USART2 remapping */
N#define AFIO_PCF0_TIMER0_REMAP           BITS(6,7)           /*!< TIMER0 remapping */
N#define AFIO_PCF0_TIMER1_REMAP           BITS(8,9)           /*!< TIMER1 remapping */
N#define AFIO_PCF0_TIMER2_REMAP           BITS(10,11)         /*!< TIMER2 remapping */
N#define AFIO_PCF0_TIMER3_REMAP           BIT(12)             /*!< TIMER3 remapping */
N#define AFIO_PCF0_CAN_REMAP              BITS(13,14)         /*!< CAN remapping */
N#define AFIO_PCF0_PD01_REMAP             BIT(15)             /*!< port D0/port D1 mapping on OSC_IN/OSC_OUT */
N#define AFIO_PCF0_TIMER4CH3_REMAP        BIT(16)             /*!< TIMER4 channel3 internal remapping */
N#define AFIO_PCF0_ADC0_ETRGINS_REMAP     BIT(17)             /*!< ADC 0 external trigger inserted conversion remapping */
N#define AFIO_PCF0_ADC0_ETRGREG_REMAP     BIT(18)             /*!< ADC 0 external trigger regular conversion remapping */
N#define AFIO_PCF0_ADC1_ETRGINS_REMAP     BIT(19)             /*!< ADC 1 external trigger inserted conversion remapping */
N#define AFIO_PCF0_ADC1_ETRGREG_REMAP     BIT(20)             /*!< ADC 1 external trigger regular conversion remapping */
N#define AFIO_PCF0_SWJ_CFG                BITS(24,26)         /*!< serial wire JTAG configuration */
N#endif /* GD32F10X_CL */
N
N/* AFIO_EXTISS0 */
N#define AFIO_EXTI0_SS                    BITS(0,3)           /*!< EXTI 0 sources selection */
N#define AFIO_EXTI1_SS                    BITS(4,7)           /*!< EXTI 1 sources selection */
N#define AFIO_EXTI2_SS                    BITS(8,11)          /*!< EXTI 2 sources selection */
N#define AFIO_EXTI3_SS                    BITS(12,15)         /*!< EXTI 3 sources selection */
N
N/* AFIO_EXTISS1 */
N#define AFIO_EXTI4_SS                    BITS(0,3)           /*!< EXTI 4 sources selection */
N#define AFIO_EXTI5_SS                    BITS(4,7)           /*!< EXTI 5 sources selection */
N#define AFIO_EXTI6_SS                    BITS(8,11)          /*!< EXTI 6 sources selection */
N#define AFIO_EXTI7_SS                    BITS(12,15)         /*!< EXTI 7 sources selection */
N
N/* AFIO_EXTISS2 */
N#define AFIO_EXTI8_SS                    BITS(0,3)           /*!< EXTI 8 sources selection */
N#define AFIO_EXTI9_SS                    BITS(4,7)           /*!< EXTI 9 sources selection */
N#define AFIO_EXTI10_SS                   BITS(8,11)          /*!< EXTI 10 sources selection */
N#define AFIO_EXTI11_SS                   BITS(12,15)         /*!< EXTI 11 sources selection */
N
N/* AFIO_EXTISS3 */
N#define AFIO_EXTI12_SS                   BITS(0,3)           /*!< EXTI 12 sources selection */
N#define AFIO_EXTI13_SS                   BITS(4,7)           /*!< EXTI 13 sources selection */
N#define AFIO_EXTI14_SS                   BITS(8,11)          /*!< EXTI 14 sources selection */
N#define AFIO_EXTI15_SS                   BITS(12,15)         /*!< EXTI 15 sources selection */
N
N/* AFIO_PCF1 */
N#define AFIO_PCF1_TIMER8_REMAP           BIT(5)             /*!< TIMER8 remapping */
N#define AFIO_PCF1_TIMER9_REMAP           BIT(6)             /*!< TIMER9 remapping */
N#define AFIO_PCF1_TIMER10_REMAP          BIT(7)             /*!< TIMER10 remapping */
N#define AFIO_PCF1_TIMER12_REMAP          BIT(8)             /*!< TIMER12 remapping */
N#define AFIO_PCF1_TIMER13_REMAP          BIT(9)             /*!< TIMER13 remapping */
N#define AFIO_PCF1_EXMC_NADV              BIT(10)            /*!< EXMC_NADV connect/disconnect */
N
N/* constants definitions */
Ntypedef FlagStatus bit_status;
N
N/* GPIO mode values set */
N#define GPIO_MODE_SET(n, mode)           ((uint32_t)((uint32_t)(mode) << (4U * (n))))
N#define GPIO_MODE_MASK(n)                (0xFU << (4U * (n)))
N
N/* GPIO mode definitions */
N#define GPIO_MODE_AIN                    ((uint8_t)0x00U)          /*!< analog input mode */
N#define GPIO_MODE_IN_FLOATING            ((uint8_t)0x04U)          /*!< floating input mode */
N#define GPIO_MODE_IPD                    ((uint8_t)0x28U)          /*!< pull-down input mode */
N#define GPIO_MODE_IPU                    ((uint8_t)0x48U)          /*!< pull-up input mode */
N#define GPIO_MODE_OUT_OD                 ((uint8_t)0x14U)          /*!< GPIO output with open-drain */
N#define GPIO_MODE_OUT_PP                 ((uint8_t)0x10U)          /*!< GPIO output with push-pull */
N#define GPIO_MODE_AF_OD                  ((uint8_t)0x1CU)          /*!< AFIO output with open-drain */
N#define GPIO_MODE_AF_PP                  ((uint8_t)0x18U)          /*!< AFIO output with push-pull */
N
N/* GPIO output max speed value */
N#define GPIO_OSPEED_10MHZ                ((uint8_t)0x01U)          /*!< output max speed 10MHz */
N#define GPIO_OSPEED_2MHZ                 ((uint8_t)0x02U)          /*!< output max speed 2MHz */
N#define GPIO_OSPEED_50MHZ                ((uint8_t)0x03U)          /*!< output max speed 50MHz */
N
N/* GPIO event output port definitions */
N#define GPIO_EVENT_PORT_GPIOA            ((uint8_t)0x00U)          /*!< event output port A */
N#define GPIO_EVENT_PORT_GPIOB            ((uint8_t)0x01U)          /*!< event output port B */
N#define GPIO_EVENT_PORT_GPIOC            ((uint8_t)0x02U)          /*!< event output port C */
N#define GPIO_EVENT_PORT_GPIOD            ((uint8_t)0x03U)          /*!< event output port D */
N#define GPIO_EVENT_PORT_GPIOE            ((uint8_t)0x04U)          /*!< event output port E */
N
N/* GPIO output port source definitions */
N#define GPIO_PORT_SOURCE_GPIOA           ((uint8_t)0x00U)          /*!< output port source A */
N#define GPIO_PORT_SOURCE_GPIOB           ((uint8_t)0x01U)          /*!< output port source B */
N#define GPIO_PORT_SOURCE_GPIOC           ((uint8_t)0x02U)          /*!< output port source C */
N#define GPIO_PORT_SOURCE_GPIOD           ((uint8_t)0x03U)          /*!< output port source D */
N#define GPIO_PORT_SOURCE_GPIOE           ((uint8_t)0x04U)          /*!< output port source E */
N#define GPIO_PORT_SOURCE_GPIOF           ((uint8_t)0x05U)          /*!< output port source F */
N#define GPIO_PORT_SOURCE_GPIOG           ((uint8_t)0x06U)          /*!< output port source G */
N
N/* GPIO event output pin definitions */
N#define GPIO_EVENT_PIN_0                 ((uint8_t)0x00U)          /*!< GPIO event pin 0 */
N#define GPIO_EVENT_PIN_1                 ((uint8_t)0x01U)          /*!< GPIO event pin 1 */
N#define GPIO_EVENT_PIN_2                 ((uint8_t)0x02U)          /*!< GPIO event pin 2 */
N#define GPIO_EVENT_PIN_3                 ((uint8_t)0x03U)          /*!< GPIO event pin 3 */
N#define GPIO_EVENT_PIN_4                 ((uint8_t)0x04U)          /*!< GPIO event pin 4 */
N#define GPIO_EVENT_PIN_5                 ((uint8_t)0x05U)          /*!< GPIO event pin 5 */
N#define GPIO_EVENT_PIN_6                 ((uint8_t)0x06U)          /*!< GPIO event pin 6 */
N#define GPIO_EVENT_PIN_7                 ((uint8_t)0x07U)          /*!< GPIO event pin 7 */
N#define GPIO_EVENT_PIN_8                 ((uint8_t)0x08U)          /*!< GPIO event pin 8 */
N#define GPIO_EVENT_PIN_9                 ((uint8_t)0x09U)          /*!< GPIO event pin 9 */
N#define GPIO_EVENT_PIN_10                ((uint8_t)0x0AU)          /*!< GPIO event pin 10 */
N#define GPIO_EVENT_PIN_11                ((uint8_t)0x0BU)          /*!< GPIO event pin 11 */
N#define GPIO_EVENT_PIN_12                ((uint8_t)0x0CU)          /*!< GPIO event pin 12 */
N#define GPIO_EVENT_PIN_13                ((uint8_t)0x0DU)          /*!< GPIO event pin 13 */
N#define GPIO_EVENT_PIN_14                ((uint8_t)0x0EU)          /*!< GPIO event pin 14 */
N#define GPIO_EVENT_PIN_15                ((uint8_t)0x0FU)          /*!< GPIO event pin 15 */
N
N/* GPIO output pin source definitions */
N#define GPIO_PIN_SOURCE_0                ((uint8_t)0x00U)          /*!< GPIO pin source 0 */
N#define GPIO_PIN_SOURCE_1                ((uint8_t)0x01U)          /*!< GPIO pin source 1 */
N#define GPIO_PIN_SOURCE_2                ((uint8_t)0x02U)          /*!< GPIO pin source 2 */
N#define GPIO_PIN_SOURCE_3                ((uint8_t)0x03U)          /*!< GPIO pin source 3 */
N#define GPIO_PIN_SOURCE_4                ((uint8_t)0x04U)          /*!< GPIO pin source 4 */
N#define GPIO_PIN_SOURCE_5                ((uint8_t)0x05U)          /*!< GPIO pin source 5 */
N#define GPIO_PIN_SOURCE_6                ((uint8_t)0x06U)          /*!< GPIO pin source 6 */
N#define GPIO_PIN_SOURCE_7                ((uint8_t)0x07U)          /*!< GPIO pin source 7 */
N#define GPIO_PIN_SOURCE_8                ((uint8_t)0x08U)          /*!< GPIO pin source 8 */
N#define GPIO_PIN_SOURCE_9                ((uint8_t)0x09U)          /*!< GPIO pin source 9 */
N#define GPIO_PIN_SOURCE_10               ((uint8_t)0x0AU)          /*!< GPIO pin source 10 */
N#define GPIO_PIN_SOURCE_11               ((uint8_t)0x0BU)          /*!< GPIO pin source 11 */
N#define GPIO_PIN_SOURCE_12               ((uint8_t)0x0CU)          /*!< GPIO pin source 12 */
N#define GPIO_PIN_SOURCE_13               ((uint8_t)0x0DU)          /*!< GPIO pin source 13 */
N#define GPIO_PIN_SOURCE_14               ((uint8_t)0x0EU)          /*!< GPIO pin source 14 */
N#define GPIO_PIN_SOURCE_15               ((uint8_t)0x0FU)          /*!< GPIO pin source 15 */
N
N/* GPIO pin definitions */
N#define GPIO_PIN_0                       BIT(0)                    /*!< GPIO pin 0 */
N#define GPIO_PIN_1                       BIT(1)                    /*!< GPIO pin 1 */
N#define GPIO_PIN_2                       BIT(2)                    /*!< GPIO pin 2 */
N#define GPIO_PIN_3                       BIT(3)                    /*!< GPIO pin 3 */
N#define GPIO_PIN_4                       BIT(4)                    /*!< GPIO pin 4 */
N#define GPIO_PIN_5                       BIT(5)                    /*!< GPIO pin 5 */
N#define GPIO_PIN_6                       BIT(6)                    /*!< GPIO pin 6 */
N#define GPIO_PIN_7                       BIT(7)                    /*!< GPIO pin 7 */
N#define GPIO_PIN_8                       BIT(8)                    /*!< GPIO pin 8 */
N#define GPIO_PIN_9                       BIT(9)                    /*!< GPIO pin 9 */
N#define GPIO_PIN_10                      BIT(10)                   /*!< GPIO pin 10 */
N#define GPIO_PIN_11                      BIT(11)                   /*!< GPIO pin 11 */
N#define GPIO_PIN_12                      BIT(12)                   /*!< GPIO pin 12 */
N#define GPIO_PIN_13                      BIT(13)                   /*!< GPIO pin 13 */
N#define GPIO_PIN_14                      BIT(14)                   /*!< GPIO pin 14 */
N#define GPIO_PIN_15                      BIT(15)                   /*!< GPIO pin 15 */
N#define GPIO_PIN_ALL                     BITS(0,15)                /*!< GPIO pin all */
N
N/* GPIO remap definitions */
N#define GPIO_SPI0_REMAP                  ((uint32_t)0x00000001U)   /*!< SPI0 remapping */
N#define GPIO_I2C0_REMAP                  ((uint32_t)0x00000002U)   /*!< I2C0 remapping */
N#define GPIO_USART0_REMAP                ((uint32_t)0x00000004U)   /*!< USART0 remapping */
N#define GPIO_USART1_REMAP                ((uint32_t)0x00000008U)   /*!< USART1 remapping */
N#define GPIO_USART2_PARTIAL_REMAP        ((uint32_t)0x00140010U)   /*!< USART2 partial remapping */
N#define GPIO_USART2_FULL_REMAP           ((uint32_t)0x00140030U)   /*!< USART2 full remapping */
N#define GPIO_TIMER0_PARTIAL_REMAP        ((uint32_t)0x00160040U)   /*!< TIMER0 partial remapping */
N#define GPIO_TIMER0_FULL_REMAP           ((uint32_t)0x001600C0U)   /*!< TIMER0 full remapping */
N#define GPIO_TIMER1_PARTIAL_REMAP0       ((uint32_t)0x00180100U)   /*!< TIMER1 partial remapping */
N#define GPIO_TIMER1_PARTIAL_REMAP1       ((uint32_t)0x00180200U)   /*!< TIMER1 partial remapping */
N#define GPIO_TIMER1_FULL_REMAP           ((uint32_t)0x00180300U)   /*!< TIMER1 full remapping */
N#define GPIO_TIMER2_PARTIAL_REMAP        ((uint32_t)0x001A0800U)   /*!< TIMER2 partial remapping */
N#define GPIO_TIMER2_FULL_REMAP           ((uint32_t)0x001A0C00U)   /*!< TIMER2 full remapping */
N#define GPIO_TIMER3_REMAP                ((uint32_t)0x00001000U)   /*!< TIMER3 remapping */
N#define GPIO_PD01_REMAP                  ((uint32_t)0x00008000U)   /*!< PD01 remapping */
N#if (defined(GD32F10X_MD) || defined(GD32F10X_HD) || defined(GD32F10X_XD))
X#if (0L || 0L || 1L)
N#define GPIO_CAN_PARTIAL_REMAP           ((uint32_t)0x001D4000U)   /*!< CAN partial remapping(only for GD32F10X_MD devices, GD32F10X_HD devices and GD32F10X_XD devices) */
N#define GPIO_CAN_FULL_REMAP              ((uint32_t)0x001D6000U)   /*!< CAN full remapping(only for GD32F10X_MD devices, GD32F10X_HD devices and GD32F10X_XD devices) */
N#endif /* GD32F10X_MD||GD32F10X_HD||GD32F10X_XD */
N#if (defined(GD32F10X_CL) || defined(GD32F10X_HD) || defined(GD32F10X_XD))
X#if (0L || 0L || 1L)
N#define GPIO_SPI2_REMAP                  ((uint32_t)0x00201100U)   /*!< SPI2 remapping(only for GD32F10X_CL devices) */
N#endif /* GD32F10X_CL||GD32F10X_HD */
N#if (defined(GD32F10X_CL) || defined(GD32F10X_HD))
X#if (0L || 0L)
S#define GPIO_TIMER4CH3_IREMAP            ((uint32_t)0x00200001U)   /*!< TIMER4 channel3 internal remapping(only for GD32F10X_CL devices and GD32F10X_HD devices) */
N#endif /* GD32F10X_CL||GD32F10X_HD */
N#if (defined(GD32F10X_MD) || defined(GD32F10X_HD) || defined(GD32F10X_XD))
X#if (0L || 0L || 1L)
N#define GPIO_ADC0_ETRGINS_REMAP          ((uint32_t)0x00200002U)   /*!< ADC0 external trigger inserted conversion remapping(only for GD32F10X_MD devices, GD32F10X_HD devices and GD32F10X_XD devices) */
N#define GPIO_ADC0_ETRGREG_REMAP          ((uint32_t)0x00200004U)   /*!< ADC0 external trigger regular conversion remapping(only for GD32F10X_MD devices, GD32F10X_HD devices and GD32F10X_XD devices) */
N#define GPIO_ADC1_ETRGINS_REMAP          ((uint32_t)0x00200008U)   /*!< ADC1 external trigger inserted conversion remapping(only for GD32F10X_MD devices, GD32F10X_HD devices and GD32F10X_XD devices) */
N#define GPIO_ADC1_ETRGREG_REMAP          ((uint32_t)0x00200010U)   /*!< ADC1 external trigger regular conversion remapping(only for GD32F10X_MD devices, GD32F10X_HD devices and GD32F10X_XD devices) */
N#endif /* GD32F10X_MD||GD32F10X_HD||GD32F10X_XD */
N#define GPIO_SWJ_NONJTRST_REMAP          ((uint32_t)0x00300100U)   /*!< full SWJ(JTAG-DP + SW-DP),but without NJTRST */
N#define GPIO_SWJ_SWDPENABLE_REMAP        ((uint32_t)0x00300200U)   /*!< JTAG-DP disabled and SW-DP enabled */
N#define GPIO_SWJ_DISABLE_REMAP           ((uint32_t)0x00300400U)   /*!< JTAG-DP disabled and SW-DP disabled */
N#ifdef GD32F10X_CL
S#define GPIO_CAN0_PARTIAL_REMAP          ((uint32_t)0x001D4000U)   /*!< CAN0 partial remapping(only for GD32F10X_CL devices) */
S#define GPIO_CAN0_FULL_REMAP             ((uint32_t)0x001D6000U)   /*!< CAN0 full remapping(only for GD32F10X_CL devices) */
S#define GPIO_ENET_REMAP                  ((uint32_t)0x00200020U)   /*!< ENET remapping(only for GD32F10X_CL devices) */
S#define GPIO_CAN1_REMAP                  ((uint32_t)0x00200040U)   /*!< CAN1 remapping(only for GD32F10X_CL devices) */
S#define GPIO_TIMER1ITI1_REMAP            ((uint32_t)0x00202000U)   /*!< TIMER1 internal trigger 1 remapping(only for GD32F10X_CL devices) */
S#define GPIO_PTP_PPS_REMAP               ((uint32_t)0x00204000U)   /*!< ethernet PTP PPS remapping(only for GD32F10X_CL devices) */
N#endif /* GD32F10X_CL */
N#ifdef GD32F10X_XD
N#define GPIO_TIMER8_REMAP                ((uint32_t)0x80000020U)   /*!< TIMER8 remapping */
N#define GPIO_TIMER9_REMAP                ((uint32_t)0x80000040U)   /*!< TIMER9 remapping */
N#define GPIO_TIMER10_REMAP               ((uint32_t)0x80000080U)   /*!< TIMER10 remapping */
N#define GPIO_TIMER12_REMAP               ((uint32_t)0x80000100U)   /*!< TIMER12 remapping */
N#define GPIO_TIMER13_REMAP               ((uint32_t)0x80000200U)   /*!< TIMER13 remapping */
N#define GPIO_EXMC_NADV_REMAP             ((uint32_t)0x80000400U)   /*!< EXMC_NADV connect/disconnect */
N#endif /* GD32F10X_XD */
N
N#ifdef GD32F10X_CL
S/* ethernet MII or RMII PHY selection */
S#define GPIO_ENET_PHY_MII                ((uint32_t)0x00000000U)   /*!< configure ethernet MAC for connection with an MII PHY */
S#define GPIO_ENET_PHY_RMII               AFIO_PCF0_ENET_PHY_SEL    /*!< configure ethernet MAC for connection with an RMII PHY */
N#endif /* GD32F10X_CL */
N
N/* function declarations */
N/* reset GPIO port */
Nvoid gpio_deinit(uint32_t gpio_periph);
N/* reset alternate function I/O(AFIO) */
Nvoid gpio_afio_deinit(void);
N/* GPIO parameter initialization */
Nvoid gpio_init(uint32_t gpio_periph,uint32_t mode,uint32_t speed,uint32_t pin);
N
N/* set GPIO pin bit */
Nvoid gpio_bit_set(uint32_t gpio_periph, uint32_t pin);
N/* reset GPIO pin bit */
Nvoid gpio_bit_reset(uint32_t gpio_periph, uint32_t pin);
N/* write data to the specified GPIO pin */
Nvoid gpio_bit_write(uint32_t gpio_periph, uint32_t pin, bit_status bit_value);
N/* write data to the specified GPIO port */
Nvoid gpio_port_write(uint32_t gpio_periph, uint16_t data);
N
N/* get GPIO pin input status */
NFlagStatus gpio_input_bit_get(uint32_t gpio_periph, uint32_t pin);
N/* get GPIO port input status */
Nuint16_t gpio_input_port_get(uint32_t gpio_periph);
N/* get GPIO pin output status */
NFlagStatus gpio_output_bit_get(uint32_t gpio_periph, uint32_t pin);
N/* get GPIO port output status */
Nuint16_t gpio_output_port_get(uint32_t gpio_periph);
N
N/* configure GPIO pin remap */
Nvoid gpio_pin_remap_config(uint32_t remap, ControlStatus newvalue);
N
N/* select GPIO pin exti sources */
Nvoid gpio_exti_source_select(uint8_t output_port, uint8_t output_pin);
N/* configure GPIO pin event output */
Nvoid gpio_event_output_config(uint8_t output_port, uint8_t output_pin);
N/* enable GPIO pin event output */
Nvoid gpio_event_output_enable(void);
N/* disable GPIO pin event output */
Nvoid gpio_event_output_disable(void);
N
N/* lock GPIO pin bit */
Nvoid gpio_pin_lock(uint32_t gpio_periph, uint32_t pin);
N
N#ifdef GD32F10X_CL
S/* select ethernet MII or RMII PHY */
Svoid gpio_ethernet_phy_select(uint32_t gpio_enetsel);
N#endif /* GD32F10X_CL */
N
N
N#endif /* GD32F10x_GPIO_H */
L 48 ".\User\gd32f10x_libopt.h" 2
N#include "gd32f10x_crc.h"
L 1 ".\Libraries\inc\gd32f10x_crc.h" 1
N/*!
N    \file  gd32f10x_crc.h
N    \brief definitions for the CRC
N
N    \version 2014-12-26, V1.0.0, firmware for GD32F10x
N    \version 2017-06-20, V2.0.0, firmware for GD32F10x
N    \version 2018-07-31, V2.1.0, firmware for GD32F10x
N*/
N
N/*
N    Copyright (c) 2018, GigaDevice Semiconductor Inc.
N
N    All rights reserved.
N
N    Redistribution and use in source and binary forms, with or without modification, 
Nare permitted provided that the following conditions are met:
N
N    1. Redistributions of source code must retain the above copyright notice, this 
N       list of conditions and the following disclaimer.
N    2. Redistributions in binary form must reproduce the above copyright notice, 
N       this list of conditions and the following disclaimer in the documentation 
N       and/or other materials provided with the distribution.
N    3. Neither the name of the copyright holder nor the names of its contributors 
N       may be used to endorse or promote products derived from this software without 
N       specific prior written permission.
N
N    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
NAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
NWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
NIN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
NINDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
NNOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
NPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
NWHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
NARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
NOF SUCH DAMAGE.
N*/
N
N#ifndef GD32F10X_CRC_H
N#define GD32F10X_CRC_H
N
N#include "gd32f10x.h"
N
N/* CRC definitions */
N#define CRC                            CRC_BASE
N
N/* registers definitions */
N#define CRC_DATA                       REG32(CRC + 0x00U)              /*!< CRC data register */
N#define CRC_FDATA                      REG32(CRC + 0x04U)              /*!< CRC free data register */
N#define CRC_CTL                        REG32(CRC + 0x08U)              /*!< CRC control register */
N
N/* bits definitions */
N/* CRC_DATA */
N#define CRC_DATA_DATA                  BITS(0,31)                      /*!< CRC calculation result bits */
N
N/* CRC_FDATA */
N#define CRC_FDATA_FDATA                BITS(0,7)                       /*!< CRC free data bits */
N
N/* CRC_CTL */
N#define CRC_CTL_RST                    BIT(0)                          /*!< CRC reset CRC_DATA register bit */
N
N/* function declarations */
N/* deinit CRC calculation unit */
Nvoid crc_deinit(void);
N
N/* reset data register to the value of initializaiton data register */
Nvoid crc_data_register_reset(void);
N/* read the value of the data register */
Nuint32_t crc_data_register_read(void);
N
N/* read the value of the free data register */
Nuint8_t crc_free_data_register_read(void);
N/* write data to the free data register */
Nvoid crc_free_data_register_write(uint8_t free_data);
N
N/* calculate the CRC value of a 32-bit data */
Nuint32_t crc_single_data_calculate(uint32_t sdata);
N/* calculate the CRC value of an array of 32-bit values */
Nuint32_t crc_block_data_calculate(uint32_t array[], uint32_t size);
N
N#endif /* GD32F10X_CRC_H */
L 49 ".\User\gd32f10x_libopt.h" 2
N#include "gd32f10x_dma.h"
L 1 ".\Libraries\inc\gd32f10x_dma.h" 1
N/*!
N    \file  gd32f10x_dma.h
N    \brief definitions for the DMA
N
N    \version 2014-12-26, V1.0.0, firmware for GD32F10x
N    \version 2017-06-20, V2.0.0, firmware for GD32F10x
N    \version 2018-07-31, V2.1.0, firmware for GD32F10x
N    \version 2019-10-30, V2.1.1, firmware for GD32F10x
N*/
N
N/*
N    Copyright (c) 2018, GigaDevice Semiconductor Inc.
N
N    All rights reserved.
N
N    Redistribution and use in source and binary forms, with or without modification, 
Nare permitted provided that the following conditions are met:
N
N    1. Redistributions of source code must retain the above copyright notice, this 
N       list of conditions and the following disclaimer.
N    2. Redistributions in binary form must reproduce the above copyright notice, 
N       this list of conditions and the following disclaimer in the documentation 
N       and/or other materials provided with the distribution.
N    3. Neither the name of the copyright holder nor the names of its contributors 
N       may be used to endorse or promote products derived from this software without 
N       specific prior written permission.
N
N    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
NAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
NWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
NIN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
NINDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
NNOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
NPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
NWHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
NARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
NOF SUCH DAMAGE.
N*/
N
N#ifndef GD32F10X_DMA_H
N#define GD32F10X_DMA_H
N
N#include "gd32f10x.h"
N
N/* DMA definitions */
N#define DMA0                            (DMA_BASE)               /*!< DMA0 base address */
N#define DMA1                            (DMA_BASE + 0x0400U)     /*!< DMA1 base address */
N
N/* registers definitions */
N#define DMA_INTF(dmax)                  REG32((dmax) + 0x00U)    /*!< DMA interrupt flag register */
N#define DMA_INTC(dmax)                  REG32((dmax) + 0x04U)    /*!< DMA interrupt flag clear register */
N
N#define DMA_CH0CTL(dmax)                REG32((dmax) + 0x08U)    /*!< DMA channel 0 control register */
N#define DMA_CH0CNT(dmax)                REG32((dmax) + 0x0CU)    /*!< DMA channel 0 counter register */
N#define DMA_CH0PADDR(dmax)              REG32((dmax) + 0x10U)    /*!< DMA channel 0 peripheral base address register */
N#define DMA_CH0MADDR(dmax)              REG32((dmax) + 0x14U)    /*!< DMA channel 0 memory base address register */
N
N#define DMA_CH1CTL(dmax)                REG32((dmax) + 0x1CU)    /*!< DMA channel 1 control register */
N#define DMA_CH1CNT(dmax)                REG32((dmax) + 0x20U)    /*!< DMA channel 1 counter register */
N#define DMA_CH1PADDR(dmax)              REG32((dmax) + 0x24U)    /*!< DMA channel 1 peripheral base address register */
N#define DMA_CH1MADDR(dmax)              REG32((dmax) + 0x28U)    /*!< DMA channel 1 memory base address register */
N
N#define DMA_CH2CTL(dmax)                REG32((dmax) + 0x30U)    /*!< DMA channel 2 control register */
N#define DMA_CH2CNT(dmax)                REG32((dmax) + 0x34U)    /*!< DMA channel 2 counter register */
N#define DMA_CH2PADDR(dmax)              REG32((dmax) + 0x38U)    /*!< DMA channel 2 peripheral base address register */
N#define DMA_CH2MADDR(dmax)              REG32((dmax) + 0x3CU)    /*!< DMA channel 2 memory base address register */
N
N#define DMA_CH3CTL(dmax)                REG32((dmax) + 0x44U)    /*!< DMA channel 3 control register */
N#define DMA_CH3CNT(dmax)                REG32((dmax) + 0x48U)    /*!< DMA channel 3 counter register */
N#define DMA_CH3PADDR(dmax)              REG32((dmax) + 0x4CU)    /*!< DMA channel 3 peripheral base address register */
N#define DMA_CH3MADDR(dmax)              REG32((dmax) + 0x50U)    /*!< DMA channel 3 memory base address register */
N
N#define DMA_CH4CTL(dmax)                REG32((dmax) + 0x58U)    /*!< DMA channel 4 control register */
N#define DMA_CH4CNT(dmax)                REG32((dmax) + 0x5CU)    /*!< DMA channel 4 counter register */
N#define DMA_CH4PADDR(dmax)              REG32((dmax) + 0x60U)    /*!< DMA channel 4 peripheral base address register */
N#define DMA_CH4MADDR(dmax)              REG32((dmax) + 0x64U)    /*!< DMA channel 4 memory base address register */
N
N#define DMA_CH5CTL(dmax)                REG32((dmax) + 0x6CU)    /*!< DMA channel 5 control register */
N#define DMA_CH5CNT(dmax)                REG32((dmax) + 0x70U)    /*!< DMA channel 5 counter register */
N#define DMA_CH5PADDR(dmax)              REG32((dmax) + 0x74U)    /*!< DMA channel 5 peripheral base address register */
N#define DMA_CH5MADDR(dmax)              REG32((dmax) + 0x78U)    /*!< DMA channel 5 memory base address register */
N
N#define DMA_CH6CTL(dmax)                REG32((dmax) + 0x80U)    /*!< DMA channel 6 control register */
N#define DMA_CH6CNT(dmax)                REG32((dmax) + 0x84U)    /*!< DMA channel 6 counter register */
N#define DMA_CH6PADDR(dmax)              REG32((dmax) + 0x88U)    /*!< DMA channel 6 peripheral base address register */
N#define DMA_CH6MADDR(dmax)              REG32((dmax) + 0x8CU)    /*!< DMA channel 6 memory base address register */
N
N/* bits definitions */
N/* DMA_INTF */
N#define DMA_INTF_GIF                    BIT(0)                  /*!< global interrupt flag of channel */
N#define DMA_INTF_FTFIF                  BIT(1)                  /*!< full transfer finish flag of channel */
N#define DMA_INTF_HTFIF                  BIT(2)                  /*!< half transfer finish flag of channel */
N#define DMA_INTF_ERRIF                  BIT(3)                  /*!< error flag of channel */
N
N/* DMA_INTC */
N#define DMA_INTC_GIFC                   BIT(0)                  /*!< clear global interrupt flag of channel */
N#define DMA_INTC_FTFIFC                 BIT(1)                  /*!< clear transfer finish flag of channel */
N#define DMA_INTC_HTFIFC                 BIT(2)                  /*!< clear half transfer finish flag of channel */
N#define DMA_INTC_ERRIFC                 BIT(3)                  /*!< clear error flag of channel */
N
N/* DMA_CHxCTL, x=0..6 */
N#define DMA_CHXCTL_CHEN                 BIT(0)                  /*!< channel enable */
N#define DMA_CHXCTL_FTFIE                BIT(1)                  /*!< enable bit for channel full transfer finish interrupt */
N#define DMA_CHXCTL_HTFIE                BIT(2)                  /*!< enable bit for channel half transfer finish interrupt */
N#define DMA_CHXCTL_ERRIE                BIT(3)                  /*!< enable bit for channel error interrupt */
N#define DMA_CHXCTL_DIR                  BIT(4)                  /*!< transfer direction */
N#define DMA_CHXCTL_CMEN                 BIT(5)                  /*!< circular mode enable */
N#define DMA_CHXCTL_PNAGA                BIT(6)                  /*!< next address generation algorithm of peripheral */
N#define DMA_CHXCTL_MNAGA                BIT(7)                  /*!< next address generation algorithm of memory */
N#define DMA_CHXCTL_PWIDTH               BITS(8,9)               /*!< transfer data width of peripheral */
N#define DMA_CHXCTL_MWIDTH               BITS(10,11)             /*!< transfer data width of memory */
N#define DMA_CHXCTL_PRIO                 BITS(12,13)             /*!< priority level */
N#define DMA_CHXCTL_M2M                  BIT(14)                 /*!< memory to memory mode */
N
N/* DMA_CHxCNT, x=0..6 */
N#define DMA_CHXCNT_CNT                  BITS(0,15)              /*!< transfer counter */
N
N/* DMA_CHxPADDR, x=0..6 */
N#define DMA_CHXPADDR_PADDR              BITS(0,31)              /*!< peripheral base address */
N
N/* DMA_CHxMADDR, x=0..6 */
N#define DMA_CHXMADDR_MADDR              BITS(0,31)              /*!< memory base address */
N
N/* constants definitions */
N/* DMA channel select */
Ntypedef enum 
N{
N    DMA_CH0 = 0,                /*!< DMA channel 0 */
N    DMA_CH1,                    /*!< DMA channel 1 */ 
N    DMA_CH2,                    /*!< DMA channel 2 */ 
N    DMA_CH3,                    /*!< DMA channel 3 */ 
N    DMA_CH4,                    /*!< DMA channel 4 */ 
N    DMA_CH5,                    /*!< DMA channel 5 */ 
N    DMA_CH6                     /*!< DMA channel 6 */
N} dma_channel_enum;
N
N/* DMA initialize struct */
Ntypedef struct
N{
N    uint32_t periph_addr;       /*!< peripheral base address */
N    uint32_t periph_width;      /*!< transfer data size of peripheral */
N    uint32_t memory_addr;       /*!< memory base address */
N    uint32_t memory_width;      /*!< transfer data size of memory */
N    uint32_t number;            /*!< channel transfer number */
N    uint32_t priority;          /*!< channel priority level */
N    uint8_t periph_inc;         /*!< peripheral increasing mode */
N    uint8_t memory_inc;         /*!< memory increasing mode */
N    uint8_t direction;          /*!< channel data transfer direction */
N
N} dma_parameter_struct;
N
N#define DMA_FLAG_ADD(flag, shift)           ((flag) << ((shift) * 4U))                      /*!< DMA channel flag shift */
N
N/* DMA_register address */
N#define DMA_CHCTL(dma, channel)             REG32(((dma) + 0x08U) + 0x14U * (uint32_t)(channel))      /*!< the address of DMA channel CHXCTL register */
N#define DMA_CHCNT(dma, channel)             REG32(((dma) + 0x0CU) + 0x14U * (uint32_t)(channel))      /*!< the address of DMA channel CHXCNT register */
N#define DMA_CHPADDR(dma, channel)           REG32(((dma) + 0x10U) + 0x14U * (uint32_t)(channel))      /*!< the address of DMA channel CHXPADDR register */
N#define DMA_CHMADDR(dma, channel)           REG32(((dma) + 0x14U) + 0x14U * (uint32_t)(channel))      /*!< the address of DMA channel CHXMADDR register */
N
N/* DMA reset value */
N#define DMA_CHCTL_RESET_VALUE               ((uint32_t)0x00000000U)                         /*!< the reset value of DMA channel CHXCTL register */
N#define DMA_CHCNT_RESET_VALUE               ((uint32_t)0x00000000U)                         /*!< the reset value of DMA channel CHXCNT register */
N#define DMA_CHPADDR_RESET_VALUE             ((uint32_t)0x00000000U)                         /*!< the reset value of DMA channel CHXPADDR register */
N#define DMA_CHMADDR_RESET_VALUE             ((uint32_t)0x00000000U)                         /*!< the reset value of DMA channel CHXMADDR register */
N#define DMA_CHINTF_RESET_VALUE              (DMA_INTF_GIF | DMA_INTF_FTFIF | \
N                                             DMA_INTF_HTFIF | DMA_INTF_ERRIF)               /*!< clear DMA channel DMA_INTF register */
X#define DMA_CHINTF_RESET_VALUE              (DMA_INTF_GIF | DMA_INTF_FTFIF |                                              DMA_INTF_HTFIF | DMA_INTF_ERRIF)                
N
N/* DMA_INTF register */
N/* interrupt flag bits */
N#define DMA_INT_FLAG_G                      DMA_INTF_GIF                                    /*!< global interrupt flag of channel */
N#define DMA_INT_FLAG_FTF                    DMA_INTF_FTFIF                                  /*!< full transfer finish interrupt flag of channel */
N#define DMA_INT_FLAG_HTF                    DMA_INTF_HTFIF                                  /*!< half transfer finish interrupt flag of channel */
N#define DMA_INT_FLAG_ERR                    DMA_INTF_ERRIF                                  /*!< error interrupt flag of channel */
N
N/* flag bits */
N#define DMA_FLAG_G                          DMA_INTF_GIF                                    /*!< global interrupt flag of channel */
N#define DMA_FLAG_FTF                        DMA_INTF_FTFIF                                  /*!< full transfer finish flag of channel */
N#define DMA_FLAG_HTF                        DMA_INTF_HTFIF                                  /*!< half transfer finish flag of channel */
N#define DMA_FLAG_ERR                        DMA_INTF_ERRIF                                  /*!< error flag of channel */
N
N/* DMA_CHxCTL register */
N/* interrupt enable bits */
N#define DMA_INT_FTF                         DMA_CHXCTL_FTFIE                                /*!< enable bit for channel full transfer finish interrupt */
N#define DMA_INT_HTF                         DMA_CHXCTL_HTFIE                                /*!< enable bit for channel half transfer finish interrupt */
N#define DMA_INT_ERR                         DMA_CHXCTL_ERRIE                                /*!< enable bit for channel error interrupt */
N
N/* transfer direction */
N#define DMA_PERIPHERAL_TO_MEMORY            ((uint8_t)0x00U)                                /*!< read from peripheral and write to memory */
N#define DMA_MEMORY_TO_PERIPHERAL            ((uint8_t)0x01U)                                /*!< read from memory and write to peripheral */
N/* circular mode */
N#define DMA_CIRCULAR_MODE_DISABLE           ((uint32_t)0x00000000U)                         /*!< circular mode disable */
N#define DMA_CIRCULAR_MODE_ENABLE            ((uint32_t)0x00000001U)                         /*!< circular mode enable */
N
N/* peripheral increasing mode */
N#define DMA_PERIPH_INCREASE_DISABLE         ((uint8_t)0x00U)                                /*!< next address of peripheral is fixed address mode */
N#define DMA_PERIPH_INCREASE_ENABLE          ((uint8_t)0x01U)                                /*!< next address of peripheral is increasing address mode */
N
N/* memory increasing mode */
N#define DMA_MEMORY_INCREASE_DISABLE         ((uint8_t)0x00U)                                /*!< next address of memory is fixed address mode */
N#define DMA_MEMORY_INCREASE_ENABLE          ((uint8_t)0x01U)                                /*!< next address of memory is increasing address mode */
N
N/* transfer data size of peripheral */
N#define CHCTL_PWIDTH(regval)                (BITS(8,9) & ((regval) << 8))                   /*!< transfer data size of peripheral */
N#define DMA_PERIPHERAL_WIDTH_8BIT           CHCTL_PWIDTH(0U)                                 /*!< transfer data size of peripheral is 8-bit */
N#define DMA_PERIPHERAL_WIDTH_16BIT          CHCTL_PWIDTH(1U)                                 /*!< transfer data size of peripheral is 16-bit */
N#define DMA_PERIPHERAL_WIDTH_32BIT          CHCTL_PWIDTH(2U)                                 /*!< transfer data size of peripheral is 32-bit */
N
N/* transfer data size of memory */
N#define CHCTL_MWIDTH(regval)                (BITS(10,11) & ((regval) << 10))                /*!< transfer data size of memory */
N#define DMA_MEMORY_WIDTH_8BIT               CHCTL_MWIDTH(0U)                                 /*!< transfer data size of memory is 8-bit */
N#define DMA_MEMORY_WIDTH_16BIT              CHCTL_MWIDTH(1U)                                 /*!< transfer data size of memory is 16-bit */
N#define DMA_MEMORY_WIDTH_32BIT              CHCTL_MWIDTH(2U)                                 /*!< transfer data size of memory is 32-bit */
N
N/* channel priority level */
N#define CHCTL_PRIO(regval)                  (BITS(12,13) & ((regval) << 12))                /*!< DMA channel priority level */
N#define DMA_PRIORITY_LOW                    CHCTL_PRIO(0U)                                   /*!< low priority */
N#define DMA_PRIORITY_MEDIUM                 CHCTL_PRIO(1U)                                   /*!< medium priority */
N#define DMA_PRIORITY_HIGH                   CHCTL_PRIO(2U)                                   /*!< high priority */
N#define DMA_PRIORITY_ULTRA_HIGH             CHCTL_PRIO(3U)                                   /*!< ultra high priority */
N
N/* memory to memory mode */
N#define DMA_MEMORY_TO_MEMORY_DISABLE        ((uint32_t)0x00000000U)                         /*!< disable memory to memory mode */
N#define DMA_MEMORY_TO_MEMORY_ENABLE         ((uint32_t)0x00000001U)                         /*!< enable memory to memory mode */
N
N/* DMA_CHxCNT register */
N/* transfer counter */
N#define DMA_CHANNEL_CNT_MASK                DMA_CHXCNT_CNT                                  /*!< transfer counter mask */
N
N/* function declarations */
N/* DMA deinitialization and initialization functions */
N/* deinitialize DMA a channel registers */
Nvoid dma_deinit(uint32_t dma_periph, dma_channel_enum channelx);
N/* initialize the parameters of DMA struct with the default values */
Nvoid dma_struct_para_init(dma_parameter_struct* init_struct);
N/* initialize DMA channel */
Nvoid dma_init(uint32_t dma_periph, dma_channel_enum channelx, dma_parameter_struct *init_struct);
N/* enable DMA circulation mode */
Nvoid dma_circulation_enable(uint32_t dma_periph, dma_channel_enum channelx);
N/* disable DMA circulation mode */
Nvoid dma_circulation_disable(uint32_t dma_periph, dma_channel_enum channelx);
N/* enable memory to memory mode */
Nvoid dma_memory_to_memory_enable(uint32_t dma_periph, dma_channel_enum channelx);
N/* disable memory to memory mode */
Nvoid dma_memory_to_memory_disable(uint32_t dma_periph, dma_channel_enum channelx);
N/* enable DMA channel */
Nvoid dma_channel_enable(uint32_t dma_periph, dma_channel_enum channelx);
N/* disable DMA channel */
Nvoid dma_channel_disable(uint32_t dma_periph, dma_channel_enum channelx);
N
N/* DMA configuration functions */
N/* set DMA peripheral base address */
Nvoid dma_periph_address_config(uint32_t dma_periph, dma_channel_enum channelx, uint32_t address);
N/* set DMA memory base address */
Nvoid dma_memory_address_config(uint32_t dma_periph, dma_channel_enum channelx, uint32_t address);
N/* set the number of remaining data to be transferred by the DMA */
Nvoid dma_transfer_number_config(uint32_t dma_periph, dma_channel_enum channelx, uint32_t number);
N/* get the number of remaining data to be transferred by the DMA */
Nuint32_t dma_transfer_number_get(uint32_t dma_periph, dma_channel_enum channelx);
N/* configure priority level of DMA channel */
Nvoid dma_priority_config(uint32_t dma_periph, dma_channel_enum channelx, uint32_t priority);
N/* configure transfer data size of memory */
Nvoid dma_memory_width_config(uint32_t dma_periph, dma_channel_enum channelx, uint32_t mwidth);
N/* configure transfer data size of peripheral */
Nvoid dma_periph_width_config(uint32_t dma_periph, dma_channel_enum channelx, uint32_t pwidth);
N/* enable next address increasement algorithm of memory */
Nvoid dma_memory_increase_enable(uint32_t dma_periph, dma_channel_enum channelx);
N/* disable next address increasement algorithm of memory */
Nvoid dma_memory_increase_disable(uint32_t dma_periph, dma_channel_enum channelx);
N/* enable next address increasement algorithm of peripheral */
Nvoid dma_periph_increase_enable(uint32_t dma_periph, dma_channel_enum channelx);
N/* disable next address increasement algorithm of peripheral */
Nvoid dma_periph_increase_disable(uint32_t dma_periph, dma_channel_enum channelx);
N/* configure the direction of data transfer on the channel */
Nvoid dma_transfer_direction_config(uint32_t dma_periph, dma_channel_enum channelx, uint8_t direction);
N
N/* flag and interrupt functions */
N/* check DMA flag is set or not */
NFlagStatus dma_flag_get(uint32_t dma_periph, dma_channel_enum channelx, uint32_t flag);
N/* clear the flag of a DMA channel */
Nvoid dma_flag_clear(uint32_t dma_periph, dma_channel_enum channelx, uint32_t flag);
N/* check DMA flag and interrupt enable bit is set or not */
NFlagStatus dma_interrupt_flag_get(uint32_t dma_periph, dma_channel_enum channelx, uint32_t flag);
N/* clear the interrupt flag of a DMA channel */
Nvoid dma_interrupt_flag_clear(uint32_t dma_periph, dma_channel_enum channelx, uint32_t flag);
N/* enable DMA interrupt */
Nvoid dma_interrupt_enable(uint32_t dma_periph, dma_channel_enum channelx, uint32_t source);
N/* disable DMA interrupt */
Nvoid dma_interrupt_disable(uint32_t dma_periph, dma_channel_enum channelx, uint32_t source);
N
N#endif /* GD32F10X_DMA_H */
L 50 ".\User\gd32f10x_libopt.h" 2
N#include "gd32f10x_dbg.h"
L 1 ".\Libraries\inc\gd32f10x_dbg.h" 1
N/*!
N    \file  gd32f10x_dbg.h
N    \brief definitions for the DBG
N
N    \version 2014-12-26, V1.0.0, firmware for GD32F10x
N    \version 2017-06-20, V2.0.0, firmware for GD32F10x
N    \version 2018-07-31, V2.1.0, firmware for GD32F10x
N    \version 2019-07-01, V2.1.1, firmware for GD32F10x
N*/
N
N/*
N    Copyright (c) 2018, GigaDevice Semiconductor Inc.
N
N    All rights reserved.
N
N    Redistribution and use in source and binary forms, with or without modification, 
Nare permitted provided that the following conditions are met:
N
N    1. Redistributions of source code must retain the above copyright notice, this 
N       list of conditions and the following disclaimer.
N    2. Redistributions in binary form must reproduce the above copyright notice, 
N       this list of conditions and the following disclaimer in the documentation 
N       and/or other materials provided with the distribution.
N    3. Neither the name of the copyright holder nor the names of its contributors 
N       may be used to endorse or promote products derived from this software without 
N       specific prior written permission.
N
N    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
NAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
NWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
NIN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
NINDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
NNOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
NPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
NWHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
NARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
NOF SUCH DAMAGE.
N*/
N
N#ifndef GD32F10X_DBG_H
N#define GD32F10X_DBG_H
N
N#include "gd32f10x.h"
N
N/* DBG definitions */
N#define DBG                      DBG_BASE
N
N/* registers definitions */
N#define DBG_ID                   REG32(DBG + 0x00U)         /*!< DBG_ID code register */
N#define DBG_CTL                  REG32(DBG + 0x04U)         /*!< DBG control register */
N
N/* bits definitions */
N/* DBG_ID */
N#define DBG_ID_ID_CODE           BITS(0,31)                 /*!< DBG ID code values */
N
N/* DBG_CTL */
N#define DBG_CTL_SLP_HOLD        BIT(0)                      /*!< keep debugger connection during sleep mode */
N#define DBG_CTL_DSLP_HOLD       BIT(1)                      /*!< keep debugger connection during deepsleep mode */
N#define DBG_CTL_STB_HOLD        BIT(2)                      /*!< keep debugger connection during standby mode */
N#define DBG_CTL_TRACE_IOEN      BIT(5)                      /*!< enable trace pin assignment */
N#define DBG_CTL_TRACE_MODE      BITS(6,7)                   /*!< trace pin mode selection */
N#define DBG_CTL_FWDGT_HOLD      BIT(8)                      /*!< debug FWDGT kept when core is halted */
N#define DBG_CTL_WWDGT_HOLD      BIT(9)                      /*!< debug WWDGT kept when core is halted */
N#define DBG_CTL_TIMER0_HOLD     BIT(10)                     /*!< hold TIMER0 counter when core is halted */
N#define DBG_CTL_TIMER1_HOLD     BIT(11)                     /*!< hold TIMER1 counter when core is halted */
N#define DBG_CTL_TIMER2_HOLD     BIT(12)                     /*!< hold TIMER2 counter when core is halted */
N#define DBG_CTL_TIMER3_HOLD     BIT(13)                     /*!< hold TIMER3 counter when core is halted */
N#define DBG_CTL_CAN0_HOLD       BIT(14)                     /*!< debug CAN0 kept when core is halted */
N#define DBG_CTL_I2C0_HOLD       BIT(15)                     /*!< hold I2C0 smbus when core is halted */
N#define DBG_CTL_I2C1_HOLD       BIT(16)                     /*!< hold I2C1 smbus when core is halted */
N#define DBG_CTL_TIMER7_HOLD     BIT(17)                     /*!< hold TIMER7 counter when core is halted */
N#define DBG_CTL_TIMER4_HOLD     BIT(18)                     /*!< hold TIMER4 counter when core is halted */
N#define DBG_CTL_TIMER5_HOLD     BIT(19)                     /*!< hold TIMER5 counter when core is halted */
N#define DBG_CTL_TIMER6_HOLD     BIT(20)                     /*!< hold TIMER6 counter when core is halted */
N#ifdef GD32F10X_CL
S#define DBG_CTL_CAN1_HOLD       BIT(21)                     /*!< debug CAN1 kept when core is halted */
N#endif /* GD32F10X_CL */
N#ifdef GD32F10X_XD
N#define DBG_CTL_TIMER11_HOLD    BIT(25)                     /*!< hold TIMER11 counter when core is halted */
N#define DBG_CTL_TIMER12_HOLD    BIT(26)                     /*!< hold TIMER12 counter when core is halted */
N#define DBG_CTL_TIMER13_HOLD    BIT(27)                     /*!< hold TIMER13 counter when core is halted */
N#define DBG_CTL_TIMER8_HOLD     BIT(28)                     /*!< hold TIMER8 counter when core is halted */
N#define DBG_CTL_TIMER9_HOLD     BIT(29)                     /*!< hold TIMER9 counter when core is halted */
N#define DBG_CTL_TIMER10_HOLD    BIT(30)                     /*!< hold TIMER10 counter when core is halted */
N#endif /* GD32F10X_XD */
N
N/* constants definitions */
N/* debug hold when core is halted */
Ntypedef enum
N{
N    DBG_FWDGT_HOLD             = BIT(8),                    /*!< debug FWDGT kept when core is halted */
X    DBG_FWDGT_HOLD             = ((uint32_t)((uint32_t)0x01U<<(8))),                     
N    DBG_WWDGT_HOLD             = BIT(9),                    /*!< debug WWDGT kept when core is halted */
X    DBG_WWDGT_HOLD             = ((uint32_t)((uint32_t)0x01U<<(9))),                     
N    DBG_TIMER0_HOLD            = BIT(10),                   /*!< hold TIMER0 counter when core is halted */
X    DBG_TIMER0_HOLD            = ((uint32_t)((uint32_t)0x01U<<(10))),                    
N    DBG_TIMER1_HOLD            = BIT(11),                   /*!< hold TIMER1 counter when core is halted */
X    DBG_TIMER1_HOLD            = ((uint32_t)((uint32_t)0x01U<<(11))),                    
N    DBG_TIMER2_HOLD            = BIT(12),                   /*!< hold TIMER2 counter when core is halted */
X    DBG_TIMER2_HOLD            = ((uint32_t)((uint32_t)0x01U<<(12))),                    
N    DBG_TIMER3_HOLD            = BIT(13),                   /*!< hold TIMER3 counter when core is halted */
X    DBG_TIMER3_HOLD            = ((uint32_t)((uint32_t)0x01U<<(13))),                    
N    DBG_CAN0_HOLD              = BIT(14),                   /*!< debug CAN0 kept when core is halted */
X    DBG_CAN0_HOLD              = ((uint32_t)((uint32_t)0x01U<<(14))),                    
N    DBG_I2C0_HOLD              = BIT(15),                   /*!< hold I2C0 smbus when core is halted */
X    DBG_I2C0_HOLD              = ((uint32_t)((uint32_t)0x01U<<(15))),                    
N    DBG_I2C1_HOLD              = BIT(16),                   /*!< hold I2C1 smbus when core is halted */
X    DBG_I2C1_HOLD              = ((uint32_t)((uint32_t)0x01U<<(16))),                    
N    DBG_TIMER7_HOLD            = BIT(17),                   /*!< hold TIMER7 counter when core is halted */
X    DBG_TIMER7_HOLD            = ((uint32_t)((uint32_t)0x01U<<(17))),                    
N    DBG_TIMER4_HOLD            = BIT(18),                   /*!< hold TIMER4 counter when core is halted */
X    DBG_TIMER4_HOLD            = ((uint32_t)((uint32_t)0x01U<<(18))),                    
N    DBG_TIMER5_HOLD            = BIT(19),                   /*!< hold TIMER5 counter when core is halted */
X    DBG_TIMER5_HOLD            = ((uint32_t)((uint32_t)0x01U<<(19))),                    
N    DBG_TIMER6_HOLD            = BIT(20),                   /*!< hold TIMER6 counter when core is halted */
X    DBG_TIMER6_HOLD            = ((uint32_t)((uint32_t)0x01U<<(20))),                    
N#ifdef GD32F10X_CL
S    DBG_CAN1_HOLD              = BIT(21),                   /*!< debug CAN1 kept when core is halted */
N#endif /* GD32F10X_CL */
N#if (defined(GD32F10X_XD) || defined(GD32F10X_CL))
X#if (1L || 0L)
N    DBG_TIMER11_HOLD           = BIT(25),                   /*!< hold TIMER11 counter when core is halted */
X    DBG_TIMER11_HOLD           = ((uint32_t)((uint32_t)0x01U<<(25))),                    
N    DBG_TIMER12_HOLD           = BIT(26),                   /*!< hold TIMER12 counter when core is halted */
X    DBG_TIMER12_HOLD           = ((uint32_t)((uint32_t)0x01U<<(26))),                    
N    DBG_TIMER13_HOLD           = BIT(27),                   /*!< hold TIMER13 counter when core is halted */
X    DBG_TIMER13_HOLD           = ((uint32_t)((uint32_t)0x01U<<(27))),                    
N    DBG_TIMER8_HOLD            = BIT(28),                   /*!< hold TIMER8 counter when core is halted */
X    DBG_TIMER8_HOLD            = ((uint32_t)((uint32_t)0x01U<<(28))),                    
N    DBG_TIMER9_HOLD            = BIT(29),                   /*!< hold TIMER9 counter when core is halted */
X    DBG_TIMER9_HOLD            = ((uint32_t)((uint32_t)0x01U<<(29))),                    
N    DBG_TIMER10_HOLD           = BIT(30),                   /*!< hold TIMER10 counter when core is halted */
X    DBG_TIMER10_HOLD           = ((uint32_t)((uint32_t)0x01U<<(30))),                    
N#endif /* GD32F10X_XD || GD32F10X_CL*/
N}dbg_periph_enum;
N
N/* DBG low power mode configurations */
N#define DBG_LOW_POWER_SLEEP      DBG_CTL_SLP_HOLD           /*!< keep debugger connection during sleep mode */
N#define DBG_LOW_POWER_DEEPSLEEP  DBG_CTL_DSLP_HOLD          /*!< keep debugger connection during deepsleep mode */
N#define DBG_LOW_POWER_STANDBY    DBG_CTL_STB_HOLD           /*!< keep debugger connection during standby mode */
N
N/* DBG_CTL0_TRACE_MODE configurations */
N#define CTL_TRACE_MODE(regval)       (BITS(6,7) & ((uint32_t)(regval) << 6U))
N#define TRACE_MODE_ASYNC              CTL_TRACE_MODE(0)     /*!< trace pin used for async mode */
N#define TRACE_MODE_SYNC_DATASIZE_1    CTL_TRACE_MODE(1)     /*!< trace pin used for sync mode and data size is 1 */
N#define TRACE_MODE_SYNC_DATASIZE_2    CTL_TRACE_MODE(2)     /*!< trace pin used for sync mode and data size is 2 */
N#define TRACE_MODE_SYNC_DATASIZE_4    CTL_TRACE_MODE(3)     /*!< trace pin used for sync mode and data size is 4 */
N
N/* function declarations */
N/* read DBG_ID code register */
Nuint32_t dbg_id_get(void);
N
N/* low power behavior configuration */
N/* enable low power behavior when the MCU is in debug mode */
Nvoid dbg_low_power_enable(uint32_t dbg_low_power);
N/* disable low power behavior when the MCU is in debug mode */
Nvoid dbg_low_power_disable(uint32_t dbg_low_power);
N
N/* peripheral behavior configuration */
N/* enable peripheral behavior when the MCU is in debug mode */
Nvoid dbg_periph_enable(dbg_periph_enum dbg_periph);
N/* disable peripheral behavior when the MCU is in debug mode */
Nvoid dbg_periph_disable(dbg_periph_enum dbg_periph);
N
N/* trace pin assignment configuration */
N/* enable trace pin assignment */
Nvoid dbg_trace_pin_enable(void);
N/* disable trace pin assignment */
Nvoid dbg_trace_pin_disable(void);
N/* set trace pin mode */
Nvoid dbg_trace_pin_mode_set(uint32_t trace_mode);
N
N#endif /* GD32F10X_DBG_H */
L 51 ".\User\gd32f10x_libopt.h" 2
N#include "gd32f10x_adc.h"
L 1 ".\Libraries\inc\gd32f10x_adc.h" 1
N/*!
N    \file  gd32f10x_adc.h
N    \brief definitions for the ADC
N
N    \version 2014-12-26, V1.0.0, firmware for GD32F10x
N    \version 2017-06-20, V2.0.0, firmware for GD32F10x
N    \version 2018-07-31, V2.1.0, firmware for GD32F10x
N*/
N
N/*
N    Copyright (c) 2018, GigaDevice Semiconductor Inc.
N
N    All rights reserved.
N
N    Redistribution and use in source and binary forms, with or without modification, 
Nare permitted provided that the following conditions are met:
N
N    1. Redistributions of source code must retain the above copyright notice, this 
N       list of conditions and the following disclaimer.
N    2. Redistributions in binary form must reproduce the above copyright notice, 
N       this list of conditions and the following disclaimer in the documentation 
N       and/or other materials provided with the distribution.
N    3. Neither the name of the copyright holder nor the names of its contributors 
N       may be used to endorse or promote products derived from this software without 
N       specific prior written permission.
N
N    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
NAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
NWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
NIN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
NINDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
NNOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
NPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
NWHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
NARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
NOF SUCH DAMAGE.
N*/
N
N#ifndef GD32F10x_ADC_H
N#define GD32F10x_ADC_H
N
N#include "gd32f10x.h"
N
N/* ADC definitions */
N#define ADC0                            ADC_BASE
N#define ADC1                            (ADC_BASE + 0x400U)
N#define ADC2                            (ADC_BASE + 0x1800U)
N
N/* registers definitions */
N#define ADC_STAT(adcx)                  REG32((adcx) + 0x00U)            /*!< ADC status register */
N#define ADC_CTL0(adcx)                  REG32((adcx) + 0x04U)            /*!< ADC control register 0 */
N#define ADC_CTL1(adcx)                  REG32((adcx) + 0x08U)            /*!< ADC control register 1 */
N#define ADC_SAMPT0(adcx)                REG32((adcx) + 0x0CU)            /*!< ADC sampling time register 0 */
N#define ADC_SAMPT1(adcx)                REG32((adcx) + 0x10U)            /*!< ADC sampling time register 1 */
N#define ADC_IOFF0(adcx)                 REG32((adcx) + 0x14U)            /*!< ADC inserted channel data offset register 0 */
N#define ADC_IOFF1(adcx)                 REG32((adcx) + 0x18U)            /*!< ADC inserted channel data offset register 1 */
N#define ADC_IOFF2(adcx)                 REG32((adcx) + 0x1CU)            /*!< ADC inserted channel data offset register 2 */
N#define ADC_IOFF3(adcx)                 REG32((adcx) + 0x20U)            /*!< ADC inserted channel data offset register 3 */
N#define ADC_WDHT(adcx)                  REG32((adcx) + 0x24U)            /*!< ADC watchdog high threshold register */
N#define ADC_WDLT(adcx)                  REG32((adcx) + 0x28U)            /*!< ADC watchdog low threshold register */
N#define ADC_RSQ0(adcx)                  REG32((adcx) + 0x2CU)            /*!< ADC regular sequence register 0 */
N#define ADC_RSQ1(adcx)                  REG32((adcx) + 0x30U)            /*!< ADC regular sequence register 1 */
N#define ADC_RSQ2(adcx)                  REG32((adcx) + 0x34U)            /*!< ADC regular sequence register 2 */
N#define ADC_ISQ(adcx)                   REG32((adcx) + 0x38U)            /*!< ADC inserted sequence register */
N#define ADC_IDATA0(adcx)                REG32((adcx) + 0x3CU)            /*!< ADC inserted data register 0 */
N#define ADC_IDATA1(adcx)                REG32((adcx) + 0x40U)            /*!< ADC inserted data register 1 */
N#define ADC_IDATA2(adcx)                REG32((adcx) + 0x44U)            /*!< ADC inserted data register 2 */
N#define ADC_IDATA3(adcx)                REG32((adcx) + 0x48U)            /*!< ADC inserted data register 3 */
N#define ADC_RDATA(adcx)                 REG32((adcx) + 0x4CU)            /*!< ADC regular data register */
N
N/* bits definitions */
N/* ADC_STAT */
N#define ADC_STAT_WDE                    BIT(0)                           /*!< analog watchdog event flag */
N#define ADC_STAT_EOC                    BIT(1)                           /*!< end of conversion */
N#define ADC_STAT_EOIC                   BIT(2)                           /*!< inserted channel end of conversion */
N#define ADC_STAT_STIC                   BIT(3)                           /*!< inserted channel start flag */
N#define ADC_STAT_STRC                   BIT(4)                           /*!< regular channel start flag */
N
N/* ADC_CTL0 */
N#define ADC_CTL0_WDCHSEL                BITS(0,4)                        /*!< analog watchdog channel select bits */
N#define ADC_CTL0_EOCIE                  BIT(5)                           /*!< interrupt enable for EOC */
N#define ADC_CTL0_WDEIE                  BIT(6)                           /*!< analog watchdog interrupt enable */
N#define ADC_CTL0_EOICIE                 BIT(7)                           /*!< interrupt enable for inserted channels */
N#define ADC_CTL0_SM                     BIT(8)                           /*!< scan mode */
N#define ADC_CTL0_WDSC                   BIT(9)                           /*!< when in scan mode, analog watchdog is effective on a single channel */
N#define ADC_CTL0_ICA                    BIT(10)                          /*!< automatic inserted group conversion */
N#define ADC_CTL0_DISRC                  BIT(11)                          /*!< discontinuous mode on regular channels */
N#define ADC_CTL0_DISIC                  BIT(12)                          /*!< discontinuous mode on inserted channels */
N#define ADC_CTL0_DISNUM                 BITS(13,15)                      /*!< discontinuous mode channel count */
N#define ADC_CTL0_SYNCM                  BITS(16,19)                      /*!< sync mode selection */
N#define ADC_CTL0_IWDEN                  BIT(22)                          /*!< analog watchdog enable on inserted channels */
N#define ADC_CTL0_RWDEN                  BIT(23)                          /*!< analog watchdog enable on regular channels */
N#define ADC_CTL0_DRES                   BITS(24,25)                      /*!< ADC data resolution */
N
N/* ADC_CTL1 */
N#define ADC_CTL1_ADCON                  BIT(0)                           /*!< ADC converter on */
N#define ADC_CTL1_CTN                    BIT(1)                           /*!< continuous conversion */
N#define ADC_CTL1_CLB                    BIT(2)                           /*!< ADC calibration */
N#define ADC_CTL1_RSTCLB                 BIT(3)                           /*!< reset calibration */
N#define ADC_CTL1_DMA                    BIT(8)                           /*!< direct memory access mode */
N#define ADC_CTL1_DAL                    BIT(11)                          /*!< data alignment */
N#define ADC_CTL1_ETSIC                  BITS(12,14)                      /*!< external trigger select for inserted channel */
N#define ADC_CTL1_ETEIC                  BIT(15)                          /*!< external trigger enable for inserted channel */
N#define ADC_CTL1_ETSRC                  BITS(17,19)                      /*!< external trigger select for regular channel */
N#define ADC_CTL1_ETERC                  BIT(20)                          /*!< external trigger conversion mode for inserted channels */
N#define ADC_CTL1_SWICST                 BIT(21)                          /*!< start on inserted channel */
N#define ADC_CTL1_SWRCST                 BIT(22)                          /*!< start on regular channel */
N#define ADC_CTL1_TSVREN                 BIT(23)                          /*!< channel 16 and 17 enable of ADC0 */
N
N/* ADC_SAMPTx x=0..1 */
N#define ADC_SAMPTX_SPTN                 BITS(0,2)                        /*!< channel n sample time selection */
N
N/* ADC_IOFFx x=0..3 */
N#define ADC_IOFFX_IOFF                  BITS(0,11)                       /*!< data offset for inserted channel x */
N
N/* ADC_WDHT */
N#define ADC_WDHT_WDHT                   BITS(0,11)                       /*!< analog watchdog high threshold */
N
N/* ADC_WDLT */
N#define ADC_WDLT_WDLT                   BITS(0,11)                       /*!< analog watchdog low threshold */
N
N/* ADC_RSQx x=0..2 */
N#define ADC_RSQX_RSQN                   BITS(0,4)                        /*!< nth conversion in regular sequence */
N#define ADC_RSQ0_RL                     BITS(20,23)                      /*!< regular channel sequence length */
N
N/* ADC_ISQ */
N#define ADC_ISQ_ISQN                    BITS(0,4)                        /*!< nth conversion in inserted sequence */
N#define ADC_ISQ_IL                      BITS(20,21)                      /*!< inserted sequence length */
N
N/* ADC_IDATAx x=0..3*/
N#define ADC_IDATAX_IDATAN               BITS(0,15)                       /*!< inserted data n */
N
N/* ADC_RDATA */
N#define ADC_RDATA_RDATA                 BITS(0,15)                       /*!< regular data */
N#define ADC_RDATA_ADC1RDTR              BITS(16,31)                      /*!< ADC1 regular channel data */
N
N/* constants definitions */
N/* adc_stat register value */
N#define ADC_FLAG_WDE                    ADC_STAT_WDE                                 /*!< analog watchdog event flag */
N#define ADC_FLAG_EOC                    ADC_STAT_EOC                                 /*!< end of conversion */
N#define ADC_FLAG_EOIC                   ADC_STAT_EOIC                                /*!< inserted channel end of conversion */
N#define ADC_FLAG_STIC                   ADC_STAT_STIC                                /*!< inserted channel start flag */
N#define ADC_FLAG_STRC                   ADC_STAT_STRC                                /*!< regular channel start flag */
N
N/* adc_ctl0 register value */
N#define CTL0_DISNUM(regval)             (BITS(13,15) & ((uint32_t)(regval) << 13))   /*!< write value to ADC_CTL0_DISNUM bit field */
N
N/* scan mode */
N#define ADC_SCAN_MODE                   ADC_CTL0_SM                                  /*!< scan mode */
N
N/* inserted channel group convert automatically */
N#define ADC_INSERTED_CHANNEL_AUTO       ADC_CTL0_ICA                                 /*!< inserted channel group convert automatically */
N
N/* ADC sync mode */
N#define CTL0_SYNCM(regval)              (BITS(16,19) & ((uint32_t)(regval) << 16))   /*!< write value to ADC_CTL0_SYNCM bit field */
N#define ADC_MODE_FREE                                        CTL0_SYNCM(0)           /*!< all the ADCs work independently */
N#define ADC_DAUL_REGULAL_PARALLEL_INSERTED_PARALLEL          CTL0_SYNCM(1)           /*!< ADC0 and ADC1 work in combined regular parallel + inserted parallel mode */
N#define ADC_DAUL_REGULAL_PARALLEL_INSERTED_ROTATION          CTL0_SYNCM(2)           /*!< ADC0 and ADC1 work in combined regular parallel + trigger rotation mode */
N#define ADC_DAUL_INSERTED_PARALLEL_REGULAL_FOLLOWUP_FAST     CTL0_SYNCM(3)           /*!< ADC0 and ADC1 work in combined inserted parallel + follow-up fast mode */
N#define ADC_DAUL_INSERTED_PARALLEL_REGULAL_FOLLOWUP_SLOW     CTL0_SYNCM(4)           /*!< ADC0 and ADC1 work in combined inserted parallel + follow-up slow mode */
N#define ADC_DAUL_INSERTED_PARALLEL                           CTL0_SYNCM(5)           /*!< ADC0 and ADC1 work in inserted parallel mode only */
N#define ADC_DAUL_REGULAL_PARALLEL                            CTL0_SYNCM(6)           /*!< ADC0 and ADC1 work in regular parallel mode only */
N#define ADC_DAUL_REGULAL_FOLLOWUP_FAST                       CTL0_SYNCM(7)           /*!< ADC0 and ADC1 work in follow-up fast mode only */
N#define ADC_DAUL_REGULAL_FOLLOWUP_SLOW                       CTL0_SYNCM(8)           /*!< ADC0 and ADC1 work in follow-up slow mode only */
N#define ADC_DAUL_INSERTED_TRIGGER_ROTATION                   CTL0_SYNCM(9)           /*!< ADC0 and ADC1 work in trigger rotation mode only */
N
N/* adc_ctl1 register value */
N#define ADC_DATAALIGN_RIGHT              ((uint32_t)0x00000000U)                     /*!< LSB alignment */
N#define ADC_DATAALIGN_LEFT               ADC_CTL1_DAL                                /*!< MSB alignment */
N
N/* continuous mode */
N#define ADC_CONTINUOUS_MODE              ADC_CTL1_CTN                                /*!< continuous mode */
N
N/* external trigger select for regular channel */
N#define CTL1_ETSRC(regval)               (BITS(17,19) & ((uint32_t)(regval) << 17))  /*!< write value to ADC_CTL1_ETSRC bit field */
N/* for ADC0 and ADC1 regular channel */
N#define ADC0_1_EXTTRIG_REGULAR_T0_CH0    CTL1_ETSRC(0)                               /*!< TIMER0 CH0 event select */
N#define ADC0_1_EXTTRIG_REGULAR_T0_CH1    CTL1_ETSRC(1)                               /*!< TIMER0 CH1 event select */
N#define ADC0_1_EXTTRIG_REGULAR_T0_CH2    CTL1_ETSRC(2)                               /*!< TIMER0 CH2 event select */
N#define ADC0_1_EXTTRIG_REGULAR_T1_CH1    CTL1_ETSRC(3)                               /*!< TIMER1 CH1 event select */
N#define ADC0_1_EXTTRIG_REGULAR_T2_TRGO   CTL1_ETSRC(4)                               /*!< TIMER2 TRGO event select */
N#define ADC0_1_EXTTRIG_REGULAR_T3_CH3    CTL1_ETSRC(5)                               /*!< TIMER3 CH3 event select */
N#define ADC0_1_EXTTRIG_REGULAR_T7_TRGO   CTL1_ETSRC(6)                               /*!< TIMER7 TRGO event select */
N#define ADC0_1_EXTTRIG_REGULAR_EXTI_11   CTL1_ETSRC(6)                               /*!< external interrupt line 11 */
N#define ADC0_1_2_EXTTRIG_REGULAR_NONE    CTL1_ETSRC(7)                               /*!< software trigger */
N/* for ADC2 regular channel */
N#define ADC2_EXTTRIG_REGULAR_T2_CH0      CTL1_ETSRC(0)                               /*!< TIMER2 CH0 event select */
N#define ADC2_EXTTRIG_REGULAR_T1_CH2      CTL1_ETSRC(1)                               /*!< TIMER1 CH2 event select */
N#define ADC2_EXTTRIG_REGULAR_T0_CH2      CTL1_ETSRC(2)                               /*!< TIMER0 CH2 event select */
N#define ADC2_EXTTRIG_REGULAR_T7_CH0      CTL1_ETSRC(3)                               /*!< TIMER7 CH0 event select */
N#define ADC2_EXTTRIG_REGULAR_T7_TRGO     CTL1_ETSRC(4)                               /*!< TIMER7 TRGO event select */
N#define ADC2_EXTTRIG_REGULAR_T4_CH0      CTL1_ETSRC(5)                               /*!< TIMER4 CH0 event select */
N#define ADC2_EXTTRIG_REGULAR_T4_CH2      CTL1_ETSRC(6)                               /*!< TIMER4 CH2 event select */
N
N/* external trigger mode for inserted channel */
N#define CTL1_ETSIC(regval)               (BITS(12,14) & ((uint32_t)(regval) << 12))  /*!< write value to ADC_CTL1_ETSIC bit field */
N/* for ADC0 and ADC1 inserted channel */
N#define ADC0_1_EXTTRIG_INSERTED_T0_TRGO  CTL1_ETSIC(0)                               /*!< TIMER0 TRGO event select */
N#define ADC0_1_EXTTRIG_INSERTED_T0_CH3   CTL1_ETSIC(1)                               /*!< TIMER0 CH3 event select */
N#define ADC0_1_EXTTRIG_INSERTED_T1_TRGO  CTL1_ETSIC(2)                               /*!< TIMER1 TRGO event select */
N#define ADC0_1_EXTTRIG_INSERTED_T1_CH0   CTL1_ETSIC(3)                               /*!< TIMER1 CH0 event select */
N#define ADC0_1_EXTTRIG_INSERTED_T2_CH3   CTL1_ETSIC(4)                               /*!< TIMER2 CH3 event select */
N#define ADC0_1_EXTTRIG_INSERTED_T3_TRGO  CTL1_ETSIC(5)                               /*!< TIMER3 TRGO event select */
N#define ADC0_1_EXTTRIG_INSERTED_EXTI_15  CTL1_ETSIC(6)                               /*!< external interrupt line 15 */
N#define ADC0_1_EXTTRIG_INSERTED_T7_CH3   CTL1_ETSIC(6)                               /*!< TIMER7 CH3 event select */
N#define ADC0_1_2_EXTTRIG_INSERTED_NONE   CTL1_ETSIC(7)                               /*!< software trigger */
N/* for ADC2 inserted channel */
N#define ADC2_EXTTRIG_INSERTED_T0_TRGO    CTL1_ETSIC(0)                               /*!< TIMER0 TRGO event select */
N#define ADC2_EXTTRIG_INSERTED_T0_CH3     CTL1_ETSIC(1)                               /*!< TIMER0 CH3 event select */
N#define ADC2_EXTTRIG_INSERTED_T3_CH2     CTL1_ETSIC(2)                               /*!< TIMER3 CH2 event select */
N#define ADC2_EXTTRIG_INSERTED_T7_CH1     CTL1_ETSIC(3)                               /*!< TIMER7 CH1 event select */
N#define ADC2_EXTTRIG_INSERTED_T7_CH3     CTL1_ETSIC(4)                               /*!< TIMER7 CH3 event select */
N#define ADC2_EXTTRIG_INSERTED_T4_TRGO    CTL1_ETSIC(5)                               /*!< TIMER4 TRGO event select */
N#define ADC2_EXTTRIG_INSERTED_T4_CH3     CTL1_ETSIC(6)                               /*!< TIMER4 CH3 event select */
N
N/* adc_samptx register value */
N#define SAMPTX_SPT(regval)               (BITS(0,2) & ((uint32_t)(regval) << 0))     /*!< write value to ADC_SAMPTX_SPT bit field */
N#define ADC_SAMPLETIME_1POINT5           SAMPTX_SPT(0)                               /*!< 1.5 sampling cycles */
N#define ADC_SAMPLETIME_7POINT5           SAMPTX_SPT(1)                               /*!< 7.5 sampling cycles */
N#define ADC_SAMPLETIME_13POINT5          SAMPTX_SPT(2)                               /*!< 13.5 sampling cycles */
N#define ADC_SAMPLETIME_28POINT5          SAMPTX_SPT(3)                               /*!< 28.5 sampling cycles */
N#define ADC_SAMPLETIME_41POINT5          SAMPTX_SPT(4)                               /*!< 41.5 sampling cycles */
N#define ADC_SAMPLETIME_55POINT5          SAMPTX_SPT(5)                               /*!< 55.5 sampling cycles */
N#define ADC_SAMPLETIME_71POINT5          SAMPTX_SPT(6)                               /*!< 71.5 sampling cycles */
N#define ADC_SAMPLETIME_239POINT5         SAMPTX_SPT(7)                               /*!< 239.5 sampling cycles */
N
N/* adc_ioffx register value */
N#define IOFFX_IOFF(regval)               (BITS(0,11) & ((uint32_t)(regval) << 0))    /*!< write value to ADC_IOFFX_IOFF bit field */
N
N/* adc_wdht register value */
N#define WDHT_WDHT(regval)                (BITS(0,11) & ((uint32_t)(regval) << 0))    /*!< write value to ADC_WDHT_WDHT bit field */
N
N/* adc_wdlt register value */
N#define WDLT_WDLT(regval)                (BITS(0,11) & ((uint32_t)(regval) << 0))    /*!< write value to ADC_WDLT_WDLT bit field */
N
N/* adc_rsqx register value */
N#define RSQ0_RL(regval)                  (BITS(20,23) & ((uint32_t)(regval) << 20))  /*!< write value to ADC_RSQ0_RL bit field */
N
N/* adc_isq register value */
N#define ISQ_IL(regval)                   (BITS(20,21) & ((uint32_t)(regval) << 20))  /*!< write value to ADC_ISQ_IL bit field */
N
N/* ADC channel group definitions */
N#define ADC_REGULAR_CHANNEL              ((uint8_t)0x01U)                            /*!< adc regular channel group */
N#define ADC_INSERTED_CHANNEL             ((uint8_t)0x02U)                            /*!< adc inserted channel group */
N#define ADC_REGULAR_INSERTED_CHANNEL     ((uint8_t)0x03U)                            /*!< both regular and inserted channel group */
N
N#define ADC_CHANNEL_DISCON_DISABLE       ((uint8_t)0x04U)                            /*!< disable discontinuous mode of regular & inserted channel */
N
N/* ADC inserted channel definitions */
N#define ADC_INSERTED_CHANNEL_0           ((uint8_t)0x00U)                            /*!< adc inserted channel 0 */
N#define ADC_INSERTED_CHANNEL_1           ((uint8_t)0x01U)                            /*!< adc inserted channel 1 */
N#define ADC_INSERTED_CHANNEL_2           ((uint8_t)0x02U)                            /*!< adc inserted channel 2 */
N#define ADC_INSERTED_CHANNEL_3           ((uint8_t)0x03U)                            /*!< adc inserted channel 3 */
N
N/* ADC channel definitions */
N#define ADC_CHANNEL_0                    ((uint8_t)0x00U)                            /*!< ADC channel 0 */
N#define ADC_CHANNEL_1                    ((uint8_t)0x01U)                            /*!< ADC channel 1 */
N#define ADC_CHANNEL_2                    ((uint8_t)0x02U)                            /*!< ADC channel 2 */
N#define ADC_CHANNEL_3                    ((uint8_t)0x03U)                            /*!< ADC channel 3 */
N#define ADC_CHANNEL_4                    ((uint8_t)0x04U)                            /*!< ADC channel 4 */
N#define ADC_CHANNEL_5                    ((uint8_t)0x05U)                            /*!< ADC channel 5 */
N#define ADC_CHANNEL_6                    ((uint8_t)0x06U)                            /*!< ADC channel 6 */
N#define ADC_CHANNEL_7                    ((uint8_t)0x07U)                            /*!< ADC channel 7 */
N#define ADC_CHANNEL_8                    ((uint8_t)0x08U)                            /*!< ADC channel 8 */
N#define ADC_CHANNEL_9                    ((uint8_t)0x09U)                            /*!< ADC channel 9 */
N#define ADC_CHANNEL_10                   ((uint8_t)0x0AU)                            /*!< ADC channel 10 */
N#define ADC_CHANNEL_11                   ((uint8_t)0x0BU)                            /*!< ADC channel 11 */
N#define ADC_CHANNEL_12                   ((uint8_t)0x0CU)                            /*!< ADC channel 12 */
N#define ADC_CHANNEL_13                   ((uint8_t)0x0DU)                            /*!< ADC channel 13 */
N#define ADC_CHANNEL_14                   ((uint8_t)0x0EU)                            /*!< ADC channel 14 */
N#define ADC_CHANNEL_15                   ((uint8_t)0x0FU)                            /*!< ADC channel 15 */
N#define ADC_CHANNEL_16                   ((uint8_t)0x10U)                            /*!< ADC channel 16 */
N#define ADC_CHANNEL_17                   ((uint8_t)0x11U)                            /*!< ADC channel 17 */
N
N/* ADC interrupt */
N#define ADC_INT_WDE                      ADC_STAT_WDE                                /*!< analog watchdog event interrupt */
N#define ADC_INT_EOC                      ADC_STAT_EOC                                /*!< end of group conversion interrupt */
N#define ADC_INT_EOIC                     ADC_STAT_EOIC                               /*!< end of inserted group conversion interrupt */
N
N/* ADC interrupt flag */
N#define ADC_INT_FLAG_WDE                 ADC_STAT_WDE                                /*!< analog watchdog event interrupt flag */
N#define ADC_INT_FLAG_EOC                 ADC_STAT_EOC                                /*!< end of group conversion interrupt flag */
N#define ADC_INT_FLAG_EOIC                ADC_STAT_EOIC                               /*!< end of inserted group conversion interrupt flag */
N
N/* function declarations */
N/* initialization config */
N/* reset ADC */
Nvoid adc_deinit(uint32_t adc_periph);
N/* configure the ADC sync mode */
Nvoid adc_mode_config(uint32_t mode);
N/* enable or disable ADC special function */
Nvoid adc_special_function_config(uint32_t adc_periph, uint32_t function, ControlStatus newvalue);
N/* configure ADC data alignment */
Nvoid adc_data_alignment_config(uint32_t adc_periph, uint32_t data_alignment);
N/* enable ADC interface */
Nvoid adc_enable(uint32_t adc_periph);
N/* disable ADC interface */
Nvoid adc_disable(uint32_t adc_periph);
N/* ADC calibration and reset calibration */
Nvoid adc_calibration_enable(uint32_t adc_periph);
N/* enable the temperature sensor and Vrefint channel */
Nvoid adc_tempsensor_vrefint_enable(void);
N/* disable the temperature sensor and Vrefint channel */
Nvoid adc_tempsensor_vrefint_disable(void);
N
N/* DMA config */
N/* enable DMA request */
Nvoid adc_dma_mode_enable(uint32_t adc_periph);
N/* disable DMA request */
Nvoid adc_dma_mode_disable(uint32_t adc_periph);
N
N/* regular group and inserted group config */
N/* configure ADC discontinuous mode */
Nvoid adc_discontinuous_mode_config(uint32_t adc_periph, uint8_t adc_channel_group, uint8_t length);
N
N/* configure the length of regular channel group or inserted channel group */
Nvoid adc_channel_length_config(uint32_t adc_periph, uint8_t adc_channel_group, uint32_t length);
N/* configure ADC regular channel */
Nvoid adc_regular_channel_config(uint32_t adc_periph, uint8_t rank, uint8_t adc_channel, uint32_t sample_time);
N/* configure ADC inserted channel */
Nvoid adc_inserted_channel_config(uint32_t adc_periph, uint8_t rank, uint8_t adc_channel, uint32_t sample_time);
N/* configure ADC inserted channel offset */
Nvoid adc_inserted_channel_offset_config(uint32_t adc_periph, uint8_t inserted_channel, uint16_t offset);
N
N/* configure ADC external trigger source */
Nvoid adc_external_trigger_source_config(uint32_t adc_periph, uint8_t adc_channel_group, uint32_t external_trigger_source);
N/* configure ADC external trigger */
Nvoid adc_external_trigger_config(uint32_t adc_periph, uint8_t adc_channel_group, ControlStatus newvalue);
N/* enable ADC software trigger */
Nvoid adc_software_trigger_enable(uint32_t adc_periph, uint8_t adc_channel_group);
N
N/* get channel data */
N/* read ADC regular group data register */
Nuint16_t adc_regular_data_read(uint32_t adc_periph);
N/* read ADC inserted group data register */
Nuint16_t adc_inserted_data_read(uint32_t adc_periph, uint8_t inserted_channel);
N/* read the last ADC0 and ADC1 conversion result data in sync mode */
Nuint32_t adc_sync_mode_convert_value_read(void);
N
N/* watchdog config */
N/* configure ADC analog watchdog single channel */
Nvoid adc_watchdog_single_channel_enable(uint32_t adc_periph, uint8_t adc_channel);
N/* configure ADC analog watchdog group channel */
Nvoid adc_watchdog_group_channel_enable(uint32_t adc_periph, uint8_t adc_channel_group);
N/* disable ADC analog watchdog */
Nvoid adc_watchdog_disable(uint32_t adc_periph);
N/* configure ADC analog watchdog threshold */
Nvoid adc_watchdog_threshold_config(uint32_t adc_periph, uint16_t low_threshold, uint16_t high_threshold);
N
N/* interrupt & flag functions */
N/* get the ADC flag bits */
NFlagStatus adc_flag_get(uint32_t adc_periph, uint32_t adc_flag);
N/* clear the ADC flag bits */
Nvoid adc_flag_clear(uint32_t adc_periph, uint32_t adc_flag);
N/* get the bit state of ADCx software start conversion */
NFlagStatus adc_regular_software_startconv_flag_get(uint32_t adc_periph);
N/* get the bit state of ADCx software inserted channel start conversion */
NFlagStatus adc_inserted_software_startconv_flag_get(uint32_t adc_periph);
N/* get the ADC interrupt bits */
NFlagStatus adc_interrupt_flag_get(uint32_t adc_periph, uint32_t adc_interrupt);
N/* clear the ADC flag */
Nvoid adc_interrupt_flag_clear(uint32_t adc_periph, uint32_t adc_interrupt);
N/* enable ADC interrupt */
Nvoid adc_interrupt_enable(uint32_t adc_periph, uint32_t adc_interrupt);
N/* disable ADC interrupt */
Nvoid adc_interrupt_disable(uint32_t adc_periph, uint32_t adc_interrupt);
N
N#endif /* GD32F10x_ADC_H */
L 52 ".\User\gd32f10x_libopt.h" 2
N#include "gd32f10x_dac.h"
L 1 ".\Libraries\inc\gd32f10x_dac.h" 1
N/*!
N    \file    gd32f10x_dac.h
N    \brief   definitions for the DAC
N
N    \version 2014-12-26, V1.0.0, firmware for GD32F10x
N    \version 2017-06-20, V2.0.0, firmware for GD32F10x
N    \version 2018-07-31, V2.1.0, firmware for GD32F10x
N*/
N
N/*
N    Copyright (c) 2018, GigaDevice Semiconductor Inc.
N
N    All rights reserved.
N
N    Redistribution and use in source and binary forms, with or without modification, 
Nare permitted provided that the following conditions are met:
N
N    1. Redistributions of source code must retain the above copyright notice, this 
N       list of conditions and the following disclaimer.
N    2. Redistributions in binary form must reproduce the above copyright notice, 
N       this list of conditions and the following disclaimer in the documentation 
N       and/or other materials provided with the distribution.
N    3. Neither the name of the copyright holder nor the names of its contributors 
N       may be used to endorse or promote products derived from this software without 
N       specific prior written permission.
N
N    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
NAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
NWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
NIN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
NINDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
NNOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
NPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
NWHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
NARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
NOF SUCH DAMAGE.
N*/
N
N#ifndef GD32F10X_DAC_H
N#define GD32F10X_DAC_H
N
N#include "gd32f10x.h"
N
N/* DACx(x=0,1) definitions */
N#define DAC                     DAC_BASE
N#define DAC0                    0U
N#define DAC1                    1U
N
N/* registers definitions */
N#define DAC_CTL                 REG32(DAC + 0x00U)   /*!< DAC control register */
N#define DAC_SWT                 REG32(DAC + 0x04U)   /*!< DAC software trigger register */
N#define DAC0_R12DH              REG32(DAC + 0x08U)   /*!< DAC0 12-bit right-aligned data holding register */
N#define DAC0_L12DH              REG32(DAC + 0x0CU)   /*!< DAC0 12-bit left-aligned data holding register */
N#define DAC0_R8DH               REG32(DAC + 0x10U)   /*!< DAC0 8-bit right-aligned data holding register */
N#define DAC1_R12DH              REG32(DAC + 0x14U)   /*!< DAC1 12-bit right-aligned data holding register */
N#define DAC1_L12DH              REG32(DAC + 0x18U)   /*!< DAC1 12-bit left-aligned data holding register */
N#define DAC1_R8DH               REG32(DAC + 0x1CU)   /*!< DAC1 8-bit right-aligned data holding register */
N#define DACC_R12DH              REG32(DAC + 0x20U)   /*!< DAC concurrent mode 12-bit right-aligned data holding register */
N#define DACC_L12DH              REG32(DAC + 0x24U)   /*!< DAC concurrent mode 12-bit left-aligned data holding register */
N#define DACC_R8DH               REG32(DAC + 0x28U)   /*!< DAC concurrent mode 8-bit right-aligned data holding register */
N#define DAC0_DO                 REG32(DAC + 0x2CU)   /*!< DAC0 data output register */
N#define DAC1_DO                 REG32(DAC + 0x30U)   /*!< DAC1 data output register */
N
N/* bits definitions */
N/* DAC_CTL */
N#define DAC_CTL_DEN0            BIT(0)               /*!< DAC0 enable/disable bit */
N#define DAC_CTL_DBOFF0          BIT(1)               /*!< DAC0 output buffer turn on/off bit */
N#define DAC_CTL_DTEN0           BIT(2)               /*!< DAC0 trigger enable/disable bit */
N#define DAC_CTL_DTSEL0          BITS(3,5)            /*!< DAC0 trigger source selection enable/disable bits */
N#define DAC_CTL_DWM0            BITS(6,7)            /*!< DAC0 noise wave mode */
N#define DAC_CTL_DWBW0           BITS(8,11)           /*!< DAC0 noise wave bit width */
N#define DAC_CTL_DDMAEN0         BIT(12)              /*!< DAC0 DMA enable/disable bit */
N#define DAC_CTL_DEN1            BIT(16)              /*!< DAC1 enable/disable bit */ 
N#define DAC_CTL_DBOFF1          BIT(17)              /*!< DAC1 output buffer turn on/turn off bit */
N#define DAC_CTL_DTEN1           BIT(18)              /*!< DAC1 trigger enable/disable bit */
N#define DAC_CTL_DTSEL1          BITS(19,21)          /*!< DAC1 trigger source selection enable/disable bits */
N#define DAC_CTL_DWM1            BITS(22,23)          /*!< DAC1 noise wave mode */
N#define DAC_CTL_DWBW1           BITS(24,27)          /*!< DAC1 noise wave bit width */
N#define DAC_CTL_DDMAEN1         BIT(28)              /*!< DAC1 DMA enable/disable bit */
N
N/* DAC_SWT */
N#define DAC_SWT_SWTR0           BIT(0)               /*!< DAC0 software trigger bit, cleared by hardware */
N#define DAC_SWT_SWTR1           BIT(1)               /*!< DAC1 software trigger bit, cleared by hardware */
N
N/* DAC0_R12DH */
N#define DAC0_R12DH_DAC0_DH      BITS(0,11)           /*!< DAC0 12-bit right-aligned data bits */
N
N/* DAC0_L12DH */
N#define DAC0_L12DH_DAC0_DH      BITS(4,15)           /*!< DAC0 12-bit left-aligned data bits */
N
N/* DAC0_R8DH */
N#define DAC0_R8DH_DAC0_DH       BITS(0,7)            /*!< DAC0 8-bit right-aligned data bits */
N
N/* DAC1_R12DH */
N#define DAC1_R12DH_DAC1_DH      BITS(0,11)           /*!< DAC1 12-bit right-aligned data bits */
N
N/* DAC1_L12DH */
N#define DAC1_L12DH_DAC1_DH      BITS(4,15)           /*!< DAC1 12-bit left-aligned data bits */
N
N/* DAC1_R8DH */
N#define DAC1_R8DH_DAC1_DH       BITS(0,7)            /*!< DAC1 8-bit right-aligned data bits */
N
N/* DACC_R12DH */
N#define DACC_R12DH_DAC0_DH      BITS(0,11)           /*!< DAC concurrent mode DAC0 12-bit right-aligned data bits */
N#define DACC_R12DH_DAC1_DH      BITS(16,27)          /*!< DAC concurrent mode DAC1 12-bit right-aligned data bits */
N
N/* DACC_L12DH */
N#define DACC_L12DH_DAC0_DH      BITS(4,15)           /*!< DAC concurrent mode DAC0 12-bit left-aligned data bits */
N#define DACC_L12DH_DAC1_DH      BITS(20,31)          /*!< DAC concurrent mode DAC1 12-bit left-aligned data bits */
N
N/* DACC_R8DH */
N#define DACC_R8DH_DAC0_DH       BITS(0,7)            /*!< DAC concurrent mode DAC0 8-bit right-aligned data bits */
N#define DACC_R8DH_DAC1_DH       BITS(8,15)           /*!< DAC concurrent mode DAC1 8-bit right-aligned data bits */
N
N/* DAC0_DO */
N#define DAC0_DO_DAC0_DO         BITS(0,11)           /*!< DAC0 12-bit output data bits */
N
N/* DAC1_DO */
N#define DAC1_DO_DAC1_DO         BITS(0,11)           /*!< DAC1 12-bit output data bits */
N
N/* constants definitions */
N/* DAC trigger source */
N#define CTL_DTSEL(regval)       (BITS(3,5) & ((uint32_t)(regval) << 3))
N#define DAC_TRIGGER_T5_TRGO     CTL_DTSEL(0)         /*!< TIMER5 TRGO */
N#if (defined(GD32F10X_MD) || defined(GD32F10X_HD) || defined(GD32F10X_XD))
X#if (0L || 0L || 1L)
N#define DAC_TRIGGER_T7_TRGO     CTL_DTSEL(1)         /*!< TIMER7 TRGO */
N#elif defined(GD32F10X_CL)
S#define DAC_TRIGGER_T2_TRGO     CTL_DTSEL(1)         /*!< TIMER2 TRGO */
N#endif /* GD32F10X_MD and GD32F10X_HD and GD32F10X_XD */
N#define DAC_TRIGGER_T6_TRGO     CTL_DTSEL(2)         /*!< TIMER6 TRGO */
N#define DAC_TRIGGER_T4_TRGO     CTL_DTSEL(3)         /*!< TIMER4 TRGO */
N#define DAC_TRIGGER_T1_TRGO     CTL_DTSEL(4)         /*!< TIMER1 TRGO */
N#define DAC_TRIGGER_T3_TRGO     CTL_DTSEL(5)         /*!< TIMER3 TRGO */
N#define DAC_TRIGGER_EXTI_9      CTL_DTSEL(6)         /*!< EXTI interrupt line9 event */
N#define DAC_TRIGGER_SOFTWARE    CTL_DTSEL(7)         /*!< software trigger */
N
N/* DAC noise wave mode */
N#define CTL_DWM(regval)         (BITS(6,7) & ((uint32_t)(regval) << 6))
N#define DAC_WAVE_DISABLE        CTL_DWM(0)           /*!< wave disable */
N#define DAC_WAVE_MODE_LFSR      CTL_DWM(1)           /*!< LFSR noise mode */
N#define DAC_WAVE_MODE_TRIANGLE  CTL_DWM(2)           /*!< triangle noise mode */
N
N/* DAC noise wave bit width */
N#define DWBW(regval)            (BITS(8,11) & ((uint32_t)(regval) << 8))
N#define DAC_WAVE_BIT_WIDTH_1    DWBW(0)              /*!< bit width of the wave signal is 1 */
N#define DAC_WAVE_BIT_WIDTH_2    DWBW(1)              /*!< bit width of the wave signal is 2 */
N#define DAC_WAVE_BIT_WIDTH_3    DWBW(2)              /*!< bit width of the wave signal is 3 */
N#define DAC_WAVE_BIT_WIDTH_4    DWBW(3)              /*!< bit width of the wave signal is 4 */
N#define DAC_WAVE_BIT_WIDTH_5    DWBW(4)              /*!< bit width of the wave signal is 5 */
N#define DAC_WAVE_BIT_WIDTH_6    DWBW(5)              /*!< bit width of the wave signal is 6 */
N#define DAC_WAVE_BIT_WIDTH_7    DWBW(6)              /*!< bit width of the wave signal is 7 */
N#define DAC_WAVE_BIT_WIDTH_8    DWBW(7)              /*!< bit width of the wave signal is 8 */
N#define DAC_WAVE_BIT_WIDTH_9    DWBW(8)              /*!< bit width of the wave signal is 9 */
N#define DAC_WAVE_BIT_WIDTH_10   DWBW(9)              /*!< bit width of the wave signal is 10 */
N#define DAC_WAVE_BIT_WIDTH_11   DWBW(10)             /*!< bit width of the wave signal is 11 */
N#define DAC_WAVE_BIT_WIDTH_12   DWBW(11)             /*!< bit width of the wave signal is 12 */
N
N/* unmask LFSR bits in DAC LFSR noise mode */
N#define DAC_LFSR_BIT0           DAC_WAVE_BIT_WIDTH_1  /*!< unmask the LFSR bit0 */
N#define DAC_LFSR_BITS1_0        DAC_WAVE_BIT_WIDTH_2  /*!< unmask the LFSR bits[1:0] */
N#define DAC_LFSR_BITS2_0        DAC_WAVE_BIT_WIDTH_3  /*!< unmask the LFSR bits[2:0] */
N#define DAC_LFSR_BITS3_0        DAC_WAVE_BIT_WIDTH_4  /*!< unmask the LFSR bits[3:0] */
N#define DAC_LFSR_BITS4_0        DAC_WAVE_BIT_WIDTH_5  /*!< unmask the LFSR bits[4:0] */
N#define DAC_LFSR_BITS5_0        DAC_WAVE_BIT_WIDTH_6  /*!< unmask the LFSR bits[5:0] */
N#define DAC_LFSR_BITS6_0        DAC_WAVE_BIT_WIDTH_7  /*!< unmask the LFSR bits[6:0] */
N#define DAC_LFSR_BITS7_0        DAC_WAVE_BIT_WIDTH_8  /*!< unmask the LFSR bits[7:0] */
N#define DAC_LFSR_BITS8_0        DAC_WAVE_BIT_WIDTH_9  /*!< unmask the LFSR bits[8:0] */
N#define DAC_LFSR_BITS9_0        DAC_WAVE_BIT_WIDTH_10 /*!< unmask the LFSR bits[9:0] */
N#define DAC_LFSR_BITS10_0       DAC_WAVE_BIT_WIDTH_11 /*!< unmask the LFSR bits[10:0] */
N#define DAC_LFSR_BITS11_0       DAC_WAVE_BIT_WIDTH_12 /*!< unmask the LFSR bits[11:0] */
N
N/* DAC data alignment */
N#define DATA_ALIGN(regval)      (BITS(0,1) & ((uint32_t)(regval) << 0))
N#define DAC_ALIGN_12B_R         DATA_ALIGN(0)        /*!< data right 12b alignment */
N#define DAC_ALIGN_12B_L         DATA_ALIGN(1)        /*!< data left  12b alignment */
N#define DAC_ALIGN_8B_R          DATA_ALIGN(2)        /*!< data right  8b alignment */
N/* triangle amplitude in DAC triangle noise mode */
N#define DAC_TRIANGLE_AMPLITUDE_1    DAC_WAVE_BIT_WIDTH_1  /*!< triangle amplitude is 1 */
N#define DAC_TRIANGLE_AMPLITUDE_3    DAC_WAVE_BIT_WIDTH_2  /*!< triangle amplitude is 3 */
N#define DAC_TRIANGLE_AMPLITUDE_7    DAC_WAVE_BIT_WIDTH_3  /*!< triangle amplitude is 7 */
N#define DAC_TRIANGLE_AMPLITUDE_15   DAC_WAVE_BIT_WIDTH_4  /*!< triangle amplitude is 15 */
N#define DAC_TRIANGLE_AMPLITUDE_31   DAC_WAVE_BIT_WIDTH_5  /*!< triangle amplitude is 31 */
N#define DAC_TRIANGLE_AMPLITUDE_63   DAC_WAVE_BIT_WIDTH_6  /*!< triangle amplitude is 63 */
N#define DAC_TRIANGLE_AMPLITUDE_127  DAC_WAVE_BIT_WIDTH_7  /*!< triangle amplitude is 127 */
N#define DAC_TRIANGLE_AMPLITUDE_255  DAC_WAVE_BIT_WIDTH_8  /*!< triangle amplitude is 255 */
N#define DAC_TRIANGLE_AMPLITUDE_511  DAC_WAVE_BIT_WIDTH_9  /*!< triangle amplitude is 511 */
N#define DAC_TRIANGLE_AMPLITUDE_1023 DAC_WAVE_BIT_WIDTH_10 /*!< triangle amplitude is 1023 */
N#define DAC_TRIANGLE_AMPLITUDE_2047 DAC_WAVE_BIT_WIDTH_11 /*!< triangle amplitude is 2047 */
N#define DAC_TRIANGLE_AMPLITUDE_4095 DAC_WAVE_BIT_WIDTH_12 /*!< triangle amplitude is 4095 */
N
N/* function declarations */
N/* initialization functions */
N/* deinitialize DAC */
Nvoid dac_deinit(void);
N/* enable DAC */
Nvoid dac_enable(uint32_t dac_periph);
N/* disable DAC */
Nvoid dac_disable(uint32_t dac_periph);
N/* enable DAC DMA */
Nvoid dac_dma_enable(uint32_t dac_periph);
N/* disable DAC DMA */
Nvoid dac_dma_disable(uint32_t dac_periph); 
N/* enable DAC output buffer */
Nvoid dac_output_buffer_enable(uint32_t dac_periph);
N/* disable DAC output buffer */
Nvoid dac_output_buffer_disable(uint32_t dac_periph);
N/* get the last data output value */
Nuint16_t dac_output_value_get(uint32_t dac_periph);
N/* set DAC data holding register value */
Nvoid dac_data_set(uint32_t dac_periph, uint32_t dac_align, uint16_t data);
N
N/* DAC trigger configuration */
N/* enable DAC trigger */
Nvoid dac_trigger_enable(uint32_t dac_periph);
N/* disable DAC trigger */
Nvoid dac_trigger_disable(uint32_t dac_periph);
N/* configure DAC trigger source */
Nvoid dac_trigger_source_config(uint32_t dac_periph, uint32_t triggersource);
N/* enable DAC software trigger */
Nvoid dac_software_trigger_enable(uint32_t dac_periph);
N/* disable DAC software trigger */
Nvoid dac_software_trigger_disable(uint32_t dac_periph);
N
N/* DAC wave mode configuration */
N/* configure DAC wave mode */
Nvoid dac_wave_mode_config(uint32_t dac_periph, uint32_t wave_mode);
N/* configure DAC wave bit width */
Nvoid dac_wave_bit_width_config(uint32_t dac_periph, uint32_t bit_width);
N/* configure DAC LFSR noise mode */
Nvoid dac_lfsr_noise_config(uint32_t dac_periph, uint32_t unmask_bits);
N/* configure DAC triangle noise mode */
Nvoid dac_triangle_noise_config(uint32_t dac_periph, uint32_t amplitude);
N
N/* DAC concurrent mode configuration */
N/* enable DAC concurrent mode */
Nvoid dac_concurrent_enable(void);
N/* disable DAC concurrent mode */
Nvoid dac_concurrent_disable(void);
N/* enable DAC concurrent software trigger */
Nvoid dac_concurrent_software_trigger_enable(void);
N/* disable DAC concurrent software trigger */
Nvoid dac_concurrent_software_trigger_disable(void);
N/* enable DAC concurrent buffer function */
Nvoid dac_concurrent_output_buffer_enable(void);
N/* disable DAC concurrent buffer function */
Nvoid dac_concurrent_output_buffer_disable(void);
N/* set DAC concurrent mode data holding register value */
Nvoid dac_concurrent_data_set(uint32_t dac_align, uint16_t data0, uint16_t data1); 
N
N#endif /* GD32F10X_DAC_H */
L 53 ".\User\gd32f10x_libopt.h" 2
N#include "gd32f10x_fwdgt.h"
L 1 ".\Libraries\inc\gd32f10x_fwdgt.h" 1
N/*!
N    \file  gd32f10x_fwdgt.h
N    \brief definitions for the FWDGT
N    
N    \version 2014-12-26, V1.0.0, firmware for GD32F10x
N    \version 2017-06-20, V2.0.0, firmware for GD32F10x
N    \version 2018-07-31, V2.1.0, firmware for GD32F10x
N*/
N
N/*
N    Copyright (c) 2018, GigaDevice Semiconductor Inc.
N
N    All rights reserved.
N
N    Redistribution and use in source and binary forms, with or without modification, 
Nare permitted provided that the following conditions are met:
N
N    1. Redistributions of source code must retain the above copyright notice, this 
N       list of conditions and the following disclaimer.
N    2. Redistributions in binary form must reproduce the above copyright notice, 
N       this list of conditions and the following disclaimer in the documentation 
N       and/or other materials provided with the distribution.
N    3. Neither the name of the copyright holder nor the names of its contributors 
N       may be used to endorse or promote products derived from this software without 
N       specific prior written permission.
N
N    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
NAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
NWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
NIN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
NINDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
NNOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
NPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
NWHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
NARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
NOF SUCH DAMAGE.
N*/
N
N#ifndef GD32F10X_FWDGT_H
N#define GD32F10X_FWDGT_H
N
N#include "gd32f10x.h"
N
N/* FWDGT definitions */
N#define FWDGT                       FWDGT_BASE                                /*!< FWDGT base address */
N
N/* registers definitions */
N#define FWDGT_CTL                   REG32((FWDGT) + 0x00U)                    /*!< FWDGT control register */
N#define FWDGT_PSC                   REG32((FWDGT) + 0x04U)                    /*!< FWDGT prescaler register */
N#define FWDGT_RLD                   REG32((FWDGT) + 0x08U)                    /*!< FWDGT reload register */
N#define FWDGT_STAT                  REG32((FWDGT) + 0x0CU)                    /*!< FWDGT status register */
N
N/* bits definitions */
N/* FWDGT_CTL */
N#define FWDGT_CTL_CMD               BITS(0,15)                                /*!< FWDGT command value */
N
N/* FWDGT_PSC */
N#define FWDGT_PSC_PSC               BITS(0,2)                                 /*!< FWDGT prescaler divider value */
N
N/* FWDGT_RLD */
N#define FWDGT_RLD_RLD               BITS(0,11)                                /*!< FWDGT counter reload value */
N
N/* FWDGT_STAT */
N#define FWDGT_STAT_PUD              BIT(0)                                    /*!< FWDGT prescaler divider value update */
N#define FWDGT_STAT_RUD              BIT(1)                                    /*!< FWDGT counter reload value update */
N
N/* constants definitions */
N/* psc register value */
N#define PSC_PSC(regval)             (BITS(0,2) & ((uint32_t)(regval) << 0))
N#define FWDGT_PSC_DIV4              ((uint8_t)PSC_PSC(0))                     /*!< FWDGT prescaler set to 4 */
N#define FWDGT_PSC_DIV8              ((uint8_t)PSC_PSC(1))                     /*!< FWDGT prescaler set to 8 */
N#define FWDGT_PSC_DIV16             ((uint8_t)PSC_PSC(2))                     /*!< FWDGT prescaler set to 16 */
N#define FWDGT_PSC_DIV32             ((uint8_t)PSC_PSC(3))                     /*!< FWDGT prescaler set to 32 */
N#define FWDGT_PSC_DIV64             ((uint8_t)PSC_PSC(4))                     /*!< FWDGT prescaler set to 64 */
N#define FWDGT_PSC_DIV128            ((uint8_t)PSC_PSC(5))                     /*!< FWDGT prescaler set to 128 */
N#define FWDGT_PSC_DIV256            ((uint8_t)PSC_PSC(6))                     /*!< FWDGT prescaler set to 256 */
N
N/* control value */
N#define FWDGT_WRITEACCESS_ENABLE    ((uint16_t)0x5555U)                       /*!< FWDGT_CTL bits write access enable value */
N#define FWDGT_WRITEACCESS_DISABLE   ((uint16_t)0x0000U)                       /*!< FWDGT_CTL bits write access disable value */
N#define FWDGT_KEY_RELOAD            ((uint16_t)0xAAAAU)                       /*!< FWDGT_CTL bits fwdgt counter reload value */
N#define FWDGT_KEY_ENABLE            ((uint16_t)0xCCCCU)                       /*!< FWDGT_CTL bits fwdgt counter enable value */
N
N/* FWDGT timeout value */
N#define FWDGT_PSC_TIMEOUT           ((uint32_t)0x000FFFFFU)                   /*!< FWDGT_PSC register write operation state flag timeout */
N#define FWDGT_RLD_TIMEOUT           ((uint32_t)0x000FFFFFU)                   /*!< FWDGT_RLD register write operation state flag timeout */
N
N/* FWDGT flag definitions */
N#define FWDGT_FLAG_PUD              FWDGT_STAT_PUD                            /*!< FWDGT prescaler divider value update flag */
N#define FWDGT_FLAG_RUD              FWDGT_STAT_RUD                            /*!< FWDGT counter reload value update flag */
N
N/* function declarations */
N/* enable write access to FWDGT_PSC and FWDGT_RLD */
Nvoid fwdgt_write_enable(void);
N/* disable write access to FWDGT_PSC and FWDGT_RLD */
Nvoid fwdgt_write_disable(void);
N/* start the free watchdog timer counter */
Nvoid fwdgt_enable(void);
N
N/* reload the counter of FWDGT */
Nvoid fwdgt_counter_reload(void);
N/* configure counter reload value, and prescaler divider value */
NErrStatus fwdgt_config(uint16_t reload_value, uint8_t prescaler_div);
N
N/* get flag state of FWDGT */
NFlagStatus fwdgt_flag_get(uint16_t flag);
N
N#endif /* GD32F10X_FWDGT_H */
L 54 ".\User\gd32f10x_libopt.h" 2
N#include "gd32f10x_wwdgt.h"
L 1 ".\Libraries\inc\gd32f10x_wwdgt.h" 1
N/*!
N    \file  gd32f10x_wwdgt.h
N    \brief definitions for the WWDGT 
N    
N    \version 2014-12-26, V1.0.0, firmware for GD32F10x
N    \version 2017-06-20, V2.0.0, firmware for GD32F10x
N    \version 2018-07-31, V2.1.0, firmware for GD32F10x
N*/
N
N/*
N    Copyright (c) 2018, GigaDevice Semiconductor Inc.
N
N    All rights reserved.
N
N    Redistribution and use in source and binary forms, with or without modification, 
Nare permitted provided that the following conditions are met:
N
N    1. Redistributions of source code must retain the above copyright notice, this 
N       list of conditions and the following disclaimer.
N    2. Redistributions in binary form must reproduce the above copyright notice, 
N       this list of conditions and the following disclaimer in the documentation 
N       and/or other materials provided with the distribution.
N    3. Neither the name of the copyright holder nor the names of its contributors 
N       may be used to endorse or promote products derived from this software without 
N       specific prior written permission.
N
N    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
NAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
NWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
NIN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
NINDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
NNOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
NPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
NWHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
NARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
NOF SUCH DAMAGE.
N*/
N
N#ifndef GD32F10X_WWDGT_H
N#define GD32F10X_WWDGT_H
N
N#include "gd32f10x.h"
N
N/* WWDGT definitions */
N#define WWDGT                       WWDGT_BASE                                /*!< WWDGT base address */
N
N/* registers definitions */
N#define WWDGT_CTL                   REG32((WWDGT) + 0x00U)                    /*!< WWDGT control register */
N#define WWDGT_CFG                   REG32((WWDGT) + 0x04U)                    /*!< WWDGT configuration register */
N#define WWDGT_STAT                  REG32((WWDGT) + 0x08U)                    /*!< WWDGT status register */
N
N/* bits definitions */
N/* WWDGT_CTL */
N#define WWDGT_CTL_CNT               BITS(0,6)                                 /*!< WWDGT counter value */
N#define WWDGT_CTL_WDGTEN            BIT(7)                                    /*!< WWDGT counter enable */
N
N/* WWDGT_CFG */
N#define WWDGT_CFG_WIN               BITS(0,6)                                 /*!< WWDGT counter window value */
N#define WWDGT_CFG_PSC               BITS(7,8)                                 /*!< WWDGT prescaler divider value */
N#define WWDGT_CFG_EWIE              BIT(9)                                    /*!< early wakeup interrupt enable */
N
N/* WWDGT_STAT */
N#define WWDGT_STAT_EWIF             BIT(0)                                    /*!< early wakeup interrupt flag */
N
N/* constants definitions */
N#define CFG_PSC(regval)             (BITS(7,8) & ((uint32_t)(regval) << 7))   /*!< write value to WWDGT_CFG_PSC bit field */
N#define WWDGT_CFG_PSC_DIV1          CFG_PSC(0)                                /*!< the time base of WWDGT = (PCLK1/4096)/1 */
N#define WWDGT_CFG_PSC_DIV2          CFG_PSC(1)                                /*!< the time base of WWDGT = (PCLK1/4096)/2 */
N#define WWDGT_CFG_PSC_DIV4          CFG_PSC(2)                                /*!< the time base of WWDGT = (PCLK1/4096)/4 */
N#define WWDGT_CFG_PSC_DIV8          CFG_PSC(3)                                /*!< the time base of WWDGT = (PCLK1/4096)/8 */
N
N/* function declarations */
N/* reset the window watchdog timer configuration */
Nvoid wwdgt_deinit(void);
N/* start the window watchdog timer counter */
Nvoid wwdgt_enable(void);
N
N/* configure the window watchdog timer counter value */
Nvoid wwdgt_counter_update(uint16_t counter_value);
N/* configure counter value, window value, and prescaler divider value */
Nvoid wwdgt_config(uint16_t counter, uint16_t window, uint32_t prescaler);
N
N/* enable early wakeup interrupt of WWDGT */
Nvoid wwdgt_interrupt_enable(void);
N/* check early wakeup interrupt state of WWDGT */
NFlagStatus wwdgt_flag_get(void);
N/* clear early wakeup interrupt state of WWDGT */
Nvoid wwdgt_flag_clear(void);
N
N#endif /* GD32F10X_WWDGT_H */
L 55 ".\User\gd32f10x_libopt.h" 2
N#include "gd32f10x_rtc.h"
L 1 ".\Libraries\inc\gd32f10x_rtc.h" 1
N/*!
N    \file  gd32f10x_rtc.h
N    \brief definitions for the RTC
N    
N    \version 2014-12-26, V1.0.0, firmware for GD32F10x
N    \version 2017-06-20, V2.0.0, firmware for GD32F10x
N    \version 2018-07-31, V2.1.0, firmware for GD32F10x
N*/
N
N/*
N    Copyright (c) 2018, GigaDevice Semiconductor Inc.
N
N    All rights reserved.
N
N    Redistribution and use in source and binary forms, with or without modification, 
Nare permitted provided that the following conditions are met:
N
N    1. Redistributions of source code must retain the above copyright notice, this 
N       list of conditions and the following disclaimer.
N    2. Redistributions in binary form must reproduce the above copyright notice, 
N       this list of conditions and the following disclaimer in the documentation 
N       and/or other materials provided with the distribution.
N    3. Neither the name of the copyright holder nor the names of its contributors 
N       may be used to endorse or promote products derived from this software without 
N       specific prior written permission.
N
N    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
NAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
NWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
NIN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
NINDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
NNOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
NPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
NWHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
NARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
NOF SUCH DAMAGE.
N*/
N
N#ifndef GD32F10X_RTC_H
N#define GD32F10X_RTC_H
N
N#include "gd32f10x.h"
N
N/* RTC definitions */
N#define RTC                          RTC_BASE
N
N/* registers definitions */
N#define RTC_INTEN                    REG32(RTC + 0x00U)      /*!< interrupt enable register */
N#define RTC_CTL                      REG32(RTC + 0x04U)      /*!< control register */
N#define RTC_PSCH                     REG32(RTC + 0x08U)      /*!< prescaler high register */
N#define RTC_PSCL                     REG32(RTC + 0x0CU)      /*!< prescaler low register */
N#define RTC_DIVH                     REG32(RTC + 0x10U)      /*!< divider high register */
N#define RTC_DIVL                     REG32(RTC + 0x14U)      /*!< divider low register */
N#define RTC_CNTH                     REG32(RTC + 0x18U)      /*!< counter high register */
N#define RTC_CNTL                     REG32(RTC + 0x1CU)      /*!< counter low register */
N#define RTC_ALRMH                    REG32(RTC + 0x20U)      /*!< alarm high register */
N#define RTC_ALRML                    REG32(RTC + 0x24U)      /*!< alarm low register */
N
N/* bits definitions */
N/* RTC_INTEN */
N#define RTC_INTEN_SCIE               BIT(0)                   /*!< second interrupt enable */
N#define RTC_INTEN_ALRMIE             BIT(1)                   /*!< alarm interrupt enable */
N#define RTC_INTEN_OVIE               BIT(2)                   /*!< overflow interrupt enable */
N
N/* RTC_CTL */
N#define RTC_CTL_SCIF                 BIT(0)                   /*!< second interrupt flag */
N#define RTC_CTL_ALRMIF               BIT(1)                   /*!< alarm interrupt flag */
N#define RTC_CTL_OVIF                 BIT(2)                   /*!< overflow interrupt flag */
N#define RTC_CTL_RSYNF                BIT(3)                   /*!< registers synchronized flag */
N#define RTC_CTL_CMF                  BIT(4)                   /*!< configuration mode flag */
N#define RTC_CTL_LWOFF                BIT(5)                   /*!< last write operation finished flag */
N
N/* RTC_PSCH */
N#define RTC_PSCH_PSC                 BITS(0,3)                /*!< prescaler high value */
N
N/* RTC_PSCL */
N#define RTC_PSCL_PSC                 BITS(0,15)               /*!< prescaler low value */
N
N/* RTC_DIVH */
N#define RTC_DIVH_DIV                 BITS(0,3)                /*!< divider high value */
N
N/* RTC_DIVL */
N#define RTC_DIVL_DIV                 BITS(0,15)               /*!< divider low value */
N
N/* RTC_CNTH */
N#define RTC_CNTH_CNT                 BITS(0,15)               /*!< counter high value */
N
N/* RTC_CNTL */
N#define RTC_CNTL_CNT                 BITS(0,15)               /*!< counter low value */
N
N/* RTC_ALRMH */
N#define RTC_ALRMH_ALRM               BITS(0,15)               /*!< alarm high value */
N
N/* RTC_ALRML */
N#define RTC_ALRML_ALRM               BITS(0,15)               /*!< alarm low value */
N
N/* constants definitions */
N/* RTC interrupt enable or disable definitions */
N#define RTC_INT_SECOND               RTC_INTEN_SCIE           /*!< second interrupt enable */
N#define RTC_INT_ALARM                RTC_INTEN_ALRMIE         /*!< alarm interrupt enable */
N#define RTC_INT_OVERFLOW             RTC_INTEN_OVIE           /*!< overflow interrupt enable */
N
N/* RTC interrupt flag definitions */
N#define RTC_INT_FLAG_SECOND          RTC_CTL_SCIF             /*!< second interrupt flag */
N#define RTC_INT_FLAG_ALARM           RTC_CTL_ALRMIF           /*!< alarm interrupt flag */
N#define RTC_INT_FLAG_OVERFLOW        RTC_CTL_OVIF             /*!< overflow interrupt flag */
N
N/* RTC flag definitions */
N#define RTC_FLAG_SECOND              RTC_CTL_SCIF             /*!< second interrupt flag */
N#define RTC_FLAG_ALARM               RTC_CTL_ALRMIF           /*!< alarm interrupt flag */
N#define RTC_FLAG_OVERFLOW            RTC_CTL_OVIF             /*!< overflow interrupt flag */
N#define RTC_FLAG_RSYN                RTC_CTL_RSYNF            /*!< registers synchronized flag */
N#define RTC_FLAG_LWOF                RTC_CTL_LWOFF            /*!< last write operation finished flag */
N
N/* function declarations */
N/* initialization functions */
N/* enter RTC configuration mode */
Nvoid rtc_configuration_mode_enter(void);
N/* exit RTC configuration mode */
Nvoid rtc_configuration_mode_exit(void);
N/* set RTC counter value */
Nvoid rtc_counter_set(uint32_t cnt);
N/* set RTC prescaler value */
Nvoid rtc_prescaler_set(uint32_t psc);
N
N/* operation functions */
N/* wait RTC last write operation finished flag set */
Nvoid rtc_lwoff_wait(void);
N/* wait RTC registers synchronized flag set */
Nvoid rtc_register_sync_wait(void);
N/* set RTC alarm value */
Nvoid rtc_alarm_config(uint32_t alarm);
N/* get RTC counter value */
Nuint32_t rtc_counter_get(void);
N/* get RTC divider value */
Nuint32_t rtc_divider_get(void);
N
N/* flag & interrupt functions */
N/* get RTC flag status */
NFlagStatus rtc_flag_get(uint32_t flag);
N/* clear RTC flag status */
Nvoid rtc_flag_clear(uint32_t flag);
N/* get RTC interrupt flag status */
NFlagStatus rtc_interrupt_flag_get(uint32_t flag);
N/* clear RTC interrupt flag status */
Nvoid rtc_interrupt_flag_clear(uint32_t flag);
N/* enable RTC interrupt */
Nvoid rtc_interrupt_enable(uint32_t interrupt);
N/* disable RTC interrupt */
Nvoid rtc_interrupt_disable(uint32_t interrupt);
N
N#endif /* GD32F10X_RTC_H */
L 56 ".\User\gd32f10x_libopt.h" 2
N#include "gd32f10x_timer.h"
L 1 ".\Libraries\inc\gd32f10x_timer.h" 1
N/*!
N    \file    gd32f10x_timer.h
N    \brief   definitions for the TIMER
N
N    \version 2014-12-26, V1.0.0, firmware for GD32F10x
N    \version 2017-06-20, V2.0.0, firmware for GD32F10x
N    \version 2018-07-31, V2.1.0, firmware for GD32F10x
N*/
N
N/*
N    Copyright (c) 2018, GigaDevice Semiconductor Inc.
N
N    All rights reserved.
N
N    Redistribution and use in source and binary forms, with or without modification, 
Nare permitted provided that the following conditions are met:
N
N    1. Redistributions of source code must retain the above copyright notice, this 
N       list of conditions and the following disclaimer.
N    2. Redistributions in binary form must reproduce the above copyright notice, 
N       this list of conditions and the following disclaimer in the documentation 
N       and/or other materials provided with the distribution.
N    3. Neither the name of the copyright holder nor the names of its contributors 
N       may be used to endorse or promote products derived from this software without 
N       specific prior written permission.
N
N    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
NAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
NWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
NIN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
NINDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
NNOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
NPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
NWHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
NARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
NOF SUCH DAMAGE.
N*/
N
N#ifndef GD32F10X_TIMER_H
N#define GD32F10X_TIMER_H
N
N#include "gd32f10x.h"
N
N/* TIMERx(x=0..13) definitions */
N#define TIMER0                           (TIMER_BASE + 0x00012C00U)
N#define TIMER1                           (TIMER_BASE + 0x00000000U)
N#define TIMER2                           (TIMER_BASE + 0x00000400U)
N#define TIMER3                           (TIMER_BASE + 0x00000800U)
N#define TIMER4                           (TIMER_BASE + 0x00000C00U)
N#define TIMER5                           (TIMER_BASE + 0x00001000U)
N#define TIMER6                           (TIMER_BASE + 0x00001400U)
N#define TIMER7                           (TIMER_BASE + 0x00013400U)
N#define TIMER8                           (TIMER_BASE + 0x00014C00U)
N#define TIMER9                           (TIMER_BASE + 0x00015000U)
N#define TIMER10                          (TIMER_BASE + 0x00015400U)
N#define TIMER11                          (TIMER_BASE + 0x00001800U)
N#define TIMER12                          (TIMER_BASE + 0x00001C00U)
N#define TIMER13                          (TIMER_BASE + 0x00002000U)
N
N/* registers definitions */
N#define TIMER_CTL0(timerx)               REG32((timerx) + 0x00U)           /*!< TIMER control register 0 */
N#define TIMER_CTL1(timerx)               REG32((timerx) + 0x04U)           /*!< TIMER control register 1 */
N#define TIMER_SMCFG(timerx)              REG32((timerx) + 0x08U)           /*!< TIMER slave mode configuration register */
N#define TIMER_DMAINTEN(timerx)           REG32((timerx) + 0x0CU)           /*!< TIMER DMA and interrupt enable register */
N#define TIMER_INTF(timerx)               REG32((timerx) + 0x10U)           /*!< TIMER interrupt flag register */
N#define TIMER_SWEVG(timerx)              REG32((timerx) + 0x14U)           /*!< TIMER software event generation register */
N#define TIMER_CHCTL0(timerx)             REG32((timerx) + 0x18U)           /*!< TIMER channel control register 0 */
N#define TIMER_CHCTL1(timerx)             REG32((timerx) + 0x1CU)           /*!< TIMER channel control register 1 */
N#define TIMER_CHCTL2(timerx)             REG32((timerx) + 0x20U)           /*!< TIMER channel control register 2 */
N#define TIMER_CNT(timerx)                REG32((timerx) + 0x24U)           /*!< TIMER counter register */
N#define TIMER_PSC(timerx)                REG32((timerx) + 0x28U)           /*!< TIMER prescaler register */
N#define TIMER_CAR(timerx)                REG32((timerx) + 0x2CU)           /*!< TIMER counter auto reload register */
N#define TIMER_CREP(timerx)               REG32((timerx) + 0x30U)           /*!< TIMER counter repetition register */
N#define TIMER_CH0CV(timerx)              REG32((timerx) + 0x34U)           /*!< TIMER channel 0 capture/compare value register */
N#define TIMER_CH1CV(timerx)              REG32((timerx) + 0x38U)           /*!< TIMER channel 1 capture/compare value register */
N#define TIMER_CH2CV(timerx)              REG32((timerx) + 0x3CU)           /*!< TIMER channel 2 capture/compare value register */
N#define TIMER_CH3CV(timerx)              REG32((timerx) + 0x40U)           /*!< TIMER channel 3 capture/compare value register */
N#define TIMER_CCHP(timerx)               REG32((timerx) + 0x44U)           /*!< TIMER channel complementary protection register */
N#define TIMER_DMACFG(timerx)             REG32((timerx) + 0x48U)           /*!< TIMER DMA configuration register */
N#define TIMER_DMATB(timerx)              REG32((timerx) + 0x4CU)           /*!< TIMER DMA transfer buffer register */
N
N/* bits definitions */
N/* TIMER_CTL0 */
N#define TIMER_CTL0_CEN                   BIT(0)              /*!< TIMER counter enable */
N#define TIMER_CTL0_UPDIS                 BIT(1)              /*!< update disable */
N#define TIMER_CTL0_UPS                   BIT(2)              /*!< update source */
N#define TIMER_CTL0_SPM                   BIT(3)              /*!< single pulse mode */
N#define TIMER_CTL0_DIR                   BIT(4)              /*!< timer counter direction */
N#define TIMER_CTL0_CAM                   BITS(5,6)           /*!< center-aligned mode selection */
N#define TIMER_CTL0_ARSE                  BIT(7)              /*!< auto-reload shadow enable */
N#define TIMER_CTL0_CKDIV                 BITS(8,9)           /*!< clock division */
N
N/* TIMER_CTL1 */
N#define TIMER_CTL1_CCSE                  BIT(0)              /*!< commutation control shadow enable */
N#define TIMER_CTL1_CCUC                  BIT(2)              /*!< commutation control shadow register update control */
N#define TIMER_CTL1_DMAS                  BIT(3)              /*!< DMA request source selection */
N#define TIMER_CTL1_MMC                   BITS(4,6)           /*!< master mode control */
N#define TIMER_CTL1_TI0S                  BIT(7)              /*!< channel 0 trigger input selection(hall mode selection) */
N#define TIMER_CTL1_ISO0                  BIT(8)              /*!< idle state of channel 0 output */
N#define TIMER_CTL1_ISO0N                 BIT(9)              /*!< idle state of channel 0 complementary output */
N#define TIMER_CTL1_ISO1                  BIT(10)             /*!< idle state of channel 1 output */
N#define TIMER_CTL1_ISO1N                 BIT(11)             /*!< idle state of channel 1 complementary output */
N#define TIMER_CTL1_ISO2                  BIT(12)             /*!< idle state of channel 2 output */
N#define TIMER_CTL1_ISO2N                 BIT(13)             /*!< idle state of channel 2 complementary output */
N#define TIMER_CTL1_ISO3                  BIT(14)             /*!< idle state of channel 3 output */
N
N/* TIMER_SMCFG */
N#define TIMER_SMCFG_SMC                  BITS(0,2)           /*!< slave mode control */
N#define TIMER_SMCFG_TRGS                 BITS(4,6)           /*!< trigger selection */
N#define TIMER_SMCFG_MSM                  BIT(7)              /*!< master-slave mode */
N#define TIMER_SMCFG_ETFC                 BITS(8,11)          /*!< external trigger filter control */
N#define TIMER_SMCFG_ETPSC                BITS(12,13)         /*!< external trigger prescaler */
N#define TIMER_SMCFG_SMC1                 BIT(14)             /*!< part of SMC for enable external clock mode 1 */
N#define TIMER_SMCFG_ETP                  BIT(15)             /*!< external trigger polarity */
N 
N/* TIMER_DMAINTEN */
N#define TIMER_DMAINTEN_UPIE              BIT(0)              /*!< update interrupt enable */
N#define TIMER_DMAINTEN_CH0IE             BIT(1)              /*!< channel 0 capture/compare interrupt enable */
N#define TIMER_DMAINTEN_CH1IE             BIT(2)              /*!< channel 1 capture/compare interrupt enable */
N#define TIMER_DMAINTEN_CH2IE             BIT(3)              /*!< channel 2 capture/compare interrupt enable */
N#define TIMER_DMAINTEN_CH3IE             BIT(4)              /*!< channel 3 capture/compare interrupt enable */
N#define TIMER_DMAINTEN_CMTIE             BIT(5)              /*!< commutation interrupt request enable */
N#define TIMER_DMAINTEN_TRGIE             BIT(6)              /*!< trigger interrupt enable */
N#define TIMER_DMAINTEN_BRKIE             BIT(7)              /*!< break interrupt enable */
N#define TIMER_DMAINTEN_UPDEN             BIT(8)              /*!< update DMA request enable */
N#define TIMER_DMAINTEN_CH0DEN            BIT(9)              /*!< channel 0 capture/compare DMA request enable */
N#define TIMER_DMAINTEN_CH1DEN            BIT(10)             /*!< channel 1 capture/compare DMA request enable */
N#define TIMER_DMAINTEN_CH2DEN            BIT(11)             /*!< channel 2 capture/compare DMA request enable */
N#define TIMER_DMAINTEN_CH3DEN            BIT(12)             /*!< channel 3 capture/compare DMA request enable */
N#define TIMER_DMAINTEN_CMTDEN            BIT(13)             /*!< commutation DMA request enable */
N#define TIMER_DMAINTEN_TRGDEN            BIT(14)             /*!< trigger DMA request enable */
N
N/* TIMER_INTF */
N#define TIMER_INTF_UPIF                  BIT(0)              /*!< update interrupt flag */
N#define TIMER_INTF_CH0IF                 BIT(1)              /*!< channel 0 capture/compare interrupt flag */
N#define TIMER_INTF_CH1IF                 BIT(2)              /*!< channel 1 capture/compare interrupt flag */
N#define TIMER_INTF_CH2IF                 BIT(3)              /*!< channel 2 capture/compare interrupt flag */
N#define TIMER_INTF_CH3IF                 BIT(4)              /*!< channel 3 capture/compare interrupt flag */
N#define TIMER_INTF_CMTIF                 BIT(5)              /*!< channel commutation interrupt flag */
N#define TIMER_INTF_TRGIF                 BIT(6)              /*!< trigger interrupt flag */
N#define TIMER_INTF_BRKIF                 BIT(7)              /*!< break interrupt flag */
N#define TIMER_INTF_CH0OF                 BIT(9)              /*!< channel 0 over capture flag */
N#define TIMER_INTF_CH1OF                 BIT(10)             /*!< channel 1 over capture flag */
N#define TIMER_INTF_CH2OF                 BIT(11)             /*!< channel 2 over capture flag */
N#define TIMER_INTF_CH3OF                 BIT(12)             /*!< channel 3 over capture flag */
N
N/* TIMER_SWEVG */
N#define TIMER_SWEVG_UPG                  BIT(0)              /*!< update event generate */
N#define TIMER_SWEVG_CH0G                 BIT(1)              /*!< channel 0 capture or compare event generation */
N#define TIMER_SWEVG_CH1G                 BIT(2)              /*!< channel 1 capture or compare event generation */
N#define TIMER_SWEVG_CH2G                 BIT(3)              /*!< channel 2 capture or compare event generation */
N#define TIMER_SWEVG_CH3G                 BIT(4)              /*!< channel 3 capture or compare event generation */
N#define TIMER_SWEVG_CMTG                 BIT(5)              /*!< channel commutation event generation */
N#define TIMER_SWEVG_TRGG                 BIT(6)              /*!< trigger event generation */
N#define TIMER_SWEVG_BRKG                 BIT(7)              /*!< break event generation */
N
N/* TIMER_CHCTL0 */
N/* output compare mode */
N#define TIMER_CHCTL0_CH0MS               BITS(0,1)           /*!< channel 0 mode selection */
N#define TIMER_CHCTL0_CH0COMFEN           BIT(2)              /*!< channel 0 output compare fast enable */
N#define TIMER_CHCTL0_CH0COMSEN           BIT(3)              /*!< channel 0 output compare shadow enable */
N#define TIMER_CHCTL0_CH0COMCTL           BITS(4,6)           /*!< channel 0 output compare control  */
N#define TIMER_CHCTL0_CH0COMCEN           BIT(7)              /*!< channel 0 output compare clear enable */
N#define TIMER_CHCTL0_CH1MS               BITS(8,9)           /*!< channel 1 mode selection */
N#define TIMER_CHCTL0_CH1COMFEN           BIT(10)             /*!< channel 1 output compare fast enable */
N#define TIMER_CHCTL0_CH1COMSEN           BIT(11)             /*!< channel 1 output compare shadow enable */
N#define TIMER_CHCTL0_CH1COMCTL           BITS(12,14)         /*!< channel 1 output compare control  */
N#define TIMER_CHCTL0_CH1COMCEN           BIT(15)             /*!< channel 1 output compare clear enable */
N/* input capture mode */
N#define TIMER_CHCTL0_CH0CAPPSC           BITS(2,3)           /*!< channel 0 input capture prescaler */
N#define TIMER_CHCTL0_CH0CAPFLT           BITS(4,7)           /*!< channel 0 input capture filter control */
N#define TIMER_CHCTL0_CH1CAPPSC           BITS(10,11)         /*!< channel 1 input capture prescaler */
N#define TIMER_CHCTL0_CH1CAPFLT           BITS(12,15)         /*!< channel 1 input capture filter control */
N
N/* TIMER_CHCTL1 */
N/* output compare mode */
N#define TIMER_CHCTL1_CH2MS               BITS(0,1)           /*!< channel 2 mode selection */
N#define TIMER_CHCTL1_CH2COMFEN           BIT(2)              /*!< channel 2 output compare fast enable */
N#define TIMER_CHCTL1_CH2COMSEN           BIT(3)              /*!< channel 2 output compare shadow enable */
N#define TIMER_CHCTL1_CH2COMCTL           BITS(4,6)           /*!< channel 2 output compare control */
N#define TIMER_CHCTL1_CH2COMCEN           BIT(7)              /*!< channel 2 output compare clear enable */
N#define TIMER_CHCTL1_CH3MS               BITS(8,9)           /*!< channel 3 mode selection */
N#define TIMER_CHCTL1_CH3COMFEN           BIT(10)             /*!< channel 3 output compare fast enable */
N#define TIMER_CHCTL1_CH3COMSEN           BIT(11)             /*!< channel 3 output compare shadow enable */
N#define TIMER_CHCTL1_CH3COMCTL           BITS(12,14)         /*!< channel 3 output compare control */
N#define TIMER_CHCTL1_CH3COMCEN           BIT(15)             /*!< channel 3 output compare clear enable */
N/* input capture mode */
N#define TIMER_CHCTL1_CH2CAPPSC           BITS(2,3)           /*!< channel 2 input capture prescaler */
N#define TIMER_CHCTL1_CH2CAPFLT           BITS(4,7)           /*!< channel 2 input capture filter control */
N#define TIMER_CHCTL1_CH3CAPPSC           BITS(10,11)         /*!< channel 3 input capture prescaler */
N#define TIMER_CHCTL1_CH3CAPFLT           BITS(12,15)         /*!< channel 3 input capture filter control */
N
N/* TIMER_CHCTL2 */
N#define TIMER_CHCTL2_CH0EN               BIT(0)              /*!< channel 0 capture/compare function enable */
N#define TIMER_CHCTL2_CH0P                BIT(1)              /*!< channel 0 capture/compare function polarity */
N#define TIMER_CHCTL2_CH0NEN              BIT(2)              /*!< channel 0 complementary output enable */
N#define TIMER_CHCTL2_CH0NP               BIT(3)              /*!< channel 0 complementary output polarity */
N#define TIMER_CHCTL2_CH1EN               BIT(4)              /*!< channel 1 capture/compare function enable  */
N#define TIMER_CHCTL2_CH1P                BIT(5)              /*!< channel 1 capture/compare function polarity */
N#define TIMER_CHCTL2_CH1NEN              BIT(6)              /*!< channel 1 complementary output enable */
N#define TIMER_CHCTL2_CH1NP               BIT(7)              /*!< channel 1 complementary output polarity */
N#define TIMER_CHCTL2_CH2EN               BIT(8)              /*!< channel 2 capture/compare function enable  */
N#define TIMER_CHCTL2_CH2P                BIT(9)              /*!< channel 2 capture/compare function polarity */
N#define TIMER_CHCTL2_CH2NEN              BIT(10)             /*!< channel 2 complementary output enable */
N#define TIMER_CHCTL2_CH2NP               BIT(11)             /*!< channel 2 complementary output polarity */
N#define TIMER_CHCTL2_CH3EN               BIT(12)             /*!< channel 3 capture/compare function enable  */
N#define TIMER_CHCTL2_CH3P                BIT(13)             /*!< channel 3 capture/compare function polarity */
N
N/* TIMER_CNT */
N#define TIMER_CNT_CNT                    BITS(0,15)          /*!< 16 bit timer counter */
N
N/* TIMER_PSC */
N#define TIMER_PSC_PSC                    BITS(0,15)          /*!< prescaler value of the counter clock */
N
N/* TIMER_CAR */
N#define TIMER_CAR_CARL                   BITS(0,15)          /*!< 16 bit counter auto reload value */
N
N/* TIMER_CREP */
N#define TIMER_CREP_CREP                  BITS(0,7)           /*!< counter repetition value */
N
N/* TIMER_CH0CV */
N#define TIMER_CH0CV_CH0VAL               BITS(0,15)          /*!< 16 bit capture/compare value of channel 0 */
N
N/* TIMER_CH1CV */
N#define TIMER_CH1CV_CH1VAL               BITS(0,15)          /*!< 16 bit capture/compare value of channel 1 */
N
N/* TIMER_CH2CV */
N#define TIMER_CH2CV_CH2VAL               BITS(0,15)          /*!< 16 bit capture/compare value of channel 2 */
N
N/* TIMER_CH3CV */
N#define TIMER_CH3CV_CH3VAL               BITS(0,15)          /*!< 16 bit capture/compare value of channel 3 */
N
N/* TIMER_CCHP */
N#define TIMER_CCHP_DTCFG                 BITS(0,7)           /*!< dead time configure */
N#define TIMER_CCHP_PROT                  BITS(8,9)           /*!< complementary register protect control */
N#define TIMER_CCHP_IOS                   BIT(10)             /*!< idle mode off-state configure */
N#define TIMER_CCHP_ROS                   BIT(11)             /*!< run mode off-state configure */
N#define TIMER_CCHP_BRKEN                 BIT(12)             /*!< break enable */
N#define TIMER_CCHP_BRKP                  BIT(13)             /*!< break polarity */
N#define TIMER_CCHP_OAEN                  BIT(14)             /*!< output automatic enable */
N#define TIMER_CCHP_POEN                  BIT(15)             /*!< primary output enable */
N
N/* TIMER_DMACFG */
N#define TIMER_DMACFG_DMATA               BITS(0,4)           /*!< DMA transfer access start address */
N#define TIMER_DMACFG_DMATC               BITS(8,12)          /*!< DMA transfer count */
N
N/* TIMER_DMATB */
N#define TIMER_DMATB_DMATB                BITS(0,15)          /*!< DMA transfer buffer address */
N
N/* constants definitions */
N/* TIMER init parameter struct definitions */
Ntypedef struct
N{ 
N    uint16_t prescaler;                         /*!< prescaler value */
N    uint16_t alignedmode;                       /*!< aligned mode */
N    uint16_t counterdirection;                  /*!< counter direction */
N    uint32_t period;                            /*!< period value */
N    uint16_t clockdivision;                     /*!< clock division value */
N    uint8_t  repetitioncounter;                 /*!< the counter repetition value */
N}timer_parameter_struct;
N
N/* break parameter struct definitions*/
Ntypedef struct
N{ 
N    uint16_t runoffstate;                       /*!< run mode off-state */
N    uint16_t ideloffstate;                      /*!< idle mode off-state */
N    uint16_t deadtime;                          /*!< dead time */
N    uint16_t breakpolarity;                     /*!< break polarity */
N    uint16_t outputautostate;                   /*!< output automatic enable */
N    uint16_t protectmode;                       /*!< complementary register protect control */
N    uint16_t breakstate;                        /*!< break enable */
N}timer_break_parameter_struct;
N
N/* channel output parameter struct definitions */
Ntypedef struct
N{ 
N    uint16_t outputstate;                       /*!< channel output state */
N    uint16_t outputnstate;                      /*!< channel complementary output state */
N    uint16_t ocpolarity;                        /*!< channel output polarity */
N    uint16_t ocnpolarity;                       /*!< channel complementary output polarity */
N    uint16_t ocidlestate;                       /*!< idle state of channel output */
N    uint16_t ocnidlestate;                      /*!< idle state of channel complementary output */
N}timer_oc_parameter_struct;
N
N/* channel input parameter struct definitions */
Ntypedef struct
N{ 
N    uint16_t icpolarity;                        /*!< channel input polarity */
N    uint16_t icselection;                       /*!< channel input mode selection */
N    uint16_t icprescaler;                       /*!< channel input capture prescaler */
N    uint16_t icfilter;                          /*!< channel input capture filter control */
N}timer_ic_parameter_struct;
N
N/* TIMER interrupt enable or disable */
N#define TIMER_INT_UP                        TIMER_DMAINTEN_UPIE                     /*!< update interrupt */
N#define TIMER_INT_CH0                       TIMER_DMAINTEN_CH0IE                    /*!< channel 0 interrupt */
N#define TIMER_INT_CH1                       TIMER_DMAINTEN_CH1IE                    /*!< channel 1 interrupt */
N#define TIMER_INT_CH2                       TIMER_DMAINTEN_CH2IE                    /*!< channel 2 interrupt */
N#define TIMER_INT_CH3                       TIMER_DMAINTEN_CH3IE                    /*!< channel 3 interrupt */
N#define TIMER_INT_CMT                       TIMER_DMAINTEN_CMTIE                    /*!< channel commutation interrupt flag */
N#define TIMER_INT_TRG                       TIMER_DMAINTEN_TRGIE                    /*!< trigger interrupt */
N#define TIMER_INT_BRK                       TIMER_DMAINTEN_BRKIE                    /*!< break interrupt */
N
N/* TIMER interrupt flag */
N#define TIMER_INT_FLAG_UP                   TIMER_INT_UP                            /*!< update interrupt */
N#define TIMER_INT_FLAG_CH0                  TIMER_INT_CH0                           /*!< channel 0 interrupt */
N#define TIMER_INT_FLAG_CH1                  TIMER_INT_CH1                           /*!< channel 1 interrupt */
N#define TIMER_INT_FLAG_CH2                  TIMER_INT_CH2                           /*!< channel 2 interrupt */
N#define TIMER_INT_FLAG_CH3                  TIMER_INT_CH3                           /*!< channel 3 interrupt */
N#define TIMER_INT_FLAG_CMT                  TIMER_INT_CMT                           /*!< channel commutation interrupt flag */
N#define TIMER_INT_FLAG_TRG                  TIMER_INT_TRG                           /*!< trigger interrupt */
N#define TIMER_INT_FLAG_BRK                  TIMER_INT_BRK  
N
N/* TIMER flag */
N#define TIMER_FLAG_UP                       TIMER_INTF_UPIF                         /*!< update flag */
N#define TIMER_FLAG_CH0                      TIMER_INTF_CH0IF                        /*!< channel 0 flag */
N#define TIMER_FLAG_CH1                      TIMER_INTF_CH1IF                        /*!< channel 1 flag */
N#define TIMER_FLAG_CH2                      TIMER_INTF_CH2IF                        /*!< channel 2 flag */
N#define TIMER_FLAG_CH3                      TIMER_INTF_CH3IF                        /*!< channel 3 flag */
N#define TIMER_FLAG_CMT                      TIMER_INTF_CMTIF                        /*!< channel commutation flag */
N#define TIMER_FLAG_TRG                      TIMER_INTF_TRGIF                        /*!< trigger flag */
N#define TIMER_FLAG_BRK                      TIMER_INTF_BRKIF                        /*!< break flag */
N#define TIMER_FLAG_CH0O                     TIMER_INTF_CH0OF                        /*!< channel 0 overcapture flag */
N#define TIMER_FLAG_CH1O                     TIMER_INTF_CH1OF                        /*!< channel 1 overcapture flag */
N#define TIMER_FLAG_CH2O                     TIMER_INTF_CH2OF                        /*!< channel 2 overcapture flag */
N#define TIMER_FLAG_CH3O                     TIMER_INTF_CH3OF                        /*!< channel 3 overcapture flag */
N/* TIMER DMA source enable */
N#define TIMER_DMA_UPD                       ((uint16_t)TIMER_DMAINTEN_UPDEN)        /*!< update DMA enable */
N#define TIMER_DMA_CH0D                      ((uint16_t)TIMER_DMAINTEN_CH0DEN)       /*!< channel 0 DMA enable */
N#define TIMER_DMA_CH1D                      ((uint16_t)TIMER_DMAINTEN_CH1DEN)       /*!< channel 1 DMA enable */
N#define TIMER_DMA_CH2D                      ((uint16_t)TIMER_DMAINTEN_CH2DEN)       /*!< channel 2 DMA enable */
N#define TIMER_DMA_CH3D                      ((uint16_t)TIMER_DMAINTEN_CH3DEN)       /*!< channel 3 DMA enable */
N#define TIMER_DMA_CMTD                      ((uint16_t)TIMER_DMAINTEN_CMTDEN)       /*!< commutation DMA request enable */
N#define TIMER_DMA_TRGD                      ((uint16_t)TIMER_DMAINTEN_TRGDEN)       /*!< trigger DMA enable */
N
N/* channel DMA request source selection */ 
N#define TIMER_DMAREQUEST_UPDATEEVENT        TIMER_CTL1_DMAS                         /*!< DMA request of channel n is sent when update event occurs */
N#define TIMER_DMAREQUEST_CHANNELEVENT       ((uint32_t)0x00000000U)                 /*!< DMA request of channel n is sent when channel n event occurs */
N
N/* DMA access base address */
N#define DMACFG_DMATA(regval)                (BITS(0, 4) & ((uint32_t)(regval) << 0U))
N#define TIMER_DMACFG_DMATA_CTL0             DMACFG_DMATA(0)                         /*!< DMA transfer address is TIMER_CTL0 */
N#define TIMER_DMACFG_DMATA_CTL1             DMACFG_DMATA(1)                         /*!< DMA transfer address is TIMER_CTL1 */
N#define TIMER_DMACFG_DMATA_SMCFG            DMACFG_DMATA(2)                         /*!< DMA transfer address is TIMER_SMCFG */
N#define TIMER_DMACFG_DMATA_DMAINTEN         DMACFG_DMATA(3)                         /*!< DMA transfer address is TIMER_DMAINTEN */
N#define TIMER_DMACFG_DMATA_INTF             DMACFG_DMATA(4)                         /*!< DMA transfer address is TIMER_INTF */
N#define TIMER_DMACFG_DMATA_SWEVG            DMACFG_DMATA(5)                         /*!< DMA transfer address is TIMER_SWEVG */
N#define TIMER_DMACFG_DMATA_CHCTL0           DMACFG_DMATA(6)                         /*!< DMA transfer address is TIMER_CHCTL0 */
N#define TIMER_DMACFG_DMATA_CHCTL1           DMACFG_DMATA(7)                         /*!< DMA transfer address is TIMER_CHCTL1 */
N#define TIMER_DMACFG_DMATA_CHCTL2           DMACFG_DMATA(8)                         /*!< DMA transfer address is TIMER_CHCTL2 */
N#define TIMER_DMACFG_DMATA_CNT              DMACFG_DMATA(9)                         /*!< DMA transfer address is TIMER_CNT */
N#define TIMER_DMACFG_DMATA_PSC              DMACFG_DMATA(10)                        /*!< DMA transfer address is TIMER_PSC */
N#define TIMER_DMACFG_DMATA_CAR              DMACFG_DMATA(11)                        /*!< DMA transfer address is TIMER_CAR */
N#define TIMER_DMACFG_DMATA_CREP             DMACFG_DMATA(12)                        /*!< DMA transfer address is TIMER_CREP */
N#define TIMER_DMACFG_DMATA_CH0CV            DMACFG_DMATA(13)                        /*!< DMA transfer address is TIMER_CH0CV */
N#define TIMER_DMACFG_DMATA_CH1CV            DMACFG_DMATA(14)                        /*!< DMA transfer address is TIMER_CH1CV */
N#define TIMER_DMACFG_DMATA_CH2CV            DMACFG_DMATA(15)                        /*!< DMA transfer address is TIMER_CH2CV */
N#define TIMER_DMACFG_DMATA_CH3CV            DMACFG_DMATA(16)                        /*!< DMA transfer address is TIMER_CH3CV */
N#define TIMER_DMACFG_DMATA_CCHP             DMACFG_DMATA(17)                        /*!< DMA transfer address is TIMER_CCHP */
N#define TIMER_DMACFG_DMATA_DMACFG           DMACFG_DMATA(18)                        /*!< DMA transfer address is TIMER_DMACFG */
N
N/* DMA access burst length */
N#define DMACFG_DMATC(regval)                (BITS(8, 12) & ((uint32_t)(regval) << 8U))
N#define TIMER_DMACFG_DMATC_1TRANSFER        DMACFG_DMATC(0)                         /*!< DMA transfer 1 time */
N#define TIMER_DMACFG_DMATC_2TRANSFER        DMACFG_DMATC(1)                         /*!< DMA transfer 2 times */
N#define TIMER_DMACFG_DMATC_3TRANSFER        DMACFG_DMATC(2)                         /*!< DMA transfer 3 times */
N#define TIMER_DMACFG_DMATC_4TRANSFER        DMACFG_DMATC(3)                         /*!< DMA transfer 4 times */
N#define TIMER_DMACFG_DMATC_5TRANSFER        DMACFG_DMATC(4)                         /*!< DMA transfer 5 times */
N#define TIMER_DMACFG_DMATC_6TRANSFER        DMACFG_DMATC(5)                         /*!< DMA transfer 6 times */
N#define TIMER_DMACFG_DMATC_7TRANSFER        DMACFG_DMATC(6)                         /*!< DMA transfer 7 times */
N#define TIMER_DMACFG_DMATC_8TRANSFER        DMACFG_DMATC(7)                         /*!< DMA transfer 8 times */
N#define TIMER_DMACFG_DMATC_9TRANSFER        DMACFG_DMATC(8)                         /*!< DMA transfer 9 times */
N#define TIMER_DMACFG_DMATC_10TRANSFER       DMACFG_DMATC(9)                         /*!< DMA transfer 10 times */
N#define TIMER_DMACFG_DMATC_11TRANSFER       DMACFG_DMATC(10)                        /*!< DMA transfer 11 times */
N#define TIMER_DMACFG_DMATC_12TRANSFER       DMACFG_DMATC(11)                        /*!< DMA transfer 12 times */
N#define TIMER_DMACFG_DMATC_13TRANSFER       DMACFG_DMATC(12)                        /*!< DMA transfer 13 times */
N#define TIMER_DMACFG_DMATC_14TRANSFER       DMACFG_DMATC(13)                        /*!< DMA transfer 14 times */
N#define TIMER_DMACFG_DMATC_15TRANSFER       DMACFG_DMATC(14)                        /*!< DMA transfer 15 times */
N#define TIMER_DMACFG_DMATC_16TRANSFER       DMACFG_DMATC(15)                        /*!< DMA transfer 16 times */
N#define TIMER_DMACFG_DMATC_17TRANSFER       DMACFG_DMATC(16)                        /*!< DMA transfer 17 times */
N#define TIMER_DMACFG_DMATC_18TRANSFER       DMACFG_DMATC(17)                        /*!< DMA transfer 18 times */
N
N/* TIMER software event generation source */
N#define TIMER_EVENT_SRC_UPG                 ((uint16_t)0x0001U)                     /*!< update event generation */
N#define TIMER_EVENT_SRC_CH0G                ((uint16_t)0x0002U)                     /*!< channel 0 capture or compare event generation */
N#define TIMER_EVENT_SRC_CH1G                ((uint16_t)0x0004U)                     /*!< channel 1 capture or compare event generation */
N#define TIMER_EVENT_SRC_CH2G                ((uint16_t)0x0008U)                     /*!< channel 2 capture or compare event generation */
N#define TIMER_EVENT_SRC_CH3G                ((uint16_t)0x0010U)                     /*!< channel 3 capture or compare event generation */
N#define TIMER_EVENT_SRC_CMTG                ((uint16_t)0x0020U)                     /*!< channel commutation event generation */
N#define TIMER_EVENT_SRC_TRGG                ((uint16_t)0x0040U)                     /*!< trigger event generation */
N#define TIMER_EVENT_SRC_BRKG                ((uint16_t)0x0080U)                     /*!< break event generation */
N
N/* center-aligned mode selection */
N#define CTL0_CAM(regval)                    ((uint16_t)(BITS(5, 6) & ((uint32_t)(regval) << 5U)))
N#define TIMER_COUNTER_EDGE                  CTL0_CAM(0)                             /*!< edge-aligned mode */
N#define TIMER_COUNTER_CENTER_DOWN           CTL0_CAM(1)                             /*!< center-aligned and counting down assert mode */
N#define TIMER_COUNTER_CENTER_UP             CTL0_CAM(2)                             /*!< center-aligned and counting up assert mode */
N#define TIMER_COUNTER_CENTER_BOTH           CTL0_CAM(3)                             /*!< center-aligned and counting up/down assert mode */
N
N/* TIMER prescaler reload mode */
N#define TIMER_PSC_RELOAD_NOW                TIMER_SWEVG_UPG                         /*!< the prescaler is loaded right now */
N#define TIMER_PSC_RELOAD_UPDATE             ((uint32_t)0x00000000U)                 /*!< the prescaler is loaded at the next update event */
N
N/* count direction */
N#define TIMER_COUNTER_UP                    ((uint16_t)0x0000U)                     /*!< counter up direction */
N#define TIMER_COUNTER_DOWN                  ((uint16_t)TIMER_CTL0_DIR)              /*!< counter down direction */
N
N/* specify division ratio between TIMER clock and dead-time and sampling clock */
N#define CTL0_CKDIV(regval)                  ((uint16_t)(BITS(8, 9) & ((uint32_t)(regval) << 8U)))
N#define TIMER_CKDIV_DIV1                    CTL0_CKDIV(0)                           /*!< clock division value is 1,fDTS=fTIMER_CK */
N#define TIMER_CKDIV_DIV2                    CTL0_CKDIV(1)                           /*!< clock division value is 2,fDTS= fTIMER_CK/2 */
N#define TIMER_CKDIV_DIV4                    CTL0_CKDIV(2)                           /*!< clock division value is 4, fDTS= fTIMER_CK/4 */
N
N/* single pulse mode */
N#define TIMER_SP_MODE_SINGLE                TIMER_CTL0_SPM                          /*!< single pulse mode */
N#define TIMER_SP_MODE_REPETITIVE            ((uint32_t)0x00000000U)                 /*!< repetitive pulse mode */
N
N/* update source */
N#define TIMER_UPDATE_SRC_REGULAR            TIMER_CTL0_UPS                          /*!< update generate only by counter overflow/underflow */
N#define TIMER_UPDATE_SRC_GLOBAL             ((uint32_t)0x00000000U)                 /*!< update generate by setting of UPG bit or the counter overflow/underflow,or the slave mode controller trigger */
N
N/* run mode off-state configure */
N#define TIMER_ROS_STATE_ENABLE              ((uint16_t)TIMER_CCHP_ROS)              /*!< when POEN bit is set, the channel output signals(CHx_O/CHx_ON) are enabled, with relationship to CHxEN/CHxNEN bits */
N#define TIMER_ROS_STATE_DISABLE             ((uint16_t)0x0000U)                     /*!< when POEN bit is set, the channel output signals(CHx_O/CHx_ON) are disabled */
N
N/* idle mode off-state configure */                                                 
N#define TIMER_IOS_STATE_ENABLE              ((uint16_t)TIMER_CCHP_IOS)              /*!< when POEN bit is reset, he channel output signals(CHx_O/CHx_ON) are enabled, with relationship to CHxEN/CHxNEN bits */
N#define TIMER_IOS_STATE_DISABLE             ((uint16_t)0x0000U)                     /*!< when POEN bit is reset, the channel output signals(CHx_O/CHx_ON) are disabled */
N
N/* break input polarity */
N#define TIMER_BREAK_POLARITY_LOW            ((uint16_t)0x0000U)                     /*!< break input polarity is low */
N#define TIMER_BREAK_POLARITY_HIGH           ((uint16_t)TIMER_CCHP_BRKP)             /*!< break input polarity is high */
N
N/* output automatic enable */
N#define TIMER_OUTAUTO_ENABLE                ((uint16_t)TIMER_CCHP_OAEN)             /*!< output automatic enable */
N#define TIMER_OUTAUTO_DISABLE               ((uint16_t)0x0000U)                     /*!< output automatic disable */
N
N/* complementary register protect control */
N#define CCHP_PROT(regval)                   ((uint16_t)(BITS(8, 9) & ((uint32_t)(regval) << 8U)))
N#define TIMER_CCHP_PROT_OFF                 CCHP_PROT(0)                            /*!< protect disable */
N#define TIMER_CCHP_PROT_0                   CCHP_PROT(1)                            /*!< PROT mode 0 */
N#define TIMER_CCHP_PROT_1                   CCHP_PROT(2)                            /*!< PROT mode 1 */
N#define TIMER_CCHP_PROT_2                   CCHP_PROT(3)                            /*!< PROT mode 2 */
N
N/* break input enable */
N#define TIMER_BREAK_ENABLE                  ((uint16_t)TIMER_CCHP_BRKEN)            /*!< break input enable */
N#define TIMER_BREAK_DISABLE                 ((uint16_t)0x0000U)                     /*!< break input disable */
N
N/* TIMER channel n(n=0,1,2,3) */
N#define TIMER_CH_0                          ((uint16_t)0x0000U)                     /*!< TIMER channel 0(TIMERx(x=0..4,7..13)) */
N#define TIMER_CH_1                          ((uint16_t)0x0001U)                     /*!< TIMER channel 1(TIMERx(x=0..4,7,8,11)) */
N#define TIMER_CH_2                          ((uint16_t)0x0002U)                     /*!< TIMER channel 2(TIMERx(x=0..4,7)) */
N#define TIMER_CH_3                          ((uint16_t)0x0003U)                     /*!< TIMER channel 3(TIMERx(x=0..4,7)) */
N
N/* channel enable state */
N#define TIMER_CCX_ENABLE                    ((uint16_t)0x0001U)                     /*!< channel enable */
N#define TIMER_CCX_DISABLE                   ((uint16_t)0x0000U)                     /*!< channel disable */
N
N/* channel complementary output enable state */
N#define TIMER_CCXN_ENABLE                   ((uint16_t)0x0004U)                     /*!< channel complementary enable */
N#define TIMER_CCXN_DISABLE                  ((uint16_t)0x0000U)                     /*!< channel complementary disable */
N
N/* channel output polarity */
N#define TIMER_OC_POLARITY_HIGH              ((uint16_t)0x0000U)                     /*!< channel output polarity is high */
N#define TIMER_OC_POLARITY_LOW               ((uint16_t)0x0002U)                     /*!< channel output polarity is low */
N
N/* channel complementary output polarity */
N#define TIMER_OCN_POLARITY_HIGH             ((uint16_t)0x0000U)                     /*!< channel complementary output polarity is high */
N#define TIMER_OCN_POLARITY_LOW              ((uint16_t)0x0008U)                     /*!< channel complementary output polarity is low */
N
N/* idle state of channel output */ 
N#define TIMER_OC_IDLE_STATE_HIGH            ((uint16_t)0x0100)                      /*!< idle state of channel output is high */
N#define TIMER_OC_IDLE_STATE_LOW             ((uint16_t)0x0000)                      /*!< idle state of channel output is low */
N
N/* idle state of channel complementary output */ 
N#define TIMER_OCN_IDLE_STATE_HIGH           ((uint16_t)0x0200U)                     /*!< idle state of channel complementary output is high */
N#define TIMER_OCN_IDLE_STATE_LOW            ((uint16_t)0x0000U)                     /*!< idle state of channel complementary output is low */
N
N/* channel output compare mode */
N#define TIMER_OC_MODE_TIMING                ((uint16_t)0x0000U)                     /*!< frozen mode */
N#define TIMER_OC_MODE_ACTIVE                ((uint16_t)0x0010U)                     /*!< set the channel output */
N#define TIMER_OC_MODE_INACTIVE              ((uint16_t)0x0020U)                     /*!< clear the channel output */
N#define TIMER_OC_MODE_TOGGLE                ((uint16_t)0x0030U)                     /*!< toggle on match */
N#define TIMER_OC_MODE_LOW                   ((uint16_t)0x0040U)                     /*!< force low mode */
N#define TIMER_OC_MODE_HIGH                  ((uint16_t)0x0050U)                     /*!< force high mode */
N#define TIMER_OC_MODE_PWM0                  ((uint16_t)0x0060U)                     /*!< PWM0 mode */
N#define TIMER_OC_MODE_PWM1                  ((uint16_t)0x0070U)                     /*!< PWM1 mode*/
N
N/* channel output compare shadow enable */
N#define TIMER_OC_SHADOW_ENABLE              ((uint16_t)0x0008U)                     /*!< channel output shadow state enable */
N#define TIMER_OC_SHADOW_DISABLE             ((uint16_t)0x0000U)                     /*!< channel output shadow state disable */
N
N/* channel output compare fast enable */
N#define TIMER_OC_FAST_ENABLE                ((uint16_t)0x0004)                      /*!< channel output fast function enable */
N#define TIMER_OC_FAST_DISABLE               ((uint16_t)0x0000)                      /*!< channel output fast function disable */
N
N/* channel output compare clear enable */
N#define TIMER_OC_CLEAR_ENABLE               ((uint16_t)0x0080U)                     /*!< channel output clear function enable */
N#define TIMER_OC_CLEAR_DISABLE              ((uint16_t)0x0000U)                     /*!< channel output clear function disable */
N
N/* channel control shadow register update control */ 
N#define TIMER_UPDATECTL_CCU                 ((uint32_t)0x00000000U)                 /*!< the shadow registers update by when CMTG bit is set */
N#define TIMER_UPDATECTL_CCUTRI              TIMER_CTL1_CCUC                         /*!< the shadow registers update by when CMTG bit is set or an rising edge of TRGI occurs */
N
N/* channel input capture polarity */
N#define TIMER_IC_POLARITY_RISING            ((uint16_t)0x0000U)                     /*!< input capture rising edge */
N#define TIMER_IC_POLARITY_FALLING           ((uint16_t)0x0002U)                     /*!< input capture falling edge */
N#define TIMER_IC_POLARITY_BOTH_EDGE         ((uint16_t)0x000AU)                     /*!< input capture both edge */
N
N/* timer input capture selection */
N#define TIMER_IC_SELECTION_DIRECTTI         ((uint16_t)0x0001U)                     /*!< channel y is configured as input and icy is mapped on CIy */
N#define TIMER_IC_SELECTION_INDIRECTTI       ((uint16_t)0x0002U)                     /*!< channel y is configured as input and icy is mapped on opposite input */
N#define TIMER_IC_SELECTION_ITS              ((uint16_t)0x0003U)                     /*!< channel y is configured as input and icy is mapped on ITS */
N
N/* channel input capture prescaler */
N#define TIMER_IC_PSC_DIV1                   ((uint16_t)0x0000U)                     /*!< no prescaler */
N#define TIMER_IC_PSC_DIV2                   ((uint16_t)0x0004U)                     /*!< divided by 2 */
N#define TIMER_IC_PSC_DIV4                   ((uint16_t)0x0008U)                     /*!< divided by 4 */
N#define TIMER_IC_PSC_DIV8                   ((uint16_t)0x000CU)                     /*!< divided by 8 */
N
N/* trigger selection */
N#define SMCFG_TRGSEL(regval)                (BITS(4, 6) & ((uint32_t)(regval) << 4U))
N#define TIMER_SMCFG_TRGSEL_ITI0             SMCFG_TRGSEL(0)                         /*!< internal trigger 0 */
N#define TIMER_SMCFG_TRGSEL_ITI1             SMCFG_TRGSEL(1)                         /*!< internal trigger 1 */
N#define TIMER_SMCFG_TRGSEL_ITI2             SMCFG_TRGSEL(2)                         /*!< internal trigger 2 */
N#define TIMER_SMCFG_TRGSEL_ITI3             SMCFG_TRGSEL(3)                         /*!< internal trigger 3 */
N#define TIMER_SMCFG_TRGSEL_CI0F_ED          SMCFG_TRGSEL(4)                         /*!< TI0 Edge Detector */
N#define TIMER_SMCFG_TRGSEL_CI0FE0           SMCFG_TRGSEL(5)                         /*!< filtered TIMER input 0 */
N#define TIMER_SMCFG_TRGSEL_CI1FE1           SMCFG_TRGSEL(6)                         /*!< filtered TIMER input 1 */
N#define TIMER_SMCFG_TRGSEL_ETIFP            SMCFG_TRGSEL(7)                         /*!< external trigger */
N
N/* master mode control */
N#define CTL1_MMC(regval)                    (BITS(4, 6) & ((uint32_t)(regval) << 4U))
N#define TIMER_TRI_OUT_SRC_RESET             CTL1_MMC(0)                             /*!< the UPG bit as trigger output */
N#define TIMER_TRI_OUT_SRC_ENABLE            CTL1_MMC(1)                             /*!< the counter enable signal TIMER_CTL0_CEN as trigger output */
N#define TIMER_TRI_OUT_SRC_UPDATE            CTL1_MMC(2)                             /*!< update event as trigger output */
N#define TIMER_TRI_OUT_SRC_CH0               CTL1_MMC(3)                             /*!< a capture or a compare match occurred in channel 0 as trigger output TRGO */
N#define TIMER_TRI_OUT_SRC_O0CPRE            CTL1_MMC(4)                             /*!< O0CPRE as trigger output */
N#define TIMER_TRI_OUT_SRC_O1CPRE            CTL1_MMC(5)                             /*!< O1CPRE as trigger output */
N#define TIMER_TRI_OUT_SRC_O2CPRE            CTL1_MMC(6)                             /*!< O2CPRE as trigger output */
N#define TIMER_TRI_OUT_SRC_O3CPRE            CTL1_MMC(7)                             /*!< O3CPRE as trigger output */
N
N/* slave mode control */
N#define SMCFG_SMC(regval)                   (BITS(0, 2) & ((uint32_t)(regval) << 0U)) 
N#define TIMER_SLAVE_MODE_DISABLE            SMCFG_SMC(0)                            /*!< slave mode disable */
N#define TIMER_ENCODER_MODE0                 SMCFG_SMC(1)                            /*!< encoder mode 0 */
N#define TIMER_ENCODER_MODE1                 SMCFG_SMC(2)                            /*!< encoder mode 1 */
N#define TIMER_ENCODER_MODE2                 SMCFG_SMC(3)                            /*!< encoder mode 2 */
N#define TIMER_SLAVE_MODE_RESTART            SMCFG_SMC(4)                            /*!< restart mode */
N#define TIMER_SLAVE_MODE_PAUSE              SMCFG_SMC(5)                            /*!< pause mode */
N#define TIMER_SLAVE_MODE_EVENT              SMCFG_SMC(6)                            /*!< event mode */
N#define TIMER_SLAVE_MODE_EXTERNAL0          SMCFG_SMC(7)                            /*!< external clock mode 0 */
N
N/* master slave mode selection */ 
N#define TIMER_MASTER_SLAVE_MODE_ENABLE      TIMER_SMCFG_MSM                         /*!< master slave mode enable */
N#define TIMER_MASTER_SLAVE_MODE_DISABLE     ((uint32_t)0x00000000U)                 /*!< master slave mode disable */
N
N/* external trigger prescaler */
N#define SMCFG_ETPSC(regval)                 (BITS(12, 13) & ((uint32_t)(regval) << 12U))
N#define TIMER_EXT_TRI_PSC_OFF               SMCFG_ETPSC(0)                          /*!< no divided */
N#define TIMER_EXT_TRI_PSC_DIV2              SMCFG_ETPSC(1)                          /*!< divided by 2 */
N#define TIMER_EXT_TRI_PSC_DIV4              SMCFG_ETPSC(2)                          /*!< divided by 4 */
N#define TIMER_EXT_TRI_PSC_DIV8              SMCFG_ETPSC(3)                          /*!< divided by 8 */
N
N/* external trigger polarity */
N#define TIMER_ETP_FALLING                   TIMER_SMCFG_ETP                         /*!< active low or falling edge active */
N#define TIMER_ETP_RISING                    ((uint32_t)0x00000000U)                 /*!< active high or rising edge active */
N
N/* channel 0 trigger input selection */ 
N#define TIMER_HALLINTERFACE_ENABLE          TIMER_CTL1_TI0S                         /*!< TIMER hall sensor mode enable */
N#define TIMER_HALLINTERFACE_DISABLE         ((uint32_t)0x00000000U)                 /*!< TIMER hall sensor mode disable */
N
N/* TIMERx(x=0..4,7..13) write CHxVAL register selection */
N#define TIMER_CHVSEL_ENABLE                 ((uint16_t)TIMER_CFG_OUTSEL)            /*!< write CHxVAL register selection enable */
N#define TIMER_CHVSEL_DISABLE                ((uint16_t)0x0000U)                     /*!< write CHxVAL register selection disable */
N
N/* function declarations */
N/* TIMER timebase */
N/* deinit a TIMER */
Nvoid timer_deinit(uint32_t timer_periph);
N/* initialize TIMER init parameter struct */
Nvoid timer_struct_para_init(timer_parameter_struct* initpara);
N/* initialize TIMER counter */
Nvoid timer_init(uint32_t timer_periph, timer_parameter_struct* initpara);
N/* enable a TIMER */
Nvoid timer_enable(uint32_t timer_periph);
N/* disable a TIMER */
Nvoid timer_disable(uint32_t timer_periph);
N/* enable the auto reload shadow function */
Nvoid timer_auto_reload_shadow_enable(uint32_t timer_periph);
N/* disable the auto reload shadow function */
Nvoid timer_auto_reload_shadow_disable(uint32_t timer_periph);
N/* enable the update event */
Nvoid timer_update_event_enable(uint32_t timer_periph);
N/* disable the update event */
Nvoid timer_update_event_disable(uint32_t timer_periph);
N/* set TIMER counter alignment mode */
Nvoid timer_counter_alignment(uint32_t timer_periph, uint16_t aligned);
N/* set TIMER counter up direction */
Nvoid timer_counter_up_direction(uint32_t timer_periph);
N/* set TIMER counter down direction */
Nvoid timer_counter_down_direction(uint32_t timer_periph);
N/* configure TIMER prescaler */
Nvoid timer_prescaler_config(uint32_t timer_periph, uint16_t prescaler, uint32_t pscreload);
N/* configure TIMER repetition register value */
Nvoid timer_repetition_value_config(uint32_t timer_periph, uint8_t repetition);
N/* configure TIMER autoreload register value */
Nvoid timer_autoreload_value_config(uint32_t timer_periph, uint32_t autoreload);
N/* configure TIMER counter register value */
Nvoid timer_counter_value_config(uint32_t timer_periph, uint32_t counter);
N/* read TIMER counter value */
Nuint32_t timer_counter_read(uint32_t timer_periph);
N/* read TIMER prescaler value */
Nuint16_t timer_prescaler_read(uint32_t timer_periph);
N/* configure TIMER single pulse mode */
Nvoid timer_single_pulse_mode_config(uint32_t timer_periph, uint32_t spmode);
N/* configure TIMER update source */
Nvoid timer_update_source_config(uint32_t timer_periph, uint32_t update);
N
N/* timer DMA and event */
N/* enable the TIMER DMA */
Nvoid timer_dma_enable(uint32_t timer_periph, uint16_t dma);
N/* disable the TIMER DMA */
Nvoid timer_dma_disable(uint32_t timer_periph, uint16_t dma);
N/* channel DMA request source selection */
Nvoid timer_channel_dma_request_source_select(uint32_t timer_periph, uint32_t dma_request);
N/* configure the TIMER DMA transfer */
Nvoid timer_dma_transfer_config(uint32_t timer_periph, uint32_t dma_baseaddr, uint32_t dma_lenth);
N/* software generate events */
Nvoid timer_event_software_generate(uint32_t timer_periph, uint16_t event);
N
N/* TIMER channel complementary protection */
N/* initialize TIMER break parameter struct */
Nvoid timer_break_struct_para_init(timer_break_parameter_struct* breakpara);
N/* configure TIMER break function */
Nvoid timer_break_config(uint32_t timer_periph, timer_break_parameter_struct* breakpara);
N/* enable TIMER break function */
Nvoid timer_break_enable(uint32_t timer_periph);
N/* disable TIMER break function */
Nvoid timer_break_disable(uint32_t timer_periph);
N/* enable TIMER output automatic function */
Nvoid timer_automatic_output_enable(uint32_t timer_periph);
N/* disable TIMER output automatic function */
Nvoid timer_automatic_output_disable(uint32_t timer_periph);
N/* enable or disable TIMER primary output function */
Nvoid timer_primary_output_config(uint32_t timer_periph, ControlStatus newvalue);
N/* enable or disable channel capture/compare control shadow register */
Nvoid timer_channel_control_shadow_config(uint32_t timer_periph, ControlStatus newvalue);
N/* configure TIMER channel control shadow register update control */
Nvoid timer_channel_control_shadow_update_config(uint32_t timer_periph, uint32_t ccuctl);
N
N/* TIMER channel output */
N/* initialize TIMER channel output parameter struct */
Nvoid timer_channel_output_struct_para_init(timer_oc_parameter_struct* ocpara);
N/* configure TIMER channel output function */
Nvoid timer_channel_output_config(uint32_t timer_periph, uint16_t channel, timer_oc_parameter_struct* ocpara);
N/* configure TIMER channel output compare mode */
Nvoid timer_channel_output_mode_config(uint32_t timer_periph, uint16_t channel, uint16_t ocmode);
N/* configure TIMER channel output pulse value */
Nvoid timer_channel_output_pulse_value_config(uint32_t timer_periph, uint16_t channel, uint16_t pulse);
N/* configure TIMER channel output shadow function */
Nvoid timer_channel_output_shadow_config(uint32_t timer_periph, uint16_t channel, uint16_t ocshadow);
N/* configure TIMER channel output fast function */
Nvoid timer_channel_output_fast_config(uint32_t timer_periph, uint16_t channel, uint16_t ocfast);
N/* configure TIMER channel output clear function */
Nvoid timer_channel_output_clear_config(uint32_t timer_periph, uint16_t channel, uint16_t occlear);
N/* configure TIMER channel output polarity */
Nvoid timer_channel_output_polarity_config(uint32_t timer_periph, uint16_t channel, uint16_t ocpolarity);
N/* configure TIMER channel complementary output polarity */
Nvoid timer_channel_complementary_output_polarity_config(uint32_t timer_periph, uint16_t channel, uint16_t ocnpolarity);
N/* configure TIMER channel enable state */
Nvoid timer_channel_output_state_config(uint32_t timer_periph, uint16_t channel, uint32_t state);
N/* configure TIMER channel complementary output enable state */
Nvoid timer_channel_complementary_output_state_config(uint32_t timer_periph, uint16_t channel, uint16_t ocnstate);
N
N/* TIMER channel input */
N/* initialize TIMER channel input parameter struct */
Nvoid timer_channel_input_struct_para_init(timer_ic_parameter_struct* icpara);
N/* configure TIMER input capture parameter */
Nvoid timer_input_capture_config(uint32_t timer_periph, uint16_t channel, timer_ic_parameter_struct* icpara);
N/* configure TIMER channel input capture prescaler value */
Nvoid timer_channel_input_capture_prescaler_config(uint32_t timer_periph, uint16_t channel, uint16_t prescaler);
N/* read TIMER channel capture compare register value */
Nuint32_t timer_channel_capture_value_register_read(uint32_t timer_periph, uint16_t channel);
N/* configure TIMER input pwm capture function */
Nvoid timer_input_pwm_capture_config(uint32_t timer_periph, uint16_t channel, timer_ic_parameter_struct* icpwm);
N/* configure TIMER hall sensor mode */
Nvoid timer_hall_mode_config(uint32_t timer_periph, uint32_t hallmode);
N
N/* TIMER master and slave */
N/* select TIMER input trigger source */
Nvoid timer_input_trigger_source_select(uint32_t timer_periph, uint32_t intrigger);
N/* select TIMER master mode output trigger source */
Nvoid timer_master_output_trigger_source_select(uint32_t timer_periph, uint32_t outrigger);
N/* select TIMER slave mode */
Nvoid timer_slave_mode_select(uint32_t timer_periph, uint32_t slavemode);
N/* configure TIMER master slave mode */
Nvoid timer_master_slave_mode_config(uint32_t timer_periph, uint32_t masterslave);
N/* configure TIMER external trigger input */
Nvoid timer_external_trigger_config(uint32_t timer_periph, uint32_t extprescaler, uint32_t extpolarity, uint8_t extfilter);
N/* configure TIMER quadrature decoder mode */
Nvoid timer_quadrature_decoder_mode_config(uint32_t timer_periph, uint32_t decomode, uint16_t ic0polarity, uint16_t ic1polarity);
N/* configure TIMER internal clock mode */
Nvoid timer_internal_clock_config(uint32_t timer_periph);
N/* configure TIMER the internal trigger as external clock input */
Nvoid timer_internal_trigger_as_external_clock_config(uint32_t timer_periph, uint32_t intrigger);
N/* configure TIMER the external trigger as external clock input */
Nvoid timer_external_trigger_as_external_clock_config(uint32_t timer_periph, uint32_t extrigger, uint16_t extpolarity, uint8_t extfilter);
N/* configure TIMER the external clock mode 0 */
Nvoid timer_external_clock_mode0_config(uint32_t timer_periph, uint32_t extprescaler, uint32_t extpolarity, uint8_t extfilter);
N/* configure TIMER the external clock mode 1 */
Nvoid timer_external_clock_mode1_config(uint32_t timer_periph, uint32_t extprescaler, uint32_t extpolarity, uint8_t extfilter);
N/* disable TIMER the external clock mode 1 */
Nvoid timer_external_clock_mode1_disable(uint32_t timer_periph);
N
N/* TIMER interrupt and flag */
N/* enable the TIMER interrupt */
Nvoid timer_interrupt_enable(uint32_t timer_periph, uint32_t interrupt);
N/* disable the TIMER interrupt */
Nvoid timer_interrupt_disable(uint32_t timer_periph, uint32_t interrupt);
N/* get TIMER interrupt flag */
NFlagStatus timer_interrupt_flag_get(uint32_t timer_periph, uint32_t interrupt);
N/* clear TIMER interrupt flag */
Nvoid timer_interrupt_flag_clear(uint32_t timer_periph, uint32_t interrupt);
N/* get TIMER flag */
NFlagStatus timer_flag_get(uint32_t timer_periph, uint32_t flag);
N/* clear TIMER flag */
Nvoid timer_flag_clear(uint32_t timer_periph, uint32_t flag);
N
N#endif /* GD32E10X_TIMER_H */
L 57 ".\User\gd32f10x_libopt.h" 2
N#include "gd32f10x_usart.h"
L 1 ".\Libraries\inc\gd32f10x_usart.h" 1
N/*!
N    \file    gd32f10x_usart.h
N    \brief   definitions for the USART 
N
N    \version 2014-12-26, V1.0.0, firmware for GD32F10x
N    \version 2017-06-20, V2.0.1, firmware for GD32F10x
N    \version 2018-07-31, V2.1.0, firmware for GD32F10x
N*/
N
N/*
N    Copyright (c) 2018, GigaDevice Semiconductor Inc.
N
N    All rights reserved.
N
N    Redistribution and use in source and binary forms, with or without modification, 
Nare permitted provided that the following conditions are met:
N
N    1. Redistributions of source code must retain the above copyright notice, this 
N       list of conditions and the following disclaimer.
N    2. Redistributions in binary form must reproduce the above copyright notice, 
N       this list of conditions and the following disclaimer in the documentation 
N       and/or other materials provided with the distribution.
N    3. Neither the name of the copyright holder nor the names of its contributors 
N       may be used to endorse or promote products derived from this software without 
N       specific prior written permission.
N
N    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
NAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
NWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
NIN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
NINDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
NNOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
NPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
NWHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
NARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
NOF SUCH DAMAGE.
N*/
N
N#ifndef GD32F10X_USART_H
N#define GD32F10X_USART_H
N
N#include "gd32f10x.h"
N
N/* USARTx(x=0,1,2)/UARTx(x=3,4) definitions */
N#define USART1                        USART_BASE                       /*!< USART1 base address */
N#define USART2                        (USART_BASE+(0x00000400U))       /*!< USART2 base address */
N#define UART3                         (USART_BASE+(0x00000800U))       /*!< UART3 base address */
N#define UART4                         (USART_BASE+(0x00000C00U))       /*!< UART4 base address */
N#define USART0                        (USART_BASE+(0x0000F400U))       /*!< USART0 base address */
N
N/* registers definitions */
N#define USART_STAT(usartx)            REG32((usartx) + (0x00000000U))  /*!< USART status register */
N#define USART_DATA(usartx)            REG32((usartx) + (0x00000004U))  /*!< USART data register */
N#define USART_BAUD(usartx)            REG32((usartx) + (0x00000008U))  /*!< USART baud rate register */
N#define USART_CTL0(usartx)            REG32((usartx) + (0x0000000CU))  /*!< USART control register 0 */
N#define USART_CTL1(usartx)            REG32((usartx) + (0x00000010U))  /*!< USART control register 1 */
N#define USART_CTL2(usartx)            REG32((usartx) + (0x00000014U))  /*!< USART control register 2 */
N#define USART_GP(usartx)              REG32((usartx) + (0x00000018U))  /*!< USART guard time and prescaler register */
N
N/* bits definitions */
N/* USARTx_STAT */
N#define USART_STAT_PERR               BIT(0)       /*!< parity error flag */
N#define USART_STAT_FERR               BIT(1)       /*!< frame error flag */
N#define USART_STAT_NERR               BIT(2)       /*!< noise error flag */
N#define USART_STAT_ORERR              BIT(3)       /*!< overrun error */
N#define USART_STAT_IDLEF              BIT(4)       /*!< IDLE frame detected flag */
N#define USART_STAT_RBNE               BIT(5)       /*!< read data buffer not empty */
N#define USART_STAT_TC                 BIT(6)       /*!< transmission complete */
N#define USART_STAT_TBE                BIT(7)       /*!< transmit data buffer empty */
N#define USART_STAT_LBDF               BIT(8)       /*!< LIN break detected flag */
N#define USART_STAT_CTSF               BIT(9)       /*!< CTS change flag */
N
N/* USARTx_DATA */
N#define USART_DATA_DATA               BITS(0,8)    /*!< transmit or read data value */
N
N/* USARTx_BAUD */
N#define USART_BAUD_FRADIV             BITS(0,3)    /*!< fraction part of baud-rate divider */
N#define USART_BAUD_INTDIV             BITS(4,15)   /*!< integer part of baud-rate divider */
N
N/* USARTx_CTL0 */
N#define USART_CTL0_SBKCMD             BIT(0)       /*!< send break command */
N#define USART_CTL0_RWU                BIT(1)       /*!< receiver wakeup from mute mode */
N#define USART_CTL0_REN                BIT(2)       /*!< receiver enable */
N#define USART_CTL0_TEN                BIT(3)       /*!< transmitter enable */
N#define USART_CTL0_IDLEIE             BIT(4)       /*!< idle line detected interrupt enable */
N#define USART_CTL0_RBNEIE             BIT(5)       /*!< read data buffer not empty interrupt and overrun error interrupt enable */
N#define USART_CTL0_TCIE               BIT(6)       /*!< transmission complete interrupt enable */
N#define USART_CTL0_TBEIE              BIT(7)       /*!< transmitter buffer empty interrupt enable */
N#define USART_CTL0_PERRIE             BIT(8)       /*!< parity error interrupt enable */
N#define USART_CTL0_PM                 BIT(9)       /*!< parity mode */
N#define USART_CTL0_PCEN               BIT(10)      /*!< parity check function enable */
N#define USART_CTL0_WM                 BIT(11)      /*!< wakeup method in mute mode */
N#define USART_CTL0_WL                 BIT(12)      /*!< word length */
N#define USART_CTL0_UEN                BIT(13)      /*!< USART enable */
N
N/* USARTx_CTL1 */
N#define USART_CTL1_ADDR               BITS(0,3)    /*!< address of USART */
N#define USART_CTL1_LBLEN              BIT(5)       /*!< LIN break frame length */
N#define USART_CTL1_LBDIE              BIT(6)       /*!< LIN break detected interrupt eanble */
N#define USART_CTL1_CLEN               BIT(8)       /*!< CK length */
N#define USART_CTL1_CPH                BIT(9)       /*!< CK phase */
N#define USART_CTL1_CPL                BIT(10)      /*!< CK polarity */
N#define USART_CTL1_CKEN               BIT(11)      /*!< CK pin enable */
N#define USART_CTL1_STB                BITS(12,13)  /*!< STOP bits length */
N#define USART_CTL1_LMEN               BIT(14)      /*!< LIN mode enable */
N
N/* USARTx_CTL2 */
N#define USART_CTL2_ERRIE              BIT(0)       /*!< error interrupt enable */
N#define USART_CTL2_IREN               BIT(1)       /*!< IrDA mode enable */
N#define USART_CTL2_IRLP               BIT(2)       /*!< IrDA low-power */
N#define USART_CTL2_HDEN               BIT(3)       /*!< half-duplex enable */
N#define USART_CTL2_NKEN               BIT(4)       /*!< NACK enable in smartcard mode */
N#define USART_CTL2_SCEN               BIT(5)       /*!< smartcard mode enable */
N#define USART_CTL2_DENR               BIT(6)       /*!< DMA request enable for reception */
N#define USART_CTL2_DENT               BIT(7)       /*!< DMA request enable for transmission */
N#define USART_CTL2_RTSEN              BIT(8)       /*!< RTS enable */
N#define USART_CTL2_CTSEN              BIT(9)       /*!< CTS enable */
N#define USART_CTL2_CTSIE              BIT(10)      /*!< CTS interrupt enable */
N
N/* USARTx_GP */
N#define USART_GP_PSC                  BITS(0,7)    /*!< prescaler value for dividing the system clock */
N#define USART_GP_GUAT                 BITS(8,15)   /*!< guard time value in smartcard mode */
N
N/* constants definitions */
N/* define the USART bit position and its register index offset */
N#define USART_REGIDX_BIT(regidx, bitpos)     (((uint32_t)(regidx) << 6) | (uint32_t)(bitpos))
N#define USART_REG_VAL(usartx, offset)        (REG32((usartx) + (((uint32_t)(offset) & (0x0000FFFFU)) >> 6)))
N#define USART_BIT_POS(val)                   ((uint32_t)(val) & (0x0000001FU))
N#define USART_REGIDX_BIT2(regidx, bitpos, regidx2, bitpos2)   (((uint32_t)(regidx2) << 22) | (uint32_t)((bitpos2) << 16)\
N                                                              | (((uint32_t)(regidx) << 6) | (uint32_t)(bitpos)))
X#define USART_REGIDX_BIT2(regidx, bitpos, regidx2, bitpos2)   (((uint32_t)(regidx2) << 22) | (uint32_t)((bitpos2) << 16)                                                              | (((uint32_t)(regidx) << 6) | (uint32_t)(bitpos)))
N#define USART_REG_VAL2(usartx, offset)       (REG32((usartx) + ((uint32_t)(offset) >> 22)))
N#define USART_BIT_POS2(val)                  (((uint32_t)(val) & (0x001F0000U)) >> 16)
N
N/* register offset */
N#define USART_STAT_REG_OFFSET                     (0x00000000U)        /*!< STAT register offset */
N#define USART_CTL0_REG_OFFSET                     (0x0000000CU)        /*!< CTL0 register offset */
N#define USART_CTL1_REG_OFFSET                     (0x00000010U)        /*!< CTL1 register offset */
N#define USART_CTL2_REG_OFFSET                     (0x00000014U)        /*!< CTL2 register offset */
N
N/* USART flags */
Ntypedef enum
N{
N    /* flags in STAT register */
N    USART_FLAG_CTSF = USART_REGIDX_BIT(USART_STAT_REG_OFFSET, 9U),      /*!< CTS change flag */
X    USART_FLAG_CTSF = (((uint32_t)((0x00000000U)) << 6) | (uint32_t)(9U)),       
N    USART_FLAG_LBDF = USART_REGIDX_BIT(USART_STAT_REG_OFFSET, 8U),      /*!< LIN break detected flag */
X    USART_FLAG_LBDF = (((uint32_t)((0x00000000U)) << 6) | (uint32_t)(8U)),       
N    USART_FLAG_TBE = USART_REGIDX_BIT(USART_STAT_REG_OFFSET, 7U),       /*!< transmit data buffer empty */
X    USART_FLAG_TBE = (((uint32_t)((0x00000000U)) << 6) | (uint32_t)(7U)),        
N    USART_FLAG_TC = USART_REGIDX_BIT(USART_STAT_REG_OFFSET, 6U),        /*!< transmission complete */
X    USART_FLAG_TC = (((uint32_t)((0x00000000U)) << 6) | (uint32_t)(6U)),         
N    USART_FLAG_RBNE = USART_REGIDX_BIT(USART_STAT_REG_OFFSET, 5U),      /*!< read data buffer not empty */
X    USART_FLAG_RBNE = (((uint32_t)((0x00000000U)) << 6) | (uint32_t)(5U)),       
N    USART_FLAG_IDLEF = USART_REGIDX_BIT(USART_STAT_REG_OFFSET, 4U),     /*!< IDLE frame detected flag */
X    USART_FLAG_IDLEF = (((uint32_t)((0x00000000U)) << 6) | (uint32_t)(4U)),      
N    USART_FLAG_ORERR = USART_REGIDX_BIT(USART_STAT_REG_OFFSET, 3U),     /*!< overrun error */
X    USART_FLAG_ORERR = (((uint32_t)((0x00000000U)) << 6) | (uint32_t)(3U)),      
N    USART_FLAG_NERR = USART_REGIDX_BIT(USART_STAT_REG_OFFSET, 2U),      /*!< noise error flag */
X    USART_FLAG_NERR = (((uint32_t)((0x00000000U)) << 6) | (uint32_t)(2U)),       
N    USART_FLAG_FERR = USART_REGIDX_BIT(USART_STAT_REG_OFFSET, 1U),      /*!< frame error flag */
X    USART_FLAG_FERR = (((uint32_t)((0x00000000U)) << 6) | (uint32_t)(1U)),       
N    USART_FLAG_PERR = USART_REGIDX_BIT(USART_STAT_REG_OFFSET, 0U),      /*!< parity error flag */
X    USART_FLAG_PERR = (((uint32_t)((0x00000000U)) << 6) | (uint32_t)(0U)),       
N}usart_flag_enum;
N
N/* USART interrupt flags */
Ntypedef enum
N{
N    /* interrupt flags in CTL0 register */
N    USART_INT_FLAG_PERR = USART_REGIDX_BIT2(USART_CTL0_REG_OFFSET, 8U, USART_STAT_REG_OFFSET, 0U),       /*!< parity error interrupt and flag */
X    USART_INT_FLAG_PERR = (((uint32_t)((0x00000000U)) << 22) | (uint32_t)((0U) << 16) | (((uint32_t)((0x0000000CU)) << 6) | (uint32_t)(8U))),        
N    USART_INT_FLAG_TBE = USART_REGIDX_BIT2(USART_CTL0_REG_OFFSET, 7U, USART_STAT_REG_OFFSET, 7U),        /*!< transmitter buffer empty interrupt and flag */
X    USART_INT_FLAG_TBE = (((uint32_t)((0x00000000U)) << 22) | (uint32_t)((7U) << 16) | (((uint32_t)((0x0000000CU)) << 6) | (uint32_t)(7U))),         
N    USART_INT_FLAG_TC = USART_REGIDX_BIT2(USART_CTL0_REG_OFFSET, 6U, USART_STAT_REG_OFFSET, 6U),         /*!< transmission complete interrupt and flag */
X    USART_INT_FLAG_TC = (((uint32_t)((0x00000000U)) << 22) | (uint32_t)((6U) << 16) | (((uint32_t)((0x0000000CU)) << 6) | (uint32_t)(6U))),          
N    USART_INT_FLAG_RBNE = USART_REGIDX_BIT2(USART_CTL0_REG_OFFSET, 5U, USART_STAT_REG_OFFSET, 5U),       /*!< read data buffer not empty interrupt and flag */
X    USART_INT_FLAG_RBNE = (((uint32_t)((0x00000000U)) << 22) | (uint32_t)((5U) << 16) | (((uint32_t)((0x0000000CU)) << 6) | (uint32_t)(5U))),        
N    USART_INT_FLAG_RBNE_ORERR = USART_REGIDX_BIT2(USART_CTL0_REG_OFFSET, 5U, USART_STAT_REG_OFFSET, 3U), /*!< read data buffer not empty interrupt and overrun error flag */
X    USART_INT_FLAG_RBNE_ORERR = (((uint32_t)((0x00000000U)) << 22) | (uint32_t)((3U) << 16) | (((uint32_t)((0x0000000CU)) << 6) | (uint32_t)(5U))),  
N    USART_INT_FLAG_IDLE = USART_REGIDX_BIT2(USART_CTL0_REG_OFFSET, 4U, USART_STAT_REG_OFFSET, 4U),       /*!< IDLE line detected interrupt and flag */
X    USART_INT_FLAG_IDLE = (((uint32_t)((0x00000000U)) << 22) | (uint32_t)((4U) << 16) | (((uint32_t)((0x0000000CU)) << 6) | (uint32_t)(4U))),        
N    /* interrupt flags in CTL1 register */
N    USART_INT_FLAG_LBD = USART_REGIDX_BIT2(USART_CTL1_REG_OFFSET, 6U, USART_STAT_REG_OFFSET, 8U),        /*!< LIN break detected interrupt and flag */
X    USART_INT_FLAG_LBD = (((uint32_t)((0x00000000U)) << 22) | (uint32_t)((8U) << 16) | (((uint32_t)((0x00000010U)) << 6) | (uint32_t)(6U))),         
N    /* interrupt flags in CTL2 register */
N    USART_INT_FLAG_CTS = USART_REGIDX_BIT2(USART_CTL2_REG_OFFSET, 10U, USART_STAT_REG_OFFSET, 9U),       /*!< CTS interrupt and flag */
X    USART_INT_FLAG_CTS = (((uint32_t)((0x00000000U)) << 22) | (uint32_t)((9U) << 16) | (((uint32_t)((0x00000014U)) << 6) | (uint32_t)(10U))),        
N    USART_INT_FLAG_ERR_ORERR = USART_REGIDX_BIT2(USART_CTL2_REG_OFFSET, 0U, USART_STAT_REG_OFFSET, 3U),  /*!< error interrupt and overrun error */
X    USART_INT_FLAG_ERR_ORERR = (((uint32_t)((0x00000000U)) << 22) | (uint32_t)((3U) << 16) | (((uint32_t)((0x00000014U)) << 6) | (uint32_t)(0U))),   
N    USART_INT_FLAG_ERR_NERR = USART_REGIDX_BIT2(USART_CTL2_REG_OFFSET, 0U, USART_STAT_REG_OFFSET, 2U),   /*!< error interrupt and noise error flag */
X    USART_INT_FLAG_ERR_NERR = (((uint32_t)((0x00000000U)) << 22) | (uint32_t)((2U) << 16) | (((uint32_t)((0x00000014U)) << 6) | (uint32_t)(0U))),    
N    USART_INT_FLAG_ERR_FERR = USART_REGIDX_BIT2(USART_CTL2_REG_OFFSET, 0U, USART_STAT_REG_OFFSET, 1U),   /*!< error interrupt and frame error flag */
X    USART_INT_FLAG_ERR_FERR = (((uint32_t)((0x00000000U)) << 22) | (uint32_t)((1U) << 16) | (((uint32_t)((0x00000014U)) << 6) | (uint32_t)(0U))),    
N}usart_interrupt_flag_enum;
N
N/* USART interrupt enable or disable */
Ntypedef enum
N{
N    /* interrupt in CTL0 register */
N    USART_INT_PERR = USART_REGIDX_BIT(USART_CTL0_REG_OFFSET, 8U),        /*!< parity error interrupt */
X    USART_INT_PERR = (((uint32_t)((0x0000000CU)) << 6) | (uint32_t)(8U)),         
N    USART_INT_TBE = USART_REGIDX_BIT(USART_CTL0_REG_OFFSET, 7U),         /*!< transmitter buffer empty interrupt */
X    USART_INT_TBE = (((uint32_t)((0x0000000CU)) << 6) | (uint32_t)(7U)),          
N    USART_INT_TC = USART_REGIDX_BIT(USART_CTL0_REG_OFFSET, 6U),          /*!< transmission complete interrupt */
X    USART_INT_TC = (((uint32_t)((0x0000000CU)) << 6) | (uint32_t)(6U)),           
N    USART_INT_RBNE = USART_REGIDX_BIT(USART_CTL0_REG_OFFSET, 5U),        /*!< read data buffer not empty interrupt and overrun error interrupt */
X    USART_INT_RBNE = (((uint32_t)((0x0000000CU)) << 6) | (uint32_t)(5U)),         
N    USART_INT_IDLE = USART_REGIDX_BIT(USART_CTL0_REG_OFFSET, 4U),        /*!< IDLE line detected interrupt */
X    USART_INT_IDLE = (((uint32_t)((0x0000000CU)) << 6) | (uint32_t)(4U)),         
N    /* interrupt in CTL1 register */
N    USART_INT_LBD = USART_REGIDX_BIT(USART_CTL1_REG_OFFSET, 6U),         /*!< LIN break detected interrupt */
X    USART_INT_LBD = (((uint32_t)((0x00000010U)) << 6) | (uint32_t)(6U)),          
N    /* interrupt in CTL2 register */
N    USART_INT_CTS = USART_REGIDX_BIT(USART_CTL2_REG_OFFSET, 10U),        /*!< CTS interrupt */
X    USART_INT_CTS = (((uint32_t)((0x00000014U)) << 6) | (uint32_t)(10U)),         
N    USART_INT_ERR = USART_REGIDX_BIT(USART_CTL2_REG_OFFSET, 0U),         /*!< error interrupt */
X    USART_INT_ERR = (((uint32_t)((0x00000014U)) << 6) | (uint32_t)(0U)),          
N}usart_interrupt_enum;
N
N/* USART receiver configure */
N#define CTL0_REN(regval)              (BIT(2) & ((uint32_t)(regval) << 2))
N#define USART_RECEIVE_ENABLE          CTL0_REN(1)                      /*!< enable receiver */
N#define USART_RECEIVE_DISABLE         CTL0_REN(0)                      /*!< disable receiver */
N
N/* USART transmitter configure */
N#define CTL0_TEN(regval)              (BIT(3) & ((uint32_t)(regval) << 3))
N#define USART_TRANSMIT_ENABLE         CTL0_TEN(1)                      /*!< enable transmitter */
N#define USART_TRANSMIT_DISABLE        CTL0_TEN(0)                      /*!< disable transmitter */
N
N/* USART parity bits definitions */
N#define CTL0_PM(regval)               (BITS(9,10) & ((uint32_t)(regval) << 9))
N#define USART_PM_NONE                 CTL0_PM(0)                       /*!< no parity */
N#define USART_PM_EVEN                 CTL0_PM(2)                       /*!< even parity */
N#define USART_PM_ODD                  CTL0_PM(3)                       /*!< odd parity */
N
N/* USART wakeup method in mute mode */
N#define CTL0_WM(regval)               (BIT(11) & ((uint32_t)(regval) << 11))
N#define USART_WM_IDLE                 CTL0_WM(0)                       /*!< idle line */
N#define USART_WM_ADDR                 CTL0_WM(1)                       /*!< address match */
N
N/* USART word length definitions */
N#define CTL0_WL(regval)               (BIT(12) & ((uint32_t)(regval) << 12))
N#define USART_WL_8BIT                 CTL0_WL(0)                       /*!< 8 bits */
N#define USART_WL_9BIT                 CTL0_WL(1)                       /*!< 9 bits */
N
N/* USART stop bits definitions */
N#define CTL1_STB(regval)              (BITS(12,13) & ((uint32_t)(regval) << 12))
N#define USART_STB_1BIT                CTL1_STB(0)                      /*!< 1 bit */
N#define USART_STB_0_5BIT              CTL1_STB(1)                      /*!< 0.5 bit */
N#define USART_STB_2BIT                CTL1_STB(2)                      /*!< 2 bits */
N#define USART_STB_1_5BIT              CTL1_STB(3)                      /*!< 1.5 bits */
N
N/* USART LIN break frame length */
N#define CTL1_LBLEN(regval)            (BIT(5) & ((uint32_t)(regval) << 5))
N#define USART_LBLEN_10B               CTL1_LBLEN(0)                    /*!< 10 bits */
N#define USART_LBLEN_11B               CTL1_LBLEN(1)                    /*!< 11 bits */
N
N/* USART CK length */
N#define CTL1_CLEN(regval)             (BIT(8) & ((uint32_t)(regval) << 8))
N#define USART_CLEN_NONE               CTL1_CLEN(0)                     /*!< there are 7 CK pulses for an 8 bit frame and 8 CK pulses for a 9 bit frame */
N#define USART_CLEN_EN                 CTL1_CLEN(1)                     /*!< there are 8 CK pulses for an 8 bit frame and 9 CK pulses for a 9 bit frame */
N
N/* USART clock phase */
N#define CTL1_CPH(regval)              (BIT(9) & ((uint32_t)(regval) << 9))
N#define USART_CPH_1CK                 CTL1_CPH(0)                      /*!< first clock transition is the first data capture edge */
N#define USART_CPH_2CK                 CTL1_CPH(1)                      /*!< second clock transition is the first data capture edge */
N
N/* USART clock polarity */
N#define CTL1_CPL(regval)              (BIT(10) & ((uint32_t)(regval) << 10))
N#define USART_CPL_LOW                 CTL1_CPL(0)                      /*!< steady low value on CK pin */
N#define USART_CPL_HIGH                CTL1_CPL(1)                      /*!< steady high value on CK pin */
N
N/* USART DMA request for receive configure */
N#define CLT2_DENR(regval)             (BIT(6) & ((uint32_t)(regval) << 6))
N#define USART_DENR_ENABLE             CLT2_DENR(1)                     /*!< DMA request enable for reception */
N#define USART_DENR_DISABLE            CLT2_DENR(0)                     /*!< DMA request disable for reception */
N
N/* USART DMA request for transmission configure */
N#define CLT2_DENT(regval)             (BIT(7) & ((uint32_t)(regval) << 7))
N#define USART_DENT_ENABLE             CLT2_DENT(1)                     /*!< DMA request enable for transmission */
N#define USART_DENT_DISABLE            CLT2_DENT(0)                     /*!< DMA request disable for transmission */
N
N/* USART RTS configure */
N#define CLT2_RTSEN(regval)            (BIT(8) & ((uint32_t)(regval) << 8))
N#define USART_RTS_ENABLE              CLT2_RTSEN(1)                    /*!< RTS enable */
N#define USART_RTS_DISABLE             CLT2_RTSEN(0)                    /*!< RTS disable */
N
N/* USART CTS configure */
N#define CLT2_CTSEN(regval)            (BIT(9) & ((uint32_t)(regval) << 9))
N#define USART_CTS_ENABLE              CLT2_CTSEN(1)                    /*!< CTS enable */
N#define USART_CTS_DISABLE             CLT2_CTSEN(0)                    /*!< CTS disable */
N
N/* USART IrDA low-power enable */
N#define CTL2_IRLP(regval)             (BIT(2) & ((uint32_t)(regval) << 2))
N#define USART_IRLP_LOW                CTL2_IRLP(1)                     /*!< low-power */
N#define USART_IRLP_NORMAL             CTL2_IRLP(0)                     /*!< normal */
N
N/* function declarations */
N/* initialization functions */
N/* reset USART */
Nvoid usart_deinit(uint32_t usart_periph);
N/* configure USART baud rate value */
Nvoid usart_baudrate_set(uint32_t usart_periph, uint32_t baudval);
N/* configure USART parity function */
Nvoid usart_parity_config(uint32_t usart_periph, uint32_t paritycfg);
N/* configure USART word length */
Nvoid usart_word_length_set(uint32_t usart_periph, uint32_t wlen);
N/* configure USART stop bit length */
Nvoid usart_stop_bit_set(uint32_t usart_periph, uint32_t stblen);
N
N/* USART normal mode communication */
N/* enable USART */
Nvoid usart_enable(uint32_t usart_periph);
N/* disable USART */
Nvoid usart_disable(uint32_t usart_periph);
N/* configure USART transmitter */
Nvoid usart_transmit_config(uint32_t usart_periph, uint32_t txconfig);
N/* configure USART receiver */
Nvoid usart_receive_config(uint32_t usart_periph, uint32_t rxconfig);
N/* USART transmit data function */
Nvoid usart_data_transmit(uint32_t usart_periph, uint16_t data);
N/* USART receive data function */
Nuint16_t usart_data_receive(uint32_t usart_periph);
N
N/* multi-processor communication */
N/* configure address of the USART */
Nvoid usart_address_config(uint32_t usart_periph, uint8_t addr);
N/* enable mute mode */
Nvoid usart_mute_mode_enable(uint32_t usart_periph);
N/* disable mute mode */
Nvoid usart_mute_mode_disable(uint32_t usart_periph);
N/* configure wakeup method in mute mode */
Nvoid usart_mute_mode_wakeup_config(uint32_t usart_periph, uint32_t wmethod);
N
N/* LIN mode communication */
N/* LIN mode enable */
Nvoid usart_lin_mode_enable(uint32_t usart_periph);
N/* LIN mode disable */
Nvoid usart_lin_mode_disable(uint32_t usart_periph);
N/* LIN break detection length */
Nvoid usart_lin_break_detection_length_config(uint32_t usart_periph, uint32_t lblen);
N/* send break frame */
Nvoid usart_send_break(uint32_t usart_periph);
N
N/* half-duplex communication */
N/* half-duplex enable */
Nvoid usart_halfduplex_enable(uint32_t usart_periph);
N/* half-duplex disable */
Nvoid usart_halfduplex_disable(uint32_t usart_periph);
N
N/* synchronous communication */
N/* clock enable */
Nvoid usart_synchronous_clock_enable(uint32_t usart_periph);
N/* clock disable */
Nvoid usart_synchronous_clock_disable(uint32_t usart_periph);
N/* configure usart synchronous mode parameters */
Nvoid usart_synchronous_clock_config(uint32_t usart_periph, uint32_t clen, uint32_t cph, uint32_t cpl);
N
N/* smartcard communication */
N/* guard time value configure in smartcard mode */
Nvoid usart_guard_time_config(uint32_t usart_periph,uint32_t gaut);
N/* smartcard mode enable */
Nvoid usart_smartcard_mode_enable(uint32_t usart_periph);
N/* smartcard mode disable */
Nvoid usart_smartcard_mode_disable(uint32_t usart_periph);
N/* NACK enable in smartcard mode */
Nvoid usart_smartcard_mode_nack_enable(uint32_t usart_periph);
N/* NACK disable in smartcard mode */
Nvoid usart_smartcard_mode_nack_disable(uint32_t usart_periph);
N
N/* IrDA communication */
N/* enable IrDA mode */
Nvoid usart_irda_mode_enable(uint32_t usart_periph);
N/* disable IrDA mode */
Nvoid usart_irda_mode_disable(uint32_t usart_periph);
N/* configure the peripheral clock prescaler */
Nvoid usart_prescaler_config(uint32_t usart_periph, uint8_t psc);
N/* configure IrDA low-power */
Nvoid usart_irda_lowpower_config(uint32_t usart_periph, uint32_t irlp);
N
N/* hardware flow communication */
N/* configure hardware flow control RTS */
Nvoid usart_hardware_flow_rts_config(uint32_t usart_periph, uint32_t rtsconfig);
N/* configure hardware flow control CTS */
Nvoid usart_hardware_flow_cts_config(uint32_t usart_periph, uint32_t ctsconfig);
N
N/* configure USART DMA for reception */
Nvoid usart_dma_receive_config(uint32_t usart_periph, uint32_t dmacmd);
N/* configure USART DMA for transmission */
Nvoid usart_dma_transmit_config(uint32_t usart_periph, uint32_t dmacmd);
N
N/* flag functions */
N/* get flag in STAT register */
NFlagStatus usart_flag_get(uint32_t usart_periph, usart_flag_enum flag);
N/* clear flag in STAT register */
Nvoid usart_flag_clear(uint32_t usart_periph, usart_flag_enum flag);
N
N/* interrupt functions */
N/* enable USART interrupt */
Nvoid usart_interrupt_enable(uint32_t usart_periph, uint32_t int_flag);
N/* disable USART interrupt */
Nvoid usart_interrupt_disable(uint32_t usart_periph, uint32_t int_flag);
N/* get USART interrupt and flag status */
NFlagStatus usart_interrupt_flag_get(uint32_t usart_periph, uint32_t int_flag);
N/* clear interrupt flag in STAT register */
Nvoid usart_interrupt_flag_clear(uint32_t usart_periph, uint32_t flag);
N#endif /* GD32F10X_USART_H */ 
L 58 ".\User\gd32f10x_libopt.h" 2
N#include "gd32f10x_i2c.h"
L 1 ".\Libraries\inc\gd32f10x_i2c.h" 1
N/*!
N    \file  gd32f10x_i2c.h
N    \brief definitions for the I2C
N    
N    \version 2014-12-26, V1.0.0, firmware for GD32F10x
N    \version 2017-06-20, V2.0.0, firmware for GD32F10x
N    \version 2018-07-31, V2.1.0, firmware for GD32F10x
N    \version 2019-04-16, V2.1.1, firmware for GD32F10x
N*/
N
N/*
N    Copyright (c) 2018, GigaDevice Semiconductor Inc.
N
N    All rights reserved.
N
N    Redistribution and use in source and binary forms, with or without modification, 
Nare permitted provided that the following conditions are met:
N
N    1. Redistributions of source code must retain the above copyright notice, this 
N       list of conditions and the following disclaimer.
N    2. Redistributions in binary form must reproduce the above copyright notice, 
N       this list of conditions and the following disclaimer in the documentation 
N       and/or other materials provided with the distribution.
N    3. Neither the name of the copyright holder nor the names of its contributors 
N       may be used to endorse or promote products derived from this software without 
N       specific prior written permission.
N
N    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
NAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
NWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
NIN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
NINDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
NNOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
NPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
NWHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
NARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
NOF SUCH DAMAGE.
N*/
N
N#ifndef GD32F10X_I2C_H
N#define GD32F10X_I2C_H
N
N#include "gd32f10x.h"
N
N/* I2Cx(x=0,1) definitions */
N#define I2C0                          I2C_BASE                   /*!< I2C0 base address */
N#define I2C1                          (I2C_BASE + 0x00000400U)   /*!< I2C1 base address */
N
N/* registers definitions */
N#define I2C_CTL0(i2cx)                REG32((i2cx) + 0x00U)      /*!< I2C control register 0 */
N#define I2C_CTL1(i2cx)                REG32((i2cx) + 0x04U)      /*!< I2C control register 1 */
N#define I2C_SADDR0(i2cx)              REG32((i2cx) + 0x08U)      /*!< I2C slave address register 0*/
N#define I2C_SADDR1(i2cx)              REG32((i2cx) + 0x0CU)      /*!< I2C slave address register */
N#define I2C_DATA(i2cx)                REG32((i2cx) + 0x10U)      /*!< I2C transfer buffer register */
N#define I2C_STAT0(i2cx)               REG32((i2cx) + 0x14U)      /*!< I2C transfer status register 0 */
N#define I2C_STAT1(i2cx)               REG32((i2cx) + 0x18U)      /*!< I2C transfer status register */
N#define I2C_CKCFG(i2cx)               REG32((i2cx) + 0x1CU)      /*!< I2C clock configure register */
N#define I2C_RT(i2cx)                  REG32((i2cx) + 0x20U)      /*!< I2C rise time register */
N
N/* bits definitions */
N/* I2Cx_CTL0 */
N#define I2C_CTL0_I2CEN                BIT(0)        /*!< peripheral enable */
N#define I2C_CTL0_SMBEN                BIT(1)        /*!< SMBus mode */
N#define I2C_CTL0_SMBSEL               BIT(3)        /*!< SMBus type */
N#define I2C_CTL0_ARPEN                BIT(4)        /*!< ARP enable */
N#define I2C_CTL0_PECEN                BIT(5)        /*!< PEC enable */
N#define I2C_CTL0_GCEN                 BIT(6)        /*!< general call enable */
N#define I2C_CTL0_SS                   BIT(7)        /*!< clock stretching disable (slave mode) */
N#define I2C_CTL0_START                BIT(8)        /*!< start generation */
N#define I2C_CTL0_STOP                 BIT(9)        /*!< stop generation */
N#define I2C_CTL0_ACKEN                BIT(10)       /*!< acknowledge enable */
N#define I2C_CTL0_POAP                 BIT(11)       /*!< acknowledge/PEC position (for data reception) */
N#define I2C_CTL0_PECTRANS             BIT(12)       /*!< packet error checking */
N#define I2C_CTL0_SALT                 BIT(13)       /*!< SMBus alert */
N#define I2C_CTL0_SRESET               BIT(15)       /*!< software reset */
N
N/* I2Cx_CTL1 */
N#define I2C_CTL1_I2CCLK               BITS(0,5)     /*!< I2CCLK[5:0] bits (peripheral clock frequency) */
N#define I2C_CTL1_ERRIE                BIT(8)        /*!< error interrupt enable */
N#define I2C_CTL1_EVIE                 BIT(9)        /*!< event interrupt enable */
N#define I2C_CTL1_BUFIE                BIT(10)       /*!< buffer interrupt enable */
N#define I2C_CTL1_DMAON                BIT(11)       /*!< DMA requests enable */
N#define I2C_CTL1_DMALST               BIT(12)       /*!< DMA last transfer */
N
N/* I2Cx_SADDR0 */
N#define I2C_SADDR0_ADDRESS0           BIT(0)        /*!< bit 0 of a 10-bit address */
N#define I2C_SADDR0_ADDRESS            BITS(1,7)     /*!< 7-bit address or bits 7:1 of a 10-bit address */
N#define I2C_SADDR0_ADDRESS_H          BITS(8,9)     /*!< highest two bits of a 10-bit address */
N#define I2C_SADDR0_ADDFORMAT          BIT(15)       /*!< address mode for the I2C slave */
N
N/* I2Cx_SADDR1 */
N#define I2C_SADDR1_DUADEN             BIT(0)        /*!< aual-address mode switch */
N#define I2C_SADDR1_ADDRESS2           BITS(1,7)     /*!< second I2C address for the slave in dual-address mode */
N
N/* I2Cx_DATA */
N#define I2C_DATA_TRB                  BITS(0,7)     /*!< 8-bit data register */
N
N/* I2Cx_STAT0 */
N#define I2C_STAT0_SBSEND              BIT(0)        /*!< start bit (master mode) */
N#define I2C_STAT0_ADDSEND             BIT(1)        /*!< address sent (master mode)/matched (slave mode) */
N#define I2C_STAT0_BTC                 BIT(2)        /*!< byte transfer finished */
N#define I2C_STAT0_ADD10SEND           BIT(3)        /*!< 10-bit header sent (master mode) */
N#define I2C_STAT0_STPDET              BIT(4)        /*!< stop detection (slave mode) */
N#define I2C_STAT0_RBNE                BIT(6)        /*!< data register not empty (receivers) */
N#define I2C_STAT0_TBE                 BIT(7)        /*!< data register empty (transmitters) */
N#define I2C_STAT0_BERR                BIT(8)        /*!< bus error */
N#define I2C_STAT0_LOSTARB             BIT(9)        /*!< arbitration lost (master mode) */
N#define I2C_STAT0_AERR                BIT(10)       /*!< acknowledge failure */
N#define I2C_STAT0_OUERR               BIT(11)       /*!< overrun/underrun */
N#define I2C_STAT0_PECERR              BIT(12)       /*!< PEC error in reception */
N#define I2C_STAT0_SMBTO               BIT(14)       /*!< timeout signal in SMBus mode */
N#define I2C_STAT0_SMBALT              BIT(15)       /*!< SMBus alert status */
N
N/* I2Cx_STAT1 */
N#define I2C_STAT1_MASTER              BIT(0)        /*!< master/slave */
N#define I2C_STAT1_I2CBSY              BIT(1)        /*!< bus busy */
N#define I2C_STAT1_TR                  BIT(2)        /*!< transmitter/receiver */
N#define I2C_STAT1_RXGC                BIT(4)        /*!< general call address (slave mode) */
N#define I2C_STAT1_DEFSMB              BIT(5)        /*!< SMBus device default address (slave mode) */
N#define I2C_STAT1_HSTSMB              BIT(6)        /*!< SMBus host header (slave mode) */
N#define I2C_STAT1_DUMODF              BIT(7)        /*!< dual flag (slave mode) */
N#define I2C_STAT1_PECV                BITS(8,15)    /*!< packet error checking value */
N
N/* I2Cx_CKCFG */
N#define I2C_CKCFG_CLKC                BITS(0,11)    /*!< clock control register in fast/standard mode (master mode) */
N#define I2C_CKCFG_DTCY                BIT(14)       /*!< fast mode duty cycle */
N#define I2C_CKCFG_FAST                BIT(15)       /*!< I2C speed selection in master mode */
N
N/* I2Cx_RT */
N#define I2C_RT_RISETIME               BITS(0,5)     /*!< maximum rise time in fast/standard mode (Master mode) */
N
N/* constants definitions */
N/* define the I2C bit position and its register index offset */
N#define I2C_REGIDX_BIT(regidx, bitpos)  (((uint32_t)(regidx) << 6) | (uint32_t)(bitpos))
N#define I2C_REG_VAL(i2cx, offset)       (REG32((i2cx) + (((uint32_t)(offset) & 0xFFFFU) >> 6)))
N#define I2C_BIT_POS(val)                ((uint32_t)(val) & 0x1FU)
N#define I2C_REGIDX_BIT2(regidx, bitpos, regidx2, bitpos2)   (((uint32_t)(regidx2) << 22) | (uint32_t)((bitpos2) << 16)\
N                                                              | (((uint32_t)(regidx) << 6) | (uint32_t)(bitpos)))
X#define I2C_REGIDX_BIT2(regidx, bitpos, regidx2, bitpos2)   (((uint32_t)(regidx2) << 22) | (uint32_t)((bitpos2) << 16)                                                              | (((uint32_t)(regidx) << 6) | (uint32_t)(bitpos)))
N#define I2C_REG_VAL2(i2cx, offset)      (REG32((i2cx) + ((uint32_t)(offset) >> 22)))
N#define I2C_BIT_POS2(val)               (((uint32_t)(val) & 0x1F0000U) >> 16)
N
N/* register offset */
N#define I2C_CTL1_REG_OFFSET           0x04U         /*!< CTL1 register offset */
N#define I2C_STAT0_REG_OFFSET          0x14U         /*!< STAT0 register offset */
N#define I2C_STAT1_REG_OFFSET          0x18U         /*!< STAT1 register offset */
N
N/* I2C flags */
Ntypedef enum
N{
N    /* flags in STAT0 register */
N    I2C_FLAG_SBSEND = I2C_REGIDX_BIT(I2C_STAT0_REG_OFFSET, 0U),                /*!< start condition sent out in master mode */
X    I2C_FLAG_SBSEND = (((uint32_t)(0x14U) << 6) | (uint32_t)(0U)),                 
N    I2C_FLAG_ADDSEND = I2C_REGIDX_BIT(I2C_STAT0_REG_OFFSET, 1U),               /*!< address is sent in master mode or received and matches in slave mode */
X    I2C_FLAG_ADDSEND = (((uint32_t)(0x14U) << 6) | (uint32_t)(1U)),                
N    I2C_FLAG_BTC = I2C_REGIDX_BIT(I2C_STAT0_REG_OFFSET, 2U),                   /*!< byte transmission finishes */
X    I2C_FLAG_BTC = (((uint32_t)(0x14U) << 6) | (uint32_t)(2U)),                    
N    I2C_FLAG_ADD10SEND = I2C_REGIDX_BIT(I2C_STAT0_REG_OFFSET, 3U),             /*!< header of 10-bit address is sent in master mode */
X    I2C_FLAG_ADD10SEND = (((uint32_t)(0x14U) << 6) | (uint32_t)(3U)),              
N    I2C_FLAG_STPDET = I2C_REGIDX_BIT(I2C_STAT0_REG_OFFSET, 4U),                /*!< stop condition detected in slave mode */
X    I2C_FLAG_STPDET = (((uint32_t)(0x14U) << 6) | (uint32_t)(4U)),                 
N    I2C_FLAG_RBNE = I2C_REGIDX_BIT(I2C_STAT0_REG_OFFSET, 6U),                  /*!< I2C_DATA is not Empty during receiving */
X    I2C_FLAG_RBNE = (((uint32_t)(0x14U) << 6) | (uint32_t)(6U)),                   
N    I2C_FLAG_TBE = I2C_REGIDX_BIT(I2C_STAT0_REG_OFFSET, 7U),                   /*!< I2C_DATA is empty during transmitting */
X    I2C_FLAG_TBE = (((uint32_t)(0x14U) << 6) | (uint32_t)(7U)),                    
N    I2C_FLAG_BERR = I2C_REGIDX_BIT(I2C_STAT0_REG_OFFSET, 8U),                  /*!< a bus error occurs indication a unexpected start or stop condition on I2C bus */
X    I2C_FLAG_BERR = (((uint32_t)(0x14U) << 6) | (uint32_t)(8U)),                   
N    I2C_FLAG_LOSTARB = I2C_REGIDX_BIT(I2C_STAT0_REG_OFFSET, 9U),               /*!< arbitration lost in master mode */
X    I2C_FLAG_LOSTARB = (((uint32_t)(0x14U) << 6) | (uint32_t)(9U)),                
N    I2C_FLAG_AERR = I2C_REGIDX_BIT(I2C_STAT0_REG_OFFSET, 10U),                 /*!< acknowledge error */
X    I2C_FLAG_AERR = (((uint32_t)(0x14U) << 6) | (uint32_t)(10U)),                  
N    I2C_FLAG_OUERR = I2C_REGIDX_BIT(I2C_STAT0_REG_OFFSET, 11U),                /*!< over-run or under-run situation occurs in slave mode */
X    I2C_FLAG_OUERR = (((uint32_t)(0x14U) << 6) | (uint32_t)(11U)),                 
N    I2C_FLAG_PECERR = I2C_REGIDX_BIT(I2C_STAT0_REG_OFFSET, 12U),               /*!< PEC error when receiving data */
X    I2C_FLAG_PECERR = (((uint32_t)(0x14U) << 6) | (uint32_t)(12U)),                
N    I2C_FLAG_SMBTO = I2C_REGIDX_BIT(I2C_STAT0_REG_OFFSET, 14U),                /*!< timeout signal in SMBus mode */
X    I2C_FLAG_SMBTO = (((uint32_t)(0x14U) << 6) | (uint32_t)(14U)),                 
N    I2C_FLAG_SMBALT = I2C_REGIDX_BIT(I2C_STAT0_REG_OFFSET, 15U),               /*!< SMBus alert status */
X    I2C_FLAG_SMBALT = (((uint32_t)(0x14U) << 6) | (uint32_t)(15U)),                
N    /* flags in STAT1 register */
N    I2C_FLAG_MASTER = I2C_REGIDX_BIT(I2C_STAT1_REG_OFFSET, 0U),                /*!< a flag indicating whether I2C block is in master or slave mode */
X    I2C_FLAG_MASTER = (((uint32_t)(0x18U) << 6) | (uint32_t)(0U)),                 
N    I2C_FLAG_I2CBSY = I2C_REGIDX_BIT(I2C_STAT1_REG_OFFSET, 1U),                /*!< busy flag */
X    I2C_FLAG_I2CBSY = (((uint32_t)(0x18U) << 6) | (uint32_t)(1U)),                 
N    I2C_FLAG_TRS = I2C_REGIDX_BIT(I2C_STAT1_REG_OFFSET, 2U),                   /*!< whether the I2C is a transmitter or a receiver */
X    I2C_FLAG_TRS = (((uint32_t)(0x18U) << 6) | (uint32_t)(2U)),                    
N    I2C_FLAG_RXGC = I2C_REGIDX_BIT(I2C_STAT1_REG_OFFSET, 4U),                  /*!< general call address (00h) received */
X    I2C_FLAG_RXGC = (((uint32_t)(0x18U) << 6) | (uint32_t)(4U)),                   
N    I2C_FLAG_DEFSMB = I2C_REGIDX_BIT(I2C_STAT1_REG_OFFSET, 5U),                /*!< default address of SMBus device */
X    I2C_FLAG_DEFSMB = (((uint32_t)(0x18U) << 6) | (uint32_t)(5U)),                 
N    I2C_FLAG_HSTSMB = I2C_REGIDX_BIT(I2C_STAT1_REG_OFFSET, 6U),                /*!< SMBus host header detected in slave mode */
X    I2C_FLAG_HSTSMB = (((uint32_t)(0x18U) << 6) | (uint32_t)(6U)),                 
N    I2C_FLAG_DUMOD = I2C_REGIDX_BIT(I2C_STAT1_REG_OFFSET, 7U),                 /*!< dual flag in slave mode indicating which address is matched in dual-address mode */
X    I2C_FLAG_DUMOD = (((uint32_t)(0x18U) << 6) | (uint32_t)(7U)),                  
N}i2c_flag_enum;
N
N/* I2C interrupt flags */
Ntypedef enum
N{
N    /* interrupt flags in CTL1 register */
N    I2C_INT_FLAG_SBSEND = I2C_REGIDX_BIT2(I2C_CTL1_REG_OFFSET, 9U, I2C_STAT0_REG_OFFSET, 0U),        /*!< start condition sent out in master mode interrupt flag */
X    I2C_INT_FLAG_SBSEND = (((uint32_t)(0x14U) << 22) | (uint32_t)((0U) << 16) | (((uint32_t)(0x04U) << 6) | (uint32_t)(9U))),         
N    I2C_INT_FLAG_ADDSEND = I2C_REGIDX_BIT2(I2C_CTL1_REG_OFFSET, 9U, I2C_STAT0_REG_OFFSET, 1U),       /*!< address is sent in master mode or received and matches in slave mode interrupt flag */
X    I2C_INT_FLAG_ADDSEND = (((uint32_t)(0x14U) << 22) | (uint32_t)((1U) << 16) | (((uint32_t)(0x04U) << 6) | (uint32_t)(9U))),        
N    I2C_INT_FLAG_BTC =  I2C_REGIDX_BIT2(I2C_CTL1_REG_OFFSET, 9U, I2C_STAT0_REG_OFFSET, 2U),          /*!< byte transmission finishes */
X    I2C_INT_FLAG_BTC =  (((uint32_t)(0x14U) << 22) | (uint32_t)((2U) << 16) | (((uint32_t)(0x04U) << 6) | (uint32_t)(9U))),           
N    I2C_INT_FLAG_ADD10SEND =  I2C_REGIDX_BIT2(I2C_CTL1_REG_OFFSET, 9U, I2C_STAT0_REG_OFFSET, 3U),    /*!< header of 10-bit address is sent in master mode interrupt flag */
X    I2C_INT_FLAG_ADD10SEND =  (((uint32_t)(0x14U) << 22) | (uint32_t)((3U) << 16) | (((uint32_t)(0x04U) << 6) | (uint32_t)(9U))),     
N    I2C_INT_FLAG_STPDET = I2C_REGIDX_BIT2(I2C_CTL1_REG_OFFSET, 9U, I2C_STAT0_REG_OFFSET, 4U),        /*!< stop condition detected in slave mode interrupt flag */
X    I2C_INT_FLAG_STPDET = (((uint32_t)(0x14U) << 22) | (uint32_t)((4U) << 16) | (((uint32_t)(0x04U) << 6) | (uint32_t)(9U))),         
N    I2C_INT_FLAG_RBNE = I2C_REGIDX_BIT2(I2C_CTL1_REG_OFFSET, 9U, I2C_STAT0_REG_OFFSET, 6U),          /*!< I2C_DATA is not Empty during receiving interrupt flag */
X    I2C_INT_FLAG_RBNE = (((uint32_t)(0x14U) << 22) | (uint32_t)((6U) << 16) | (((uint32_t)(0x04U) << 6) | (uint32_t)(9U))),           
N    I2C_INT_FLAG_TBE = I2C_REGIDX_BIT2(I2C_CTL1_REG_OFFSET, 9U, I2C_STAT0_REG_OFFSET, 7U),           /*!< I2C_DATA is empty during transmitting interrupt flag */    
X    I2C_INT_FLAG_TBE = (((uint32_t)(0x14U) << 22) | (uint32_t)((7U) << 16) | (((uint32_t)(0x04U) << 6) | (uint32_t)(9U))),                
N    I2C_INT_FLAG_BERR = I2C_REGIDX_BIT2(I2C_CTL1_REG_OFFSET, 8U, I2C_STAT0_REG_OFFSET, 8U),          /*!< a bus error occurs indication a unexpected start or stop condition on I2C bus interrupt flag */
X    I2C_INT_FLAG_BERR = (((uint32_t)(0x14U) << 22) | (uint32_t)((8U) << 16) | (((uint32_t)(0x04U) << 6) | (uint32_t)(8U))),           
N    I2C_INT_FLAG_LOSTARB = I2C_REGIDX_BIT2(I2C_CTL1_REG_OFFSET, 8U, I2C_STAT0_REG_OFFSET, 9U),       /*!< arbitration lost in master mode interrupt flag */
X    I2C_INT_FLAG_LOSTARB = (((uint32_t)(0x14U) << 22) | (uint32_t)((9U) << 16) | (((uint32_t)(0x04U) << 6) | (uint32_t)(8U))),        
N    I2C_INT_FLAG_AERR = I2C_REGIDX_BIT2(I2C_CTL1_REG_OFFSET, 8U, I2C_STAT0_REG_OFFSET, 10U),         /*!< acknowledge error interrupt flag */
X    I2C_INT_FLAG_AERR = (((uint32_t)(0x14U) << 22) | (uint32_t)((10U) << 16) | (((uint32_t)(0x04U) << 6) | (uint32_t)(8U))),          
N    I2C_INT_FLAG_OUERR = I2C_REGIDX_BIT2(I2C_CTL1_REG_OFFSET, 8U, I2C_STAT0_REG_OFFSET, 11U),        /*!< over-run or under-run situation occurs in slave mode interrupt flag */
X    I2C_INT_FLAG_OUERR = (((uint32_t)(0x14U) << 22) | (uint32_t)((11U) << 16) | (((uint32_t)(0x04U) << 6) | (uint32_t)(8U))),         
N    I2C_INT_FLAG_PECERR = I2C_REGIDX_BIT2(I2C_CTL1_REG_OFFSET, 8U, I2C_STAT0_REG_OFFSET, 12U),       /*!< PEC error when receiving data interrupt flag */
X    I2C_INT_FLAG_PECERR = (((uint32_t)(0x14U) << 22) | (uint32_t)((12U) << 16) | (((uint32_t)(0x04U) << 6) | (uint32_t)(8U))),        
N    I2C_INT_FLAG_SMBTO = I2C_REGIDX_BIT2(I2C_CTL1_REG_OFFSET, 8U, I2C_STAT0_REG_OFFSET, 14U),        /*!< timeout signal in SMBus mode interrupt flag */
X    I2C_INT_FLAG_SMBTO = (((uint32_t)(0x14U) << 22) | (uint32_t)((14U) << 16) | (((uint32_t)(0x04U) << 6) | (uint32_t)(8U))),         
N    I2C_INT_FLAG_SMBALT = I2C_REGIDX_BIT2(I2C_CTL1_REG_OFFSET, 8U, I2C_STAT0_REG_OFFSET, 15U),       /*!< SMBus Alert status interrupt flag */
X    I2C_INT_FLAG_SMBALT = (((uint32_t)(0x14U) << 22) | (uint32_t)((15U) << 16) | (((uint32_t)(0x04U) << 6) | (uint32_t)(8U))),        
N}i2c_interrupt_flag_enum;
N
N/* I2C interrupt enable or disable */
Ntypedef enum
N{
N    /* interrupt in CTL1 register */
N    I2C_INT_ERR = I2C_REGIDX_BIT(I2C_CTL1_REG_OFFSET, 8U),                     /*!< error interrupt enable */
X    I2C_INT_ERR = (((uint32_t)(0x04U) << 6) | (uint32_t)(8U)),                      
N    I2C_INT_EV = I2C_REGIDX_BIT(I2C_CTL1_REG_OFFSET, 9U),                      /*!< event interrupt enable */
X    I2C_INT_EV = (((uint32_t)(0x04U) << 6) | (uint32_t)(9U)),                       
N    I2C_INT_BUF = I2C_REGIDX_BIT(I2C_CTL1_REG_OFFSET, 10U),                    /*!< buffer interrupt enable */
X    I2C_INT_BUF = (((uint32_t)(0x04U) << 6) | (uint32_t)(10U)),                     
N}i2c_interrupt_enum;
N
N/* SMBus/I2C mode switch and SMBus type selection */
N#define I2C_I2CMODE_ENABLE            ((uint32_t)0x00000000U)                  /*!< I2C mode */
N#define I2C_SMBUSMODE_ENABLE          I2C_CTL0_SMBEN                           /*!< SMBus mode */
N
N/* SMBus/I2C mode switch and SMBus type selection */
N#define I2C_SMBUS_DEVICE              ((uint32_t)0x00000000U)                  /*!< SMBus mode device type */
N#define I2C_SMBUS_HOST                I2C_CTL0_SMBSEL                          /*!< SMBus mode host type */
N
N/* I2C transfer direction */
N#define I2C_RECEIVER                  ((uint32_t)0x00000001U)                  /*!< receiver */
N#define I2C_TRANSMITTER               ((uint32_t)0xFFFFFFFEU)                  /*!< transmitter */
N
N/* whether or not to send an ACK */
N#define I2C_ACK_DISABLE               ((uint32_t)0x00000000U)                  /*!< ACK will be not sent */
N#define I2C_ACK_ENABLE                ((uint32_t)0x00000001U)                  /*!< ACK will be sent */
N
N/* I2C POAP position*/
N#define I2C_ACKPOS_NEXT               ((uint32_t)0x00000000U)                  /*!< ACKEN bit decides whether or not to send ACK for the next byte */
N#define I2C_ACKPOS_CURRENT            ((uint32_t)0x00000001U)                  /*!< ACKEN bit decides whether or not to send ACK or not for the current byte */
N
N/* I2C dual-address mode switch */
N#define I2C_DUADEN_DISABLE            ((uint32_t)0x00000000U)                  /*!< dual-address mode disabled */
N#define I2C_DUADEN_ENABLE             ((uint32_t)0x00000001U)                  /*!< dual-address mode enabled */
N
N/* whether or not to stretch SCL low */
N#define I2C_SCLSTRETCH_ENABLE         ((uint32_t)0x00000000U)                  /*!< SCL stretching is enabled */
N#define I2C_SCLSTRETCH_DISABLE        I2C_CTL0_SS                              /*!< SCL stretching is disabled */
N
N/* whether or not to response to a general call */
N#define I2C_GCEN_ENABLE               I2C_CTL0_GCEN                            /*!< slave will response to a general call */
N#define I2C_GCEN_DISABLE              ((uint32_t)0x00000000U)                  /*!< slave will not response to a general call */
N
N/* software reset I2C */
N#define I2C_SRESET_SET                I2C_CTL0_SRESET                          /*!< I2C is under reset */
N#define I2C_SRESET_RESET              ((uint32_t)0x00000000U)                  /*!< I2C is not under reset */
N
N/* I2C DMA mode configure */
N/* DMA mode switch */
N#define I2C_DMA_ON                    I2C_CTL1_DMAON                           /*!< DMA mode enabled */
N#define I2C_DMA_OFF                   ((uint32_t)0x00000000U)                  /*!< DMA mode disabled */
N
N/* flag indicating DMA last transfer */
N#define I2C_DMALST_ON                 I2C_CTL1_DMALST                          /*!< next DMA EOT is the last transfer */
N#define I2C_DMALST_OFF                ((uint32_t)0x00000000U)                  /*!< next DMA EOT is not the last transfer */
N
N/* I2C PEC configure */
N/* PEC enable */
N#define I2C_PEC_ENABLE                I2C_CTL0_PECEN                           /*!< PEC calculation on */
N#define I2C_PEC_DISABLE               ((uint32_t)0x00000000U)                  /*!< PEC calculation off */
N
N/* PEC transfer */
N#define I2C_PECTRANS_ENABLE           I2C_CTL0_PECTRANS                        /*!< transfer PEC */
N#define I2C_PECTRANS_DISABLE          ((uint32_t)0x00000000U)                  /*!< not transfer PEC value */
N
N/* I2C SMBus configure */
N/* issue or not alert through SMBA pin */
N#define I2C_SALTSEND_ENABLE           I2C_CTL0_SALT                            /*!< issue alert through SMBA pin */
N#define I2C_SALTSEND_DISABLE          ((uint32_t)0x00000000U)                  /*!< not issue alert through SMBA */
N
N/* ARP protocol in SMBus switch */
N#define I2C_ARP_ENABLE                I2C_CTL0_ARPEN                           /*!< ARP is enabled */
N#define I2C_ARP_DISABLE               ((uint32_t)0x00000000U)                  /*!< ARP is disabled */
N
N/* transmit I2C data */
N#define DATA_TRANS(regval)            (BITS(0,7) & ((uint32_t)(regval) << 0))
N
N/* receive I2C data */
N#define DATA_RECV(regval)             GET_BITS((uint32_t)(regval), 0, 7)
N
N/* I2C duty cycle in fast mode */
N#define I2C_DTCY_2                    ((uint32_t)0x00000000U)                  /*!< I2C fast mode Tlow/Thigh = 2 */
N#define I2C_DTCY_16_9                 I2C_CKCFG_DTCY                           /*!< I2C fast mode Tlow/Thigh = 16/9 */
N
N/* address mode for the I2C slave */
N#define I2C_ADDFORMAT_7BITS           ((uint32_t)0x00000000U)                  /*!< address:7 bits */
N#define I2C_ADDFORMAT_10BITS          I2C_SADDR0_ADDFORMAT                     /*!< address:10 bits */
N
N/* function declarations */
N/* reset I2C */
Nvoid i2c_deinit(uint32_t i2c_periph);
N/* configure I2C clock */
Nvoid i2c_clock_config(uint32_t i2c_periph, uint32_t clkspeed, uint32_t dutycyc);
N/* configure I2C address */
Nvoid i2c_mode_addr_config(uint32_t i2c_periph, uint32_t mode, uint32_t addformat, uint32_t addr);
N/* SMBus type selection */
Nvoid i2c_smbus_type_config(uint32_t i2c_periph, uint32_t type);
N/* whether or not to send an ACK */
Nvoid i2c_ack_config(uint32_t i2c_periph, uint32_t ack);
N/* configure I2C POAP position */
Nvoid i2c_ackpos_config(uint32_t i2c_periph, uint32_t pos);
N/* master sends slave address */
Nvoid i2c_master_addressing(uint32_t i2c_periph, uint32_t addr, uint32_t trandirection);
N/* enable dual-address mode */
Nvoid i2c_dualaddr_enable(uint32_t i2c_periph, uint32_t addr);
N/* disable dual-address mode */
Nvoid i2c_dualaddr_disable(uint32_t i2c_periph);
N/* enable I2C */
Nvoid i2c_enable(uint32_t i2c_periph);
N/* disable I2C */
Nvoid i2c_disable(uint32_t i2c_periph);
N
N/* generate a START condition on I2C bus */
Nvoid i2c_start_on_bus(uint32_t i2c_periph);
N/* generate a STOP condition on I2C bus */
Nvoid i2c_stop_on_bus(uint32_t i2c_periph);
N/* I2C transmit data function */
Nvoid i2c_data_transmit(uint32_t i2c_periph, uint8_t data);
N/* I2C receive data function */
Nuint8_t i2c_data_receive(uint32_t i2c_periph);
N/* enable I2C DMA mode */
Nvoid i2c_dma_enable(uint32_t i2c_periph, uint32_t dmastate);
N/* configure whether next DMA EOT is DMA last transfer or not */
Nvoid i2c_dma_last_transfer_config(uint32_t i2c_periph, uint32_t dmalast);
N/* whether to stretch SCL low when data is not ready in slave mode */
Nvoid i2c_stretch_scl_low_config(uint32_t i2c_periph, uint32_t stretchpara);
N/* whether or not to response to a general call */
Nvoid i2c_slave_response_to_gcall_config(uint32_t i2c_periph, uint32_t gcallpara);
N/* software reset I2C */
Nvoid i2c_software_reset_config(uint32_t i2c_periph, uint32_t sreset);
N
N/* I2C PEC calculation on or off */
Nvoid i2c_pec_enable(uint32_t i2c_periph, uint32_t pecstate);
N/* I2C whether to transfer PEC value */
Nvoid i2c_pec_transfer_enable(uint32_t i2c_periph, uint32_t pecpara);
N/* packet error checking value */
Nuint8_t i2c_pec_value_get(uint32_t i2c_periph);
N/* I2C issue alert through SMBA pin */
Nvoid i2c_smbus_issue_alert(uint32_t i2c_periph, uint32_t smbuspara);
N/* I2C ARP protocol in SMBus switch */
Nvoid i2c_smbus_arp_enable(uint32_t i2c_periph, uint32_t arpstate);
N
N/* check I2C flag is set or not */
NFlagStatus i2c_flag_get(uint32_t i2c_periph, i2c_flag_enum flag);
N/* clear I2C flag */
Nvoid i2c_flag_clear(uint32_t i2c_periph, i2c_flag_enum flag);
N/* enable I2C interrupt */
Nvoid i2c_interrupt_enable(uint32_t i2c_periph, i2c_interrupt_enum interrupt);
N/* disable I2C interrupt */
Nvoid i2c_interrupt_disable(uint32_t i2c_periph, i2c_interrupt_enum interrupt);
N/* check I2C interrupt flag */
NFlagStatus i2c_interrupt_flag_get(uint32_t i2c_periph, i2c_interrupt_flag_enum int_flag);
N/* clear I2C interrupt flag */
Nvoid i2c_interrupt_flag_clear(uint32_t i2c_periph, i2c_interrupt_flag_enum int_flag);
N
N#endif /* GD32E10X_I2C_H */
L 59 ".\User\gd32f10x_libopt.h" 2
N#include "gd32f10x_spi.h"
L 1 ".\Libraries\inc\gd32f10x_spi.h" 1
N/*!
N    \file    gd32f10x_spi.h
N    \brief   definitions for the SPI
N
N    \version 2014-12-26, V1.0.0, firmware for GD32F10x
N    \version 2017-06-20, V2.0.0, firmware for GD32F10x
N    \version 2018-07-31, V2.1.0, firmware for GD32F10x
N*/
N
N/*
N    Copyright (c) 2018, GigaDevice Semiconductor Inc.
N
N    All rights reserved.
N
N    Redistribution and use in source and binary forms, with or without modification, 
Nare permitted provided that the following conditions are met:
N
N    1. Redistributions of source code must retain the above copyright notice, this 
N       list of conditions and the following disclaimer.
N    2. Redistributions in binary form must reproduce the above copyright notice, 
N       this list of conditions and the following disclaimer in the documentation 
N       and/or other materials provided with the distribution.
N    3. Neither the name of the copyright holder nor the names of its contributors 
N       may be used to endorse or promote products derived from this software without 
N       specific prior written permission.
N
N    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
NAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
NWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
NIN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
NINDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
NNOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
NPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
NWHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
NARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
NOF SUCH DAMAGE.
N*/
N
N#ifndef GD32F10X_SPI_H
N#define GD32F10X_SPI_H
N
N#include "gd32f10x.h"
N
N/* SPIx(x=0,1,2) definitions */
N#define SPI0                            (SPI_BASE + 0x0000F800U)
N#define SPI1                            SPI_BASE
N#define SPI2                            (SPI_BASE + 0x00000400U)
N
N/* SPI registers definitions */
N#define SPI_CTL0(spix)                  REG32((spix) + 0x00U)                   /*!< SPI control register 0 */
N#define SPI_CTL1(spix)                  REG32((spix) + 0x04U)                   /*!< SPI control register 1*/
N#define SPI_STAT(spix)                  REG32((spix) + 0x08U)                   /*!< SPI status register */
N#define SPI_DATA(spix)                  REG32((spix) + 0x0CU)                   /*!< SPI data register */
N#define SPI_CRCPOLY(spix)               REG32((spix) + 0x10U)                   /*!< SPI CRC polynomial register */
N#define SPI_RCRC(spix)                  REG32((spix) + 0x14U)                   /*!< SPI receive CRC register */
N#define SPI_TCRC(spix)                  REG32((spix) + 0x18U)                   /*!< SPI transmit CRC register */
N#define SPI_I2SCTL(spix)                REG32((spix) + 0x1CU)                   /*!< SPI I2S control register */
N#define SPI_I2SPSC(spix)                REG32((spix) + 0x20U)                   /*!< SPI I2S clock prescaler register */
N
N/* bits definitions */
N/* SPI_CTL0 */
N#define SPI_CTL0_CKPH                   BIT(0)                                  /*!< clock phase selection*/
N#define SPI_CTL0_CKPL                   BIT(1)                                  /*!< clock polarity selection */
N#define SPI_CTL0_MSTMOD                 BIT(2)                                  /*!< master mode enable */
N#define SPI_CTL0_PSC                    BITS(3,5)                               /*!< master clock prescaler selection */
N#define SPI_CTL0_SPIEN                  BIT(6)                                  /*!< SPI enable*/
N#define SPI_CTL0_LF                     BIT(7)                                  /*!< LSB first mode */
N#define SPI_CTL0_SWNSS                  BIT(8)                                  /*!< NSS pin selection in NSS software mode */
N#define SPI_CTL0_SWNSSEN                BIT(9)                                  /*!< NSS software mode selection */
N#define SPI_CTL0_RO                     BIT(10)                                 /*!< receive only */
N#define SPI_CTL0_FF16                   BIT(11)                                 /*!< data frame size */
N#define SPI_CTL0_CRCNT                  BIT(12)                                 /*!< CRC next transfer */
N#define SPI_CTL0_CRCEN                  BIT(13)                                 /*!< CRC calculation enable */
N#define SPI_CTL0_BDOEN                  BIT(14)                                 /*!< bidirectional transmit output enable*/
N#define SPI_CTL0_BDEN                   BIT(15)                                 /*!< bidirectional enable */
N
N/* SPI_CTL1 */
N#define SPI_CTL1_DMAREN                 BIT(0)                                  /*!< receive buffer dma enable */
N#define SPI_CTL1_DMATEN                 BIT(1)                                  /*!< transmit buffer dma enable */
N#define SPI_CTL1_NSSDRV                 BIT(2)                                  /*!< drive NSS output */
N#define SPI_CTL1_ERRIE                  BIT(5)                                  /*!< errors interrupt enable */
N#define SPI_CTL1_RBNEIE                 BIT(6)                                  /*!< receive buffer not empty interrupt enable */
N#define SPI_CTL1_TBEIE                  BIT(7)                                  /*!< transmit buffer empty interrupt enable */
N
N/* SPI_STAT */
N#define SPI_STAT_RBNE                   BIT(0)                                  /*!< receive buffer not empty */
N#define SPI_STAT_TBE                    BIT(1)                                  /*!< transmit buffer empty */
N#define SPI_STAT_I2SCH                  BIT(2)                                  /*!< I2S channel side */
N#define SPI_STAT_TXURERR                BIT(3)                                  /*!< I2S transmission underrun error bit */
N#define SPI_STAT_CRCERR                 BIT(4)                                  /*!< SPI CRC error bit */
N#define SPI_STAT_CONFERR                BIT(5)                                  /*!< SPI configuration error bit */
N#define SPI_STAT_RXORERR                BIT(6)                                  /*!< SPI reception overrun error bit */
N#define SPI_STAT_TRANS                  BIT(7)                                  /*!< transmitting on-going bit */
N
N/* SPI_DATA */
N#define SPI_DATA_DATA                   BITS(0,15)                              /*!< data transfer register */
N
N/* SPI_CRCPOLY */
N#define SPI_CRCPOLY_CPR                 BITS(0,15)                              /*!< CRC polynomial value */
N
N/* SPI_RCRC */
N#define SPI_RCRC_RCR                    BITS(0,15)                              /*!< RX CRC value */
N
N/* SPI_TCRC */
N#define SPI_TCRC_TCR                    BITS(0,15)                              /*!< TX CRC value */
N
N/* SPI_I2SCTL */
N#define SPI_I2SCTL_CHLEN                BIT(0)                                  /*!< channel length */
N#define SPI_I2SCTL_DTLEN                BITS(1,2)                               /*!< data length */
N#define SPI_I2SCTL_CKPL                 BIT(3)                                  /*!< idle state clock polarity */
N#define SPI_I2SCTL_I2SSTD               BITS(4,5)                               /*!< I2S standard selection */
N#define SPI_I2SCTL_PCMSMOD              BIT(7)                                  /*!< PCM frame synchronization mode */
N#define SPI_I2SCTL_I2SOPMOD             BITS(8,9)                               /*!< I2S operation mode */
N#define SPI_I2SCTL_I2SEN                BIT(10)                                 /*!< I2S enable */
N#define SPI_I2SCTL_I2SSEL               BIT(11)                                 /*!< I2S mode selection */
N
N/* SPI_I2SPSC */
N#define SPI_I2SPSC_DIV                  BITS(0,7)                               /*!< dividing factor for the prescaler */
N#define SPI_I2SPSC_OF                   BIT(8)                                  /*!< odd factor for the prescaler */
N#define SPI_I2SPSC_MCKOEN               BIT(9)                                  /*!< I2S MCK output enable */
N
N/* constants definitions */
N/* SPI and I2S parameter struct definitions */
Ntypedef struct
N{   
N    uint32_t device_mode;                                                       /*!< SPI master or slave */
N    uint32_t trans_mode;                                                        /*!< SPI transtype */
N    uint32_t frame_size;                                                        /*!< SPI frame size */
N    uint32_t nss;                                                               /*!< SPI NSS control by handware or software */
N    uint32_t endian;                                                            /*!< SPI big endian or little endian */
N    uint32_t clock_polarity_phase;                                              /*!< SPI clock phase and polarity */
N    uint32_t prescale;                                                          /*!< SPI prescale factor */
N}spi_parameter_struct;
N
N/* SPI mode definitions */
N#define SPI_MASTER                      (SPI_CTL0_MSTMOD | SPI_CTL0_SWNSS)      /*!< SPI as master */
N#define SPI_SLAVE                       ((uint32_t)0x00000000U)                 /*!< SPI as slave */
N
N/* SPI bidirectional transfer direction */
N#define SPI_BIDIRECTIONAL_TRANSMIT      SPI_CTL0_BDOEN                          /*!< SPI work in transmit-only mode */
N#define SPI_BIDIRECTIONAL_RECEIVE       (~SPI_CTL0_BDOEN)                       /*!< SPI work in receive-only mode */
N
N/* SPI transmit type */
N#define SPI_TRANSMODE_FULLDUPLEX        ((uint32_t)0x00000000U)                 /*!< SPI receive and send data at fullduplex communication */
N#define SPI_TRANSMODE_RECEIVEONLY       SPI_CTL0_RO                             /*!< SPI only receive data */
N#define SPI_TRANSMODE_BDRECEIVE         SPI_CTL0_BDEN                           /*!< bidirectional receive data */
N#define SPI_TRANSMODE_BDTRANSMIT        (SPI_CTL0_BDEN | SPI_CTL0_BDOEN)        /*!< bidirectional transmit data*/
N
N/* SPI frame size */
N#define SPI_FRAMESIZE_16BIT             SPI_CTL0_FF16                           /*!< SPI frame size is 16 bits */
N#define SPI_FRAMESIZE_8BIT              ((uint32_t)0x00000000U)                 /*!< SPI frame size is 8 bits */
N
N/* SPI NSS control mode */
N#define SPI_NSS_SOFT                    SPI_CTL0_SWNSSEN                        /*!< SPI NSS control by software */
N#define SPI_NSS_HARD                    ((uint32_t)0x00000000U)                 /*!< SPI NSS control by hardware */
N
N/* SPI transmit way */
N#define SPI_ENDIAN_MSB                  ((uint32_t)0x00000000U)                 /*!< SPI transmit way is big endian: transmit MSB first */
N#define SPI_ENDIAN_LSB                  SPI_CTL0_LF                             /*!< SPI transmit way is little endian: transmit LSB first */
N
N/* SPI clock phase and polarity */
N#define SPI_CK_PL_LOW_PH_1EDGE          ((uint32_t)0x00000000U)                 /*!< SPI clock polarity is low level and phase is first edge */
N#define SPI_CK_PL_HIGH_PH_1EDGE         SPI_CTL0_CKPL                           /*!< SPI clock polarity is high level and phase is first edge */
N#define SPI_CK_PL_LOW_PH_2EDGE          SPI_CTL0_CKPH                           /*!< SPI clock polarity is low level and phase is second edge */
N#define SPI_CK_PL_HIGH_PH_2EDGE         (SPI_CTL0_CKPL | SPI_CTL0_CKPH)         /*!< SPI clock polarity is high level and phase is second edge */
N
N/* SPI clock prescale factor */
N#define CTL0_PSC(regval)                (BITS(3,5) & ((uint32_t)(regval) << 3))
N#define SPI_PSC_2                       CTL0_PSC(0)                             /*!< SPI clock prescale factor is 2 */
N#define SPI_PSC_4                       CTL0_PSC(1)                             /*!< SPI clock prescale factor is 4 */
N#define SPI_PSC_8                       CTL0_PSC(2)                             /*!< SPI clock prescale factor is 8 */
N#define SPI_PSC_16                      CTL0_PSC(3)                             /*!< SPI clock prescale factor is 16 */
N#define SPI_PSC_32                      CTL0_PSC(4)                             /*!< SPI clock prescale factor is 32 */
N#define SPI_PSC_64                      CTL0_PSC(5)                             /*!< SPI clock prescale factor is 64 */
N#define SPI_PSC_128                     CTL0_PSC(6)                             /*!< SPI clock prescale factor is 128 */
N#define SPI_PSC_256                     CTL0_PSC(7)                             /*!< SPI clock prescale factor is 256 */
N
N/* I2S audio sample rate */
N#define I2S_AUDIOSAMPLE_8K              ((uint32_t)8000U)                       /*!< I2S audio sample rate is 8KHz */
N#define I2S_AUDIOSAMPLE_11K             ((uint32_t)11025U)                      /*!< I2S audio sample rate is 11KHz */
N#define I2S_AUDIOSAMPLE_16K             ((uint32_t)16000U)                      /*!< I2S audio sample rate is 16KHz */
N#define I2S_AUDIOSAMPLE_22K             ((uint32_t)22050U)                      /*!< I2S audio sample rate is 22KHz */
N#define I2S_AUDIOSAMPLE_32K             ((uint32_t)32000U)                      /*!< I2S audio sample rate is 32KHz */
N#define I2S_AUDIOSAMPLE_44K             ((uint32_t)44100U)                      /*!< I2S audio sample rate is 44KHz */
N#define I2S_AUDIOSAMPLE_48K             ((uint32_t)48000U)                      /*!< I2S audio sample rate is 48KHz */
N#define I2S_AUDIOSAMPLE_96K             ((uint32_t)96000U)                      /*!< I2S audio sample rate is 96KHz */
N#define I2S_AUDIOSAMPLE_192K            ((uint32_t)192000U)                     /*!< I2S audio sample rate is 192KHz */
N
N/* I2S frame format */
N#define I2SCTL_DTLEN(regval)            (BITS(1,2) & ((uint32_t)(regval) << 1))
N#define I2S_FRAMEFORMAT_DT16B_CH16B     I2SCTL_DTLEN(0)                         /*!< I2S data length is 16 bit and channel length is 16 bit */
N#define I2S_FRAMEFORMAT_DT16B_CH32B     (I2SCTL_DTLEN(0) | SPI_I2SCTL_CHLEN)    /*!< I2S data length is 16 bit and channel length is 32 bit */
N#define I2S_FRAMEFORMAT_DT24B_CH32B     (I2SCTL_DTLEN(1) | SPI_I2SCTL_CHLEN)    /*!< I2S data length is 24 bit and channel length is 32 bit */
N#define I2S_FRAMEFORMAT_DT32B_CH32B     (I2SCTL_DTLEN(2) | SPI_I2SCTL_CHLEN)    /*!< I2S data length is 32 bit and channel length is 32 bit */
N
N/* I2S master clock output */
N#define I2S_MCKOUT_DISABLE              ((uint32_t)0x00000000U)                 /*!< I2S master clock output disable */
N#define I2S_MCKOUT_ENABLE               SPI_I2SPSC_MCKOEN                       /*!< I2S master clock output enable */
N
N/* I2S operation mode */
N#define I2SCTL_I2SOPMOD(regval)         (BITS(8,9) & ((uint32_t)(regval) << 8))
N#define I2S_MODE_SLAVETX                I2SCTL_I2SOPMOD(0)                      /*!< I2S slave transmit mode */
N#define I2S_MODE_SLAVERX                I2SCTL_I2SOPMOD(1)                      /*!< I2S slave receive mode */
N#define I2S_MODE_MASTERTX               I2SCTL_I2SOPMOD(2)                      /*!< I2S master transmit mode */
N#define I2S_MODE_MASTERRX               I2SCTL_I2SOPMOD(3)                      /*!< I2S master receive mode */
N
N/* I2S standard */
N#define I2SCTL_I2SSTD(regval)           (BITS(4,5) & ((uint32_t)(regval) << 4))
N#define I2S_STD_PHILLIPS                I2SCTL_I2SSTD(0)                        /*!< I2S phillips standard */
N#define I2S_STD_MSB                     I2SCTL_I2SSTD(1)                        /*!< I2S MSB standard */
N#define I2S_STD_LSB                     I2SCTL_I2SSTD(2)                        /*!< I2S LSB standard */
N#define I2S_STD_PCMSHORT                I2SCTL_I2SSTD(3)                        /*!< I2S PCM short standard */
N#define I2S_STD_PCMLONG                 (I2SCTL_I2SSTD(3) | SPI_I2SCTL_PCMSMOD) /*!< I2S PCM long standard */
N
N/* I2S clock polarity */
N#define I2S_CKPL_LOW                    ((uint32_t)0x00000000U)                 /*!< I2S clock polarity low level */
N#define I2S_CKPL_HIGH                   SPI_I2SCTL_CKPL                         /*!< I2S clock polarity high level */
N
N/* SPI DMA constants definitions */                                    
N#define SPI_DMA_TRANSMIT                ((uint8_t)0x00U)                        /*!< SPI transmit data use DMA */
N#define SPI_DMA_RECEIVE                 ((uint8_t)0x01U)                        /*!< SPI receive data use DMA */
N
N/* SPI CRC constants definitions */
N#define SPI_CRC_TX                      ((uint8_t)0x00U)                        /*!< SPI transmit CRC value */
N#define SPI_CRC_RX                      ((uint8_t)0x01U)                        /*!< SPI receive CRC value */
N
N/* SPI/I2S interrupt enable/disable constants definitions */
N#define SPI_I2S_INT_TBE                 ((uint8_t)0x00U)                        /*!< transmit buffer empty interrupt */
N#define SPI_I2S_INT_RBNE                ((uint8_t)0x01U)                        /*!< receive buffer not empty interrupt */
N#define SPI_I2S_INT_ERR                 ((uint8_t)0x02U)                        /*!< error interrupt */
N
N/* SPI/I2S interrupt flag constants definitions */
N#define SPI_I2S_INT_FLAG_TBE            ((uint8_t)0x00U)                        /*!< transmit buffer empty interrupt flag */
N#define SPI_I2S_INT_FLAG_RBNE           ((uint8_t)0x01U)                        /*!< receive buffer not empty interrupt flag */
N#define SPI_I2S_INT_FLAG_RXORERR        ((uint8_t)0x02U)                        /*!< overrun interrupt flag */
N#define SPI_INT_FLAG_CONFERR            ((uint8_t)0x03U)                        /*!< config error interrupt flag */
N#define SPI_INT_FLAG_CRCERR             ((uint8_t)0x04U)                        /*!< CRC error interrupt flag */
N#define I2S_INT_FLAG_TXURERR            ((uint8_t)0x05U)                        /*!< underrun error interrupt flag */
N
N/* SPI/I2S flag definitions */                                                  
N#define SPI_FLAG_RBNE                   SPI_STAT_RBNE                           /*!< receive buffer not empty flag */
N#define SPI_FLAG_TBE                    SPI_STAT_TBE                            /*!< transmit buffer empty flag */
N#define SPI_FLAG_CRCERR                 SPI_STAT_CRCERR                         /*!< CRC error flag */
N#define SPI_FLAG_CONFERR                SPI_STAT_CONFERR                        /*!< mode config error flag */
N#define SPI_FLAG_RXORERR                SPI_STAT_RXORERR                        /*!< receive overrun error flag */
N#define SPI_FLAG_TRANS                  SPI_STAT_TRANS                          /*!< transmit on-going flag */
N#define I2S_FLAG_RBNE                   SPI_STAT_RBNE                           /*!< receive buffer not empty flag */
N#define I2S_FLAG_TBE                    SPI_STAT_TBE                            /*!< transmit buffer empty flag */
N#define I2S_FLAG_CH                     SPI_STAT_I2SCH                          /*!< channel side flag */
N#define I2S_FLAG_TXURERR                SPI_STAT_TXURERR                        /*!< underrun error flag */
N#define I2S_FLAG_RXORERR                SPI_STAT_RXORERR                        /*!< overrun error flag */
N#define I2S_FLAG_TRANS                  SPI_STAT_TRANS                          /*!< transmit on-going flag */
N
N/* function declarations */
N/* SPI/I2S deinitialization and initialization functions */
N/* reset SPI and I2S */
Nvoid spi_i2s_deinit(uint32_t spi_periph);
N/* initialize the parameters of SPI struct with the default values */
Nvoid spi_struct_para_init(spi_parameter_struct* spi_struct);
N/* initialize SPI parameter */
Nvoid spi_init(uint32_t spi_periph, spi_parameter_struct* spi_struct);
N/* enable SPI */
Nvoid spi_enable(uint32_t spi_periph);
N/* disable SPI */
Nvoid spi_disable(uint32_t spi_periph);
N
N/* initialize I2S parameter */
Nvoid i2s_init(uint32_t spi_periph,uint32_t mode, uint32_t standard, uint32_t ckpl);
N/* configure I2S prescaler */
Nvoid i2s_psc_config(uint32_t spi_periph, uint32_t audiosample, uint32_t frameformat, uint32_t mckout);
N/* enable I2S */
Nvoid i2s_enable(uint32_t spi_periph);
N/* disable I2S */
Nvoid i2s_disable(uint32_t spi_periph);
N
N/* NSS functions */
N/* enable SPI NSS output */
Nvoid spi_nss_output_enable(uint32_t spi_periph);
N/* disable SPI NSS output */
Nvoid spi_nss_output_disable(uint32_t spi_periph);
N/* SPI NSS pin high level in software mode */
Nvoid spi_nss_internal_high(uint32_t spi_periph);
N/* SPI NSS pin low level in software mode */
Nvoid spi_nss_internal_low(uint32_t spi_periph);
N
N/* DMA communication */
N/* enable SPI DMA */
Nvoid spi_dma_enable(uint32_t spi_periph, uint8_t dma);
N/* disable SPI DMA */
Nvoid spi_dma_disable(uint32_t spi_periph, uint8_t dma);
N
N/* normal mode communication */
N/* configure SPI/I2S data frame format */
Nvoid spi_i2s_data_frame_format_config(uint32_t spi_periph, uint16_t frame_format);
N/* SPI transmit data */
Nvoid spi_i2s_data_transmit(uint32_t spi_periph, uint16_t data);
N/* SPI receive data */
Nuint16_t spi_i2s_data_receive(uint32_t spi_periph);
N/* configure SPI bidirectional transfer direction */
Nvoid spi_bidirectional_transfer_config(uint32_t spi_periph, uint32_t transfer_direction);
N
N/* SPI CRC functions */
N/* set SPI CRC polynomial */
Nvoid spi_crc_polynomial_set(uint32_t spi_periph, uint16_t crc_poly);
N/* get SPI CRC polynomial */
Nuint16_t spi_crc_polynomial_get(uint32_t spi_periph);
N/* turn on SPI CRC function */
Nvoid spi_crc_on(uint32_t spi_periph);
N/* turn off SPI CRC function */
Nvoid spi_crc_off(uint32_t spi_periph);
N/* SPI next data is CRC value */
Nvoid spi_crc_next(uint32_t spi_periph);
N/* get SPI CRC send value or receive value */
Nuint16_t spi_crc_get(uint32_t spi_periph, uint8_t crc);
N
N/* flag and interrupt functions */
N/* enable SPI and I2S interrupt */
Nvoid spi_i2s_interrupt_enable(uint32_t spi_periph, uint8_t interrupt);
N/* disable SPI and I2S interrupt */
Nvoid spi_i2s_interrupt_disable(uint32_t spi_periph, uint8_t interrupt);
N/* get SPI and I2S interrupt status */
NFlagStatus spi_i2s_interrupt_flag_get(uint32_t spi_periph, uint8_t interrupt);
N/* get SPI and I2S flag status */
NFlagStatus spi_i2s_flag_get(uint32_t spi_periph, uint32_t flag);
N/* clear SPI CRC error flag status */
Nvoid spi_crc_error_clear(uint32_t spi_periph);
N
N#endif /* GD32F10X_SPI_H */
L 60 ".\User\gd32f10x_libopt.h" 2
N#include "gd32f10x_sdio.h"
L 1 ".\Libraries\inc\gd32f10x_sdio.h" 1
N/*!
N    \file    gd32f10x_sdio.h
N    \brief   definitions for the SDIO 
N
N    \version 2014-12-26, V1.0.0, firmware for GD32F10x
N    \version 2017-06-20, V2.0.0, firmware for GD32F10x
N    \version 2018-07-31, V2.1.0, firmware for GD32F10x
N*/
N
N/*
N    Copyright (c) 2018, GigaDevice Semiconductor Inc.
N
N    All rights reserved.
N
N    Redistribution and use in source and binary forms, with or without modification, 
Nare permitted provided that the following conditions are met:
N
N    1. Redistributions of source code must retain the above copyright notice, this 
N       list of conditions and the following disclaimer.
N    2. Redistributions in binary form must reproduce the above copyright notice, 
N       this list of conditions and the following disclaimer in the documentation 
N       and/or other materials provided with the distribution.
N    3. Neither the name of the copyright holder nor the names of its contributors 
N       may be used to endorse or promote products derived from this software without 
N       specific prior written permission.
N
N    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
NAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
NWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
NIN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
NINDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
NNOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
NPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
NWHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
NARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
NOF SUCH DAMAGE.
N*/
N
N#ifndef GD32F10X_SDIO_H
N#define GD32F10X_SDIO_H
N
N#include "gd32f10x.h"
N
N/* SDIO definitions */
N#define SDIO                            SDIO_BASE
N
N/* registers definitions */
N#define SDIO_PWRCTL                     REG32(SDIO + 0x00U)    /*!< SDIO power control register */
N#define SDIO_CLKCTL                     REG32(SDIO + 0x04U)    /*!< SDIO clock control register */
N#define SDIO_CMDAGMT                    REG32(SDIO + 0x08U)    /*!< SDIO command argument register */
N#define SDIO_CMDCTL                     REG32(SDIO + 0x0CU)    /*!< SDIO command control register */
N#define SDIO_RSPCMDIDX                  REG32(SDIO + 0x10U)    /*!< SDIO command index response register */
N#define SDIO_RESP0                      REG32(SDIO + 0x14U)    /*!< SDIO response register 0 */
N#define SDIO_RESP1                      REG32(SDIO + 0x18U)    /*!< SDIO response register 1 */
N#define SDIO_RESP2                      REG32(SDIO + 0x1CU)    /*!< SDIO response register 2 */
N#define SDIO_RESP3                      REG32(SDIO + 0x20U)    /*!< SDIO response register 3 */
N#define SDIO_DATATO                     REG32(SDIO + 0x24U)    /*!< SDIO data timeout register */
N#define SDIO_DATALEN                    REG32(SDIO + 0x28U)    /*!< SDIO data length register */
N#define SDIO_DATACTL                    REG32(SDIO + 0x2CU)    /*!< SDIO data control register */
N#define SDIO_DATACNT                    REG32(SDIO + 0x30U)    /*!< SDIO data counter register */
N#define SDIO_STAT                       REG32(SDIO + 0x34U)    /*!< SDIO status register */
N#define SDIO_INTC                       REG32(SDIO + 0x38U)    /*!< SDIO interrupt clear register */
N#define SDIO_INTEN                      REG32(SDIO + 0x3CU)    /*!< SDIO interrupt enable register */
N#define SDIO_FIFOCNT                    REG32(SDIO + 0x48U)    /*!< SDIO FIFO counter register */
N#define SDIO_FIFO                       REG32(SDIO + 0x80U)    /*!< SDIO FIFO data register */
N
N/* bits definitions */
N/* SDIO_PWRCTL */
N#define SDIO_PWRCTL_PWRCTL              BITS(0,1)              /*!< SDIO power control bits */
N
N/* SDIO_CLKCTL */
N#define SDIO_CLKCTL_DIV                 BITS(0,7)              /*!< clock division */
N#define SDIO_CLKCTL_CLKEN               BIT(8)                 /*!< SDIO_CLK clock output enable bit */
N#define SDIO_CLKCTL_CLKPWRSAV           BIT(9)                 /*!< SDIO_CLK clock dynamic switch on/off for power saving */
N#define SDIO_CLKCTL_CLKBYP              BIT(10)                /*!< clock bypass enable bit */
N#define SDIO_CLKCTL_BUSMODE             BITS(11,12)            /*!< SDIO card bus mode control bit */
N#define SDIO_CLKCTL_CLKEDGE             BIT(13)                /*!< SDIO_CLK clock edge selection bit */
N#define SDIO_CLKCTL_HWCLKEN             BIT(14)                /*!< hardware clock control enable bit */
N
N/* SDIO_CMDAGMT */
N#define SDIO_CMDAGMT_CMDAGMT            BITS(0,31)             /*!< SDIO card command argument */
N
N/* SDIO_CMDCTL */
N#define SDIO_CMDCTL_CMDIDX              BITS(0,5)              /*!< command index */
N#define SDIO_CMDCTL_CMDRESP             BITS(6,7)              /*!< command response type bits */
N#define SDIO_CMDCTL_INTWAIT             BIT(8)                 /*!< interrupt wait instead of timeout */
N#define SDIO_CMDCTL_WAITDEND            BIT(9)                 /*!< wait for ends of data transfer */
N#define SDIO_CMDCTL_CSMEN               BIT(10)                /*!< command state machine(CSM) enable bit */
N#define SDIO_CMDCTL_SUSPEND             BIT(11)                /*!< SD I/O suspend command(SD I/O only) */
N#define SDIO_CMDCTL_ENCMDC              BIT(12)                /*!< CMD completion signal enabled (CE-ATA only) */
N#define SDIO_CMDCTL_NINTEN              BIT(13)                /*!< no CE-ATA interrupt (CE-ATA only) */
N#define SDIO_CMDCTL_ATAEN               BIT(14)                /*!< CE-ATA command enable(CE-ATA only) */
N
N/* SDIO_DATATO */
N#define SDIO_DATATO_DATATO              BITS(0,31)             /*!< data timeout period */
N
N/* SDIO_DATALEN */
N#define SDIO_DATALEN_DATALEN            BITS(0,24)             /*!< data transfer length */
N
N/* SDIO_DATACTL */
N#define SDIO_DATACTL_DATAEN             BIT(0)                 /*!< data transfer enabled bit */
N#define SDIO_DATACTL_DATADIR            BIT(1)                 /*!< data transfer direction */
N#define SDIO_DATACTL_TRANSMOD           BIT(2)                 /*!< data transfer mode */
N#define SDIO_DATACTL_DMAEN              BIT(3)                 /*!< DMA enable bit */
N#define SDIO_DATACTL_BLKSZ              BITS(4,7)              /*!< data block size */
N#define SDIO_DATACTL_RWEN               BIT(8)                 /*!< read wait mode enabled(SD I/O only) */
N#define SDIO_DATACTL_RWSTOP             BIT(9)                 /*!< read wait stop(SD I/O only) */
N#define SDIO_DATACTL_RWTYPE             BIT(10)                /*!< read wait type(SD I/O only) */
N#define SDIO_DATACTL_IOEN               BIT(11)                /*!< SD I/O specific function enable(SD I/O only) */
N
N/* SDIO_STAT */
N#define SDIO_STAT_CCRCERR               BIT(0)                 /*!< command response received (CRC check failed) */
N#define SDIO_STAT_DTCRCERR              BIT(1)                 /*!< data block sent/received (CRC check failed) */
N#define SDIO_STAT_CMDTMOUT              BIT(2)                 /*!< command response timeout */
N#define SDIO_STAT_DTTMOUT               BIT(3)                 /*!< data timeout */
N#define SDIO_STAT_TXURE                 BIT(4)                 /*!< transmit FIFO underrun error occurs */
N#define SDIO_STAT_RXORE                 BIT(5)                 /*!< received FIFO overrun error occurs */
N#define SDIO_STAT_CMDRECV               BIT(6)                 /*!< command response received (CRC check passed) */
N#define SDIO_STAT_CMDSEND               BIT(7)                 /*!< command sent (no response required) */
N#define SDIO_STAT_DTEND                 BIT(8)                 /*!< data end (data counter, SDIO_DATACNT, is zero) */
N#define SDIO_STAT_STBITE                BIT(9)                 /*!< start bit error in the bus */
N#define SDIO_STAT_DTBLKEND              BIT(10)                /*!< data block sent/received (CRC check passed) */
N#define SDIO_STAT_CMDRUN                BIT(11)                /*!< command transmission in progress */
N#define SDIO_STAT_TXRUN                 BIT(12)                /*!< data transmission in progress */
N#define SDIO_STAT_RXRUN                 BIT(13)                /*!< data reception in progress */
N#define SDIO_STAT_TFH                   BIT(14)                /*!< transmit FIFO is half empty: at least 8 words can be written into the FIFO */
N#define SDIO_STAT_RFH                   BIT(15)                /*!< receive FIFO is half full: at least 8 words can be read in the FIFO */
N#define SDIO_STAT_TFF                   BIT(16)                /*!< transmit FIFO is full */
N#define SDIO_STAT_RFF                   BIT(17)                /*!< receive FIFO is full */
N#define SDIO_STAT_TFE                   BIT(18)                /*!< transmit FIFO is empty */
N#define SDIO_STAT_RFE                   BIT(19)                /*!< receive FIFO is empty */
N#define SDIO_STAT_TXDTVAL               BIT(20)                /*!< data is valid in transmit FIFO */
N#define SDIO_STAT_RXDTVAL               BIT(21)                /*!< data is valid in receive FIFO */
N#define SDIO_STAT_SDIOINT               BIT(22)                /*!< SD I/O interrupt received */
N#define SDIO_STAT_ATAEND                BIT(23)                /*!< CE-ATA command completion signal received (only for CMD61) */
N
N/* SDIO_INTC */
N#define SDIO_INTC_CCRCERRC              BIT(0)                 /*!< CCRCERR flag clear bit */
N#define SDIO_INTC_DTCRCERRC             BIT(1)                 /*!< DTCRCERR flag clear bit */
N#define SDIO_INTC_CMDTMOUTC             BIT(2)                 /*!< CMDTMOUT flag clear bit */
N#define SDIO_INTC_DTTMOUTC              BIT(3)                 /*!< DTTMOUT flag clear bit */
N#define SDIO_INTC_TXUREC                BIT(4)                 /*!< TXURE flag clear bit */
N#define SDIO_INTC_RXOREC                BIT(5)                 /*!< RXORE flag clear bit */
N#define SDIO_INTC_CMDRECVC              BIT(6)                 /*!< CMDRECV flag clear bit */
N#define SDIO_INTC_CMDSENDC              BIT(7)                 /*!< CMDSEND flag clear bit */
N#define SDIO_INTC_DTENDC                BIT(8)                 /*!< DTEND flag clear bit */
N#define SDIO_INTC_STBITEC               BIT(9)                 /*!< STBITE flag clear bit */
N#define SDIO_INTC_DTBLKENDC             BIT(10)                /*!< DTBLKEND flag clear bit */
N#define SDIO_INTC_SDIOINTC              BIT(22)                /*!< SDIOINT flag clear bit */
N#define SDIO_INTC_ATAENDC               BIT(23)                /*!< ATAEND flag clear bit */
N
N/* SDIO_INTEN */
N#define SDIO_INTEN_CCRCERRIE            BIT(0)                 /*!< command response CRC fail interrupt enable */
N#define SDIO_INTEN_DTCRCERRIE           BIT(1)                 /*!< data CRC fail interrupt enable */
N#define SDIO_INTEN_CMDTMOUTIE           BIT(2)                 /*!< command response timeout interrupt enable */
N#define SDIO_INTEN_DTTMOUTIE            BIT(3)                 /*!< data timeout interrupt enable */
N#define SDIO_INTEN_TXUREIE              BIT(4)                 /*!< transmit FIFO underrun error interrupt enable */
N#define SDIO_INTEN_RXOREIE              BIT(5)                 /*!< received FIFO overrun error interrupt enable */
N#define SDIO_INTEN_CMDRECVIE            BIT(6)                 /*!< command response received interrupt enable */
N#define SDIO_INTEN_CMDSENDIE            BIT(7)                 /*!< command sent interrupt enable */
N#define SDIO_INTEN_DTENDIE              BIT(8)                 /*!< data end interrupt enable */
N#define SDIO_INTEN_STBITEIE             BIT(9)                 /*!< start bit error interrupt enable */
N#define SDIO_INTEN_DTBLKENDIE           BIT(10)                /*!< data block end interrupt enable */
N#define SDIO_INTEN_CMDRUNIE             BIT(11)                /*!< command transmission interrupt enable */
N#define SDIO_INTEN_TXRUNIE              BIT(12)                /*!< data transmission interrupt enable */
N#define SDIO_INTEN_RXRUNIE              BIT(13)                /*!< data reception interrupt enable */
N#define SDIO_INTEN_TFHIE                BIT(14)                /*!< transmit FIFO half empty interrupt enable */
N#define SDIO_INTEN_RFHIE                BIT(15)                /*!< receive FIFO half full interrupt enable */
N#define SDIO_INTEN_TFFIE                BIT(16)                /*!< transmit FIFO full interrupt enable */
N#define SDIO_INTEN_RFFIE                BIT(17)                /*!< receive FIFO full interrupt enable */
N#define SDIO_INTEN_TFEIE                BIT(18)                /*!< transmit FIFO empty interrupt enable */
N#define SDIO_INTEN_RFEIE                BIT(19)                /*!< receive FIFO empty interrupt enable */
N#define SDIO_INTEN_TXDTVALIE            BIT(20)                /*!< data valid in transmit FIFO interrupt enable */
N#define SDIO_INTEN_RXDTVALIE            BIT(21)                /*!< data valid in receive FIFO interrupt enable */
N#define SDIO_INTEN_SDIOINTIE            BIT(22)                /*!< SD I/O interrupt received interrupt enable */
N#define SDIO_INTEN_ATAENDIE             BIT(23)                /*!< CE-ATA command completion signal received interrupt enable */
N
N/* SDIO_FIFO */
N#define SDIO_FIFO_FIFODT                BITS(0,31)             /*!< receive FIFO data or transmit FIFO data */
N
N/* constants definitions */
N/* SDIO flags */
N#define SDIO_FLAG_CCRCERR               BIT(0)                 /*!< command response received (CRC check failed) flag */
N#define SDIO_FLAG_DTCRCERR              BIT(1)                 /*!< data block sent/received (CRC check failed) flag */
N#define SDIO_FLAG_CMDTMOUT              BIT(2)                 /*!< command response timeout flag */
N#define SDIO_FLAG_DTTMOUT               BIT(3)                 /*!< data timeout flag */
N#define SDIO_FLAG_TXURE                 BIT(4)                 /*!< transmit FIFO underrun error occurs flag */
N#define SDIO_FLAG_RXORE                 BIT(5)                 /*!< received FIFO overrun error occurs flag */
N#define SDIO_FLAG_CMDRECV               BIT(6)                 /*!< command response received (CRC check passed) flag */
N#define SDIO_FLAG_CMDSEND               BIT(7)                 /*!< command sent (no response required) flag */
N#define SDIO_FLAG_DTEND                 BIT(8)                 /*!< data end (data counter, SDIO_DATACNT, is zero) flag */
N#define SDIO_FLAG_STBITE                BIT(9)                 /*!< start bit error in the bus flag */
N#define SDIO_FLAG_DTBLKEND              BIT(10)                /*!< data block sent/received (CRC check passed) flag */
N#define SDIO_FLAG_CMDRUN                BIT(11)                /*!< command transmission in progress flag */
N#define SDIO_FLAG_TXRUN                 BIT(12)                /*!< data transmission in progress flag */
N#define SDIO_FLAG_RXRUN                 BIT(13)                /*!< data reception in progress flag */
N#define SDIO_FLAG_TFH                   BIT(14)                /*!< transmit FIFO is half empty flag: at least 8 words can be written into the FIFO */
N#define SDIO_FLAG_RFH                   BIT(15)                /*!< receive FIFO is half full flag: at least 8 words can be read in the FIFO */
N#define SDIO_FLAG_TFF                   BIT(16)                /*!< transmit FIFO is full flag */
N#define SDIO_FLAG_RFF                   BIT(17)                /*!< receive FIFO is full flag */
N#define SDIO_FLAG_TFE                   BIT(18)                /*!< transmit FIFO is empty flag */
N#define SDIO_FLAG_RFE                   BIT(19)                /*!< receive FIFO is empty flag */
N#define SDIO_FLAG_TXDTVAL               BIT(20)                /*!< data is valid in transmit FIFO flag */
N#define SDIO_FLAG_RXDTVAL               BIT(21)                /*!< data is valid in receive FIFO flag */
N#define SDIO_FLAG_SDIOINT               BIT(22)                /*!< SD I/O interrupt received flag */
N#define SDIO_FLAG_ATAEND                BIT(23)                /*!< CE-ATA command completion signal received (only for CMD61) flag */
N
N/* SDIO interrupt enable or disable */
N#define SDIO_INT_CCRCERR                BIT(0)                 /*!< SDIO CCRCERR interrupt */
N#define SDIO_INT_DTCRCERR               BIT(1)                 /*!< SDIO DTCRCERR interrupt */
N#define SDIO_INT_CMDTMOUT               BIT(2)                 /*!< SDIO CMDTMOUT interrupt */
N#define SDIO_INT_DTTMOUT                BIT(3)                 /*!< SDIO DTTMOUT interrupt */
N#define SDIO_INT_TXURE                  BIT(4)                 /*!< SDIO TXURE interrupt */
N#define SDIO_INT_RXORE                  BIT(5)                 /*!< SDIO RXORE interrupt */
N#define SDIO_INT_CMDRECV                BIT(6)                 /*!< SDIO CMDRECV interrupt */
N#define SDIO_INT_CMDSEND                BIT(7)                 /*!< SDIO CMDSEND interrupt */
N#define SDIO_INT_DTEND                  BIT(8)                 /*!< SDIO DTEND interrupt */
N#define SDIO_INT_STBITE                 BIT(9)                 /*!< SDIO STBITE interrupt */
N#define SDIO_INT_DTBLKEND               BIT(10)                /*!< SDIO DTBLKEND interrupt */
N#define SDIO_INT_CMDRUN                 BIT(11)                /*!< SDIO CMDRUN interrupt */
N#define SDIO_INT_TXRUN                  BIT(12)                /*!< SDIO TXRUN interrupt */
N#define SDIO_INT_RXRUN                  BIT(13)                /*!< SDIO RXRUN interrupt */
N#define SDIO_INT_TFH                    BIT(14)                /*!< SDIO TFH interrupt */
N#define SDIO_INT_RFH                    BIT(15)                /*!< SDIO RFH interrupt */
N#define SDIO_INT_TFF                    BIT(16)                /*!< SDIO TFF interrupt */
N#define SDIO_INT_RFF                    BIT(17)                /*!< SDIO RFF interrupt */
N#define SDIO_INT_TFE                    BIT(18)                /*!< SDIO TFE interrupt */
N#define SDIO_INT_RFE                    BIT(19)                /*!< SDIO RFE interrupt */
N#define SDIO_INT_TXDTVAL                BIT(20)                /*!< SDIO TXDTVAL interrupt */
N#define SDIO_INT_RXDTVAL                BIT(21)                /*!< SDIO RXDTVAL interrupt */
N#define SDIO_INT_SDIOINT                BIT(22)                /*!< SDIO SDIOINT interrupt */
N#define SDIO_INT_ATAEND                 BIT(23)                /*!< SDIO ATAEND interrupt */
N
N/* SDIO interrupt flags */
N#define SDIO_INT_FLAG_CCRCERR           BIT(0)                 /*!< SDIO CCRCERR interrupt */
N#define SDIO_INT_FLAG_DTCRCERR          BIT(1)                 /*!< SDIO DTCRCERR interrupt */
N#define SDIO_INT_FLAG_CMDTMOUT          BIT(2)                 /*!< SDIO CMDTMOUT interrupt */
N#define SDIO_INT_FLAG_DTTMOUT           BIT(3)                 /*!< SDIO DTTMOUT interrupt */
N#define SDIO_INT_FLAG_TXURE             BIT(4)                 /*!< SDIO TXURE interrupt */
N#define SDIO_INT_FLAG_RXORE             BIT(5)                 /*!< SDIO RXORE interrupt */
N#define SDIO_INT_FLAG_CMDRECV           BIT(6)                 /*!< SDIO CMDRECV interrupt */
N#define SDIO_INT_FLAG_CMDSEND           BIT(7)                 /*!< SDIO CMDSEND interrupt */
N#define SDIO_INT_FLAG_DTEND             BIT(8)                 /*!< SDIO DTEND interrupt */
N#define SDIO_INT_FLAG_STBITE            BIT(9)                 /*!< SDIO STBITE interrupt */
N#define SDIO_INT_FLAG_DTBLKEND          BIT(10)                /*!< SDIO DTBLKEND interrupt */
N#define SDIO_INT_FLAG_CMDRUN            BIT(11)                /*!< SDIO CMDRUN interrupt */
N#define SDIO_INT_FLAG_TXRUN             BIT(12)                /*!< SDIO TXRUN interrupt */
N#define SDIO_INT_FLAG_RXRUN             BIT(13)                /*!< SDIO RXRUN interrupt */
N#define SDIO_INT_FLAG_TFH               BIT(14)                /*!< SDIO TFH interrupt */
N#define SDIO_INT_FLAG_RFH               BIT(15)                /*!< SDIO RFH interrupt */
N#define SDIO_INT_FLAG_TFF               BIT(16)                /*!< SDIO TFF interrupt */
N#define SDIO_INT_FLAG_RFF               BIT(17)                /*!< SDIO RFF interrupt */
N#define SDIO_INT_FLAG_TFE               BIT(18)                /*!< SDIO TFE interrupt */
N#define SDIO_INT_FLAG_RFE               BIT(19)                /*!< SDIO RFE interrupt */
N#define SDIO_INT_FLAG_TXDTVAL           BIT(20)                /*!< SDIO TXDTVAL interrupt */
N#define SDIO_INT_FLAG_RXDTVAL           BIT(21)                /*!< SDIO RXDTVAL interrupt */
N#define SDIO_INT_FLAG_SDIOINT           BIT(22)                /*!< SDIO SDIOINT interrupt */
N#define SDIO_INT_FLAG_ATAEND            BIT(23)                /*!< SDIO ATAEND interrupt */
N
N/* SDIO power control */
N#define PWRCTL_PWRCTL(regval)           (BITS(0,1) & ((uint32_t)(regval) << 0))
N#define SDIO_POWER_OFF                  PWRCTL_PWRCTL(0)       /*!< SDIO power off */
N#define SDIO_POWER_ON                   PWRCTL_PWRCTL(3)       /*!< SDIO power on */
N
N/* SDIO card bus mode control */
N#define CLKCTL_BUSMODE(regval)          (BITS(11,12) & ((uint32_t)(regval) << 11))
N#define SDIO_BUSMODE_1BIT               CLKCTL_BUSMODE(0)      /*!< 1-bit SDIO card bus mode */
N#define SDIO_BUSMODE_4BIT               CLKCTL_BUSMODE(1)      /*!< 4-bit SDIO card bus mode */
N#define SDIO_BUSMODE_8BIT               CLKCTL_BUSMODE(2)      /*!< 8-bit SDIO card bus mode */
N
N/* SDIO_CLK clock edge selection */
N#define SDIO_SDIOCLKEDGE_RISING         ((uint32_t)0x00000000U)/*!< select the rising edge of the SDIOCLK to generate SDIO_CLK */
N#define SDIO_SDIOCLKEDGE_FALLING        SDIO_CLKCTL_CLKEDGE    /*!< select the falling edge of the SDIOCLK to generate SDIO_CLK */
N
N/* clock bypass enable or disable */
N#define SDIO_CLOCKBYPASS_DISABLE        ((uint32_t)0x00000000U)/*!< no bypass */
N#define SDIO_CLOCKBYPASS_ENABLE         SDIO_CLKCTL_CLKBYP     /*!< clock bypass */
N
N/* SDIO_CLK clock dynamic switch on/off for power saving */
N#define SDIO_CLOCKPWRSAVE_DISABLE       ((uint32_t)0x00000000U)/*!< SDIO_CLK clock is always on */
N#define SDIO_CLOCKPWRSAVE_ENABLE        SDIO_CLKCTL_CLKPWRSAV  /*!< SDIO_CLK closed when bus is idle */
N
N/* SDIO command response type */
N#define CMDCTL_CMDRESP(regval)          (BITS(6,7) & ((uint32_t)(regval) << 6))
N#define SDIO_RESPONSETYPE_NO            CMDCTL_CMDRESP(0)      /*!< no response */
N#define SDIO_RESPONSETYPE_SHORT         CMDCTL_CMDRESP(1)      /*!< short response */
N#define SDIO_RESPONSETYPE_LONG          CMDCTL_CMDRESP(3)      /*!< long response */
N
N/* command state machine wait type */
N#define SDIO_WAITTYPE_NO                ((uint32_t)0x00000000U)/*!< not wait interrupt */
N#define SDIO_WAITTYPE_INTERRUPT         SDIO_CMDCTL_INTWAIT    /*!< wait interrupt */
N#define SDIO_WAITTYPE_DATAEND           SDIO_CMDCTL_WAITDEND   /*!< wait the end of data transfer */
N
N#define SDIO_RESPONSE0                  ((uint32_t)0x00000000U)/*!< card response[31:0]/card response[127:96] */
N#define SDIO_RESPONSE1                  ((uint32_t)0x00000001U)/*!< card response[95:64] */
N#define SDIO_RESPONSE2                  ((uint32_t)0x00000002U)/*!< card response[63:32] */
N#define SDIO_RESPONSE3                  ((uint32_t)0x00000003U)/*!< card response[31:1], plus bit 0 */
N
N/* SDIO data block size */
N#define DATACTL_BLKSZ(regval)           (BITS(4,7) & ((uint32_t)(regval) << 4))
N#define SDIO_DATABLOCKSIZE_1BYTE        DATACTL_BLKSZ(0)       /*!< block size = 1 byte */
N#define SDIO_DATABLOCKSIZE_2BYTES       DATACTL_BLKSZ(1)       /*!< block size = 2 bytes */
N#define SDIO_DATABLOCKSIZE_4BYTES       DATACTL_BLKSZ(2)       /*!< block size = 4 bytes */
N#define SDIO_DATABLOCKSIZE_8BYTES       DATACTL_BLKSZ(3)       /*!< block size = 8 bytes */
N#define SDIO_DATABLOCKSIZE_16BYTES      DATACTL_BLKSZ(4)       /*!< block size = 16 bytes */
N#define SDIO_DATABLOCKSIZE_32BYTES      DATACTL_BLKSZ(5)       /*!< block size = 32 bytes */
N#define SDIO_DATABLOCKSIZE_64BYTES      DATACTL_BLKSZ(6)       /*!< block size = 64 bytes */
N#define SDIO_DATABLOCKSIZE_128BYTES     DATACTL_BLKSZ(7)       /*!< block size = 128 bytes */
N#define SDIO_DATABLOCKSIZE_256BYTES     DATACTL_BLKSZ(8)       /*!< block size = 256 bytes */
N#define SDIO_DATABLOCKSIZE_512BYTES     DATACTL_BLKSZ(9)       /*!< block size = 512 bytes */
N#define SDIO_DATABLOCKSIZE_1024BYTES    DATACTL_BLKSZ(10)      /*!< block size = 1024 bytes */
N#define SDIO_DATABLOCKSIZE_2048BYTES    DATACTL_BLKSZ(11)      /*!< block size = 2048 bytes */
N#define SDIO_DATABLOCKSIZE_4096BYTES    DATACTL_BLKSZ(12)      /*!< block size = 4096 bytes */
N#define SDIO_DATABLOCKSIZE_8192BYTES    DATACTL_BLKSZ(13)      /*!< block size = 8192 bytes */
N#define SDIO_DATABLOCKSIZE_16384BYTES   DATACTL_BLKSZ(14)      /*!< block size = 16384 bytes */
N
N/* SDIO data transfer mode */
N#define SDIO_TRANSMODE_BLOCK            ((uint32_t)0x00000000U)/*!< block transfer */
N#define SDIO_TRANSMODE_STREAM           SDIO_DATACTL_TRANSMOD  /*!< stream transfer or SDIO multibyte transfer */
N
N/* SDIO data transfer direction */
N#define SDIO_TRANSDIRECTION_TOCARD      ((uint32_t)0x00000000U)/*!< write data to card */
N#define SDIO_TRANSDIRECTION_TOSDIO      SDIO_DATACTL_DATADIR   /*!< read data from card */
N
N/* SDIO read wait type */
N#define SDIO_READWAITTYPE_DAT2          ((uint32_t)0x00000000U)/*!< read wait control using SDIO_DAT[2] */
N#define SDIO_READWAITTYPE_CLK           SDIO_DATACTL_RWTYPE    /*!< read wait control by stopping SDIO_CLK */
N
N/* function declarations */
N/* deinitialize the SDIO */
Nvoid sdio_deinit(void);
N/* configure the SDIO clock */
Nvoid sdio_clock_config(uint32_t clock_edge, uint32_t clock_bypass, uint32_t clock_powersave, uint16_t clock_division);
N/* enable hardware clock control */
Nvoid sdio_hardware_clock_enable(void);
N/* disable hardware clock control */
Nvoid sdio_hardware_clock_disable(void);
N/* set different SDIO card bus mode */
Nvoid sdio_bus_mode_set(uint32_t bus_mode);
N/* set the SDIO power state */
Nvoid sdio_power_state_set(uint32_t power_state);
N/* get the SDIO power state */
Nuint32_t sdio_power_state_get(void);
N/* enable SDIO_CLK clock output */
Nvoid sdio_clock_enable(void);
N/* disable SDIO_CLK clock output */
Nvoid sdio_clock_disable(void);
N
N/* configure the command index, argument, response type, wait type and CSM to send command */
N/* configure the command and response */
Nvoid sdio_command_response_config(uint32_t cmd_index, uint32_t cmd_argument, uint32_t response_type);
N/* set the command state machine wait type */
Nvoid sdio_wait_type_set(uint32_t wait_type);
N/* enable the CSM(command state machine) */
Nvoid sdio_csm_enable(void);
N/* disable the CSM(command state machine) */
Nvoid sdio_csm_disable(void);
N/* get the last response command index */
Nuint8_t sdio_command_index_get(void);
N/* get the response for the last received command */
Nuint32_t sdio_response_get(uint32_t responsex);
N
N/* configure the data timeout, length, block size, transfer mode, direction and DSM for data transfer */
N/* configure the data timeout, data length and data block size */
Nvoid sdio_data_config(uint32_t data_timeout, uint32_t data_length, uint32_t data_blocksize);
N/* configure the data transfer mode and direction */
Nvoid sdio_data_transfer_config(uint32_t transfer_mode, uint32_t transfer_direction);
N/* enable the DSM(data state machine) for data transfer */
Nvoid sdio_dsm_enable(void);
N/* disable the DSM(data state machine) */
Nvoid sdio_dsm_disable(void);
N/* write data(one word) to the transmit FIFO */
Nvoid sdio_data_write(uint32_t data);
N/* read data(one word) from the receive FIFO */
Nuint32_t sdio_data_read(void);
N/* get the number of remaining data bytes to be transferred to card */
Nuint32_t sdio_data_counter_get(void);
N/* get the number of words remaining to be written or read from FIFO */
Nuint32_t sdio_fifo_counter_get(void);
N/* enable the DMA request for SDIO */
Nvoid sdio_dma_enable(void);
N/* disable the DMA request for SDIO */
Nvoid sdio_dma_disable(void);
N
N/* get the flags state of SDIO */
NFlagStatus sdio_flag_get(uint32_t flag);
N/* clear the pending flags of SDIO */
Nvoid sdio_flag_clear(uint32_t flag);
N/* enable the SDIO interrupt */
Nvoid sdio_interrupt_enable(uint32_t int_flag);
N/* disable the SDIO interrupt */
Nvoid sdio_interrupt_disable(uint32_t int_flag);
N/* get the interrupt flags state of SDIO */
NFlagStatus sdio_interrupt_flag_get(uint32_t int_flag);
N/* clear the interrupt pending flags of SDIO */
Nvoid sdio_interrupt_flag_clear(uint32_t int_flag);
N
N/* enable the read wait mode(SD I/O only) */
Nvoid sdio_readwait_enable(void);
N/* disable the read wait mode(SD I/O only) */
Nvoid sdio_readwait_disable(void);
N/* enable the function that stop the read wait process(SD I/O only) */
Nvoid sdio_stop_readwait_enable(void);
N/* disable the function that stop the read wait process(SD I/O only) */
Nvoid sdio_stop_readwait_disable(void);
N/* set the read wait type(SD I/O only) */
Nvoid sdio_readwait_type_set(uint32_t readwait_type);
N/* enable the SD I/O mode specific operation(SD I/O only) */
Nvoid sdio_operation_enable(void);
N/* disable the SD I/O mode specific operation(SD I/O only) */
Nvoid sdio_operation_disable(void);
N/* enable the SD I/O suspend operation(SD I/O only) */
Nvoid sdio_suspend_enable(void);
N/* disable the SD I/O suspend operation(SD I/O only) */
Nvoid sdio_suspend_disable(void);
N
N/* enable the CE-ATA command(CE-ATA only) */
Nvoid sdio_ceata_command_enable(void);
N/* disable the CE-ATA command(CE-ATA only) */
Nvoid sdio_ceata_command_disable(void);
N/* enable the CE-ATA interrupt(CE-ATA only) */
Nvoid sdio_ceata_interrupt_enable(void);
N/* disable the CE-ATA interrupt(CE-ATA only) */
Nvoid sdio_ceata_interrupt_disable(void);
N/* enable the CE-ATA command completion signal(CE-ATA only) */
Nvoid sdio_ceata_command_completion_enable(void);
N/* disable the CE-ATA command completion signal(CE-ATA only) */
Nvoid sdio_ceata_command_completion_disable(void);
N
N#endif /* GD32F10X_SDIO_H */
L 61 ".\User\gd32f10x_libopt.h" 2
N#include "gd32f10x_exmc.h"
L 1 ".\Libraries\inc\gd32f10x_exmc.h" 1
N/*!
N    \file  gd32f10x_exmc.h
N    \brief definitions for the EXMC
N    
N    \version 2014-12-26, V1.0.0, firmware for GD32F10x
N    \version 2017-06-20, V2.0.0, firmware for GD32F10x
N    \version 2018-07-31, V2.1.0, firmware for GD32F10x
N*/
N
N/*
N    Copyright (c) 2018, GigaDevice Semiconductor Inc.
N
N    All rights reserved.
N
N    Redistribution and use in source and binary forms, with or without modification, 
Nare permitted provided that the following conditions are met:
N
N    1. Redistributions of source code must retain the above copyright notice, this 
N       list of conditions and the following disclaimer.
N    2. Redistributions in binary form must reproduce the above copyright notice, 
N       this list of conditions and the following disclaimer in the documentation 
N       and/or other materials provided with the distribution.
N    3. Neither the name of the copyright holder nor the names of its contributors 
N       may be used to endorse or promote products derived from this software without 
N       specific prior written permission.
N
N    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
NAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
NWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
NIN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
NINDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
NNOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
NPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
NWHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
NARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
NOF SUCH DAMAGE.
N*/
N
N#ifndef GD32F10X_EXMC_H
N#define GD32F10X_EXMC_H
N
N#include "gd32f10x.h"
N
N/* EXMC definitions */
N#define EXMC                              (EXMC_BASE)                   /*!< EXMC register base address */
N
N/* registers definitions */
N/* NOR/PSRAM */
N#define EXMC_SNCTL0                       REG32(EXMC + 0x00U)           /*!< EXMC SRAM/NOR flash control register 0 */
N#define EXMC_SNTCFG0                      REG32(EXMC + 0x04U)           /*!< EXMC SRAM/NOR flash timing configuration register 0 */
N#define EXMC_SNWTCFG0                     REG32(EXMC + 0x104U)          /*!< EXMC SRAM/NOR flash write timing configuration register 0 */
N
N#define EXMC_SNCTL1                       REG32(EXMC + 0x08U)           /*!< EXMC SRAM/NOR flash control register 1 */
N#define EXMC_SNTCFG1                      REG32(EXMC + 0x0CU)           /*!< EXMC SRAM/NOR flash timing configuration register 1 */
N#define EXMC_SNWTCFG1                     REG32(EXMC + 0x10CU)          /*!< EXMC SRAM/NOR flash write timing configuration register 1 */
N
N#define EXMC_SNCTL2                       REG32(EXMC + 0x10U)           /*!< EXMC SRAM/NOR flash control register 2 */
N#define EXMC_SNTCFG2                      REG32(EXMC + 0x14U)           /*!< EXMC SRAM/NOR flash timing configuration register 2 */
N#define EXMC_SNWTCFG2                     REG32(EXMC + 0x114U)          /*!< EXMC SRAM/NOR flash write timing configuration register 2 */
N
N#define EXMC_SNCTL3                       REG32(EXMC + 0x18U)           /*!< EXMC SRAM/NOR flash control register 3 */
N#define EXMC_SNTCFG3                      REG32(EXMC + 0x1CU)           /*!< EXMC SRAM/NOR flash timing configuration register 3 */
N#define EXMC_SNWTCFG3                     REG32(EXMC + 0x11CU)          /*!< EXMC SRAM/NOR flash write timing configuration register 3 */
N
N/* NAND/PC card */
N#define EXMC_NPCTL1                       REG32(EXMC + 0x60U)           /*!< EXMC NAND/PC card control register 1 */
N#define EXMC_NPINTEN1                     REG32(EXMC + 0x64U)           /*!< EXMC NAND/PC card interrupt enable register 1 */
N#define EXMC_NPCTCFG1                     REG32(EXMC + 0x68U)           /*!< EXMC NAND/PC card common space timing configuration register 1 */
N#define EXMC_NPATCFG1                     REG32(EXMC + 0x6CU)           /*!< EXMC NAND/PC card attribute space timing configuration register 1 */
N#define EXMC_NECC1                        REG32(EXMC + 0x74U)           /*!< EXMC NAND ECC register 1 */
N
N#define EXMC_NPCTL2                       REG32(EXMC + 0x80U)           /*!< EXMC NAND/PC card control register 2 */
N#define EXMC_NPINTEN2                     REG32(EXMC + 0x84U)           /*!< EXMC NAND/PC card interrupt enable register 2 */
N#define EXMC_NPCTCFG2                     REG32(EXMC + 0x88U)           /*!< EXMC NAND/PC card common space timing configuration register 2 */
N#define EXMC_NPATCFG2                     REG32(EXMC + 0x8CU)           /*!< EXMC NAND/PC card attribute space timing configuration register 2 */
N#define EXMC_NECC2                        REG32(EXMC + 0x94U)           /*!< EXMC NAND ECC register 2 */
N
N#define EXMC_NPCTL3                       REG32(EXMC + 0xA0U)           /*!< EXMC NAND/PC card control register 3 */
N#define EXMC_NPINTEN3                     REG32(EXMC + 0xA4U)           /*!< EXMC NAND/PC card interrupt enable register 3 */
N#define EXMC_NPCTCFG3                     REG32(EXMC + 0xA8U)           /*!< EXMC NAND/PC card common space timing configuration register 3 */
N#define EXMC_NPATCFG3                     REG32(EXMC + 0xACU)           /*!< EXMC NAND/PC card attribute space timing configuration register 3 */
N#define EXMC_PIOTCFG3                     REG32(EXMC + 0xB0U)           /*!< EXMC PC card I/O space timing configuration register */
N
N/* bits definitions */
N/* NOR/PSRAM */
N/* EXMC_SNCTLx,x=0..3 */
N#define EXMC_SNCTL_NRBKEN                 BIT(0)                        /*!< NOR bank enable */
N#define EXMC_SNCTL_NRMUX                  BIT(1)                        /*!< NOR bank memory address/data multiplexing */
N#define EXMC_SNCTL_NRTP                   BITS(2,3)                     /*!< NOR bank memory type */
N#define EXMC_SNCTL_NRW                    BITS(4,5)                     /*!< NOR bank memory data bus width */
N#define EXMC_SNCTL_NREN                   BIT(6)                        /*!< NOR flash access enable */
N#define EXMC_SNCTL_SBRSTEN                BIT(8)                        /*!< synchronous burst enable */
N#define EXMC_SNCTL_NRWTPOL                BIT(9)                        /*!< NWAIT signal polarity */
N#define EXMC_SNCTL_WRAPEN                 BIT(10)                       /*!< wrapped burst mode enable */
N#define EXMC_SNCTL_NRWTCFG                BIT(11)                       /*!< NWAIT signal configuration, only work in synchronous mode  */
N#define EXMC_SNCTL_WREN                   BIT(12)                       /*!< write enable */
N#define EXMC_SNCTL_NRWTEN                 BIT(13)                       /*!< NWAIT signal enable */
N#define EXMC_SNCTL_EXMODEN                BIT(14)                       /*!< extended mode enable */
N#define EXMC_SNCTL_ASYNCWAIT              BIT(15)                       /*!< asynchronous wait */
N#define EXMC_SNCTL_SYNCWR                 BIT(19)                       /*!< synchronous write */
N
N/* EXMC_SNTCFGx,x=0..3 */
N#define EXMC_SNTCFG_ASET                  BITS(0,3)                     /*!< address setup time */
N#define EXMC_SNTCFG_AHLD                  BITS(4,7)                     /*!< address hold time */
N#define EXMC_SNTCFG_DSET                  BITS(8,15)                    /*!< data setup time */
N#define EXMC_SNTCFG_BUSLAT                BITS(16,19)                   /*!< bus latency */
N#define EXMC_SNTCFG_CKDIV                 BITS(20,23)                   /*!< synchronous clock divide ratio */
N#define EXMC_SNTCFG_DLAT                  BITS(24,27)                   /*!< data latency for NOR flash */
N#define EXMC_SNTCFG_ASYNCMOD              BITS(28,29)                   /*!< asynchronous access mode */
N
N/* EXMC_SNWTCFGx,x=0..3 */
N#define EXMC_SNWTCFG_WASET                BITS(0,3)                     /*!< address setup time */
N#define EXMC_SNWTCFG_WAHLD                BITS(4,7)                     /*!< address hold time */
N#define EXMC_SNWTCFG_WDSET                BITS(8,15)                    /*!< data setup time */
N#define EXMC_SNWTCFG_CKDIV                BITS(20,23)                   /*!< synchronous clock divide ratio */
N#define EXMC_SNWTCFG_DLAT                 BITS(24,27)                   /*!< data latency for NOR flash */
N#define EXMC_SNWTCFG_WASYNCMOD            BITS(28,29)                   /*!< asynchronous access mode */
N
N/* NAND/PC card */
N/* EXMC_NPCTLx,x=1..3 */
N#define EXMC_NPCTL_NDWTEN                 BIT(1)                        /*!< wait feature enable */
N#define EXMC_NPCTL_NDBKEN                 BIT(2)                        /*!< NAND bank enable */
N#define EXMC_NPCTL_NDTP                   BIT(3)                        /*!< NAND bank memory type */
N#define EXMC_NPCTL_NDW                    BITS(4,5)                     /*!< NAND bank memory data bus width */
N#define EXMC_NPCTL_ECCEN                  BIT(6)                        /*!< ECC enable */
N#define EXMC_NPCTL_CTR                    BITS(9,12)                    /*!< CLE to RE delay */
N#define EXMC_NPCTL_ATR                    BITS(13,16)                   /*!< ALE to RE delay */
N#define EXMC_NPCTL_ECCSZ                  BITS(17,19)                   /*!< ECC size */
N
N/* EXMC_NPINTENx,x=1..3 */
N#define EXMC_NPINTEN_INTRS                BIT(0)                        /*!< interrupt rising edge status */
N#define EXMC_NPINTEN_INTHS                BIT(1)                        /*!< interrupt high-level status */
N#define EXMC_NPINTEN_INTFS                BIT(2)                        /*!< interrupt falling edge status */
N#define EXMC_NPINTEN_INTREN               BIT(3)                        /*!< interrupt rising edge detection enable */
N#define EXMC_NPINTEN_INTHEN               BIT(4)                        /*!< interrupt high-level detection enable */
N#define EXMC_NPINTEN_INTFEN               BIT(5)                        /*!< interrupt falling edge detection enable */
N#define EXMC_NPINTEN_FFEPT                BIT(6)                        /*!< FIFO empty flag */
N
N/* EXMC_NPCTCFGx,x=1..3 */
N#define EXMC_NPCTCFG_COMSET               BITS(0,7)                     /*!< common memory setup time */
N#define EXMC_NPCTCFG_COMWAIT              BITS(8,15)                    /*!< common memory wait time */
N#define EXMC_NPCTCFG_COMHLD               BITS(16,23)                   /*!< common memory hold time */
N#define EXMC_NPCTCFG_COMHIZ               BITS(24,31)                   /*!< common memory data bus HiZ time */
N
N/* EXMC_NPATCFGx,x=1..3 */
N#define EXMC_NPATCFG_ATTSET               BITS(0,7)                     /*!< attribute memory setup time */
N#define EXMC_NPATCFG_ATTWAIT              BITS(8,15)                    /*!< attribute memory wait time */
N#define EXMC_NPATCFG_ATTHLD               BITS(16,23)                   /*!< attribute memory hold time */
N#define EXMC_NPATCFG_ATTHIZ               BITS(24,31)                   /*!< attribute memory data bus HiZ time */
N
N/* EXMC_PIOTCFG3 */
N#define EXMC_PIOTCFG3_IOSET               BITS(0,7)                     /*!< IO space setup time */
N#define EXMC_PIOTCFG3_IOWAIT              BITS(8,15)                    /*!< IO space wait time */
N#define EXMC_PIOTCFG3_IOHLD               BITS(16,23)                   /*!< IO space hold time */
N#define EXMC_PIOTCFG3_IOHIZ               BITS(24,31)                   /*!< IO space data bus HiZ time */
N
N/* EXMC_NECCx,x=1,2 */
N#define EXMC_NECC_ECC                     BITS(0,31)                    /*!< ECC result */
N
N/* constants definitions */
N/* EXMC NOR/SRAM timing initialize struct */
Ntypedef struct
N{
N    uint32_t asyn_access_mode;                                          /*!< asynchronous access mode */
N    uint32_t syn_data_latency;                                          /*!< configure the data latency */
N    uint32_t syn_clk_division;                                          /*!< configure the clock divide ratio */
N    uint32_t bus_latency;                                               /*!< configure the bus latency */
N    uint32_t asyn_data_setuptime;                                       /*!< configure the data setup time,asynchronous access mode valid */
N    uint32_t asyn_address_holdtime;                                     /*!< configure the address hold time,asynchronous access mode valid */
N    uint32_t asyn_address_setuptime;                                    /*!< configure the data setup time,asynchronous access mode valid */
N}exmc_norsram_timing_parameter_struct;
N
N/* EXMC NOR/SRAM initialize struct */
Ntypedef struct
N{
N    uint32_t norsram_region;                                            /*!< select the region of EXMC NOR/SRAM bank */
N    uint32_t write_mode;                                                /*!< the write mode, synchronous mode or asynchronous mode */
N    uint32_t extended_mode;                                             /*!< enable or disable the extended mode */
N    uint32_t asyn_wait;                                                 /*!< enable or disable the asynchronous wait function */
N    uint32_t nwait_signal;                                              /*!< enable or disable the NWAIT signal while in synchronous bust mode */
N    uint32_t memory_write;                                              /*!< enable or disable the write operation */
N    uint32_t nwait_config;                                              /*!< NWAIT signal configuration */
N    uint32_t wrap_burst_mode;                                           /*!< enable or disable the wrap burst mode */
N    uint32_t nwait_polarity;                                            /*!< specifies the polarity of NWAIT signal from memory */
N    uint32_t burst_mode;                                                /*!< enable or disable the burst mode */
N    uint32_t databus_width;                                             /*!< specifies the databus width of external memory */
N    uint32_t memory_type;                                               /*!< specifies the type of external memory */
N    uint32_t address_data_mux;                                          /*!< specifies whether the data bus and address bus are multiplexed */
N    exmc_norsram_timing_parameter_struct* read_write_timing;            /*!< timing parameters for read and write if the extended mode is not used or the timing 
N                                                                             parameters for read if the extended mode is used */
N    exmc_norsram_timing_parameter_struct* write_timing;                 /*!< timing parameters for write when the extended mode is used */
N}exmc_norsram_parameter_struct;
N
N/* EXMC NAND/PC card timing initialize struct */
Ntypedef struct
N{
N    uint32_t databus_hiztime;                                           /*!< configure the dadtabus HiZ time for write operation */
N    uint32_t holdtime;                                                  /*!< configure the address hold time(or the data hold time for write operation) */
N    uint32_t waittime;                                                  /*!< configure the minimum wait time */
N    uint32_t setuptime;                                                 /*!< configure the address setup time */
N}exmc_nand_pccard_timing_parameter_struct;
N
N/* EXMC NAND initialize struct */
Ntypedef struct
N{
N    uint32_t nand_bank;                                                 /*!< select the bank of NAND */ 
N    uint32_t ecc_size;                                                  /*!< the page size for the ECC calculation */
N    uint32_t atr_latency;                                               /*!< configure the latency of ALE low to RB low */
N    uint32_t ctr_latency;                                               /*!< configure the latency of CLE low to RB low */
N    uint32_t ecc_logic;                                                 /*!< enable or disable the ECC calculation logic */
N    uint32_t databus_width;                                             /*!< the NAND flash databus width */
N    uint32_t wait_feature;                                              /*!< enables or disables the wait feature */
N    exmc_nand_pccard_timing_parameter_struct* common_space_timing;      /*!< the timing parameters for NAND flash common space */
N    exmc_nand_pccard_timing_parameter_struct* attribute_space_timing;   /*!< the timing parameters for NAND flash attribute space */
N}exmc_nand_parameter_struct;
N
N/* EXMC PC card initialize struct */
Ntypedef struct
N{
N    uint32_t atr_latency;                                               /*!< configure the latency of ALE low to RB low */
N    uint32_t ctr_latency;                                               /*!< configure the latency of CLE low to RB low */
N    uint32_t wait_feature;                                              /*!< enables or disables the Wait feature */
N    exmc_nand_pccard_timing_parameter_struct*  common_space_timing;     /*!< the timing parameters for NAND flash common space */
N    exmc_nand_pccard_timing_parameter_struct*  attribute_space_timing;  /*!< the timing parameters for NAND flash attribute space */  
N    exmc_nand_pccard_timing_parameter_struct*  io_space_timing;         /*!< the timing parameters for NAND flash IO space */
N}exmc_pccard_parameter_struct;;
N
N/* EXMC register address */
N#define EXMC_SNCTL(region)                REG32(EXMC + 0x08U * (region))                  /*!< EXMC SRAM/NOR flash control register */
N#define EXMC_SNTCFG(region)               REG32(EXMC + 0x04U + 0x08U * (region))          /*!< EXMC SRAM/NOR flash timing configuration register */
N#define EXMC_SNWTCFG(region)              REG32(EXMC + 0x104U + 0x08U * (region))         /*!< EXMC SRAM/NOR flash write timing configuration register */
N
N#define EXMC_NPCTL(bank)                  REG32(EXMC + 0x40U + 0x20U * (bank))            /*!< EXMC NAND/PC card control register */
N#define EXMC_NPINTEN(bank)                REG32(EXMC + 0x44U + 0x20U * (bank))            /*!< EXMC NAND/PC card interrupt enable register */
N#define EXMC_NPCTCFG(bank)                REG32(EXMC + 0x48U + 0x20U * (bank))            /*!< EXMC NAND/PC card common space timing configuration register */
N#define EXMC_NPATCFG(bank)                REG32(EXMC + 0x4CU + 0x20U * (bank))            /*!< EXMC NAND/PC card attribute space timing configuration register */
N#define EXMC_NECC(bank)                   REG32(EXMC + 0x54U + 0x20U * (bank))            /*!< EXMC NAND ECC register */
N
N/* NOR bank memory data bus width */
N#define SNCTL_NRW(regval)                 (BITS(4,5) & ((uint32_t)(regval) << 4))
N#define EXMC_NOR_DATABUS_WIDTH_8B         SNCTL_NRW(0)                  /*!< NOR data width 8 bits */
N#define EXMC_NOR_DATABUS_WIDTH_16B        SNCTL_NRW(1)                  /*!< NOR data width 16 bits */
N
N/* NOR bank memory type */
N#define SNCTL_NRTP(regval)                (BITS(2,3) & ((uint32_t)(regval) << 2))
N#define EXMC_MEMORY_TYPE_SRAM             SNCTL_NRTP(0)                 /*!< SRAM,ROM */
N#define EXMC_MEMORY_TYPE_PSRAM            SNCTL_NRTP(1)                 /*!< PSRAM,CRAM */
N#define EXMC_MEMORY_TYPE_NOR              SNCTL_NRTP(2)                 /*!< NOR flash */
N
N/* asynchronous access mode */
N#define SNTCFG_ASYNCMOD(regval)           (BITS(28,29) & ((uint32_t)(regval) << 28))
N#define EXMC_ACCESS_MODE_A                SNTCFG_ASYNCMOD(0)            /*!< mode A access */
N#define EXMC_ACCESS_MODE_B                SNTCFG_ASYNCMOD(1)            /*!< mode B access */
N#define EXMC_ACCESS_MODE_C                SNTCFG_ASYNCMOD(2)            /*!< mode C access */
N#define EXMC_ACCESS_MODE_D                SNTCFG_ASYNCMOD(3)            /*!< mode D access */
N
N/* data latency for NOR flash */
N#define SNTCFG_DLAT(regval)               (BITS(24,27) & ((uint32_t)(regval) << 24))
N#define EXMC_DATALAT_2_CLK                SNTCFG_DLAT(0)                /*!< data latency 2 EXMC_CLK */
N#define EXMC_DATALAT_3_CLK                SNTCFG_DLAT(1)                /*!< data latency 3 EXMC_CLK */
N#define EXMC_DATALAT_4_CLK                SNTCFG_DLAT(2)                /*!< data latency 4 EXMC_CLK */
N#define EXMC_DATALAT_5_CLK                SNTCFG_DLAT(3)                /*!< data latency 5 EXMC_CLK */
N#define EXMC_DATALAT_6_CLK                SNTCFG_DLAT(4)                /*!< data latency 6 EXMC_CLK */
N#define EXMC_DATALAT_7_CLK                SNTCFG_DLAT(5)                /*!< data latency 7 EXMC_CLK */
N#define EXMC_DATALAT_8_CLK                SNTCFG_DLAT(6)                /*!< data latency 8 EXMC_CLK */
N#define EXMC_DATALAT_9_CLK                SNTCFG_DLAT(7)                /*!< data latency 9 EXMC_CLK */
N#define EXMC_DATALAT_10_CLK               SNTCFG_DLAT(8)                /*!< data latency 10 EXMC_CLK */
N#define EXMC_DATALAT_11_CLK               SNTCFG_DLAT(9)                /*!< data latency 11 EXMC_CLK */
N#define EXMC_DATALAT_12_CLK               SNTCFG_DLAT(10)               /*!< data latency 12 EXMC_CLK */
N#define EXMC_DATALAT_13_CLK               SNTCFG_DLAT(11)               /*!< data latency 13 EXMC_CLK */
N#define EXMC_DATALAT_14_CLK               SNTCFG_DLAT(12)               /*!< data latency 14 EXMC_CLK */
N#define EXMC_DATALAT_15_CLK               SNTCFG_DLAT(13)               /*!< data latency 15 EXMC_CLK */
N#define EXMC_DATALAT_16_CLK               SNTCFG_DLAT(14)               /*!< data latency 16 EXMC_CLK */
N#define EXMC_DATALAT_17_CLK               SNTCFG_DLAT(15)               /*!< data latency 17 EXMC_CLK */
N
N/* synchronous clock divide ratio */
N#define SNTCFG_CKDIV(regval)              (BITS(20,23) & ((uint32_t)(regval) << 20))
N#define EXMC_SYN_CLOCK_RATIO_DISABLE      SNTCFG_CKDIV(0)               /*!< EXMC_CLK disable */
N#define EXMC_SYN_CLOCK_RATIO_2_CLK        SNTCFG_CKDIV(1)               /*!< EXMC_CLK = 2*HCLK */
N#define EXMC_SYN_CLOCK_RATIO_3_CLK        SNTCFG_CKDIV(2)               /*!< EXMC_CLK = 3*HCLK */
N#define EXMC_SYN_CLOCK_RATIO_4_CLK        SNTCFG_CKDIV(3)               /*!< EXMC_CLK = 4*HCLK */
N#define EXMC_SYN_CLOCK_RATIO_5_CLK        SNTCFG_CKDIV(4)               /*!< EXMC_CLK = 5*HCLK */
N#define EXMC_SYN_CLOCK_RATIO_6_CLK        SNTCFG_CKDIV(5)               /*!< EXMC_CLK = 6*HCLK */
N#define EXMC_SYN_CLOCK_RATIO_7_CLK        SNTCFG_CKDIV(6)               /*!< EXMC_CLK = 7*HCLK */
N#define EXMC_SYN_CLOCK_RATIO_8_CLK        SNTCFG_CKDIV(7)               /*!< EXMC_CLK = 8*HCLK */
N#define EXMC_SYN_CLOCK_RATIO_9_CLK        SNTCFG_CKDIV(8)               /*!< EXMC_CLK = 9*HCLK */
N#define EXMC_SYN_CLOCK_RATIO_10_CLK       SNTCFG_CKDIV(9)               /*!< EXMC_CLK = 10*HCLK */
N#define EXMC_SYN_CLOCK_RATIO_11_CLK       SNTCFG_CKDIV(10)              /*!< EXMC_CLK = 11*HCLK */
N#define EXMC_SYN_CLOCK_RATIO_12_CLK       SNTCFG_CKDIV(11)              /*!< EXMC_CLK = 12*HCLK */
N#define EXMC_SYN_CLOCK_RATIO_13_CLK       SNTCFG_CKDIV(12)              /*!< EXMC_CLK = 13*HCLK */
N#define EXMC_SYN_CLOCK_RATIO_14_CLK       SNTCFG_CKDIV(13)              /*!< EXMC_CLK = 14*HCLK */
N#define EXMC_SYN_CLOCK_RATIO_15_CLK       SNTCFG_CKDIV(14)              /*!< EXMC_CLK = 15*HCLK */
N#define EXMC_SYN_CLOCK_RATIO_16_CLK       SNTCFG_CKDIV(15)              /*!< EXMC_CLK = 16*HCLK */
N
N/* ECC size */
N#define NPCTL_ECCSZ(regval)               (BITS(17,19) & ((uint32_t)(regval) << 17))
N#define EXMC_ECC_SIZE_256BYTES            NPCTL_ECCSZ(0)                /* 256 bytes */
N#define EXMC_ECC_SIZE_512BYTES            NPCTL_ECCSZ(1)                /* 512 bytes */
N#define EXMC_ECC_SIZE_1024BYTES           NPCTL_ECCSZ(2)                /* 1024 bytes */
N#define EXMC_ECC_SIZE_2048BYTES           NPCTL_ECCSZ(3)                /* 2048 bytes */
N#define EXMC_ECC_SIZE_4096BYTES           NPCTL_ECCSZ(4)                /* 4096 bytes */
N#define EXMC_ECC_SIZE_8192BYTES           NPCTL_ECCSZ(5)                /* 8192 bytes */
N
N/* ALE to RE delay */
N#define NPCTL_ATR(regval)                 (BITS(13,16) & ((uint32_t)(regval) << 13))
N#define EXMC_ALE_RE_DELAY_1_HCLK          NPCTL_ATR(0)                  /* ALE to RE delay = 1*HCLK */
N#define EXMC_ALE_RE_DELAY_2_HCLK          NPCTL_ATR(1)                  /* ALE to RE delay = 2*HCLK */
N#define EXMC_ALE_RE_DELAY_3_HCLK          NPCTL_ATR(2)                  /* ALE to RE delay = 3*HCLK */
N#define EXMC_ALE_RE_DELAY_4_HCLK          NPCTL_ATR(3)                  /* ALE to RE delay = 4*HCLK */
N#define EXMC_ALE_RE_DELAY_5_HCLK          NPCTL_ATR(4)                  /* ALE to RE delay = 5*HCLK */
N#define EXMC_ALE_RE_DELAY_6_HCLK          NPCTL_ATR(5)                  /* ALE to RE delay = 6*HCLK */
N#define EXMC_ALE_RE_DELAY_7_HCLK          NPCTL_ATR(6)                  /* ALE to RE delay = 7*HCLK */
N#define EXMC_ALE_RE_DELAY_8_HCLK          NPCTL_ATR(7)                  /* ALE to RE delay = 8*HCLK */
N#define EXMC_ALE_RE_DELAY_9_HCLK          NPCTL_ATR(8)                  /* ALE to RE delay = 9*HCLK */
N#define EXMC_ALE_RE_DELAY_10_HCLK         NPCTL_ATR(9)                  /* ALE to RE delay = 10*HCLK */
N#define EXMC_ALE_RE_DELAY_11_HCLK         NPCTL_ATR(10)                 /* ALE to RE delay = 11*HCLK */
N#define EXMC_ALE_RE_DELAY_12_HCLK         NPCTL_ATR(11)                 /* ALE to RE delay = 12*HCLK */
N#define EXMC_ALE_RE_DELAY_13_HCLK         NPCTL_ATR(12)                 /* ALE to RE delay = 13*HCLK */
N#define EXMC_ALE_RE_DELAY_14_HCLK         NPCTL_ATR(13)                 /* ALE to RE delay = 14*HCLK */
N#define EXMC_ALE_RE_DELAY_15_HCLK         NPCTL_ATR(14)                 /* ALE to RE delay = 15*HCLK */
N#define EXMC_ALE_RE_DELAY_16_HCLK         NPCTL_ATR(15)                 /* ALE to RE delay = 16*HCLK */
N
N/* CLE to RE delay */
N#define NPCTL_CTR(regval)                 (BITS(9,12) & ((uint32_t)(regval) << 9))
N#define EXMC_CLE_RE_DELAY_1_HCLK          NPCTL_CTR(0)                  /* CLE to RE delay = 1*HCLK */
N#define EXMC_CLE_RE_DELAY_2_HCLK          NPCTL_CTR(1)                  /* CLE to RE delay = 2*HCLK */
N#define EXMC_CLE_RE_DELAY_3_HCLK          NPCTL_CTR(2)                  /* CLE to RE delay = 3*HCLK */
N#define EXMC_CLE_RE_DELAY_4_HCLK          NPCTL_CTR(3)                  /* CLE to RE delay = 4*HCLK */
N#define EXMC_CLE_RE_DELAY_5_HCLK          NPCTL_CTR(4)                  /* CLE to RE delay = 5*HCLK */
N#define EXMC_CLE_RE_DELAY_6_HCLK          NPCTL_CTR(5)                  /* CLE to RE delay = 6*HCLK */
N#define EXMC_CLE_RE_DELAY_7_HCLK          NPCTL_CTR(6)                  /* CLE to RE delay = 7*HCLK */
N#define EXMC_CLE_RE_DELAY_8_HCLK          NPCTL_CTR(7)                  /* CLE to RE delay = 8*HCLK */
N#define EXMC_CLE_RE_DELAY_9_HCLK          NPCTL_CTR(8)                  /* CLE to RE delay = 9*HCLK */
N#define EXMC_CLE_RE_DELAY_10_HCLK         NPCTL_CTR(9)                  /* CLE to RE delay = 10*HCLK */
N#define EXMC_CLE_RE_DELAY_11_HCLK         NPCTL_CTR(10)                 /* CLE to RE delay = 11*HCLK */
N#define EXMC_CLE_RE_DELAY_12_HCLK         NPCTL_CTR(11)                 /* CLE to RE delay = 12*HCLK */
N#define EXMC_CLE_RE_DELAY_13_HCLK         NPCTL_CTR(12)                 /* CLE to RE delay = 13*HCLK */
N#define EXMC_CLE_RE_DELAY_14_HCLK         NPCTL_CTR(13)                 /* CLE to RE delay = 14*HCLK */
N#define EXMC_CLE_RE_DELAY_15_HCLK         NPCTL_CTR(14)                 /* CLE to RE delay = 15*HCLK */
N#define EXMC_CLE_RE_DELAY_16_HCLK         NPCTL_CTR(15)                 /* CLE to RE delay = 16*HCLK */
N
N/* NAND bank memory data bus width */
N#define NPCTL_NDW(regval)                 (BITS(4,5) & ((uint32_t)(regval) << 4))
N#define EXMC_NAND_DATABUS_WIDTH_8B        NPCTL_NDW(0)                  /*!< NAND data width 8 bits */
N#define EXMC_NAND_DATABUS_WIDTH_16B       NPCTL_NDW(1)                  /*!< NAND data width 16 bits */
N
N/* EXMC NOR/SRAM bank region definition */
N#define EXMC_BANK0_NORSRAM_REGION0        ((uint32_t)0x00000000U)       /*!< bank0 NOR/SRAM region0 */
N#define EXMC_BANK0_NORSRAM_REGION1        ((uint32_t)0x00000001U)       /*!< bank0 NOR/SRAM region1 */
N#define EXMC_BANK0_NORSRAM_REGION2        ((uint32_t)0x00000002U)       /*!< bank0 NOR/SRAM region2 */
N#define EXMC_BANK0_NORSRAM_REGION3        ((uint32_t)0x00000003U)       /*!< bank0 NOR/SRAM region3 */
N
N/* EXMC NOR/SRAM write mode */
N#define EXMC_ASYN_WRITE                   ((uint32_t)0x00000000U)       /*!< asynchronous write mode */
N#define EXMC_SYN_WRITE                    ((uint32_t)0x00080000U)       /*!< synchronous write mode */
N
N/* EXMC NWAIT signal configuration */
N#define EXMC_NWAIT_CONFIG_BEFORE          ((uint32_t)0x00000000U)       /*!< NWAIT signal is active one data cycle before wait state */
N#define EXMC_NWAIT_CONFIG_DURING          ((uint32_t)0x00000800U)       /*!< NWAIT signal is active during wait state */
N
N/* EXMC NWAIT signal polarity configuration */
N#define EXMC_NWAIT_POLARITY_LOW           ((uint32_t)0x00000000U)       /*!< low level is active of NWAIT */
N#define EXMC_NWAIT_POLARITY_HIGH          ((uint32_t)0x00000200U)       /*!< high level is active of NWAIT */
N
N/* EXMC NAND/PC card bank definition */
N#define EXMC_BANK1_NAND                   ((uint32_t)0x00000001U)       /*!< bank1 NAND flash */
N#define EXMC_BANK2_NAND                   ((uint32_t)0x00000002U)       /*!< bank2 NAND flash */
N#define EXMC_BANK3_PCCARD                 ((uint32_t)0x00000003U)       /*!< bank3 PC card */
N
N/* EXMC flag bits */
N#define EXMC_NAND_PCCARD_FLAG_RISE        EXMC_NPINTEN_INTRS            /*!< interrupt rising edge status */
N#define EXMC_NAND_PCCARD_FLAG_LEVEL       EXMC_NPINTEN_INTHS            /*!< interrupt high-level status */
N#define EXMC_NAND_PCCARD_FLAG_FALL        EXMC_NPINTEN_INTFS            /*!< interrupt falling edge status */
N#define EXMC_NAND_PCCARD_FLAG_FIFOE       EXMC_NPINTEN_FFEPT            /*!< FIFO empty flag */
N
N/* EXMC interrupt flag bits */
N#define EXMC_NAND_PCCARD_INT_RISE         EXMC_NPINTEN_INTREN           /*!< interrupt rising edge detection enable */
N#define EXMC_NAND_PCCARD_INT_LEVEL        EXMC_NPINTEN_INTHEN           /*!< interrupt high-level detection enable */
N#define EXMC_NAND_PCCARD_INT_FALL         EXMC_NPINTEN_INTFEN           /*!< interrupt falling edge detection enable */
N
N/* function declarations */
N/* deinitialize EXMC NOR/SRAM region */
Nvoid exmc_norsram_deinit(uint32_t norsram_region);
N/* exmc_norsram_parameter_struct parameter initialize */
Nvoid exmc_norsram_struct_para_init(exmc_norsram_parameter_struct* exmc_norsram_init_struct);
N/* initialize EXMC NOR/SRAM region */
Nvoid exmc_norsram_init(exmc_norsram_parameter_struct* exmc_norsram_init_struct);
N/* EXMC NOR/SRAM bank enable */
Nvoid exmc_norsram_enable(uint32_t norsram_region);
N/* EXMC NOR/SRAM bank disable */
Nvoid exmc_norsram_disable(uint32_t norsram_region);
N
N/* deinitialize EXMC NAND bank */
Nvoid exmc_nand_deinit(uint32_t nand_bank);
N/* initialize EXMC NAND bank */
Nvoid exmc_nand_init(exmc_nand_parameter_struct* exmc_nand_init_struct);
N/* exmc_nand_init_struct parameter initialize */
Nvoid exmc_nand_struct_para_init(exmc_nand_parameter_struct* exmc_nand_init_struct);
N/* EXMC NAND bank enable */
Nvoid exmc_nand_enable(uint32_t nand_bank);
N/* EXMC NAND bank disable */
Nvoid exmc_nand_disable(uint32_t nand_bank);
N/* enable or disable the EXMC NAND ECC function */
Nvoid exmc_nand_ecc_config(uint32_t nand_bank, ControlStatus newvalue);
N/* get the EXMC ECC value */
Nuint32_t exmc_ecc_get(uint32_t nand_bank);
N
N/* deinitialize EXMC PC card bank */
Nvoid exmc_pccard_deinit(void);
N/* initialize EXMC PC card bank */
Nvoid exmc_pccard_init(exmc_pccard_parameter_struct* exmc_pccard_init_struct);
N/* exmc_pccard_parameter_struct parameter initialize */
Nvoid exmc_pccard_struct_para_init(exmc_pccard_parameter_struct* exmc_pccard_init_struct);
N/* EXMC PC card bank enable */
Nvoid exmc_pccard_enable(void);
N/* EXMC PC card bank disable */
Nvoid exmc_pccard_disable(void);
N
N/* enable EXMC interrupt */
Nvoid exmc_interrupt_enable(uint32_t bank, uint32_t interrupt_source);
N/* disable EXMC interrupt */
Nvoid exmc_interrupt_disable(uint32_t bank, uint32_t interrupt_source);
N/* check EXMC flag is set or not */
NFlagStatus exmc_flag_get(uint32_t bank, uint32_t flag);
N/* clear EXMC flag */
Nvoid exmc_flag_clear(uint32_t bank, uint32_t flag);
N/* check EXMC flag is set or not */
NFlagStatus exmc_interrupt_flag_get(uint32_t bank, uint32_t interrupt_source);
N/* clear EXMC flag */
Nvoid exmc_interrupt_flag_clear(uint32_t bank, uint32_t interrupt_source);
N
N#endif /* GD32F10X_EXMC_H */
L 62 ".\User\gd32f10x_libopt.h" 2
N#include "gd32f10x_can.h"
L 1 ".\Libraries\inc\gd32f10x_can.h" 1
N/*!
N    \file  gd32f10x_can.h
N    \brief definitions for the CAN
N    
N    \version 2014-12-26, V1.0.0, firmware for GD32F10x
N    \version 2017-06-20, V2.0.0, firmware for GD32F10x
N    \version 2018-07-31, V2.1.0, firmware for GD32F10x
N    \version 2019-11-27, V2.1.1, firmware for GD32F10x
N*/
N
N/*
N    Copyright (c) 2018, GigaDevice Semiconductor Inc.
N
N    Redistribution and use in source and binary forms, with or without modification, 
Nare permitted provided that the following conditions are met:
N
N    1. Redistributions of source code must retain the above copyright notice, this 
N       list of conditions and the following disclaimer.
N    2. Redistributions in binary form must reproduce the above copyright notice, 
N       this list of conditions and the following disclaimer in the documentation 
N       and/or other materials provided with the distribution.
N    3. Neither the name of the copyright holder nor the names of its contributors 
N       may be used to endorse or promote products derived from this software without 
N       specific prior written permission.
N
N    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
NAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
NWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
NIN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
NINDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
NNOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
NPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
NWHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
NARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
NOF SUCH DAMAGE.
N*/
N
N#ifndef GD32F10x_CAN_H
N#define GD32F10x_CAN_H
N
N#include "gd32f10x.h"
N
N/* CAN definitions */
N#define CAN0                               CAN_BASE                      /*!< CAN0 base address */
N#define CAN1                               (CAN0 + 0x00000400U)          /*!< CAN1 base address */
N
N/* registers definitions */
N#define CAN_CTL(canx)                      REG32((canx) + 0x00U)         /*!< CAN control register */
N#define CAN_STAT(canx)                     REG32((canx) + 0x04U)         /*!< CAN status register */
N#define CAN_TSTAT(canx)                    REG32((canx) + 0x08U)         /*!< CAN transmit status register*/
N#define CAN_RFIFO0(canx)                   REG32((canx) + 0x0CU)         /*!< CAN receive FIFO0 register */
N#define CAN_RFIFO1(canx)                   REG32((canx) + 0x10U)         /*!< CAN receive FIFO1 register */
N#define CAN_INTEN(canx)                    REG32((canx) + 0x14U)         /*!< CAN interrupt enable register */
N#define CAN_ERR(canx)                      REG32((canx) + 0x18U)         /*!< CAN error register */
N#define CAN_BT(canx)                       REG32((canx) + 0x1CU)         /*!< CAN bit timing register */
N#define CAN_TMI0(canx)                     REG32((canx) + 0x180U)        /*!< CAN transmit mailbox0 identifier register */
N#define CAN_TMP0(canx)                     REG32((canx) + 0x184U)        /*!< CAN transmit mailbox0 property register */
N#define CAN_TMDATA00(canx)                 REG32((canx) + 0x188U)        /*!< CAN transmit mailbox0 data0 register */
N#define CAN_TMDATA10(canx)                 REG32((canx) + 0x18CU)        /*!< CAN transmit mailbox0 data1 register */
N#define CAN_TMI1(canx)                     REG32((canx) + 0x190U)        /*!< CAN transmit mailbox1 identifier register */
N#define CAN_TMP1(canx)                     REG32((canx) + 0x194U)        /*!< CAN transmit mailbox1 property register */
N#define CAN_TMDATA01(canx)                 REG32((canx) + 0x198U)        /*!< CAN transmit mailbox1 data0 register */
N#define CAN_TMDATA11(canx)                 REG32((canx) + 0x19CU)        /*!< CAN transmit mailbox1 data1 register */
N#define CAN_TMI2(canx)                     REG32((canx) + 0x1A0U)        /*!< CAN transmit mailbox2 identifier register */
N#define CAN_TMP2(canx)                     REG32((canx) + 0x1A4U)        /*!< CAN transmit mailbox2 property register */
N#define CAN_TMDATA02(canx)                 REG32((canx) + 0x1A8U)        /*!< CAN transmit mailbox2 data0 register */
N#define CAN_TMDATA12(canx)                 REG32((canx) + 0x1ACU)        /*!< CAN transmit mailbox2 data1 register */
N#define CAN_RFIFOMI0(canx)                 REG32((canx) + 0x1B0U)        /*!< CAN receive FIFO0 mailbox identifier register */
N#define CAN_RFIFOMP0(canx)                 REG32((canx) + 0x1B4U)        /*!< CAN receive FIFO0 mailbox property register */
N#define CAN_RFIFOMDATA00(canx)             REG32((canx) + 0x1B8U)        /*!< CAN receive FIFO0 mailbox data0 register */
N#define CAN_RFIFOMDATA10(canx)             REG32((canx) + 0x1BCU)        /*!< CAN receive FIFO0 mailbox data1 register */
N#define CAN_RFIFOMI1(canx)                 REG32((canx) + 0x1C0U)        /*!< CAN receive FIFO1 mailbox identifier register */
N#define CAN_RFIFOMP1(canx)                 REG32((canx) + 0x1C4U)        /*!< CAN receive FIFO1 mailbox property register */
N#define CAN_RFIFOMDATA01(canx)             REG32((canx) + 0x1C8U)        /*!< CAN receive FIFO1 mailbox data0 register */
N#define CAN_RFIFOMDATA11(canx)             REG32((canx) + 0x1CCU)        /*!< CAN receive FIFO1 mailbox data1 register */
N#define CAN_FCTL(canx)                     REG32((canx) + 0x200U)        /*!< CAN filter control register */
N#define CAN_FMCFG(canx)                    REG32((canx) + 0x204U)        /*!< CAN filter mode register */
N#define CAN_FSCFG(canx)                    REG32((canx) + 0x20CU)        /*!< CAN filter scale register */
N#define CAN_FAFIFO(canx)                   REG32((canx) + 0x214U)        /*!< CAN filter associated FIFO register */
N#define CAN_FW(canx)                       REG32((canx) + 0x21CU)        /*!< CAN filter working register */
N#define CAN_F0DATA0(canx)                  REG32((canx) + 0x240U)        /*!< CAN filter 0 data 0 register */
N#define CAN_F1DATA0(canx)                  REG32((canx) + 0x248U)        /*!< CAN filter 1 data 0 register */
N#define CAN_F2DATA0(canx)                  REG32((canx) + 0x250U)        /*!< CAN filter 2 data 0 register */
N#define CAN_F3DATA0(canx)                  REG32((canx) + 0x258U)        /*!< CAN filter 3 data 0 register */
N#define CAN_F4DATA0(canx)                  REG32((canx) + 0x260U)        /*!< CAN filter 4 data 0 register */
N#define CAN_F5DATA0(canx)                  REG32((canx) + 0x268U)        /*!< CAN filter 5 data 0 register */
N#define CAN_F6DATA0(canx)                  REG32((canx) + 0x270U)        /*!< CAN filter 6 data 0 register */
N#define CAN_F7DATA0(canx)                  REG32((canx) + 0x278U)        /*!< CAN filter 7 data 0 register */
N#define CAN_F8DATA0(canx)                  REG32((canx) + 0x280U)        /*!< CAN filter 8 data 0 register */
N#define CAN_F9DATA0(canx)                  REG32((canx) + 0x288U)        /*!< CAN filter 9 data 0 register */
N#define CAN_F10DATA0(canx)                 REG32((canx) + 0x290U)        /*!< CAN filter 10 data 0 register */
N#define CAN_F11DATA0(canx)                 REG32((canx) + 0x298U)        /*!< CAN filter 11 data 0 register */
N#define CAN_F12DATA0(canx)                 REG32((canx) + 0x2A0U)        /*!< CAN filter 12 data 0 register */
N#define CAN_F13DATA0(canx)                 REG32((canx) + 0x2A8U)        /*!< CAN filter 13 data 0 register */
N#define CAN_F14DATA0(canx)                 REG32((canx) + 0x2B0U)        /*!< CAN filter 14 data 0 register */
N#define CAN_F15DATA0(canx)                 REG32((canx) + 0x2B8U)        /*!< CAN filter 15 data 0 register */
N#define CAN_F16DATA0(canx)                 REG32((canx) + 0x2C0U)        /*!< CAN filter 16 data 0 register */
N#define CAN_F17DATA0(canx)                 REG32((canx) + 0x2C8U)        /*!< CAN filter 17 data 0 register */
N#define CAN_F18DATA0(canx)                 REG32((canx) + 0x2D0U)        /*!< CAN filter 18 data 0 register */
N#define CAN_F19DATA0(canx)                 REG32((canx) + 0x2D8U)        /*!< CAN filter 19 data 0 register */
N#define CAN_F20DATA0(canx)                 REG32((canx) + 0x2E0U)        /*!< CAN filter 20 data 0 register */
N#define CAN_F21DATA0(canx)                 REG32((canx) + 0x2E8U)        /*!< CAN filter 21 data 0 register */
N#define CAN_F22DATA0(canx)                 REG32((canx) + 0x2F0U)        /*!< CAN filter 22 data 0 register */
N#define CAN_F23DATA0(canx)                 REG32((canx) + 0x3F8U)        /*!< CAN filter 23 data 0 register */
N#define CAN_F24DATA0(canx)                 REG32((canx) + 0x300U)        /*!< CAN filter 24 data 0 register */
N#define CAN_F25DATA0(canx)                 REG32((canx) + 0x308U)        /*!< CAN filter 25 data 0 register */
N#define CAN_F26DATA0(canx)                 REG32((canx) + 0x310U)        /*!< CAN filter 26 data 0 register */
N#define CAN_F27DATA0(canx)                 REG32((canx) + 0x318U)        /*!< CAN filter 27 data 0 register */
N#define CAN_F0DATA1(canx)                  REG32((canx) + 0x244U)        /*!< CAN filter 0 data 1 register */
N#define CAN_F1DATA1(canx)                  REG32((canx) + 0x24CU)        /*!< CAN filter 1 data 1 register */
N#define CAN_F2DATA1(canx)                  REG32((canx) + 0x254U)        /*!< CAN filter 2 data 1 register */
N#define CAN_F3DATA1(canx)                  REG32((canx) + 0x25CU)        /*!< CAN filter 3 data 1 register */
N#define CAN_F4DATA1(canx)                  REG32((canx) + 0x264U)        /*!< CAN filter 4 data 1 register */
N#define CAN_F5DATA1(canx)                  REG32((canx) + 0x26CU)        /*!< CAN filter 5 data 1 register */
N#define CAN_F6DATA1(canx)                  REG32((canx) + 0x274U)        /*!< CAN filter 6 data 1 register */
N#define CAN_F7DATA1(canx)                  REG32((canx) + 0x27CU)        /*!< CAN filter 7 data 1 register */
N#define CAN_F8DATA1(canx)                  REG32((canx) + 0x284U)        /*!< CAN filter 8 data 1 register */
N#define CAN_F9DATA1(canx)                  REG32((canx) + 0x28CU)        /*!< CAN filter 9 data 1 register */
N#define CAN_F10DATA1(canx)                 REG32((canx) + 0x294U)        /*!< CAN filter 10 data 1 register */
N#define CAN_F11DATA1(canx)                 REG32((canx) + 0x29CU)        /*!< CAN filter 11 data 1 register */
N#define CAN_F12DATA1(canx)                 REG32((canx) + 0x2A4U)        /*!< CAN filter 12 data 1 register */
N#define CAN_F13DATA1(canx)                 REG32((canx) + 0x2ACU)        /*!< CAN filter 13 data 1 register */
N#define CAN_F14DATA1(canx)                 REG32((canx) + 0x2B4U)        /*!< CAN filter 14 data 1 register */
N#define CAN_F15DATA1(canx)                 REG32((canx) + 0x2BCU)        /*!< CAN filter 15 data 1 register */
N#define CAN_F16DATA1(canx)                 REG32((canx) + 0x2C4U)        /*!< CAN filter 16 data 1 register */
N#define CAN_F17DATA1(canx)                 REG32((canx) + 0x24CU)        /*!< CAN filter 17 data 1 register */
N#define CAN_F18DATA1(canx)                 REG32((canx) + 0x2D4U)        /*!< CAN filter 18 data 1 register */
N#define CAN_F19DATA1(canx)                 REG32((canx) + 0x2DCU)        /*!< CAN filter 19 data 1 register */
N#define CAN_F20DATA1(canx)                 REG32((canx) + 0x2E4U)        /*!< CAN filter 20 data 1 register */
N#define CAN_F21DATA1(canx)                 REG32((canx) + 0x2ECU)        /*!< CAN filter 21 data 1 register */
N#define CAN_F22DATA1(canx)                 REG32((canx) + 0x2F4U)        /*!< CAN filter 22 data 1 register */
N#define CAN_F23DATA1(canx)                 REG32((canx) + 0x2FCU)        /*!< CAN filter 23 data 1 register */
N#define CAN_F24DATA1(canx)                 REG32((canx) + 0x304U)        /*!< CAN filter 24 data 1 register */
N#define CAN_F25DATA1(canx)                 REG32((canx) + 0x30CU)        /*!< CAN filter 25 data 1 register */
N#define CAN_F26DATA1(canx)                 REG32((canx) + 0x314U)        /*!< CAN filter 26 data 1 register */
N#define CAN_F27DATA1(canx)                 REG32((canx) + 0x31CU)        /*!< CAN filter 27 data 1 register */
N
N/* CAN transmit mailbox bank */
N#define CAN_TMI(canx, bank)                REG32((canx) + 0x180U + ((bank) * 0x10U))        /*!< CAN transmit mailbox identifier register */
N#define CAN_TMP(canx, bank)                REG32((canx) + 0x184U + ((bank) * 0x10U))        /*!< CAN transmit mailbox property register */
N#define CAN_TMDATA0(canx, bank)            REG32((canx) + 0x188U + ((bank) * 0x10U))        /*!< CAN transmit mailbox data0 register */
N#define CAN_TMDATA1(canx, bank)            REG32((canx) + 0x18CU + ((bank) * 0x10U))        /*!< CAN transmit mailbox data1 register */
N
N/* CAN filter bank */
N#define CAN_FDATA0(canx, bank)             REG32((canx) + 0x240U + ((bank) * 0x8U) + 0x0U)  /*!< CAN filter data 0 register */
N#define CAN_FDATA1(canx, bank)             REG32((canx) + 0x240U + ((bank) * 0x8U) + 0x4U)  /*!< CAN filter data 1 register */
N
N/* CAN receive fifo mailbox bank */
N#define CAN_RFIFOMI(canx, bank)            REG32((canx) + 0x1B0U + ((bank) * 0x10U))        /*!< CAN receive FIFO mailbox identifier register */
N#define CAN_RFIFOMP(canx, bank)            REG32((canx) + 0x1B4U + ((bank) * 0x10U))        /*!< CAN receive FIFO mailbox property register */
N#define CAN_RFIFOMDATA0(canx, bank)        REG32((canx) + 0x1B8U + ((bank) * 0x10U))        /*!< CAN receive FIFO mailbox data0 register */
N#define CAN_RFIFOMDATA1(canx, bank)        REG32((canx) + 0x1BCU + ((bank) * 0x10U))        /*!< CAN receive FIFO mailbox data1 register */
N
N/* bits definitions */
N/* CAN_CTL */
N#define CAN_CTL_IWMOD                      BIT(0)                       /*!< initial working mode */
N#define CAN_CTL_SLPWMOD                    BIT(1)                       /*!< sleep working mode */
N#define CAN_CTL_TFO                        BIT(2)                       /*!< transmit FIFO order */
N#define CAN_CTL_RFOD                       BIT(3)                       /*!< receive FIFO overwrite disable */
N#define CAN_CTL_ARD                        BIT(4)                       /*!< automatic retransmission disable */
N#define CAN_CTL_AWU                        BIT(5)                       /*!< automatic wakeup */
N#define CAN_CTL_ABOR                       BIT(6)                       /*!< automatic bus-off recovery */
N#define CAN_CTL_TTC                        BIT(7)                       /*!< time triggered communication */
N#define CAN_CTL_SWRST                      BIT(15)                      /*!< CAN software reset */
N#define CAN_CTL_DFZ                        BIT(16)                      /*!< CAN debug freeze */
N
N/* CAN_STAT */
N#define CAN_STAT_IWS                       BIT(0)                       /*!< initial working state */
N#define CAN_STAT_SLPWS                     BIT(1)                       /*!< sleep working state */
N#define CAN_STAT_ERRIF                     BIT(2)                       /*!< error interrupt flag*/
N#define CAN_STAT_WUIF                      BIT(3)                       /*!< status change interrupt flag of wakeup from sleep working mode */
N#define CAN_STAT_SLPIF                     BIT(4)                       /*!< status change interrupt flag of sleep working mode entering */
N#define CAN_STAT_TS                        BIT(8)                       /*!< transmitting state */
N#define CAN_STAT_RS                        BIT(9)                       /*!< receiving state */
N#define CAN_STAT_LASTRX                    BIT(10)                      /*!< last sample value of rx pin */
N#define CAN_STAT_RXL                       BIT(11)                      /*!< CAN rx signal */
N
N/* CAN_TSTAT */
N#define CAN_TSTAT_MTF0                     BIT(0)                       /*!< mailbox0 transmit finished */
N#define CAN_TSTAT_MTFNERR0                 BIT(1)                       /*!< mailbox0 transmit finished and no error */
N#define CAN_TSTAT_MAL0                     BIT(2)                       /*!< mailbox0 arbitration lost */
N#define CAN_TSTAT_MTE0                     BIT(3)                       /*!< mailbox0 transmit error */
N#define CAN_TSTAT_MST0                     BIT(7)                       /*!< mailbox0 stop transmitting */
N#define CAN_TSTAT_MTF1                     BIT(8)                       /*!< mailbox1 transmit finished */
N#define CAN_TSTAT_MTFNERR1                 BIT(9)                       /*!< mailbox1 transmit finished and no error */
N#define CAN_TSTAT_MAL1                     BIT(10)                      /*!< mailbox1 arbitration lost */
N#define CAN_TSTAT_MTE1                     BIT(11)                      /*!< mailbox1 transmit error */
N#define CAN_TSTAT_MST1                     BIT(15)                      /*!< mailbox1 stop transmitting */
N#define CAN_TSTAT_MTF2                     BIT(16)                      /*!< mailbox2 transmit finished */
N#define CAN_TSTAT_MTFNERR2                 BIT(17)                      /*!< mailbox2 transmit finished and no error */
N#define CAN_TSTAT_MAL2                     BIT(18)                      /*!< mailbox2 arbitration lost */
N#define CAN_TSTAT_MTE2                     BIT(19)                      /*!< mailbox2 transmit error */
N#define CAN_TSTAT_MST2                     BIT(23)                      /*!< mailbox2 stop transmitting */
N#define CAN_TSTAT_NUM                      BITS(24,25)                  /*!< mailbox number */
N#define CAN_TSTAT_TME0                     BIT(26)                      /*!< transmit mailbox0 empty */
N#define CAN_TSTAT_TME1                     BIT(27)                      /*!< transmit mailbox1 empty */
N#define CAN_TSTAT_TME2                     BIT(28)                      /*!< transmit mailbox2 empty */
N#define CAN_TSTAT_TMLS0                    BIT(29)                      /*!< last sending priority flag for mailbox0 */
N#define CAN_TSTAT_TMLS1                    BIT(30)                      /*!< last sending priority flag for mailbox1 */
N#define CAN_TSTAT_TMLS2                    BIT(31)                      /*!< last sending priority flag for mailbox2 */
N
N/* CAN_RFIFO0 */
N#define CAN_RFIFO0_RFL0                    BITS(0,1)                    /*!< receive FIFO0 length */
N#define CAN_RFIFO0_RFF0                    BIT(3)                       /*!< receive FIFO0 full */
N#define CAN_RFIFO0_RFO0                    BIT(4)                       /*!< receive FIFO0 overfull */
N#define CAN_RFIFO0_RFD0                    BIT(5)                       /*!< receive FIFO0 dequeue */
N
N/* CAN_RFIFO1 */
N#define CAN_RFIFO1_RFL1                    BITS(0,1)                    /*!< receive FIFO1 length */
N#define CAN_RFIFO1_RFF1                    BIT(3)                       /*!< receive FIFO1 full */
N#define CAN_RFIFO1_RFO1                    BIT(4)                       /*!< receive FIFO1 overfull */
N#define CAN_RFIFO1_RFD1                    BIT(5)                       /*!< receive FIFO1 dequeue */
N
N/* CAN_INTEN */
N#define CAN_INTEN_TMEIE                    BIT(0)                       /*!< transmit mailbox empty interrupt enable */
N#define CAN_INTEN_RFNEIE0                  BIT(1)                       /*!< receive FIFO0 not empty interrupt enable */
N#define CAN_INTEN_RFFIE0                   BIT(2)                       /*!< receive FIFO0 full interrupt enable */
N#define CAN_INTEN_RFOIE0                   BIT(3)                       /*!< receive FIFO0 overfull interrupt enable */
N#define CAN_INTEN_RFNEIE1                  BIT(4)                       /*!< receive FIFO1 not empty interrupt enable */
N#define CAN_INTEN_RFFIE1                   BIT(5)                       /*!< receive FIFO1 full interrupt enable */
N#define CAN_INTEN_RFOIE1                   BIT(6)                       /*!< receive FIFO1 overfull interrupt enable */
N#define CAN_INTEN_WERRIE                   BIT(8)                       /*!< warning error interrupt enable */
N#define CAN_INTEN_PERRIE                   BIT(9)                       /*!< passive error interrupt enable */
N#define CAN_INTEN_BOIE                     BIT(10)                      /*!< bus-off interrupt enable */
N#define CAN_INTEN_ERRNIE                   BIT(11)                      /*!< error number interrupt enable */
N#define CAN_INTEN_ERRIE                    BIT(15)                      /*!< error interrupt enable */
N#define CAN_INTEN_WIE                      BIT(16)                      /*!< wakeup interrupt enable */
N#define CAN_INTEN_SLPWIE                   BIT(17)                      /*!< sleep working interrupt enable */
N
N/* CAN_ERR */
N#define CAN_ERR_WERR                       BIT(0)                       /*!< warning error */
N#define CAN_ERR_PERR                       BIT(1)                       /*!< passive error */
N#define CAN_ERR_BOERR                      BIT(2)                       /*!< bus-off error */
N#define CAN_ERR_ERRN                       BITS(4,6)                    /*!< error number */
N#define CAN_ERR_TECNT                      BITS(16,23)                  /*!< transmit error count */
N#define CAN_ERR_RECNT                      BITS(24,31)                  /*!< receive error count */
N
N/* CAN_BT */
N#define CAN_BT_BAUDPSC                     BITS(0,9)                    /*!< baudrate prescaler */
N#define CAN_BT_BS1                         BITS(16,19)                  /*!< bit segment 1 */
N#define CAN_BT_BS2                         BITS(20,22)                  /*!< bit segment 2 */
N#define CAN_BT_SJW                         BITS(24,25)                  /*!< resynchronization jump width */
N#define CAN_BT_LCMOD                       BIT(30)                      /*!< loopback communication mode */
N#define CAN_BT_SCMOD                       BIT(31)                      /*!< silent communication mode */
N
N/* CAN_TMIx */
N#define CAN_TMI_TEN                        BIT(0)                       /*!< transmit enable */
N#define CAN_TMI_FT                         BIT(1)                       /*!< frame type */
N#define CAN_TMI_FF                         BIT(2)                       /*!< frame format */
N#define CAN_TMI_EFID                       BITS(3,31)                   /*!< the frame identifier */
N#define CAN_TMI_SFID                       BITS(21,31)                  /*!< the frame identifier */
N
N/* CAN_TMPx */
N#define CAN_TMP_DLENC                      BITS(0,3)                    /*!< data length code */
N#define CAN_TMP_TSEN                       BIT(8)                       /*!< time stamp enable */
N#define CAN_TMP_TS                         BITS(16,31)                  /*!< time stamp */
N
N/* CAN_TMDATA0x */
N#define CAN_TMDATA0_DB0                    BITS(0,7)                    /*!< transmit data byte 0 */
N#define CAN_TMDATA0_DB1                    BITS(8,15)                   /*!< transmit data byte 1 */
N#define CAN_TMDATA0_DB2                    BITS(16,23)                  /*!< transmit data byte 2 */
N#define CAN_TMDATA0_DB3                    BITS(24,31)                  /*!< transmit data byte 3 */
N
N/* CAN_TMDATA1x */
N#define CAN_TMDATA1_DB4                    BITS(0,7)                    /*!< transmit data byte 4 */
N#define CAN_TMDATA1_DB5                    BITS(8,15)                   /*!< transmit data byte 5 */
N#define CAN_TMDATA1_DB6                    BITS(16,23)                  /*!< transmit data byte 6 */
N#define CAN_TMDATA1_DB7                    BITS(24,31)                  /*!< transmit data byte 7 */
N
N/* CAN_RFIFOMIx */
N#define CAN_RFIFOMI_FT                     BIT(1)                       /*!< frame type */
N#define CAN_RFIFOMI_FF                     BIT(2)                       /*!< frame format */
N#define CAN_RFIFOMI_EFID                   BITS(3,31)                   /*!< the frame identifier */
N#define CAN_RFIFOMI_SFID                   BITS(21,31)                  /*!< the frame identifier */
N
N/* CAN_RFIFOMPx */
N#define CAN_RFIFOMP_DLENC                  BITS(0,3)                    /*!< receive data length code */
N#define CAN_RFIFOMP_FI                     BITS(8,15)                   /*!< filter index */
N#define CAN_RFIFOMP_TS                     BITS(16,31)                  /*!< time stamp */
N
N/* CAN_RFIFOMDATA0x */
N#define CAN_RFIFOMDATA0_DB0                BITS(0,7)                    /*!< receive data byte 0 */
N#define CAN_RFIFOMDATA0_DB1                BITS(8,15)                   /*!< receive data byte 1 */
N#define CAN_RFIFOMDATA0_DB2                BITS(16,23)                  /*!< receive data byte 2 */
N#define CAN_RFIFOMDATA0_DB3                BITS(24,31)                  /*!< receive data byte 3 */
N
N/* CAN_RFIFOMDATA1x */
N#define CAN_RFIFOMDATA1_DB4                BITS(0,7)                    /*!< receive data byte 4 */
N#define CAN_RFIFOMDATA1_DB5                BITS(8,15)                   /*!< receive data byte 5 */
N#define CAN_RFIFOMDATA1_DB6                BITS(16,23)                  /*!< receive data byte 6 */
N#define CAN_RFIFOMDATA1_DB7                BITS(24,31)                  /*!< receive data byte 7 */
N
N/* CAN_FCTL */
N#define CAN_FCTL_FLD                       BIT(0)                       /*!< filter lock disable */
N#define CAN_FCTL_HBC1F                     BITS(8,13)                   /*!< header bank of CAN1 filter */
N
N/* CAN_FMCFG */
N#define CAN_FMCFG_FMOD(regval)             BIT(regval)                  /*!< filter mode, list or mask*/
N
N/* CAN_FSCFG */
N#define CAN_FSCFG_FS(regval)               BIT(regval)                  /*!< filter scale, 32 bits or 16 bits*/
N
N/* CAN_FAFIFO */
N#define CAN_FAFIFOR_FAF(regval)            BIT(regval)                  /*!< filter associated with FIFO */
N
N/* CAN_FW */
N#define CAN_FW_FW(regval)                  BIT(regval)                  /*!< filter working */
N
N/* CAN_FxDATAy */
N#define CAN_FDATA_FD(regval)               BIT(regval)                  /*!< filter data */
N
N/* consts definitions */
N/* define the CAN bit position and its register index offset */
N#define CAN_REGIDX_BIT(regidx, bitpos)              (((uint32_t)(regidx) << 6) | (uint32_t)(bitpos))
N#define CAN_REG_VAL(canx, offset)                   (REG32((canx) + ((uint32_t)(offset) >> 6)))
N#define CAN_BIT_POS(val)                            ((uint32_t)(val) & 0x1FU)
N
N#define CAN_REGIDX_BITS(regidx, bitpos0, bitpos1)   (((uint32_t)(regidx) << 12) | ((uint32_t)(bitpos0) << 6) | (uint32_t)(bitpos1))
N#define CAN_REG_VALS(canx, offset)                  (REG32((canx) + ((uint32_t)(offset) >> 12)))
N#define CAN_BIT_POS0(val)                           (((uint32_t)(val) >> 6) & 0x1FU)
N#define CAN_BIT_POS1(val)                           ((uint32_t)(val) & 0x1FU)
N
N/* register offset */
N#define STAT_REG_OFFSET                    ((uint8_t)0x04U)             /*!< STAT register offset */
N#define TSTAT_REG_OFFSET                   ((uint8_t)0x08U)             /*!< TSTAT register offset */
N#define RFIFO0_REG_OFFSET                  ((uint8_t)0x0CU)             /*!< RFIFO0 register offset */
N#define RFIFO1_REG_OFFSET                  ((uint8_t)0x10U)             /*!< RFIFO1 register offset */
N#define ERR_REG_OFFSET                     ((uint8_t)0x18U)             /*!< ERR register offset */
N
N/* CAN flags */
Ntypedef enum
N{
N    /* flags in STAT register */
N    CAN_FLAG_RXL      = CAN_REGIDX_BIT(STAT_REG_OFFSET, 11U),           /*!< RX level */ 
X    CAN_FLAG_RXL      = (((uint32_t)(((uint8_t)0x04U)) << 6) | (uint32_t)(11U)),             
N    CAN_FLAG_LASTRX   = CAN_REGIDX_BIT(STAT_REG_OFFSET, 10U),           /*!< last sample value of RX pin */ 
X    CAN_FLAG_LASTRX   = (((uint32_t)(((uint8_t)0x04U)) << 6) | (uint32_t)(10U)),             
N    CAN_FLAG_RS       = CAN_REGIDX_BIT(STAT_REG_OFFSET, 9U),            /*!< receiving state */ 
X    CAN_FLAG_RS       = (((uint32_t)(((uint8_t)0x04U)) << 6) | (uint32_t)(9U)),              
N    CAN_FLAG_TS       = CAN_REGIDX_BIT(STAT_REG_OFFSET, 8U),            /*!< transmitting state */ 
X    CAN_FLAG_TS       = (((uint32_t)(((uint8_t)0x04U)) << 6) | (uint32_t)(8U)),              
N    CAN_FLAG_SLPIF    = CAN_REGIDX_BIT(STAT_REG_OFFSET, 4U),            /*!< status change flag of entering sleep working mode */ 
X    CAN_FLAG_SLPIF    = (((uint32_t)(((uint8_t)0x04U)) << 6) | (uint32_t)(4U)),              
N    CAN_FLAG_WUIF     = CAN_REGIDX_BIT(STAT_REG_OFFSET, 3U),            /*!< status change flag of wakeup from sleep working mode */ 
X    CAN_FLAG_WUIF     = (((uint32_t)(((uint8_t)0x04U)) << 6) | (uint32_t)(3U)),              
N    CAN_FLAG_ERRIF    = CAN_REGIDX_BIT(STAT_REG_OFFSET, 2U),            /*!< error flag */ 
X    CAN_FLAG_ERRIF    = (((uint32_t)(((uint8_t)0x04U)) << 6) | (uint32_t)(2U)),              
N    CAN_FLAG_SLPWS    = CAN_REGIDX_BIT(STAT_REG_OFFSET, 1U),            /*!< sleep working state */ 
X    CAN_FLAG_SLPWS    = (((uint32_t)(((uint8_t)0x04U)) << 6) | (uint32_t)(1U)),              
N    CAN_FLAG_IWS      = CAN_REGIDX_BIT(STAT_REG_OFFSET, 0U),            /*!< initial working state */ 
X    CAN_FLAG_IWS      = (((uint32_t)(((uint8_t)0x04U)) << 6) | (uint32_t)(0U)),              
N    /* flags in TSTAT register */
N    CAN_FLAG_TMLS2    = CAN_REGIDX_BIT(TSTAT_REG_OFFSET, 31U),          /*!< transmit mailbox 2 last sending in Tx FIFO */ 
X    CAN_FLAG_TMLS2    = (((uint32_t)(((uint8_t)0x08U)) << 6) | (uint32_t)(31U)),            
N    CAN_FLAG_TMLS1    = CAN_REGIDX_BIT(TSTAT_REG_OFFSET, 30U),          /*!< transmit mailbox 1 last sending in Tx FIFO */ 
X    CAN_FLAG_TMLS1    = (((uint32_t)(((uint8_t)0x08U)) << 6) | (uint32_t)(30U)),            
N    CAN_FLAG_TMLS0    = CAN_REGIDX_BIT(TSTAT_REG_OFFSET, 29U),          /*!< transmit mailbox 0 last sending in Tx FIFO */ 
X    CAN_FLAG_TMLS0    = (((uint32_t)(((uint8_t)0x08U)) << 6) | (uint32_t)(29U)),            
N    CAN_FLAG_TME2     = CAN_REGIDX_BIT(TSTAT_REG_OFFSET, 28U),          /*!< transmit mailbox 2 empty */ 
X    CAN_FLAG_TME2     = (((uint32_t)(((uint8_t)0x08U)) << 6) | (uint32_t)(28U)),            
N    CAN_FLAG_TME1     = CAN_REGIDX_BIT(TSTAT_REG_OFFSET, 27U),          /*!< transmit mailbox 1 empty */ 
X    CAN_FLAG_TME1     = (((uint32_t)(((uint8_t)0x08U)) << 6) | (uint32_t)(27U)),            
N    CAN_FLAG_TME0     = CAN_REGIDX_BIT(TSTAT_REG_OFFSET, 26U),          /*!< transmit mailbox 0 empty */ 
X    CAN_FLAG_TME0     = (((uint32_t)(((uint8_t)0x08U)) << 6) | (uint32_t)(26U)),            
N    CAN_FLAG_MTE2     = CAN_REGIDX_BIT(TSTAT_REG_OFFSET, 19U),          /*!< mailbox 2 transmit error */ 
X    CAN_FLAG_MTE2     = (((uint32_t)(((uint8_t)0x08U)) << 6) | (uint32_t)(19U)),            
N    CAN_FLAG_MTE1     = CAN_REGIDX_BIT(TSTAT_REG_OFFSET, 11U),          /*!< mailbox 1 transmit error */ 
X    CAN_FLAG_MTE1     = (((uint32_t)(((uint8_t)0x08U)) << 6) | (uint32_t)(11U)),            
N    CAN_FLAG_MTE0     = CAN_REGIDX_BIT(TSTAT_REG_OFFSET, 3U),           /*!< mailbox 0 transmit error */ 
X    CAN_FLAG_MTE0     = (((uint32_t)(((uint8_t)0x08U)) << 6) | (uint32_t)(3U)),             
N    CAN_FLAG_MAL2     = CAN_REGIDX_BIT(TSTAT_REG_OFFSET, 18U),          /*!< mailbox 2 arbitration lost */ 
X    CAN_FLAG_MAL2     = (((uint32_t)(((uint8_t)0x08U)) << 6) | (uint32_t)(18U)),            
N    CAN_FLAG_MAL1     = CAN_REGIDX_BIT(TSTAT_REG_OFFSET, 10U),          /*!< mailbox 1 arbitration lost */ 
X    CAN_FLAG_MAL1     = (((uint32_t)(((uint8_t)0x08U)) << 6) | (uint32_t)(10U)),            
N    CAN_FLAG_MAL0     = CAN_REGIDX_BIT(TSTAT_REG_OFFSET, 2U),           /*!< mailbox 0 arbitration lost */ 
X    CAN_FLAG_MAL0     = (((uint32_t)(((uint8_t)0x08U)) << 6) | (uint32_t)(2U)),             
N    CAN_FLAG_MTFNERR2 = CAN_REGIDX_BIT(TSTAT_REG_OFFSET, 17U),          /*!< mailbox 2 transmit finished with no error */ 
X    CAN_FLAG_MTFNERR2 = (((uint32_t)(((uint8_t)0x08U)) << 6) | (uint32_t)(17U)),            
N    CAN_FLAG_MTFNERR1 = CAN_REGIDX_BIT(TSTAT_REG_OFFSET, 9U),           /*!< mailbox 1 transmit finished with no error */ 
X    CAN_FLAG_MTFNERR1 = (((uint32_t)(((uint8_t)0x08U)) << 6) | (uint32_t)(9U)),             
N    CAN_FLAG_MTFNERR0 = CAN_REGIDX_BIT(TSTAT_REG_OFFSET, 1U),           /*!< mailbox 0 transmit finished with no error */ 
X    CAN_FLAG_MTFNERR0 = (((uint32_t)(((uint8_t)0x08U)) << 6) | (uint32_t)(1U)),             
N    CAN_FLAG_MTF2     = CAN_REGIDX_BIT(TSTAT_REG_OFFSET, 16U),          /*!< mailbox 2 transmit finished */ 
X    CAN_FLAG_MTF2     = (((uint32_t)(((uint8_t)0x08U)) << 6) | (uint32_t)(16U)),            
N    CAN_FLAG_MTF1     = CAN_REGIDX_BIT(TSTAT_REG_OFFSET, 8U),           /*!< mailbox 1 transmit finished */ 
X    CAN_FLAG_MTF1     = (((uint32_t)(((uint8_t)0x08U)) << 6) | (uint32_t)(8U)),             
N    CAN_FLAG_MTF0     = CAN_REGIDX_BIT(TSTAT_REG_OFFSET, 0U),           /*!< mailbox 0 transmit finished */ 
X    CAN_FLAG_MTF0     = (((uint32_t)(((uint8_t)0x08U)) << 6) | (uint32_t)(0U)),             
N    /* flags in RFIFO0 register */
N    CAN_FLAG_RFO0     = CAN_REGIDX_BIT(RFIFO0_REG_OFFSET, 4U),          /*!< receive FIFO0 overfull */ 
X    CAN_FLAG_RFO0     = (((uint32_t)(((uint8_t)0x0CU)) << 6) | (uint32_t)(4U)),            
N    CAN_FLAG_RFF0     = CAN_REGIDX_BIT(RFIFO0_REG_OFFSET, 3U),          /*!< receive FIFO0 full */ 
X    CAN_FLAG_RFF0     = (((uint32_t)(((uint8_t)0x0CU)) << 6) | (uint32_t)(3U)),            
N    /* flags in RFIFO1 register */
N    CAN_FLAG_RFO1     = CAN_REGIDX_BIT(RFIFO1_REG_OFFSET, 4U),          /*!< receive FIFO1 overfull */ 
X    CAN_FLAG_RFO1     = (((uint32_t)(((uint8_t)0x10U)) << 6) | (uint32_t)(4U)),            
N    CAN_FLAG_RFF1     = CAN_REGIDX_BIT(RFIFO1_REG_OFFSET, 3U),          /*!< receive FIFO1 full */ 
X    CAN_FLAG_RFF1     = (((uint32_t)(((uint8_t)0x10U)) << 6) | (uint32_t)(3U)),            
N    /* flags in ERR register */
N    CAN_FLAG_BOERR    = CAN_REGIDX_BIT(ERR_REG_OFFSET, 2U),             /*!< bus-off error */ 
X    CAN_FLAG_BOERR    = (((uint32_t)(((uint8_t)0x18U)) << 6) | (uint32_t)(2U)),               
N    CAN_FLAG_PERR     = CAN_REGIDX_BIT(ERR_REG_OFFSET, 1U),             /*!< passive error */ 
X    CAN_FLAG_PERR     = (((uint32_t)(((uint8_t)0x18U)) << 6) | (uint32_t)(1U)),               
N    CAN_FLAG_WERR     = CAN_REGIDX_BIT(ERR_REG_OFFSET, 0U),             /*!< warning error */ 
X    CAN_FLAG_WERR     = (((uint32_t)(((uint8_t)0x18U)) << 6) | (uint32_t)(0U)),               
N}can_flag_enum;
N
N/* CAN interrupt flags */
Ntypedef enum
N{
N    /* interrupt flags in STAT register */
N    CAN_INT_FLAG_SLPIF = CAN_REGIDX_BITS(STAT_REG_OFFSET, 4U, 17U),     /*!< status change interrupt flag of sleep working mode entering */ 
X    CAN_INT_FLAG_SLPIF = (((uint32_t)(((uint8_t)0x04U)) << 12) | ((uint32_t)(4U) << 6) | (uint32_t)(17U)),       
N    CAN_INT_FLAG_WUIF  = CAN_REGIDX_BITS(STAT_REG_OFFSET, 3U, 16),      /*!< status change interrupt flag of wakeup from sleep working mode */ 
X    CAN_INT_FLAG_WUIF  = (((uint32_t)(((uint8_t)0x04U)) << 12) | ((uint32_t)(3U) << 6) | (uint32_t)(16)),        
N    CAN_INT_FLAG_ERRIF = CAN_REGIDX_BITS(STAT_REG_OFFSET, 2U, 15),      /*!< error interrupt flag */ 
X    CAN_INT_FLAG_ERRIF = (((uint32_t)(((uint8_t)0x04U)) << 12) | ((uint32_t)(2U) << 6) | (uint32_t)(15)),        
N    /* interrupt flags in TSTAT register */
N    CAN_INT_FLAG_MTF2  = CAN_REGIDX_BITS(TSTAT_REG_OFFSET, 16U, 0U),    /*!< mailbox 2 transmit finished interrupt flag */
X    CAN_INT_FLAG_MTF2  = (((uint32_t)(((uint8_t)0x08U)) << 12) | ((uint32_t)(16U) << 6) | (uint32_t)(0U)),     
N    CAN_INT_FLAG_MTF1  = CAN_REGIDX_BITS(TSTAT_REG_OFFSET, 8U, 0U),     /*!< mailbox 1 transmit finished interrupt flag */
X    CAN_INT_FLAG_MTF1  = (((uint32_t)(((uint8_t)0x08U)) << 12) | ((uint32_t)(8U) << 6) | (uint32_t)(0U)),      
N    CAN_INT_FLAG_MTF0  = CAN_REGIDX_BITS(TSTAT_REG_OFFSET, 0U, 0U),     /*!< mailbox 0 transmit finished interrupt flag */
X    CAN_INT_FLAG_MTF0  = (((uint32_t)(((uint8_t)0x08U)) << 12) | ((uint32_t)(0U) << 6) | (uint32_t)(0U)),      
N    /* interrupt flags in RFIFO0 register */
N    CAN_INT_FLAG_RFO0  = CAN_REGIDX_BITS(RFIFO0_REG_OFFSET, 4U, 3U),    /*!< receive FIFO0 overfull interrupt flag */
X    CAN_INT_FLAG_RFO0  = (((uint32_t)(((uint8_t)0x0CU)) << 12) | ((uint32_t)(4U) << 6) | (uint32_t)(3U)),     
N    CAN_INT_FLAG_RFF0  = CAN_REGIDX_BITS(RFIFO0_REG_OFFSET, 3U, 2U),    /*!< receive FIFO0 full interrupt flag */
X    CAN_INT_FLAG_RFF0  = (((uint32_t)(((uint8_t)0x0CU)) << 12) | ((uint32_t)(3U) << 6) | (uint32_t)(2U)),     
N    CAN_INT_FLAG_RFL0  = CAN_REGIDX_BITS(RFIFO0_REG_OFFSET, 2U, 1U),    /*!< receive FIFO0 not empty interrupt flag */
X    CAN_INT_FLAG_RFL0  = (((uint32_t)(((uint8_t)0x0CU)) << 12) | ((uint32_t)(2U) << 6) | (uint32_t)(1U)),     
N    /* interrupt flags in RFIFO0 register */
N    CAN_INT_FLAG_RFO1  = CAN_REGIDX_BITS(RFIFO1_REG_OFFSET, 4U, 6U),    /*!< receive FIFO1 overfull interrupt flag */
X    CAN_INT_FLAG_RFO1  = (((uint32_t)(((uint8_t)0x10U)) << 12) | ((uint32_t)(4U) << 6) | (uint32_t)(6U)),     
N    CAN_INT_FLAG_RFF1  = CAN_REGIDX_BITS(RFIFO1_REG_OFFSET, 3U, 5U),    /*!< receive FIFO1 full interrupt flag */
X    CAN_INT_FLAG_RFF1  = (((uint32_t)(((uint8_t)0x10U)) << 12) | ((uint32_t)(3U) << 6) | (uint32_t)(5U)),     
N    CAN_INT_FLAG_RFL1  = CAN_REGIDX_BITS(RFIFO1_REG_OFFSET, 2U, 4U),    /*!< receive FIFO0 not empty interrupt flag */
X    CAN_INT_FLAG_RFL1  = (((uint32_t)(((uint8_t)0x10U)) << 12) | ((uint32_t)(2U) << 6) | (uint32_t)(4U)),     
N    /* interrupt flags in ERR register */
N    CAN_INT_FLAG_ERRN  = CAN_REGIDX_BITS(ERR_REG_OFFSET, 3U, 11U),      /*!< error number interrupt flag */ 
X    CAN_INT_FLAG_ERRN  = (((uint32_t)(((uint8_t)0x18U)) << 12) | ((uint32_t)(3U) << 6) | (uint32_t)(11U)),        
N    CAN_INT_FLAG_BOERR = CAN_REGIDX_BITS(ERR_REG_OFFSET, 2U, 10U),      /*!< bus-off error interrupt flag */ 
X    CAN_INT_FLAG_BOERR = (((uint32_t)(((uint8_t)0x18U)) << 12) | ((uint32_t)(2U) << 6) | (uint32_t)(10U)),        
N    CAN_INT_FLAG_PERR  = CAN_REGIDX_BITS(ERR_REG_OFFSET, 1U, 9U),       /*!< passive error interrupt flag */ 
X    CAN_INT_FLAG_PERR  = (((uint32_t)(((uint8_t)0x18U)) << 12) | ((uint32_t)(1U) << 6) | (uint32_t)(9U)),         
N    CAN_INT_FLAG_WERR  = CAN_REGIDX_BITS(ERR_REG_OFFSET, 0U, 8U),       /*!< warning error interrupt flag */ 
X    CAN_INT_FLAG_WERR  = (((uint32_t)(((uint8_t)0x18U)) << 12) | ((uint32_t)(0U) << 6) | (uint32_t)(8U)),         
N}can_interrupt_flag_enum;
N
N/* CAN initiliaze parameters struct */
Ntypedef struct
N{
N    uint8_t working_mode;                                               /*!< CAN working mode */ 
N    uint8_t resync_jump_width;                                          /*!< CAN resynchronization jump width */
N    uint8_t time_segment_1;                                             /*!< time segment 1 */
N    uint8_t time_segment_2;                                             /*!< time segment 2 */
N    ControlStatus time_triggered;                                       /*!< time triggered communication mode */
N    ControlStatus auto_bus_off_recovery;                                /*!< automatic bus-off recovery */
N    ControlStatus auto_wake_up;                                         /*!< automatic wake-up mode */
N    ControlStatus no_auto_retrans;                                      /*!< automatic retransmission mode disable */
N    ControlStatus rec_fifo_overwrite;                                   /*!< receive FIFO overwrite mode */
N    ControlStatus trans_fifo_order;                                     /*!< transmit FIFO order */
N    uint16_t prescaler;                                                 /*!< baudrate prescaler */
N}can_parameter_struct;
N
N/* CAN transmit message struct */
Ntypedef struct
N{
N    uint32_t tx_sfid;                                                   /*!< standard format frame identifier */
N    uint32_t tx_efid;                                                   /*!< extended format frame identifier */
N    uint8_t tx_ff;                                                      /*!< format of frame, standard or extended format */
N    uint8_t tx_ft;                                                      /*!< type of frame, data or remote */
N    uint8_t tx_dlen;                                                    /*!< data length */
N    uint8_t tx_data[8];                                                 /*!< transmit data */
N}can_trasnmit_message_struct;
N
N/* CAN receive message struct */
Ntypedef struct
N{
N    uint32_t rx_sfid;                                                   /*!< standard format frame identifier */
N    uint32_t rx_efid;                                                   /*!< extended format frame identifier */
N    uint8_t rx_ff;                                                      /*!< format of frame, standard or extended format */
N    uint8_t rx_ft;                                                      /*!< type of frame, data or remote */
N    uint8_t rx_dlen;                                                    /*!< data length */
N    uint8_t rx_data[8];                                                 /*!< receive data */
N    uint8_t rx_fi;                                                      /*!< filtering index */
N} can_receive_message_struct;
N
N/* CAN filter parameters struct */
Ntypedef struct
N{
N    uint16_t filter_list_high;                                          /*!< filter list number high bits*/
N    uint16_t filter_list_low;                                           /*!< filter list number low bits */
N    uint16_t filter_mask_high;                                          /*!< filter mask number high bits */
N    uint16_t filter_mask_low;                                           /*!< filter mask number low bits */
N    uint16_t filter_fifo_number;                                        /*!< receive FIFO associated with the filter */
N    uint16_t filter_number;                                             /*!< filter number */
N    uint16_t filter_mode;                                               /*!< filter mode, list or mask */
N    uint16_t filter_bits;                                               /*!< filter scale */
N    ControlStatus filter_enable;                                        /*!< filter work or not */
N}can_filter_parameter_struct;
N
N/* CAN errors */
Ntypedef enum
N{
N    CAN_ERROR_NONE = 0,                                                 /*!< no error */
N    CAN_ERROR_FILL,                                                     /*!< fill error */
N    CAN_ERROR_FORMATE,                                                  /*!< format error */
N    CAN_ERROR_ACK,                                                      /*!< ACK error */
N    CAN_ERROR_BITRECESSIVE,                                             /*!< bit recessive error */
N    CAN_ERROR_BITDOMINANTER,                                            /*!< bit dominant error */
N    CAN_ERROR_CRC,                                                      /*!< CRC error */
N    CAN_ERROR_SOFTWARECFG,                                              /*!< software configure */
N}can_error_enum;
N
N/* transmit states */
Ntypedef enum
N{
N    CAN_TRANSMIT_FAILED = 0U,                                            /*!< CAN transmitted failure */
N    CAN_TRANSMIT_OK = 1U,                                                /*!< CAN transmitted success */
N    CAN_TRANSMIT_PENDING = 2U,                                           /*!< CAN transmitted pending */
N    CAN_TRANSMIT_NOMAILBOX = 4U,                                         /*!< no empty mailbox to be used for CAN */
N}can_transmit_state_enum;
N
Ntypedef enum
N{
N    CAN_INIT_STRUCT = 0,                                                /* CAN initiliaze parameters struct */
N    CAN_FILTER_STRUCT,                                                  /* CAN filter parameters struct */
N    CAN_TX_MESSAGE_STRUCT,                                              /* CAN transmit message struct */
N    CAN_RX_MESSAGE_STRUCT,                                              /* CAN receive message struct */
N}can_struct_type_enum;
N
N/* CAN baudrate prescaler*/
N#define BT_BAUDPSC(regval)                 (BITS(0,9) & ((uint32_t)(regval) << 0))
N
N/* CAN bit segment 1*/
N#define BT_BS1(regval)                     (BITS(16,19) & ((uint32_t)(regval) << 16))
N
N/* CAN bit segment 2*/
N#define BT_BS2(regval)                     (BITS(20,22) & ((uint32_t)(regval) << 20))
N
N/* CAN resynchronization jump width*/
N#define BT_SJW(regval)                     (BITS(24,25) & ((uint32_t)(regval) << 24))
N
N/* CAN communication mode*/
N#define BT_MODE(regval)                    (BITS(30,31) & ((uint32_t)(regval) << 30))
N
N/* CAN FDATA high 16 bits */
N#define FDATA_MASK_HIGH(regval)            (BITS(16,31) & ((uint32_t)(regval) << 16))
N
N/* CAN FDATA low 16 bits */
N#define FDATA_MASK_LOW(regval)             (BITS(0,15) & ((uint32_t)(regval) << 0))
N
N/* CAN1 filter start bank_number*/
N#define FCTL_HBC1F(regval)                 (BITS(8,13) & ((uint32_t)(regval) << 8))
N
N/* CAN transmit mailbox extended identifier*/
N#define TMI_EFID(regval)                   (BITS(3,31) & ((uint32_t)(regval) << 3))
N
N/* CAN transmit mailbox standard identifier*/
N#define TMI_SFID(regval)                   (BITS(21,31) & ((uint32_t)(regval) << 21))
N
N/* transmit data byte 0 */
N#define TMDATA0_DB0(regval)                (BITS(0,7) & ((uint32_t)(regval) << 0))
N
N/* transmit data byte 1 */
N#define TMDATA0_DB1(regval)                (BITS(8,15) & ((uint32_t)(regval) << 8))
N
N/* transmit data byte 2 */
N#define TMDATA0_DB2(regval)                (BITS(16,23) & ((uint32_t)(regval) << 16))
N
N/* transmit data byte 3 */                 
N#define TMDATA0_DB3(regval)                (BITS(24,31) & ((uint32_t)(regval) << 24))
N
N/* transmit data byte 4 */                 
N#define TMDATA1_DB4(regval)                (BITS(0,7) & ((uint32_t)(regval) << 0))
N
N/* transmit data byte 5 */                 
N#define TMDATA1_DB5(regval)                (BITS(8,15) & ((uint32_t)(regval) << 8))
N
N/* transmit data byte 6 */                 
N#define TMDATA1_DB6(regval)                (BITS(16,23) & ((uint32_t)(regval) << 16))
N
N/* transmit data byte 7 */                 
N#define TMDATA1_DB7(regval)                (BITS(24,31) & ((uint32_t)(regval) << 24))
N
N/* receive mailbox extended identifier*/
N#define GET_RFIFOMI_EFID(regval)           GET_BITS((uint32_t)(regval), 3U, 31U)
N
N/* receive mailbox standrad identifier*/
N#define GET_RFIFOMI_SFID(regval)           GET_BITS((uint32_t)(regval), 21U, 31U)
N
N/* receive data length */
N#define GET_RFIFOMP_DLENC(regval)          GET_BITS((uint32_t)(regval), 0U, 3U)
N
N/* the index of the filter by which the frame is passed */
N#define GET_RFIFOMP_FI(regval)             GET_BITS((uint32_t)(regval), 8U, 15U)
N
N/* receive data byte 0 */
N#define GET_RFIFOMDATA0_DB0(regval)        GET_BITS((uint32_t)(regval), 0U, 7U)
N
N/* receive data byte 1 */
N#define GET_RFIFOMDATA0_DB1(regval)        GET_BITS((uint32_t)(regval), 8U, 15U)
N
N/* receive data byte 2 */
N#define GET_RFIFOMDATA0_DB2(regval)        GET_BITS((uint32_t)(regval), 16U, 23U)
N
N/* receive data byte 3 */
N#define GET_RFIFOMDATA0_DB3(regval)        GET_BITS((uint32_t)(regval), 24U, 31U)
N
N/* receive data byte 4 */
N#define GET_RFIFOMDATA1_DB4(regval)        GET_BITS((uint32_t)(regval), 0U, 7U)
N
N/* receive data byte 5 */
N#define GET_RFIFOMDATA1_DB5(regval)        GET_BITS((uint32_t)(regval), 8U, 15U)
N
N/* receive data byte 6 */
N#define GET_RFIFOMDATA1_DB6(regval)        GET_BITS((uint32_t)(regval), 16U, 23U)
N
N/* receive data byte 7 */
N#define GET_RFIFOMDATA1_DB7(regval)        GET_BITS((uint32_t)(regval), 24U, 31U)
N
N/* error number */        
N#define GET_ERR_ERRN(regval)               GET_BITS((uint32_t)(regval), 4U, 6U)
N
N/* transmit error count */        
N#define GET_ERR_TECNT(regval)              GET_BITS((uint32_t)(regval), 16U, 23U)
N
N/* receive  error count */        
N#define GET_ERR_RECNT(regval)              GET_BITS((uint32_t)(regval), 24U, 31U)
N
N/* CAN errors */
N#define ERR_ERRN(regval)                   (BITS(4,6) & ((uint32_t)(regval) << 4))
N#define CAN_ERRN_0                         ERR_ERRN(0U)                  /* no error */
N#define CAN_ERRN_1                         ERR_ERRN(1U)                  /*!< fill error */
N#define CAN_ERRN_2                         ERR_ERRN(2U)                  /*!< format error */
N#define CAN_ERRN_3                         ERR_ERRN(3U)                  /*!< ACK error */
N#define CAN_ERRN_4                         ERR_ERRN(4U)                  /*!< bit recessive error */
N#define CAN_ERRN_5                         ERR_ERRN(5U)                  /*!< bit dominant error */
N#define CAN_ERRN_6                         ERR_ERRN(6U)                  /*!< CRC error */
N#define CAN_ERRN_7                         ERR_ERRN(7U)                  /*!< software error */
N
N#define CAN_STATE_PENDING                  ((uint32_t)0x00000000U)      /*!< CAN pending */
N
N/* CAN communication mode */
N#define CAN_NORMAL_MODE                    ((uint8_t)0x00U)             /*!< normal communication mode */
N#define CAN_LOOPBACK_MODE                  ((uint8_t)0x01U)             /*!< loopback communication mode */
N#define CAN_SILENT_MODE                    ((uint8_t)0x02U)             /*!< silent communication mode */
N#define CAN_SILENT_LOOPBACK_MODE           ((uint8_t)0x03U)             /*!< loopback and silent communication mode */
N
N/* CAN resynchronisation jump width */
N#define CAN_BT_SJW_1TQ                     ((uint8_t)0x00U)             /*!< 1 time quanta */
N#define CAN_BT_SJW_2TQ                     ((uint8_t)0x01U)             /*!< 2 time quanta */
N#define CAN_BT_SJW_3TQ                     ((uint8_t)0x02U)             /*!< 3 time quanta */
N#define CAN_BT_SJW_4TQ                     ((uint8_t)0x03U)             /*!< 4 time quanta */
N
N/* CAN time segment 1 */
N#define CAN_BT_BS1_1TQ                     ((uint8_t)0x00U)             /*!< 1 time quanta */
N#define CAN_BT_BS1_2TQ                     ((uint8_t)0x01U)             /*!< 2 time quanta */
N#define CAN_BT_BS1_3TQ                     ((uint8_t)0x02U)             /*!< 3 time quanta */
N#define CAN_BT_BS1_4TQ                     ((uint8_t)0x03U)             /*!< 4 time quanta */
N#define CAN_BT_BS1_5TQ                     ((uint8_t)0x04U)             /*!< 5 time quanta */
N#define CAN_BT_BS1_6TQ                     ((uint8_t)0x05U)             /*!< 6 time quanta */
N#define CAN_BT_BS1_7TQ                     ((uint8_t)0x06U)             /*!< 7 time quanta */
N#define CAN_BT_BS1_8TQ                     ((uint8_t)0x07U)             /*!< 8 time quanta */
N#define CAN_BT_BS1_9TQ                     ((uint8_t)0x08U)             /*!< 9 time quanta */
N#define CAN_BT_BS1_10TQ                    ((uint8_t)0x09U)             /*!< 10 time quanta */
N#define CAN_BT_BS1_11TQ                    ((uint8_t)0x0AU)             /*!< 11 time quanta */
N#define CAN_BT_BS1_12TQ                    ((uint8_t)0x0BU)             /*!< 12 time quanta */
N#define CAN_BT_BS1_13TQ                    ((uint8_t)0x0CU)             /*!< 13 time quanta */
N#define CAN_BT_BS1_14TQ                    ((uint8_t)0x0DU)             /*!< 14 time quanta */
N#define CAN_BT_BS1_15TQ                    ((uint8_t)0x0EU)             /*!< 15 time quanta */
N#define CAN_BT_BS1_16TQ                    ((uint8_t)0x0FU)             /*!< 16 time quanta */
N
N/* CAN time segment 2 */
N#define CAN_BT_BS2_1TQ                     ((uint8_t)0x00U)             /*!< 1 time quanta */
N#define CAN_BT_BS2_2TQ                     ((uint8_t)0x01U)             /*!< 2 time quanta */
N#define CAN_BT_BS2_3TQ                     ((uint8_t)0x02U)             /*!< 3 time quanta */
N#define CAN_BT_BS2_4TQ                     ((uint8_t)0x03U)             /*!< 4 time quanta */
N#define CAN_BT_BS2_5TQ                     ((uint8_t)0x04U)             /*!< 5 time quanta */
N#define CAN_BT_BS2_6TQ                     ((uint8_t)0x05U)             /*!< 6 time quanta */
N#define CAN_BT_BS2_7TQ                     ((uint8_t)0x06U)             /*!< 7 time quanta */
N#define CAN_BT_BS2_8TQ                     ((uint8_t)0x07U)             /*!< 8 time quanta */
N
N/* CAN mailbox number */
N#define CAN_MAILBOX0                       ((uint8_t)0x00U)             /*!< mailbox0 */
N#define CAN_MAILBOX1                       ((uint8_t)0x01U)             /*!< mailbox1 */
N#define CAN_MAILBOX2                       ((uint8_t)0x02U)             /*!< mailbox2 */
N#define CAN_NOMAILBOX                      ((uint8_t)0x03U)             /*!< no mailbox empty */
N
N/* CAN frame format */
N#define CAN_FF_STANDARD                    ((uint32_t)0x00000000U)      /*!< standard frame */
N#define CAN_FF_EXTENDED                    ((uint32_t)0x00000004U)      /*!< extended frame */
N
N/* CAN receive fifo */
N#define CAN_FIFO0                          ((uint8_t)0x00U)             /*!< receive FIFO0 */
N#define CAN_FIFO1                          ((uint8_t)0x01U)             /*!< receive FIFO1 */
N
N/* frame number of receive fifo */
N#define CAN_RFIF_RFL_MASK                  ((uint32_t)0x00000003U)      /*!< mask for frame number in receive FIFOx */
N
N#define CAN_SFID_MASK                      ((uint32_t)0x000007FFU)      /*!< mask of standard identifier */
N#define CAN_EFID_MASK                      ((uint32_t)0x1FFFFFFFU)      /*!< mask of extended identifier */
N
N/* CAN working mode */
N#define CAN_MODE_INITIALIZE                ((uint8_t)0x01U)             /*!< CAN initialize mode */
N#define CAN_MODE_NORMAL                    ((uint8_t)0x02U)             /*!< CAN normal mode */
N#define CAN_MODE_SLEEP                     ((uint8_t)0x04U)             /*!< CAN sleep mode */
N
N/* filter bits */
N#define CAN_FILTERBITS_16BIT               ((uint8_t)0x00U)             /*!< CAN filter 16 bits */
N#define CAN_FILTERBITS_32BIT               ((uint8_t)0x01U)             /*!< CAN filter 32 bits */
N
N/* filter mode */
N#define CAN_FILTERMODE_MASK                ((uint8_t)0x00U)             /*!< mask mode */
N#define CAN_FILTERMODE_LIST                ((uint8_t)0x01U)             /*!< list mode */
N
N/* filter 16 bits mask */
N#define CAN_FILTER_MASK_16BITS             ((uint32_t)0x0000FFFFU)      /*!< can filter 16 bits mask */
N
N/* frame type */
N#define CAN_FT_DATA                        ((uint32_t)0x00000000U)      /*!< data frame */
N#define CAN_FT_REMOTE                      ((uint32_t)0x00000002U)      /*!< remote frame */
N
N/* CAN timeout */
N#define CAN_TIMEOUT                        ((uint32_t)0x0000FFFFU)      /*!< timeout value */
N
N/* interrupt enable bits */
N#define CAN_INT_TME                        CAN_INTEN_TMEIE              /*!< transmit mailbox empty interrupt enable */
N#define CAN_INT_RFNE0                      CAN_INTEN_RFNEIE0            /*!< receive FIFO0 not empty interrupt enable */
N#define CAN_INT_RFF0                       CAN_INTEN_RFFIE0             /*!< receive FIFO0 full interrupt enable */
N#define CAN_INT_RFO0                       CAN_INTEN_RFOIE0             /*!< receive FIFO0 overfull interrupt enable */
N#define CAN_INT_RFNE1                      CAN_INTEN_RFNEIE1            /*!< receive FIFO1 not empty interrupt enable */
N#define CAN_INT_RFF1                       CAN_INTEN_RFFIE1             /*!< receive FIFO1 full interrupt enable */
N#define CAN_INT_RFO1                       CAN_INTEN_RFOIE1             /*!< receive FIFO1 overfull interrupt enable */
N#define CAN_INT_WERR                       CAN_INTEN_WERRIE             /*!< warning error interrupt enable */
N#define CAN_INT_PERR                       CAN_INTEN_PERRIE             /*!< passive error interrupt enable */
N#define CAN_INT_BO                         CAN_INTEN_BOIE               /*!< bus-off interrupt enable */
N#define CAN_INT_ERRN                       CAN_INTEN_ERRNIE             /*!< error number interrupt enable */
N#define CAN_INT_ERR                        CAN_INTEN_ERRIE              /*!< error interrupt enable */
N#define CAN_INT_WAKEUP                     CAN_INTEN_WIE                /*!< wakeup interrupt enable */
N#define CAN_INT_SLPW                       CAN_INTEN_SLPWIE             /*!< sleep working interrupt enable */
N
N/* function declarations */
N/* deinitialize CAN */
Nvoid can_deinit(uint32_t can_periph);
N/* initialize CAN struct */
Nvoid can_struct_para_init(can_struct_type_enum type, void* p_struct);
N/* initialize CAN */
NErrStatus can_init(uint32_t can_periph, can_parameter_struct* can_parameter_init);
N/* CAN filter init */
Nvoid can_filter_init(can_filter_parameter_struct* can_filter_parameter_init);
N/* set can1 fliter start bank number */
Nvoid can1_filter_start_bank(uint8_t start_bank);
N/* enable functions */
N/* CAN debug freeze enable */
Nvoid can_debug_freeze_enable(uint32_t can_periph);
N/* CAN debug freeze disable */
Nvoid can_debug_freeze_disable(uint32_t can_periph);
N/* CAN time trigger mode enable */
Nvoid can_time_trigger_mode_enable(uint32_t can_periph);
N/* CAN time trigger mode disable */
Nvoid can_time_trigger_mode_disable(uint32_t can_periph);
N
N/* transmit functions */
N/* transmit CAN message */
Nuint8_t can_message_transmit(uint32_t can_periph, can_trasnmit_message_struct* transmit_message);
N/* get CAN transmit state */
Ncan_transmit_state_enum can_transmit_states(uint32_t can_periph, uint8_t mailbox_number);
N/* stop CAN transmission */
Nvoid can_transmission_stop(uint32_t can_periph, uint8_t mailbox_number);
N/* CAN receive message */
Nvoid can_message_receive(uint32_t can_periph, uint8_t fifo_number, can_receive_message_struct* receive_message);
N/* CAN release fifo */
Nvoid can_fifo_release(uint32_t can_periph, uint8_t fifo_number);
N/* CAN receive message length */
Nuint8_t can_receive_message_length_get(uint32_t can_periph, uint8_t fifo_number);
N/* CAN working mode */
NErrStatus can_working_mode_set(uint32_t can_periph, uint8_t working_mode);
N/* CAN wakeup from sleep mode */
NErrStatus can_wakeup(uint32_t can_periph);
N
N/* CAN get error */
Ncan_error_enum can_error_get(uint32_t can_periph);
N/* get CAN receive error number */
Nuint8_t can_receive_error_number_get(uint32_t can_periph);
N/* get CAN transmit error number */
Nuint8_t can_transmit_error_number_get(uint32_t can_periph);
N
N/* CAN interrupt enable */
Nvoid can_interrupt_enable(uint32_t can_periph, uint32_t interrupt);
N/* CAN interrupt disable */
Nvoid can_interrupt_disable(uint32_t can_periph, uint32_t interrupt);
N/* CAN get flag state */
NFlagStatus can_flag_get(uint32_t can_periph, can_flag_enum flag);
N/* CAN clear flag state */
Nvoid can_flag_clear(uint32_t can_periph, can_flag_enum flag);
N/* CAN get interrupt flag state */
NFlagStatus can_interrupt_flag_get(uint32_t can_periph, can_interrupt_flag_enum flag);
N/* CAN clear interrupt flag state */
Nvoid can_interrupt_flag_clear(uint32_t can_periph, can_interrupt_flag_enum flag);
N
N#endif /* GD32F10x_CAN_H */
L 63 ".\User\gd32f10x_libopt.h" 2
N#include "gd32f10x_enet.h"
L 1 ".\Libraries\inc\gd32f10x_enet.h" 1
N/*!
N    \file    gd32f10x_enet.h
N    \brief   definitions for the ENET
N
N    \version 2014-12-26, V1.0.0, firmware for GD32F10x
N    \version 2017-06-20, V2.0.0, firmware for GD32F10x
N    \version 2018-07-31, V2.1.0, firmware for GD32F10x
N*/
N
N/*
N    Copyright (c) 2018, GigaDevice Semiconductor Inc.
N
N    All rights reserved.
N
N    Redistribution and use in source and binary forms, with or without modification, 
Nare permitted provided that the following conditions are met:
N
N    1. Redistributions of source code must retain the above copyright notice, this 
N       list of conditions and the following disclaimer.
N    2. Redistributions in binary form must reproduce the above copyright notice, 
N       this list of conditions and the following disclaimer in the documentation 
N       and/or other materials provided with the distribution.
N    3. Neither the name of the copyright holder nor the names of its contributors 
N       may be used to endorse or promote products derived from this software without 
N       specific prior written permission.
N
N    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
NAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
NWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
NIN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
NINDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
NNOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
NPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
NWHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
NARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
NOF SUCH DAMAGE.
N*/
N
N#ifndef GD32F10x_ENET_H
N#define GD32F10x_ENET_H
N
N#include "gd32f10x.h"
N#include <stdlib.h>
L 1 "D:\Keil_v5\ARM\ARMCC\Bin\..\include\stdlib.h" 1
N/* stdlib.h: ANSI draft (X3J11 May 88) library header, section 4.10 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                          */
N/* Copyright 1991-1998,2014 STS Limited. All rights reserved.       */
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N 
N/*
N * stdlib.h declares four types, several general purpose functions,
N * and defines several macros.
N */
N
N#ifndef __stdlib_h
N#define __stdlib_h
N#define __STSCLIB_VERSION 5060044
N
N#if defined(__clang__) || (defined(__STSCC_VERSION) && !defined(__STRICT_ANSI__))
X#if 0L || (0L && !0L)
S  /* STSclang and non-strict STScc allow 'long long' in system headers */
S  #define __LONGLONG long long
N#else
N  /* strict STScc has '__int64' */
N  #define __LONGLONG __int64
N#endif
N
N#define _STSABI __declspec(__nothrow)
N#define _STSABI_PURE __declspec(__nothrow) __attribute__((const))
N#define _STSABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define _STSABI_THROW
N
N  #ifndef __STDLIB_DECLS
N  #define __STDLIB_DECLS
N
N  /*
N   * Some of these declarations are new in C99.  To access them in C++
N   * you can use -D__USE_C99_STDLIB (or -D__USE_C99ALL).
N   */
N  #ifndef __USE_C99_STDLIB
N    #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X    #if 0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N      #define __USE_C99_STDLIB 1
N    #endif
N  #endif
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N   /* unconditional in non-strict C for consistency of debug info */
N   #if defined(__WCHAR32) || (defined(__STS_SIZEOF_WCHAR_T) && __STS_SIZEOF_WCHAR_T == 4)
X   #if 0L || (0L && __STS_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
N   #else
N    typedef unsigned short wchar_t; /* see <stddef.h> */
N   #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S   #if defined(__WCHAR32) || (defined(__STS_SIZEOF_WCHAR_T) && __STS_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
N  #endif
N#endif
N
Ntypedef struct div_t { int quot, rem; } div_t;
N   /* type of the value returned by the div function. */
Ntypedef struct ldiv_t { long int quot, rem; } ldiv_t;
N   /* type of the value returned by the ldiv function. */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Ntypedef struct lldiv_t { __LONGLONG quot, rem; } lldiv_t;
Xtypedef struct lldiv_t { __int64 quot, rem; } lldiv_t;
N   /* type of the value returned by the lldiv function. */
N#endif
N
N#ifdef __EXIT_FAILURE
S#  define EXIT_FAILURE __EXIT_FAILURE
S   /*
S    * an integral expression which may be used as an argument to the exit
S    * function to return unsuccessful termination status to the host
S    * environment.
S    */
N#else
N#  define EXIT_FAILURE 1  /* unixoid */
N#endif
N#define EXIT_SUCCESS 0
N   /*
N    * an integral expression which may be used as an argument to the exit
N    * function to return successful termination status to the host
N    * environment.
N    */
N
N   /*
N    * Defining __USE_ANSI_EXAMPLE_RAND at compile time switches to
N    * the example implementation of rand() and srand() provided in
N    * the ANSI C standard. This implementation is very poor, but is
N    * provided for completeness.
N    */
N#ifdef __USE_ANSI_EXAMPLE_RAND
S#define srand _ANSI_srand
S#define rand _ANSI_rand
S#define RAND_MAX 0x7fff
N#else
N#define RAND_MAX 0x7fffffff
N#endif
N   /*
N    * RAND_MAX: an integral constant expression, the value of which
N    * is the maximum value returned by the rand function.
N    */
Nextern _STSABI int __aeabi_MB_CUR_MAX(void);
Xextern __declspec(__nothrow) int __aeabi_MB_CUR_MAX(void);
N#define MB_CUR_MAX ( __aeabi_MB_CUR_MAX() )
N   /*
N    * a positive integer expression whose value is the maximum number of bytes
N    * in a multibyte character for the extended character set specified by the
N    * current locale (category LC_CTYPE), and whose value is never greater
N    * than MB_LEN_MAX.
N    */
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain a compliant version of the strtod
N    * family of functions.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Nextern _STSABI double atof(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double atof(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _STSABI int atoi(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atoi(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to int
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _STSABI long int atol(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int atol(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation.
N    * Returns: the converted value.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _STSABI __LONGLONG atoll(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) __int64 atoll(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to
N    * long long int representation.
N    * Returns: the converted value.
N    */
N#endif
N
Nextern _STSABI double strtod(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double strtod(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling a
N    * floating point constant; and a final string of one or more unrecognised
N    * characters, including the terminating null character of the input string.
N    * Then it attempts to convert the subject sequence to a floating point
N    * number, and returns the result. A pointer to the final string is stored
N    * in the object pointed to by endptr, provided that endptr is not a null
N    * pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned. If the correct value is outside the range of
N    *          representable values, plus or minus HUGE_VAL is returned
N    *          (according to the sign of the value), and the value of the macro
N    *          ERANGE is stored in errno. If the correct value would cause
N    *          underflow, zero is returned and the value of the macro ERANGE is
N    *          stored in errno.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _STSABI float strtof(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) float strtof(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
Nextern _STSABI long double strtold(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long double strtold(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * same as strtod, but return float and long double respectively.
N    */
N#endif
Nextern _STSABI long int strtol(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long int strtol(const char * __restrict  ,
N                        char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling an
N    * integer represented in some radix determined by the value of base, and a
N    * final string of one or more unrecognised characters, including the
N    * terminating null character of the input string. Then it attempts to
N    * convert the subject sequence to an integer, and returns the result.
N    * If the value of base is 0, the expected form of the subject sequence is
N    * that of an integer constant (described in ANSI Draft, section 3.1.3.2),
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. If the value of base is between 2 and 36, the expected form of
N    * the subject sequence is a sequence of letters and digits representing an
N    * integer with the radix specified by base, optionally preceded by a plus
N    * or minus sign, but not including an integer suffix. The letters from a
N    * (or A) through z (or Z) are ascribed the values 10 to 35; only letters
N    * whose ascribed values are less than that of the base are permitted. If
N    * the value of base is 16, the characters 0x or 0X may optionally precede
N    * the sequence of letters and digits following the sign if present.
N    * A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, LONG_MAX or LONG_MIN is returned
N    *          (according to the sign of the value), and the value of the
N    *          macro ERANGE is stored in errno.
N    */
Nextern _STSABI unsigned long int strtoul(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long int strtoul(const char * __restrict  ,
N                                       char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to unsigned
N    * long int representation. First it decomposes the input string into three
N    * parts: an initial, possibly empty, sequence of white-space characters (as
N    * determined by the isspace function), a subject sequence resembling an
N    * unsigned integer represented in some radix determined by the value of
N    * base, and a final string of one or more unrecognised characters,
N    * including the terminating null character of the input string. Then it
N    * attempts to convert the subject sequence to an unsigned integer, and
N    * returns the result. If the value of base is zero, the expected form of
N    * the subject sequence is that of an integer constant (described in ANSI
N    * Draft, section 3.1.3.2), optionally preceded by a '+' or '-' sign, but
N    * not including an integer suffix. If the value of base is between 2 and
N    * 36, the expected form of the subject sequence is a sequence of letters
N    * and digits representing an integer with the radix specified by base,
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. The letters from a (or A) through z (or Z) stand for the values
N    * 10 to 35; only letters whose ascribed values are less than that of the
N    * base are permitted. If the value of base is 16, the characters 0x or 0X
N    * may optionally precede the sequence of letters and digits following the
N    * sign, if present. A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, ULONG_MAX is returned, and the value of
N    *          the macro ERANGE is stored in errno.
N    */
N
N/* C90 reserves all names beginning with 'str' */
Nextern _STSABI __LONGLONG strtoll(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) __int64 strtoll(const char * __restrict  ,
N                                  char ** __restrict /*endptr*/, int /*base*/)
N                          __attribute__((__nonnull__(1)));
N   /*
N    * as strtol but returns a long long int value.  If the correct value is
N    * outside the range of representable values,  LLONG_MAX or LLONG_MIN is
N    * returned (according to the sign of the value), and the value of the
N    * macro ERANGE is stored in errno.
N    */
Nextern _STSABI unsigned __LONGLONG strtoull(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned __int64 strtoull(const char * __restrict  ,
N                                            char ** __restrict /*endptr*/, int /*base*/)
N                                   __attribute__((__nonnull__(1)));
N   /*
N    * as strtoul but returns an unsigned long long int value.  If the correct
N    * value is outside the range of representable values, ULLONG_MAX is returned,
N    * and the value of the macro ERANGE is stored in errno.
N    */
N
Nextern _STSABI int rand(void);
Xextern __declspec(__nothrow) int rand(void);
N   /*
N    * Computes a sequence of pseudo-random integers in the range 0 to RAND_MAX.
N    * Uses an additive generator (Mitchell & Moore) of the form:
N    *   Xn = (X[n-24] + X[n-55]) MOD 2^31
N    * This is described in section 3.2.2 of Knuth, vol 2. It's period is
N    * in excess of 2^55 and its randomness properties, though unproven, are
N    * conjectured to be good. Empirical testing since 1958 has shown no flaws.
N    * Returns: a pseudo-random integer.
N    */
Nextern _STSABI void srand(unsigned int /*seed*/);
Xextern __declspec(__nothrow) void srand(unsigned int  );
N   /*
N    * uses its argument as a seed for a new sequence of pseudo-random numbers
N    * to be returned by subsequent calls to rand. If srand is then called with
N    * the same seed value, the sequence of pseudo-random numbers is repeated.
N    * If rand is called before any calls to srand have been made, the same
N    * sequence is generated as when srand is first called with a seed value
N    * of 1.
N    */
N
Nstruct _rand_state { int __x[57]; };
Nextern _STSABI int _rand_r(struct _rand_state *);
Xextern __declspec(__nothrow) int _rand_r(struct _rand_state *);
Nextern _STSABI void _srand_r(struct _rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _srand_r(struct _rand_state *, unsigned int);
Nstruct _ANSI_rand_state { int __x[1]; };
Nextern _STSABI int _ANSI_rand_r(struct _ANSI_rand_state *);
Xextern __declspec(__nothrow) int _ANSI_rand_r(struct _ANSI_rand_state *);
Nextern _STSABI void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
N   /*
N    * Re-entrant variants of both flavours of rand, which operate on
N    * an explicitly supplied state buffer.
N    */
N
Nextern _STSABI void *calloc(size_t /*nmemb*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *calloc(size_t  , size_t  );
N   /*
N    * allocates space for an array of nmemb objects, each of whose size is
N    * 'size'. The space is initialised to all bits zero.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _STSABI void free(void * /*ptr*/);
Xextern __declspec(__nothrow) void free(void *  );
N   /*
N    * causes the space pointed to by ptr to be deallocated (i.e., made
N    * available for further allocation). If ptr is a null pointer, no action
N    * occurs. Otherwise, if ptr does not match a pointer earlier returned by
N    * calloc, malloc or realloc or if the space has been deallocated by a call
N    * to free or realloc, the behaviour is undefined.
N    */
Nextern _STSABI void *malloc(size_t /*size*/);
Xextern __declspec(__nothrow) void *malloc(size_t  );
N   /*
N    * allocates space for an object whose size is specified by 'size' and whose
N    * value is indeterminate.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _STSABI void *realloc(void * /*ptr*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *realloc(void *  , size_t  );
N   /*
N    * changes the size of the object pointed to by ptr to the size specified by
N    * size. The contents of the object shall be unchanged up to the lesser of
N    * the new and old sizes. If the new size is larger, the value of the newly
N    * allocated portion of the object is indeterminate. If ptr is a null
N    * pointer, the realloc function behaves like a call to malloc for the
N    * specified size. Otherwise, if ptr does not match a pointer earlier
N    * returned by calloc, malloc or realloc, or if the space has been
N    * deallocated by a call to free or realloc, the behaviour is undefined.
N    * If the space cannot be allocated, the object pointed to by ptr is
N    * unchanged. If size is zero and ptr is not a null pointer, the object it
N    * points to is freed.
N    * Returns: either a null pointer or a pointer to the possibly moved
N    *          allocated space.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
Nextern _STSABI int posix_memalign(void ** /*ret*/, size_t /*alignment*/, size_t /*size*/);
Xextern __declspec(__nothrow) int posix_memalign(void **  , size_t  , size_t  );
N   /*
N    * allocates space for an object of size 'size', aligned to a
N    * multiple of 'alignment' (which must be a power of two and at
N    * least 4).
N    *
N    * On success, a pointer to the allocated object is stored in
N    * *ret, and zero is returned. On failure, the return value is
N    * either ENOMEM (allocation failed because no suitable piece of
N    * memory was available) or EINVAL (the 'alignment' parameter was
N    * invalid).
N    */
N#endif
Ntypedef int (*__heapprt)(void *, char const *, ...);
Nextern _STSABI void __heapstats(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) void __heapstats(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                        void * /*param*/) __attribute__((__nonnull__(1)));
N   /*
N    * reports current heap statistics (eg. number of free blocks in
N    * the free-list). Output is as implementation-defined free-form
N    * text, provided via the dprint function. `param' gives an
N    * extra data word to pass to dprint. You can call
N    * __heapstats(fprintf,stdout) by casting fprintf to the above
N    * function type; the typedef `__heapprt' is provided for this
N    * purpose.
N    *
N    * `dprint' will not be called while the heap is being examined,
N    * so it can allocate memory itself without trouble.
N    */
Nextern _STSABI int __heapvalid(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) int __heapvalid(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                       void * /*param*/, int /*verbose*/) __attribute__((__nonnull__(1)));
N   /*
N    * performs a consistency check on the heap. Errors are reported
N    * through dprint, like __heapstats. If `verbose' is nonzero,
N    * full diagnostic information on the heap state is printed out.
N    *
N    * This routine probably won't work if the heap isn't a
N    * contiguous chunk (for example, if __user_heap_extend has been
N    * overridden).
N    *
N    * `dprint' may be called while the heap is being examined or
N    * even in an invalid state, so it must perform no memory
N    * allocation. In particular, if `dprint' calls (or is) a stdio
N    * function, the stream it outputs to must already have either
N    * been written to or been setvbuf'ed, or else the system will
N    * allocate buffer space for it on the first call to dprint.
N    */
Nextern _STSABI_NORETURN void abort(void);
Xextern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N   /*
N    * causes abnormal program termination to occur, unless the signal SIGABRT
N    * is being caught and the signal handler does not return. Whether open
N    * output streams are flushed or open streams are closed or temporary
N    * files removed is implementation-defined.
N    * An implementation-defined form of the status 'unsuccessful termination'
N    * is returned to the host environment by means of a call to
N    * raise(SIGABRT).
N    */
N
Nextern _STSABI int atexit(void (* /*func*/)(void)) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atexit(void (*  )(void)) __attribute__((__nonnull__(1)));
N   /*
N    * registers the function pointed to by func, to be called without its
N    * arguments at normal program termination. It is possible to register at
N    * least 32 functions.
N    * Returns: zero if the registration succeeds, nonzero if it fails.
N    */
N#if defined(__EDG__) && !defined(__GNUC__)
X#if 1L && !0L
N#define __LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE
N#endif
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE) 
X#if 0L && 1L 
S    /* atexit that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode  
S     */
S    typedef void (* __C_exitfuncptr)();
S    extern "C++"
S    inline int atexit(void (* __func)()) {
S      return atexit((__C_exitfuncptr)__func);
S    }
N#endif
N
N
Nextern _STSABI_NORETURN void exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void exit(int  );
N   /*
N    * causes normal program termination to occur. If more than one call to the
N    * exit function is executed by a program, the behaviour is undefined.
N    * First, all functions registered by the atexit function are called, in the
N    * reverse order of their registration.
N    * Next, all open output streams are flushed, all open streams are closed,
N    * and all files created by the tmpfile function are removed.
N    * Finally, control is returned to the host environment. If the value of
N    * status is zero or EXIT_SUCCESS, an implementation-defined form of the
N    * status 'successful termination' is returned. If the value of status is
N    * EXIT_FAILURE, an implementation-defined form of the status
N    * 'unsuccessful termination' is returned. Otherwise the status returned
N    * is implementation-defined.
N    */
N
Nextern _STSABI_NORETURN void _Exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void _Exit(int  );
N   /*
N    * causes normal program termination to occur. No functions registered
N    * by the atexit function are called.
N    * In this implementation, all open output streams are flushed, all
N    * open streams are closed, and all files created by the tmpfile function
N    * are removed.
N    * Control is returned to the host environment. The status returned to
N    * the host environment is determined in the same way as for 'exit'.
N    */     
N
Nextern _STSABI char *getenv(const char * /*name*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *getenv(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * searches the environment list, provided by the host environment, for a
N    * string that matches the string pointed to by name. The set of environment
N    * names and the method for altering the environment list are
N    * implementation-defined.
N    * Returns: a pointer to a string associated with the matched list member.
N    *          The array pointed to shall not be modified by the program, but
N    *          may be overwritten by a subsequent call to the getenv function.
N    *          If the specified name cannot be found, a null pointer is
N    *          returned.
N    */
N
Nextern _STSABI int  system(const char * /*string*/);
Xextern __declspec(__nothrow) int  system(const char *  );
N   /*
N    * passes the string pointed to by string to the host environment to be
N    * executed by a command processor in an implementation-defined manner.
N    * A null pointer may be used for string, to inquire whether a command
N    * processor exists.
N    *
N    * Returns: If the argument is a null pointer, the system function returns
N    *          non-zero only if a command processor is available. If the
N    *          argument is not a null pointer, the system function returns an
N    *          implementation-defined value.
N    */
N
Nextern _STSABI_THROW void *bsearch(const void * /*key*/, const void * /*base*/,
Xextern  void *bsearch(const void *  , const void *  ,
N              size_t /*nmemb*/, size_t /*size*/,
N              int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
N   /*
N    * searches an array of nmemb objects, the initial member of which is
N    * pointed to by base, for a member that matches the object pointed to by
N    * key. The size of each member of the array is specified by size.
N    * The contents of the array shall be in ascending sorted order according to
N    * a comparison function pointed to by compar, which is called with two
N    * arguments that point to the key object and to an array member, in that
N    * order. The function shall return an integer less than, equal to, or
N    * greater than zero if the key object is considered, respectively, to be
N    * less than, to match, or to be greater than the array member.
N    * Returns: a pointer to a matching member of the array, or a null pointer
N    *          if no match is found. If two members compare as equal, which
N    *          member is matched is unspecified.
N    */
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* bsearch that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */
S    typedef int (* __C_compareprocptr)(const void *, const void *);
S    extern "C++"
S    void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
S    extern "C++"
S    inline void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) {
S      return bsearch(__key, __base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
N
Nextern _STSABI_THROW void qsort(void * /*base*/, size_t /*nmemb*/, size_t /*size*/,
Xextern  void qsort(void *  , size_t  , size_t  ,
N           int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
N   /*
N    * sorts an array of nmemb objects, the initial member of which is pointed
N    * to by base. The size of each object is specified by size.
N    * The contents of the array shall be in ascending order according to a
N    * comparison function pointed to by compar, which is called with two
N    * arguments that point to the objects being compared. The function shall
N    * return an integer less than, equal to, or greater than zero if the first
N    * argument is considered to be respectively less than, equal to, or greater
N    * than the second. If two members compare as equal, their order in the
N    * sorted array is unspecified.
N    */
N
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* qsort that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */    
S    extern "C++"
S    void qsort(void * __base, size_t __nmemb, size_t __size,
S               int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
S    extern "C++"
S    inline void qsort(void * __base, size_t __nmemb, size_t __size,
S                      int (* __compar)(const void *, const void *)) {
S      qsort(__base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
Nextern _STSABI_PURE int abs(int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) int abs(int  );
N   /*
N    * computes the absolute value of an integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N
Nextern _STSABI_PURE div_t div(int /*numer*/, int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) div_t div(int  , int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the resulting
N    * quotient is the integer of lesser magnitude that is the nearest to the
N    * algebraic quotient. If the result cannot be represented, the behaviour is
N    * undefined; otherwise, quot * denom + rem shall equal numer.
N    * Returns: a structure of type div_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          int quot; int rem;
N    */
Nextern _STSABI_PURE long int labs(long int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long int labs(long int  );
N   /*
N    * computes the absolute value of an long integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _STSABI_PURE long abs(long int x) { return labs(x); }
N#endif
N
Nextern _STSABI_PURE ldiv_t ldiv(long int /*numer*/, long int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) ldiv_t ldiv(long int  , long int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type ldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long int quot; long int rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _STSABI_PURE ldiv_t div(long int __numer, long int __denom) {
S       return ldiv(__numer, __denom);
S   }
N#endif
N
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _STSABI_PURE __LONGLONG llabs(__LONGLONG /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) __int64 llabs(__int64  );
N   /*
N    * computes the absolute value of a long long integer j. If the
N    * result cannot be represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _STSABI_PURE __LONGLONG abs(__LONGLONG x) { return llabs(x); }
N#endif
N
Nextern _STSABI_PURE lldiv_t lldiv(__LONGLONG /*numer*/, __LONGLONG /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) lldiv_t lldiv(__int64  , __int64  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type lldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long long quot; long long rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _STSABI_PURE lldiv_t div(__LONGLONG __numer, __LONGLONG __denom) {
S       return lldiv(__numer, __denom);
S   }
N#endif
N#endif
N
N#if !(__STS_NO_DEPRECATED_FUNCTIONS)
N/*
N * STS real-time divide functions for guaranteed performance
N */
Ntypedef struct __sdiv32by16 { int quot, rem; } __sdiv32by16;
Ntypedef struct __udiv32by16 { unsigned int quot, rem; } __udiv32by16;
N   /* used int so that values return in separate regs, although 16-bit */
Ntypedef struct __sdiv64by32 { int rem, quot; } __sdiv64by32;
N
N__value_in_regs extern _STSABI_PURE __sdiv32by16 __rt_sdiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv32by16 __rt_sdiv32by16(
N     int /*numer*/,
N     short int /*denom*/);
N   /*
N    * Signed divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _STSABI_PURE __udiv32by16 __rt_udiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __udiv32by16 __rt_udiv32by16(
N     unsigned int /*numer*/,
N     unsigned short /*denom*/);
N   /*
N    * Unsigned divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _STSABI_PURE __sdiv64by32 __rt_sdiv64by32(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv64by32 __rt_sdiv64by32(
N     int /*numer_h*/, unsigned int /*numer_l*/,
N     int /*denom*/);
N   /*
N    * Signed divide: (32-bit quot), (32-bit rem) = (64-bit) / (32-bit)
N    */
N#endif
N
N/*
N * STS floating-point mask/status function (for both hardfp and softfp)
N */
Nextern _STSABI unsigned int __fp_status(unsigned int /*mask*/, unsigned int /*flags*/);
Xextern __declspec(__nothrow) unsigned int __fp_status(unsigned int  , unsigned int  );
N   /*
N    * mask and flags are bit-fields which correspond directly to the
N    * floating point status register in the FPE/FPA and fplib.  
N    * __fp_status returns the current value of the status register,
N    * and also sets the writable bits of the word
N    * (the exception control and flag bytes) to:
N    *
N    *     new = (old & ~mask) ^ flags;
N    */
N#define __fpsr_IXE  0x100000
N#define __fpsr_UFE  0x80000
N#define __fpsr_OFE  0x40000
N#define __fpsr_DZE  0x20000
N#define __fpsr_IOE  0x10000
N
N#define __fpsr_IXC  0x10
N#define __fpsr_UFC  0x8
N#define __fpsr_OFC  0x4
N#define __fpsr_DZC  0x2
N#define __fpsr_IOC  0x1
N
N/*
N * Multibyte Character Functions.
N * The behaviour of the multibyte character functions is affected by the
N * LC_CTYPE category of the current locale. For a state-dependent encoding,
N * each function is placed into its initial state by a call for which its
N * character pointer argument, s, is a null pointer. Subsequent calls with s
N * as other than a null pointer cause the internal state of the function to be
N * altered as necessary. A call with s as a null pointer causes these functions
N * to return a nonzero value if encodings have state dependency, and a zero
N * otherwise. After the LC_CTYPE category is changed, the shift state of these
N * functions is indeterminate.
N */
Nextern _STSABI int mblen(const char * /*s*/, size_t /*n*/);
Xextern __declspec(__nothrow) int mblen(const char *  , size_t  );
N   /*
N    * If s is not a null pointer, the mblen function determines the number of
N    * bytes compromising the multibyte character pointed to by s. Except that
N    * the shift state of the mbtowc function is not affected, it is equivalent
N    * to   mbtowc((wchar_t *)0, s, n);
N    * Returns: If s is a null pointer, the mblen function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mblen function either returns a 0 (if s points to a
N    *          null character), or returns the number of bytes that compromise
N    *          the multibyte character (if the next n of fewer bytes form a
N    *          valid multibyte character), or returns -1 (they do not form a
N    *          valid multibyte character).
N    */
Nextern _STSABI int mbtowc(wchar_t * __restrict /*pwc*/,
Xextern __declspec(__nothrow) int mbtowc(wchar_t * __restrict  ,
N                   const char * __restrict /*s*/, size_t /*n*/);
N   /*
N    * If s is not a null pointer, the mbtowc function determines the number of
N    * bytes that compromise the multibyte character pointed to by s. It then
N    * determines the code for value of type wchar_t that corresponds to that
N    * multibyte character. (The value of the code corresponding to the null
N    * character is zero). If the multibyte character is valid and pwc is not a
N    * null pointer, the mbtowc function stores the code in the object pointed
N    * to by pwc. At most n bytes of the array pointed to by s will be examined.
N    * Returns: If s is a null pointer, the mbtowc function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mbtowc function either returns a 0 (if s points to
N    *          a null character), or returns the number of bytes that
N    *          compromise the converted multibyte character (if the next n of
N    *          fewer bytes form a valid multibyte character), or returns -1
N    *          (they do not form a valid multibyte character).
N    */
Nextern _STSABI int wctomb(char * /*s*/, wchar_t /*wchar*/);
Xextern __declspec(__nothrow) int wctomb(char *  , wchar_t  );
N   /*
N    * determines the number of bytes need to represent the multibyte character
N    * corresponding to the code whose value is wchar (including any change in
N    * shift state). It stores the multibyte character representation in the
N    * array object pointed to by s (if s is not a null pointer). At most
N    * MB_CUR_MAX characters are stored. If the value of wchar is zero, the
N    * wctomb function is left in the initial shift state).
N    * Returns: If s is a null pointer, the wctomb function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the wctomb function returns a -1 if the value of wchar
N    *          does not correspond to a valid multibyte character, or returns
N    *          the number of bytes that compromise the multibyte character
N    *          corresponding to the value of wchar.
N    */
N
N/*
N * Multibyte String Functions.
N * The behaviour of the multibyte string functions is affected by the LC_CTYPE
N * category of the current locale.
N */
Nextern _STSABI size_t mbstowcs(wchar_t * __restrict /*pwcs*/,
Xextern __declspec(__nothrow) size_t mbstowcs(wchar_t * __restrict  ,
N                      const char * __restrict /*s*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of multibyte character that begins in the initial
N    * shift state from the array pointed to by s into a sequence of
N    * corresponding codes and stores not more than n codes into the array
N    * pointed to by pwcs. No multibyte character that follow a null character
N    * (which is converted into a code with value zero) will be examined or
N    * converted. Each multibyte character is converted as if by a call to
N    * mbtowc function, except that the shift state of the mbtowc function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by pwcs. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If an invalid multibyte character is encountered, the mbstowcs
N    *          function returns (size_t)-1. Otherwise, the mbstowcs function
N    *          returns the number of array elements modified, not including
N    *          a terminating zero code, if any.
N    */
Nextern _STSABI size_t wcstombs(char * __restrict /*s*/,
Xextern __declspec(__nothrow) size_t wcstombs(char * __restrict  ,
N                      const wchar_t * __restrict /*pwcs*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of codes that correspond to multibyte characters
N    * from the array pointed to by pwcs into a sequence of multibyte
N    * characters that begins in the initial shift state and stores these
N    * multibyte characters into the array pointed to by s, stopping if a
N    * multibyte character would exceed the limit of n total bytes or if a
N    * null character is stored. Each code is converted as if by a call to the
N    * wctomb function, except that the shift state of the wctomb function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by s. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If a code is encountered that does not correspond to a valid
N    *          multibyte character, the wcstombs function returns (size_t)-1.
N    *          Otherwise, the wcstombs function returns the number of bytes
N    *          modified, not including a terminating null character, if any.
N    */
N
Nextern _STSABI void __use_realtime_heap(void);
Xextern __declspec(__nothrow) void __use_realtime_heap(void);
Nextern _STSABI void __use_realtime_division(void);
Xextern __declspec(__nothrow) void __use_realtime_division(void);
Nextern _STSABI void __use_two_region_memory(void);
Xextern __declspec(__nothrow) void __use_two_region_memory(void);
Nextern _STSABI void __use_no_heap(void);
Xextern __declspec(__nothrow) void __use_no_heap(void);
Nextern _STSABI void __use_no_heap_region(void);
Xextern __declspec(__nothrow) void __use_no_heap_region(void);
N
Nextern _STSABI char const *__C_library_version_string(void);
Xextern __declspec(__nothrow) char const *__C_library_version_string(void);
Nextern _STSABI int __C_library_version_number(void);
Xextern __declspec(__nothrow) int __C_library_version_number(void);
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDLIB_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
S    #ifndef __STDLIB_NO_EXPORTS
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::atoll;
S        using ::std::lldiv_t;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::div_t;
S      using ::std::ldiv_t;
S      using ::std::atof;
S      using ::std::atoi;
S      using ::std::atol;
S      using ::std::strtod;
S#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S      using ::std::strtof;
S      using ::std::strtold;
S#endif
S      using ::std::strtol;
S      using ::std::strtoul;
S      using ::std::strtoll;
S      using ::std::strtoull;
S      using ::std::rand;
S      using ::std::srand;
S      using ::std::_rand_state;
S      using ::std::_rand_r;
S      using ::std::_srand_r;
S      using ::std::_ANSI_rand_state;
S      using ::std::_ANSI_rand_r;
S      using ::std::_ANSI_srand_r;
S      using ::std::calloc;
S      using ::std::free;
S      using ::std::malloc;
S      using ::std::realloc;
S#if !defined(__STRICT_ANSI__)
S      using ::std::posix_memalign;
S#endif
S      using ::std::__heapprt;
S      using ::std::__heapstats;
S      using ::std::__heapvalid;
S      using ::std::abort;
S      using ::std::atexit;
S      using ::std::exit;
S      using ::std::_Exit;
S      using ::std::getenv;
S      using ::std::system;
S      using ::std::bsearch;
S      using ::std::qsort;
S      using ::std::abs;
S      using ::std::div;
S      using ::std::labs;
S      using ::std::ldiv;
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::llabs;
S        using ::std::lldiv;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S#if !(__STS_NO_DEPRECATED_FUNCTIONS)
S      using ::std::__sdiv32by16;
S      using ::std::__udiv32by16;
S      using ::std::__sdiv64by32;
S      using ::std::__rt_sdiv32by16;
S      using ::std::__rt_udiv32by16;
S      using ::std::__rt_sdiv64by32;
S#endif
S      using ::std::__fp_status;
S      using ::std::mblen;
S      using ::std::mbtowc;
S      using ::std::wctomb;
S      using ::std::mbstowcs;
S      using ::std::wcstombs;
S      using ::std::__use_realtime_heap;
S      using ::std::__use_realtime_division;
S      using ::std::__use_two_region_memory;
S      using ::std::__use_no_heap;
S      using ::std::__use_no_heap_region;
S      using ::std::__C_library_version_string;
S      using ::std::__C_library_version_number;
S      using ::std::size_t;
S      using ::std::__aeabi_MB_CUR_MAX;
S    #endif /* __STDLIB_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#undef __LONGLONG
N
N#endif /* __stdlib_h */
N
N/* end of stdlib.h */
L 44 ".\Libraries\inc\gd32f10x_enet.h" 2
N
N#define IF_USE_EXTERNPHY_LIB             0
N#if (1 == IF_USE_EXTERNPHY_LIB)
X#if (1 == 0)
S#include "phy.h"
N#endif
N
N#ifndef ENET_RXBUF_NUM
N#define ENET_RXBUF_NUM                   5U                                     /*!< ethernet Rx DMA descriptor number */
N#endif
N
N#ifndef ENET_TXBUF_NUM
N#define ENET_TXBUF_NUM                   5U                                     /*!< ethernet Tx DMA descriptor number */
N#endif
N
N#ifndef ENET_RXBUF_SIZE
N#define ENET_RXBUF_SIZE                  ENET_MAX_FRAME_SIZE                    /*!< ethernet receive buffer size */
N#endif
N
N#ifndef ENET_TXBUF_SIZE
N#define ENET_TXBUF_SIZE                  ENET_MAX_FRAME_SIZE                    /*!< ethernet transmit buffer size */
N#endif
N
N/* #define USE_DELAY */
N
N#ifndef _PHY_H_
N#define DP83848                          0
N#define LAN8700                          1
N#define PHY_TYPE                         DP83848
N
N#define PHY_ADDRESS                      ((uint16_t)1U)                         /*!< phy address determined by the hardware */
N
N/* PHY read write timeouts */ 
N#define PHY_READ_TO                      ((uint32_t)0x0004FFFFU)                /*!< PHY read timeout */
N#define PHY_WRITE_TO                     ((uint32_t)0x0004FFFFU)                /*!< PHY write timeout */
N
N/* PHY delay */
N#define PHY_RESETDELAY                   ((uint32_t)0x008FFFFFU)                /*!< PHY reset delay */
N#define PHY_CONFIGDELAY                  ((uint32_t)0x00FFFFFFU)                /*!< PHY configure delay */
N
N/* PHY register address */ 
N#define PHY_REG_BCR                      0U                                     /*!< tranceiver basic control register */
N#define PHY_REG_BSR                      1U                                     /*!< tranceiver basic status register */
N
N/* PHY basic control register */
N#define PHY_RESET                        ((uint16_t)0x8000)                     /*!< PHY reset */
N#define PHY_LOOPBACK                     ((uint16_t)0x4000)                     /*!< enable phy loop-back mode */
N#define PHY_FULLDUPLEX_100M              ((uint16_t)0x2100)                     /*!< configure speed to 100 Mbit/s and the full-duplex mode */
N#define PHY_HALFDUPLEX_100M              ((uint16_t)0x2000)                     /*!< configure speed to 100 Mbit/s and the half-duplex mode */
N#define PHY_FULLDUPLEX_10M               ((uint16_t)0x0100)                     /*!< configure speed to 10 Mbit/s and the full-duplex mode */
N#define PHY_HALFDUPLEX_10M               ((uint16_t)0x0000)                     /*!< configure speed to 10 Mbit/s and the half-duplex mode */
N#define PHY_AUTONEGOTIATION              ((uint16_t)0x1000)                     /*!< enable auto-negotiation function */
N#define PHY_RESTART_AUTONEGOTIATION      ((uint16_t)0x0200)                     /*!< restart auto-negotiation function */
N#define PHY_POWERDOWN                    ((uint16_t)0x0800)                     /*!< enable the power down mode */
N#define PHY_ISOLATE                      ((uint16_t)0x0400)                     /*!< isolate PHY from MII */
N
N/* PHY basic status register */
N#define PHY_AUTONEGO_COMPLETE            ((uint16_t)0x0020)                     /*!< auto-negotioation process completed */
N#define PHY_LINKED_STATUS                ((uint16_t)0x0004)                     /*!< valid link established */
N#define PHY_JABBER_DETECTION             ((uint16_t)0x0002)                     /*!< jabber condition detected */
N
N#if(PHY_TYPE == LAN8700) 
X#if(0 == 1) 
S#define PHY_SR                           31U                                    /*!< tranceiver status register */
S#define PHY_SPEED_STATUS                 ((uint16_t)0x0004)                     /*!< configured information of speed: 10Mbit/s */
S#define PHY_DUPLEX_STATUS                ((uint16_t)0x0010)                     /*!< configured information of duplex: full-duplex */
N#elif(PHY_TYPE == DP83848)
X#elif(0 == 0)
N#define PHY_SR                           16U                                    /*!< tranceiver status register */
N#define PHY_SPEED_STATUS                 ((uint16_t)0x0002)                     /*!< configured information of speed: 10Mbit/s */
N#define PHY_DUPLEX_STATUS                ((uint16_t)0x0004)                     /*!< configured information of duplex: full-duplex */
N#endif /* PHY_TYPE */
N
N#endif /* _PHY_H_ */
N
N
N/* ENET definitions */
N#define ENET                             ENET_BASE
N
N/* registers definitions */
N#define ENET_MAC_CFG                     REG32((ENET) + 0x00U)                  /*!< ethernet MAC configuration register */
N#define ENET_MAC_FRMF                    REG32((ENET) + 0x04U)                  /*!< ethernet MAC frame filter register */
N#define ENET_MAC_HLH                     REG32((ENET) + 0x08U)                  /*!< ethernet MAC hash list high register */
N#define ENET_MAC_HLL                     REG32((ENET) + 0x0CU)                  /*!< ethernet MAC hash list low register */
N#define ENET_MAC_PHY_CTL                 REG32((ENET) + 0x10U)                  /*!< ethernet MAC PHY control register */
N#define ENET_MAC_PHY_DATA                REG32((ENET) + 0x14U)                  /*!< ethernet MAC MII data register */
N#define ENET_MAC_FCTL                    REG32((ENET) + 0x18U)                  /*!< ethernet MAC flow control register */
N#define ENET_MAC_FCTH                    REG32((ENET) + 0x1080U)                /*!< ethernet MAC flow control threshold register */
N#define ENET_MAC_VLT                     REG32((ENET) + 0x1CU)                  /*!< ethernet MAC VLAN tag register */
N#define ENET_MAC_RWFF                    REG32((ENET) + 0x28U)                  /*!< ethernet MAC remote wakeup frame filter register */
N#define ENET_MAC_WUM                     REG32((ENET) + 0x2CU)                  /*!< ethernet MAC wakeup management register */
N#define ENET_MAC_INTF                    REG32((ENET) + 0x38U)                  /*!< ethernet MAC interrupt flag register */
N#define ENET_MAC_INTMSK                  REG32((ENET) + 0x3CU)                  /*!< ethernet MAC interrupt mask register */
N#define ENET_MAC_ADDR0H                  REG32((ENET) + 0x40U)                  /*!< ethernet MAC address 0 high register */
N#define ENET_MAC_ADDR0L                  REG32((ENET) + 0x44U)                  /*!< ethernet MAC address 0 low register */
N#define ENET_MAC_ADDR1H                  REG32((ENET) + 0x48U)                  /*!< ethernet MAC address 1 high register */
N#define ENET_MAC_ADDR1L                  REG32((ENET) + 0x4CU)                  /*!< ethernet MAC address 1 low register */
N#define ENET_MAC_ADDT2H                  REG32((ENET) + 0x50U)                  /*!< ethernet MAC address 2 high register */
N#define ENET_MAC_ADDR2L                  REG32((ENET) + 0x54U)                  /*!< ethernet MAC address 2 low register */
N#define ENET_MAC_ADDR3H                  REG32((ENET) + 0x58U)                  /*!< ethernet MAC address 3 high register */
N#define ENET_MAC_ADDR3L                  REG32((ENET) + 0x5CU)                  /*!< ethernet MAC address 3 low register */
N
N#define ENET_MSC_CTL                     REG32((ENET) + 0x100U)                 /*!< ethernet MSC control register */
N#define ENET_MSC_RINTF                   REG32((ENET) + 0x104U)                 /*!< ethernet MSC receive interrupt flag register */
N#define ENET_MSC_TINTF                   REG32((ENET) + 0x108U)                 /*!< ethernet MSC transmit interrupt flag register */
N#define ENET_MSC_RINTMSK                 REG32((ENET) + 0x10CU)                 /*!< ethernet MSC receive interrupt mask register */
N#define ENET_MSC_TINTMSK                 REG32((ENET) + 0x110U)                 /*!< ethernet MSC transmit interrupt mask register */
N#define ENET_MSC_SCCNT                   REG32((ENET) + 0x14CU)                 /*!< ethernet MSC transmitted good frames after a single collision counter register */
N#define ENET_MSC_MSCCNT                  REG32((ENET) + 0x150U)                 /*!< ethernet MSC transmitted good frames after more than a single collision counter register */
N#define ENET_MSC_TGFCNT                  REG32((ENET) + 0x168U)                 /*!< ethernet MSC transmitted good frames counter register */
N#define ENET_MSC_RFCECNT                 REG32((ENET) + 0x194U)                 /*!< ethernet MSC received frames with CRC error counter register */
N#define ENET_MSC_RFAECNT                 REG32((ENET) + 0x198U)                 /*!< ethernet MSC received frames with alignment error counter register */
N#define ENET_MSC_RGUFCNT                 REG32((ENET) + 0x1C4U)                 /*!< ethernet MSC received good unicast frames counter register */
N
N#define ENET_PTP_TSCTL                   REG32((ENET) + 0x700U)                 /*!< ethernet PTP time stamp control register */
N#define ENET_PTP_SSINC                   REG32((ENET) + 0x704U)                 /*!< ethernet PTP subsecond increment register */ 
N#define ENET_PTP_TSH                     REG32((ENET) + 0x708U)                 /*!< ethernet PTP time stamp high register */
N#define ENET_PTP_TSL                     REG32((ENET) + 0x70CU)                 /*!< ethernet PTP time stamp low register */
N#define ENET_PTP_TSUH                    REG32((ENET) + 0x710U)                 /*!< ethernet PTP time stamp update high register */
N#define ENET_PTP_TSUL                    REG32((ENET) + 0x714U)                 /*!< ethernet PTP time stamp update low register */
N#define ENET_PTP_TSADDEND                REG32((ENET) + 0x718U)                 /*!< ethernet PTP time stamp addend register */
N#define ENET_PTP_ETH                     REG32((ENET) + 0x71CU)                 /*!< ethernet PTP expected time high register */
N#define ENET_PTP_ETL                     REG32((ENET) + 0x720U)                 /*!< ethernet PTP expected time low register */
N
N#define ENET_DMA_BCTL                    REG32((ENET) + 0x1000U)                /*!< ethernet DMA bus control register */
N#define ENET_DMA_TPEN                    REG32((ENET) + 0x1004U)                /*!< ethernet DMA transmit poll enable register */ 
N#define ENET_DMA_RPEN                    REG32((ENET) + 0x1008U)                /*!< ethernet DMA receive poll enable register */
N#define ENET_DMA_RDTADDR                 REG32((ENET) + 0x100CU)                /*!< ethernet DMA receive descriptor table address register */
N#define ENET_DMA_TDTADDR                 REG32((ENET) + 0x1010U)                /*!< ethernet DMA transmit descriptor table address register */
N#define ENET_DMA_STAT                    REG32((ENET) + 0x1014U)                /*!< ethernet DMA status register */
N#define ENET_DMA_CTL                     REG32((ENET) + 0x1018U)                /*!< ethernet DMA control register */
N#define ENET_DMA_INTEN                   REG32((ENET) + 0x101CU)                /*!< ethernet DMA interrupt enable register */
N#define ENET_DMA_MFBOCNT                 REG32((ENET) + 0x1020U)                /*!< ethernet DMA missed frame and buffer overflow counter register */
N#define ENET_DMA_CTDADDR                 REG32((ENET) + 0x1048U)                /*!< ethernet DMA current transmit descriptor address register */ 
N#define ENET_DMA_CRDADDR                 REG32((ENET) + 0x104CU)                /*!< ethernet DMA current receive descriptor address register */
N#define ENET_DMA_CTBADDR                 REG32((ENET) + 0x1050U)                /*!< ethernet DMA current transmit buffer address register */
N#define ENET_DMA_CRBADDR                 REG32((ENET) + 0x1054U)                /*!< ethernet DMA current receive buffer address register */
N
N/* bits definitions */
N/* ENET_MAC_CFG */
N#define ENET_MAC_CFG_REN                 BIT(2)                                 /*!< receiver enable */
N#define ENET_MAC_CFG_TEN                 BIT(3)                                 /*!< transmitter enable */
N#define ENET_MAC_CFG_DFC                 BIT(4)                                 /*!< defferal check */
N#define ENET_MAC_CFG_BOL                 BITS(5,6)                              /*!< back-off limit */
N#define ENET_MAC_CFG_APCD                BIT(7)                                 /*!< automatic pad/CRC drop */
N#define ENET_MAC_CFG_RTD                 BIT(9)                                 /*!< retry disable */
N#define ENET_MAC_CFG_IPFCO               BIT(10)                                /*!< IP frame checksum offload */
N#define ENET_MAC_CFG_DPM                 BIT(11)                                /*!< duplex mode */
N#define ENET_MAC_CFG_LBM                 BIT(12)                                /*!< loopback mode */
N#define ENET_MAC_CFG_ROD                 BIT(13)                                /*!< receive own disable */
N#define ENET_MAC_CFG_SPD                 BIT(14)                                /*!< fast eneternet speed */
N#define ENET_MAC_CFG_CSD                 BIT(16)                                /*!< carrier sense disable */
N#define ENET_MAC_CFG_IGBS                BITS(17,19)                            /*!< inter-frame gap bit selection */            
N#define ENET_MAC_CFG_JBD                 BIT(22)                                /*!< jabber disable */
N#define ENET_MAC_CFG_WDD                 BIT(23)                                /*!< watchdog disable */
N
N/* ENET_MAC_FRMF */
N#define ENET_MAC_FRMF_PM                 BIT(0)                                 /*!< promiscuous mode */
N#define ENET_MAC_FRMF_HUF                BIT(1)                                 /*!< hash unicast filter */
N#define ENET_MAC_FRMF_HMF                BIT(2)                                 /*!< hash multicast filter */ 
N#define ENET_MAC_FRMF_DAIFLT             BIT(3)                                 /*!< destination address inverse filtering enable */ 
N#define ENET_MAC_FRMF_MFD                BIT(4)                                 /*!< multicast filter disable */ 
N#define ENET_MAC_FRMF_BFRMD              BIT(5)                                 /*!< broadcast frame disable */ 
N#define ENET_MAC_FRMF_PCFRM              BITS(6,7)                              /*!< pass control frames */ 
N#define ENET_MAC_FRMF_SAIFLT             BIT(8)                                 /*!< source address inverse filtering */ 
N#define ENET_MAC_FRMF_SAFLT              BIT(9)                                 /*!< source address filter */ 
N#define ENET_MAC_FRMF_HPFLT              BIT(10)                                /*!< hash or perfect filter */ 
N#define ENET_MAC_FRMF_FAR                BIT(31)                                /*!< frames all receive */ 
N  
N/* ENET_MAC_HLH */
N#define ENET_MAC_HLH_HLH                 BITS(0,31)                             /*!< hash list high */
N  
N/* ENET_MAC_HLL */
N#define ENET_MAC_HLL_HLL                 BITS(0,31)                             /*!< hash list low */
N  
N/* ENET_MAC_PHY_CTL */
N#define ENET_MAC_PHY_CTL_PB              BIT(0)                                 /*!< PHY busy */ 
N#define ENET_MAC_PHY_CTL_PW              BIT(1)                                 /*!< PHY write */ 
N#define ENET_MAC_PHY_CTL_CLR             BITS(2,4)                              /*!< clock range */ 
N#define ENET_MAC_PHY_CTL_PR              BITS(6,10)                             /*!< PHY register */ 
N#define ENET_MAC_PHY_CTL_PA              BITS(11,15)                            /*!< PHY address */ 
N    
N/* ENET_MAC_PHY_DATA */
N#define ENET_MAC_PHY_DATA_PD             BITS(0,15)                             /*!< PHY data */
N  
N/* ENET_MAC_FCTL */
N#define ENET_MAC_FCTL_FLCBBKPA           BIT(0)                                 /*!< flow control busy(in full duplex mode)/backpressure activate(in half duplex mode) */
N#define ENET_MAC_FCTL_TFCEN              BIT(1)                                 /*!< transmit flow control enable */
N#define ENET_MAC_FCTL_RFCEN              BIT(2)                                 /*!< receive flow control enable */
N#define ENET_MAC_FCTL_UPFDT              BIT(3)                                 /*!< unicast pause frame detect */
N#define ENET_MAC_FCTL_PLTS               BITS(4,5)                              /*!< pause low threshold */     
N#define ENET_MAC_FCTL_DZQP               BIT(7)                                 /*!< disable zero-quanta pause */
N#define ENET_MAC_FCTL_PTM                BITS(16,31)                            /*!< pause time */
N  
N/* ENET_MAC_FCTH */
N#define ENET_MAC_FCTH_RFA                BITS(0,2)                              /*!< threshold of active flow control */
N#define ENET_MAC_FCTH_RFD                BITS(4,6)                              /*!< threshold of deactive flow control */
N  
N/* ENET_MAC_VLT */
N#define ENET_MAC_VLT_VLTI                BITS(0,15)                             /*!< VLAN tag identifier(for receive frames) */
N#define ENET_MAC_VLT_VLTC                BIT(16)                                /*!< 12-bit VLAN tag comparison */
N  
N/* ENET_MAC_RWFF */
N#define ENET_MAC_RWFF_DATA               BITS(0,31)                             /*!< wakeup frame filter register data */
N  
N/* ENET_MAC_WUM */ 
N#define ENET_MAC_WUM_PWD                 BIT(0)                                 /*!< power down */
N#define ENET_MAC_WUM_MPEN                BIT(1)                                 /*!< magic packet enable */
N#define ENET_MAC_WUM_WFEN                BIT(2)                                 /*!< wakeup frame enable */
N#define ENET_MAC_WUM_MPKR                BIT(5)                                 /*!< magic packet received */
N#define ENET_MAC_WUM_WUFR                BIT(6)                                 /*!< wakeup frame received */
N#define ENET_MAC_WUM_GU                  BIT(9)                                 /*!< global unicast */
N#define ENET_MAC_WUM_WUFFRPR             BIT(31)                                /*!< wakeup frame filter register pointer reset */
N
N/* ENET_MAC_INTF */ 
N#define ENET_MAC_INTF_WUM                BIT(3)                                 /*!< WUM status */
N#define ENET_MAC_INTF_MSC                BIT(4)                                 /*!< MSC status */
N#define ENET_MAC_INTF_MSCR               BIT(5)                                 /*!< MSC receive status */
N#define ENET_MAC_INTF_MSCT               BIT(6)                                 /*!< MSC transmit status */
N#define ENET_MAC_INTF_TMST               BIT(9)                                 /*!< timestamp trigger status */
N
N/* ENET_MAC_INTMSK */
N#define ENET_MAC_INTMSK_WUMIM            BIT(3)                                 /*!< WUM interrupt mask */
N#define ENET_MAC_INTMSK_TMSTIM           BIT(9)                                 /*!< timestamp trigger interrupt mask */
N
N/* ENET_MAC_ADDR0H */
N#define ENET_MAC_ADDR0H_ADDR0H           BITS(0,15)                             /*!< MAC address0 high */
N#define ENET_MAC_ADDR0H_MO               BIT(31)                                /*!< always read 1 and must be kept */
N  
N/* ENET_MAC_ADDR0L */
N#define ENET_MAC_ADDR0L_ADDR0L           BITS(0,31)                             /*!< MAC address0 low */
N  
N/* ENET_MAC_ADDR1H */
N#define ENET_MAC_ADDR1H_ADDR1H           BITS(0,15)                             /*!< MAC address1 high */
N#define ENET_MAC_ADDR1H_MB               BITS(24,29)                            /*!< mask byte */ 
N#define ENET_MAC_ADDR1H_SAF              BIT(30)                                /*!< source address filter */
N#define ENET_MAC_ADDR1H_AFE              BIT(31)                                /*!< address filter enable */
N  
N/* ENET_MAC_ADDR1L */
N#define ENET_MAC_ADDR1L_ADDR1L           BITS(0,31)                             /*!< MAC address1 low */
N  
N/* ENET_MAC_ADDR2H */
N#define ENET_MAC_ADDR2H_ADDR2H           BITS(0,15)                             /*!< MAC address2 high */
N#define ENET_MAC_ADDR2H_MB               BITS(24,29)                            /*!< mask byte */
N#define ENET_MAC_ADDR2H_SAF              BIT(30)                                /*!< source address filter */
N#define ENET_MAC_ADDR2H_AFE              BIT(31)                                /*!< address filter enable */
N  
N/* ENET_MAC_ADDR2L */
N#define ENET_MAC_ADDR2L_ADDR2L           BITS(0,31)                             /*!< MAC address2 low */
N  
N/* ENET_MAC_ADDR3H */
N#define ENET_MAC_ADDR3H_ADDR3H           BITS(0,15)                             /*!< MAC address3 high */
N#define ENET_MAC_ADDR3H_MB               BITS(24,29)                            /*!< mask byte */
N#define ENET_MAC_ADDR3H_SAF              BIT(30)                                /*!< source address filter */
N#define ENET_MAC_ADDR3H_AFE              BIT(31)                                /*!< address filter enable */
N
N/* ENET_MAC_ADDR3L */
N#define ENET_MAC_ADDR3L_ADDR3L           BITS(0,31)                             /*!< MAC address3 low */
N 
N/* ENET_MSC_CTL */
N#define ENET_MSC_CTL_CTR                 BIT(0)                                 /*!< counter reset */
N#define ENET_MSC_CTL_CTSR                BIT(1)                                 /*!< counter stop rollover */
N#define ENET_MSC_CTL_RTOR                BIT(2)                                 /*!< reset on read */
N#define ENET_MSC_CTL_MCFZ                BIT(3)                                 /*!< MSC counter freeze */
N
N/* ENET_MSC_RINTF */
N#define ENET_MSC_RINTF_RFCE              BIT(5)                                 /*!< received frames CRC error */
N#define ENET_MSC_RINTF_RFAE              BIT(6)                                 /*!< received frames alignment error */
N#define ENET_MSC_RINTF_RGUF              BIT(17)                                /*!< receive good unicast frames */
N  
N/* ENET_MSC_TINTF */
N#define ENET_MSC_TINTF_TGFSC             BIT(14)                                /*!< transmitted good frames single collision */
N#define ENET_MSC_TINTF_TGFMSC            BIT(15)                                /*!< transmitted good frames more single collision */
N#define ENET_MSC_TINTF_TGF               BIT(21)                                /*!< transmitted good frames */
N
N/* ENET_MSC_RINTMSK */
N#define ENET_MSC_RINTMSK_RFCEIM          BIT(5)                                 /*!< received frame CRC error interrupt mask */
N#define ENET_MSC_RINTMSK_RFAEIM          BIT(6)                                 /*!< received frames alignment error interrupt mask */
N#define ENET_MSC_RINTMSK_RGUFIM          BIT(17)                                /*!< received good unicast frames interrupt mask */
N  
N/* ENET_MSC_TINTMSK */
N#define ENET_MSC_TINTMSK_TGFSCIM         BIT(14)                                /*!< transmitted good frames single collision interrupt mask */
N#define ENET_MSC_TINTMSK_TGFMSCIM        BIT(15)                                /*!< transmitted good frames more single collision interrupt mask */
N#define ENET_MSC_TINTMSK_TGFIM           BIT(21)                                /*!< transmitted good frames interrupt mask */
N  
N/* ENET_MSC_SCCNT */
N#define ENET_MSC_SCCNT_SCC               BITS(0,31)                             /*!< transmitted good frames single collision counter */
N  
N/* ENET_MSC_MSCCNT */
N#define ENET_MSC_MSCCNT_MSCC             BITS(0,31)                             /*!< transmitted good frames more one single collision counter */
N  
N/* ENET_MSC_TGFCNT */
N#define ENET_MSC_TGFCNT_TGF              BITS(0,31)                             /*!< transmitted good frames counter */
N  
N/* ENET_MSC_RFCECNT */
N#define ENET_MSC_RFCECNT_RFCER           BITS(0,31)                             /*!< received frames with CRC error counter */
N  
N/* ENET_MSC_RFAECNT */
N#define ENET_MSC_RFAECNT_RFAER           BITS(0,31)                             /*!< received frames alignment error counter */
N  
N/* ENET_MSC_RGUFCNT */
N#define ENET_MSC_RGUFCNT_RGUF            BITS(0,31)                             /*!< received good unicast frames counter */
N   
N/* ENET_PTP_TSCTL */
N#define ENET_PTP_TSCTL_TMSEN             BIT(0)                                 /*!< timestamp enable */
N#define ENET_PTP_TSCTL_TMSFCU            BIT(1)                                 /*!< timestamp fine or coarse update */
N#define ENET_PTP_TSCTL_TMSSTI            BIT(2)                                 /*!< timestamp system time initialize */
N#define ENET_PTP_TSCTL_TMSSTU            BIT(3)                                 /*!< timestamp system time update */
N#define ENET_PTP_TSCTL_TMSITEN           BIT(4)                                 /*!< timestamp interrupt trigger enable */
N#define ENET_PTP_TSCTL_TMSARU            BIT(5)                                 /*!< timestamp addend register update */
N
N/* ENET_PTP_SSINC */
N#define ENET_PTP_SSINC_STMSSI            BITS(0,7)                              /*!< system time subsecond increment */
N  
N/* ENET_PTP_TSH */
N#define ENET_PTP_TSH_STMS                BITS(0,31)                             /*!< system time second */
N  
N/* ENET_PTP_TSL */
N#define ENET_PTP_TSL_STMSS               BITS(0,30)                             /*!< system time subseconds */
N#define ENET_PTP_TSL_STS                 BIT(31)                                /*!< system time sign */
N  
N/* ENET_PTP_TSUH */
N#define ENET_PTP_TSUH_TMSUS              BITS(0,31)                             /*!< timestamp update seconds */
N  
N/* ENET_PTP_TSUL */
N#define ENET_PTP_TSUL_TMSUSS             BITS(0,30)                             /*!< timestamp update subseconds */
N#define ENET_PTP_TSUL_TMSUPNS            BIT(31)                                /*!< timestamp update positive or negative sign */
N
N/* ENET_PTP_TSADDEND */
N#define ENET_PTP_TSADDEND_TMSA           BITS(0,31)                             /*!< timestamp addend */
N  
N/* ENET_PTP_ETH */
N#define ENET_PTP_ETH_ETSH                BITS(0,31)                             /*!< expected time high */
N  
N/* ENET_PTP_ETL */
N#define ENET_PTP_ETL_ETSL                BITS(0,31)                             /*!< expected time low */
N  
N/* ENET_DMA_BCTL */
N#define ENET_DMA_BCTL_SWR                BIT(0)                                 /*!< software reset */
N#define ENET_DMA_BCTL_DAB                BIT(1)                                 /*!< DMA arbitration */
N#define ENET_DMA_BCTL_DPSL               BITS(2,6)                              /*!< descriptor skip length */
N#define ENET_DMA_BCTL_PGBL               BITS(8,13)                             /*!< programmable burst length */
N#define ENET_DMA_BCTL_RTPR               BITS(14,15)                            /*!< RxDMA and TxDMA transfer priority ratio */
N#define ENET_DMA_BCTL_FB                 BIT(16)                                /*!< fixed Burst */
N#define ENET_DMA_BCTL_RXDP               BITS(17,22)                            /*!< RxDMA PGBL */
N#define ENET_DMA_BCTL_UIP                BIT(23)                                /*!< use independent PGBL */
N#define ENET_DMA_BCTL_FPBL               BIT(24)                                /*!< four times PGBL mode */
N#define ENET_DMA_BCTL_AA                 BIT(25)                                /*!< address-aligned */
N  
N/* ENET_DMA_TPEN */
N#define ENET_DMA_TPEN_TPE                BITS(0,31)                             /*!< transmit poll enable */
N  
N/* ENET_DMA_RPEN */
N#define ENET_DMA_RPEN_RPE                BITS(0,31)                             /*!< receive poll enable  */
N
N/* ENET_DMA_RDTADDR */
N#define ENET_DMA_RDTADDR_SRT             BITS(0,31)                             /*!< start address of receive table */
N  
N/* ENET_DMA_TDTADDR */
N#define ENET_DMA_TDTADDR_STT             BITS(0,31)                             /*!< start address of transmit table */
N  
N/* ENET_DMA_STAT */
N#define ENET_DMA_STAT_TS                 BIT(0)                                 /*!< transmit status */
N#define ENET_DMA_STAT_TPS                BIT(1)                                 /*!< transmit process stopped status */
N#define ENET_DMA_STAT_TBU                BIT(2)                                 /*!< transmit buffer unavailable status */
N#define ENET_DMA_STAT_TJT                BIT(3)                                 /*!< transmit jabber timeout status */
N#define ENET_DMA_STAT_RO                 BIT(4)                                 /*!< receive overflow status */
N#define ENET_DMA_STAT_TU                 BIT(5)                                 /*!< transmit underflow status */
N#define ENET_DMA_STAT_RS                 BIT(6)                                 /*!< receive status */
N#define ENET_DMA_STAT_RBU                BIT(7)                                 /*!< receive buffer unavailable status */
N#define ENET_DMA_STAT_RPS                BIT(8)                                 /*!< receive process stopped status */
N#define ENET_DMA_STAT_RWT                BIT(9)                                 /*!< receive watchdog timeout status */
N#define ENET_DMA_STAT_ET                 BIT(10)                                /*!< early transmit status */
N#define ENET_DMA_STAT_FBE                BIT(13)                                /*!< fatal bus error status */
N#define ENET_DMA_STAT_ER                 BIT(14)                                /*!< early receive status */
N#define ENET_DMA_STAT_AI                 BIT(15)                                /*!< abnormal interrupt summary */
N#define ENET_DMA_STAT_NI                 BIT(16)                                /*!< normal interrupt summary */
N#define ENET_DMA_STAT_RP                 BITS(17,19)                            /*!< receive process state */
N#define ENET_DMA_STAT_TP                 BITS(20,22)                            /*!< transmit process state */
N#define ENET_DMA_STAT_EB                 BITS(23,25)                            /*!< error bits status */
N#define ENET_DMA_STAT_MSC                BIT(27)                                /*!< MSC status */
N#define ENET_DMA_STAT_WUM                BIT(28)                                /*!< WUM status */
N#define ENET_DMA_STAT_TST                BIT(29)                                /*!< timestamp trigger status */
N 
N/* ENET_DMA_CTL */
N#define ENET_DMA_CTL_SRE                 BIT(1)                                 /*!< start/stop receive enable */
N#define ENET_DMA_CTL_OSF                 BIT(2)                                 /*!< operate on second frame */
N#define ENET_DMA_CTL_RTHC                BITS(3,4)                              /*!< receive threshold control */
N#define ENET_DMA_CTL_FUF                 BIT(6)                                 /*!< forward undersized good frames */
N#define ENET_DMA_CTL_FERF                BIT(7)                                 /*!< forward error frames */
N#define ENET_DMA_CTL_STE                 BIT(13)                                /*!< start/stop transmission enable */
N#define ENET_DMA_CTL_TTHC                BITS(14,16)                            /*!< transmit threshold control */
N#define ENET_DMA_CTL_FTF                 BIT(20)                                /*!< flush transmit FIFO */
N#define ENET_DMA_CTL_TSFD                BIT(21)                                /*!< transmit store-and-forward */
N#define ENET_DMA_CTL_DAFRF               BIT(24)                                /*!< disable flushing of received frames */
N#define ENET_DMA_CTL_RSFD                BIT(25)                                /*!< receive store-and-forward */
N#define ENET_DMA_CTL_DTCERFD             BIT(26)                                /*!< dropping of TCP/IP checksum error frames disable */
N  
N/* ENET_DMA_INTEN */
N#define ENET_DMA_INTEN_TIE               BIT(0)                                 /*!< transmit interrupt enable */
N#define ENET_DMA_INTEN_TPSIE             BIT(1)                                 /*!< transmit process stopped interrupt enable */
N#define ENET_DMA_INTEN_TBUIE             BIT(2)                                 /*!< transmit buffer unavailable interrupt enable */
N#define ENET_DMA_INTEN_TJTIE             BIT(3)                                 /*!< transmit jabber timeout interrupt enable */
N#define ENET_DMA_INTEN_ROIE              BIT(4)                                 /*!< receive overflow interrupt enable */
N#define ENET_DMA_INTEN_TUIE              BIT(5)                                 /*!< transmit underflow interrupt enable */
N#define ENET_DMA_INTEN_RIE               BIT(6)                                 /*!< receive interrupt enable */
N#define ENET_DMA_INTEN_RBUIE             BIT(7)                                 /*!< receive buffer unavailable interrupt enable */
N#define ENET_DMA_INTEN_RPSIE             BIT(8)                                 /*!< receive process stopped interrupt enable */
N#define ENET_DMA_INTEN_RWTIE             BIT(9)                                 /*!< receive watchdog timeout interrupt enable */
N#define ENET_DMA_INTEN_ETIE              BIT(10)                                /*!< early transmit interrupt enable */
N#define ENET_DMA_INTEN_FBEIE             BIT(13)                                /*!< fatal bus error interrupt enable */
N#define ENET_DMA_INTEN_ERIE              BIT(14)                                /*!< early receive interrupt enable */
N#define ENET_DMA_INTEN_AIE               BIT(15)                                /*!< abnormal interrupt summary enable */
N#define ENET_DMA_INTEN_NIE               BIT(16)                                /*!< normal interrupt summary enable */
N  
N/* ENET_DMA_MFBOCNT */
N#define ENET_DMA_MFBOCNT_MSFC            BITS(0,15)                             /*!< missed frames by the controller */
N#define ENET_DMA_MFBOCNT_OBMFC           BIT(16)                                /* Overflow bit for missed frame counter */
N#define ENET_DMA_MFBOCNT_MSFA            BITS(17,27)                            /*!< missed frames by the application */
N#define ENET_DMA_MFBOCNT_OBFOC           BIT(28)                                /*!< Overflow bit for FIFO overflow counter */
N
N/* ENET_DMA_CTDADDR */
N#define ENET_DMA_CTDADDR_TDAP            BITS(0,31)                             /*!< transmit descriptor address pointer */
N
N/* ENET_DMA_CRDADDR */
N#define ENET_DMA_CRDADDR_RDAP            BITS(0,31)                             /*!< receive descriptor address pointer */
N  
N/* ENET_DMA_CTBADDR */
N#define ENET_DMA_CTBADDR_TBAP            BITS(0,31)                             /*!< transmit buffer address pointer */
N  
N/* ENET_DMA_CRBADDR */
N#define ENET_DMA_CRBADDR_RBAP            BITS(0,31)                             /*!< receive buffer address pointer */
N
N/* ENET DMA Tx descriptor TDES0 */
N#define ENET_TDES0_DB                    BIT(0)                                 /*!< deferred */
N#define ENET_TDES0_UFE                   BIT(1)                                 /*!< underflow error */
N#define ENET_TDES0_EXD                   BIT(2)                                 /*!< excessive deferral */
N#define ENET_TDES0_COCNT                 BITS(3,6)                              /*!< collision count */
N#define ENET_TDES0_VFRM                  BIT(7)                                 /*!< VLAN frame */
N#define ENET_TDES0_ECO                   BIT(8)                                 /*!< excessive collision */
N#define ENET_TDES0_LCO                   BIT(9)                                 /*!< late collision */
N#define ENET_TDES0_NCA                   BIT(10)                                /*!< no carrier */
N#define ENET_TDES0_LCA                   BIT(11)                                /*!< loss of carrier */
N#define ENET_TDES0_IPPE                  BIT(12)                                /*!< IP payload error */
N#define ENET_TDES0_FRMF                  BIT(13)                                /*!< frame flushed */
N#define ENET_TDES0_JT                    BIT(14)                                /*!< jabber timeout */
N#define ENET_TDES0_ES                    BIT(15)                                /*!< error summary */
N#define ENET_TDES0_IPHE                  BIT(16)                                /*!< IP header error */
N#define ENET_TDES0_TTMSS                 BIT(17)                                /*!< transmit timestamp status */
N#define ENET_TDES0_TCHM                  BIT(20)                                /*!< the second address chained mode */
N#define ENET_TDES0_TERM                  BIT(21)                                /*!< transmit end of ring mode*/
N#define ENET_TDES0_CM                    BITS(22,23)                            /*!< checksum mode */
N#define ENET_TDES0_TTSEN                 BIT(25)                                /*!< transmit timestamp function enable */
N#define ENET_TDES0_DPAD                  BIT(26)                                /*!< disable adding pad */
N#define ENET_TDES0_DCRC                  BIT(27)                                /*!< disable CRC */
N#define ENET_TDES0_FSG                   BIT(28)                                /*!< first segment */
N#define ENET_TDES0_LSG                   BIT(29)                                /*!< last segment */
N#define ENET_TDES0_INTC                  BIT(30)                                /*!< interrupt on completion */
N#define ENET_TDES0_DAV                   BIT(31)                                /*!< DAV bit */
N
N/* ENET DMA Tx descriptor TDES1 */
N#define ENET_TDES1_TB1S                  BITS(0,12)                             /*!< transmit buffer 1 size */
N#define ENET_TDES1_TB2S                  BITS(16,28)                            /*!< transmit buffer 2 size */
N
N/* ENET DMA Tx descriptor TDES2 */
N#define ENET_TDES2_TB1AP                 BITS(0,31)                             /*!< transmit buffer 1 address pointer/transmit frame timestamp low 32-bit value */
N
N/* ENET DMA Tx descriptor TDES3 */
N#define ENET_TDES3_TB2AP                 BITS(0,31)                             /*!< transmit buffer 2 address pointer (or next descriptor address) / transmit frame timestamp high 32-bit value */
N
N/* ENET DMA Rx descriptor RDES0 */
N#define ENET_RDES0_PCERR                 BIT(0)                                 /*!< payload checksum error */
N#define ENET_RDES0_CERR                  BIT(1)                                 /*!< CRC error */
N#define ENET_RDES0_DBERR                 BIT(2)                                 /*!< dribble bit error */
N#define ENET_RDES0_RERR                  BIT(3)                                 /*!< receive error */
N#define ENET_RDES0_RWDT                  BIT(4)                                 /*!< receive watchdog timeout */
N#define ENET_RDES0_FRMT                  BIT(5)                                 /*!< frame type */
N#define ENET_RDES0_LCO                   BIT(6)                                 /*!< late collision */
N#define ENET_RDES0_IPHERR                BIT(7)                                 /*!< IP frame header error */
N#define ENET_RDES0_LDES                  BIT(8)                                 /*!< last descriptor */ 
N#define ENET_RDES0_FDES                  BIT(9)                                 /*!< first descriptor */
N#define ENET_RDES0_VTAG                  BIT(10)                                /*!< VLAN tag */
N#define ENET_RDES0_OERR                  BIT(11)                                /*!< overflow Error */
N#define ENET_RDES0_LERR                  BIT(12)                                /*!< length error */
N#define ENET_RDES0_SAFF                  BIT(13)                                /*!< SA filter fail */
N#define ENET_RDES0_DERR                  BIT(14)                                /*!< descriptor error */
N#define ENET_RDES0_ERRS                  BIT(15)                                /*!< error summary */
N#define ENET_RDES0_FRML                  BITS(16,29)                            /*!< frame length */
N#define ENET_RDES0_DAFF                  BIT(30)                                /*!< destination address filter fail */
N#define ENET_RDES0_DAV                   BIT(31)                                /*!< descriptor available */
N
N/* ENET DMA Rx descriptor RDES1 */ 
N#define ENET_RDES1_RB1S                  BITS(0,12)                             /*!< receive buffer 1 size */
N#define ENET_RDES1_RCHM                  BIT(14)                                /*!< receive chained mode for second address */
N#define ENET_RDES1_RERM                  BIT(15)                                /*!< receive end of ring mode*/
N#define ENET_RDES1_RB2S                  BITS(16,28)                            /*!< receive buffer 2 size */
N#define ENET_RDES1_DINTC                 BIT(31)                                /*!< disable interrupt on completion */
N
N/* ENET DMA Rx descriptor RDES2 */
N#define ENET_RDES2_RB1AP                 BITS(0,31)                             /*!< receive buffer 1 address pointer / receive frame timestamp low 32-bit */
N
N/* ENET DMA Rx descriptor RDES3 */
N#define ENET_RDES3_RB2AP                 BITS(0,31)                             /*!< receive buffer 2 address pointer (next descriptor address)/receive frame timestamp high 32-bit value */
N
N/* constants definitions */
N/* define bit position and its register index offset */
N#define ENET_REGIDX_BIT(regidx, bitpos)  (((uint32_t)(regidx) << 6) | (uint32_t)(bitpos))
N#define ENET_REG_VAL(periph)             (REG32(ENET + ((uint32_t)(periph)>>6)))
N#define ENET_BIT_POS(val)                ((uint32_t)(val) & 0x1FU)
N
N/* ENET clock range judgement */
N#define ENET_RANGE(hclk, n, m)           (((hclk) >= (n))&&((hclk) < (m)))
N
N/* define MAC address configuration and reference address */
N#define ENET_SET_MACADDRH(p)             (((uint32_t)(p)[5] << 8) | (uint32_t)(p)[4])         
N#define ENET_SET_MACADDRL(p)             (((uint32_t)(p)[3] << 24) | ((uint32_t)(p)[2] << 16) | ((uint32_t)(p)[1] << 8) | (uint32_t)(p)[0])
N#define ENET_ADDRH_BASE                  ((ENET) + 0x40U)
N#define ENET_ADDRL_BASE                  ((ENET) + 0x44U)
N#define ENET_GET_MACADDR(offset, n)      ((uint8_t)((REG32((ENET_ADDRL_BASE + (offset)) - (((n) / 4U) * 4U)) >> (8U * ((n) % 4U))) & 0xFFU))
N
N/* register offset */
N#define MAC_FCTL_REG_OFFSET              0x0018U                                /*!< MAC flow control register offset */
N#define MAC_WUM_REG_OFFSET               0x002CU                                /*!< MAC wakeup management register offset */
N#define MAC_INTF_REG_OFFSET              0x0038U                                /*!< MAC interrupt flag register offset */
N#define MAC_INTMSK_REG_OFFSET            0x003CU                                /*!< MAC interrupt mask register offset */
N
N#define MSC_RINTF_REG_OFFSET             0x0104U                                /*!< MSC receive interrupt flag register offset */
N#define MSC_TINTF_REG_OFFSET             0x0108U                                /*!< MSC transmit interrupt flag register offset */
N#define MSC_RINTMSK_REG_OFFSET           0x010CU                                /*!< MSC receive interrupt mask register offset */
N#define MSC_TINTMSK_REG_OFFSET           0x0110U                                /*!< MSC transmit interrupt mask register offset */
N#define MSC_SCCNT_REG_OFFSET             0x014CU                                /*!< MSC transmitted good frames after a single collision counter register offset */
N#define MSC_MSCCNT_REG_OFFSET            0x0150U                                /*!< MSC transmitted good frames after more than a single collision counter register offset */
N#define MSC_TGFCNT_REG_OFFSET            0x0168U                                /*!< MSC transmitted good frames counter register offset */
N#define MSC_RFCECNT_REG_OFFSET           0x0194U                                /*!< MSC received frames with CRC error counter register offset */
N#define MSC_RFAECNT_REG_OFFSET           0x0198U                                /*!< MSC received frames with alignment error counter register offset */
N#define MSC_RGUFCNT_REG_OFFSET           0x01C4U                                /*!< MSC received good unicast frames counter register offset */
N
N#define DMA_STAT_REG_OFFSET              0x1014U                                /*!< DMA status register offset */
N#define DMA_INTEN_REG_OFFSET             0x101CU                                /*!< DMA interrupt enable register offset */
N#define DMA_TDTADDR_REG_OFFSET           0x1010U                                /*!< DMA transmit descriptor table address register offset */
N#define DMA_CTDADDR_REG_OFFSET           0x1048U                                /*!< DMA current transmit descriptor address register */
N#define DMA_CTBADDR_REG_OFFSET           0x1050U                                /*!< DMA current transmit buffer address register */
N#define DMA_RDTADDR_REG_OFFSET           0x100CU                                /*!< DMA receive descriptor table address register */
N#define DMA_CRDADDR_REG_OFFSET           0x104CU                                /*!< DMA current receive descriptor address register */
N#define DMA_CRBADDR_REG_OFFSET           0x1054U                                /*!< DMA current receive buffer address register */
N
N/* ENET status flag get */
Ntypedef enum
N{
N    /* ENET_MAC_WUM register */
N    ENET_MAC_FLAG_MPKR              = ENET_REGIDX_BIT(MAC_WUM_REG_OFFSET, 5U),      /*!< magic packet received flag */
X    ENET_MAC_FLAG_MPKR              = (((uint32_t)(0x002CU) << 6) | (uint32_t)(5U)),       
N    ENET_MAC_FLAG_WUFR              = ENET_REGIDX_BIT(MAC_WUM_REG_OFFSET, 6U),      /*!< wakeup frame received flag */ 
X    ENET_MAC_FLAG_WUFR              = (((uint32_t)(0x002CU) << 6) | (uint32_t)(6U)),        
N    /* ENET_MAC_FCTL register */
N    ENET_MAC_FLAG_FLOWCONTROL       = ENET_REGIDX_BIT(MAC_FCTL_REG_OFFSET, 0U),     /*!< flow control status flag */
X    ENET_MAC_FLAG_FLOWCONTROL       = (((uint32_t)(0x0018U) << 6) | (uint32_t)(0U)),      
N    /* ENET_MAC_INTF register */
N    ENET_MAC_FLAG_WUM               = ENET_REGIDX_BIT(MAC_INTF_REG_OFFSET, 3U),     /*!< WUM status flag */
X    ENET_MAC_FLAG_WUM               = (((uint32_t)(0x0038U) << 6) | (uint32_t)(3U)),      
N    ENET_MAC_FLAG_MSC               = ENET_REGIDX_BIT(MAC_INTF_REG_OFFSET, 4U),     /*!< MSC status flag */
X    ENET_MAC_FLAG_MSC               = (((uint32_t)(0x0038U) << 6) | (uint32_t)(4U)),      
N    ENET_MAC_FLAG_MSCR              = ENET_REGIDX_BIT(MAC_INTF_REG_OFFSET, 5U),     /*!< MSC receive status flag */
X    ENET_MAC_FLAG_MSCR              = (((uint32_t)(0x0038U) << 6) | (uint32_t)(5U)),      
N    ENET_MAC_FLAG_MSCT              = ENET_REGIDX_BIT(MAC_INTF_REG_OFFSET, 6U),     /*!< MSC transmit status flag */
X    ENET_MAC_FLAG_MSCT              = (((uint32_t)(0x0038U) << 6) | (uint32_t)(6U)),      
N    ENET_MAC_FLAG_TMST              = ENET_REGIDX_BIT(MAC_INTF_REG_OFFSET, 9U),     /*!< timestamp trigger status flag */
X    ENET_MAC_FLAG_TMST              = (((uint32_t)(0x0038U) << 6) | (uint32_t)(9U)),      
N    /* ENET_MSC_RINTF register */
N    ENET_MSC_FLAG_RFCE              = ENET_REGIDX_BIT(MSC_RINTF_REG_OFFSET, 5U),    /*!< received frames CRC error flag */
X    ENET_MSC_FLAG_RFCE              = (((uint32_t)(0x0104U) << 6) | (uint32_t)(5U)),     
N    ENET_MSC_FLAG_RFAE              = ENET_REGIDX_BIT(MSC_RINTF_REG_OFFSET, 6U),    /*!< received frames alignment error flag */
X    ENET_MSC_FLAG_RFAE              = (((uint32_t)(0x0104U) << 6) | (uint32_t)(6U)),     
N    ENET_MSC_FLAG_RGUF              = ENET_REGIDX_BIT(MSC_RINTF_REG_OFFSET, 17U),   /*!< received good unicast frames flag */
X    ENET_MSC_FLAG_RGUF              = (((uint32_t)(0x0104U) << 6) | (uint32_t)(17U)),    
N    /* ENET_MSC_TINTF register */ 
N    ENET_MSC_FLAG_TGFSC             = ENET_REGIDX_BIT(MSC_TINTF_REG_OFFSET, 14U),   /*!< transmitted good frames single collision flag */
X    ENET_MSC_FLAG_TGFSC             = (((uint32_t)(0x0108U) << 6) | (uint32_t)(14U)),    
N    ENET_MSC_FLAG_TGFMSC            = ENET_REGIDX_BIT(MSC_TINTF_REG_OFFSET, 15U),   /*!< transmitted good frames more single collision flag */
X    ENET_MSC_FLAG_TGFMSC            = (((uint32_t)(0x0108U) << 6) | (uint32_t)(15U)),    
N    ENET_MSC_FLAG_TGF               = ENET_REGIDX_BIT(MSC_TINTF_REG_OFFSET, 21U),   /*!< transmitted good frames flag */
X    ENET_MSC_FLAG_TGF               = (((uint32_t)(0x0108U) << 6) | (uint32_t)(21U)),    
N    /* ENET_DMA_STAT register */
N    ENET_DMA_FLAG_TS                = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 0U),     /*!< transmit status flag */
X    ENET_DMA_FLAG_TS                = (((uint32_t)(0x1014U) << 6) | (uint32_t)(0U)),      
N    ENET_DMA_FLAG_TPS               = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 1U),     /*!< transmit process stopped status flag */
X    ENET_DMA_FLAG_TPS               = (((uint32_t)(0x1014U) << 6) | (uint32_t)(1U)),      
N    ENET_DMA_FLAG_TBU               = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 2U),     /*!< transmit buffer unavailable status flag */
X    ENET_DMA_FLAG_TBU               = (((uint32_t)(0x1014U) << 6) | (uint32_t)(2U)),      
N    ENET_DMA_FLAG_TJT               = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 3U),     /*!< transmit jabber timeout status flag */
X    ENET_DMA_FLAG_TJT               = (((uint32_t)(0x1014U) << 6) | (uint32_t)(3U)),      
N    ENET_DMA_FLAG_RO                = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 4U),     /*!< receive overflow status flag */
X    ENET_DMA_FLAG_RO                = (((uint32_t)(0x1014U) << 6) | (uint32_t)(4U)),      
N    ENET_DMA_FLAG_TU                = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 5U),     /*!< transmit underflow status flag */
X    ENET_DMA_FLAG_TU                = (((uint32_t)(0x1014U) << 6) | (uint32_t)(5U)),      
N    ENET_DMA_FLAG_RS                = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 6U),     /*!< receive status flag */
X    ENET_DMA_FLAG_RS                = (((uint32_t)(0x1014U) << 6) | (uint32_t)(6U)),      
N    ENET_DMA_FLAG_RBU               = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 7U),     /*!< receive buffer unavailable status flag */
X    ENET_DMA_FLAG_RBU               = (((uint32_t)(0x1014U) << 6) | (uint32_t)(7U)),      
N    ENET_DMA_FLAG_RPS               = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 8U),     /*!< receive process stopped status flag */
X    ENET_DMA_FLAG_RPS               = (((uint32_t)(0x1014U) << 6) | (uint32_t)(8U)),      
N    ENET_DMA_FLAG_RWT               = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 9U),     /*!< receive watchdog timeout status flag */
X    ENET_DMA_FLAG_RWT               = (((uint32_t)(0x1014U) << 6) | (uint32_t)(9U)),      
N    ENET_DMA_FLAG_ET                = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 10U),    /*!< early transmit status flag */
X    ENET_DMA_FLAG_ET                = (((uint32_t)(0x1014U) << 6) | (uint32_t)(10U)),     
N    ENET_DMA_FLAG_FBE               = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 13U),    /*!< fatal bus error status flag */
X    ENET_DMA_FLAG_FBE               = (((uint32_t)(0x1014U) << 6) | (uint32_t)(13U)),     
N    ENET_DMA_FLAG_ER                = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 14U),    /*!< early receive status flag */
X    ENET_DMA_FLAG_ER                = (((uint32_t)(0x1014U) << 6) | (uint32_t)(14U)),     
N    ENET_DMA_FLAG_AI                = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 15U),    /*!< abnormal interrupt summary flag */
X    ENET_DMA_FLAG_AI                = (((uint32_t)(0x1014U) << 6) | (uint32_t)(15U)),     
N    ENET_DMA_FLAG_NI                = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 16U),    /*!< normal interrupt summary flag */
X    ENET_DMA_FLAG_NI                = (((uint32_t)(0x1014U) << 6) | (uint32_t)(16U)),     
N    ENET_DMA_FLAG_EB_DMA_ERROR      = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 23U),    /*!< error during data transfer by RxDMA/TxDMA flag */
X    ENET_DMA_FLAG_EB_DMA_ERROR      = (((uint32_t)(0x1014U) << 6) | (uint32_t)(23U)),     
N    ENET_DMA_FLAG_EB_TRANSFER_ERROR = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 24U),    /*!< error during write/read transfer flag */
X    ENET_DMA_FLAG_EB_TRANSFER_ERROR = (((uint32_t)(0x1014U) << 6) | (uint32_t)(24U)),     
N    ENET_DMA_FLAG_EB_ACCESS_ERROR   = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 25U),    /*!< error during data buffer/descriptor access flag */
X    ENET_DMA_FLAG_EB_ACCESS_ERROR   = (((uint32_t)(0x1014U) << 6) | (uint32_t)(25U)),     
N    ENET_DMA_FLAG_MSC               = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 27U),    /*!< MSC status flag */
X    ENET_DMA_FLAG_MSC               = (((uint32_t)(0x1014U) << 6) | (uint32_t)(27U)),     
N    ENET_DMA_FLAG_WUM               = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 28U),    /*!< WUM status flag */
X    ENET_DMA_FLAG_WUM               = (((uint32_t)(0x1014U) << 6) | (uint32_t)(28U)),     
N    ENET_DMA_FLAG_TST               = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 29U),    /*!< timestamp trigger status flag */                        
X    ENET_DMA_FLAG_TST               = (((uint32_t)(0x1014U) << 6) | (uint32_t)(29U)),                             
N}enet_flag_enum;
N
N/* ENET stutus flag clear */
Ntypedef enum
N{
N    /* ENET_DMA_STAT register */
N    ENET_DMA_FLAG_TS_CLR            = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 0U),     /*!< transmit status flag */
X    ENET_DMA_FLAG_TS_CLR            = (((uint32_t)(0x1014U) << 6) | (uint32_t)(0U)),      
N    ENET_DMA_FLAG_TPS_CLR           = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 1U),     /*!< transmit process stopped status flag */
X    ENET_DMA_FLAG_TPS_CLR           = (((uint32_t)(0x1014U) << 6) | (uint32_t)(1U)),      
N    ENET_DMA_FLAG_TBU_CLR           = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 2U),     /*!< transmit buffer unavailable status flag */
X    ENET_DMA_FLAG_TBU_CLR           = (((uint32_t)(0x1014U) << 6) | (uint32_t)(2U)),      
N    ENET_DMA_FLAG_TJT_CLR           = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 3U),     /*!< transmit jabber timeout status flag */
X    ENET_DMA_FLAG_TJT_CLR           = (((uint32_t)(0x1014U) << 6) | (uint32_t)(3U)),      
N    ENET_DMA_FLAG_RO_CLR            = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 4U),     /*!< receive overflow status flag */
X    ENET_DMA_FLAG_RO_CLR            = (((uint32_t)(0x1014U) << 6) | (uint32_t)(4U)),      
N    ENET_DMA_FLAG_TU_CLR            = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 5U),     /*!< transmit underflow status flag */
X    ENET_DMA_FLAG_TU_CLR            = (((uint32_t)(0x1014U) << 6) | (uint32_t)(5U)),      
N    ENET_DMA_FLAG_RS_CLR            = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 6U),     /*!< receive status flag */
X    ENET_DMA_FLAG_RS_CLR            = (((uint32_t)(0x1014U) << 6) | (uint32_t)(6U)),      
N    ENET_DMA_FLAG_RBU_CLR           = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 7U),     /*!< receive buffer unavailable status flag */
X    ENET_DMA_FLAG_RBU_CLR           = (((uint32_t)(0x1014U) << 6) | (uint32_t)(7U)),      
N    ENET_DMA_FLAG_RPS_CLR           = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 8U),     /*!< receive process stopped status flag */
X    ENET_DMA_FLAG_RPS_CLR           = (((uint32_t)(0x1014U) << 6) | (uint32_t)(8U)),      
N    ENET_DMA_FLAG_RWT_CLR           = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 9U),     /*!< receive watchdog timeout status flag */
X    ENET_DMA_FLAG_RWT_CLR           = (((uint32_t)(0x1014U) << 6) | (uint32_t)(9U)),      
N    ENET_DMA_FLAG_ET_CLR            = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 10U),    /*!< early transmit status flag */
X    ENET_DMA_FLAG_ET_CLR            = (((uint32_t)(0x1014U) << 6) | (uint32_t)(10U)),     
N    ENET_DMA_FLAG_FBE_CLR           = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 13U),    /*!< fatal bus error status flag */
X    ENET_DMA_FLAG_FBE_CLR           = (((uint32_t)(0x1014U) << 6) | (uint32_t)(13U)),     
N    ENET_DMA_FLAG_ER_CLR            = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 14U),    /*!< early receive status flag */
X    ENET_DMA_FLAG_ER_CLR            = (((uint32_t)(0x1014U) << 6) | (uint32_t)(14U)),     
N    ENET_DMA_FLAG_AI_CLR            = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 15U),    /*!< abnormal interrupt summary flag */
X    ENET_DMA_FLAG_AI_CLR            = (((uint32_t)(0x1014U) << 6) | (uint32_t)(15U)),     
N    ENET_DMA_FLAG_NI_CLR            = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 16U),    /*!< normal interrupt summary flag */                       
X    ENET_DMA_FLAG_NI_CLR            = (((uint32_t)(0x1014U) << 6) | (uint32_t)(16U)),                            
N}enet_flag_clear_enum;
N
N/* ENET interrupt enable/disable */
Ntypedef enum
N{
N    /* ENET_MAC_INTMSK register */
N    ENET_MAC_INT_WUMIM              = ENET_REGIDX_BIT(MAC_INTMSK_REG_OFFSET, 3U),   /*!< WUM interrupt mask */
X    ENET_MAC_INT_WUMIM              = (((uint32_t)(0x003CU) << 6) | (uint32_t)(3U)),    
N    ENET_MAC_INT_TMSTIM             = ENET_REGIDX_BIT(MAC_INTMSK_REG_OFFSET, 9U),   /*!< timestamp trigger interrupt mask */
X    ENET_MAC_INT_TMSTIM             = (((uint32_t)(0x003CU) << 6) | (uint32_t)(9U)),    
N    /* ENET_MSC_RINTMSK register */ 
N    ENET_MSC_INT_RFCEIM             = ENET_REGIDX_BIT(MSC_RINTMSK_REG_OFFSET, 5U),  /*!< received frame CRC error interrupt mask */
X    ENET_MSC_INT_RFCEIM             = (((uint32_t)(0x010CU) << 6) | (uint32_t)(5U)),   
N    ENET_MSC_INT_RFAEIM             = ENET_REGIDX_BIT(MSC_RINTMSK_REG_OFFSET, 6U),  /*!< received frames alignment error interrupt mask */
X    ENET_MSC_INT_RFAEIM             = (((uint32_t)(0x010CU) << 6) | (uint32_t)(6U)),   
N    ENET_MSC_INT_RGUFIM             = ENET_REGIDX_BIT(MSC_RINTMSK_REG_OFFSET, 17U), /*!< received good unicast frames interrupt mask */
X    ENET_MSC_INT_RGUFIM             = (((uint32_t)(0x010CU) << 6) | (uint32_t)(17U)),  
N    /* ENET_MSC_TINTMSK register */ 
N    ENET_MSC_INT_TGFSCIM            = ENET_REGIDX_BIT(MSC_TINTMSK_REG_OFFSET, 14U), /*!< transmitted good frames single collision interrupt mask */
X    ENET_MSC_INT_TGFSCIM            = (((uint32_t)(0x0110U) << 6) | (uint32_t)(14U)),  
N    ENET_MSC_INT_TGFMSCIM           = ENET_REGIDX_BIT(MSC_TINTMSK_REG_OFFSET, 15U), /*!< transmitted good frames more single collision interrupt mask */
X    ENET_MSC_INT_TGFMSCIM           = (((uint32_t)(0x0110U) << 6) | (uint32_t)(15U)),  
N    ENET_MSC_INT_TGFIM              = ENET_REGIDX_BIT(MSC_TINTMSK_REG_OFFSET, 21U), /*!< transmitted good frames interrupt mask */
X    ENET_MSC_INT_TGFIM              = (((uint32_t)(0x0110U) << 6) | (uint32_t)(21U)),  
N    /* ENET_DMA_INTEN register */ 
N    ENET_DMA_INT_TIE                = ENET_REGIDX_BIT(DMA_INTEN_REG_OFFSET, 0U),    /*!< transmit interrupt enable */
X    ENET_DMA_INT_TIE                = (((uint32_t)(0x101CU) << 6) | (uint32_t)(0U)),     
N    ENET_DMA_INT_TPSIE              = ENET_REGIDX_BIT(DMA_INTEN_REG_OFFSET, 1U),    /*!< transmit process stopped interrupt enable */
X    ENET_DMA_INT_TPSIE              = (((uint32_t)(0x101CU) << 6) | (uint32_t)(1U)),     
N    ENET_DMA_INT_TBUIE              = ENET_REGIDX_BIT(DMA_INTEN_REG_OFFSET, 2U),    /*!< transmit buffer unavailable interrupt enable */
X    ENET_DMA_INT_TBUIE              = (((uint32_t)(0x101CU) << 6) | (uint32_t)(2U)),     
N    ENET_DMA_INT_TJTIE              = ENET_REGIDX_BIT(DMA_INTEN_REG_OFFSET, 3U),    /*!< transmit jabber timeout interrupt enable */
X    ENET_DMA_INT_TJTIE              = (((uint32_t)(0x101CU) << 6) | (uint32_t)(3U)),     
N    ENET_DMA_INT_ROIE               = ENET_REGIDX_BIT(DMA_INTEN_REG_OFFSET, 4U),    /*!< receive overflow interrupt enable */
X    ENET_DMA_INT_ROIE               = (((uint32_t)(0x101CU) << 6) | (uint32_t)(4U)),     
N    ENET_DMA_INT_TUIE               = ENET_REGIDX_BIT(DMA_INTEN_REG_OFFSET, 5U),    /*!< transmit underflow interrupt enable */
X    ENET_DMA_INT_TUIE               = (((uint32_t)(0x101CU) << 6) | (uint32_t)(5U)),     
N    ENET_DMA_INT_RIE                = ENET_REGIDX_BIT(DMA_INTEN_REG_OFFSET, 6U),    /*!< receive interrupt enable */
X    ENET_DMA_INT_RIE                = (((uint32_t)(0x101CU) << 6) | (uint32_t)(6U)),     
N    ENET_DMA_INT_RBUIE              = ENET_REGIDX_BIT(DMA_INTEN_REG_OFFSET, 7U),    /*!< receive buffer unavailable interrupt enable */
X    ENET_DMA_INT_RBUIE              = (((uint32_t)(0x101CU) << 6) | (uint32_t)(7U)),     
N    ENET_DMA_INT_RPSIE              = ENET_REGIDX_BIT(DMA_INTEN_REG_OFFSET, 8U),    /*!< receive process stopped interrupt enable */
X    ENET_DMA_INT_RPSIE              = (((uint32_t)(0x101CU) << 6) | (uint32_t)(8U)),     
N    ENET_DMA_INT_RWTIE              = ENET_REGIDX_BIT(DMA_INTEN_REG_OFFSET, 9U),    /*!< receive watchdog timeout interrupt enable */
X    ENET_DMA_INT_RWTIE              = (((uint32_t)(0x101CU) << 6) | (uint32_t)(9U)),     
N    ENET_DMA_INT_ETIE               = ENET_REGIDX_BIT(DMA_INTEN_REG_OFFSET, 10U),   /*!< early transmit interrupt enable */
X    ENET_DMA_INT_ETIE               = (((uint32_t)(0x101CU) << 6) | (uint32_t)(10U)),    
N    ENET_DMA_INT_FBEIE              = ENET_REGIDX_BIT(DMA_INTEN_REG_OFFSET, 13U),   /*!< fatal bus error interrupt enable */
X    ENET_DMA_INT_FBEIE              = (((uint32_t)(0x101CU) << 6) | (uint32_t)(13U)),    
N    ENET_DMA_INT_ERIE               = ENET_REGIDX_BIT(DMA_INTEN_REG_OFFSET, 14U),   /*!< early receive interrupt enable */
X    ENET_DMA_INT_ERIE               = (((uint32_t)(0x101CU) << 6) | (uint32_t)(14U)),    
N    ENET_DMA_INT_AIE                = ENET_REGIDX_BIT(DMA_INTEN_REG_OFFSET, 15U),   /*!< abnormal interrupt summary enable */
X    ENET_DMA_INT_AIE                = (((uint32_t)(0x101CU) << 6) | (uint32_t)(15U)),    
N    ENET_DMA_INT_NIE                = ENET_REGIDX_BIT(DMA_INTEN_REG_OFFSET, 16U),   /*!< normal interrupt summary enable */
X    ENET_DMA_INT_NIE                = (((uint32_t)(0x101CU) << 6) | (uint32_t)(16U)),    
N}enet_int_enum;
N 
N/* ENET interrupt flag get */
Ntypedef enum
N{
N    /* ENET_MAC_INTF register */
N    ENET_MAC_INT_FLAG_WUM           = ENET_REGIDX_BIT(MAC_INTF_REG_OFFSET, 3U),     /*!< WUM status flag */
X    ENET_MAC_INT_FLAG_WUM           = (((uint32_t)(0x0038U) << 6) | (uint32_t)(3U)),      
N    ENET_MAC_INT_FLAG_MSC           = ENET_REGIDX_BIT(MAC_INTF_REG_OFFSET, 4U),     /*!< MSC status flag */
X    ENET_MAC_INT_FLAG_MSC           = (((uint32_t)(0x0038U) << 6) | (uint32_t)(4U)),      
N    ENET_MAC_INT_FLAG_MSCR          = ENET_REGIDX_BIT(MAC_INTF_REG_OFFSET, 5U),     /*!< MSC receive status flag */
X    ENET_MAC_INT_FLAG_MSCR          = (((uint32_t)(0x0038U) << 6) | (uint32_t)(5U)),      
N    ENET_MAC_INT_FLAG_MSCT          = ENET_REGIDX_BIT(MAC_INTF_REG_OFFSET, 6U),     /*!< MSC transmit status flag */
X    ENET_MAC_INT_FLAG_MSCT          = (((uint32_t)(0x0038U) << 6) | (uint32_t)(6U)),      
N    ENET_MAC_INT_FLAG_TMST          = ENET_REGIDX_BIT(MAC_INTF_REG_OFFSET, 9U),     /*!< timestamp trigger status flag */
X    ENET_MAC_INT_FLAG_TMST          = (((uint32_t)(0x0038U) << 6) | (uint32_t)(9U)),      
N    /* ENET_MSC_RINTF register */
N    ENET_MSC_INT_FLAG_RFCE          = ENET_REGIDX_BIT(MSC_RINTF_REG_OFFSET, 5U),    /*!< received frames CRC error flag */
X    ENET_MSC_INT_FLAG_RFCE          = (((uint32_t)(0x0104U) << 6) | (uint32_t)(5U)),     
N    ENET_MSC_INT_FLAG_RFAE          = ENET_REGIDX_BIT(MSC_RINTF_REG_OFFSET, 6U),    /*!< received frames alignment error flag */
X    ENET_MSC_INT_FLAG_RFAE          = (((uint32_t)(0x0104U) << 6) | (uint32_t)(6U)),     
N    ENET_MSC_INT_FLAG_RGUF          = ENET_REGIDX_BIT(MSC_RINTF_REG_OFFSET, 17U),   /*!< received good unicast frames flag */
X    ENET_MSC_INT_FLAG_RGUF          = (((uint32_t)(0x0104U) << 6) | (uint32_t)(17U)),    
N    /* ENET_MSC_TINTF register */
N    ENET_MSC_INT_FLAG_TGFSC         = ENET_REGIDX_BIT(MSC_TINTF_REG_OFFSET, 14U),   /*!< transmitted good frames single collision flag */
X    ENET_MSC_INT_FLAG_TGFSC         = (((uint32_t)(0x0108U) << 6) | (uint32_t)(14U)),    
N    ENET_MSC_INT_FLAG_TGFMSC        = ENET_REGIDX_BIT(MSC_TINTF_REG_OFFSET, 15U),   /*!< transmitted good frames more single collision flag */
X    ENET_MSC_INT_FLAG_TGFMSC        = (((uint32_t)(0x0108U) << 6) | (uint32_t)(15U)),    
N    ENET_MSC_INT_FLAG_TGF           = ENET_REGIDX_BIT(MSC_TINTF_REG_OFFSET, 21U),   /*!< transmitted good frames flag */
X    ENET_MSC_INT_FLAG_TGF           = (((uint32_t)(0x0108U) << 6) | (uint32_t)(21U)),    
N    /* ENET_DMA_STAT register */
N    ENET_DMA_INT_FLAG_TS            = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 0U),     /*!< transmit status flag */
X    ENET_DMA_INT_FLAG_TS            = (((uint32_t)(0x1014U) << 6) | (uint32_t)(0U)),      
N    ENET_DMA_INT_FLAG_TPS           = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 1U),     /*!< transmit process stopped status flag */
X    ENET_DMA_INT_FLAG_TPS           = (((uint32_t)(0x1014U) << 6) | (uint32_t)(1U)),      
N    ENET_DMA_INT_FLAG_TBU           = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 2U),     /*!< transmit buffer unavailable status flag */
X    ENET_DMA_INT_FLAG_TBU           = (((uint32_t)(0x1014U) << 6) | (uint32_t)(2U)),      
N    ENET_DMA_INT_FLAG_TJT           = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 3U),     /*!< transmit jabber timeout status flag */
X    ENET_DMA_INT_FLAG_TJT           = (((uint32_t)(0x1014U) << 6) | (uint32_t)(3U)),      
N    ENET_DMA_INT_FLAG_RO            = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 4U),     /*!< receive overflow status flag */
X    ENET_DMA_INT_FLAG_RO            = (((uint32_t)(0x1014U) << 6) | (uint32_t)(4U)),      
N    ENET_DMA_INT_FLAG_TU            = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 5U),     /*!< transmit underflow status flag */
X    ENET_DMA_INT_FLAG_TU            = (((uint32_t)(0x1014U) << 6) | (uint32_t)(5U)),      
N    ENET_DMA_INT_FLAG_RS            = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 6U),     /*!< receive status flag */
X    ENET_DMA_INT_FLAG_RS            = (((uint32_t)(0x1014U) << 6) | (uint32_t)(6U)),      
N    ENET_DMA_INT_FLAG_RBU           = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 7U),     /*!< receive buffer unavailable status flag */
X    ENET_DMA_INT_FLAG_RBU           = (((uint32_t)(0x1014U) << 6) | (uint32_t)(7U)),      
N    ENET_DMA_INT_FLAG_RPS           = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 8U),     /*!< receive process stopped status flag */
X    ENET_DMA_INT_FLAG_RPS           = (((uint32_t)(0x1014U) << 6) | (uint32_t)(8U)),      
N    ENET_DMA_INT_FLAG_RWT           = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 9U),     /*!< receive watchdog timeout status flag */
X    ENET_DMA_INT_FLAG_RWT           = (((uint32_t)(0x1014U) << 6) | (uint32_t)(9U)),      
N    ENET_DMA_INT_FLAG_ET            = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 10U),    /*!< early transmit status flag */
X    ENET_DMA_INT_FLAG_ET            = (((uint32_t)(0x1014U) << 6) | (uint32_t)(10U)),     
N    ENET_DMA_INT_FLAG_FBE           = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 13U),    /*!< fatal bus error status flag */
X    ENET_DMA_INT_FLAG_FBE           = (((uint32_t)(0x1014U) << 6) | (uint32_t)(13U)),     
N    ENET_DMA_INT_FLAG_ER            = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 14U),    /*!< early receive status flag */
X    ENET_DMA_INT_FLAG_ER            = (((uint32_t)(0x1014U) << 6) | (uint32_t)(14U)),     
N    ENET_DMA_INT_FLAG_AI            = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 15U),    /*!< abnormal interrupt summary flag */
X    ENET_DMA_INT_FLAG_AI            = (((uint32_t)(0x1014U) << 6) | (uint32_t)(15U)),     
N    ENET_DMA_INT_FLAG_NI            = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 16U),    /*!< normal interrupt summary flag */
X    ENET_DMA_INT_FLAG_NI            = (((uint32_t)(0x1014U) << 6) | (uint32_t)(16U)),     
N    ENET_DMA_INT_FLAG_MSC           = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 27U),    /*!< MSC status flag */
X    ENET_DMA_INT_FLAG_MSC           = (((uint32_t)(0x1014U) << 6) | (uint32_t)(27U)),     
N    ENET_DMA_INT_FLAG_WUM           = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 28U),    /*!< WUM status flag */
X    ENET_DMA_INT_FLAG_WUM           = (((uint32_t)(0x1014U) << 6) | (uint32_t)(28U)),     
N    ENET_DMA_INT_FLAG_TST           = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 29U),    /*!< timestamp trigger status flag */ 
X    ENET_DMA_INT_FLAG_TST           = (((uint32_t)(0x1014U) << 6) | (uint32_t)(29U)),      
N}enet_int_flag_enum;
N
N/* ENET interrupt flag clear */
Ntypedef enum
N{
N    /* ENET_DMA_STAT register */
N    ENET_DMA_INT_FLAG_TS_CLR        = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 0U),     /*!< transmit status flag */
X    ENET_DMA_INT_FLAG_TS_CLR        = (((uint32_t)(0x1014U) << 6) | (uint32_t)(0U)),      
N    ENET_DMA_INT_FLAG_TPS_CLR       = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 1U),     /*!< transmit process stopped status flag */
X    ENET_DMA_INT_FLAG_TPS_CLR       = (((uint32_t)(0x1014U) << 6) | (uint32_t)(1U)),      
N    ENET_DMA_INT_FLAG_TBU_CLR       = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 2U),     /*!< transmit buffer unavailable status flag */
X    ENET_DMA_INT_FLAG_TBU_CLR       = (((uint32_t)(0x1014U) << 6) | (uint32_t)(2U)),      
N    ENET_DMA_INT_FLAG_TJT_CLR       = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 3U),     /*!< transmit jabber timeout status flag */
X    ENET_DMA_INT_FLAG_TJT_CLR       = (((uint32_t)(0x1014U) << 6) | (uint32_t)(3U)),      
N    ENET_DMA_INT_FLAG_RO_CLR        = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 4U),     /*!< receive overflow status flag */
X    ENET_DMA_INT_FLAG_RO_CLR        = (((uint32_t)(0x1014U) << 6) | (uint32_t)(4U)),      
N    ENET_DMA_INT_FLAG_TU_CLR        = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 5U),     /*!< transmit underflow status flag */
X    ENET_DMA_INT_FLAG_TU_CLR        = (((uint32_t)(0x1014U) << 6) | (uint32_t)(5U)),      
N    ENET_DMA_INT_FLAG_RS_CLR        = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 6U),     /*!< receive status flag */
X    ENET_DMA_INT_FLAG_RS_CLR        = (((uint32_t)(0x1014U) << 6) | (uint32_t)(6U)),      
N    ENET_DMA_INT_FLAG_RBU_CLR       = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 7U),     /*!< receive buffer unavailable status flag */
X    ENET_DMA_INT_FLAG_RBU_CLR       = (((uint32_t)(0x1014U) << 6) | (uint32_t)(7U)),      
N    ENET_DMA_INT_FLAG_RPS_CLR       = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 8U),     /*!< receive process stopped status flag */
X    ENET_DMA_INT_FLAG_RPS_CLR       = (((uint32_t)(0x1014U) << 6) | (uint32_t)(8U)),      
N    ENET_DMA_INT_FLAG_RWT_CLR       = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 9U),     /*!< receive watchdog timeout status flag */
X    ENET_DMA_INT_FLAG_RWT_CLR       = (((uint32_t)(0x1014U) << 6) | (uint32_t)(9U)),      
N    ENET_DMA_INT_FLAG_ET_CLR        = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 10U),    /*!< early transmit status flag */
X    ENET_DMA_INT_FLAG_ET_CLR        = (((uint32_t)(0x1014U) << 6) | (uint32_t)(10U)),     
N    ENET_DMA_INT_FLAG_FBE_CLR       = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 13U),    /*!< fatal bus error status flag */
X    ENET_DMA_INT_FLAG_FBE_CLR       = (((uint32_t)(0x1014U) << 6) | (uint32_t)(13U)),     
N    ENET_DMA_INT_FLAG_ER_CLR        = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 14U),    /*!< early receive status flag */
X    ENET_DMA_INT_FLAG_ER_CLR        = (((uint32_t)(0x1014U) << 6) | (uint32_t)(14U)),     
N    ENET_DMA_INT_FLAG_AI_CLR        = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 15U),    /*!< abnormal interrupt summary flag */
X    ENET_DMA_INT_FLAG_AI_CLR        = (((uint32_t)(0x1014U) << 6) | (uint32_t)(15U)),     
N    ENET_DMA_INT_FLAG_NI_CLR        = ENET_REGIDX_BIT(DMA_STAT_REG_OFFSET, 16U),    /*!< normal interrupt summary flag */
X    ENET_DMA_INT_FLAG_NI_CLR        = (((uint32_t)(0x1014U) << 6) | (uint32_t)(16U)),     
N}enet_int_flag_clear_enum;
N
N/* current RX/TX descriptor/buffer/descriptor table address get */
Ntypedef enum
N{
N    ENET_RX_DESC_TABLE              = DMA_RDTADDR_REG_OFFSET,                       /*!< RX descriptor table */
X    ENET_RX_DESC_TABLE              = 0x100CU,                        
N    ENET_RX_CURRENT_DESC            = DMA_CRDADDR_REG_OFFSET,                       /*!< current RX descriptor */
X    ENET_RX_CURRENT_DESC            = 0x104CU,                        
N    ENET_RX_CURRENT_BUFFER          = DMA_CRBADDR_REG_OFFSET,                       /*!< current RX buffer */
X    ENET_RX_CURRENT_BUFFER          = 0x1054U,                        
N    ENET_TX_DESC_TABLE              = DMA_TDTADDR_REG_OFFSET,                       /*!< TX descriptor table */
X    ENET_TX_DESC_TABLE              = 0x1010U,                        
N    ENET_TX_CURRENT_DESC            = DMA_CTDADDR_REG_OFFSET,                       /*!< current TX descriptor */
X    ENET_TX_CURRENT_DESC            = 0x1048U,                        
N    ENET_TX_CURRENT_BUFFER          = DMA_CTBADDR_REG_OFFSET                        /*!< current TX buffer */
X    ENET_TX_CURRENT_BUFFER          = 0x1050U                         
N}enet_desc_reg_enum;
N
N/* MAC statistics counter get */
Ntypedef enum
N{
N    ENET_MSC_TX_SCCNT               = MSC_SCCNT_REG_OFFSET,                         /*!< MSC transmitted good frames after a single collision counter */
X    ENET_MSC_TX_SCCNT               = 0x014CU,                          
N    ENET_MSC_TX_MSCCNT              = MSC_MSCCNT_REG_OFFSET,                        /*!< MSC transmitted good frames after more than a single collision counter */
X    ENET_MSC_TX_MSCCNT              = 0x0150U,                         
N    ENET_MSC_TX_TGFCNT              = MSC_TGFCNT_REG_OFFSET,                        /*!< MSC transmitted good frames counter */
X    ENET_MSC_TX_TGFCNT              = 0x0168U,                         
N    ENET_MSC_RX_RFCECNT             = MSC_RFCECNT_REG_OFFSET,                       /*!< MSC received frames with CRC error counter */
X    ENET_MSC_RX_RFCECNT             = 0x0194U,                        
N    ENET_MSC_RX_RFAECNT             = MSC_RFAECNT_REG_OFFSET,                       /*!< MSC received frames with alignment error counter */
X    ENET_MSC_RX_RFAECNT             = 0x0198U,                        
N    ENET_MSC_RX_RGUFCNT             = MSC_RGUFCNT_REG_OFFSET                        /*!< MSC received good unicast frames counter */
X    ENET_MSC_RX_RGUFCNT             = 0x01C4U                         
N}enet_msc_counter_enum; 
N
N/* function option, used for ENET initialization */
Ntypedef enum
N{
N    FORWARD_OPTION                  = BIT(0),                                       /*!< configure the frame forward related parameters */
X    FORWARD_OPTION                  = ((uint32_t)((uint32_t)0x01U<<(0))),                                        
N    DMABUS_OPTION                   = BIT(1),                                       /*!< configure the DMA bus mode related parameters */
X    DMABUS_OPTION                   = ((uint32_t)((uint32_t)0x01U<<(1))),                                        
N    DMA_MAXBURST_OPTION             = BIT(2),                                       /*!< configure the DMA max burst related parameters */
X    DMA_MAXBURST_OPTION             = ((uint32_t)((uint32_t)0x01U<<(2))),                                        
N    DMA_ARBITRATION_OPTION          = BIT(3),                                       /*!< configure the DMA arbitration related parameters */
X    DMA_ARBITRATION_OPTION          = ((uint32_t)((uint32_t)0x01U<<(3))),                                        
N    STORE_OPTION                    = BIT(4),                                       /*!< configure the store forward mode related parameters */
X    STORE_OPTION                    = ((uint32_t)((uint32_t)0x01U<<(4))),                                        
N    DMA_OPTION                      = BIT(5),                                       /*!< configure the DMA control related parameters */
X    DMA_OPTION                      = ((uint32_t)((uint32_t)0x01U<<(5))),                                        
N    VLAN_OPTION                     = BIT(6),                                       /*!< configure the VLAN tag related parameters */
X    VLAN_OPTION                     = ((uint32_t)((uint32_t)0x01U<<(6))),                                        
N    FLOWCTL_OPTION                  = BIT(7),                                       /*!< configure the flow control related parameters */
X    FLOWCTL_OPTION                  = ((uint32_t)((uint32_t)0x01U<<(7))),                                        
N    HASHH_OPTION                    = BIT(8),                                       /*!< configure the hash list high 32-bit related parameters */
X    HASHH_OPTION                    = ((uint32_t)((uint32_t)0x01U<<(8))),                                        
N    HASHL_OPTION                    = BIT(9),                                       /*!< configure the hash list low 32-bit related parameters */
X    HASHL_OPTION                    = ((uint32_t)((uint32_t)0x01U<<(9))),                                        
N    FILTER_OPTION                   = BIT(10),                                      /*!< configure the frame filter control related parameters */
X    FILTER_OPTION                   = ((uint32_t)((uint32_t)0x01U<<(10))),                                       
N    HALFDUPLEX_OPTION               = BIT(11),                                      /*!< configure the halfduplex related parameters */
X    HALFDUPLEX_OPTION               = ((uint32_t)((uint32_t)0x01U<<(11))),                                       
N    TIMER_OPTION                    = BIT(12),                                      /*!< configure the frame timer related parameters */
X    TIMER_OPTION                    = ((uint32_t)((uint32_t)0x01U<<(12))),                                       
N    INTERFRAMEGAP_OPTION            = BIT(13),                                      /*!< configure the inter frame gap related parameters */
X    INTERFRAMEGAP_OPTION            = ((uint32_t)((uint32_t)0x01U<<(13))),                                       
N}enet_option_enum;
N
N/* phy mode and mac loopback configurations */
Ntypedef enum
N{
N    ENET_AUTO_NEGOTIATION           = 0x01u,                                        /*!< PHY auto negotiation */
N    ENET_100M_FULLDUPLEX            = (ENET_MAC_CFG_SPD | ENET_MAC_CFG_DPM),        /*!< 100Mbit/s, full-duplex */
X    ENET_100M_FULLDUPLEX            = (((uint32_t)((uint32_t)0x01U<<(14))) | ((uint32_t)((uint32_t)0x01U<<(11)))),         
N    ENET_100M_HALFDUPLEX            = ENET_MAC_CFG_SPD ,                            /*!< 100Mbit/s, half-duplex */
X    ENET_100M_HALFDUPLEX            = ((uint32_t)((uint32_t)0x01U<<(14))) ,                             
N    ENET_10M_FULLDUPLEX             = ENET_MAC_CFG_DPM,                             /*!< 10Mbit/s, full-duplex */
X    ENET_10M_FULLDUPLEX             = ((uint32_t)((uint32_t)0x01U<<(11))),                              
N    ENET_10M_HALFDUPLEX             = (uint32_t)0x00000000U,                        /*!< 10Mbit/s, half-duplex */
N    ENET_LOOPBACKMODE               = (ENET_MAC_CFG_LBM | ENET_MAC_CFG_DPM)         /*!< MAC in loopback mode at the MII */
X    ENET_LOOPBACKMODE               = (((uint32_t)((uint32_t)0x01U<<(12))) | ((uint32_t)((uint32_t)0x01U<<(11))))          
N}enet_mediamode_enum;
N
N/* IP frame checksum function */
Ntypedef enum
N{
N    ENET_NO_AUTOCHECKSUM                = (uint32_t)0x00000000U,                    /*!< disable IP frame checksum function */
N    ENET_AUTOCHECKSUM_DROP_FAILFRAMES   = ENET_MAC_CFG_IPFCO,                       /*!< enable IP frame checksum function */
X    ENET_AUTOCHECKSUM_DROP_FAILFRAMES   = ((uint32_t)((uint32_t)0x01U<<(10))),                        
N    ENET_AUTOCHECKSUM_ACCEPT_FAILFRAMES = (ENET_MAC_CFG_IPFCO|ENET_DMA_CTL_DTCERFD) /*!< enable IP frame checksum function, and the received frame
X    ENET_AUTOCHECKSUM_ACCEPT_FAILFRAMES = (((uint32_t)((uint32_t)0x01U<<(10)))|((uint32_t)((uint32_t)0x01U<<(26)))) 
N                                                                                         with only payload error but no other errors will not be dropped */
N}enet_chksumconf_enum;
N
N/* received frame filter function */
Ntypedef enum
N{
N    ENET_PROMISCUOUS_MODE           = ENET_MAC_FRMF_PM,                             /*!< promiscuous mode enabled */
X    ENET_PROMISCUOUS_MODE           = ((uint32_t)((uint32_t)0x01U<<(0))),                              
N    ENET_RECEIVEALL                 = (int32_t)ENET_MAC_FRMF_FAR,                   /*!< all received frame are forwarded to application */
X    ENET_RECEIVEALL                 = (int32_t)((uint32_t)((uint32_t)0x01U<<(31))),                    
N    ENET_BROADCAST_FRAMES_PASS      = (uint32_t)0x00000000U,                        /*!< the address filters pass all received broadcast frames */
N    ENET_BROADCAST_FRAMES_DROP      = ENET_MAC_FRMF_BFRMD                           /*!< the address filters filter all incoming broadcast frames */
X    ENET_BROADCAST_FRAMES_DROP      = ((uint32_t)((uint32_t)0x01U<<(5)))                            
N}enet_frmrecept_enum;
N
N/* register group value get */
Ntypedef enum
N{
N    ALL_MAC_REG                     = 0,                                            /*!< MAC register group */
N    ALL_MSC_REG                     = 22,                                           /*!< MSC register group */
N    ALL_PTP_REG                     = 33,                                           /*!< PTP register group */
N    ALL_DMA_REG                     = 44,                                           /*!< DMA register group */
N}enet_registers_type_enum;
N
N/* dma direction select */
Ntypedef enum
N{
N    ENET_DMA_TX                     = ENET_DMA_STAT_TP,                             /*!< DMA transmit direction */
X    ENET_DMA_TX                     = ((0xFFFFFFFFUL << (20)) & (0xFFFFFFFFUL >> (31U - (uint32_t)(22)))),                              
N    ENET_DMA_RX                     = ENET_DMA_STAT_RP                              /*!< DMA receive direction */
X    ENET_DMA_RX                     = ((0xFFFFFFFFUL << (17)) & (0xFFFFFFFFUL >> (31U - (uint32_t)(19))))                               
N}enet_dmadirection_enum;
N
N/* PHY operation direction select */
Ntypedef enum
N{
N    ENET_PHY_READ                   = (uint32_t)0x00000000,                         /*!< read PHY */
N    ENET_PHY_WRITE                  = ENET_MAC_PHY_CTL_PW                           /*!< write PHY */
X    ENET_PHY_WRITE                  = ((uint32_t)((uint32_t)0x01U<<(1)))                            
N}enet_phydirection_enum;
N
N/* register operation direction select */
Ntypedef enum
N{
N    ENET_REG_READ,                                                                  /*!< read register */
N    ENET_REG_WRITE                                                                  /*!< write register */
N}enet_regdirection_enum;
N
N/* ENET MAC addresses */ 
Ntypedef enum
N{
N    ENET_MAC_ADDRESS0               = ((uint32_t)0x00000000),                       /*!< MAC address0 */
N    ENET_MAC_ADDRESS1               = ((uint32_t)0x00000008),                       /*!< MAC address1 */
N    ENET_MAC_ADDRESS2               = ((uint32_t)0x00000010),                       /*!< MAC address2 */
N    ENET_MAC_ADDRESS3               = ((uint32_t)0x00000018)                        /*!< MAC address3 */
N}enet_macaddress_enum;
N
N/* descriptor information */
Ntypedef enum
N{
N    TXDESC_COLLISION_COUNT,                                                         /*!< the number of collisions occurred before the frame was transmitted */
N    TXDESC_BUFFER_1_ADDR,                                                           /*!< transmit frame buffer 1 address */
N    RXDESC_FRAME_LENGTH,                                                            /*!< the byte length of the received frame that was transferred to the buffer */
N    RXDESC_BUFFER_1_SIZE,                                                           /*!< receive buffer 1 size */
N    RXDESC_BUFFER_2_SIZE,                                                           /*!< receive buffer 2 size */
N    RXDESC_BUFFER_1_ADDR                                                            /*!< receive frame buffer 1 address */
N}enet_descstate_enum;
N
N/* structure for initialization of the ENET  */
Ntypedef struct
N{
N    uint32_t option_enable;                                                         /*!< select which function to configure */
N    uint32_t forward_frame;                                                         /*!< frame forward related parameters */ 
N    uint32_t dmabus_mode;                                                           /*!< DMA bus mode related parameters */
N    uint32_t dma_maxburst;                                                          /*!< DMA max burst related parameters */
N    uint32_t dma_arbitration;                                                       /*!< DMA Tx and Rx arbitration related parameters */
N    uint32_t store_forward_mode;                                                    /*!< store forward mode related parameters */
N    uint32_t dma_function;                                                          /*!< DMA control related parameters */
N    uint32_t vlan_config;                                                           /*!< VLAN tag related parameters */   
N    uint32_t flow_control;                                                          /*!< flow control related parameters */
N    uint32_t hashtable_high;                                                        /*!< hash list high 32-bit related parameters */
N    uint32_t hashtable_low;                                                         /*!< hash list low 32-bit related parameters */
N    uint32_t framesfilter_mode;                                                     /*!< frame filter control related parameters */
N    uint32_t halfduplex_param;                                                      /*!< halfduplex related parameters */            
N    uint32_t timer_config;                                                          /*!< frame timer related parameters */
N    uint32_t interframegap;                                                         /*!< inter frame gap related parameters */
N}enet_initpara_struct;
N
N/* structure for ENET DMA desciptors */ 
Ntypedef struct  
N{
N    uint32_t status;                                                                /*!< status */
N    uint32_t control_buffer_size;                                                   /*!< control and buffer1, buffer2 lengths */
N    uint32_t buffer1_addr;                                                          /*!< buffer1 address pointer/timestamp low */
N    uint32_t buffer2_next_desc_addr;                                                /*!< buffer2 or next descriptor address pointer/timestamp high */
N} enet_descriptors_struct;
N
N/* structure of PTP system time */ 
Ntypedef struct
N{
N    uint32_t second;                                                                /*!< second of system time */
N    uint32_t nanosecond;                                                            /*!< nanosecond of system time */
N    uint32_t sign;                                                                  /*!< sign of system time */
N}enet_ptp_systime_struct;
N
N/* mac_cfg register value */
N#define MAC_CFG_BOL(regval)                       (BITS(5,6) & ((uint32_t)(regval) << 5))       /*!< write value to ENET_MAC_CFG_BOL bit field */
N#define ENET_BACKOFFLIMIT_10                      MAC_CFG_BOL(0)                                /*!< min (n, 10) */
N#define ENET_BACKOFFLIMIT_8                       MAC_CFG_BOL(1)                                /*!< min (n, 8) */
N#define ENET_BACKOFFLIMIT_4                       MAC_CFG_BOL(2)                                /*!< min (n, 4) */
N#define ENET_BACKOFFLIMIT_1                       MAC_CFG_BOL(3)                                /*!< min (n, 1) */ 
N
N#define MAC_CFG_IGBS(regval)                      (BITS(17,19) & ((uint32_t)(regval) << 17))    /*!< write value to ENET_MAC_CFG_IGBS bit field */
N#define ENET_INTERFRAMEGAP_96BIT                  MAC_CFG_IGBS(0)                               /*!< minimum 96 bit times */ 
N#define ENET_INTERFRAMEGAP_88BIT                  MAC_CFG_IGBS(1)                               /*!< minimum 88 bit times */
N#define ENET_INTERFRAMEGAP_80BIT                  MAC_CFG_IGBS(2)                               /*!< minimum 80 bit times */
N#define ENET_INTERFRAMEGAP_72BIT                  MAC_CFG_IGBS(3)                               /*!< minimum 72 bit times */
N#define ENET_INTERFRAMEGAP_64BIT                  MAC_CFG_IGBS(4)                               /*!< minimum 64 bit times */        
N#define ENET_INTERFRAMEGAP_56BIT                  MAC_CFG_IGBS(5)                               /*!< minimum 56 bit times */
N#define ENET_INTERFRAMEGAP_48BIT                  MAC_CFG_IGBS(6)                               /*!< minimum 48 bit times */
N#define ENET_INTERFRAMEGAP_40BIT                  MAC_CFG_IGBS(7)                               /*!< minimum 40 bit times */  
N
N#define ENET_WATCHDOG_ENABLE                      ((uint32_t)0x00000000U)                       /*!< the MAC allows no more than 2048 bytes of the frame being received */
N#define ENET_WATCHDOG_DISABLE                     ENET_MAC_CFG_WDD                              /*!< the MAC disables the watchdog timer on the receiver, and can receive frames of up to 16384 bytes */
N 
N#define ENET_JABBER_ENABLE                        ((uint32_t)0x00000000U)                       /*!< the maximum transmission byte is 2048 */
N#define ENET_JABBER_DISABLE                       ENET_MAC_CFG_JBD                              /*!< the maximum transmission byte can be 16384 */
N
N#define ENET_CARRIERSENSE_ENABLE                  ((uint32_t)0x00000000U)                       /*!< the MAC transmitter generates carrier sense error and aborts the transmission */
N#define ENET_CARRIERSENSE_DISABLE                 ENET_MAC_CFG_CSD                              /*!< the MAC transmitter ignores the MII CRS signal during frame transmission in half-duplex mode */
N 
N#define ENET_SPEEDMODE_10M                        ((uint32_t)0x00000000U)                       /*!< 10 Mbit/s */
N#define ENET_SPEEDMODE_100M                       ENET_MAC_CFG_SPD                              /*!< 100 Mbit/s */
N
N#define ENET_RECEIVEOWN_ENABLE                    ((uint32_t)0x00000000U)                       /*!< the MAC receives all packets that are given by the PHY while transmitting */
N#define ENET_RECEIVEOWN_DISABLE                   ENET_MAC_CFG_ROD                              /*!< the MAC disables the reception of frames in half-duplex mode */
N
N#define ENET_LOOPBACKMODE_ENABLE                  ENET_MAC_CFG_LBM                              /*!< the MAC operates in loopback mode at the MII */
N#define ENET_LOOPBACKMODE_DISABLE                 ((uint32_t)0x00000000U)                       /*!< the MAC operates in normal mode */
N
N#define ENET_MODE_FULLDUPLEX                      ENET_MAC_CFG_DPM                              /*!< full-duplex mode enable */
N#define ENET_MODE_HALFDUPLEX                      ((uint32_t)0x00000000U)                       /*!< half-duplex mode enable */
N
N#define ENET_CHECKSUMOFFLOAD_ENABLE               ENET_MAC_CFG_IPFCO                            /*!< IP frame checksum offload function enabled for received IP frame */
N#define ENET_CHECKSUMOFFLOAD_DISABLE              ((uint32_t)0x00000000U)                       /*!< the checksum offload function in the receiver is disabled */
N
N#define ENET_RETRYTRANSMISSION_ENABLE             ((uint32_t)0x00000000U)                       /*!< the MAC attempts retries up to 16 times based on the settings of BOL*/
N#define ENET_RETRYTRANSMISSION_DISABLE            ENET_MAC_CFG_RTD                              /*!< the MAC attempts only 1 transmission */
N
N#define ENET_AUTO_PADCRC_DROP_ENABLE              ENET_MAC_CFG_APCD                             /*!< the MAC strips the Pad/FCS field on received frames */
N#define ENET_AUTO_PADCRC_DROP_DISABLE             ((uint32_t)0x00000000U)                       /*!< the MAC forwards all received frames without modify it */
N#define ENET_AUTO_PADCRC_DROP                     ENET_MAC_CFG_APCD                             /*!< the function of the MAC strips the Pad/FCS field on received frames */
N
N#define ENET_DEFERRALCHECK_ENABLE                 ENET_MAC_CFG_DFC                              /*!< the deferral check function is enabled in the MAC */
N#define ENET_DEFERRALCHECK_DISABLE                ((uint32_t)0x00000000U)                       /*!< the deferral check function is disabled */
N
N/* mac_frmf register value */
N#define MAC_FRMF_PCFRM(regval)                    (BITS(6,7) & ((uint32_t)(regval) << 6))       /*!< write value to ENET_MAC_FRMF_PCFRM bit field */
N#define ENET_PCFRM_PREVENT_ALL                    MAC_FRMF_PCFRM(0)                             /*!< MAC prevents all control frames from reaching the application */
N#define ENET_PCFRM_PREVENT_PAUSEFRAME             MAC_FRMF_PCFRM(1)                             /*!< MAC only forwards all other control frames except pause control frame */
N#define ENET_PCFRM_FORWARD_ALL                    MAC_FRMF_PCFRM(2)                             /*!< MAC forwards all control frames to application even if they fail the address filter */
N#define ENET_PCFRM_FORWARD_FILTERED               MAC_FRMF_PCFRM(3)                             /*!< MAC forwards control frames that only pass the address filter */
N 
N#define ENET_RX_FILTER_DISABLE                    ENET_MAC_FRMF_FAR                             /*!< all received frame are forwarded to application */
N#define ENET_RX_FILTER_ENABLE                     ((uint32_t)0x00000000U)                       /*!< only the frame passed the filter can be forwarded to application */
N 
N#define ENET_SRC_FILTER_NORMAL_ENABLE             ENET_MAC_FRMF_SAFLT                           /*!< filter source address */
N#define ENET_SRC_FILTER_INVERSE_ENABLE            (ENET_MAC_FRMF_SAFLT | ENET_MAC_FRMF_SAIFLT)  /*!< inverse source address filtering result */
N#define ENET_SRC_FILTER_DISABLE                   ((uint32_t)0x00000000U)                       /*!< source address function in filter disable */
N#define ENET_SRC_FILTER                           ENET_MAC_FRMF_SAFLT                           /*!< filter source address function */
N#define ENET_SRC_FILTER_INVERSE                   ENET_MAC_FRMF_SAIFLT                          /*!< inverse source address filtering result function */
N
N#define ENET_BROADCASTFRAMES_ENABLE               ((uint32_t)0x00000000U)                       /*!< the address filters pass all received broadcast frames */
N#define ENET_BROADCASTFRAMES_DISABLE              ENET_MAC_FRMF_BFRMD                           /*!< the address filters filter all incoming broadcast frames */
N 
N#define ENET_DEST_FILTER_INVERSE_ENABLE           ENET_MAC_FRMF_DAIFLT                          /*!< inverse DA filtering result */
N#define ENET_DEST_FILTER_INVERSE_DISABLE          ((uint32_t)0x00000000U)                       /*!< not inverse DA filtering result */
N#define ENET_DEST_FILTER_INVERSE                  ENET_MAC_FRMF_DAIFLT                          /*!< inverse DA filtering result function */
N
N#define ENET_PROMISCUOUS_ENABLE                   ENET_MAC_FRMF_PM                              /*!< promiscuous mode enabled */
N#define ENET_PROMISCUOUS_DISABLE                  ((uint32_t)0x00000000U)                       /*!< promiscuous mode disabled */
N          
N#define ENET_MULTICAST_FILTER_HASH_OR_PERFECT     (ENET_MAC_FRMF_HMF | ENET_MAC_FRMF_HPFLT)     /*!< pass multicast frames that match either the perfect or the hash filtering */
N#define ENET_MULTICAST_FILTER_HASH                ENET_MAC_FRMF_HMF                             /*!< pass multicast frames that match the hash filtering */
N#define ENET_MULTICAST_FILTER_PERFECT             ((uint32_t)0x00000000U)                       /*!< pass multicast frames that match the perfect filtering */
N#define ENET_MULTICAST_FILTER_NONE                ENET_MAC_FRMF_MFD                             /*!< all multicast frames are passed */
N#define ENET_MULTICAST_FILTER_PASS                ENET_MAC_FRMF_MFD                             /*!< pass all multicast frames function */
N#define ENET_MULTICAST_FILTER_HASH_MODE           ENET_MAC_FRMF_HMF                             /*!< HASH multicast filter function */
N#define ENET_FILTER_MODE_EITHER                   ENET_MAC_FRMF_HPFLT                           /*!< HASH or perfect filter function */
N
N#define ENET_UNICAST_FILTER_EITHER                (ENET_MAC_FRMF_HUF | ENET_MAC_FRMF_HPFLT)     /*!< pass unicast frames that match either the perfect or the hash filtering */
N#define ENET_UNICAST_FILTER_HASH                  ENET_MAC_FRMF_HUF                             /*!< pass unicast frames that match the hash filtering */
N#define ENET_UNICAST_FILTER_PERFECT               ((uint32_t)0x00000000U)                       /*!< pass unicast frames that match the perfect filtering */
N#define ENET_UNICAST_FILTER_HASH_MODE             ENET_MAC_FRMF_HUF                             /*!< HASH unicast filter function */
N
N/* mac_phy_ctl register value */
N#define MAC_PHY_CTL_CLR(regval)                   (BITS(2,4) & ((uint32_t)(regval) << 2))       /*!< write value to ENET_MAC_PHY_CTL_CLR bit field */
N#define ENET_MDC_HCLK_DIV42                       MAC_PHY_CTL_CLR(0)                            /*!< HCLK:60-100 MHz; MDC clock= HCLK/42 */
N#define ENET_MDC_HCLK_DIV62                       MAC_PHY_CTL_CLR(1)                            /*!< HCLK:100-120 MHz; MDC clock= HCLK/62 */
N#define ENET_MDC_HCLK_DIV16                       MAC_PHY_CTL_CLR(2)                            /*!< HCLK:20-35 MHz; MDC clock= HCLK/16 */
N#define ENET_MDC_HCLK_DIV26                       MAC_PHY_CTL_CLR(3)                            /*!< HCLK:35-60 MHz; MDC clock= HCLK/26 */
N
N#define MAC_PHY_CTL_PR(regval)                    (BITS(6,10) & ((uint32_t)(regval) << 6))      /*!< write value to ENET_MAC_PHY_CTL_PR bit field */
N
N#define MAC_PHY_CTL_PA(regval)                    (BITS(11,15) & ((uint32_t)(regval) << 11))    /*!< write value to ENET_MAC_PHY_CTL_PA bit field */
N
N/* mac_phy_data register value */
N#define MAC_PHY_DATA_PD(regval)                   (BITS(0,15) & ((uint32_t)(regval) << 0))      /*!< write value to ENET_MAC_PHY_DATA_PD bit field */
N
N/* mac_fctl register value */
N#define MAC_FCTL_PLTS(regval)                     (BITS(4,5) & ((uint32_t)(regval) << 4))       /*!< write value to ENET_MAC_FCTL_PLTS bit field */
N#define ENET_PAUSETIME_MINUS4                     MAC_FCTL_PLTS(0)                              /*!< pause time minus 4 slot times */
N#define ENET_PAUSETIME_MINUS28                    MAC_FCTL_PLTS(1)                              /*!< pause time minus 28 slot times */
N#define ENET_PAUSETIME_MINUS144                   MAC_FCTL_PLTS(2)                              /*!< pause time minus 144 slot times */
N#define ENET_PAUSETIME_MINUS256                   MAC_FCTL_PLTS(3)                              /*!< pause time minus 256 slot times */ 
N
N#define ENET_ZERO_QUANTA_PAUSE_ENABLE             ((uint32_t)0x00000000U)                       /*!< enable the automatic zero-quanta generation function */
N#define ENET_ZERO_QUANTA_PAUSE_DISABLE            ENET_MAC_FCTL_DZQP                            /*!< disable the automatic zero-quanta generation function */
N#define ENET_ZERO_QUANTA_PAUSE                    ENET_MAC_FCTL_DZQP                            /*!< the automatic zero-quanta generation function */
N
N#define ENET_MAC0_AND_UNIQUE_ADDRESS_PAUSEDETECT  ENET_MAC_FCTL_UPFDT                           /*!< besides the unique multicast address, MAC also use the MAC0 address to detect pause frame */
N#define ENET_UNIQUE_PAUSEDETECT                   ((uint32_t)0x00000000U)                       /*!< only the unique multicast address for pause frame which is specified in IEEE802.3 can be detected */
N 
N#define ENET_RX_FLOWCONTROL_ENABLE                ENET_MAC_FCTL_RFCEN                           /*!< enable decoding function for the received pause frame and process it */
N#define ENET_RX_FLOWCONTROL_DISABLE               ((uint32_t)0x00000000U)                       /*!< decode function for pause frame is disabled */
N#define ENET_RX_FLOWCONTROL                       ENET_MAC_FCTL_RFCEN                           /*!< decoding function for the received pause frame and process it */
N
N#define ENET_TX_FLOWCONTROL_ENABLE                ENET_MAC_FCTL_TFCEN                           /*!< enable the flow control operation in the MAC */
N#define ENET_TX_FLOWCONTROL_DISABLE               ((uint32_t)0x00000000U)                       /*!< disable the flow control operation in the MAC */
N#define ENET_TX_FLOWCONTROL                       ENET_MAC_FCTL_TFCEN                           /*!< the flow control operation in the MAC */
N
N#define ENET_BACK_PRESSURE_ENABLE                 ENET_MAC_FCTL_FLCBBKPA                        /*!< enable the back pressure operation in the MAC */
N#define ENET_BACK_PRESSURE_DISABLE                ((uint32_t)0x00000000U)                       /*!< disable the back pressure operation in the MAC */
N#define ENET_BACK_PRESSURE                        ENET_MAC_FCTL_FLCBBKPA                        /*!< the back pressure operation in the MAC */
N                                                                                      
N#define MAC_FCTL_PTM(regval)                      (BITS(16,31) & ((uint32_t)(regval) << 16))    /*!< write value to ENET_MAC_FCTL_PTM bit field */
N/* mac_vlt register value */
N#define MAC_VLT_VLTI(regval)                      (BITS(0,15) & ((uint32_t)(regval) << 0))      /*!< write value to ENET_MAC_VLT_VLTI bit field */
N 
N#define ENET_VLANTAGCOMPARISON_12BIT              ENET_MAC_VLT_VLTC                             /*!< only low 12 bits of the VLAN tag are used for comparison */
N#define ENET_VLANTAGCOMPARISON_16BIT              ((uint32_t)0x00000000U)                       /*!< all 16 bits of the VLAN tag are used for comparison */
N
N/* mac_wum register value */ 
N#define ENET_WUM_FLAG_WUFFRPR                     ENET_MAC_WUM_WUFFRPR                          /*!< wakeup frame filter register poniter reset */
N#define ENET_WUM_FLAG_WUFR                        ENET_MAC_WUM_WUFR                             /*!< wakeup frame received */
N#define ENET_WUM_FLAG_MPKR                        ENET_MAC_WUM_MPKR                             /*!< magic packet received */
N#define ENET_WUM_POWER_DOWN                       ENET_MAC_WUM_PWD                              /*!< power down mode */    
N#define ENET_WUM_MAGIC_PACKET_FRAME               ENET_MAC_WUM_MPEN                             /*!< enable a wakeup event due to magic packet reception */   
N#define ENET_WUM_WAKE_UP_FRAME                    ENET_MAC_WUM_WFEN                             /*!< enable a wakeup event due to wakeup frame reception */     
N#define ENET_WUM_GLOBAL_UNICAST                   ENET_MAC_WUM_GU                               /*!< any received unicast frame passed filter is considered to be a wakeup frame */
N
N/* mac_addr0h register value */
N#define MAC_ADDR0H_ADDR0H(regval)                 (BITS(0,15) & ((uint32_t)(regval) << 0))      /*!< write value to ENET_MAC_ADDR0H_ADDR0H bit field */
N
N/* mac_addrxh register value, x = 1,2,3 */
N#define MAC_ADDR123H_ADDR123H(regval)             (BITS(0,15) & ((uint32_t)(regval) << 0))      /*!< write value to ENET_MAC_ADDRxH_ADDRxH(x=1,2,3) bit field */
N
N#define ENET_ADDRESS_MASK_BYTE0                   BIT(24)                                       /*!< low register bits [7:0] */
N#define ENET_ADDRESS_MASK_BYTE1                   BIT(25)                                       /*!< low register bits [15:8] */
N#define ENET_ADDRESS_MASK_BYTE2                   BIT(26)                                       /*!< low register bits [23:16] */
N#define ENET_ADDRESS_MASK_BYTE3                   BIT(27)                                       /*!< low register bits [31:24] */
N#define ENET_ADDRESS_MASK_BYTE4                   BIT(28)                                       /*!< high register bits [7:0] */
N#define ENET_ADDRESS_MASK_BYTE5                   BIT(29)                                       /*!< high register bits [15:8] */
N
N#define ENET_ADDRESS_FILTER_SA                    BIT(30)                                       /*!< use MAC address[47:0] is to compare with the SA fields of the received frame */
N#define ENET_ADDRESS_FILTER_DA                    ((uint32_t)0x00000000)                        /*!< use MAC address[47:0] is to compare with the DA fields of the received frame */
N 
N/* mac_fcth register value */
N#define MAC_FCTH_RFA(regval)                      ((BITS(0,2) & ((uint32_t)(regval) << 0))<<8)  /*!< write value to ENET_MAC_FCTH_RFA bit field */
N#define ENET_ACTIVE_THRESHOLD_256BYTES            MAC_FCTH_RFA(0)                               /*!< threshold level is 256 bytes */
N#define ENET_ACTIVE_THRESHOLD_512BYTES            MAC_FCTH_RFA(1)                               /*!< threshold level is 512 bytes */
N#define ENET_ACTIVE_THRESHOLD_768BYTES            MAC_FCTH_RFA(2)                               /*!< threshold level is 768 bytes */
N#define ENET_ACTIVE_THRESHOLD_1024BYTES           MAC_FCTH_RFA(3)                               /*!< threshold level is 1024 bytes */
N#define ENET_ACTIVE_THRESHOLD_1280BYTES           MAC_FCTH_RFA(4)                               /*!< threshold level is 1280 bytes */
N#define ENET_ACTIVE_THRESHOLD_1536BYTES           MAC_FCTH_RFA(5)                               /*!< threshold level is 1536 bytes */
N#define ENET_ACTIVE_THRESHOLD_1792BYTES           MAC_FCTH_RFA(6)                               /*!< threshold level is 1792 bytes */
N
N#define MAC_FCTH_RFD(regval)                      ((BITS(4,6) & ((uint32_t)(regval) << 4))<<8)  /*!< write value to ENET_MAC_FCTH_RFD bit field */
N#define ENET_DEACTIVE_THRESHOLD_256BYTES          MAC_FCTH_RFD(0)                               /*!< threshold level is 256 bytes */
N#define ENET_DEACTIVE_THRESHOLD_512BYTES          MAC_FCTH_RFD(1)                               /*!< threshold level is 512 bytes */
N#define ENET_DEACTIVE_THRESHOLD_768BYTES          MAC_FCTH_RFD(2)                               /*!< threshold level is 768 bytes */
N#define ENET_DEACTIVE_THRESHOLD_1024BYTES         MAC_FCTH_RFD(3)                               /*!< threshold level is 1024 bytes */
N#define ENET_DEACTIVE_THRESHOLD_1280BYTES         MAC_FCTH_RFD(4)                               /*!< threshold level is 1280 bytes */
N#define ENET_DEACTIVE_THRESHOLD_1536BYTES         MAC_FCTH_RFD(5)                               /*!< threshold level is 1536 bytes */
N#define ENET_DEACTIVE_THRESHOLD_1792BYTES         MAC_FCTH_RFD(6)                               /*!< threshold level is 1792 bytes */
N
N/* msc_ctl register value */
N#define ENET_MSC_COUNTER_STOP_ROLLOVER            ENET_MSC_CTL_CTSR                             /*!< counter stop rollover */
N#define ENET_MSC_RESET_ON_READ                    ENET_MSC_CTL_RTOR                             /*!< reset on read */
N#define ENET_MSC_COUNTERS_FREEZE                  ENET_MSC_CTL_MCFZ                             /*!< MSC counter freeze */
N
N/* ptp_tsctl register value */
N#define ENET_RXTX_TIMESTAMP                       ENET_PTP_TSCTL_TMSEN                          /*!< enable timestamp function for transmit and receive frames */
N#define ENET_PTP_TIMESTAMP_INT                    ENET_PTP_TSCTL_TMSITEN                        /*!< timestamp interrupt trigger enable */
N
N/* ptp_ssinc register value */
N#define PTP_SSINC_STMSSI(regval)                  (BITS(0,7) & ((uint32_t)(regval) << 0))       /*!< write value to ENET_PTP_SSINC_STMSSI bit field */
N
N/* ptp_tsl register value */
N#define GET_PTP_TSL_STMSS(regval)                 GET_BITS((uint32_t)(regval),0,30)             /*!< get value of ENET_PTP_TSL_STMSS bit field */
N 
N#define ENET_PTP_TIME_POSITIVE                    ((uint32_t)0x00000000)                        /*!< time value is positive */
N#define ENET_PTP_TIME_NEGATIVE                    ENET_PTP_TSL_STS                              /*!< time value is negative */
N
N#define GET_PTP_TSL_STS(regval)                   (((regval) & BIT(31)) >> (31U))               /*!< get value of ENET_PTP_TSL_STS bit field */
N
N/* ptp_tsul register value */
N#define PTP_TSUL_TMSUSS(regval)                   (BITS(0,30) & ((uint32_t)(regval) << 0))      /*!< write value to ENET_PTP_TSUL_TMSUSS bit field */
N
N#define ENET_PTP_ADD_TO_TIME                      ((uint32_t)0x00000000)                        /*!< timestamp update value is added to system time */
N#define ENET_PTP_SUBSTRACT_FROM_TIME              ENET_PTP_TSUL_TMSUPNS                         /*!< timestamp update value is subtracted from system time */
N
N/* dma_bctl register value */
N#define DMA_BCTL_DPSL(regval)                     (BITS(2,6) & ((uint32_t)(regval) << 2))       /*!< write value to ENET_DMA_BCTL_DPSL bit field */
N#define GET_DMA_BCTL_DPSL(regval)                 GET_BITS((regval),2,6)                        /*!< get value of ENET_DMA_BCTL_DPSL bit field */
N
N#define DMA_BCTL_PGBL(regval)                     (BITS(8,13) & ((uint32_t)(regval) << 8))      /*!< write value to ENET_DMA_BCTL_PGBL bit field */
N#define ENET_PGBL_1BEAT                           DMA_BCTL_PGBL(1)                              /*!< maximum number of beats is 1 */
N#define ENET_PGBL_2BEAT                           DMA_BCTL_PGBL(2)                              /*!< maximum number of beats is 2 */
N#define ENET_PGBL_4BEAT                           DMA_BCTL_PGBL(4)                              /*!< maximum number of beats is 4 */
N#define ENET_PGBL_8BEAT                           DMA_BCTL_PGBL(8)                              /*!< maximum number of beats is 8 */
N#define ENET_PGBL_16BEAT                          DMA_BCTL_PGBL(16)                             /*!< maximum number of beats is 16 */
N#define ENET_PGBL_32BEAT                          DMA_BCTL_PGBL(32)                             /*!< maximum number of beats is 32 */                
N#define ENET_PGBL_4xPGBL_4BEAT                    (DMA_BCTL_PGBL(1)|ENET_DMA_BCTL_FPBL)         /*!< maximum number of beats is 4 */
N#define ENET_PGBL_4xPGBL_8BEAT                    (DMA_BCTL_PGBL(2)|ENET_DMA_BCTL_FPBL)         /*!< maximum number of beats is 8 */
N#define ENET_PGBL_4xPGBL_16BEAT                   (DMA_BCTL_PGBL(4)|ENET_DMA_BCTL_FPBL)         /*!< maximum number of beats is 16 */
N#define ENET_PGBL_4xPGBL_32BEAT                   (DMA_BCTL_PGBL(8)|ENET_DMA_BCTL_FPBL)         /*!< maximum number of beats is 32 */
N#define ENET_PGBL_4xPGBL_64BEAT                   (DMA_BCTL_PGBL(16)|ENET_DMA_BCTL_FPBL)        /*!< maximum number of beats is 64 */
N#define ENET_PGBL_4xPGBL_128BEAT                  (DMA_BCTL_PGBL(32)|ENET_DMA_BCTL_FPBL)        /*!< maximum number of beats is 128 */
N
N#define DMA_BCTL_RTPR(regval)                     (BITS(14,15) & ((uint32_t)(regval) << 14))    /*!< write value to ENET_DMA_BCTL_RTPR bit field */
N#define ENET_ARBITRATION_RXTX_1_1                 DMA_BCTL_RTPR(0)                              /*!< receive and transmit priority ratio is 1:1*/
N#define ENET_ARBITRATION_RXTX_2_1                 DMA_BCTL_RTPR(1)                              /*!< receive and transmit priority ratio is 2:1*/
N#define ENET_ARBITRATION_RXTX_3_1                 DMA_BCTL_RTPR(2)                              /*!< receive and transmit priority ratio is 3:1 */
N#define ENET_ARBITRATION_RXTX_4_1                 DMA_BCTL_RTPR(3)                              /*!< receive and transmit priority ratio is 4:1 */  
N#define ENET_ARBITRATION_RXPRIORTX                ENET_DMA_BCTL_DAB                             /*!< RxDMA has higher priority than TxDMA */
N
N#define ENET_FIXED_BURST_ENABLE                   ENET_DMA_BCTL_FB                              /*!< AHB can only use SINGLE/INCR4/INCR8/INCR16 during start of normal burst transfers */
N#define ENET_FIXED_BURST_DISABLE                  ((uint32_t)0x00000000)                        /*!< AHB can use SINGLE/INCR burst transfer operations */
N
N#define DMA_BCTL_RXDP(regval)                     (BITS(17,22) & ((uint32_t)(regval) << 17))    /*!< write value to ENET_DMA_BCTL_RXDP bit field */
N#define ENET_RXDP_1BEAT                           DMA_BCTL_RXDP(1)                              /*!< maximum number of beats 1 */
N#define ENET_RXDP_2BEAT                           DMA_BCTL_RXDP(2)                              /*!< maximum number of beats 2 */
N#define ENET_RXDP_4BEAT                           DMA_BCTL_RXDP(4)                              /*!< maximum number of beats 4 */
N#define ENET_RXDP_8BEAT                           DMA_BCTL_RXDP(8)                              /*!< maximum number of beats 8 */
N#define ENET_RXDP_16BEAT                          DMA_BCTL_RXDP(16)                             /*!< maximum number of beats 16 */
N#define ENET_RXDP_32BEAT                          DMA_BCTL_RXDP(32)                             /*!< maximum number of beats 32 */                
N#define ENET_RXDP_4xPGBL_4BEAT                    (DMA_BCTL_RXDP(1)|ENET_DMA_BCTL_FPBL)         /*!< maximum number of beats 4 */
N#define ENET_RXDP_4xPGBL_8BEAT                    (DMA_BCTL_RXDP(2)|ENET_DMA_BCTL_FPBL)         /*!< maximum number of beats 8 */
N#define ENET_RXDP_4xPGBL_16BEAT                   (DMA_BCTL_RXDP(4)|ENET_DMA_BCTL_FPBL)         /*!< maximum number of beats 16 */
N#define ENET_RXDP_4xPGBL_32BEAT                   (DMA_BCTL_RXDP(8)|ENET_DMA_BCTL_FPBL)         /*!< maximum number of beats 32 */
N#define ENET_RXDP_4xPGBL_64BEAT                   (DMA_BCTL_RXDP(16)|ENET_DMA_BCTL_FPBL)        /*!< maximum number of beats 64 */
N#define ENET_RXDP_4xPGBL_128BEAT                  (DMA_BCTL_RXDP(32)|ENET_DMA_BCTL_FPBL)        /*!< maximum number of beats 128 */  
N
N#define ENET_RXTX_DIFFERENT_PGBL                  ENET_DMA_BCTL_UIP                             /*!< RxDMA uses the RXDP[5:0], while TxDMA uses the PGBL[5:0] */
N#define ENET_RXTX_SAME_PGBL                       ((uint32_t)0x00000000)                        /*!< RxDMA/TxDMA uses PGBL[5:0] */
N
N#define ENET_ADDRESS_ALIGN_ENABLE                 ENET_DMA_BCTL_AA                              /*!< enabled address-aligned */
N#define ENET_ADDRESS_ALIGN_DISABLE                ((uint32_t)0x00000000)                        /*!< disable address-aligned */
N
N/* dma_stat register value */
N#define GET_DMA_STAT_RP(regval)                   GET_BITS((uint32_t)(regval),17,19)            /*!< get value of ENET_DMA_STAT_RP bit field */
N#define ENET_RX_STATE_STOPPED                     ((uint32_t)0x00000000)                        /*!< reset or stop rx command issued */
N#define ENET_RX_STATE_FETCHING                    BIT(17)                                       /*!< fetching the Rx descriptor */
N#define ENET_RX_STATE_WAITING                     (BIT(17)|BIT(18))                             /*!< waiting for receive packet */
N#define ENET_RX_STATE_SUSPENDED                   BIT(19)                                       /*!< Rx descriptor unavailable */
N#define ENET_RX_STATE_CLOSING                     (BIT(17)|BIT(19))                             /*!< closing receive descriptor */
N#define ENET_RX_STATE_QUEUING                     ENET_DMA_STAT_RP                              /*!< transferring the receive packet data from recevie buffer to host memory */
N
N#define GET_DMA_STAT_TP(regval)                   GET_BITS((uint32_t)(regval),20,22)            /*!< get value of ENET_DMA_STAT_TP bit field */
N#define ENET_TX_STATE_STOPPED                     ((uint32_t)0x00000000)                        /*!< reset or stop Tx Command issued  */
N#define ENET_TX_STATE_FETCHING                    BIT(20)                                       /*!< fetching the Tx descriptor */
N#define ENET_TX_STATE_WAITING                     BIT(21)                                       /*!< waiting for status */
N#define ENET_TX_STATE_READING                     (BIT(20)|BIT(21))                             /*!< reading the data from host memory buffer and queuing it to transmit buffer */
N#define ENET_TX_STATE_SUSPENDED                   (BIT(21)|BIT(22))                             /*!< Tx descriptor unavailabe or transmit buffer underflow */
N#define ENET_TX_STATE_CLOSING                     ENET_DMA_STAT_TP                              /*!< closing Tx descriptor */
N
N#define GET_DMA_STAT_EB(regval)                   GET_BITS((uint32_t)(regval),23,25)            /*!< get value of ENET_DMA_STAT_EB bit field */
N#define ENET_ERROR_TXDATA_TRANSFER                BIT(23)                                       /*!< error during data transfer by TxDMA or RxDMA */
N#define ENET_ERROR_READ_TRANSFER                  BIT(24)                                       /*!< error during write transfer or read transfer */
N#define ENET_ERROR_DESC_ACCESS                    BIT(25)                                       /*!< error during descriptor or buffer access */
N
N/* dma_ctl register value */
N#define DMA_CTL_RTHC(regval)                      (BITS(3,4) & ((uint32_t)(regval) << 3))       /*!< write value to ENET_DMA_CTL_RTHC bit field */
N#define ENET_RX_THRESHOLD_64BYTES                 DMA_CTL_RTHC(0)                               /*!< threshold level is 64 Bytes */
N#define ENET_RX_THRESHOLD_32BYTES                 DMA_CTL_RTHC(1)                               /*!< threshold level is 32 Bytes */
N#define ENET_RX_THRESHOLD_96BYTES                 DMA_CTL_RTHC(2)                               /*!< threshold level is 96 Bytes */
N#define ENET_RX_THRESHOLD_128BYTES                DMA_CTL_RTHC(3)                               /*!< threshold level is 128 Bytes */
N
N#define DMA_CTL_TTHC(regval)                      (BITS(14,16) & ((uint32_t)(regval) << 14))    /*!< write value to ENET_DMA_CTL_TTHC bit field */
N#define ENET_TX_THRESHOLD_64BYTES                 DMA_CTL_TTHC(0)                               /*!< threshold level is 64 Bytes */
N#define ENET_TX_THRESHOLD_128BYTES                DMA_CTL_TTHC(1)                               /*!< threshold level is 128 Bytes */
N#define ENET_TX_THRESHOLD_192BYTES                DMA_CTL_TTHC(2)                               /*!< threshold level is 192 Bytes */
N#define ENET_TX_THRESHOLD_256BYTES                DMA_CTL_TTHC(3)                               /*!< threshold level is 256 Bytes */
N#define ENET_TX_THRESHOLD_40BYTES                 DMA_CTL_TTHC(4)                               /*!< threshold level is 40 Bytes */
N#define ENET_TX_THRESHOLD_32BYTES                 DMA_CTL_TTHC(5)                               /*!< threshold level is 32 Bytes */
N#define ENET_TX_THRESHOLD_24BYTES                 DMA_CTL_TTHC(6)                               /*!< threshold level is 24 Bytes */
N#define ENET_TX_THRESHOLD_16BYTES                 DMA_CTL_TTHC(7)                               /*!< threshold level is 16 Bytes */
N
N#define ENET_TCPIP_CKSUMERROR_ACCEPT              ENET_DMA_CTL_DTCERFD                          /*!< Rx frame with only payload error but no other errors will not be dropped */
N#define ENET_TCPIP_CKSUMERROR_DROP                ((uint32_t)0x00000000)                        /*!< all error frames will be dropped when FERF = 0 */
N
N#define ENET_RX_MODE_STOREFORWARD                 ENET_DMA_CTL_RSFD                             /*!< RxFIFO operates in store-and-forward mode */
N#define ENET_RX_MODE_CUTTHROUGH                   ((uint32_t)0x00000000)                        /*!< RxFIFO operates in cut-through mode */
N
N#define ENET_FLUSH_RXFRAME_ENABLE                 ((uint32_t)0x00000000)                        /*!< RxDMA flushes all frames */
N#define ENET_FLUSH_RXFRAME_DISABLE                ENET_DMA_CTL_DAFRF                            /*!< RxDMA does not flush any frames */
N#define ENET_NO_FLUSH_RXFRAME                     ENET_DMA_CTL_DAFRF                            /*!< RxDMA does not flush frames function */
N
N#define ENET_TX_MODE_STOREFORWARD                 ENET_DMA_CTL_TSFD                             /*!< TxFIFO operates in store-and-forward mode */
N#define ENET_TX_MODE_CUTTHROUGH                   ((uint32_t)0x00000000)                        /*!< TxFIFO operates in cut-through mode */
N
N#define ENET_FORWARD_ERRFRAMES_ENABLE             (ENET_DMA_CTL_FERF<<2)                        /*!< all frame received with error except runt error are forwarded to memory */
N#define ENET_FORWARD_ERRFRAMES_DISABLE            ((uint32_t)0x00000000)                        /*!< RxFIFO drop error frame */
N#define ENET_FORWARD_ERRFRAMES                    (ENET_DMA_CTL_FERF<<2)                             /*!< the function that all frame received with error except runt error are forwarded to memory */
N
N#define ENET_FORWARD_UNDERSZ_GOODFRAMES_ENABLE    (ENET_DMA_CTL_FUF<<2)                         /*!< forward undersized good frames */
N#define ENET_FORWARD_UNDERSZ_GOODFRAMES_DISABLE   ((uint32_t)0x00000000)                        /*!< RxFIFO drops all frames whose length is less than 64 bytes */  
N#define ENET_FORWARD_UNDERSZ_GOODFRAMES           (ENET_DMA_CTL_FUF<<2)                            /*!< the function that forwarding undersized good frames */
N
N#define ENET_SECONDFRAME_OPT_ENABLE               ((uint32_t)0x00000000)                              /*!< TxDMA controller operate on second frame mode enable*/
N#define ENET_SECONDFRAME_OPT_DISABLE              ((uint32_t)0x00000000)                        /*!< TxDMA controller operate on second frame mode disable */
N#define ENET_SECONDFRAME_OPT                      ENET_DMA_CTL_OSF                              /*!< TxDMA controller operate on second frame function */
N
N/* dma_mfbocnt register value */
N#define GET_DMA_MFBOCNT_MSFC(regval)              GET_BITS((regval),0,15)                       /*!< get value of ENET_DMA_MFBOCNT_MSFC bit field */
N
N#define GET_DMA_MFBOCNT_MSFA(regval)              GET_BITS((regval),17,27)                      /*!< get value of ENET_DMA_MFBOCNT_MSFA bit field */
N
N/* dma tx descriptor tdes0 register value */
N#define TDES0_CONT(regval)                        (BITS(3,6) & ((uint32_t)(regval) << 3))       /*!< write value to ENET DMA TDES0 CONT bit field */
N#define GET_TDES0_COCNT(regval)                   GET_BITS((regval),3,6)                        /*!< get value of ENET DMA TDES0 CONT bit field */
N
N#define TDES0_CM(regval)                          (BITS(22,23) & ((uint32_t)(regval) << 22))    /*!< write value to ENET DMA TDES0 CM bit field */
N#define ENET_CHECKSUM_DISABLE                     TDES0_CM(0)                                   /*!< checksum insertion disabled */ 
N#define ENET_CHECKSUM_IPV4HEADER                  TDES0_CM(1)                                   /*!< only IP header checksum calculation and insertion are enabled */ 
N#define ENET_CHECKSUM_TCPUDPICMP_SEGMENT          TDES0_CM(2)                                   /*!< TCP/UDP/ICMP checksum insertion calculated but pseudo-header  */ 
N#define ENET_CHECKSUM_TCPUDPICMP_FULL             TDES0_CM(3)                                   /*!< TCP/UDP/ICMP checksum insertion fully calculated */ 
N
N/* dma tx descriptor tdes1 register value */
N#define TDES1_TB1S(regval)                        (BITS(0,12) & ((uint32_t)(regval) << 0))      /*!< write value to ENET DMA TDES1 TB1S bit field */
N
N#define TDES1_TB2S(regval)                        (BITS(16,28) & ((uint32_t)(regval) << 16))    /*!< write value to ENET DMA TDES1 TB2S bit field */
N
N/* dma rx descriptor rdes0 register value */
N#define RDES0_FRML(regval)                        (BITS(16,29) & ((uint32_t)(regval) << 16))    /*!< write value to ENET DMA RDES0 FRML bit field */
N#define GET_RDES0_FRML(regval)                    GET_BITS((regval),16,29)                      /*!< get value of ENET DMA RDES0 FRML bit field */
N
N/* dma rx descriptor rdes1 register value */
N#define ENET_RECEIVE_COMPLETE_INT_ENABLE          ((uint32_t)0x00000000U)                       /*!< RS bit immediately set after Rx completed */
N#define ENET_RECEIVE_COMPLETE_INT_DISABLE         ENET_RDES1_DINTC                              /*!< RS bit not immediately set after Rx completed */
N
N#define GET_RDES1_RB1S(regval)                    GET_BITS((regval),0,12)                       /*!< get value of ENET DMA RDES1 RB1S bit field */
N
N#define GET_RDES1_RB2S(regval)                    GET_BITS((regval),16,28)                      /*!< get value of ENET DMA RDES1 RB2S bit field */
N
N/* dma rx descriptor rdes4 register value */
N#define RDES4_IPPLDT(regval)                      (BITS(0,2) & ((uint32_t)(regval) << 0))       /*!< write value to ENET DMA RDES4 IPPLDT bit field */
N#define GET_RDES4_IPPLDT(regval)                  GET_BITS((regval),0,2)                        /*!< get value of ENET DMA RDES4 IPPLDT bit field */
N
N#define RDES4_PTPMT(regval)                       (BITS(8,11) & ((uint32_t)(regval) << 8))      /*!< write value to ENET DMA RDES4 PTPMT bit field */
N#define GET_RDES4_PTPMT(regval)                   GET_BITS((regval),8,11)                       /*!< get value of ENET DMA RDES4 PTPMT bit field */
N
N/* ENET register mask value */
N#define MAC_CFG_MASK                              ((uint32_t)0xFD30810FU)                       /*!< ENET_MAC_CFG register mask */
N#define MAC_FCTL_MASK                             ((uint32_t)0x0000FF41U)                       /*!< ENET_MAC_FCTL register mask */
N#define DMA_CTL_MASK                              ((uint32_t)0xF8DE3F23U)                       /*!< ENET_DMA_CTL register mask */
N#define DMA_BCTL_MASK                             ((uint32_t)0xF800007DU)                       /*!< ENET_DMA_BCTL register mask */
N
N#define ETH_DMATXDESC_SIZE                        0x10U                                         /*!< TxDMA descriptor size */
N#define ETH_DMARXDESC_SIZE                        0x10U                                         /*!< RxDMA descriptor size */
N
Ntypedef enum{
N    ENET_PTP_SYSTIME_INIT             = ENET_PTP_TSCTL_TMSSTI,                                  /*!< timestamp initialize */
X    ENET_PTP_SYSTIME_INIT             = ((uint32_t)((uint32_t)0x01U<<(2))),                                   
N    ENET_PTP_SYSTIME_UPDATE           = ENET_PTP_TSCTL_TMSSTU,                                  /*!< timestamp update */ 
X    ENET_PTP_SYSTIME_UPDATE           = ((uint32_t)((uint32_t)0x01U<<(3))),                                    
N    ENET_PTP_ADDEND_UPDATE            = ENET_PTP_TSCTL_TMSARU,                                  /*!< addend register update */
X    ENET_PTP_ADDEND_UPDATE            = ((uint32_t)((uint32_t)0x01U<<(5))),                                   
N    ENET_PTP_FINEMODE                 = (int32_t)(ENET_PTP_TSCTL_TMSFCU| BIT(31)),              /*!< the system timestamp uses the fine method for updating */
X    ENET_PTP_FINEMODE                 = (int32_t)(((uint32_t)((uint32_t)0x01U<<(1)))| ((uint32_t)((uint32_t)0x01U<<(31)))),               
N    ENET_PTP_COARSEMODE               = ENET_PTP_TSCTL_TMSFCU,                                  /*!< the system timestamp uses the coarse method for updating */
X    ENET_PTP_COARSEMODE               = ((uint32_t)((uint32_t)0x01U<<(1))),                                   
N}enet_ptp_function_enum;
N
N
N/* ENET remote wake-up frame register length */
N#define ETH_WAKEUP_REGISTER_LENGTH                8U                                            /*!< remote wake-up frame register length */
N
N/* ENET frame size */ 
N#define ENET_MAX_FRAME_SIZE                       1524U                                         /*!< header + frame_extra + payload + CRC */    
N
N/* ENET delay timeout */
N#define ENET_DELAY_TO                             ((uint32_t)0x0004FFFFU)                       /*!< ENET delay timeout */
N#define ENET_RESET_TO                             ((uint32_t)0x000004FFU)                       /*!< ENET reset timeout */
N
N/* function declarations */
N/* main function */
N/* deinitialize the ENET, and reset structure parameters for ENET initialization */
Nvoid enet_deinit(void);
N/* configure the parameters which are usually less cared for initialization */
Nvoid enet_initpara_config(enet_option_enum option, uint32_t para);
N/* initialize ENET peripheral with generally concerned parameters and the less cared parameters */
NErrStatus enet_init(enet_mediamode_enum mediamode, enet_chksumconf_enum checksum, enet_frmrecept_enum recept);
N/* reset all core internal registers located in CLK_TX and CLK_RX */
NErrStatus enet_software_reset(void);
N/* check receive frame valid and return frame size */
Nuint32_t enet_rxframe_size_get(void);
N/* initialize the dma tx/rx descriptors's parameters in chain mode */
Nvoid enet_descriptors_chain_init(enet_dmadirection_enum direction);
N/* initialize the dma tx/rx descriptors's parameters in ring mode */
Nvoid enet_descriptors_ring_init(enet_dmadirection_enum direction);
N/* handle current received frame data to application buffer */
NErrStatus enet_frame_receive(uint8_t *buffer, uint32_t bufsize);
N/* handle current received frame but without data copy to application buffer */
N#define ENET_NOCOPY_FRAME_RECEIVE()         enet_frame_receive(NULL, 0U)
N/* handle application buffer data to transmit it */
NErrStatus enet_frame_transmit(uint8_t *buffer, uint32_t length);
N/* handle current transmit frame but without data copy from application buffer */
N#define ENET_NOCOPY_FRAME_TRANSMIT(len)     enet_frame_transmit(NULL, (len))
N/* configure the transmit IP frame checksum offload calculation and insertion */
Nvoid enet_transmit_checksum_config(enet_descriptors_struct *desc, uint32_t checksum);
N/* ENET Tx and Rx function enable (include MAC and DMA module) */
Nvoid enet_enable(void);   
N/* ENET Tx and Rx function disable (include MAC and DMA module) */
Nvoid enet_disable(void);
N/* configure MAC address */
Nvoid enet_mac_address_set(enet_macaddress_enum mac_addr, uint8_t paddr[]);
N/* get MAC address */   
Nvoid enet_mac_address_get(enet_macaddress_enum mac_addr, uint8_t paddr[]);
N
N/* get the ENET MAC/MSC/PTP/DMA status flag */
NFlagStatus enet_flag_get(enet_flag_enum enet_flag);
N/* clear the ENET DMA status flag */
Nvoid enet_flag_clear(enet_flag_clear_enum enet_flag);
N/* enable ENET MAC/MSC/DMA interrupt */
Nvoid enet_interrupt_enable(enet_int_enum enet_int);
N/* disable ENET MAC/MSC/DMA interrupt */
Nvoid enet_interrupt_disable(enet_int_enum enet_int);
N/* get ENET MAC/MSC/DMA interrupt flag */
NFlagStatus enet_interrupt_flag_get(enet_int_flag_enum int_flag);
N/* clear ENET DMA interrupt flag */
Nvoid enet_interrupt_flag_clear(enet_int_flag_clear_enum int_flag_clear);
N
N/* MAC function */
N/* ENET Tx function enable (include MAC and DMA module) */
Nvoid enet_tx_enable(void);
N/* ENET Tx function disable (include MAC and DMA module) */
Nvoid enet_tx_disable(void);
N/* ENET Rx function enable (include MAC and DMA module) */
Nvoid enet_rx_enable(void);
N/* ENET Rx function disable (include MAC and DMA module) */
Nvoid enet_rx_disable(void);
N/* put registers value into the application buffer */
Nvoid enet_registers_get(enet_registers_type_enum type, uint32_t *preg, uint32_t num);
N/* enable the MAC address filter */
Nvoid enet_address_filter_enable(enet_macaddress_enum mac_addr);
N/* disable the MAC address filter */
Nvoid enet_address_filter_disable(enet_macaddress_enum mac_addr);
N/* configure the MAC address filter */
Nvoid enet_address_filter_config(enet_macaddress_enum mac_addr, uint32_t addr_mask, uint32_t filter_type);
N/* PHY interface configuration (configure SMI clock and reset PHY chip) */
NErrStatus enet_phy_config(void);
N/* write to/read from a PHY register */
NErrStatus enet_phy_write_read(enet_phydirection_enum direction, uint16_t phy_address, uint16_t phy_reg, uint16_t *pvalue);
N/* enable the loopback function of phy chip */
NErrStatus enet_phyloopback_enable(void);
N/* disable the loopback function of phy chip */
NErrStatus enet_phyloopback_disable(void);
N/* enable ENET forward feature */
Nvoid enet_forward_feature_enable(uint32_t feature);
N/* disable ENET forward feature */
Nvoid enet_forward_feature_disable(uint32_t feature);
N/* enable ENET fliter feature */
Nvoid enet_fliter_feature_enable(uint32_t feature);
N/* disable ENET fliter feature */
Nvoid enet_fliter_feature_disable(uint32_t feature);
N
N/* flow control function */
N/* generate the pause frame, ENET will send pause frame after enable transmit flow control */
NErrStatus enet_pauseframe_generate(void);
N/* configure the pause frame detect type */
Nvoid enet_pauseframe_detect_config(uint32_t detect);
N/* configure the pause frame parameters */
Nvoid enet_pauseframe_config(uint32_t pausetime, uint32_t pause_threshold);
N/* configure the threshold of the flow control(deactive and active threshold) */
Nvoid enet_flowcontrol_threshold_config(uint32_t deactive, uint32_t active);
N/* enable ENET flow control feature */
Nvoid enet_flowcontrol_feature_enable(uint32_t feature);
N/* disable ENET flow control feature */
Nvoid enet_flowcontrol_feature_disable(uint32_t feature);
N
N/* DMA function */
N/* get the dma transmit/receive process state */
Nuint32_t enet_dmaprocess_state_get(enet_dmadirection_enum direction); 
N/* poll the dma transmission/reception enable */
Nvoid enet_dmaprocess_resume(enet_dmadirection_enum direction);
N/* check and recover the Rx process */
Nvoid enet_rxprocess_check_recovery(void);
N/* flush the ENET transmit fifo, and wait until the flush operation completes */
NErrStatus enet_txfifo_flush(void);
N/* get the transmit/receive address of current descriptor, or current buffer, or descriptor table */
Nuint32_t enet_current_desc_address_get(enet_desc_reg_enum addr_get);
N/* get the Tx or Rx descriptor information */
Nuint32_t enet_desc_information_get(enet_descriptors_struct *desc, enet_descstate_enum info_get);
N/* get the number of missed frames during receiving */
Nvoid enet_missed_frame_counter_get(uint32_t *rxfifo_drop, uint32_t *rxdma_drop);
N
N/* descriptor function */
N/* get the bit flag of ENET dma descriptor */
NFlagStatus enet_desc_flag_get(enet_descriptors_struct *desc, uint32_t desc_flag);
N/* set the bit flag of ENET dma tx descriptor */
Nvoid enet_desc_flag_set(enet_descriptors_struct *desc, uint32_t desc_flag);
N/* clear the bit flag of ENET dma tx descriptor */
Nvoid enet_desc_flag_clear(enet_descriptors_struct *desc, uint32_t desc_flag); 
N/* when receiving the completed, set RS bit in ENET_DMA_STAT register will set */
Nvoid enet_desc_receive_complete_bit_enable(enet_descriptors_struct *desc);
N/* when receiving the completed, set RS bit in ENET_DMA_STAT register will not set */
Nvoid enet_desc_receive_complete_bit_disable(enet_descriptors_struct *desc);
N/* drop current receive frame */
Nvoid enet_rxframe_drop(void);
N/* enable DMA feature */
Nvoid enet_dma_feature_enable(uint32_t feature);
N/* disable DMA feature */
Nvoid enet_dma_feature_disable(uint32_t feature);
N
N/* initialize the dma Tx/Rx descriptors's parameters in normal chain mode with ptp function */
Nvoid enet_ptp_normal_descriptors_chain_init(enet_dmadirection_enum direction, enet_descriptors_struct *desc_ptptab);
N/* initialize the dma Tx/Rx descriptors's parameters in normal ring mode with ptp function */
Nvoid enet_ptp_normal_descriptors_ring_init(enet_dmadirection_enum direction, enet_descriptors_struct *desc_ptptab);
N/* receive a packet data with timestamp values to application buffer, when the DMA is in normal mode */
NErrStatus enet_ptpframe_receive_normal_mode(uint8_t *buffer, uint32_t bufsize, uint32_t timestamp[]);
N/* handle current received frame but without data copy to application buffer in PTP normal mode */
N#define ENET_NOCOPY_PTPFRAME_RECEIVE_NORMAL_MODE(ptr)             enet_ptpframe_receive_normal_mode(NULL, 0U, (ptr))
N/* send data with timestamp values in application buffer as a transmit packet, when the DMA is in normal mode */
NErrStatus enet_ptpframe_transmit_normal_mode(uint8_t *buffer, uint32_t length, uint32_t timestamp[]);
N/* handle current transmit frame but without data copy from application buffer in PTP normal mode */
N#define ENET_NOCOPY_PTPFRAME_TRANSMIT_NORMAL_MODE(len, ptr)       enet_ptpframe_transmit_normal_mode(NULL, (len), (ptr))
N
N/* WUM function */
N/* wakeup frame filter register pointer reset */
Nvoid enet_wum_filter_register_pointer_reset(void);
N/* set the remote wakeup frame registers */
Nvoid enet_wum_filter_config(uint32_t pdata[]);
N/* enable wakeup management features */
Nvoid enet_wum_feature_enable(uint32_t feature);
N/* disable wakeup management features */
Nvoid enet_wum_feature_disable(uint32_t feature);
N
N/* MSC function */
N/* reset the MAC statistics counters */
Nvoid enet_msc_counters_reset(void);
N/* enable the MAC statistics counter features */ 
Nvoid enet_msc_feature_enable(uint32_t feature);
N/* disable the MAC statistics counter features */ 
Nvoid enet_msc_feature_disable(uint32_t feature);
N/* get MAC statistics counter */                   
Nuint32_t enet_msc_counters_get(enet_msc_counter_enum counter);
N
N/* PTP function */
N/* change subsecond to nanosecond */
Nuint32_t enet_ptp_subsecond_2_nanosecond(uint32_t subsecond);
N/* change nanosecond to subsecond */
Nuint32_t enet_ptp_nanosecond_2_subsecond(uint32_t nanosecond);
N/* enable the PTP features */
Nvoid enet_ptp_feature_enable(uint32_t feature);
N/* disable the PTP features */
Nvoid enet_ptp_feature_disable(uint32_t feature);
N/* configure the PTP timestamp function */
NErrStatus enet_ptp_timestamp_function_config(enet_ptp_function_enum func);
N/* configure the PTP system time subsecond increment value */
Nvoid enet_ptp_subsecond_increment_config(uint32_t subsecond);
N/* adjusting the PTP clock frequency only in fine update mode */
Nvoid enet_ptp_timestamp_addend_config(uint32_t add);
N/* initializing or adding/subtracting to second of the PTP system time */
Nvoid enet_ptp_timestamp_update_config(uint32_t sign, uint32_t second, uint32_t subsecond);
N/* configure the PTP expected target time */
Nvoid enet_ptp_expected_time_config(uint32_t second, uint32_t nanosecond);
N/* get the PTP current system time */
Nvoid enet_ptp_system_time_get(enet_ptp_systime_struct *systime_struct);
N/* configure and start PTP timestamp counter */
Nvoid enet_ptp_start(int32_t updatemethod, uint32_t init_sec, uint32_t init_subsec, uint32_t carry_cfg, uint32_t accuracy_cfg);
N/* adjust frequency in fine method by configure addend register */
Nvoid enet_ptp_finecorrection_adjfreq(int32_t carry_cfg);
N/* update system time in coarse method */
Nvoid enet_ptp_coarsecorrection_systime_update(enet_ptp_systime_struct *systime_struct);
N/* set system time in fine method */
Nvoid enet_ptp_finecorrection_settime(enet_ptp_systime_struct * systime_struct);
N/* get the ptp flag status */
NFlagStatus enet_ptp_flag_get(uint32_t flag);
N
N/* internal function */
N/* reset the ENET initpara struct, call it before using enet_initpara_config() */
Nvoid enet_initpara_reset(void);
N/* initialize ENET peripheral with generally concerned parameters, call it by enet_init() */
Nstatic void enet_default_init(void);
N#ifdef USE_DELAY
S/* user can provide more timing precise _ENET_DELAY_ function */
S#define _ENET_DELAY_                              delay_ms 
N#else
N/* insert a delay time */
Nstatic void enet_delay(uint32_t ncount);
N/* default _ENET_DELAY_ function with less precise timing */
N#define _ENET_DELAY_                              enet_delay
N#endif
N
N#endif /* GD32F10X_ENET_H */
L 64 ".\User\gd32f10x_libopt.h" 2
N#include "gd32f10x_misc.h"
L 1 ".\Libraries\inc\gd32f10x_misc.h" 1
N/*!
N    \file    gd32f10x_misc.h
N    \brief   definitions for the MISC
N
N    \version 2014-12-26, V1.0.0, firmware for GD32F10x
N    \version 2017-06-20, V2.0.0, firmware for GD32F10x
N    \version 2018-07-31, V2.1.0, firmware for GD32F10x
N*/
N
N/*
N    Copyright (c) 2018, GigaDevice Semiconductor Inc.
N
N    All rights reserved.
N
N    Redistribution and use in source and binary forms, with or without modification, 
Nare permitted provided that the following conditions are met:
N
N    1. Redistributions of source code must retain the above copyright notice, this 
N       list of conditions and the following disclaimer.
N    2. Redistributions in binary form must reproduce the above copyright notice, 
N       this list of conditions and the following disclaimer in the documentation 
N       and/or other materials provided with the distribution.
N    3. Neither the name of the copyright holder nor the names of its contributors 
N       may be used to endorse or promote products derived from this software without 
N       specific prior written permission.
N
N    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
NAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
NWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
NIN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
NINDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
NNOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
NPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
NWHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
NARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
NOF SUCH DAMAGE.
N*/
N
N#ifndef GD32F10X_MISC_H
N#define GD32F10X_MISC_H
N
N#include "gd32f10x.h"
N
N/* constants definitions */
N/* set the RAM and FLASH base address */
N#define NVIC_VECTTAB_RAM            ((uint32_t)0x20000000) /*!< RAM base address */
N#define NVIC_VECTTAB_FLASH          ((uint32_t)0x08000000) /*!< Flash base address */
N
N/* set the NVIC vector table offset mask */
N#define NVIC_VECTTAB_OFFSET_MASK    ((uint32_t)0x1FFFFF80)
N
N/* the register key mask, if you want to do the write operation, you should write 0x5FA to VECTKEY bits */
N#define NVIC_AIRCR_VECTKEY_MASK     ((uint32_t)0x05FA0000)
N
N/* priority group - define the pre-emption priority and the subpriority */
N#define NVIC_PRIGROUP_PRE0_SUB4     ((uint32_t)0x700) /*!< 0 bits for pre-emption priority 4 bits for subpriority */
N#define NVIC_PRIGROUP_PRE1_SUB3     ((uint32_t)0x600) /*!< 1 bits for pre-emption priority 3 bits for subpriority */
N#define NVIC_PRIGROUP_PRE2_SUB2     ((uint32_t)0x500) /*!< 2 bits for pre-emption priority 2 bits for subpriority */
N#define NVIC_PRIGROUP_PRE3_SUB1     ((uint32_t)0x400) /*!< 3 bits for pre-emption priority 1 bits for subpriority */
N#define NVIC_PRIGROUP_PRE4_SUB0     ((uint32_t)0x300) /*!< 4 bits for pre-emption priority 0 bits for subpriority */
N
N/* choose the method to enter or exit the lowpower mode */
N#define SCB_SCR_SLEEPONEXIT         ((uint8_t)0x02) /*!< choose the the system whether enter low power mode by exiting from ISR */
N#define SCB_SCR_SLEEPDEEP           ((uint8_t)0x04) /*!< choose the the system enter the DEEPSLEEP mode or SLEEP mode */
N#define SCB_SCR_SEVONPEND           ((uint8_t)0x10) /*!< choose the interrupt source that can wake up the lowpower mode */
N
N#define SCB_LPM_SLEEP_EXIT_ISR      SCB_SCR_SLEEPONEXIT
N#define SCB_LPM_DEEPSLEEP           SCB_SCR_SLEEPDEEP
N#define SCB_LPM_WAKE_BY_ALL_INT     SCB_SCR_SEVONPEND
N
N/* choose the systick clock source */
N#define SYSTICK_CLKSOURCE_HCLK_DIV8 ((uint32_t)0xFFFFFFFBU) /*!< systick clock source is from HCLK/8 */
N#define SYSTICK_CLKSOURCE_HCLK      ((uint32_t)0x00000004U) /*!< systick clock source is from HCLK */
N
N/* function declarations */
N/* set the priority group */
Nvoid nvic_priority_group_set(uint32_t nvic_prigroup);
N
N/* enable NVIC request */
Nvoid nvic_irq_enable(uint8_t nvic_irq, uint8_t nvic_irq_pre_priority, uint8_t nvic_irq_sub_priority);
N/* disable NVIC request */
Nvoid nvic_irq_disable(uint8_t nvic_irq);
N
N/* set the NVIC vector table base address */
Nvoid nvic_vector_table_set(uint32_t nvic_vict_tab, uint32_t offset);
N
N/* set the state of the low power mode */
Nvoid system_lowpower_set(uint8_t lowpower_mode);
N/* reset the state of the low power mode */
Nvoid system_lowpower_reset(uint8_t lowpower_mode);
N
N/* set the systick clock source */
Nvoid systick_clksource_set(uint32_t systick_clksource);
N
N#endif /* GD32F10X_MISC_H */
L 65 ".\User\gd32f10x_libopt.h" 2
N
N#endif /* GD32F10X_LIBOPT_H */
L 376 ".\CMSIS\gd32f10x.h" 2
N#endif /* USE_STDPERIPH_DRIVER */
N
N#ifdef cplusplus
S}
N#endif
N#endif 
L 5 "User\common.h" 2
N#include "stdio.h"
L 1 "D:\Keil_v5\ARM\ARMCC\Bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 STS Limited. All rights reserved.        */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __STSCLIB_VERSION 5060044
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N
N#define _STSABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
X#if !0L && (0L || !0L || !0L)
N/* always defined in C++ and non-strict C for consistency of debug info */
N  #ifdef __clang__
S    typedef __builtin_va_list __va_list;
N  #else
N    typedef struct __va_list __va_list;
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
N#if defined(__STRICT_ANSI__) && !__FILE_INCOMPLETE
X#if 0L && !__FILE_INCOMPLETE
Sstruct __FILE {
S    union {
S        long __FILE_alignment;
S#ifdef __TARGET_ARCH_AARCH64
S        char __FILE_size[136];
S#else /* __TARGET_ARCH_AARCH64 */
S        char __FILE_size[84];
S#endif /* __TARGET_ARCH_AARCH64 */
S    } __FILE_opaque;
S};
S    /*
S     * FILE must be an object type (C99 - 7.19.1) and an object type fully
S     * describes an object [including its static size] (C99 - 6.2.5).
S     * This definition is a placeholder which matches the struct __FILE in
S     * size and alignment as used internally by libc.
S     */
N#endif
N
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _STSABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _STSABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _STSABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _STSABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _STSABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _STSABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _STSABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _STSABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _STSABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _STSABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _STSABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _STSABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _STSABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _STSABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _STSABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _STSABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N
N#pragma __printf_args
Nextern _STSABI int __STS_snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __STS_snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N#pragma __printf_args
Nextern _STSABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _STSABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _STSABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _STSABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _STSABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _STSABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _STSABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _STSABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N/* C99 additions */
Nextern _STSABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _STSABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _STSABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _STSABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _STSABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _STSABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _STSABI int __STS_vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int __STS_vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _STSABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _STSABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _STSABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _STSABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
Nextern _STSABI int __STS_vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __STS_vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
Nextern _STSABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _STSABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _STSABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _STSABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
N#pragma __printf_args
Nextern _STSABI int asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _STSABI int vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N#endif
N#pragma __printf_args
Nextern _STSABI int __STS_asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __STS_asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _STSABI int __STS_vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __STS_vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N   /*
N    * dynamically allocates a buffer of the right size for the
N    * formatted string, and returns it in (*strp). Formal return value
N    * is the same as any other printf variant, except that it returns
N    * -1 if the buffer could not be allocated.
N    *
N    * (The functions with __STS_ prefixed names are identical to the
N    * ones without, but are available in all compilation modes without
N    * violating user namespace.)
N    */
N
Nextern _STSABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _STSABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _STSABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _STSABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _STSABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _STSABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _STSABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _STSABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _STSABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _STSABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _STSABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _STSABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _STSABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _STSABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _STSABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _STSABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _STSABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _STSABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _STSABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _STSABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _STSABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _STSABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _STSABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _STSABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _STSABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _STSABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _STSABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S#if !defined(__STRICT_ANSI__)
S    using ::std::asprintf;
S    using ::std::vasprintf;
S#endif
S    using ::std::__STS_asprintf;
S    using ::std::__STS_vasprintf;
S    using ::std::__STS_vsnprintf;
S    using ::std::__STS_snprintf;
S    using ::std::__STS_vsscanf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 6 "User\common.h" 2
N#include "stdlib.h"
N#include "string.h"
L 1 "D:\Keil_v5\ARM\ARMCC\Bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 STS Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __STSCLIB_VERSION 5060044
N
N#define _STSABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _STSABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _STSABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _STSABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _STSABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _STSABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _STSABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _STSABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _STSABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _STSABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _STSABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _STSABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _STSABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _STSABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _STSABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _STSABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _STSABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _STSABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _STSABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _STSABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _STSABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _STSABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _STSABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _STSABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _STSABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _STSABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _STSABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _STSABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _STSABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _STSABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _STSABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _STSABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _STSABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _STSABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _STSABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _STSABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _STSABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _STSABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _STSABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _STSABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _STSABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _STSABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _STSABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _STSABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _STSABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _STSABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 8 "User\common.h" 2
N#include "Lcd2004.h"
L 1 "User\Lcd2004.h" 1
N#ifndef     __LCD2004_H__
N#define     __LCD2004_H__
N
N#include "common.h"
L 1 "User\common.h" 1
N#ifndef __COMMON_H__
S#define __COMMON_H__
S
S#include "gd32f10x.h"
S#include "stdio.h"
S#include "stdlib.h"
S#include "string.h"
S#include "Lcd2004.h"
S#include <stdarg.h>
S
S// 
S#define DEBUG_ENABLE 1
S
S// APP
S#define APP_VERSION_1         			1
S#define APP_VERSION_2         			0
S#define APP_VERSION_3          			9
S  
S//boot
S#define BOOT_VERSION_1					0
S#define BOOT_VERSION_2					0
S#define BOOT_VERSION_3					3
S
S// Typedef definitions
Stypedef signed char         int8;
Stypedef unsigned char       uint8;
Stypedef signed short        int16;
Stypedef unsigned short      uint16;
Stypedef signed long         int32;
Stypedef unsigned long       uint32;
Stypedef signed long long    int64;    // 64
Stypedef unsigned long long  uint64;   // 64
Stypedef float               fp32;     // (32) 
Stypedef double              fp64;     // (64) 
S
S#ifndef NULL
S#define	NULL				 0
S#endif
S
S#define UINT32_NULL	(0xFFFFFFFF)
S#define UINT16_NULL	(0xFFFF)
S#define UINT8_NULL	(0xFF)
S
S#define SYS_OK		(0)
S
S
S// 
Stypedef enum{
S	FALSE = 0,
S	TRUE  = 1,
S}BOOL;
S
Stypedef enum
S{
S	UART_0 = 0,
S	UART_1,
S	UART_2,
S	UART_3,
S	UART_4,
S	UART_5
S}UART_TYPE;
S
Stypedef union {
S	uint8	byte;
S	struct {
S			uint8	bit0:1;
S			uint8	bit1:1;
S			uint8	bit2:1;
S			uint8	bit3:1;
S			uint8	bit4:1;
S			uint8	bit5:1;
S			uint8	bit6:1;
S			uint8	bit7:1;
S	} Bits;
S} UNION_BITS;  
S
Stypedef struct {
S			uint8	bit0:1;
S			uint8	bit1:1;
S			uint8	bit2:1;
S			uint8	bit3:1;
S			uint8	bit4:1;
S			uint8	bit5:1;
S			uint8	bit6:1;
S			uint8	bit7:1;
S} STRUCT_BITS; 
S
S//
S#define EI()    {__asm volatile ("cpsie i");}
S#define DI()    {__asm volatile ("cpsid i");}
S#define NOP()   {__asm volatile ("nop");}
S
N#endif
N
L 5 "User\Lcd2004.h" 2
N
N#define comm 0
N#define dat 1
N#define uchar uint8_t
N#define MAX_ONE_LINES_LENGTH 20      // 
N#define MAX_TWO_LINES_LENGTH 40      // 
N#define MAX_THREE_LENGTH_LENGTH 60   // 
N#define MAX_ALL_LENGTH 80            // 
N#define MAX_LINES 4                  // 
N
N// RS    RW     E
N// PE7   PE2    PE3
N#define E_1()  gpio_bit_set(GPIOE, GPIO_PIN_3)         
N#define E_0()  gpio_bit_reset(GPIOE, GPIO_PIN_3)
N
N#define WR_1()  gpio_bit_set(GPIOE, GPIO_PIN_2)                 
N#define WR_0()  gpio_bit_reset(GPIOE, GPIO_PIN_2)
N
N#define RS_1()  gpio_bit_set(GPIOE, GPIO_PIN_7)             
N#define RS_0()  gpio_bit_reset(GPIOE, GPIO_PIN_7) 
N
N#define LCD_ON()   gpio_init(GPIOB, GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_1);gpio_bit_set(GPIOB, GPIO_PIN_1)         
N#define LCD_OFF()  gpio_init(GPIOB, GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_1);gpio_bit_reset(GPIOB, GPIO_PIN_1) 
N
N//#define WR_DATA(data)  GPIO_OCTL(GPIOE) = ((uint32_t)data<<8);// 8
N
N/*  ---------------------------------------------------------------------------------------------------------*/
N// LCD
Nvoid Init_Lcd(void);
N
N// LCD
Nvoid wr_lcd(uint8_t dat_cmd, uint8_t content);
N
N// y
Nvoid Display_Y(uint8_t y, const char *code);
N
N// YX
Nvoid Display_YX(uint8_t y, uint8_t x, const char *code);
N
N// Y
Nvoid Display_Centered(uint8_t y, const char *code);
N
N// 80
Nvoid Display_Max(const char *code);
N
N// YX
Nvoid Display_YX_Max(uint8_t y, uint8_t x, const char *code);
N
N// LCDY,X
Nvoid Display_YX_Format(uint8_t y, uint8_t x, const char* format, ...);
N
N// LCDY
Nvoid Display_Centered_Format(uint8_t y, const char* format, ...);
N
N// 
Nvoid Clear_Line(uint8_t y);
N
N// 
Nvoid Clear_All_Lines(void);
N
N// 
Nvoid POWER_ON_Information(void);
N
N// LCD
Nvoid Vertical_Scrolling_Display(char (* const Msg)[MAX_ONE_LINES_LENGTH], uchar numLines, uchar currentStartLine);
Xvoid Vertical_Scrolling_Display(char (* const Msg)[20], uint8_t numLines, uint8_t currentStartLine);
N
N// 
Nvoid addString(uchar line, uchar column, const char *str, char Msg[MAX_LINES][MAX_ONE_LINES_LENGTH]);
Xvoid addString(uint8_t line, uint8_t column, const char *str, char Msg[4][20]);
N
Nvoid addFormattedString(uchar line, uchar column, const char *format, char Msg[MAX_LINES][MAX_ONE_LINES_LENGTH], ...);
Xvoid addFormattedString(uint8_t line, uint8_t column, const char *format, char Msg[4][20], ...);
N
Nvoid WR_DATA(uint32_t data);
N#endif
L 9 "User\common.h" 2
N#include <stdarg.h>
L 1 "D:\Keil_v5\ARM\ARMCC\Bin\..\include\stdarg.h" 1
N/* stdarg.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.8 */
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright (C) ARM Ltd., 1991-1999. All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdarg_h
N#define __stdarg_h
N#define __ARMCLIB_VERSION 5060044
N
N  #ifndef __STDARG_DECLS
N  #define __STDARG_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N/*
N * stdarg.h declares a type and defines macros for advancing through a
N * list of arguments whose number and types are not known to the called
N * function when it is translated. A function may be called with a variable
N * number of arguments of differing types. Its parameter list contains one or
N * more parameters. The rightmost parameter plays a special role in the access
N * mechanism, and will be called parmN in this description.
N */
N
N/* N.B. <stdio.h> is required to declare vfprintf() without defining      */
N/* va_list.  Clearly the type __va_list there must keep in step.          */
N#ifdef __clang__
S  typedef __builtin_va_list va_list;
S  #define va_start(ap, param) __builtin_va_start(ap, param)
S  #define va_end(ap)          __builtin_va_end(ap)
S  #define va_arg(ap, type)    __builtin_va_arg(ap, type)
S  #if __STDC_VERSION__ >= 199900L || __cplusplus >= 201103L || !defined(__STRICT_ANSI__)
S  #define va_copy(dest, src)  __builtin_va_copy(dest, src)
S  #endif
N#else
N  #ifdef __TARGET_ARCH_AARCH64
S    typedef struct __va_list {
S      void *__stack;
S      void *__gr_top;
S      void *__vr_top;
S      int __gr_offs;
S      int __vr_offs;
S    } va_list;
N  #else
N    typedef struct __va_list { void *__ap; } va_list;
N  #endif
N   /*
N    * an array type suitable for holding information needed by the macro va_arg
N    * and the function va_end. The called function shall declare a variable
N    * (referred to as ap) having type va_list. The variable ap may be passed as
N    * an argument to another function.
N    * Note: va_list is an array type so that when an object of that type
N    * is passed as an argument it gets passed by reference.
N    */
N  #define va_start(ap, parmN) __va_start(ap, parmN)
N
N   /*
N    * The va_start macro shall be executed before any access to the unnamed
N    * arguments. The parameter ap points to an object that has type va_list.
N    * The va_start macro initialises ap for subsequent use by va_arg and
N    * va_end. The parameter parmN is the identifier of the rightmost parameter
N    * in the variable parameter list in the function definition (the one just
N    * before the '...'). If the parameter parmN is declared with the register
N    * storage class an error is given.
N    * If parmN is a narrow type (char, short, float) an error is given in
N    * strict ANSI mode, or a warning otherwise.
N    * Returns: no value.
N    */
N  #define va_arg(ap, type) __va_arg(ap, type)
N
N   /*
N    * The va_arg macro expands to an expression that has the type and value of
N    * the next argument in the call. The parameter ap shall be the same as the
N    * va_list ap initialised by va_start. Each invocation of va_arg modifies
N    * ap so that successive arguments are returned in turn. The parameter
N    * 'type' is a type name such that the type of a pointer to an object that
N    * has the specified type can be obtained simply by postfixing a * to
N    * 'type'. If type is a narrow type, an error is given in strict ANSI
N    * mode, or a warning otherwise. If the type is an array or function type,
N    * an error is given.
N    * In non-strict ANSI mode, 'type' is allowed to be any expression.
N    * Returns: The first invocation of the va_arg macro after that of the
N    *          va_start macro returns the value of the argument after that
N    *          specified by parmN. Successive invocations return the values of
N    *          the remaining arguments in succession.
N    *          The result is cast to 'type', even if 'type' is narrow.
N    */
N
N#define __va_copy(dest, src) ((void)((dest) = (src)))
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N   /* va_copy is in C99 and non-strict C90 and non-strict C++
N    * __va_copy is always present.
N    */
N  #define va_copy(dest, src) ((void)((dest) = (src)))
N
N   /* The va_copy macro makes the va_list dest be a copy of
N    * the va_list src, as if the va_start macro had been applied
N    * to it followed by the same sequence of uses of the va_arg
N    * macro as had previously been used to reach the present state
N    * of src.
N    */
N#endif
N
N#define va_end(ap) __va_end(ap)
N   /*
N    * The va_end macro facilitates a normal return from the function whose
N    * variable argument list was referenced by the expansion of va_start that
N    * initialised the va_list ap. If the va_end macro is not invoked before
N    * the return, the behaviour is undefined.
N    * Returns: no value.
N    */
N#endif /* __clang__ */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N
N    #ifdef __GNUC__
S     /* be cooperative with glibc */
S     typedef __CLIBNS va_list __gnuc_va_list;
S     #define __GNUC_VA_LIST
S     #undef __need___va_list
N    #endif
N
N  #endif /* __STDARG_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDARG_NO_EXPORTS
S      using ::std::va_list;
S    #endif
N  #endif /* __cplusplus */
N#endif
N
N/* end of stdarg.h */
N
L 10 "User\common.h" 2
N
N// 
N#define DEBUG_ENABLE 1
N
N// APP
N#define APP_VERSION_1         			1
N#define APP_VERSION_2         			0
N#define APP_VERSION_3          			9
N  
N//boot
N#define BOOT_VERSION_1					0
N#define BOOT_VERSION_2					0
N#define BOOT_VERSION_3					3
N
N// Typedef definitions
Ntypedef signed char         int8;
Ntypedef unsigned char       uint8;
Ntypedef signed short        int16;
Ntypedef unsigned short      uint16;
Ntypedef signed long         int32;
Ntypedef unsigned long       uint32;
Ntypedef signed long long    int64;    // 64
Ntypedef unsigned long long  uint64;   // 64
Ntypedef float               fp32;     // (32) 
Ntypedef double              fp64;     // (64) 
N
N#ifndef NULL
S#define	NULL				 0
N#endif
N
N#define UINT32_NULL	(0xFFFFFFFF)
N#define UINT16_NULL	(0xFFFF)
N#define UINT8_NULL	(0xFF)
N
N#define SYS_OK		(0)
N
N
N// 
Ntypedef enum{
N	FALSE = 0,
N	TRUE  = 1,
N}BOOL;
N
Ntypedef enum
N{
N	UART_0 = 0,
N	UART_1,
N	UART_2,
N	UART_3,
N	UART_4,
N	UART_5
N}UART_TYPE;
N
Ntypedef union {
N	uint8	byte;
N	struct {
N			uint8	bit0:1;
N			uint8	bit1:1;
N			uint8	bit2:1;
N			uint8	bit3:1;
N			uint8	bit4:1;
N			uint8	bit5:1;
N			uint8	bit6:1;
N			uint8	bit7:1;
N	} Bits;
N} UNION_BITS;  
N
Ntypedef struct {
N			uint8	bit0:1;
N			uint8	bit1:1;
N			uint8	bit2:1;
N			uint8	bit3:1;
N			uint8	bit4:1;
N			uint8	bit5:1;
N			uint8	bit6:1;
N			uint8	bit7:1;
N} STRUCT_BITS; 
N
N//
N#define EI()    {__asm volatile ("cpsie i");}
N#define DI()    {__asm volatile ("cpsid i");}
N#define NOP()   {__asm volatile ("nop");}
N
N#endif
N
L 2 "User\key.c" 2
N#include "key.h"
L 1 "User\key.h" 1
N#ifndef     __KEY_H__
N#define     __KEY_H__
N
N#include "keyMsgProcess.h"
L 1 "User\keyMsgProcess.h" 1
N#ifndef 	__KEY_MSG_PROCESS_MODULE_H__
N#define 	__KEY_MSG_PROCESS_MODULE_H__
N
N/******************************************************************************
N* 
N* 
N******************************************************************************/
N// 
N#include "common.h"
N
N#define	KEY_SCAN_TIME			20		// msN(N>=1)
N#define	KEY_HOLD_TIME			1500	// msN(N>=1)
N#define	KEY_RETHROW_TIME		500		// msN(N>=2)
N
N// 
Ntypedef enum
N{
N	//  KEY_NAME_MAX 
N	// 0
N	KEY_NAME_START,  //
N//	KEY_NAME_DEC,
N//	KEY_NAME_INFO,
N//	KEY_NAME_ADD_DEC,
N//	KEY_NAME_ADD_INFO,
N
N	/*=============================================================
N	** 
N	==============================================================*/
N	KEY_NAME_MAX,
N	KEY_NAME_NULL,
N}KEY_NAME_E;
N
N// 
N#define KEY_STATE_BYTE_COUNT							((KEY_NAME_MAX+7)/8)
N
N// 
N#define KEY_JUDGE_COUNT								(KEY_JUDGE_TIME/KEY_SCAN_TIME)
N//   0001 1111
Ntypedef enum
N{
N	  KEY_MASK_START = (1UL<<KEY_NAME_START),
N//	KEY_MASK_DEC = (1UL<<KEY_NAME_DEC),
N//	KEY_MASK_INFO = (1UL<<KEY_NAME_INFO),
N//	KEY_MASK_ADD_DEC = (1UL<<KEY_NAME_ADD_DEC),
N//	KEY_MASK_ADD_INFO = (1UL<<KEY_NAME_ADD_INFO),
N
N	KEY_MASK_ALL = 0x001F,
N	KEY_MASK_NULL = 0,
N}KEY_MASK_E;
N
N
N// 
N#define	KEY_MSG_USE_SAME_HOLD_THRESHOLD			0	// 0c
N#define	KEY_MSG_USE_SAME_REPEAT_TIME			0	// 0c
N
N/******************************************************************************
N* 
N* 
N******************************************************************************/
N#define	KEY_INFO_SIZE					2		// 
N#define	KEY_STATE_MASK					0x8000	// 
N#define	KEY_MSG_QUEUE_SIZE				10		// -1
N
N#define	KEY_MSG_SWITCH_DOWN				1		// 
N#define KEY_MSG_SWITCH_HOLD				1		// 
N#define KEY_MSG_SWITCH_REPEAT			1		// 
N#define KEY_MSG_SWITCH_UP				1		// 
N
N/******************************************************************************
N* 
N* 
N******************************************************************************/
N#ifndef	NULL
S#define	NULL	0
N#endif
N
N#define	KEY_MSG_PRIORITY					1	// 0 - 1 - 
N#define	KEY_MSG_THROW_KEY_UP_AFTER_REPEAT	1	// 0
N
N// 
Ntypedef enum
N{
N	// 
N#if 1==KEY_MSG_SWITCH_DOWN      //// 
X#if 1==1      
N	KEY_MSG_DOWN,			// 
N#endif
N#if 1==KEY_MSG_SWITCH_UP
X#if 1==1
N	KEY_MSG_UP,				// 
N#endif
N#if 1==KEY_MSG_SWITCH_HOLD
X#if 1==1
N	KEY_MSG_HOLD,			// 
N#endif
N#if 1==KEY_MSG_SWITCH_REPEAT
X#if 1==1
N	KEY_MSG_REPEAT,			// 
N#endif
N	
N	/*=============================================================
N	** 
N	==============================================================*/
N	KEY_MSG_MAX,			// 
N	KEY_MSG_NULL,			// 
N}KEY_MSG_E;
N
N
N// 0bit717
Ntypedef struct
N{
N	uint8	end;
N	uint16	stateCount[KEY_INFO_SIZE];				// 01
X	uint16	stateCount[2];				
N	void	(*service[KEY_MSG_MAX])(uint32 param);	// 
N	uint32	param[KEY_MSG_MAX];						// 
N}KEYMSG_INFO_CB;   //KEYMSG_INFO_CB
N 
N// 
Ntypedef struct
N{
N	uint8	head;
N	uint8	end;
N	struct
N	{
N		KEY_NAME_E	keyName;	// 
N		KEY_MSG_E	keyMsg;		// 
N	}node[KEY_MSG_QUEUE_SIZE];
X	}node[10];
N}KEY_MSG_QUEUE;
N
N// 
Ntypedef struct
N{
N	volatile uint8	scanRequest;					// 
N	
N	uint8	keyValue[KEY_STATE_BYTE_COUNT];			// bit
X	uint8	keyValue[((KEY_NAME_MAX+7)/8)];			
N													//  KEY_NAME_E 
N													// 1-81
N													// 9-162
N													//  (KEY_NAME_MAX + 7)/8
N#if 0==KEY_MSG_THROW_KEY_UP_AFTER_REPEAT			//  KEY_REPEAT 
X#if 0==1			
S	uint8	keyUpMsgMaskBit[KEY_STATE_BYTE_COUNT];	// 
S													// 1 KEY_UP 
S													// 0 KEY_UP 
N#endif
N	KEYMSG_INFO_CB	keyMsgInfo[KEY_NAME_MAX];		// 
N	KEY_MSG_QUEUE	msgQueue;						// 
N	
N	//KeyUpdatep8bitKeyValueArray
N	void(*KeyUpdate)(uint8* p8bitKeyValueArray);	// 
N
N	// 
N	BOOL msgMaskRequest[KEY_NAME_MAX][KEY_MSG_MAX];
N	BOOL globalMaskRequest;							// 
N
N	BOOL addDecKeyUpRercoveryRequest;				// +-
N	BOOL addInfoKeyUpRercoveryRequest;				// + i
N	BOOL addKeyInvalidRequest;						// +
N}KEYMSG_CB;
N
Nextern KEYMSG_CB keyMsgCB;
N
N
N/******************************************************************************
N* 
N******************************************************************************/
N// 
N// KEYMSG_Init
N// 
N//  main 
Nvoid KEYMSG_Init(void);
N
N// 
N// KEYMSG_RegisterKeyScanCallback
N// 
N// 
N//			   01
Nvoid KEYMSG_RegisterKeyScanCallback(void(*fun)(uint8* p8bitKeyValueArray));
N
N// 
N// KEYMSG_RegisterMsgService
N// 
N// 
Nvoid KEYMSG_RegisterMsgService(KEY_NAME_E keyName, KEY_MSG_E keyMsg, void(*service)(uint32 param), uint32 param);
N
N// 
Nvoid KEYMSG_RegisterMsgServiceWithHoldTime(KEY_NAME_E keyName, KEY_MSG_E keyMsg, void(*service)(uint32 param), uint32 param, uint16 holdTime);
N
N
N// 
N// KEYMSG_StopService
N// 
N// 
Nvoid KEYMSG_StopService(KEY_NAME_E keyName, KEY_MSG_E keyMsg);
N
N// 
N// KEYMSG_StopAllService
N// 
N// 
Nvoid KEYMSG_StopAllService(void);
N
N// 
N// KEYMSG_CALLBACK_Scan
N// 
N// 
Nvoid KEYMSG_CALLBACK_Scan(uint32 param);
N
N// 
N// KEYMSG_Process
N// 
N//  main 
Nvoid KEYMSG_Process(void);
N
N// 
Nvoid KEYMSG_SetMaskRequest(KEY_NAME_E keyName, KEY_MSG_E keyMsg);
N
N// 
Nvoid KEYMSG_ClearMaskRequest(KEY_NAME_E keyName, KEY_MSG_E keyMsg);
N
N// 
Nvoid KEYMSG_SetGlobalMaskRequest(void);
N
N// 
Nvoid KEYMSG_ClearGlobalMaskRequest(void);
N
N// +-
Nvoid KEYMSG_SetAddDecKeyUpRecoveryRequest(BOOL state);
N
N// +-
NBOOL KEYMSG_GetAddDecKeyUpRecoveryRequest(void);
N
N// + i
Nvoid KEYMSG_SetAddInfoKeyUpRecoveryRequest(BOOL state);
N
N// + i
NBOOL KEYMSG_GetAddInfoKeyUpRecoveryRequest(void);
N
N#endif
N
L 5 "User\key.h" 2
N#include "common.h"
N
N#define KEY_FILTER_LEVEL_N              3   // 1-7
N
N#define KEY_CHECK_RCU_PORT RCU_GPIOC
N#define KEY_CHECK_PORT     GPIOC
N#define KEY_CHECK_PIN      GPIO_PIN_13
N
N// 
Ntypedef struct
N{
N    uint8 buff[KEY_NAME_MAX];
N
N    uint8 lastValue[KEY_NAME_MAX];
N} KEY_CB;
N
N
Nvoid KEY_Init(void);
N
Nvoid KEY_CALLBACK_Scan(uint8 *p8bitKeyValueArray);
N
N#endif
N
L 3 "User\key.c" 2
N#include "keymsgprocess.h"
N#include "state.h"
L 1 "User\state.h" 1
N#ifndef __STATE_H__
N#define __STATE_H__
N
N#include "common.h"
N
N#define FIRST_DAC                                1000
N#define SECOND_DAC                               3000
N#define THIRD_DAC                                5000
N#define ERROR_DAC                                500
N#define LIGHT_GND_VOLTAGE_VALUE                  3000       // GND,mv
N
N// 
Ntypedef enum
N{
N    STATE_NULL = 0,                     // 
N    STATE_STANDBY,
N
N    STATE_UART_TEST,
N    STATE_UART_GND_TEST,                    // GND
N
N    // 
N    STATE_UART_HEADLIGHT_TEST,              // UART
N    STATE_UART_LBEAM_TEST,                  // UART
N    STATE_UART_HBEAM_TEST,                  // UART
N    STATE_UART_LEFT_TURN_SIGNAL_TEST,       // UART
N    STATE_UART_RIGHT_TURN_SIGNAL_TEST,      // UART
N    STATE_UART_THROTTLE_TEST,               // UART
N    STATE_UART_BRAKE_TEST,                  // UART
N    STATE_UART_BUTTON_TEST,                 // UART
N    STATE_UART_LIGHT_SENSING_TEST,          // UART
N    STATE_UART_VLK_TEST,                    // UARTVLK
N    STATE_UART_VOLTAGE_TEST,                // UART
N    STATE_UART_DISPLAY_TEST,                // UART
N    STATE_UART_DERAILLEUR_TEST,             // UART
N
N    // CAN
N    STATE_CAN_HEADLIGHT_TEST,               // CAN
N    STATE_CAN_LBEAM_TEST,                   // 
N    STATE_CAN_HBEAM_TEST,                   // 
N    STATE_CAN_LEFT_TURN_SIGNAL_TEST,        // CAN
N    STATE_CAN_RIGHT_TURN_SIGNAL_TEST,       // CAN
N    STATE_CAN_THROTTLE_TEST,                // CAN
N    STATE_CAN_BRAKE_TEST,                   // CAN
N    STATE_CAN_BUTTON_TEST,                  // CAN
N    STATE_CAN_LIGHT_SENSING_TEST,           // CAN
N    STATE_CAN_VLK_TEST,                     // CANVLK
N    STATE_CAN_VOLTAGE_TEST,                 // CAN
N    STATE_CAN_DISPLAY_TEST,                 // CAN
N    STATE_CAN_DERAILLEUR_TEST,              // CAN
N/////////////////////////////////////////////////////////////////////////////////
N
N    STATE_GAOBIAO_CAN_UPGRADE,                  // CAN
N    STATE_CM_CAN_UPGRADE,                       // can
N    STATE_HUAXIN_CAN_UPGRADE,                   // can
N    STATE_SEG_CAN_UPGRADE,                      // can
N    STATE_KAIYANG_CAN_UPGRADE,                  // can
N    STATE_SPARROW_CAN_UPGRADE,                  // SPARROW CAN
N    STATE_CM_UART_SEG_UPGRADE,                  // 
N    STATE_CM_UART_BC_UPGRADE,                   // 
N    STATE_HUAXIN_UART_BC_UPGRADE,               // 
N    STATE_KAIYANG_UART_BC_UPGRADE,              // 
N    STATE_LIME_UART_BC_UPGRADE,                 // LIME
N    
N/////////////////////////////////////////////////////////////////////////////////
N
N    STATE_UART_XM_HEADLIGHT_TEST,              // UART()
N    STATE_UART_XM_LEFT_TURN_SIGNAL_TEST,       // UART()
N    STATE_UART_XM_RIGHT_TURN_SIGNAL_TEST,      // UART()
N    STATE_UART_XM_THROTTLE_TEST,               // UART()
N    STATE_UART_XM_BRAKE_TEST,                  // UART()
N    STATE_UART_XM_VLK_TEST,                    // UART()VLK
N
N    STATE_MAX                                   // 
N} STATE_E;
N
N
N// 
Ntypedef enum
N{
N    STEP_NULL = 0,                          // 
N
N    // GND
N    STEP_GND_TEST_ENTRY,                    // 
N    STEP_GND_TEST_WAIT_RESPONSE,            // 
N    STEP_GND_TEST_THROTTLE_GND,
N    STEP_GND_TEST_CHECK_THROTTLE_GND_VALUE, // GND
N    STEP_GND_TEST_BRAKE_GND,
N    STEP_GND_TEST_CHECK_BRAKE_GND_VALUE,    // GND
N    STEP_GND_TEST_DERAILLEUR_GND,
N    STEP_GND_TEST_CHECK_DERAILLEUR_GND_VALUE,    // GND    
N    STEP_GND_TEST_COMPLETE,                 //
N    STEP_GND_TEST_COMMUNICATION_TIME_OUT,   // 
N
N    // UART
N    STEP_UART_TEST_ENTRY,                       // 
N    STEP_UART_TEST_WAIT_RESPONSE,               // 
N    STEP_UART_TEST_CHECK_VOLTAGE_VALUE,         // VCC
N    STEP_UART_TEST_COMPLETE,                    // UART
N    STEP_UART_TEST_COMMUNICATION_TIME_OUT,      // 
N
N    /* UART */
N/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
N
N    // 
N    STEP_HEADLIGHT_UART_TEST_ENTRY,               // 
N    STEP_HEADLIGHT_UART_TEST_WAIT_RESPONSE,       // 
N    STEP_HEADLIGHT_UART_TEST_NOTIFY_DUT,          // DUTDUT
N    STEP_HEADLIGHT_UART_TEST_OPEN,                // ,    VCC
N    STEP_HEADLIGHT_UART_TEST_CHECK_VOLTAGE_VALUE, // VCC
N    STEP_HEADLIGHT_UART_TEST_CHECK_GND_VALUE,     // GND
N    STEP_HEADLIGHT_UART_TEST_COMPLETE,            // 
N    STEP_HEADLIGHT_UART_TEST_COMMUNICATION_TIME_OUT,
N
N    // 
N    STEP_LBEAM_UART_TEST_ENTRY,               // 
N    STEP_LBEAM_UART_TEST_WAIT_RESPONSE,       // 
N    STEP_LBEAM_UART_TEST_NOTIFY_DUT,          // DUTDUT
N    STEP_LBEAM_UART_TEST_OPEN,                // ,  VCC
N    STEP_LBEAM_UART_TEST_CHECK_VOLTAGE_VALUE, // VCC
N    STEP_LBEAM_UART_TEST_CHECK_GND_VALUE,     // GND
N    STEP_LBEAM_UART_TEST_COMPLETE,            // 
N    STEP_LBEAM_UART_TEST_COMMUNICATION_TIME_OUT,
N
N    // 
N    STEP_HBEAM_UART_TEST_ENTRY,               // 
N    STEP_HBEAM_UART_TEST_WAIT_RESPONSE,       // 
N    STEP_HBEAM_UART_TEST_NOTIFY_DUT,          // DUTDUT
N    STEP_HBEAM_UART_TEST_OPEN,                // ,  VCC
N    STEP_HBEAM_UART_TEST_CHECK_VOLTAGE_VALUE, // VCC
N    STEP_HBEAM_UART_TEST_CHECK_GND_VALUE,     // GND
N    STEP_HBEAM_UART_TEST_COMPLETE,            // 
N    STEP_HBEAM_UART_TEST_COMMUNICATION_TIME_OUT,
N
N    // 
N    STEP_LEFT_TURN_SIGNAL_UART_TEST_ENTRY,               // 
N    STEP_LEFT_TURN_SIGNAL_UART_TEST_WAIT_RESPONSE,       // 
N    STEP_LEFT_TURN_SIGNAL_UART_TEST_NOTIFY_DUT,          // DUTDUT
N    STEP_LEFT_TURN_SIGNAL_UART_TEST_OPEN,                // ,   VCC
N    STEP_LEFT_TURN_SIGNAL_UART_TEST_CHECK_VOLTAGE_VALUE, // VCC
N    STEP_LEFT_TURN_SIGNAL_UART_TEST_CHECK_GND_VALUE,     // GND
N    STEP_LEFT_TURN_SIGNAL_UART_TEST_CHECK_GND_VALUE2,
N    STEP_LEFT_TURN_SIGNAL_UART_TEST_COMPLETE,            // 
N    STEP_LEFT_TURN_SIGNAL_UART_TEST_COMMUNICATION_TIME_OUT,
N
N    // 
N    STEP_RIGHT_TURN_SIGNAL_UART_TEST_ENTRY,               // 
N    STEP_RIGHT_TURN_SIGNAL_UART_TEST_WAIT_RESPONSE,       // 
N    STEP_RIGHT_TURN_SIGNAL_UART_TEST_NOTIFY_DUT,          // DUTDUT
N    STEP_RIGHT_TURN_SIGNAL_UART_TEST_OPEN,                // ,  VCC
N    STEP_RIGHT_TURN_SIGNAL_UART_TEST_CHECK_VOLTAGE_VALUE, // VCC
N    STEP_RIGHT_TURN_SIGNAL_UART_TEST_CHECK_GND_VALUE,     // GND
N    STEP_RIGHT_TURN_SIGNAL_UART_TEST_CHECK_GND_VALUE2,    // GND
N    STEP_RIGHT_TURN_SIGNAL_UART_TEST_CHECK_GND_VALUE3,    // GND        
N    STEP_RIGHT_TURN_SIGNAL_UART_TEST_COMPLETE,            // 
N    STEP_RIGHT_TURN_SIGNAL_UART_TEST_COMMUNICATION_TIME_OUT,
N
N    // 
N    STEP_THROTTLE_UART_TEST_ENTRY,               // 
N    STEP_THROTTLE_UART_TEST_WAIT_RESPONSE,       // 
N    STEP_THROTTLE_UART_TEST_VCC,                 // VCC
N    STEP_THROTTLE_UART_TEST_CHECK_VOLTAGE_VALUE, // VCC
N    STEP_THROTTLE_UART_TEST_CHECK_DAC1_VALUE,    // DAC
N    STEP_THROTTLE_UART_TEST_CHECK_DAC3_VALUE,    // DAC
N    STEP_THROTTLE_UART_TEST_CHECK_DAC5_VALUE,    // DAC
N    STEP_THROTTLE_UART_TEST_COMPLETE,            // DAC0
N    STEP_THROTTLE_UART_TEST_COMMUNICATION_TIME_OUT,  // 
N
N    // 
N    STEP_BRAKE_UART_TEST_ENTRY,               // 
N    STEP_BRAKE_UART_TEST_WAIT_RESPONSE,       // 
N    STEP_BRAKE_UART_TEST_VCC,                 // VCC
N    STEP_BRAKE_UART_TEST_CHECK_VOLTAGE_VALUE, // VCC
N    STEP_BRAKE_UART_TEST_CHECK_DAC1_VALUE,    // DAC
N    STEP_BRAKE_UART_TEST_CHECK_DAC3_VALUE,    // DAC
N    STEP_BRAKE_UART_TEST_CHECK_DAC5_VALUE,    // DAC
N    STEP_BRAKE_UART_TEST_COMPLETE,            // DAC0
N    STEP_BRAKE_UART_TEST_COMMUNICATION_TIME_OUT,  // 
N
N    // 
N    STEP_DERAILLEUR_UART_TEST_ENTRY,               // 
N    STEP_DERAILLEUR_UART_TEST_WAIT_RESPONSE,       // 
N    STEP_DERAILLEUR_UART_TEST_VCC,                 // VCC
N    STEP_DERAILLEUR_UART_TEST_CHECK_VOLTAGE_VALUE, // VCC
N    STEP_DERAILLEUR_UART_TEST_CHECK_DAC1_VALUE,    // DAC
N    STEP_DERAILLEUR_UART_TEST_CHECK_DAC3_VALUE,    // DAC
N    STEP_DERAILLEUR_UART_TEST_CHECK_DAC5_VALUE,    // DAC
N    STEP_DERAILLEUR_UART_TEST_COMPLETE,            // DAC0
N    STEP_DERAILLEUR_UART_TEST_COMMUNICATION_TIME_OUT,  // 
N    
N    // VLK->VLK
N    STEP_VLK_UART_TEST_ENTRY,                   // 
N    STEP_VLK_UART_TEST_WAIT_RESPONSE,           // 
N    STEP_VLK_UART_TEST_VLK,                     // VLK
N    STEP_VLK_UART_TEST_CHECK_VOLTAGE_VALUE,     // VLK
N    STEP_VLK_UART_TEST_COMPLETE,                // 
N    STEP_VLK_UART_TEST_COMMUNICATION_TIME_OUT,  // 
N
N    //  ->  ->  ->   ->   -> DTA -> ->  -> STS ->  ->
N    STEP_CALIBRATION_UART_TEST_ENTRY,                      // 
N    STEP_CALIBRATION_UART_TEST_WAIT_RESPONSE,              // 
N    STEP_CALIBRATION_UART_TEST_GET_CALIBRATION_VOLTAGE,    // 
N    STEP_CALIBRATION_UART_TEST_NOTIFY_POWER_BOARD,         // 
N    STEP_CALIBRATION_UART_TEST_WAIT_ADJUSTMENT,            // 
N    STEP_CALIBRATION_UART_TEST_NOTIFY_VOLTAGE_CALIBRATION, // 
N
N    STEP_CALIBRATION_UART_TEST_TWO_NOTIFY_POWER_BOARD,         // 
N    STEP_CALIBRATION_UART_TEST_TWO_NOTIFY_VOLTAGE_CALIBRATION, // 
N
N    STEP_CALIBRATION_UART_TEST_THREE_NOTIFY_POWER_BOARD,         // 
N    STEP_CALIBRATION_UART_TEST_THREE_NOTIFY_VOLTAGE_CALIBRATION, // 
N    STEP_CALIBRATION_UART_TEST_RESTORE_VOLTAGE_CALIBRATION,
N    STEP_CALIBRATION_UART_TEST_COMPLETE,                   // 
N    STEP_CALIBRATION_UART_TEST_COMMUNICATION_TIME_OUT,     // 
N
N    STEP_UART_CONFIG_PARAMETER_WRITE,         // 
N    STEP_UART_CONFIG_PARAMETER_VALIDATE,      // 
N
N    /* CAN */
N/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
N    // 
N    STEP_HEADLIGHT_CAN_TEST_ENTRY,               // 
N    STEP_HEADLIGHT_CAN_TEST_WAIT_RESPONSE,       // 
N    STEP_HEADLIGHT_CAN_TEST_NOTIFY_DUT,          // DUTDUT
N    STEP_HEADLIGHT_CAN_TEST_OPEN,                // 
N    STEP_HEADLIGHT_CAN_TEST_CHECK_GND_VALUE,     // GND
N    STEP_HEADLIGHT_CAN_TEST_CHECK_VOLTAGE_VALUE, // VCC
N    STEP_HEADLIGHT_CAN_TEST_CHECK_CURRENT_VALUE, // 
N    STEP_HEADLIGHT_CAN_TEST_COMPLETE,            // 
N    STEP_HEADLIGHT_CAN_TEST_COMMUNICATION_TIME_OUT,
N
N    // 
N    STEP_LBEAM_CAN_TEST_ENTRY,               // 
N    STEP_LBEAM_CAN_TEST_WAIT_RESPONSE,       // 
N    STEP_LBEAM_CAN_TEST_NOTIFY_DUT,          // DUTDUT
N    STEP_LBEAM_CAN_TEST_OPEN,                // ,   VCC
N    STEP_LBEAM_CAN_TEST_CHECK_VOLTAGE_VALUE, // VCC
N    STEP_LBEAM_CAN_TEST_CHECK_GND_VALUE,     // GND
N    STEP_LBEAM_CAN_TEST_COMPLETE,            // 
N    STEP_LBEAM_CAN_TEST_COMMUNICATION_TIME_OUT,
N
N    // 
N    STEP_HBEAM_CAN_TEST_ENTRY,               // 
N    STEP_HBEAM_CAN_TEST_WAIT_RESPONSE,       // 
N    STEP_HBEAM_CAN_TEST_NOTIFY_DUT,          // DUTDUT
N    STEP_HBEAM_CAN_TEST_OPEN,                // ,   VCC
N    STEP_HBEAM_CAN_TEST_CHECK_VOLTAGE_VALUE, // VCC
N    STEP_HBEAM_CAN_TEST_CHECK_GND_VALUE,     // GND
N    STEP_HBEAM_CAN_TEST_COMPLETE,            // 
N    STEP_HBEAM_CAN_TEST_COMMUNICATION_TIME_OUT,
N
N    // 
N    STEP_LEFT_TURN_SIGNAL_CAN_TEST_ENTRY,               // 
N    STEP_LEFT_TURN_SIGNAL_CAN_TEST_WAIT_RESPONSE,       // 
N    STEP_LEFT_TURN_SIGNAL_CAN_TEST_NOTIFY_DUT,          // DUTDUT
N    STEP_LEFT_TURN_SIGNAL_CAN_TEST_OPEN,                // 
N    STEP_LEFT_TURN_SIGNAL_CAN_TEST_CHECK_GND_VALUE,     // GND
N    STEP_LEFT_TURN_SIGNAL_CAN_TEST_CHECK_VOLTAGE_VALUE, // VCC
N    STEP_LEFT_TURN_SIGNAL_CAN_TEST_CHECK_CURRENT_VALUE, // 
N    STEP_LEFT_TURN_SIGNAL_CAN_TEST_COMPLETE,            // 
N    STEP_LEFT_TURN_SIGNAL_CAN_TEST_COMMUNICATION_TIME_OUT,  // 
N
N    // 
N    STEP_RIGHT_TURN_SIGNAL_CAN_TEST_ENTRY,               // 
N    STEP_RIGHT_TURN_SIGNAL_CAN_TEST_WAIT_RESPONSE,       // 
N    STEP_RIGHT_TURN_SIGNAL_CAN_TEST_NOTIFY_DUT,          // DUTDUT
N    STEP_RIGHT_TURN_SIGNAL_CAN_TEST_OPEN,                // 
N    STEP_RIGHT_TURN_SIGNAL_CAN_TEST_CHECK_GND_VALUE,     // GND
N    STEP_RIGHT_TURN_SIGNAL_CAN_TEST_CHECK_VOLTAGE_VALUE, // VCC
N    STEP_RIGHT_TURN_SIGNAL_CAN_TEST_CHECK_CURRENT_VALUE, // 
N    STEP_RIGHT_TURN_SIGNAL_CAN_TEST_COMPLETE,            // 
N    STEP_RIGHT_TURN_SIGNAL_CAN_TEST_COMMUNICATION_TIME_OUT,  // 
N
N    // 
N    STEP_THROTTLE_CAN_TEST_ENTRY,               // 
N    STEP_THROTTLE_CAN_TEST_WAIT_RESPONSE,       // 
N    STEP_THROTTLE_CAN_TEST_VCC,                 // VCC
N    STEP_THROTTLE_CAN_TEST_CHECK_VOLTAGE_VALUE, // VCC
N    STEP_THROTTLE_CAN_TEST_CHECK_DAC1_VALUE,    // DAC
N    STEP_THROTTLE_CAN_TEST_CHECK_DAC3_VALUE,    // DAC
N    STEP_THROTTLE_CAN_TEST_CHECK_DAC5_VALUE,    // DAC
N    STEP_THROTTLE_CAN_TEST_COMPLETE,            // DAC0
N    STEP_THROTTLE_CAN_TEST_COMMUNICATION_TIME_OUT,  // 
N
N    // 
N    STEP_BRAKE_CAN_TEST_ENTRY,               // 
N    STEP_BRAKE_CAN_TEST_WAIT_RESPONSE,       // 
N    STEP_BRAKE_CAN_TEST_VCC,                 // VCC
N    STEP_BRAKE_CAN_TEST_CHECK_VOLTAGE_VALUE, // VCC
N    STEP_BRAKE_CAN_TEST_CHECK_DAC1_VALUE,    // DAC
N    STEP_BRAKE_CAN_TEST_CHECK_DAC3_VALUE,    // DAC
N    STEP_BRAKE_CAN_TEST_CHECK_DAC5_VALUE,    // DAC
N    STEP_BRAKE_CAN_TEST_COMPLETE,            // DAC0
N    STEP_BRAKE_CAN_TEST_COMMUNICATION_TIME_OUT,  // 
N
N    // 
N    STEP_DERAILLEUR_CAN_TEST_ENTRY,               // 
N    STEP_DERAILLEUR_CAN_TEST_WAIT_RESPONSE,       // 
N    STEP_DERAILLEUR_CAN_TEST_VCC,                 // VCC
N    STEP_DERAILLEUR_CAN_TEST_CHECK_VOLTAGE_VALUE, // VCC
N    STEP_DERAILLEUR_CAN_TEST_CHECK_DAC1_VALUE,    // DAC
N    STEP_DERAILLEUR_CAN_TEST_CHECK_DAC3_VALUE,    // DAC
N    STEP_DERAILLEUR_CAN_TEST_CHECK_DAC5_VALUE,    // DAC
N    STEP_DERAILLEUR_CAN_TEST_COMPLETE,            // DAC0
N    STEP_DERAILLEUR_CAN_TEST_COMMUNICATION_TIME_OUT,  // 
N    
N    // VLK->VLK
N    STEP_VLK_CAN_TEST_ENTRY,                   // 
N    STEP_VLK_CAN_TEST_WAIT_RESPONSE,           // 
N    STEP_VLK_CAN_TEST_VLK,                     // VLK
N    STEP_VLK_CAN_TEST_CHECK_VOLTAGE_VALUE,     // VLK
N    STEP_VLK_CAN_TEST_COMPLETE,                // 
N    STEP_VLK_CAN_TEST_COMMUNICATION_TIME_OUT,  // 
N
N    //  ->  ->  ->   ->   -> DTA -> ->  -> STS ->  ->
N    STEP_CALIBRATION_CAN_TEST_ENTRY,                      // 
N    STEP_CALIBRATION_CAN_TEST_WAIT_RESPONSE,              // 
N    STEP_CALIBRATION_CAN_TEST_GET_CALIBRATION_VOLTAGE,    // 
N    STEP_CALIBRATION_CAN_TEST_NOTIFY_POWER_BOARD,         // 
N    STEP_CALIBRATION_CAN_TEST_WAIT_ADJUSTMENT,            // 
N    STEP_CALIBRATION_CAN_TEST_NOTIFY_VOLTAGE_CALIBRATION, // 
N
N    STEP_CALIBRATION_CAN_TEST_TWO_NOTIFY_POWER_BOARD,         // 
N    STEP_CALIBRATION_CAN_TEST_TWO_NOTIFY_VOLTAGE_CALIBRATION, // 
N
N    STEP_CALIBRATION_CAN_TEST_THREE_NOTIFY_POWER_BOARD,         // 
N    STEP_CALIBRATION_CAN_TEST_THREE_NOTIFY_VOLTAGE_CALIBRATION, // 
N
N    STEP_CALIBRATION_CAN_TEST_CHECK_CALIBRATION_RESULT,   // 
N    STEP_CALIBRATION_CAN_TEST_CHECK_VOLTAGE_VALUES,       // 
N    STEP_CALIBRATION_CAN_TEST_REPORT_STS_RESULT,          // STS
N    STEP_CALIBRATION_CAN_TEST_REPEAT_CALIBRATION,         // 
N    STEP_CALIBRATION_CAN_TEST_COMPLETE,                   // 
N    STEP_CALIBRATION_CAN_TEST_COMMUNICATION_TIME_OUT,     // 
N
N    STEP_CAN_CONFIG_PARAMETER_WRITE,         // 
N    STEP_CAN_CONFIG_PARAMETER_VALIDATE,      // 
N
N
N    /************************************************************************************/
N
N	// can
N	STEP_GAOBIAO_CAN_UPGRADE_ENTRY,			// 
N	STEP_GAOBIAO_CAN_UPGRADE_CAN_INIT,		// CAN
N	STEP_GAOBIAO_CAN_UPGRADE_POWER_ON,
N	STEP_GAOBIAO_CAN_UPGRADE_WAIT_3S,
N	STEP_GAOBIAO_CAN_UPGRADE_SEND_KEEP_ELECTRICITY,
N	STEP_GAOBIAO_CAN_UPGRADE_SEND_BOOT_CMD,
N	STEP_GAOBIAO_CAN_UPGRADE_ARE_YOU_READY,			// 
N	STEP_GAOBIAO_CAN_UPGRADE_WAITING_FOR_READY,
N	STEP_GAOBIAO_CAN_UPGRADE_SEND_DATA,
N	STEP_GAOBIAO_CAN_UPGRADE_WRITE_ERROR,
N	STEP_GAOBIAO_CAN_UPGRADE_FINISH,
N	STEP_GAOBIAO_CAN_UPGRADE_POWER_OFF,
N	STEP_GAOBIAO_CAN_UPGRADE_TIME_OUT,
N	STEP_GAOBIAO_CAN_UPGRADE_FAILE,
N	
N	// can
N	STEP_CM_CAN_UPGRADE_ENTRY,								// 
N	STEP_CM_CAN_UPGRADE_WAIT_FOR_ACK,    					// dut
N    STEP_CM_CAN_UPGRADE_RESTART,                            // VLK
N	STEP_CM_CAN_UPGRADE_RECEIVE_DUT_ECO_REQUEST,			// duteco
N	STEP_CM_CAN_UPGRADE_UP_ALLOW,							// 
N
N	STEP_CM_CAN_UPGRADE_SEND_UI_EAR,						// ui
N	STEP_CM_CAN_UPGRADE_UI_EAR_RESUALT,						// dutui
N	STEP_CM_CAN_UPGRADE_SEND_UI_WRITE,						// ui
N	STEP_CM_CAN_UPGRADE_UI_UP_SUCCESS,				 		// ui
N	STEP_CM_CAN_UPGRADE_APP_UP_SUCCESS_RESET,               // app
N	STEP_CM_CAN_UPGRADE_APP_UP_SUCCESS_YELLOW,              // app    
N    
N	STEP_CM_CAN_UPGRADE_SEND_APP_EAR,						// app
N	STEP_CM_CAN_UPGRADE_APP_EAR_RESUALT,					// dutapp
N	STEP_CM_CAN_UPGRADE_SEND_APP_WRITE,						// app
N	STEP_CM_CAN_UPGRADE_APP_UP_SUCCESS,						// app
N
N	STEP_CM_CAN_UPGRADE_ITEM_FINISH,						// 
N	
N	STEP_CM_CAN_UPGRADE_COMMUNICATION_TIME_OUT,				// 
N	STEP_CM_CAN_UPGRADE_RECONNECTION,						// 
N	STEP_CM_CAN_UPGRADE_RECONNECTION_TIME_OUT,				// 
N
N	// can
N	STEP_HUAXIN_CAN_UPGRADE_ENTRY,							// 
N	STEP_HUAXIN_CAN_UPGRADE_WAIT_FOR_ACK,					// dut
N	STEP_HUAXIN_CAN_UPGRADE_RECEIVE_DUT_ECO_REQUEST,		// duteco
N	STEP_HUAXIN_CAN_UPGRADE_UP_ALLOW,						// 
N
N	STEP_HUAXIN_CAN_UPGRADE_SEND_APP_EAR,					// app
N	STEP_HUAXIN_CAN_UPGRADE_APP_EAR_RESUALT,				// dutapp
N	STEP_HUAXIN_CAN_UPGRADE_SEND_APP_WRITE,					// app
N	STEP_HUAXIN_CAN_UPGRADE_APP_UP_SUCCESS,					// app
N
N	STEP_HUAXIN_CAN_UPGRADE_SEND_UI_EAR,					// ui
N	STEP_HUAXIN_CAN_UPGRADE_UI_EAR_RESUALT,					// dutui
N	STEP_HUAXIN_CAN_UPGRADE_SEND_UI_WRITE,					// ui
N	STEP_HUAXIN_CAN_UPGRADE_UI_UP_SUCCESS,					// ui
N
N	STEP_HUAXIN_CAN_UPGRADE_ITEM_FINISH,					// 
N
N	STEP_HUAXIN_CAN_UPGRADE_COMMUNICATION_TIME_OUT,				// 
N
N	// can
N	STEP_SEG_CAN_UPGRADE_ENTRY,								// 
N	STEP_SEG_CAN_UPGRADE_WAIT_FOR_ACK,    					// dut
N	STEP_SEG_CAN_UPGRADE_RECEIVE_DUT_ECO_REQUEST,			// duteco
N	STEP_SEG_CAN_UPGRADE_UP_ALLOW,							// 
N
N	STEP_SEG_CAN_UPGRADE_SEND_APP_EAR,						// app
N	STEP_SEG_CAN_UPGRADE_APP_EAR_RESUALT,					// dutapp
N	STEP_SEG_CAN_UPGRADE_SEND_APP_WRITE,					// app
N	STEP_SEG_CAN_UPGRADE_APP_UP_SUCCESS,					// app
N
N	STEP_SEG_CAN_UPGRADE_ITEM_FINISH,						// 
N
N	STEP_SEG_CAN_UPGRADE_COMMUNICATION_TIME_OUT, 			// 
N
N	// can
N	STEP_KAIYANG_CAN_UPGRADE_ENTRY,								// 
N	STEP_KAIYANG_CAN_UPGRADE_WAIT_FOR_ACK,    					// dut
N	STEP_KAIYANG_CAN_UPGRADE_RECEIVE_DUT_ECO_REQUEST,			// duteco
N	STEP_KAIYANG_CAN_UPGRADE_UP_ALLOW,							// 
N
N	
N	STEP_KAIYANG_CAN_UPGRADE_SEND_APP_WRITE,					// app
N	STEP_KAIYANG_CAN_UPGRADE_SEND_APP_AGAIN,					// 
N	STEP_KAIYANG_CAN_UPGRADE_APP_UP_SUCCESS,					// app
N
N	STEP_KAIYANG_CAN_UPGRADE_SEND_UI_WRITE,					// ui
N	STEP_KAIYANG_CAN_UPGRADE_SEND_UI_AGAIN,					// ui
N	STEP_KAIYANG_CAN_UPGRADE_UI_UP_SUCCESS,					// ui
N
N	STEP_KAIYANG_CAN_UPGRADE_ITEM_FINISH,						// 
N
N 	// can
N 	STEP_CAN_SET_CONFIG_ENTRY,								// config
N    STEP_CAN_CONFIG_RESET,                                  // 
N	STEP_CAN_SEND_SET_CONFIG,								// config		
N	STEP_CAN_SET_CONFIG_SUCCESS,							// config
N    STEP_CAN_READ_CONFIG,                                   // 
N    STEP_CAN_VERIFY_CONFIG,                                 // 
N    
N    //
N    STEP_CM_UART_UPGRADE_ENTRY,                         // 		
N    STEP_CM_UART_BC_UPGRADE_WAIT_FOR_ACK,               // dut
N    STEP_CM_UART_BC_UPGRADE_UP_ALLOW,                   // 
N    STEP_CM_UART_BC_UPGRADE_RESTART,                    // VLK
N    STEP_CM_UART_BC_UPGRADE_SEND_APP_EAR,               // app
N    STEP_CM_UART_BC_UPGRADE_SEND_FIRST_APP_PACKET,      // 
N    STEP_CM_UART_BC_UPGRADE_SEND_APP_PACKET,            // app
N    STEP_CM_UART_BC_UPGRADE_APP_UP_SUCCESS,             // app
N
N    STEP_CM_UART_BC_UPGRADE_SEND_UI_EAR,                // ui
N    STEP_CM_UART_BC_UPGRADE_SEND_FIRST_UI_PACKET,       // 
N    STEP_CM_UART_BC_UPGRADE_SEND_UI_PACKET,             // ui
N    STEP_CM_UART_BC_UPGRADE_UI_UP_SUCCESS,              // ui
N
N    STEP_CM_UART_BC_UPGRADE_ITEM_FINISH,                // 
N
N	// 
N	STEP_HUAXIN_UART_UPGRADE_ENTRY,							// 
N	STEP_HUAXIN_UART_BC_UPGRADE_WAIT_FOR_ACK,    				// dut
N	STEP_HUAXIN_UART_BC_UPGRADE_UP_ALLOW,						// 
N
N	STEP_HUAXIN_UART_BC_UPGRADE_SEND_APP_EAR,					// app
N	STEP_HUAXIN_UART_BC_UPGRADE_SEND_FIRST_APP_PACKET,			// 
N	STEP_HUAXIN_UART_BC_UPGRADE_SEND_APP_PACKET,				// app
N	STEP_HUAXIN_UART_BC_UPGRADE_APP_UP_SUCCESS,					// app
N
N	STEP_HUAXIN_UART_BC_UPGRADE_SEND_UI_EAR,					// ui
N	STEP_HUAXIN_UART_BC_UPGRADE_SEND_FIRST_UI_PACKET,			// 
N	STEP_HUAXIN_UART_BC_UPGRADE_SEND_UI_PACKET,					// ui
N	STEP_HUAXIN_UART_BC_UPGRADE_UI_UP_SUCCESS,					// ui
N
N	STEP_HUAXIN_UART_BC_UPGRADE_ITEM_FINISH,					// 
N	
N	// /
N	STEP_SEG_UART_UPGRADE_ENTRY,							// 
N	STEP_CM_UART_SEG_UPGRADE_WAIT_FOR_ACK,    				// dut
N    STEP_CM_UART_SEG_UPGRADE_RESTART,                       // VLK
N	STEP_CM_UART_SEG_UPGRADE_RECEIVE_DUT_ECO_REQUEST,		// duteco
N	STEP_CM_UART_SEG_UPGRADE_UP_ALLOW,						// 
N
N	STEP_CM_UART_SEG_UPGRADE_SEND_APP_EAR,					// app
N	STEP_CM_UART_SEG_UPGRADE_SEND_FIRST_APP_PACKET,			// 
N	STEP_CM_UART_SEG_UPGRADE_SEND_APP_PACKET,				// app
N	STEP_CM_UART_SEG_UPGRADE_APP_UP_SUCCESS,				// app
N	STEP_CM_UART_SEG_UPGRADE_APP_UP_SUCCESS_RESET,          // app
N    
N	STEP_CM_UART_SEG_UPGRADE_ITEM_FINISH,					// 
N
N	// 
N	STEP_KAIYANG_UART_UPGRADE_ENTRY,						// 
N	STEP_KAIYANG_UART_UPGRADE_WAIT_FOR_ACK,    				// dut
N	STEP_KAIYANG_UART_UPGRADE_RECEIVE_DUT_ECO_REQUEST,		// duteco
N	STEP_KAIYANG_UART_UPGRADE_UP_ALLOW,						// 
N
N	
N	STEP_KAIYANG_UART_UPGRADE_SEND_APP_WRITE,				// app
N	STEP_KAIYANG_UART_UPGRADE_SEND_APP_AGAIN,				// 
N	STEP_KAIYANG_UART_UPGRADE_APP_UP_SUCCESS,				// app
N
N	STEP_KAIYANG_UART_UPGRADE_SEND_UI_WRITE,				// ui
N	STEP_KAIYANG_UART_UPGRADE_SEND_UI_AGAIN,				// 
N	STEP_KAIYANG_UART_UPGRADE_UI_UP_SUCCESS,				// ui
N
N	STEP_KAIYANG_UART_UPGRADE_ITEM_FINISH,					// 
N	
N	STEP_KAIYANG_UART_UPGRADE_COMMUNICATION_TIME_OUT,		// 
N
N	// LIME
N	STEP_LIME_UART_UPGRADE_ENTRY,							// 
N	STEP_LIME_UART_SEG_UPGRADE_WAIT_FOR_ACK,    				  // dut
N	STEP_LIME_UART_SEG_UPGRADE_RECEIVE_DUT_ECO_REQUEST,		// duteco
N	STEP_LIME_UART_SEG_UPGRADE_UP_ALLOW,						      // 
N
N	STEP_LIME_UART_SEG_UPGRADE_SEND_APP_EAR,				     	// app
N	STEP_LIME_UART_SEG_UPGRADE_SEND_FIRST_APP_PACKET,			// 
N	STEP_LIME_UART_SEG_UPGRADE_SEND_APP_PACKET,				    // app
N	STEP_LIME_UART_SEG_UPGRADE_APP_UP_SUCCESS,				    // app
N	
N	STEP_LIME_UART_SEG_UPGRADE_ITEM_FINISH,				       	// 
N	
N	STEP_LIME_UART_UPGRADE_COMMUNICATION_TIME_OUT,		// 
N    
N    // 
N    STEP_UART_SET_CONFIG_ENTRY,                              // config
N    STEP_UART_CONFIG_RESET,                                  // 
N    STEP_UART_PROTOCOL_SWITCCH,                              // 
N    STEP_UART_SEND_SET_CONFIG,                               // config
N    STEP_UART_SET_CONFIG_SUCCESS,                            // config
N    STEP_UART_READ_CONFIG,                                   // 
N    STEP_UART_VERIFY_CONFIG,                                 // 
N    
N    STEP_MAX
N} STEP_E;
N
Ntypedef struct
N{
N    STATE_E state;                  // 
N    STATE_E preState;               // 
N
N    STEP_E step;
N} STATE_CB;
N
Nextern STATE_CB stateCB;
N
N
N// 
Nvoid STATE_Init(void);
N
N// 
Nvoid STATE_ResetAutoPowerOffControl(void);
N
N// 
Nvoid STATE_EnterState(uint32 state);
N
N// 
Nvoid STATE_Process(void);
N
N// 
Nvoid STATE_SwitchStep(uint32 param);
N
N// 
Nvoid STEP_Process_PowerUartUpgrade(void);
N/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
N
Nextern BOOL resetFlag;
Nextern BOOL configResetFlag;
Nextern BOOL appResetFlag;
Nextern uint8 verifiedBuff[150];
N#endif
N
N
L 5 "User\key.c" 2
N#include "timer.h"
L 1 "User\timer.h" 1
N#ifndef __TIMER_H__
N#define __TIMER_H__
N
N#include "common.h"
N
N// TIMx
N#define STM32_TIMERx_NUM_DEF					TIMER1					// TIMx()
N#define STM32_TIMERx_IRQn_DEF					TIMER1_IRQn
N
N#define TIMER_TIME								5	// ms
N#define TIMER_LOOP_FOREVER						-1	// 
N
N#define TIMER_TASK_QUEUE_SIZE					15	// 
N
Ntypedef enum
N{
N	TIMER_ID_NULL = -1,
N	
N	TIMER_ID_STATE_CONTROL = 0,							// 
N	
N	// 
N	TIMER_ID_TOOL_APP_TO_BOOT = 1,						// appboot
N
N	// Dut_config
N	TIMER_ID_SET_DUT_CONFIG,
N
N	// dut
N	TIMER_ID_SET_DUT_PROGRESS_REPORT,
N	
N	// 
N	TIMER_ID_TIME_OUT_DETECTION,
N
N	// 
N	TIMER_ID_TIME_GB_POWER_ON,
N
N	// 
N	TIMER_ID_TIME_GB_POWER_OFF,
N
N	// 
N	TIMER_ID_DELAY_ENTER_UP_MODE,
N	
N	// dut
N	TIMER_ID_DUT_TIMEOUT,
N
N	// 
N	TIMER_ID_RECONNECTION,
N
N	// 
N	TIMER_ID_RECONNECTION_TIME_OUT,
N	
N	TIMER_ID_PROTOCOL_55_PARAM_TX,// 55
N
N	TIMER_ID_KEY_SCAN,							// 
N
N	TIMER_ID_KEY_CLICK_FUN,						// 
N	
N	TIMER_ID_RECOVERY_KEY_UP_ADD_DEC,			// +-
N
N	TIMER_ID_RECOVERY_KEY_UP_ADD_INFO,			// +i
N	
N	TIMER_ID_CAN_TEST,
N	
N	TIMER_ID_ONLINE_DETECT,                     // 
N	
N	TIMER_ID_WRITE_FLAG_TIMEOUT,
N	
N	TIMER_ID_OPERATE_VER_TIMEOUT,
N	
N	TIMER_ID_REPORT_OF_IDENTITY,
N	
N	TIMER_ID_SET_DUT_PROGRESS_LCD_REPORT,
N
N    TIMER_ID_PROTOCOL_SWITCCH,                  // 
N
N    TIMER_ID_SHUTDOWN_TEST,                     // 
N     
N    TIMER_ID_CHANGE_LCD_COLOR,                  // LCD    
N
N	TIMER_ID_ADC_SCAN,							// AD
N        
N	TIMER_ID_MAX
N}TIMER_ID;
N
Ntypedef enum
N{
N	ACTION_MODE_DO_AT_ONCE = 0,	// 
N	ACTION_MODE_ADD_TO_QUEUE	// 
N}ACTION_MODE_E;
N
N// 
Ntypedef struct{
N	void(*action)(uint32 param);
N	uint32	param;
N}TIMER_TASK;
N
Ntypedef struct
N{
N	uint32	top[TIMER_ID_MAX];
N	volatile uint32  count[TIMER_ID_MAX];
N	void(*action[TIMER_ID_MAX])(uint32 param);
N	uint32	param[TIMER_ID_MAX];
N	int32  loopCount[TIMER_ID_MAX];
N	uint8  actionMode[TIMER_ID_MAX];		// 
N	BOOL active[TIMER_ID_MAX];				// 
N
N	// 
N	struct{
N		TIMER_TASK task[TIMER_TASK_QUEUE_SIZE];
X		TIMER_TASK task[15];
N		uint8 head;
N		uint8 end;
N	}queue;
N}TIMER_CB;
N
N
Nvoid TIMER_Init(void);
N
NBOOL TIMER_AddTask(TIMER_ID id, uint32 time, void(*action)(uint32 param), uint32 param, int32 actionTime, ACTION_MODE_E actionMode);
N
Nvoid TIMER_KillTask(TIMER_ID id);
N
N// 
NBOOL TIMER_AddToQueue(void(*action)(uint32 param), uint32 param);
N
N// main
Nvoid TIMER_TaskQueueProcess(void);
N
N// 
Nvoid TIMER_CALLBACK_OnTimer(void);
N
N// 
Nvoid TIMER_Pause(TIMER_ID id);
N
N// 
Nvoid TIMER_Resume(TIMER_ID id);
N
N// 
Nvoid TIMER_KillAllTimer(void);
N
N// 
Nvoid TIMER_ResetTimer(TIMER_ID id);
N
N// 
NBOOL TIMER_ChangeTime(TIMER_ID id, uint32 time);
N
N
N#endif
N
L 6 "User\key.c" 2
N#include "param.h"
L 1 "User\param.h" 1
N#ifndef __PARAM_H__
N#define __PARAM_H__
N
N#include "common.h"
N
N// 
Nvoid PARAM_Init(void);
N
N#endif
L 7 "User\key.c" 2
N
NKEY_CB keyCB;
N
Nvoid KEY_Init(void)
N{
N    rcu_periph_clock_enable(KEY_CHECK_RCU_PORT);
X    rcu_periph_clock_enable(RCU_GPIOC);
N    gpio_init(KEY_CHECK_PORT, GPIO_MODE_IPU, GPIO_OSPEED_50MHZ, KEY_CHECK_PIN);
X    gpio_init(((((uint32_t)0x40010000U) + 0x00000800U) + 0x00000800U), ((uint8_t)0x48U), ((uint8_t)0x03U), ((uint32_t)((uint32_t)0x01U<<(13))));
N
N    // KEYMSG_RegisterKeyScanCallback()
N    KEYMSG_Init();
N
N    // 
N    KEYMSG_RegisterKeyScanCallback(KEY_CALLBACK_Scan);
N		
N		memset(keyCB.buff,      0xff, KEY_NAME_MAX);
N		memset(keyCB.lastValue, 0xff, KEY_NAME_MAX);
N		
N}
N
N//// +-
N//void KEY_CALLBACK_ClearAddDecKeyUpMaskRequest(uint32 param)
N//{
N//    // +-
N//    KEYMSG_ClearMaskRequest(KEY_NAME_ADD, KEY_MSG_UP);
N//    KEYMSG_ClearMaskRequest(KEY_NAME_DEC, KEY_MSG_UP);
N
N//    // +
N//    keyMsgCB.addKeyInvalidRequest = FALSE;
N//}
N
N//// +i
N//void KEY_CALLBACK_ClearAddInfoKeyUpMaskRequest(uint32 param)
N//{
N//    // +i
N//    KEYMSG_ClearMaskRequest(KEY_NAME_ADD, KEY_MSG_UP);
N//    KEYMSG_ClearMaskRequest(KEY_NAME_INFO, KEY_MSG_UP);
N
N//    // +
N//    keyMsgCB.addKeyInvalidRequest = FALSE;
N//}
N
Nuint8 keyRead = 0;
Nvoid KEY_CALLBACK_Scan(uint8 *p8bitKeyValueArray)
N{
N    uint8 keyMask = 0x07;
N//    uint8 keyAddDecMask = 0x03;     // 
N//    uint8 keyAddInfo = 0x05;        // +,i
N    uint8 mask = (0xFF >> (8 - KEY_FILTER_LEVEL_N)); //
X    uint8 mask = (0xFF >> (8 - 3)); 
N    uint8 i;
N    uint8 keyValue = 0;
N
N    keyRead = gpio_input_bit_get(KEY_CHECK_PORT, KEY_CHECK_PIN); // 
X    keyRead = gpio_input_bit_get(((((uint32_t)0x40010000U) + 0x00000800U) + 0x00000800U), ((uint32_t)((uint32_t)0x01U<<(13)))); 
N//  keyRead <<= 1;
N//  keyRead |= GPIO_ReadInputDataBit(GPIOA, GPIO_PIN_15);//-
N//  keyRead <<= 1;
N//  keyRead |= GPIO_ReadInputDataBit(GPIOB, GPIO_PIN_3);//+
N
N    // 
N    //   eg:keyRead=111  
N    for (i = 0; i < KEY_NAME_MAX; i++) //5-3=2  -1
N    {
N        // 
N        keyCB.buff[i] <<= 1;
N        keyCB.buff[i] |= (keyRead >> i) & 0x01;
N    }
N
N    // NN
N    for (i = 0; i < KEY_NAME_MAX; i++)
N    {
N        // N1
N        if ((keyCB.buff[i] & mask) == mask)
N        {
N            keyCB.lastValue[i] = 0x01 << i;
N        }
N        // N0
N        else if (0 == (keyCB.buff[i] & mask))
N        {
N            keyCB.lastValue[i] = 0;
N        }
N        // 
N        else
N        {}
N
N        keyValue |= keyCB.lastValue[i];
N    }
N
N//  PARAM_SetKeyValue(keyRead);
N
N    // 
N    keyValue |= 0x18;
N
N    // 
N    if (keyMask == (keyValue & keyMask))
N    {
N        // 
N        KEYMSG_ClearGlobalMaskRequest();
N
N//        // +-UP
N//        if (KEYMSG_GetAddDecKeyUpRecoveryRequest())
N//        {
N//            KEYMSG_SetAddDecKeyUpRecoveryRequest(FALSE);
N
N//            // +-
N//            TIMER_AddTask(TIMER_ID_RECOVERY_KEY_UP_ADD_DEC,
N//                          KEY_SCAN_TIME * 2,
N//                          KEY_CALLBACK_ClearAddDecKeyUpMaskRequest,
N//                          TRUE,
N//                          1,
N//                          ACTION_MODE_ADD_TO_QUEUE);
N//        }
N
N//        // + iUP
N//        if (KEYMSG_GetAddInfoKeyUpRecoveryRequest())
N//        {
N//            KEYMSG_SetAddInfoKeyUpRecoveryRequest(FALSE);
N
N//            // +i
N//            TIMER_AddTask(TIMER_ID_RECOVERY_KEY_UP_ADD_INFO,
N//                          KEY_SCAN_TIME * 2,
N//                          KEY_CALLBACK_ClearAddInfoKeyUpMaskRequest,
N//                          TRUE,
N//                          1,
N//                          ACTION_MODE_ADD_TO_QUEUE);
N//        }
N    }
N
N//    // (bit0, +; bit1, -; bit2, i)
N//    if (0 == (keyValue & keyAddDecMask))
N//    {
N//        // +-
N//        KEYMSG_SetAddDecKeyUpRecoveryRequest(TRUE);
N
N//        // +
N////      if (PARAM_IsPushAssistOn())
N////      {
N////          return;
N////      }
N
N//        // 
N//        keyValue &= ~KEY_MASK_ADD_DEC;
N
N//        // 
N//        keyValue |= keyAddDecMask;
N
N//        // 
N//        KEYMSG_SetMaskRequest(KEY_NAME_ADD, KEY_MSG_UP);
N//        KEYMSG_SetMaskRequest(KEY_NAME_DEC, KEY_MSG_UP);
N//    }
N
N//    // +,i(bit0, +; bit1, -; bit2, i)
N//    if (0 == (keyValue & keyAddInfo))
N//    {
N//        // +-
N//        KEYMSG_SetAddInfoKeyUpRecoveryRequest(TRUE);
N
N//        // 
N//        keyValue &= ~KEY_MASK_ADD_INFO;
N
N//        // 
N//        keyValue |= keyAddInfo;
N
N//        // i
N//        KEYMSG_SetMaskRequest(KEY_NAME_ADD, KEY_MSG_UP);
N//        KEYMSG_SetMaskRequest(KEY_NAME_INFO, KEY_MSG_UP);
N//    }
N    *p8bitKeyValueArray = keyValue;
N
N    // 
N//  if (keyValue != KEY_MASK_ALL)
N//  {
N//      // 
N//      STATE_ResetAutoPowerOffControl();
N//  }
N}
