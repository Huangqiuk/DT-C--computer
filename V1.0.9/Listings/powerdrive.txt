; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\powerdrive.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\powerdrive.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -I.\User\qrencode -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.3\Device\Include -D__MICROLIB -D__UVISION_VERSION=539 -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\powerdrive.crf User\PowerDrive.c]
                          THUMB

                          AREA ||i.POWER_UART_AddTxArray||, CODE, READONLY, ALIGN=2

                  POWER_UART_AddTxArray PROC
;;;310    // 向发送缓冲区中添加一条待发送序列
;;;311    BOOL POWER_UART_AddTxArray(uint16 id, uint8 *pArray, uint16 length)
000000  b570              PUSH     {r4-r6,lr}
;;;312    {
;;;313        uint16 i;
;;;314        uint16 head = POWERUartCB.tx.head;
000002  4c1b              LDR      r4,|L1.112|
000004  f8b454d4          LDRH     r5,[r4,#0x4d4]  ; POWERUartCB
;;;315        uint16 end = POWERUartCB.tx.end;
000008  f8b434d6          LDRH     r3,[r4,#0x4d6]  ; POWERUartCB
;;;316    
;;;317        // 参数检验
;;;318        if ((NULL == pArray) || (0 == length))
00000c  2900              CMP      r1,#0
00000e  d007              BEQ      |L1.32|
000010  b132              CBZ      r2,|L1.32|
;;;319        {
;;;320            return FALSE;
;;;321        }
;;;322    
;;;323        // 发送缓冲区已满，不予接收
;;;324        if ((end + 1) % POWER_UART_DRIVE_TX_QUEUE_SIZE == head)
000012  1c5e              ADDS     r6,r3,#1
000014  f0060607          AND      r6,r6,#7
000018  42ae              CMP      r6,r5
00001a  d103              BNE      |L1.36|
;;;325        {
;;;326            return FALSE;
00001c  2000              MOVS     r0,#0
;;;327        }
;;;328    
;;;329        POWERUartCB.tx.cmdQueue[end].deviceID = id;
;;;330        for (i = 0; i < length; i++)
;;;331        {
;;;332            POWERUartCB.tx.cmdQueue[end].buff[i] = *pArray++;
;;;333        }
;;;334        POWERUartCB.tx.cmdQueue[end].length = length;
;;;335    
;;;336        // 发送环形队列更新位置
;;;337        POWERUartCB.tx.end++;
;;;338        POWERUartCB.tx.end %= POWER_UART_DRIVE_TX_QUEUE_SIZE;
;;;339        POWERUartCB.tx.cmdQueue[POWERUartCB.tx.end].length = 0;
;;;340    
;;;341        return TRUE;
;;;342    }
00001e  bd70              POP      {r4-r6,pc}
                  |L1.32|
000020  2000              MOVS     r0,#0                 ;320
000022  bd70              POP      {r4-r6,pc}
                  |L1.36|
000024  254d              MOVS     r5,#0x4d              ;329
000026  436b              MULS     r3,r5,r3              ;329
000028  eb040343          ADD      r3,r4,r3,LSL #1       ;329
00002c  8098              STRH     r0,[r3,#4]            ;329
00002e  2000              MOVS     r0,#0                 ;330
000030  e005              B        |L1.62|
                  |L1.50|
000032  181e              ADDS     r6,r3,r0              ;332
000034  f8115b01          LDRB     r5,[r1],#1            ;332
000038  71b5              STRB     r5,[r6,#6]            ;332
00003a  1c40              ADDS     r0,r0,#1              ;330
00003c  b280              UXTH     r0,r0                 ;330
                  |L1.62|
00003e  4290              CMP      r0,r2                 ;330
000040  d3f7              BCC      |L1.50|
000042  f8a3209c          STRH     r2,[r3,#0x9c]         ;334
000046  f20444d6          ADD      r4,r4,#0x4d6          ;337
00004a  8820              LDRH     r0,[r4,#0]            ;337  ; POWERUartCB
00004c  1c40              ADDS     r0,r0,#1              ;337
00004e  8020              STRH     r0,[r4,#0]            ;337
000050  8820              LDRH     r0,[r4,#0]            ;338  ; POWERUartCB
000052  f0000007          AND      r0,r0,#7              ;338
000056  8020              STRH     r0,[r4,#0]            ;338
000058  8820              LDRH     r0,[r4,#0]            ;339  ; POWERUartCB
00005a  2100              MOVS     r1,#0                 ;339
00005c  224d              MOVS     r2,#0x4d              ;339
00005e  f2a444d6          SUB      r4,r4,#0x4d6          ;339
000062  4350              MULS     r0,r2,r0              ;339
000064  eb040040          ADD      r0,r4,r0,LSL #1       ;339
000068  f8a0109c          STRH     r1,[r0,#0x9c]         ;339
00006c  2001              MOVS     r0,#1                 ;341
00006e  bd70              POP      {r4-r6,pc}
                          ENDP

                  |L1.112|
                          DCD      ||area_number.13||

                          AREA ||i.POWER_UART_BC_SendData||, CODE, READONLY, ALIGN=2

                  POWER_UART_BC_SendData PROC
;;;176    // 阻塞发送一个字节数据
;;;177    void POWER_UART_BC_SendData(uint8 data)
000000  b570              PUSH     {r4-r6,lr}
;;;178    {
000002  4605              MOV      r5,r0
;;;179        // 防止丢失第一个字节(清除空标志位,务必加)
;;;180        usart_flag_get(POWER_UART_TYPE_DEF, USART_FLAG_TC);
000004  4c07              LDR      r4,|L2.36|
000006  2106              MOVS     r1,#6
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       usart_flag_get
;;;181    
;;;182        // 填充数据
;;;183        usart_data_transmit(POWER_UART_TYPE_DEF, data);
00000e  4629              MOV      r1,r5
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       usart_data_transmit
                  |L2.22|
;;;184    
;;;185        // 未发送完，持续等待
;;;186        while (usart_flag_get(POWER_UART_TYPE_DEF, USART_FLAG_TC) != SET);
000016  2106              MOVS     r1,#6
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       usart_flag_get
00001e  2801              CMP      r0,#1
000020  d1f9              BNE      |L2.22|
;;;187    }
000022  bd70              POP      {r4-r6,pc}
;;;188    
                          ENDP

                  |L2.36|
                          DCD      0x40004800

                          AREA ||i.POWER_UART_DataStructureInit||, CODE, READONLY, ALIGN=2

                  POWER_UART_DataStructureInit PROC
;;;66     // 数据结构初始化
;;;67     void POWER_UART_DataStructureInit(POWER_UART_CB *pCB)
000000  2800              CMP      r0,#0
;;;68     {
000002  d016              BEQ      |L3.50|
;;;69         uint16 i;
;;;70     
;;;71         // 参数合法性检验
;;;72         if (NULL == pCB)
;;;73         {
;;;74             return;
;;;75         }
;;;76     
;;;77         pCB->tx.txBusy = FALSE;
000004  2200              MOVS     r2,#0
000006  f88024da          STRB     r2,[r0,#0x4da]
;;;78         pCB->tx.index = 0;
00000a  f8a024d8          STRH     r2,[r0,#0x4d8]
;;;79         pCB->tx.head = 0;
00000e  f8a024d4          STRH     r2,[r0,#0x4d4]
;;;80         pCB->tx.end = 0;
000012  f8a024d6          STRH     r2,[r0,#0x4d6]
;;;81         for (i = 0; i < POWER_UART_DRIVE_TX_QUEUE_SIZE; i++)
000016  2100              MOVS     r1,#0
                  |L3.24|
;;;82         {
;;;83             pCB->tx.cmdQueue[i].length = 0;
000018  234d              MOVS     r3,#0x4d
00001a  434b              MULS     r3,r1,r3
00001c  eb000343          ADD      r3,r0,r3,LSL #1
000020  f8a3209c          STRH     r2,[r3,#0x9c]
000024  1c49              ADDS     r1,r1,#1              ;81
000026  b289              UXTH     r1,r1                 ;81
000028  2908              CMP      r1,#8                 ;81
00002a  d3f5              BCC      |L3.24|
;;;84         }
;;;85     
;;;86         POWERUartCB.rcvBleMacOK = FALSE;
00002c  4801              LDR      r0,|L3.52|
00002e  f8802524          STRB     r2,[r0,#0x524]
                  |L3.50|
;;;87     }
000032  4770              BX       lr
;;;88     
                          ENDP

                  |L3.52|
                          DCD      ||area_number.13||

                          AREA ||i.POWER_UART_HwInit||, CODE, READONLY, ALIGN=2

                  POWER_UART_HwInit PROC
;;;35     // UART初始化
;;;36     void POWER_UART_HwInit(uint32 baud)
000000  b570              PUSH     {r4-r6,lr}
;;;37     {
000002  4605              MOV      r5,r0
;;;38         // 打开时钟
;;;39         rcu_periph_clock_enable(RCU_GPIOB);
000004  f2406003          MOV      r0,#0x603
000008  f7fffffe          BL       rcu_periph_clock_enable
;;;40         gpio_init(GPIOB, GPIO_MODE_AF_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_10); // TX
00000c  4c22              LDR      r4,|L4.152|
00000e  f44f6380          MOV      r3,#0x400
000012  2203              MOVS     r2,#3
000014  2118              MOVS     r1,#0x18
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       gpio_init
;;;41     
;;;42         gpio_init(GPIOB, GPIO_MODE_IPU, GPIO_OSPEED_50MHZ, GPIO_PIN_11);  //RX
00001c  14e3              ASRS     r3,r4,#19
00001e  2203              MOVS     r2,#3
000020  2148              MOVS     r1,#0x48
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       gpio_init
;;;43     
;;;44         // UART时钟配置
;;;45         rcu_periph_clock_enable(RCU_USART2);
000028  f2407012          MOV      r0,#0x712
00002c  f7fffffe          BL       rcu_periph_clock_enable
;;;46         usart_deinit(POWER_UART_TYPE_DEF); // 复位串口
000030  4c1a              LDR      r4,|L4.156|
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       usart_deinit
;;;47     
;;;48         // 串口配置
;;;49         usart_baudrate_set(POWER_UART_TYPE_DEF, baud);                        // 波特率
000038  4629              MOV      r1,r5
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       usart_baudrate_set
;;;50         usart_word_length_set(POWER_UART_TYPE_DEF, USART_WL_8BIT);            // 8位数据位
000040  2100              MOVS     r1,#0
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       usart_word_length_set
;;;51         usart_stop_bit_set(POWER_UART_TYPE_DEF, USART_STB_1BIT);                  // 一个停止位
000048  2100              MOVS     r1,#0
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       usart_stop_bit_set
;;;52         usart_parity_config(POWER_UART_TYPE_DEF, USART_PM_NONE);                  // 无奇偶校验
000050  2100              MOVS     r1,#0
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       usart_parity_config
;;;53         usart_hardware_flow_rts_config(POWER_UART_TYPE_DEF, USART_RTS_DISABLE); // 无硬件数据流控制
000058  2100              MOVS     r1,#0
00005a  4620              MOV      r0,r4
00005c  f7fffffe          BL       usart_hardware_flow_rts_config
;;;54         usart_hardware_flow_cts_config(POWER_UART_TYPE_DEF, USART_CTS_DISABLE);
000060  2100              MOVS     r1,#0
000062  4620              MOV      r0,r4
000064  f7fffffe          BL       usart_hardware_flow_cts_config
;;;55         usart_transmit_config(POWER_UART_TYPE_DEF, USART_TRANSMIT_ENABLE); // 使能发射
000068  2108              MOVS     r1,#8
00006a  4620              MOV      r0,r4
00006c  f7fffffe          BL       usart_transmit_config
;;;56         usart_receive_config(POWER_UART_TYPE_DEF, USART_RECEIVE_ENABLE);     // 使能接收
000070  2104              MOVS     r1,#4
000072  4620              MOV      r0,r4
000074  f7fffffe          BL       usart_receive_config
;;;57     
;;;58         // 中断配置
;;;59         nvic_irq_enable(POWER_UART_IRQn_DEF, 2, 1);
000078  2201              MOVS     r2,#1
00007a  2102              MOVS     r1,#2
00007c  2027              MOVS     r0,#0x27
00007e  f7fffffe          BL       nvic_irq_enable
;;;60     
;;;61         usart_interrupt_enable(POWER_UART_TYPE_DEF, USART_INT_RBNE); // 开启中断
000082  f2403105          MOV      r1,#0x305
000086  4620              MOV      r0,r4
000088  f7fffffe          BL       usart_interrupt_enable
;;;62     
;;;63         usart_enable(POWER_UART_TYPE_DEF); // 使能串口
00008c  4620              MOV      r0,r4
00008e  e8bd4070          POP      {r4-r6,lr}
000092  f7ffbffe          B.W      usart_enable
;;;64     }
;;;65     
                          ENDP

000096  0000              DCW      0x0000
                  |L4.152|
                          DCD      0x40010c00
                  |L4.156|
                          DCD      0x40004800

                          AREA ||i.POWER_UART_IR_StartSendData||, CODE, READONLY, ALIGN=2

                  POWER_UART_IR_StartSendData PROC
;;;163    // 启动中断字节发送
;;;164    void POWER_UART_IR_StartSendData(uint8 data)
000000  b570              PUSH     {r4-r6,lr}
;;;165    {
000002  4605              MOV      r5,r0
;;;166        // 先读SR，再填充DR会把TC标志清掉
;;;167        usart_flag_get(POWER_UART_TYPE_DEF, USART_FLAG_TC);
000004  4c07              LDR      r4,|L5.36|
000006  2106              MOVS     r1,#6
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       usart_flag_get
;;;168    
;;;169        // 发送一个字节
;;;170        usart_data_transmit(POWER_UART_TYPE_DEF, data);
00000e  4629              MOV      r1,r5
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       usart_data_transmit
;;;171    
;;;172        // 打开发送完成中断
;;;173        usart_interrupt_enable(POWER_UART_TYPE_DEF, USART_INT_TC);
000016  4620              MOV      r0,r4
000018  e8bd4070          POP      {r4-r6,lr}
00001c  f2403106          MOV      r1,#0x306
000020  f7ffbffe          B.W      usart_interrupt_enable
;;;174    }
;;;175    
                          ENDP

                  |L5.36|
                          DCD      0x40004800

                          AREA ||i.POWER_UART_Init||, CODE, READONLY, ALIGN=2

                  POWER_UART_Init PROC
;;;287    // UART初始化
;;;288    void POWER_UART_Init(void)
000000  b510              PUSH     {r4,lr}
;;;289    {
;;;290        // POWER串口初始化
;;;291        POWER_UART_HwInit(POWER_UART_BAUD_RATE);
000002  f44f30e1          MOV      r0,#0x1c200
000006  f7fffffe          BL       POWER_UART_HwInit
;;;292    
;;;293        // POWER数据结构初始化
;;;294        POWER_UART_DataStructureInit(&POWERUartCB);
00000a  e8bd4010          POP      {r4,lr}
00000e  4801              LDR      r0,|L6.20|
000010  f7ffbffe          B.W      POWER_UART_DataStructureInit
;;;295    }
;;;296    
                          ENDP

                  |L6.20|
                          DCD      ||area_number.13||

                          AREA ||i.POWER_UART_Process||, CODE, READONLY, ALIGN=2

                  POWER_UART_Process PROC
;;;297    // UART模块处理入口
;;;298    void POWER_UART_Process(void)
000000  4801              LDR      r0,|L7.8|
;;;299    {
;;;300        // 发送处理
;;;301        POWER_UART_TxProcess(&POWERUartCB);
000002  f7ffbffe          B.W      POWER_UART_TxProcess
;;;302    }
;;;303    
                          ENDP

000006  0000              DCW      0x0000
                  |L7.8|
                          DCD      ||area_number.13||

                          AREA ||i.POWER_UART_RegisterDataSendService||, CODE, READONLY, ALIGN=2

                  POWER_UART_RegisterDataSendService PROC
;;;304    // 注册数据抛出接口服务
;;;305    void POWER_UART_RegisterDataSendService(void (*service)(uint16 id, uint8 *pData, uint16 length))
000000  4901              LDR      r1,|L8.8|
;;;306    {
;;;307        POWERUartCB.receiveDataThrowService = service;
000002  6008              STR      r0,[r1,#0]  ; POWERUartCB
;;;308    }
000004  4770              BX       lr
;;;309    
                          ENDP

000006  0000              DCW      0x0000
                  |L8.8|
                          DCD      ||area_number.13||

                          AREA ||i.POWER_UART_TxProcess||, CODE, READONLY, ALIGN=1

                  POWER_UART_TxProcess PROC
;;;89     // 发送处理
;;;90     void POWER_UART_TxProcess(POWER_UART_CB *pCB)
000000  b510              PUSH     {r4,lr}
;;;91     {
000002  4604              MOV      r4,r0
;;;92     // 中断方式
;;;93     #if (POWER_UART_TX_MODE == POWER_UART_INTERRUPT_TX_MODE)
;;;94         uint16 index = pCB->tx.index;                          // 当前发送数据的索引号
000004  f8b404d8          LDRH     r0,[r4,#0x4d8]
;;;95         uint16 length = pCB->tx.cmdQueue[pCB->tx.head].length; // 当前发送的命令帧的长度
000008  f8b414d4          LDRH     r1,[r4,#0x4d4]
00000c  224d              MOVS     r2,#0x4d
00000e  4351              MULS     r1,r2,r1
000010  eb040141          ADD      r1,r4,r1,LSL #1
000014  f8b1209c          LDRH     r2,[r1,#0x9c]
;;;96         uint16 head = pCB->tx.head;                            // 发送命令帧队列头索引号
000018  f8b414d4          LDRH     r1,[r4,#0x4d4]
;;;97         uint16 end = pCB->tx.end;                              // 发送命令帧队列尾索引号
00001c  f8b434d6          LDRH     r3,[r4,#0x4d6]
;;;98     
;;;99         // 参数合法性检验
;;;100        if (NULL == pCB)
000020  2c00              CMP      r4,#0
000022  d017              BEQ      |L9.84|
;;;101        {
;;;102            return;
;;;103        }
;;;104    
;;;105        // 队列为空，不处理
;;;106        if (head == end)
000024  4299              CMP      r1,r3
000026  d015              BEQ      |L9.84|
;;;107        {
;;;108            return;
;;;109        }
;;;110    
;;;111        // 发送忙，退出
;;;112        if (pCB->tx.txBusy)
000028  f89434da          LDRB     r3,[r4,#0x4da]
00002c  2b00              CMP      r3,#0
00002e  d111              BNE      |L9.84|
;;;113        {
;;;114            return;
;;;115        }
;;;116    
;;;117        // ■■执行到这里，说明队列非空■■
;;;118    
;;;119        // 当前命令帧未发送完时，取出一个字节放到发送寄存器中
;;;120        if (index < length)
000030  4290              CMP      r0,r2
000032  d20f              BCS      |L9.84|
;;;121        {
;;;122            POWER_UART_IR_StartSendData(pCB->tx.cmdQueue[head].buff[pCB->tx.index++]);
000034  f8b404d8          LDRH     r0,[r4,#0x4d8]
000038  1c42              ADDS     r2,r0,#1
00003a  f8a424d8          STRH     r2,[r4,#0x4d8]
00003e  224d              MOVS     r2,#0x4d
000040  4351              MULS     r1,r2,r1
000042  eb040141          ADD      r1,r4,r1,LSL #1
000046  4408              ADD      r0,r0,r1
000048  7980              LDRB     r0,[r0,#6]
00004a  f7fffffe          BL       POWER_UART_IR_StartSendData
;;;123    
;;;124            // 设置发送忙状态
;;;125            pCB->tx.txBusy = TRUE;
00004e  2001              MOVS     r0,#1
000050  f88404da          STRB     r0,[r4,#0x4da]
                  |L9.84|
;;;126        }
;;;127    
;;;128    // 阻塞方式时启动发送
;;;129    #else
;;;130        uint16 index = pCB->tx.index;
;;;131        uint16 head = pCB->tx.head;
;;;132        uint16 end = pCB->tx.end;
;;;133    
;;;134        // 参数合法性检验
;;;135        if (NULL == pCB)
;;;136        {
;;;137            return;
;;;138        }
;;;139    
;;;140        // 队列为空，不处理
;;;141        if (head == end)
;;;142        {
;;;143            return;
;;;144        }
;;;145    
;;;146        // 当前命令帧未发送完时，持续发送
;;;147        while (index < pCB->tx.cmdQueue[head].length)
;;;148        {
;;;149            // 一直填充发送
;;;150            POWER_UART_BC_SendData(pCB->tx.cmdQueue[head].buff[pCB->tx.index++]);
;;;151    
;;;152            index = pCB->tx.index;
;;;153        }
;;;154    
;;;155        // 当前命令帧发送完时，删除之
;;;156        pCB->tx.cmdQueue[head].length = 0;
;;;157        pCB->tx.head++;
;;;158        pCB->tx.head %= POWER_UART_DRIVE_TX_QUEUE_SIZE;
;;;159        pCB->tx.index = 0;
;;;160    #endif
;;;161    }
000054  bd10              POP      {r4,pc}
;;;162    
                          ENDP


                          AREA ||i.USART2_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART2_IRQHandler PROC
;;;207     *************************************************************/
;;;208    void USART2_IRQHandler(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;209    {
;;;210        // 判断DR是否有数据，中断接收
;;;211        if (usart_interrupt_flag_get(POWER_UART_TYPE_DEF, USART_INT_FLAG_RBNE) != RESET)
000002  4d35              LDR      r5,|L10.216|
000004  4933              LDR      r1,|L10.212|
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       usart_interrupt_flag_get
;;;212        {
;;;213            uint8 rxdata = 0x00;
;;;214    
;;;215            // 接收数据
;;;216            rxdata = (uint8)usart_data_receive(POWER_UART_TYPE_DEF);
;;;217    
;;;218            if (NULL != POWERUartCB.receiveDataThrowService)
00000c  4c33              LDR      r4,|L10.220|
00000e  2600              MOVS     r6,#0                 ;211
000010  b158              CBZ      r0,|L10.42|
000012  9600              STR      r6,[sp,#0]            ;213
000014  4628              MOV      r0,r5                 ;216
000016  f7fffffe          BL       usart_data_receive
00001a  9000              STR      r0,[sp,#0]            ;216
00001c  6823              LDR      r3,[r4,#0]  ; POWERUartCB
00001e  b123              CBZ      r3,|L10.42|
;;;219            {
;;;220                (*POWERUartCB.receiveDataThrowService)(0xFFF, &rxdata, 1);
000020  2201              MOVS     r2,#1
000022  4669              MOV      r1,sp
000024  f64070ff          MOV      r0,#0xfff
000028  4798              BLX      r3
                  |L10.42|
;;;221            }
;;;222    
;;;223            if (!POWERUartCB.rcvBleMacOK)
;;;224            {
;;;225                //          BLE_UART_AtChannelDataProcess(rxdata);
;;;226            }
;;;227    
;;;228        }
;;;229    
;;;230    // 中断模式发送
;;;231    #if (POWER_UART_TX_MODE == POWER_UART_INTERRUPT_TX_MODE)
;;;232        // 判断DR是否有数据，中断发送
;;;233        if (usart_interrupt_flag_get(POWER_UART_TYPE_DEF, USART_INT_FLAG_TC) != RESET)
00002a  492d              LDR      r1,|L10.224|
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       usart_interrupt_flag_get
000032  b3b0              CBZ      r0,|L10.162|
;;;234        {
;;;235            uint16 head = POWERUartCB.tx.head;
000034  f8b404d4          LDRH     r0,[r4,#0x4d4]  ; POWERUartCB
;;;236            uint16 end;
;;;237            uint16 index = POWERUartCB.tx.index;
000038  f8b414d8          LDRH     r1,[r4,#0x4d8]  ; POWERUartCB
;;;238            uint8 txdata = 0x00;
;;;239    
;;;240            // 执行到这里，说明上一个数据已经发送完毕，当前命令帧未发送完时，取出一个字节放到发送寄存器中
;;;241            if (index < POWERUartCB.tx.cmdQueue[head].length)
00003c  224d              MOVS     r2,#0x4d
00003e  4350              MULS     r0,r2,r0
000040  eb040240          ADD      r2,r4,r0,LSL #1
000044  f8b2009c          LDRH     r0,[r2,#0x9c]
000048  4288              CMP      r0,r1
00004a  d90a              BLS      |L10.98|
;;;242            {
;;;243                txdata = POWERUartCB.tx.cmdQueue[head].buff[POWERUartCB.tx.index++];
00004c  f8b414d8          LDRH     r1,[r4,#0x4d8]  ; POWERUartCB
000050  1c48              ADDS     r0,r1,#1
000052  f8a404d8          STRH     r0,[r4,#0x4d8]
000056  1888              ADDS     r0,r1,r2
000058  7981              LDRB     r1,[r0,#6]
;;;244    
;;;245                // 填充数据
;;;246                usart_data_transmit(POWER_UART_TYPE_DEF, txdata);
00005a  4628              MOV      r0,r5
00005c  f7fffffe          BL       usart_data_transmit
000060  e027              B        |L10.178|
                  |L10.98|
;;;247            }
;;;248            // 当前命令帧发送完时，删除之
;;;249            else
;;;250            {
;;;251                POWERUartCB.tx.cmdQueue[head].length = 0;
000062  f8a2609c          STRH     r6,[r2,#0x9c]
;;;252                POWERUartCB.tx.head++;
000066  f20444d4          ADD      r4,r4,#0x4d4
00006a  8820              LDRH     r0,[r4,#0]  ; POWERUartCB
00006c  1c40              ADDS     r0,r0,#1
00006e  8020              STRH     r0,[r4,#0]
;;;253                POWERUartCB.tx.head %= POWER_UART_DRIVE_TX_QUEUE_SIZE;
000070  8820              LDRH     r0,[r4,#0]  ; POWERUartCB
000072  f0000007          AND      r0,r0,#7
000076  8020              STRH     r0,[r4,#0]
;;;254                POWERUartCB.tx.index = 0;
000078  80a6              STRH     r6,[r4,#4]
;;;255    
;;;256                head = POWERUartCB.tx.head;
00007a  8822              LDRH     r2,[r4,#0]  ; POWERUartCB
;;;257                end = POWERUartCB.tx.end;
00007c  8860              LDRH     r0,[r4,#2]  ; POWERUartCB
00007e  f2a444d4          SUB      r4,r4,#0x4d4
;;;258    
;;;259                // 命令帧队列非空，继续发送下一个命令帧
;;;260                if (head != end)
000082  4282              CMP      r2,r0
000084  d00e              BEQ      |L10.164|
;;;261                {
;;;262                    txdata = POWERUartCB.tx.cmdQueue[head].buff[POWERUartCB.tx.index++];
000086  f8b414d8          LDRH     r1,[r4,#0x4d8]  ; POWERUartCB
00008a  1c48              ADDS     r0,r1,#1
00008c  f8a404d8          STRH     r0,[r4,#0x4d8]
000090  204d              MOVS     r0,#0x4d
000092  4342              MULS     r2,r0,r2
000094  eb040042          ADD      r0,r4,r2,LSL #1
000098  4408              ADD      r0,r0,r1
00009a  7981              LDRB     r1,[r0,#6]
;;;263    
;;;264                    // 填充数据
;;;265                    usart_data_transmit(POWER_UART_TYPE_DEF, txdata);
00009c  4628              MOV      r0,r5
00009e  f7fffffe          BL       usart_data_transmit
                  |L10.162|
0000a2  e006              B        |L10.178|
                  |L10.164|
;;;266                }
;;;267                // 命令帧队列为空停止发送，设置空闲
;;;268                else
;;;269                {
;;;270                    // 关闭发送完成中断
;;;271                    usart_interrupt_disable(POWER_UART_TYPE_DEF, USART_INT_TC);
0000a4  f2403106          MOV      r1,#0x306
0000a8  4628              MOV      r0,r5
0000aa  f7fffffe          BL       usart_interrupt_disable
;;;272    
;;;273                    POWERUartCB.tx.txBusy = FALSE;
0000ae  f88464da          STRB     r6,[r4,#0x4da]
                  |L10.178|
;;;274                }
;;;275            }
;;;276        }
;;;277    #endif
;;;278    
;;;279        // Other USARTx interrupts handler can go here ...
;;;280        if (usart_interrupt_flag_get(POWER_UART_TYPE_DEF, USART_INT_FLAG_ERR_ORERR) != RESET) //----------------------- 接收溢出中断
0000b2  490c              LDR      r1,|L10.228|
0000b4  4628              MOV      r0,r5
0000b6  f7fffffe          BL       usart_interrupt_flag_get
0000ba  2800              CMP      r0,#0
0000bc  d008              BEQ      |L10.208|
;;;281        {
;;;282            usart_flag_get(POWER_UART_TYPE_DEF, USART_FLAG_ORERR);                          //----------------------- 清除接收溢出中断标志位
0000be  2103              MOVS     r1,#3
0000c0  4628              MOV      r0,r5
0000c2  f7fffffe          BL       usart_flag_get
;;;283            usart_data_receive(POWER_UART_TYPE_DEF);                                            //----------------------- 清空寄存器
0000c6  4628              MOV      r0,r5
0000c8  e8bd40f8          POP      {r3-r7,lr}
0000cc  f7ffbffe          B.W      usart_data_receive
                  |L10.208|
;;;284        }
;;;285    }
0000d0  bdf8              POP      {r3-r7,pc}
;;;286    
                          ENDP

0000d2  0000              DCW      0x0000
                  |L10.212|
                          DCD      0x00050305
                  |L10.216|
                          DCD      0x40004800
                  |L10.220|
                          DCD      ||area_number.13||
                  |L10.224|
                          DCD      0x00060306
                  |L10.228|
                          DCD      0x00030500

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  POWERRxBuff
                          %        200

                          AREA ||area_number.13||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.13||, ||.bss||
                  POWERUartCB
                          %        1320

;*** Start embedded assembler ***

#line 1 "User\\PowerDrive.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_PowerDrive_c_1be899e5____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___12_PowerDrive_c_1be899e5____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_PowerDrive_c_1be899e5____REVSH|
#line 128
|__asm___12_PowerDrive_c_1be899e5____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
