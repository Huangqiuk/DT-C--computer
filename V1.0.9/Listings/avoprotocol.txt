; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\avoprotocol.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\avoprotocol.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -I.\User\qrencode -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.3\Device\Include -D__MICROLIB -D__UVISION_VERSION=539 -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\avoprotocol.crf User\AvoProtocol.c]
                          THUMB

                          AREA ||i.AVO_PROTOCOL_CheckSUM||, CODE, READONLY, ALIGN=1

                  AVO_PROTOCOL_CheckSUM PROC
;;;451    // 对传入的命令帧进行校验，返回校验结果
;;;452    BOOL AVO_PROTOCOL_CheckSUM(AVO_PROTOCOL_RX_CMD_FRAME *pCmdFrame)
000000  b530              PUSH     {r4,r5,lr}
;;;453    {
;;;454        uint8_t checkSum = 0;
000002  2200              MOVS     r2,#0
;;;455        uint8_t sumTemp;
;;;456        uint16_t i = 0;
000004  2100              MOVS     r1,#0
;;;457    
;;;458        /* 参数合法性检验 */
;;;459        if (NULL == pCmdFrame)
000006  2800              CMP      r0,#0
000008  d003              BEQ      |L1.18|
;;;460        {
;;;461            return FALSE;
;;;462        }
;;;463    
;;;464        /* 从设备地址开始，到校验码之前的一个字节，依次进行异或运算 */
;;;465        for (i = 0;  i < pCmdFrame->length - 1; i++)
00000a  f8b050a2          LDRH     r5,[r0,#0xa2]
00000e  1e6b              SUBS     r3,r5,#1
000010  e006              B        |L1.32|
                  |L1.18|
000012  2000              MOVS     r0,#0                 ;461
;;;466        {
;;;467            checkSum ^= pCmdFrame->buff[i];
;;;468        }
;;;469    
;;;470        /* 异或和取反 */
;;;471        checkSum = ~checkSum ;
;;;472    
;;;473        /* 获取命令帧中校验码 */
;;;474        sumTemp = pCmdFrame->buff[pCmdFrame->length - 1];
;;;475    
;;;476        /* 判断计算得到的校验码与命令帧中的校验码是否相同 */
;;;477        if (sumTemp != checkSum)
;;;478        {
;;;479            return FALSE;
;;;480        }
;;;481    
;;;482        return TRUE;
;;;483    }
000014  bd30              POP      {r4,r5,pc}
                  |L1.22|
000016  1844              ADDS     r4,r0,r1              ;467
000018  78a4              LDRB     r4,[r4,#2]            ;467
00001a  4062              EORS     r2,r2,r4              ;467
00001c  1c49              ADDS     r1,r1,#1              ;465
00001e  b289              UXTH     r1,r1                 ;465
                  |L1.32|
000020  428b              CMP      r3,r1                 ;465
000022  dcf8              BGT      |L1.22|
000024  43d1              MVNS     r1,r2                 ;471
000026  b2c9              UXTB     r1,r1                 ;471
000028  1c40              ADDS     r0,r0,#1              ;474
00002a  5c28              LDRB     r0,[r5,r0]            ;474
00002c  4288              CMP      r0,r1                 ;477
00002e  d001              BEQ      |L1.52|
000030  2000              MOVS     r0,#0                 ;479
000032  bd30              POP      {r4,r5,pc}
                  |L1.52|
000034  2001              MOVS     r0,#1                 ;482
000036  bd30              POP      {r4,r5,pc}
;;;484    
                          ENDP


                          AREA ||i.AVO_PROTOCOL_CmdFrameProcess||, CODE, READONLY, ALIGN=2

                  AVO_PROTOCOL_CmdFrameProcess PROC
;;;563    // AVO命令帧缓冲区处理
;;;564    void AVO_PROTOCOL_CmdFrameProcess(AVO_PROTOCOL_CB *pCB)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;565    {
000004  4606              MOV      r6,r0
;;;566        AVO_PROTOCOL_CMD cmd = AVO_CMD_NULL;
;;;567        AVO_PROTOCOL_RX_CMD_FRAME *pCmdFrame = NULL;
;;;568        AVO_MEASURE_TYPE mesureType;
;;;569    
;;;570        // 参数合法性检验
;;;571        if (NULL == pCB)
000006  2e00              CMP      r6,#0
000008  d019              BEQ      |L2.62|
;;;572        {
;;;573            return;
;;;574        }
;;;575    
;;;576        // 命令帧缓冲区为空，退出
;;;577        if (pCB->rx.head == pCB->rx.end)
00000a  f8b602ba          LDRH     r0,[r6,#0x2ba]
00000e  f8b612bc          LDRH     r1,[r6,#0x2bc]
000012  4288              CMP      r0,r1
000014  d013              BEQ      |L2.62|
;;;578        {
;;;579            return;
;;;580        }
;;;581    
;;;582        // 获取当前要处理的命令帧指针
;;;583        pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.head];
000016  eb0001c0          ADD      r1,r0,r0,LSL #3
00001a  eb011140          ADD      r1,r1,r0,LSL #5
00001e  eb060181          ADD      r1,r6,r1,LSL #2
000022  31ce              ADDS     r1,r1,#0xce
;;;584    
;;;585        // 命令头非法，退出
;;;586        if (AVO_PROTOCOL_CMD_HEAD1 != pCmdFrame->buff[AVO_PROTOCOL_CMD_HEAD1_INDEX])
;;;587        {
;;;588            // 删除命令帧
;;;589            pCB->rx.head ++;
;;;590            pCB->rx.head %= AVO_PROTOCOL_RX_QUEUE_SIZE;
000024  f04f0803          MOV      r8,#3
000028  788a              LDRB     r2,[r1,#2]            ;586
00002a  2a55              CMP      r2,#0x55              ;586
00002c  d009              BEQ      |L2.66|
00002e  1c40              ADDS     r0,r0,#1              ;589
000030  b280              UXTH     r0,r0                 ;589
000032  fbb0f1f8          UDIV     r1,r0,r8
000036  fb080011          MLS      r0,r8,r1,r0
00003a  f8a602ba          STRH     r0,[r6,#0x2ba]
                  |L2.62|
;;;591            return;
;;;592        }
;;;593    
;;;594        // 命令头合法，则提取命令
;;;595        cmd = (AVO_PROTOCOL_CMD)pCmdFrame->buff[AVO_PROTOCOL_CMD_INDEX];
;;;596    
;;;597        // 执行命令帧
;;;598        switch (cmd)
;;;599        {
;;;600            case AVO_CMD_NULL:
;;;601                break;
;;;602    
;;;603            case AVO_CMD_AVOMETER_ACK:
;;;604                mesureType = (AVO_MEASURE_TYPE)pCmdFrame->buff[AVO_PROTOCOL_CMD_DATA1_INDEX];
;;;605    
;;;606                switch (mesureType)
;;;607                {
;;;608                    // 直流电压（V）
;;;609                    case MEASURE_DCV :
;;;610                        measure.data[0] = pCmdFrame->buff[AVO_PROTOCOL_CMD_DATA3_INDEX];
;;;611                        measure.data[1] = pCmdFrame->buff[AVO_PROTOCOL_CMD_DATA4_INDEX];
;;;612                        measure.data[2] = pCmdFrame->buff[AVO_PROTOCOL_CMD_DATA5_INDEX];
;;;613                        measure.data[3] = pCmdFrame->buff[AVO_PROTOCOL_CMD_DATA6_INDEX];
;;;614                        measure.result = measure.result * 1000.0f;
;;;615    
;;;616                        // 所有测试使能引脚复位
;;;617                        AVO_PIN_Reset();
;;;618    
;;;619                        // LCD显示
;;;620                        Vertical_Scrolling_Display(avoTestMsgBuff, 4, 0);
;;;621    
;;;622                        switch (dut_info.dutBusType)
;;;623                        {
;;;624                            case 0: // 串口
;;;625                                switch (dut_info.test)
;;;626                                {
;;;627                                    case TEST_TYPE_NULL:
;;;628                                        break;
;;;629    
;;;630                                    case TEST_TYPE_UART:
;;;631                                        STATE_SwitchStep(STEP_UART_TEST_CHECK_VOLTAGE_VALUE);
;;;632                                        break;
;;;633    
;;;634                                    // 大灯测试
;;;635                                    case TEST_TYPE_HEADLIGHT:
;;;636                                        headlight_cnt++;
;;;637                                        if (1 == headlight_cnt)
;;;638                                        {
;;;639                                            STATE_SwitchStep(STEP_HEADLIGHT_UART_TEST_CHECK_VOLTAGE_VALUE);
;;;640                                        }
;;;641    
;;;642                                        if (2 == headlight_cnt)
;;;643                                        {
;;;644                                            STATE_SwitchStep(STEP_HEADLIGHT_UART_TEST_CHECK_GND_VALUE);
;;;645                                            headlight_cnt = 0;
;;;646                                        }
;;;647                                        break;
;;;648    
;;;649                                    // 近光灯
;;;650                                    case TEST_TYPE_LBEAM:
;;;651                                        headlight_cnt++;
;;;652                                        if (1 == headlight_cnt)
;;;653                                        {
;;;654                                            STATE_SwitchStep(STEP_LBEAM_UART_TEST_CHECK_VOLTAGE_VALUE);
;;;655                                        }
;;;656    
;;;657                                        if (2 == headlight_cnt)
;;;658                                        {
;;;659                                            STATE_SwitchStep(STEP_LBEAM_UART_TEST_CHECK_GND_VALUE);
;;;660                                            headlight_cnt = 0;
;;;661                                        }
;;;662                                        break;
;;;663    
;;;664                                    // 远光灯
;;;665                                    case TEST_TYPE_HBEAM:
;;;666                                        headlight_cnt++;
;;;667                                        if (1 == headlight_cnt)
;;;668                                        {
;;;669                                            STATE_SwitchStep(STEP_HBEAM_UART_TEST_CHECK_VOLTAGE_VALUE);
;;;670                                        }
;;;671    
;;;672                                        if (2 == headlight_cnt)
;;;673                                        {
;;;674                                            STATE_SwitchStep(STEP_HBEAM_UART_TEST_CHECK_GND_VALUE);
;;;675                                            headlight_cnt = 0;
;;;676                                        }
;;;677                                        break;
;;;678    
;;;679                                    // 左转向灯
;;;680                                    case TEST_TYPE_LEFT_TURN_SIGNAL:
;;;681                                        headlight_cnt++;
;;;682                                        if (1 == headlight_cnt)
;;;683                                        {
;;;684                                            STATE_SwitchStep(STEP_LEFT_TURN_SIGNAL_UART_TEST_CHECK_VOLTAGE_VALUE);
;;;685                                        }
;;;686    
;;;687                                        if (2 == headlight_cnt)
;;;688                                        {
;;;689                                            STATE_SwitchStep(STEP_LEFT_TURN_SIGNAL_UART_TEST_CHECK_GND_VALUE);
;;;690                                            headlight_cnt = 0;
;;;691                                        }
;;;692                                        break;
;;;693    
;;;694                                    // 右转向灯
;;;695                                    case TEST_TYPE_RIGHT_TURN_SIGNAL:
;;;696                                        headlight_cnt++;
;;;697                                        if (1 == headlight_cnt)
;;;698                                        {
;;;699                                            STATE_SwitchStep(STEP_RIGHT_TURN_SIGNAL_UART_TEST_CHECK_VOLTAGE_VALUE);
;;;700                                        }
;;;701    
;;;702                                        if (2 == headlight_cnt)
;;;703                                        {
;;;704                                            STATE_SwitchStep(STEP_RIGHT_TURN_SIGNAL_UART_TEST_CHECK_GND_VALUE);
;;;705                                            headlight_cnt = 0;
;;;706                                        }
;;;707                                        break;
;;;708    
;;;709                                    case TEST_TYPE_THROTTLE:
;;;710                                        STATE_SwitchStep(STEP_THROTTLE_UART_TEST_CHECK_VOLTAGE_VALUE);
;;;711                                        break;
;;;712    
;;;713                                    case TEST_TYPE_BRAKE:
;;;714                                        STATE_SwitchStep(STEP_BRAKE_UART_TEST_CHECK_VOLTAGE_VALUE);
;;;715                                        break;
;;;716    
;;;717                                    case TEST_TYPE_VLK:
;;;718                                        STATE_SwitchStep(STEP_VLK_UART_TEST_CHECK_VOLTAGE_VALUE);
;;;719                                        break;
;;;720    
;;;721                                    // (小米)大灯测试
;;;722                                    case TEST_TYPE_XM_HEADLIGHT:
;;;723                                        headlight_cnt++;
;;;724                                        if (1 == headlight_cnt)
;;;725                                        {
;;;726                                            STATE_SwitchStep(STEP_HEADLIGHT_UART_TEST_CHECK_VOLTAGE_VALUE);
;;;727                                        }
;;;728    
;;;729                                        if (2 == headlight_cnt)
;;;730                                        {
;;;731                                            STATE_SwitchStep(STEP_HEADLIGHT_UART_TEST_CHECK_GND_VALUE);
;;;732                                            headlight_cnt = 0;
;;;733                                        }
;;;734                                        break;
;;;735                                        
;;;736                                    // (小米)油门测试
;;;737                                    case TEST_TYPE_XM_THROTTLE:
;;;738                                        STATE_SwitchStep(STEP_THROTTLE_UART_TEST_CHECK_VOLTAGE_VALUE);
;;;739                                        break;
;;;740    
;;;741                                    // (小米)刹把测试
;;;742                                    case TEST_TYPE_XM_BRAKE:
;;;743                                        STATE_SwitchStep(STEP_BRAKE_UART_TEST_CHECK_VOLTAGE_VALUE);
;;;744                                        break;
;;;745                                        
;;;746                                    // (小米)左转向灯
;;;747                                    case TEST_TYPE_XM_LEFT_TURN_SIGNAL:
;;;748                                        headlight_cnt++;
;;;749                                        if (1 == headlight_cnt)
;;;750                                        {
;;;751                                            STATE_SwitchStep(STEP_LEFT_TURN_SIGNAL_UART_TEST_CHECK_VOLTAGE_VALUE);
;;;752                                        }
;;;753    
;;;754                                        if (2 == headlight_cnt)
;;;755                                        {
;;;756                                            STATE_SwitchStep(STEP_LEFT_TURN_SIGNAL_UART_TEST_CHECK_GND_VALUE);
;;;757                                            headlight_cnt = 0;
;;;758                                        }
;;;759                                        
;;;760    //                                    if (3 == headlight_cnt)
;;;761    //                                    {
;;;762    //                                        STATE_SwitchStep(STEP_LEFT_TURN_SIGNAL_UART_TEST_CHECK_GND_VALUE2);
;;;763    //                                        headlight_cnt = 0;
;;;764    //                                    }                                    
;;;765                                        break;
;;;766    
;;;767                                    // (小米)右转向灯
;;;768                                    case TEST_TYPE_XM_RIGHT_TURN_SIGNAL:
;;;769                                        headlight_cnt++;
;;;770                                        if (1 == headlight_cnt)
;;;771                                        {
;;;772                                            STATE_SwitchStep(STEP_RIGHT_TURN_SIGNAL_UART_TEST_CHECK_VOLTAGE_VALUE);
;;;773                                        }
;;;774    
;;;775                                        if (2 == headlight_cnt)
;;;776                                        {
;;;777                                            STATE_SwitchStep(STEP_RIGHT_TURN_SIGNAL_UART_TEST_CHECK_GND_VALUE);
;;;778                                            headlight_cnt = 0;
;;;779                                        }
;;;780                                        
;;;781    //                                    if (3 == headlight_cnt)
;;;782    //                                    {
;;;783    //                                        STATE_SwitchStep(STEP_RIGHT_TURN_SIGNAL_UART_TEST_CHECK_GND_VALUE2);
;;;784    //                                    }  
;;;785    //                                    
;;;786    //                                    if (4 == headlight_cnt)
;;;787    //                                    {
;;;788    //                                        STATE_SwitchStep(STEP_RIGHT_TURN_SIGNAL_UART_TEST_CHECK_GND_VALUE3);
;;;789    //                                        headlight_cnt = 0;
;;;790    //                                    }                                        
;;;791                                        break;                                    
;;;792                                        
;;;793                                    default:
;;;794                                        break;
;;;795                                    }
;;;796    
;;;797                                break;
;;;798    
;;;799                            case 1: // can
;;;800                                switch (dut_info.test)
;;;801                                {
;;;802                                    case TEST_TYPE_NULL:
;;;803                                        break;
;;;804    
;;;805                                    // 大灯测试
;;;806                                    case TEST_TYPE_HEADLIGHT:
;;;807                                        headlight_cnt++;
;;;808                                        if (1 == headlight_cnt)
;;;809                                        {
;;;810                                            STATE_SwitchStep(STEP_HEADLIGHT_CAN_TEST_CHECK_VOLTAGE_VALUE);
;;;811                                        }
;;;812    
;;;813                                        if (2 == headlight_cnt)
;;;814                                        {
;;;815                                            STATE_SwitchStep(STEP_HEADLIGHT_CAN_TEST_CHECK_GND_VALUE);
;;;816                                            headlight_cnt = 0;
;;;817                                        }
;;;818                                        break;
;;;819    
;;;820                                    // 近光灯
;;;821                                    case TEST_TYPE_LBEAM:
;;;822                                        headlight_cnt++;
;;;823                                        if (1 == headlight_cnt)
;;;824                                        {
;;;825                                            STATE_SwitchStep(STEP_LBEAM_CAN_TEST_CHECK_VOLTAGE_VALUE);
;;;826                                        }
;;;827    
;;;828                                        if (2 == headlight_cnt)
;;;829                                        {
;;;830                                            STATE_SwitchStep(STEP_LBEAM_CAN_TEST_CHECK_GND_VALUE);
;;;831                                            headlight_cnt = 0;
;;;832                                        }
;;;833                                        break;
;;;834    
;;;835                                    // 远光灯
;;;836                                    case TEST_TYPE_HBEAM:
;;;837                                        headlight_cnt++;
;;;838                                        if (1 == headlight_cnt)
;;;839                                        {
;;;840                                            STATE_SwitchStep(STEP_HBEAM_CAN_TEST_CHECK_VOLTAGE_VALUE);
;;;841                                        }
;;;842    
;;;843                                        if (2 == headlight_cnt)
;;;844                                        {
;;;845                                            STATE_SwitchStep(STEP_HBEAM_CAN_TEST_CHECK_GND_VALUE);
;;;846                                            headlight_cnt = 0;
;;;847                                        }
;;;848                                        break;
;;;849    
;;;850                                    // 左转向灯
;;;851                                    case TEST_TYPE_LEFT_TURN_SIGNAL:
;;;852                                        headlight_cnt++;
;;;853                                        if (1 == headlight_cnt)
;;;854                                        {
;;;855                                            STATE_SwitchStep(STEP_LEFT_TURN_SIGNAL_UART_TEST_CHECK_VOLTAGE_VALUE);
;;;856                                        }
;;;857    
;;;858                                        if (2 == headlight_cnt)
;;;859                                        {
;;;860                                            STATE_SwitchStep(STEP_LEFT_TURN_SIGNAL_UART_TEST_CHECK_GND_VALUE);
;;;861                                            headlight_cnt = 0;
;;;862                                        }
;;;863                                        break;
;;;864    
;;;865                                    // 右转向灯
;;;866                                    case TEST_TYPE_RIGHT_TURN_SIGNAL:
;;;867                                        headlight_cnt++;
;;;868                                        if (1 == headlight_cnt)
;;;869                                        {
;;;870                                            STATE_SwitchStep(STEP_RIGHT_TURN_SIGNAL_UART_TEST_CHECK_VOLTAGE_VALUE);
;;;871                                        }
;;;872    
;;;873                                        if (2 == headlight_cnt)
;;;874                                        {
;;;875                                            STATE_SwitchStep(STEP_RIGHT_TURN_SIGNAL_UART_TEST_CHECK_GND_VALUE);
;;;876                                            headlight_cnt = 0;
;;;877                                        }
;;;878                                        break;
;;;879    
;;;880                                    case TEST_TYPE_THROTTLE:
;;;881                                        STATE_SwitchStep(STEP_THROTTLE_CAN_TEST_CHECK_VOLTAGE_VALUE);
;;;882                                        break;
;;;883    
;;;884                                    case TEST_TYPE_BRAKE:
;;;885                                        STATE_SwitchStep(STEP_BRAKE_CAN_TEST_CHECK_VOLTAGE_VALUE);
;;;886                                        break;
;;;887    
;;;888                                    case TEST_TYPE_VLK:
;;;889                                        STATE_SwitchStep(STEP_VLK_CAN_TEST_CHECK_VOLTAGE_VALUE);
;;;890                                        break;
;;;891    
;;;892                                    default:
;;;893                                        break;
;;;894                                }
;;;895    
;;;896                                break;
;;;897                            }
;;;898    
;;;899                        break;
;;;900    
;;;901                    // 电阻（Ω）
;;;902                    case MEASURE_OHM :
;;;903                        ohm.data[0] = pCmdFrame->buff[AVO_PROTOCOL_CMD_DATA3_INDEX];
;;;904                        ohm.data[1] = pCmdFrame->buff[AVO_PROTOCOL_CMD_DATA4_INDEX];
;;;905                        ohm.data[2] = pCmdFrame->buff[AVO_PROTOCOL_CMD_DATA5_INDEX];
;;;906                        ohm.data[3] = pCmdFrame->buff[AVO_PROTOCOL_CMD_DATA6_INDEX];
;;;907                        ohm.INT = ohm.INT;
;;;908    
;;;909                        // 所有测试使能引脚复位
;;;910                        AVO_PIN_Reset();
;;;911    
;;;912                        // LCD显示
;;;913                        Vertical_Scrolling_Display(avoTestMsgBuff, 4, 0);
;;;914    
;;;915                        switch (dut_info.dutBusType)
;;;916                        {
;;;917                            case 0: // 串口
;;;918                                switch (dut_info.test)
;;;919                                {
;;;920                                    case TEST_TYPE_NULL:
;;;921                                        break;
;;;922    
;;;923                                    case TEST_TYPE_GND:
;;;924                                        gnd_cnt++;
;;;925                                        if ((1 == gnd_cnt) && (dut_info.gnd == GND_TYPE_THROTTLE_BRAKE))
;;;926                                        {
;;;927                                            STATE_SwitchStep(STEP_GND_TEST_CHECK_THROTTLE_GND_VALUE);
;;;928                                        }
;;;929                                        if ((1 == gnd_cnt) && (dut_info.gnd == GND_TYPE_BRAKE))
;;;930                                        {
;;;931                                            STATE_SwitchStep(STEP_GND_TEST_CHECK_BRAKE_GND_VALUE);
;;;932                                        }
;;;933                                        if ((1 == gnd_cnt) && (dut_info.gnd == GND_TYPE_THROTTLE))
;;;934                                        {
;;;935                                            STATE_SwitchStep(STEP_GND_TEST_CHECK_THROTTLE_GND_VALUE);
;;;936                                        }
;;;937                                        if ((1 == gnd_cnt) && (dut_info.gnd == GND_TYPE_DERAILLEUR))
;;;938                                        {
;;;939                                            STATE_SwitchStep(STEP_GND_TEST_CHECK_DERAILLEUR_GND_VALUE);
;;;940                                        }                                    
;;;941                                        if ((2 == gnd_cnt) && (dut_info.gnd == GND_TYPE_THROTTLE_BRAKE))
;;;942                                        {
;;;943                                            STATE_SwitchStep(STEP_GND_TEST_CHECK_BRAKE_GND_VALUE);
;;;944                                            gnd_cnt = 0;
;;;945                                        }
;;;946                                        if ((1 == gnd_cnt) && (dut_info.gnd == GND_TYPE_BRAKE_DERAILLEUR))
;;;947                                        {
;;;948                                            STATE_SwitchStep(STEP_GND_TEST_CHECK_BRAKE_GND_VALUE);
;;;949                                        }                                        
;;;950                                        if ((2 == gnd_cnt) && (dut_info.gnd == GND_TYPE_BRAKE_DERAILLEUR))
;;;951                                        {
;;;952                                            STATE_SwitchStep(STEP_GND_TEST_CHECK_DERAILLEUR_GND_VALUE);
;;;953                                            gnd_cnt = 0;
;;;954                                        }                                    
;;;955                                        break;
;;;956    
;;;957                                    case TEST_TYPE_THROTTLE:
;;;958                                        STATE_SwitchStep(STEP_GND_TEST_CHECK_THROTTLE_GND_VALUE);
;;;959                                        break;
;;;960    
;;;961                                    case TEST_TYPE_BRAKE:
;;;962                                        STATE_SwitchStep(STEP_GND_TEST_CHECK_BRAKE_GND_VALUE);
;;;963                                        break;
;;;964    
;;;965                                    default:
;;;966                                        break;
;;;967                                }
;;;968                                break;
;;;969    
;;;970                            case 1: // can
;;;971                                switch (dut_info.test)
;;;972                                {
;;;973                                    case TEST_TYPE_NULL:
;;;974                                        break;
;;;975    
;;;976                                    case TEST_TYPE_GND:
;;;977                                        gnd_cnt++;
;;;978                                        if ((1 == gnd_cnt) && (dut_info.gnd == GND_TYPE_THROTTLE_BRAKE))
;;;979                                        {
;;;980                                            STATE_SwitchStep(STEP_GND_TEST_CHECK_THROTTLE_GND_VALUE);
;;;981                                        }
;;;982                                        if ((1 == gnd_cnt) && (dut_info.gnd == GND_TYPE_BRAKE))
;;;983                                        {
;;;984                                            STATE_SwitchStep(STEP_GND_TEST_CHECK_BRAKE_GND_VALUE);
;;;985                                        }
;;;986                                        if ((1 == gnd_cnt) && (dut_info.gnd == GND_TYPE_THROTTLE))
;;;987                                        {
;;;988                                            STATE_SwitchStep(STEP_GND_TEST_CHECK_THROTTLE_GND_VALUE);
;;;989                                        }
;;;990                                        if ((1 == gnd_cnt) && (dut_info.gnd == GND_TYPE_DERAILLEUR))
;;;991                                        {
;;;992                                            STATE_SwitchStep(STEP_GND_TEST_CHECK_DERAILLEUR_GND_VALUE);
;;;993                                        }                                    
;;;994                                        if ((2 == gnd_cnt) && (dut_info.gnd == GND_TYPE_THROTTLE_BRAKE))
;;;995                                        {
;;;996                                            STATE_SwitchStep(STEP_GND_TEST_CHECK_BRAKE_GND_VALUE);
;;;997                                            gnd_cnt = 0;
;;;998                                        }
;;;999                                        if ((1 == gnd_cnt) && (dut_info.gnd == GND_TYPE_BRAKE_DERAILLEUR))
;;;1000                                       {
;;;1001                                           STATE_SwitchStep(STEP_GND_TEST_CHECK_BRAKE_GND_VALUE);
;;;1002                                       }                                        
;;;1003                                       if ((2 == gnd_cnt) && (dut_info.gnd == GND_TYPE_BRAKE_DERAILLEUR))
;;;1004                                       {
;;;1005                                           STATE_SwitchStep(STEP_GND_TEST_CHECK_DERAILLEUR_GND_VALUE);
;;;1006                                           gnd_cnt = 0;
;;;1007                                       }                                    
;;;1008                                       break;
;;;1009   
;;;1010                                   case TEST_TYPE_THROTTLE:
;;;1011                                       STATE_SwitchStep(STEP_GND_TEST_CHECK_THROTTLE_GND_VALUE);
;;;1012                                       break;
;;;1013   
;;;1014                                   case TEST_TYPE_BRAKE:
;;;1015                                       STATE_SwitchStep(STEP_GND_TEST_CHECK_BRAKE_GND_VALUE);
;;;1016                                       break;
;;;1017   
;;;1018                                   default:
;;;1019                                       break;
;;;1020                               }
;;;1021                               break;
;;;1022                           }
;;;1023                       break;
;;;1024   
;;;1025                   default:
;;;1026                       break;
;;;1027               }
;;;1028               break;
;;;1029   
;;;1030           default:
;;;1031               break;
;;;1032       }
;;;1033   
;;;1034       // 删除命令帧
;;;1035       pCB->rx.head++;
;;;1036       pCB->rx.head %= AVO_PROTOCOL_RX_QUEUE_SIZE;
;;;1037   }
00003e  e8bd87f0          POP      {r4-r10,pc}
                  |L2.66|
000042  7948              LDRB     r0,[r1,#5]            ;595
000044  28b0              CMP      r0,#0xb0              ;598
                  |L2.70|
000046  d13f              BNE      |L2.200|
000048  7a08              LDRB     r0,[r1,#8]            ;604
00004a  2400              MOVS     r4,#0                 ;606
00004c  4ffb              LDR      r7,|L2.1084|
00004e  4dfc              LDR      r5,|L2.1088|
000050  2801              CMP      r0,#1                 ;606
000052  d002              BEQ      |L2.90|
000054  2803              CMP      r0,#3                 ;606
000056  d1f6              BNE      |L2.70|
000058  e140              B        |L2.732|
                  |L2.90|
00005a  f8df93e4          LDR      r9,|L2.1088|
00005e  7a88              LDRB     r0,[r1,#0xa]          ;610
000060  f1090904          ADD      r9,r9,#4              ;610
000064  f8890000          STRB     r0,[r9,#0]            ;610
000068  7ac8              LDRB     r0,[r1,#0xb]          ;611
00006a  f8890001          STRB     r0,[r9,#1]            ;611
00006e  7b08              LDRB     r0,[r1,#0xc]          ;612
000070  f8890002          STRB     r0,[r9,#2]            ;612
000074  7b48              LDRB     r0,[r1,#0xd]          ;613
000076  f8890003          STRB     r0,[r9,#3]            ;613
00007a  49f2              LDR      r1,|L2.1092|
00007c  f8d90000          LDR      r0,[r9,#0]            ;614  ; measure
000080  f7fffffe          BL       __aeabi_fmul
000084  f8c90000          STR      r0,[r9,#0]            ;614  ; measure
000088  f7fffffe          BL       AVO_PIN_Reset
00008c  2200              MOVS     r2,#0                 ;620
00008e  2104              MOVS     r1,#4                 ;620
000090  f1090008          ADD      r0,r9,#8              ;620
000094  f7fffffe          BL       Vertical_Scrolling_Display
000098  7eb8              LDRB     r0,[r7,#0x1a]         ;622  ; dut_info
00009a  b110              CBZ      r0,|L2.162|
00009c  2801              CMP      r0,#1                 ;622
00009e  d1d2              BNE      |L2.70|
0000a0  e0af              B        |L2.514|
                  |L2.162|
0000a2  7df8              LDRB     r0,[r7,#0x17]         ;625  ; dut_info
0000a4  2815              CMP      r0,#0x15              ;625
0000a6  d20f              BCS      |L2.200|
0000a8  e8dff000          TBB      [pc,r0]               ;625
0000ac  0e0b0e0f          DCB      0x0e,0x0b,0x0e,0x0f
0000b0  20314253          DCB      0x20,0x31,0x42,0x53
0000b4  64680e0e          DCB      0x64,0x68,0x0e,0x0e
0000b8  0e6c0e0e          DCB      0x0e,0x6c,0x0e,0x0e
0000bc  70899a81          DCB      0x70,0x89,0x9a,0x81
0000c0  8500              DCB      0x85,0x00
0000c2  200d              MOVS     r0,#0xd               ;631
0000c4  f7fffffe          BL       STATE_SwitchStep
                  |L2.200|
0000c8  e1d4              B        |L2.1140|
0000ca  7828              LDRB     r0,[r5,#0]            ;636  ; headlight_cnt
0000cc  1c40              ADDS     r0,r0,#1              ;636
0000ce  b2c0              UXTB     r0,r0                 ;636
0000d0  7028              STRB     r0,[r5,#0]            ;636
0000d2  2801              CMP      r0,#1                 ;637
0000d4  d102              BNE      |L2.220|
0000d6  2014              MOVS     r0,#0x14              ;639
0000d8  f7fffffe          BL       STATE_SwitchStep
                  |L2.220|
0000dc  7828              LDRB     r0,[r5,#0]            ;642  ; headlight_cnt
0000de  2802              CMP      r0,#2                 ;642
0000e0  d1f2              BNE      |L2.200|
0000e2  2015              MOVS     r0,#0x15              ;644
0000e4  f7fffffe          BL       STATE_SwitchStep
0000e8  702c              STRB     r4,[r5,#0]            ;645
                  |L2.234|
0000ea  e1c3              B        |L2.1140|
0000ec  7828              LDRB     r0,[r5,#0]            ;651  ; headlight_cnt
0000ee  1c40              ADDS     r0,r0,#1              ;651
0000f0  b2c0              UXTB     r0,r0                 ;651
0000f2  7028              STRB     r0,[r5,#0]            ;651
0000f4  2801              CMP      r0,#1                 ;652
0000f6  d102              BNE      |L2.254|
0000f8  201c              MOVS     r0,#0x1c              ;654
0000fa  f7fffffe          BL       STATE_SwitchStep
                  |L2.254|
0000fe  7828              LDRB     r0,[r5,#0]            ;657  ; headlight_cnt
000100  2802              CMP      r0,#2                 ;657
000102  d1e1              BNE      |L2.200|
000104  201d              MOVS     r0,#0x1d              ;659
000106  f7fffffe          BL       STATE_SwitchStep
00010a  702c              STRB     r4,[r5,#0]            ;660
                  |L2.268|
00010c  e1b2              B        |L2.1140|
00010e  7828              LDRB     r0,[r5,#0]            ;666  ; headlight_cnt
000110  1c40              ADDS     r0,r0,#1              ;666
000112  b2c0              UXTB     r0,r0                 ;666
000114  7028              STRB     r0,[r5,#0]            ;666
000116  2801              CMP      r0,#1                 ;667
000118  d102              BNE      |L2.288|
00011a  2024              MOVS     r0,#0x24              ;669
00011c  f7fffffe          BL       STATE_SwitchStep
                  |L2.288|
000120  7828              LDRB     r0,[r5,#0]            ;672  ; headlight_cnt
000122  2802              CMP      r0,#2                 ;672
000124  d1d0              BNE      |L2.200|
000126  2025              MOVS     r0,#0x25              ;674
000128  f7fffffe          BL       STATE_SwitchStep
00012c  702c              STRB     r4,[r5,#0]            ;675
                  |L2.302|
00012e  e1a1              B        |L2.1140|
000130  7828              LDRB     r0,[r5,#0]            ;681  ; headlight_cnt
000132  1c40              ADDS     r0,r0,#1              ;681
000134  b2c0              UXTB     r0,r0                 ;681
000136  7028              STRB     r0,[r5,#0]            ;681
000138  2801              CMP      r0,#1                 ;682
00013a  d102              BNE      |L2.322|
00013c  202c              MOVS     r0,#0x2c              ;684
00013e  f7fffffe          BL       STATE_SwitchStep
                  |L2.322|
000142  7828              LDRB     r0,[r5,#0]            ;687  ; headlight_cnt
000144  2802              CMP      r0,#2                 ;687
000146  d1bf              BNE      |L2.200|
000148  202d              MOVS     r0,#0x2d              ;689
00014a  f7fffffe          BL       STATE_SwitchStep
00014e  702c              STRB     r4,[r5,#0]            ;690
                  |L2.336|
000150  e190              B        |L2.1140|
000152  7828              LDRB     r0,[r5,#0]            ;696  ; headlight_cnt
000154  1c40              ADDS     r0,r0,#1              ;696
000156  b2c0              UXTB     r0,r0                 ;696
000158  7028              STRB     r0,[r5,#0]            ;696
00015a  2801              CMP      r0,#1                 ;697
00015c  d102              BNE      |L2.356|
00015e  2035              MOVS     r0,#0x35              ;699
000160  f7fffffe          BL       STATE_SwitchStep
                  |L2.356|
000164  7828              LDRB     r0,[r5,#0]            ;702  ; headlight_cnt
000166  2802              CMP      r0,#2                 ;702
000168  d1ae              BNE      |L2.200|
00016a  2036              MOVS     r0,#0x36              ;704
00016c  f7fffffe          BL       STATE_SwitchStep
000170  702c              STRB     r4,[r5,#0]            ;705
                  |L2.370|
000172  e17f              B        |L2.1140|
000174  203e              MOVS     r0,#0x3e              ;710
000176  f7fffffe          BL       STATE_SwitchStep
00017a  e17b              B        |L2.1140|
00017c  2047              MOVS     r0,#0x47              ;714
00017e  f7fffffe          BL       STATE_SwitchStep
                  |L2.386|
000182  e177              B        |L2.1140|
000184  2059              MOVS     r0,#0x59              ;718
000186  f7fffffe          BL       STATE_SwitchStep
00018a  e173              B        |L2.1140|
00018c  7828              LDRB     r0,[r5,#0]            ;723  ; headlight_cnt
00018e  1c40              ADDS     r0,r0,#1              ;723
000190  b2c0              UXTB     r0,r0                 ;723
000192  7028              STRB     r0,[r5,#0]            ;723
000194  2801              CMP      r0,#1                 ;724
000196  d102              BNE      |L2.414|
000198  2014              MOVS     r0,#0x14              ;726
00019a  f7fffffe          BL       STATE_SwitchStep
                  |L2.414|
00019e  7828              LDRB     r0,[r5,#0]            ;729  ; headlight_cnt
0001a0  2802              CMP      r0,#2                 ;729
0001a2  d191              BNE      |L2.200|
0001a4  2015              MOVS     r0,#0x15              ;731
0001a6  f7fffffe          BL       STATE_SwitchStep
0001aa  702c              STRB     r4,[r5,#0]            ;732
0001ac  e162              B        |L2.1140|
0001ae  203e              MOVS     r0,#0x3e              ;738
0001b0  f7fffffe          BL       STATE_SwitchStep
0001b4  e15e              B        |L2.1140|
0001b6  2047              MOVS     r0,#0x47              ;743
0001b8  f7fffffe          BL       STATE_SwitchStep
0001bc  e15a              B        |L2.1140|
0001be  7828              LDRB     r0,[r5,#0]            ;748  ; headlight_cnt
0001c0  1c40              ADDS     r0,r0,#1              ;748
0001c2  b2c0              UXTB     r0,r0                 ;748
0001c4  7028              STRB     r0,[r5,#0]            ;748
0001c6  2801              CMP      r0,#1                 ;749
0001c8  d102              BNE      |L2.464|
0001ca  202c              MOVS     r0,#0x2c              ;751
0001cc  f7fffffe          BL       STATE_SwitchStep
                  |L2.464|
0001d0  7828              LDRB     r0,[r5,#0]            ;754  ; headlight_cnt
0001d2  2802              CMP      r0,#2                 ;754
0001d4  d189              BNE      |L2.234|
0001d6  202d              MOVS     r0,#0x2d              ;756
0001d8  f7fffffe          BL       STATE_SwitchStep
0001dc  702c              STRB     r4,[r5,#0]            ;757
0001de  e149              B        |L2.1140|
0001e0  7828              LDRB     r0,[r5,#0]            ;769  ; headlight_cnt
0001e2  1c40              ADDS     r0,r0,#1              ;769
0001e4  b2c0              UXTB     r0,r0                 ;769
0001e6  7028              STRB     r0,[r5,#0]            ;769
0001e8  2801              CMP      r0,#1                 ;770
0001ea  d102              BNE      |L2.498|
0001ec  2035              MOVS     r0,#0x35              ;772
0001ee  f7fffffe          BL       STATE_SwitchStep
                  |L2.498|
0001f2  7828              LDRB     r0,[r5,#0]            ;775  ; headlight_cnt
0001f4  2802              CMP      r0,#2                 ;775
0001f6  d189              BNE      |L2.268|
0001f8  2036              MOVS     r0,#0x36              ;777
0001fa  f7fffffe          BL       STATE_SwitchStep
0001fe  702c              STRB     r4,[r5,#0]            ;778
000200  e138              B        |L2.1140|
                  |L2.514|
000202  7df8              LDRB     r0,[r7,#0x17]         ;800  ; dut_info
000204  280e              CMP      r0,#0xe               ;800
000206  d292              BCS      |L2.302|
000208  e8dff000          TBB      [pc,r0]               ;800
00020c  17171707          DCB      0x17,0x17,0x17,0x07
000210  18293a4b          DCB      0x18,0x29,0x3a,0x4b
000214  5c601717          DCB      0x5c,0x60,0x17,0x17
000218  1764              DCB      0x17,0x64
00021a  7828              LDRB     r0,[r5,#0]            ;807  ; headlight_cnt
00021c  1c40              ADDS     r0,r0,#1              ;807
00021e  b2c0              UXTB     r0,r0                 ;807
000220  7028              STRB     r0,[r5,#0]            ;807
000222  2801              CMP      r0,#1                 ;808
000224  d102              BNE      |L2.556|
000226  2070              MOVS     r0,#0x70              ;810
000228  f7fffffe          BL       STATE_SwitchStep
                  |L2.556|
00022c  7828              LDRB     r0,[r5,#0]            ;813  ; headlight_cnt
00022e  2802              CMP      r0,#2                 ;813
000230  d18e              BNE      |L2.336|
000232  206f              MOVS     r0,#0x6f              ;815
000234  f7fffffe          BL       STATE_SwitchStep
000238  702c              STRB     r4,[r5,#0]            ;816
00023a  e11b              B        |L2.1140|
00023c  7828              LDRB     r0,[r5,#0]            ;822  ; headlight_cnt
00023e  1c40              ADDS     r0,r0,#1              ;822
000240  b2c0              UXTB     r0,r0                 ;822
000242  7028              STRB     r0,[r5,#0]            ;822
000244  2801              CMP      r0,#1                 ;823
000246  d102              BNE      |L2.590|
000248  2078              MOVS     r0,#0x78              ;825
00024a  f7fffffe          BL       STATE_SwitchStep
                  |L2.590|
00024e  7828              LDRB     r0,[r5,#0]            ;828  ; headlight_cnt
000250  2802              CMP      r0,#2                 ;828
000252  d18e              BNE      |L2.370|
000254  2079              MOVS     r0,#0x79              ;830
000256  f7fffffe          BL       STATE_SwitchStep
00025a  702c              STRB     r4,[r5,#0]            ;831
00025c  e10a              B        |L2.1140|
00025e  7828              LDRB     r0,[r5,#0]            ;837  ; headlight_cnt
000260  1c40              ADDS     r0,r0,#1              ;837
000262  b2c0              UXTB     r0,r0                 ;837
000264  7028              STRB     r0,[r5,#0]            ;837
000266  2801              CMP      r0,#1                 ;838
000268  d102              BNE      |L2.624|
00026a  2080              MOVS     r0,#0x80              ;840
00026c  f7fffffe          BL       STATE_SwitchStep
                  |L2.624|
000270  7828              LDRB     r0,[r5,#0]            ;843  ; headlight_cnt
000272  2802              CMP      r0,#2                 ;843
000274  d185              BNE      |L2.386|
000276  2081              MOVS     r0,#0x81              ;845
000278  f7fffffe          BL       STATE_SwitchStep
00027c  702c              STRB     r4,[r5,#0]            ;846
00027e  e0f9              B        |L2.1140|
000280  7828              LDRB     r0,[r5,#0]            ;852  ; headlight_cnt
000282  1c40              ADDS     r0,r0,#1              ;852
000284  b2c0              UXTB     r0,r0                 ;852
000286  7028              STRB     r0,[r5,#0]            ;852
000288  2801              CMP      r0,#1                 ;853
00028a  d102              BNE      |L2.658|
00028c  202c              MOVS     r0,#0x2c              ;855
00028e  f7fffffe          BL       STATE_SwitchStep
                  |L2.658|
000292  7828              LDRB     r0,[r5,#0]            ;858  ; headlight_cnt
000294  2802              CMP      r0,#2                 ;858
000296  d103              BNE      |L2.672|
000298  202d              MOVS     r0,#0x2d              ;860
00029a  f7fffffe          BL       STATE_SwitchStep
00029e  702c              STRB     r4,[r5,#0]            ;861
                  |L2.672|
0002a0  e0e8              B        |L2.1140|
0002a2  7828              LDRB     r0,[r5,#0]            ;867  ; headlight_cnt
0002a4  1c40              ADDS     r0,r0,#1              ;867
0002a6  b2c0              UXTB     r0,r0                 ;867
0002a8  7028              STRB     r0,[r5,#0]            ;867
0002aa  2801              CMP      r0,#1                 ;868
0002ac  d102              BNE      |L2.692|
0002ae  2035              MOVS     r0,#0x35              ;870
0002b0  f7fffffe          BL       STATE_SwitchStep
                  |L2.692|
0002b4  7828              LDRB     r0,[r5,#0]            ;873  ; headlight_cnt
0002b6  2802              CMP      r0,#2                 ;873
0002b8  d103              BNE      |L2.706|
0002ba  2036              MOVS     r0,#0x36              ;875
0002bc  f7fffffe          BL       STATE_SwitchStep
0002c0  702c              STRB     r4,[r5,#0]            ;876
                  |L2.706|
0002c2  e0d7              B        |L2.1140|
0002c4  2099              MOVS     r0,#0x99              ;881
0002c6  f7fffffe          BL       STATE_SwitchStep
0002ca  e0d3              B        |L2.1140|
0002cc  20a2              MOVS     r0,#0xa2              ;885
0002ce  f7fffffe          BL       STATE_SwitchStep
0002d2  e0cf              B        |L2.1140|
0002d4  20b4              MOVS     r0,#0xb4              ;889
0002d6  f7fffffe          BL       STATE_SwitchStep
0002da  e0cb              B        |L2.1140|
                  |L2.732|
0002dc  4858              LDR      r0,|L2.1088|
0002de  7a8a              LDRB     r2,[r1,#0xa]          ;903
0002e0  3008              ADDS     r0,r0,#8              ;903
0002e2  7002              STRB     r2,[r0,#0]            ;903
0002e4  7aca              LDRB     r2,[r1,#0xb]          ;904
0002e6  7042              STRB     r2,[r0,#1]            ;904
0002e8  7b0a              LDRB     r2,[r1,#0xc]          ;905
0002ea  7082              STRB     r2,[r0,#2]            ;905
0002ec  7b49              LDRB     r1,[r1,#0xd]          ;906
0002ee  70c1              STRB     r1,[r0,#3]            ;906
0002f0  f7fffffe          BL       AVO_PIN_Reset
0002f4  4852              LDR      r0,|L2.1088|
0002f6  2200              MOVS     r2,#0                 ;913
0002f8  2104              MOVS     r1,#4                 ;913
0002fa  300c              ADDS     r0,r0,#0xc            ;913
0002fc  f7fffffe          BL       Vertical_Scrolling_Display
000300  7eb8              LDRB     r0,[r7,#0x1a]         ;915  ; dut_info
000302  b110              CBZ      r0,|L2.778|
000304  2801              CMP      r0,#1                 ;915
000306  d14e              BNE      |L2.934|
000308  e056              B        |L2.952|
                  |L2.778|
00030a  7df8              LDRB     r0,[r7,#0x17]         ;918  ; dut_info
00030c  2800              CMP      r0,#0                 ;918
00030e  d04a              BEQ      |L2.934|
000310  2802              CMP      r0,#2                 ;918
000312  d004              BEQ      |L2.798|
000314  2808              CMP      r0,#8                 ;918
000316  d047              BEQ      |L2.936|
000318  2809              CMP      r0,#9                 ;918
00031a  d144              BNE      |L2.934|
00031c  e048              B        |L2.944|
                  |L2.798|
00031e  7868              LDRB     r0,[r5,#1]            ;924  ; gnd_cnt
000320  1c40              ADDS     r0,r0,#1              ;924
000322  b2c0              UXTB     r0,r0                 ;924
000324  7068              STRB     r0,[r5,#1]            ;924
000326  2801              CMP      r0,#1                 ;925
000328  d105              BNE      |L2.822|
00032a  7e38              LDRB     r0,[r7,#0x18]         ;925  ; dut_info
00032c  2803              CMP      r0,#3                 ;925
00032e  d102              BNE      |L2.822|
000330  2004              MOVS     r0,#4                 ;927
000332  f7fffffe          BL       STATE_SwitchStep
                  |L2.822|
000336  7868              LDRB     r0,[r5,#1]            ;929  ; gnd_cnt
000338  2801              CMP      r0,#1                 ;929
00033a  d105              BNE      |L2.840|
00033c  7e38              LDRB     r0,[r7,#0x18]         ;929  ; dut_info
00033e  2802              CMP      r0,#2                 ;929
000340  d102              BNE      |L2.840|
000342  2006              MOVS     r0,#6                 ;931
000344  f7fffffe          BL       STATE_SwitchStep
                  |L2.840|
000348  7868              LDRB     r0,[r5,#1]            ;933  ; gnd_cnt
00034a  2801              CMP      r0,#1                 ;933
00034c  d105              BNE      |L2.858|
00034e  7e38              LDRB     r0,[r7,#0x18]         ;933  ; dut_info
000350  2801              CMP      r0,#1                 ;933
000352  d102              BNE      |L2.858|
000354  2004              MOVS     r0,#4                 ;935
000356  f7fffffe          BL       STATE_SwitchStep
                  |L2.858|
00035a  7868              LDRB     r0,[r5,#1]            ;937  ; gnd_cnt
00035c  2801              CMP      r0,#1                 ;937
00035e  d105              BNE      |L2.876|
000360  7e38              LDRB     r0,[r7,#0x18]         ;937  ; dut_info
000362  2804              CMP      r0,#4                 ;937
000364  d102              BNE      |L2.876|
000366  2008              MOVS     r0,#8                 ;939
000368  f7fffffe          BL       STATE_SwitchStep
                  |L2.876|
00036c  7868              LDRB     r0,[r5,#1]            ;941  ; gnd_cnt
00036e  2802              CMP      r0,#2                 ;941
000370  d106              BNE      |L2.896|
000372  7e38              LDRB     r0,[r7,#0x18]         ;941  ; dut_info
000374  2803              CMP      r0,#3                 ;941
000376  d103              BNE      |L2.896|
000378  2006              MOVS     r0,#6                 ;943
00037a  f7fffffe          BL       STATE_SwitchStep
00037e  706c              STRB     r4,[r5,#1]            ;944
                  |L2.896|
000380  7868              LDRB     r0,[r5,#1]            ;946  ; gnd_cnt
000382  2801              CMP      r0,#1                 ;946
000384  d105              BNE      |L2.914|
000386  7e38              LDRB     r0,[r7,#0x18]         ;946  ; dut_info
000388  2805              CMP      r0,#5                 ;946
00038a  d102              BNE      |L2.914|
00038c  2006              MOVS     r0,#6                 ;948
00038e  f7fffffe          BL       STATE_SwitchStep
                  |L2.914|
000392  7868              LDRB     r0,[r5,#1]            ;950  ; gnd_cnt
000394  2802              CMP      r0,#2                 ;950
000396  d16d              BNE      |L2.1140|
000398  7e38              LDRB     r0,[r7,#0x18]         ;950  ; dut_info
00039a  2805              CMP      r0,#5                 ;950
00039c  d16a              BNE      |L2.1140|
00039e  2008              MOVS     r0,#8                 ;952
0003a0  f7fffffe          BL       STATE_SwitchStep
0003a4  706c              STRB     r4,[r5,#1]            ;953
                  |L2.934|
0003a6  e065              B        |L2.1140|
                  |L2.936|
0003a8  2004              MOVS     r0,#4                 ;958
0003aa  f7fffffe          BL       STATE_SwitchStep
0003ae  e061              B        |L2.1140|
                  |L2.944|
0003b0  2006              MOVS     r0,#6                 ;962
0003b2  f7fffffe          BL       STATE_SwitchStep
0003b6  e05d              B        |L2.1140|
                  |L2.952|
0003b8  7df8              LDRB     r0,[r7,#0x17]         ;971  ; dut_info
0003ba  b3e8              CBZ      r0,|L2.1080|
0003bc  2802              CMP      r0,#2                 ;971
0003be  d004              BEQ      |L2.970|
0003c0  2808              CMP      r0,#8                 ;971
0003c2  d050              BEQ      |L2.1126|
0003c4  2809              CMP      r0,#9                 ;971
0003c6  d155              BNE      |L2.1140|
0003c8  e051              B        |L2.1134|
                  |L2.970|
0003ca  7868              LDRB     r0,[r5,#1]            ;977  ; gnd_cnt
0003cc  1c40              ADDS     r0,r0,#1              ;977
0003ce  b2c0              UXTB     r0,r0                 ;977
0003d0  7068              STRB     r0,[r5,#1]            ;977
0003d2  2801              CMP      r0,#1                 ;978
0003d4  d105              BNE      |L2.994|
0003d6  7e38              LDRB     r0,[r7,#0x18]         ;978  ; dut_info
0003d8  2803              CMP      r0,#3                 ;978
0003da  d102              BNE      |L2.994|
0003dc  2004              MOVS     r0,#4                 ;980
0003de  f7fffffe          BL       STATE_SwitchStep
                  |L2.994|
0003e2  7868              LDRB     r0,[r5,#1]            ;982  ; gnd_cnt
0003e4  2801              CMP      r0,#1                 ;982
0003e6  d105              BNE      |L2.1012|
0003e8  7e38              LDRB     r0,[r7,#0x18]         ;982  ; dut_info
0003ea  2802              CMP      r0,#2                 ;982
0003ec  d102              BNE      |L2.1012|
0003ee  2006              MOVS     r0,#6                 ;984
0003f0  f7fffffe          BL       STATE_SwitchStep
                  |L2.1012|
0003f4  7868              LDRB     r0,[r5,#1]            ;986  ; gnd_cnt
0003f6  2801              CMP      r0,#1                 ;986
0003f8  d105              BNE      |L2.1030|
0003fa  7e38              LDRB     r0,[r7,#0x18]         ;986  ; dut_info
0003fc  2801              CMP      r0,#1                 ;986
0003fe  d102              BNE      |L2.1030|
000400  2004              MOVS     r0,#4                 ;988
000402  f7fffffe          BL       STATE_SwitchStep
                  |L2.1030|
000406  7868              LDRB     r0,[r5,#1]            ;990  ; gnd_cnt
000408  2801              CMP      r0,#1                 ;990
00040a  d105              BNE      |L2.1048|
00040c  7e38              LDRB     r0,[r7,#0x18]         ;990  ; dut_info
00040e  2804              CMP      r0,#4                 ;990
000410  d102              BNE      |L2.1048|
000412  2008              MOVS     r0,#8                 ;992
000414  f7fffffe          BL       STATE_SwitchStep
                  |L2.1048|
000418  7868              LDRB     r0,[r5,#1]            ;994  ; gnd_cnt
00041a  2802              CMP      r0,#2                 ;994
00041c  d106              BNE      |L2.1068|
00041e  7e38              LDRB     r0,[r7,#0x18]         ;994  ; dut_info
000420  2803              CMP      r0,#3                 ;994
000422  d103              BNE      |L2.1068|
000424  2006              MOVS     r0,#6                 ;996
000426  f7fffffe          BL       STATE_SwitchStep
00042a  706c              STRB     r4,[r5,#1]            ;997
                  |L2.1068|
00042c  7868              LDRB     r0,[r5,#1]            ;999  ; gnd_cnt
00042e  2801              CMP      r0,#1                 ;999
000430  d10e              BNE      |L2.1104|
000432  7e38              LDRB     r0,[r7,#0x18]         ;999  ; dut_info
000434  2805              CMP      r0,#5                 ;999
000436  e007              B        |L2.1096|
                  |L2.1080|
000438  e014              B        |L2.1124|
00043a  0000              DCW      0x0000
                  |L2.1084|
                          DCD      dut_info
                  |L2.1088|
                          DCD      ||.data||
                  |L2.1092|
                          DCD      0x447a0000
                  |L2.1096|
000448  d102              BNE      |L2.1104|
00044a  2006              MOVS     r0,#6                 ;1001
00044c  f7fffffe          BL       STATE_SwitchStep
                  |L2.1104|
000450  7868              LDRB     r0,[r5,#1]            ;1003  ; gnd_cnt
000452  2802              CMP      r0,#2                 ;1003
000454  d10e              BNE      |L2.1140|
000456  7e38              LDRB     r0,[r7,#0x18]         ;1003  ; dut_info
000458  2805              CMP      r0,#5                 ;1003
00045a  d10b              BNE      |L2.1140|
00045c  2008              MOVS     r0,#8                 ;1005
00045e  f7fffffe          BL       STATE_SwitchStep
000462  706c              STRB     r4,[r5,#1]            ;1006
                  |L2.1124|
000464  e006              B        |L2.1140|
                  |L2.1126|
000466  2004              MOVS     r0,#4                 ;1011
000468  f7fffffe          BL       STATE_SwitchStep
00046c  e002              B        |L2.1140|
                  |L2.1134|
00046e  2006              MOVS     r0,#6                 ;1015
000470  f7fffffe          BL       STATE_SwitchStep
                  |L2.1140|
000474  f8b602ba          LDRH     r0,[r6,#0x2ba]        ;1035
000478  1c40              ADDS     r0,r0,#1              ;1035
00047a  b280              UXTH     r0,r0                 ;1035
00047c  fbb0f1f8          UDIV     r1,r0,r8              ;1036
000480  fb080011          MLS      r0,r8,r1,r0           ;1036
000484  f8a602ba          STRH     r0,[r6,#0x2ba]        ;1036
000488  e5d9              B        |L2.62|
;;;1038   
                          ENDP


                          AREA ||i.AVO_PROTOCOL_ConfirmTempCmdFrameBuff||, CODE, READONLY, ALIGN=1

                  AVO_PROTOCOL_ConfirmTempCmdFrameBuff PROC
;;;233    // 将临时缓冲区添加到命令帧缓冲区中，其本质操作是承认临时缓冲区数据有效
;;;234    BOOL AVO_PROTOCOL_ConfirmTempCmdFrameBuff(AVO_PROTOCOL_CB *pCB)
000000  2800              CMP      r0,#0
;;;235    {
000002  d01e              BEQ      |L3.66|
;;;236        AVO_PROTOCOL_RX_CMD_FRAME *pCmdFrame = NULL;
;;;237    
;;;238        // 参数合法性检验
;;;239        if (NULL == pCB)
;;;240        {
;;;241            return FALSE;
;;;242        }
;;;243    
;;;244        // 临时缓冲区为空，不予添加
;;;245        pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.end];
000004  f8b012bc          LDRH     r1,[r0,#0x2bc]
000008  eb0102c1          ADD      r2,r1,r1,LSL #3
00000c  eb021241          ADD      r2,r2,r1,LSL #5
000010  eb000282          ADD      r2,r0,r2,LSL #2
;;;246        if (0 == pCmdFrame->length)
000014  f8b22170          LDRH     r2,[r2,#0x170]
000018  b1aa              CBZ      r2,|L3.70|
;;;247        {
;;;248            return FALSE;
;;;249        }
;;;250    
;;;251        // 添加
;;;252        pCB->rx.end++;
00001a  1c49              ADDS     r1,r1,#1
00001c  b289              UXTH     r1,r1
;;;253        pCB->rx.end %= AVO_PROTOCOL_RX_QUEUE_SIZE;
00001e  2203              MOVS     r2,#3
000020  fbb1f3f2          UDIV     r3,r1,r2
000024  fb021113          MLS      r1,r2,r3,r1
000028  f8a012bc          STRH     r1,[r0,#0x2bc]
;;;254        pCB->rx.cmdQueue[pCB->rx.end].length = 0; // 该行的作用是将新的添加位置有效数据个数清零，以便将这个位置当做临时帧缓冲区
00002c  eb0103c1          ADD      r3,r1,r1,LSL #3
000030  eb031141          ADD      r1,r3,r1,LSL #5
000034  eb000081          ADD      r0,r0,r1,LSL #2
000038  2200              MOVS     r2,#0
00003a  f8a02170          STRH     r2,[r0,#0x170]
;;;255    
;;;256        return TRUE;
00003e  2001              MOVS     r0,#1
;;;257    }
000040  4770              BX       lr
                  |L3.66|
000042  2000              MOVS     r0,#0                 ;241
000044  4770              BX       lr
                  |L3.70|
000046  2000              MOVS     r0,#0                 ;248
000048  4770              BX       lr
;;;258    
                          ENDP


                          AREA ||i.AVO_PROTOCOL_DataStructInit||, CODE, READONLY, ALIGN=1

                  AVO_PROTOCOL_DataStructInit PROC
;;;168    // 数据结构初始化
;;;169    void AVO_PROTOCOL_DataStructInit(AVO_PROTOCOL_CB *pCB)
000000  2800              CMP      r0,#0
;;;170    {
000002  d02b              BEQ      |L4.92|
;;;171        uint16 i;
;;;172    
;;;173        // 参数合法性检验
;;;174        if (NULL == pCB)
;;;175        {
;;;176            return;
;;;177        }
;;;178    
;;;179        pCB->tx.txBusy = FALSE;
000004  2200              MOVS     r2,#0
000006  f88024b0          STRB     r2,[r0,#0x4b0]
;;;180        pCB->tx.index = 0;
00000a  f8a024ae          STRH     r2,[r0,#0x4ae]
;;;181        pCB->tx.head = 0;
00000e  f8a024aa          STRH     r2,[r0,#0x4aa]
;;;182        pCB->tx.end = 0;
000012  f8a024ac          STRH     r2,[r0,#0x4ac]
;;;183        for (i = 0; i < AVO_PROTOCOL_TX_QUEUE_SIZE; i++)
000016  2100              MOVS     r1,#0
                  |L4.24|
;;;184        {
;;;185            pCB->tx.cmdQueue[i].length = 0;
000018  eb0103c1          ADD      r3,r1,r1,LSL #3
00001c  eb031341          ADD      r3,r3,r1,LSL #5
000020  eb000383          ADD      r3,r0,r3,LSL #2
000024  f8a32360          STRH     r2,[r3,#0x360]
000028  1c49              ADDS     r1,r1,#1              ;183
00002a  b289              UXTH     r1,r1                 ;183
00002c  2903              CMP      r1,#3                 ;183
00002e  d3f3              BCC      |L4.24|
;;;186        }
;;;187    
;;;188        pCB->rxFIFO.head = 0;
000030  f8202fc8          STRH     r2,[r0,#0xc8]!
;;;189        pCB->rxFIFO.end = 0;
000034  8042              STRH     r2,[r0,#2]
;;;190        pCB->rxFIFO.currentProcessIndex = 0;
000036  8082              STRH     r2,[r0,#4]
;;;191    
;;;192        pCB->rx.head = 0;
000038  f8a021f2          STRH     r2,[r0,#0x1f2]
;;;193        pCB->rx.end = 0;
00003c  f8a021f4          STRH     r2,[r0,#0x1f4]
000040  38c8              SUBS     r0,r0,#0xc8
;;;194        for (i = 0; i < AVO_PROTOCOL_RX_QUEUE_SIZE; i++)
000042  2100              MOVS     r1,#0
                  |L4.68|
;;;195        {
;;;196            pCB->rx.cmdQueue[i].length = 0;
000044  eb0103c1          ADD      r3,r1,r1,LSL #3
000048  eb031341          ADD      r3,r3,r1,LSL #5
00004c  eb000383          ADD      r3,r0,r3,LSL #2
000050  f8a32170          STRH     r2,[r3,#0x170]
000054  1c49              ADDS     r1,r1,#1              ;194
000056  b289              UXTH     r1,r1                 ;194
000058  2903              CMP      r1,#3                 ;194
00005a  d3f3              BCC      |L4.68|
                  |L4.92|
;;;197        }
;;;198    
;;;199        //pCB->isTimeCheck = FALSE;
;;;200    }
00005c  4770              BX       lr
;;;201    
                          ENDP


                          AREA ||i.AVO_PROTOCOL_Init||, CODE, READONLY, ALIGN=2

                  AVO_PROTOCOL_Init PROC
;;;68     // 协议初始化
;;;69     void AVO_PROTOCOL_Init(void)
000000  b510              PUSH     {r4,lr}
;;;70     {
;;;71         // 协议层数据结构初始化
;;;72         AVO_PROTOCOL_DataStructInit(&AVOProtocolCB);
000002  4805              LDR      r0,|L5.24|
000004  f7fffffe          BL       AVO_PROTOCOL_DataStructInit
;;;73     
;;;74         // 向驱动层注册数据接收接口
;;;75         AVO_UART_RegisterDataSendService(AVO_PROTOCOL_MacProcess);
000008  4804              LDR      r0,|L5.28|
00000a  f7fffffe          BL       AVO_UART_RegisterDataSendService
;;;76     
;;;77         // 向驱动层注册数据发送接口
;;;78         AVO_PROTOCOL_RegisterDataSendService(AVO_UART_AddTxArray);
00000e  e8bd4010          POP      {r4,lr}
000012  4803              LDR      r0,|L5.32|
000014  f7ffbffe          B.W      AVO_PROTOCOL_RegisterDataSendService
;;;79     }
;;;80     
                          ENDP

                  |L5.24|
                          DCD      ||.bss||
                  |L5.28|
                          DCD      AVO_PROTOCOL_MacProcess
                  |L5.32|
                          DCD      AVO_UART_AddTxArray

                          AREA ||i.AVO_PROTOCOL_MacProcess||, CODE, READONLY, ALIGN=2

                  AVO_PROTOCOL_MacProcess PROC
;;;202    // UART报文接收处理函数(注意根据具体模块修改)
;;;203    void AVO_PROTOCOL_MacProcess(uint16 standarID, uint8 *pData, uint16 length)
000000  b570              PUSH     {r4-r6,lr}
;;;204    {
;;;205        uint16 end = AVOProtocolCB.rxFIFO.end;
000002  480d              LDR      r0,|L6.56|
000004  f8b020ca          LDRH     r2,[r0,#0xca]  ; AVOProtocolCB
;;;206        uint16 head = AVOProtocolCB.rxFIFO.head;
000008  f8b040c8          LDRH     r4,[r0,#0xc8]  ; AVOProtocolCB
;;;207        uint8 rxdata = 0x00;
;;;208    
;;;209        // 接收数据
;;;210        rxdata = *pData;
00000c  780d              LDRB     r5,[r1,#0]
;;;211    
;;;212        // 一级缓冲区已满，不予接收
;;;213        if ((end + 1) % AVO_PROTOCOL_RX_FIFO_SIZE == head)
00000e  1c53              ADDS     r3,r2,#1
000010  21c8              MOVS     r1,#0xc8
000012  fbb3f6f1          UDIV     r6,r3,r1
000016  fb013316          MLS      r3,r1,r6,r3
00001a  42a3              CMP      r3,r4
00001c  d00a              BEQ      |L6.52|
;;;214        {
;;;215            return;
;;;216        }
;;;217        // 一级缓冲区未满，接收
;;;218        else
;;;219        {
;;;220            // 将接收到的数据放到临时缓冲区中
;;;221            AVOProtocolCB.rxFIFO.buff[end] = rxdata;
00001e  5485              STRB     r5,[r0,r2]
;;;222            AVOProtocolCB.rxFIFO.end++;
000020  f8302fca          LDRH     r2,[r0,#0xca]!  ; AVOProtocolCB
000024  1c52              ADDS     r2,r2,#1
000026  8002              STRH     r2,[r0,#0]
;;;223            AVOProtocolCB.rxFIFO.end %= AVO_PROTOCOL_RX_FIFO_SIZE;
000028  8802              LDRH     r2,[r0,#0]  ; AVOProtocolCB
00002a  fbb2f3f1          UDIV     r3,r2,r1
00002e  fb012113          MLS      r1,r1,r3,r2
000032  8001              STRH     r1,[r0,#0]
                  |L6.52|
;;;224        }
;;;225    }
000034  bd70              POP      {r4-r6,pc}
;;;226    
                          ENDP

000036  0000              DCW      0x0000
                  |L6.56|
                          DCD      ||.bss||

                          AREA ||i.AVO_PROTOCOL_Process||, CODE, READONLY, ALIGN=2

                  AVO_PROTOCOL_Process PROC
;;;81     // AVO协议层过程处理
;;;82     void AVO_PROTOCOL_Process(void)
000000  b510              PUSH     {r4,lr}
;;;83     {
;;;84         // AVO接收FIFO缓冲区处理
;;;85         AVO_PROTOCOL_RxFIFOProcess(&AVOProtocolCB);
000002  4805              LDR      r0,|L7.24|
000004  f7fffffe          BL       AVO_PROTOCOL_RxFIFOProcess
;;;86     
;;;87         // AVO接收命令缓冲区处理
;;;88         AVO_PROTOCOL_CmdFrameProcess(&AVOProtocolCB);
000008  4803              LDR      r0,|L7.24|
00000a  f7fffffe          BL       AVO_PROTOCOL_CmdFrameProcess
;;;89     
;;;90         // AVO协议层发送处理过程
;;;91         AVO_PROTOCOL_TxStateProcess();
00000e  e8bd4010          POP      {r4,lr}
000012  f7ffbffe          B.W      AVO_PROTOCOL_TxStateProcess
;;;92     }
;;;93     
                          ENDP

000016  0000              DCW      0x0000
                  |L7.24|
                          DCD      ||.bss||

                          AREA ||i.AVO_PROTOCOL_RegisterDataSendService||, CODE, READONLY, ALIGN=2

                  AVO_PROTOCOL_RegisterDataSendService PROC
;;;227    // UART协议层向驱动层注册数据发送接口
;;;228    void AVO_PROTOCOL_RegisterDataSendService(BOOL (*service)(uint16 id, uint8 *pData, uint16 length))
000000  4901              LDR      r1,|L8.8|
;;;229    {
;;;230        AVOProtocolCB.sendDataThrowService = service;
000002  f8c104b4          STR      r0,[r1,#0x4b4]  ; AVOProtocolCB
;;;231    }
000006  4770              BX       lr
;;;232    
                          ENDP

                  |L8.8|
                          DCD      ||.bss||

                          AREA ||i.AVO_PROTOCOL_RxFIFOProcess||, CODE, READONLY, ALIGN=1

                  AVO_PROTOCOL_RxFIFOProcess PROC
;;;292    // 一级接收缓冲区处理，从一级接收缓冲区中取出一个字节添加到命令帧缓冲区中
;;;293    void AVO_PROTOCOL_RxFIFOProcess(AVO_PROTOCOL_CB *pCB)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;294    {
000004  4604              MOV      r4,r0
;;;295        uint16 end = pCB->rxFIFO.end;
000006  f8b410ca          LDRH     r1,[r4,#0xca]
;;;296        uint16 head = pCB->rxFIFO.head;
00000a  f8b400c8          LDRH     r0,[r4,#0xc8]
;;;297        AVO_PROTOCOL_RX_CMD_FRAME *pCmdFrame = NULL;
;;;298        uint16 length = 0;
;;;299        uint8 currentData = 0;
;;;300    
;;;301        // 参数合法性检验
;;;302        if (NULL == pCB)
00000e  2c00              CMP      r4,#0
000010  d023              BEQ      |L9.90|
;;;303        {
;;;304            return;
;;;305        }
;;;306    
;;;307        // 一级缓冲区为空，退出
;;;308        if (head == end)
000012  4288              CMP      r0,r1
000014  d021              BEQ      |L9.90|
;;;309        {
;;;310            return;
;;;311        }
;;;312    
;;;313        // 获取临时缓冲区指针
;;;314        pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.end];
000016  f8b402bc          LDRH     r0,[r4,#0x2bc]
00001a  eb0002c0          ADD      r2,r0,r0,LSL #3
00001e  eb021240          ADD      r2,r2,r0,LSL #5
000022  eb040582          ADD      r5,r4,r2,LSL #2
000026  35ce              ADDS     r5,r5,#0xce
;;;315        // 取出当前要处理的字节
;;;316        currentData = pCB->rxFIFO.buff[pCB->rxFIFO.currentProcessIndex];
000028  f8b420cc          LDRH     r2,[r4,#0xcc]
00002c  5ca2              LDRB     r2,[r4,r2]
;;;317    
;;;318        // 临时缓冲区长度为0时，搜索首字节
;;;319        if (0 == pCmdFrame->length)
00002e  f8b530a2          LDRH     r3,[r5,#0xa2]
;;;320        {
;;;321            // 命令头错误，删除当前字节并退出
;;;322            if (AVO_PROTOCOL_CMD_HEAD1 != currentData)
;;;323            {
;;;324                pCB->rxFIFO.head++;
;;;325                pCB->rxFIFO.head %= AVO_PROTOCOL_RX_FIFO_SIZE;
000032  27c8              MOVS     r7,#0xc8
000034  b19b              CBZ      r3,|L9.94|
;;;326                pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;327    
;;;328                return;
;;;329            }
;;;330    
;;;331            // 命令头正确，但无临时缓冲区可用，退出
;;;332            if ((pCB->rx.end + 1) % AVO_PROTOCOL_RX_QUEUE_SIZE == pCB->rx.head)
;;;333            {
;;;334                return;
;;;335            }
;;;336    
;;;337            // 添加UART通讯超时时间设置-2016.1.5增加
;;;338    #if AVO_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;339            TIMER_AddTask(TIMER_ID_UART_RX_TIME_OUT_CONTROL,
;;;340                          AVO_PROTOCOL_BUS_UNIDIRECTIONAL_TIME_OUT,
;;;341                          AVO_PROTOCOL_CALLBACK_RxTimeOut,
;;;342                          0,
;;;343                          1,
;;;344                          ACTION_MODE_ADD_TO_QUEUE);
;;;345    #endif
;;;346    
;;;347            // 命令头正确，有临时缓冲区可用，则将其添加到命令帧临时缓冲区中
;;;348            pCmdFrame->buff[pCmdFrame->length++] = currentData;
;;;349            pCB->rxFIFO.currentProcessIndex++;
;;;350            pCB->rxFIFO.currentProcessIndex %= AVO_PROTOCOL_RX_FIFO_SIZE;
;;;351        }
;;;352        // 非首字节，将数据添加到命令帧临时缓冲区中，但暂不删除当前数据
;;;353        else
;;;354        {
;;;355            // 临时缓冲区溢出，说明当前正在接收的命令帧是错误的，正确的命令帧不会出现长度溢出的情况
;;;356            if (pCmdFrame->length >= AVO_PROTOCOL_RX_CMD_FRAME_LENGTH_MAX)
000036  f04f0800          MOV      r8,#0
00003a  2ba0              CMP      r3,#0xa0
00003c  d37e              BCC      |L9.316|
;;;357            {
;;;358    #if AVO_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;359                // 停止RX通讯超时检测
;;;360                BLE_PROTOCOL_StopRxTimeOutCheck();
;;;361    #endif
;;;362    
;;;363                // 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;364                pCmdFrame->length = 0; // 2016.1.5增加
00003e  f8a580a2          STRH     r8,[r5,#0xa2]
;;;365                // 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;366                pCB->rxFIFO.head++;
000042  f8340fc8          LDRH     r0,[r4,#0xc8]!
000046  1c40              ADDS     r0,r0,#1
000048  8020              STRH     r0,[r4,#0]
;;;367                pCB->rxFIFO.head %= AVO_PROTOCOL_RX_FIFO_SIZE;
00004a  8820              LDRH     r0,[r4,#0]
00004c  fbb0f1f7          UDIV     r1,r0,r7
000050  fb070011          MLS      r0,r7,r1,r0
000054  8020              STRH     r0,[r4,#0]
;;;368                pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
000056  8820              LDRH     r0,[r4,#0]
000058  80a0              STRH     r0,[r4,#4]
                  |L9.90|
;;;369    
;;;370                return;
;;;371            }
;;;372    
;;;373            // 一直取到末尾
;;;374            while (end != pCB->rxFIFO.currentProcessIndex)
;;;375            {
;;;376                // 取出当前要处理的字节
;;;377                currentData = pCB->rxFIFO.buff[pCB->rxFIFO.currentProcessIndex];
;;;378                // 缓冲区未溢出，正常接收，将数据添加到临时缓冲区中
;;;379                pCmdFrame->buff[pCmdFrame->length++] = currentData;
;;;380                pCB->rxFIFO.currentProcessIndex++;
;;;381                pCB->rxFIFO.currentProcessIndex %= AVO_PROTOCOL_RX_FIFO_SIZE;
;;;382    
;;;383                // ■■接下来，需要检查命令帧是否完整，如果完整，则将命令帧临时缓冲区扶正 ■■
;;;384    
;;;385                // 首先判断命令帧最小长度，一个完整的命令字至少包括8个字节: 命令头、设备地址、命令字、数据长度、校验和L、校验和H、结束标识0xD、结束标识OxA，因此不足8个字节的必定不完整
;;;386                if (pCmdFrame->length < AVO_PROTOCOL_CMD_FRAME_LENGTH_MIN)
;;;387                {
;;;388                    // 继续接收
;;;389                    continue;
;;;390                }
;;;391    
;;;392                // 命令帧长度数值越界，说明当前命令帧错误，停止接收
;;;393                if (pCmdFrame->buff[AVO_PROTOCOL_CMD_LENGTH_INDEX] > (AVO_PROTOCOL_RX_CMD_FRAME_LENGTH_MAX - AVO_PROTOCOL_CMD_FRAME_LENGTH_MIN))
;;;394                {
;;;395    #if AVO_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;396                    // 停止RX通讯超时检测
;;;397                    AVO_PROTOCOL_StopRxTimeOutCheck();
;;;398    #endif
;;;399    
;;;400                    // 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;401                    pCmdFrame->length = 0;
;;;402                    // 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;403                    pCB->rxFIFO.head++;
;;;404                    pCB->rxFIFO.head %= AVO_PROTOCOL_RX_FIFO_SIZE;
;;;405                    pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;406    
;;;407                    return;
;;;408                }
;;;409    
;;;410                // 命令帧长度校验
;;;411                length = pCmdFrame->length;
;;;412                if (length < pCmdFrame->buff[AVO_PROTOCOL_CMD_LENGTH_INDEX] + AVO_PROTOCOL_CMD_FRAME_LENGTH_MIN)
;;;413                {
;;;414                    // 长度要求不一致，说明未接收完毕，退出继续
;;;415                    continue;
;;;416                }
;;;417    
;;;418                // 命令帧长度OK，则进行校验，失败时删除命令头
;;;419                if (!AVO_PROTOCOL_CheckSUM(pCmdFrame))
;;;420                {
;;;421    #if AVO_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;422                    // 停止RX通讯超时检测
;;;423                    AVO_PROTOCOL_StopRxTimeOutCheck();
;;;424    #endif
;;;425    
;;;426                    // 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;427                    pCmdFrame->length = 0;
;;;428                    // 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;429                    pCB->rxFIFO.head++;
;;;430                    pCB->rxFIFO.head %= AVO_PROTOCOL_RX_FIFO_SIZE;
;;;431                    pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;432    
;;;433                    return;
;;;434                }
;;;435    
;;;436    #if AVO_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;437                // 停止RX通讯超时检测
;;;438                AVO_PROTOCOL_StopRxTimeOutCheck();
;;;439    #endif
;;;440                // 执行到这里，即说明接收到了一个完整并且正确的命令帧，此时需将处理过的数据从一级缓冲区中删除，并将该命令帧扶正
;;;441                pCB->rxFIFO.head += length;
;;;442                pCB->rxFIFO.head %= AVO_PROTOCOL_RX_FIFO_SIZE;
;;;443                pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;444                AVO_PROTOCOL_ConfirmTempCmdFrameBuff(pCB);
;;;445    
;;;446                return;
;;;447            }
;;;448        }
;;;449    }
00005a  e8bd81f0          POP      {r4-r8,pc}
                  |L9.94|
00005e  2a55              CMP      r2,#0x55              ;322
000060  d00c              BEQ      |L9.124|
000062  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;324
000066  1c40              ADDS     r0,r0,#1              ;324
000068  8020              STRH     r0,[r4,#0]            ;324
00006a  8820              LDRH     r0,[r4,#0]            ;325
00006c  fbb0f1f7          UDIV     r1,r0,r7              ;325
000070  fb070011          MLS      r0,r7,r1,r0           ;325
000074  8020              STRH     r0,[r4,#0]            ;325
000076  8820              LDRH     r0,[r4,#0]            ;326
000078  80a0              STRH     r0,[r4,#4]            ;326
00007a  e7ee              B        |L9.90|
                  |L9.124|
00007c  1c40              ADDS     r0,r0,#1              ;332
00007e  2103              MOVS     r1,#3                 ;332
000080  fbb0f3f1          UDIV     r3,r0,r1              ;332
000084  fb010013          MLS      r0,r1,r3,r0           ;332
000088  f8b412ba          LDRH     r1,[r4,#0x2ba]        ;332
00008c  4288              CMP      r0,r1                 ;332
00008e  d0e4              BEQ      |L9.90|
000090  2001              MOVS     r0,#1                 ;348
000092  f8a500a2          STRH     r0,[r5,#0xa2]         ;348
000096  70aa              STRB     r2,[r5,#2]            ;348
000098  f8340fcc          LDRH     r0,[r4,#0xcc]!        ;349
00009c  1c40              ADDS     r0,r0,#1              ;349
00009e  b280              UXTH     r0,r0                 ;349
0000a0  fbb0f1f7          UDIV     r1,r0,r7              ;350
0000a4  fb070011          MLS      r0,r7,r1,r0           ;350
0000a8  8020              STRH     r0,[r4,#0]            ;350
0000aa  e7d6              B        |L9.90|
                  |L9.172|
0000ac  5c22              LDRB     r2,[r4,r0]            ;377
0000ae  f8b500a2          LDRH     r0,[r5,#0xa2]         ;379
0000b2  1c43              ADDS     r3,r0,#1              ;379
0000b4  4428              ADD      r0,r0,r5              ;379
0000b6  f8a530a2          STRH     r3,[r5,#0xa2]         ;379
0000ba  7082              STRB     r2,[r0,#2]            ;379
0000bc  f8b400cc          LDRH     r0,[r4,#0xcc]         ;380
0000c0  1c40              ADDS     r0,r0,#1              ;380
0000c2  b280              UXTH     r0,r0                 ;380
0000c4  fbb0f2f7          UDIV     r2,r0,r7              ;381
0000c8  fb070012          MLS      r0,r7,r2,r0           ;381
0000cc  f8a400cc          STRH     r0,[r4,#0xcc]         ;381
0000d0  f8b560a2          LDRH     r6,[r5,#0xa2]         ;386
0000d4  2e06              CMP      r6,#6                 ;386
0000d6  d33b              BCC      |L9.336|
0000d8  79a8              LDRB     r0,[r5,#6]            ;393
0000da  289a              CMP      r0,#0x9a              ;393
0000dc  d90e              BLS      |L9.252|
0000de  f8a580a2          STRH     r8,[r5,#0xa2]         ;401
0000e2  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;403
0000e6  1c40              ADDS     r0,r0,#1              ;403
0000e8  8020              STRH     r0,[r4,#0]            ;403
0000ea  8820              LDRH     r0,[r4,#0]            ;404
0000ec  fbb0f1f7          UDIV     r1,r0,r7              ;404
0000f0  fb070011          MLS      r0,r7,r1,r0           ;404
0000f4  8020              STRH     r0,[r4,#0]            ;404
0000f6  8820              LDRH     r0,[r4,#0]            ;405
0000f8  80a0              STRH     r0,[r4,#4]            ;405
0000fa  e7ae              B        |L9.90|
                  |L9.252|
0000fc  1d80              ADDS     r0,r0,#6              ;412
0000fe  42b0              CMP      r0,r6                 ;412
000100  d826              BHI      |L9.336|
000102  4628              MOV      r0,r5                 ;419
000104  f7fffffe          BL       AVO_PROTOCOL_CheckSUM
000108  b188              CBZ      r0,|L9.302|
00010a  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;441
00010e  4430              ADD      r0,r0,r6              ;441
000110  8020              STRH     r0,[r4,#0]            ;441
000112  8820              LDRH     r0,[r4,#0]            ;442
000114  fbb0f1f7          UDIV     r1,r0,r7              ;442
000118  fb070011          MLS      r0,r7,r1,r0           ;442
00011c  8020              STRH     r0,[r4,#0]            ;442
00011e  8820              LDRH     r0,[r4,#0]            ;443
000120  80a0              STRH     r0,[r4,#4]            ;443
000122  3cc8              SUBS     r4,r4,#0xc8           ;443
000124  4620              MOV      r0,r4                 ;444
000126  e8bd41f0          POP      {r4-r8,lr}            ;444
00012a  f7ffbffe          B.W      AVO_PROTOCOL_ConfirmTempCmdFrameBuff
                  |L9.302|
00012e  f8a580a2          STRH     r8,[r5,#0xa2]         ;427
000132  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;429
000136  1c40              ADDS     r0,r0,#1              ;429
000138  8020              STRH     r0,[r4,#0]            ;429
00013a  e000              B        |L9.318|
                  |L9.316|
00013c  e008              B        |L9.336|
                  |L9.318|
00013e  8820              LDRH     r0,[r4,#0]            ;430
000140  fbb0f1f7          UDIV     r1,r0,r7              ;430
000144  fb070011          MLS      r0,r7,r1,r0           ;430
000148  8020              STRH     r0,[r4,#0]            ;430
00014a  8820              LDRH     r0,[r4,#0]            ;431
00014c  80a0              STRH     r0,[r4,#4]            ;431
00014e  e784              B        |L9.90|
                  |L9.336|
000150  f8b400cc          LDRH     r0,[r4,#0xcc]         ;374
000154  4288              CMP      r0,r1                 ;374
000156  d1a9              BNE      |L9.172|
000158  e77f              B        |L9.90|
;;;450    
                          ENDP


                          AREA ||i.AVO_PROTOCOL_SendCmdResult||, CODE, READONLY, ALIGN=1

                  AVO_PROTOCOL_SendCmdResult PROC
;;;485    // 上报命令执行结果
;;;486    void AVO_PROTOCOL_SendCmdResult(uint32 cmd, uint32 param)
000000  b530              PUSH     {r4,r5,lr}
;;;487    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;488        AVO_PROTOCOL_TxAddData(AVO_PROTOCOL_CMD_HEAD1);
000006  2055              MOVS     r0,#0x55
000008  f7fffffe          BL       AVO_PROTOCOL_TxAddData
;;;489        AVO_PROTOCOL_TxAddData(AVO_PROTOCOL_CMD_HEAD2);
00000c  2000              MOVS     r0,#0
00000e  f7fffffe          BL       AVO_PROTOCOL_TxAddData
;;;490        AVO_PROTOCOL_TxAddData(AVO_PROTOCOL_CMD_HEAD3);
000012  20aa              MOVS     r0,#0xaa
000014  f7fffffe          BL       AVO_PROTOCOL_TxAddData
;;;491    
;;;492        AVO_PROTOCOL_TxAddData(AVO_PROTOCOL_CMD_PROTOCOL_VERSION);
000018  2001              MOVS     r0,#1
00001a  f7fffffe          BL       AVO_PROTOCOL_TxAddData
;;;493        AVO_PROTOCOL_TxAddData(AVO_PROTOCOL_CMD_DEVICE_ADDR);
00001e  2010              MOVS     r0,#0x10
000020  f7fffffe          BL       AVO_PROTOCOL_TxAddData
;;;494        AVO_PROTOCOL_TxAddData(cmd);
000024  b2e8              UXTB     r0,r5
000026  f7fffffe          BL       AVO_PROTOCOL_TxAddData
;;;495        AVO_PROTOCOL_TxAddData(0);
00002a  2000              MOVS     r0,#0
00002c  f7fffffe          BL       AVO_PROTOCOL_TxAddData
;;;496        AVO_PROTOCOL_TxAddData(2);
000030  2002              MOVS     r0,#2
000032  f7fffffe          BL       AVO_PROTOCOL_TxAddData
;;;497    
;;;498        // 写入字节数
;;;499        AVO_PROTOCOL_TxAddData(1);
000036  2001              MOVS     r0,#1
000038  f7fffffe          BL       AVO_PROTOCOL_TxAddData
;;;500    
;;;501        // 写入结果
;;;502        AVO_PROTOCOL_TxAddData((uint8)param);
00003c  b2e0              UXTB     r0,r4
00003e  f7fffffe          BL       AVO_PROTOCOL_TxAddData
;;;503    
;;;504        AVO_PROTOCOL_TxAddFrame();
000042  e8bd4030          POP      {r4,r5,lr}
000046  f7ffbffe          B.W      AVO_PROTOCOL_TxAddFrame
;;;505    }
;;;506    
                          ENDP


                          AREA ||i.AVO_PROTOCOL_Send_Mesuretype||, CODE, READONLY, ALIGN=1

                  AVO_PROTOCOL_Send_Mesuretype PROC
;;;507    // 下发测量类型命令, 通道默认为0
;;;508    void AVO_PROTOCOL_Send_Mesuretype(uint32 mesuretype)
000000  b510              PUSH     {r4,lr}
;;;509    {
000002  4604              MOV      r4,r0
;;;510        AVO_PROTOCOL_TxAddData(AVO_PROTOCOL_CMD_HEAD1);
000004  2055              MOVS     r0,#0x55
000006  f7fffffe          BL       AVO_PROTOCOL_TxAddData
;;;511        AVO_PROTOCOL_TxAddData(AVO_PROTOCOL_CMD_HEAD2);
00000a  2000              MOVS     r0,#0
00000c  f7fffffe          BL       AVO_PROTOCOL_TxAddData
;;;512        AVO_PROTOCOL_TxAddData(AVO_PROTOCOL_CMD_HEAD3);
000010  20aa              MOVS     r0,#0xaa
000012  f7fffffe          BL       AVO_PROTOCOL_TxAddData
;;;513        AVO_PROTOCOL_TxAddData(AVO_CMD_AVOMETER);
000016  20b0              MOVS     r0,#0xb0
000018  f7fffffe          BL       AVO_PROTOCOL_TxAddData
;;;514        // Length
;;;515        AVO_PROTOCOL_TxAddData(0x03);
00001c  2003              MOVS     r0,#3
00001e  f7fffffe          BL       AVO_PROTOCOL_TxAddData
;;;516        // Target board number
;;;517        AVO_PROTOCOL_TxAddData(BOARD_AVO);
000022  2004              MOVS     r0,#4
000024  f7fffffe          BL       AVO_PROTOCOL_TxAddData
;;;518        AVO_PROTOCOL_TxAddData(mesuretype);
000028  b2e0              UXTB     r0,r4
00002a  f7fffffe          BL       AVO_PROTOCOL_TxAddData
;;;519        AVO_PROTOCOL_TxAddData(0);
00002e  2000              MOVS     r0,#0
000030  f7fffffe          BL       AVO_PROTOCOL_TxAddData
;;;520        // Assemble command frame
;;;521        AVO_PROTOCOL_TxAddFrame();
000034  e8bd4010          POP      {r4,lr}
000038  f7ffbffe          B.W      AVO_PROTOCOL_TxAddFrame
;;;522    }
;;;523    
                          ENDP


                          AREA ||i.AVO_PROTOCOL_Send_Reset||, CODE, READONLY, ALIGN=1

                  AVO_PROTOCOL_Send_Reset PROC
;;;524    // 下发复位命令
;;;525    void AVO_PROTOCOL_Send_Reset(void)
000000  b500              PUSH     {lr}
;;;526    {
;;;527        AVO_PROTOCOL_TxAddData(AVO_PROTOCOL_CMD_HEAD1);
000002  2055              MOVS     r0,#0x55
000004  f7fffffe          BL       AVO_PROTOCOL_TxAddData
;;;528        AVO_PROTOCOL_TxAddData(AVO_PROTOCOL_CMD_HEAD2);
000008  2000              MOVS     r0,#0
00000a  f7fffffe          BL       AVO_PROTOCOL_TxAddData
;;;529        AVO_PROTOCOL_TxAddData(AVO_PROTOCOL_CMD_HEAD3);
00000e  20aa              MOVS     r0,#0xaa
000010  f7fffffe          BL       AVO_PROTOCOL_TxAddData
;;;530        AVO_PROTOCOL_TxAddData(AVO_CMD_AVORESET);
000014  20b1              MOVS     r0,#0xb1
000016  f7fffffe          BL       AVO_PROTOCOL_TxAddData
;;;531        // Length
;;;532        AVO_PROTOCOL_TxAddData(0x01);
00001a  2001              MOVS     r0,#1
00001c  f7fffffe          BL       AVO_PROTOCOL_TxAddData
;;;533        // Target board number
;;;534        AVO_PROTOCOL_TxAddData(BOARD_AVO);
000020  2004              MOVS     r0,#4
000022  f7fffffe          BL       AVO_PROTOCOL_TxAddData
;;;535        // Assemble command frame
;;;536        AVO_PROTOCOL_TxAddFrame();
000026  f85deb04          POP      {lr}
00002a  f7ffbffe          B.W      AVO_PROTOCOL_TxAddFrame
;;;537    }
;;;538    
                          ENDP


                          AREA ||i.AVO_PROTOCOL_Send_Type_Chl||, CODE, READONLY, ALIGN=1

                  AVO_PROTOCOL_Send_Type_Chl PROC
;;;539    // 下发测量类型和测量通道命令
;;;540    void AVO_PROTOCOL_Send_Type_Chl(uint32 mesuretype, uint32 mesurechl)
000000  b530              PUSH     {r4,r5,lr}
;;;541    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;542        AVO_PROTOCOL_TxAddData(AVO_PROTOCOL_CMD_HEAD1);
000006  2055              MOVS     r0,#0x55
000008  f7fffffe          BL       AVO_PROTOCOL_TxAddData
;;;543        AVO_PROTOCOL_TxAddData(AVO_PROTOCOL_CMD_HEAD2);
00000c  2000              MOVS     r0,#0
00000e  f7fffffe          BL       AVO_PROTOCOL_TxAddData
;;;544        AVO_PROTOCOL_TxAddData(AVO_PROTOCOL_CMD_HEAD3);
000012  20aa              MOVS     r0,#0xaa
000014  f7fffffe          BL       AVO_PROTOCOL_TxAddData
;;;545        AVO_PROTOCOL_TxAddData(AVO_CMD_AVOMETER);
000018  20b0              MOVS     r0,#0xb0
00001a  f7fffffe          BL       AVO_PROTOCOL_TxAddData
;;;546        // Length
;;;547        AVO_PROTOCOL_TxAddData(0x03);
00001e  2003              MOVS     r0,#3
000020  f7fffffe          BL       AVO_PROTOCOL_TxAddData
;;;548        // Target board number
;;;549        AVO_PROTOCOL_TxAddData(BOARD_AVO);
000024  2004              MOVS     r0,#4
000026  f7fffffe          BL       AVO_PROTOCOL_TxAddData
;;;550        AVO_PROTOCOL_TxAddData(mesuretype);
00002a  b2e8              UXTB     r0,r5
00002c  f7fffffe          BL       AVO_PROTOCOL_TxAddData
;;;551        AVO_PROTOCOL_TxAddData(mesurechl);
000030  b2e0              UXTB     r0,r4
000032  f7fffffe          BL       AVO_PROTOCOL_TxAddData
;;;552        // Assemble command frame
;;;553        AVO_PROTOCOL_TxAddFrame();
000036  e8bd4030          POP      {r4,r5,lr}
00003a  f7ffbffe          B.W      AVO_PROTOCOL_TxAddFrame
;;;554    
;;;555    }
;;;556    
                          ENDP


                          AREA ||i.AVO_PROTOCOL_TxAddData||, CODE, READONLY, ALIGN=2

                  AVO_PROTOCOL_TxAddData PROC
;;;94     // 向发送命令帧队列中添加数据
;;;95     void AVO_PROTOCOL_TxAddData(uint8 data)
000000  b530              PUSH     {r4,r5,lr}
;;;96     {
;;;97         uint16 head = AVOProtocolCB.tx.head;
000002  4910              LDR      r1,|L14.68|
000004  f8b144aa          LDRH     r4,[r1,#0x4aa]  ; AVOProtocolCB
;;;98         uint16 end = AVOProtocolCB.tx.end;
000008  f8b124ac          LDRH     r2,[r1,#0x4ac]  ; AVOProtocolCB
;;;99         AVO_PROTOCOL_TX_CMD_FRAME *pCmdFrame = &AVOProtocolCB.tx.cmdQueue[AVOProtocolCB.tx.end];
00000c  eb0203c2          ADD      r3,r2,r2,LSL #3
000010  eb031342          ADD      r3,r3,r2,LSL #5
000014  eb010183          ADD      r1,r1,r3,LSL #2
000018  f20121be          ADD      r1,r1,#0x2be
;;;100    
;;;101        // 发送缓冲区已满，不予接收
;;;102        if ((end + 1) % AVO_PROTOCOL_TX_QUEUE_SIZE == head)
00001c  1c52              ADDS     r2,r2,#1
00001e  2303              MOVS     r3,#3
000020  fbb2f5f3          UDIV     r5,r2,r3
000024  fb032215          MLS      r2,r3,r5,r2
000028  42a2              CMP      r2,r4
00002a  d009              BEQ      |L14.64|
;;;103        {
;;;104            return;
;;;105        }
;;;106    
;;;107        // 队尾命令帧已满，退出
;;;108        if (pCmdFrame->length >= AVO_PROTOCOL_TX_CMD_FRAME_LENGTH_MAX)
00002c  f8b120a2          LDRH     r2,[r1,#0xa2]
000030  2aa0              CMP      r2,#0xa0
000032  d205              BCS      |L14.64|
;;;109        {
;;;110            return;
;;;111        }
;;;112    
;;;113        // 数据添加到帧末尾，并更新帧长度
;;;114        pCmdFrame->buff[pCmdFrame->length] = data;
000034  1c8b              ADDS     r3,r1,#2
000036  54d0              STRB     r0,[r2,r3]
;;;115        pCmdFrame->length++;
000038  f8310fa2          LDRH     r0,[r1,#0xa2]!
00003c  1c40              ADDS     r0,r0,#1
00003e  8008              STRH     r0,[r1,#0]
                  |L14.64|
;;;116    }
000040  bd30              POP      {r4,r5,pc}
;;;117    
                          ENDP

000042  0000              DCW      0x0000
                  |L14.68|
                          DCD      ||.bss||

                          AREA ||i.AVO_PROTOCOL_TxAddFrame||, CODE, READONLY, ALIGN=2

                  AVO_PROTOCOL_TxAddFrame PROC
;;;118    // 确认添加命令帧，即承认之前填充的数据为命令帧，将其添加到发送队列中，由main进行调度发送，本函数内会自动校正命令长度，并添加校验码
;;;119    void AVO_PROTOCOL_TxAddFrame(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;120    {
;;;121        uint16 checkSum = 0;
000002  2200              MOVS     r2,#0
;;;122        uint16 i = 0;
000004  2100              MOVS     r1,#0
;;;123        uint16 head = AVOProtocolCB.tx.head;
000006  4e1e              LDR      r6,|L15.128|
000008  f8b654aa          LDRH     r5,[r6,#0x4aa]  ; AVOProtocolCB
;;;124        uint16 end = AVOProtocolCB.tx.end;
00000c  f8b644ac          LDRH     r4,[r6,#0x4ac]  ; AVOProtocolCB
;;;125        AVO_PROTOCOL_TX_CMD_FRAME *pCmdFrame = &AVOProtocolCB.tx.cmdQueue[AVOProtocolCB.tx.end];
000010  eb0400c4          ADD      r0,r4,r4,LSL #3
000014  eb001044          ADD      r0,r0,r4,LSL #5
000018  eb060080          ADD      r0,r6,r0,LSL #2
00001c  f20020be          ADD      r0,r0,#0x2be
;;;126        uint16 length = pCmdFrame->length;
000020  f8b030a2          LDRH     r3,[r0,#0xa2]
;;;127    
;;;128        // 发送缓冲区已满，不予接收
;;;129        if ((end + 1) % AVO_PROTOCOL_TX_QUEUE_SIZE == head)
000024  1c64              ADDS     r4,r4,#1
000026  2703              MOVS     r7,#3
000028  fbb4fcf7          UDIV     r12,r4,r7
00002c  fb07441c          MLS      r4,r7,r12,r4
000030  42ac              CMP      r4,r5
000032  d003              BEQ      |L15.60|
;;;130        {
;;;131            return;
;;;132        }
;;;133    
;;;134        // 命令帧长度不足，清除已填充的数据，退出
;;;135        if (AVO_PROTOCOL_CMD_FRAME_LENGTH_MIN - 1 > length) // 减去"校验和"1个字节
000034  2b05              CMP      r3,#5
000036  d202              BCS      |L15.62|
;;;136        {
;;;137            pCmdFrame->length = 0;
000038  f8a010a2          STRH     r1,[r0,#0xa2]
                  |L15.60|
;;;138    
;;;139            return;
;;;140        }
;;;141    
;;;142        // 队尾命令帧已满，退出
;;;143        if (length >= AVO_PROTOCOL_TX_CMD_FRAME_LENGTH_MAX)
;;;144        {
;;;145            return;
;;;146        }
;;;147    
;;;148        // 重新设置数据长度，系统在准备数据时，填充的"数据长度"可以为任意值，并且不需要添加校验码，在这里重新设置为正确的值
;;;149        // 重设数据长度,需要减去10=(3同步头1命令字+1数据长度)
;;;150        pCmdFrame->buff[AVO_PROTOCOL_CMD_LENGTH_INDEX] = length - 5;
;;;151    
;;;152        //cc = UART_GetCRCValue(&pCmdFrame->buff[UART_PROTOCOL_CMD_VERSION_INDEX], (pCmdFrame->length - UART_PROTOCOL_HEAD_BYTE));
;;;153        /* 异或取反计算校验码 */
;;;154        for (i = 0; i < pCmdFrame->length; i++)
;;;155        {
;;;156            checkSum ^= pCmdFrame->buff[i];
;;;157        }
;;;158        checkSum = ~checkSum;
;;;159    
;;;160        pCmdFrame->buff[length] = checkSum;
;;;161        pCmdFrame->length ++;
;;;162    
;;;163        AVOProtocolCB.tx.end++;
;;;164        AVOProtocolCB.tx.end %= AVO_PROTOCOL_TX_QUEUE_SIZE;
;;;165        // pCB->tx.cmdQueue[pCB->tx.end].length = 0;   //2015.12.2修改
;;;166    }
00003c  bdf0              POP      {r4-r7,pc}
                  |L15.62|
00003e  2ba0              CMP      r3,#0xa0              ;143
000040  d2fc              BCS      |L15.60|
000042  1f5c              SUBS     r4,r3,#5              ;150
000044  7184              STRB     r4,[r0,#6]            ;150
000046  f8b050a2          LDRH     r5,[r0,#0xa2]         ;126
00004a  e004              B        |L15.86|
                  |L15.76|
00004c  1844              ADDS     r4,r0,r1              ;156
00004e  78a4              LDRB     r4,[r4,#2]            ;156
000050  4062              EORS     r2,r2,r4              ;156
000052  1c49              ADDS     r1,r1,#1              ;154
000054  b289              UXTH     r1,r1                 ;154
                  |L15.86|
000056  428d              CMP      r5,r1                 ;154
000058  d8f8              BHI      |L15.76|
00005a  43d1              MVNS     r1,r2                 ;158
00005c  18c2              ADDS     r2,r0,r3              ;160
00005e  7091              STRB     r1,[r2,#2]            ;160
000060  f8301fa2          LDRH     r1,[r0,#0xa2]!        ;161
000064  1c49              ADDS     r1,r1,#1              ;161
000066  8001              STRH     r1,[r0,#0]            ;161
000068  f8b604ac          LDRH     r0,[r6,#0x4ac]        ;163  ; AVOProtocolCB
00006c  1c40              ADDS     r0,r0,#1              ;163
00006e  b280              UXTH     r0,r0                 ;163
000070  fbb0f1f7          UDIV     r1,r0,r7              ;164
000074  fb070011          MLS      r0,r7,r1,r0           ;164
000078  f8a604ac          STRH     r0,[r6,#0x4ac]        ;164
00007c  bdf0              POP      {r4-r7,pc}
;;;167    
                          ENDP

00007e  0000              DCW      0x0000
                  |L15.128|
                          DCD      ||.bss||

                          AREA ||i.AVO_PROTOCOL_TxStateProcess||, CODE, READONLY, ALIGN=2

                  AVO_PROTOCOL_TxStateProcess PROC
;;;259    // 协议层发送处理过程
;;;260    void AVO_PROTOCOL_TxStateProcess(void)
000000  b570              PUSH     {r4-r6,lr}
;;;261    {
;;;262        uint16 head = AVOProtocolCB.tx.head;
000002  4c15              LDR      r4,|L16.88|
000004  f8b434aa          LDRH     r3,[r4,#0x4aa]  ; AVOProtocolCB
;;;263        uint16 end = AVOProtocolCB.tx.end;
000008  f8b464ac          LDRH     r6,[r4,#0x4ac]  ; AVOProtocolCB
;;;264        uint16 length = AVOProtocolCB.tx.cmdQueue[head].length;
00000c  eb0300c3          ADD      r0,r3,r3,LSL #3
000010  eb001043          ADD      r0,r0,r3,LSL #5
000014  eb040080          ADD      r0,r4,r0,LSL #2
000018  4605              MOV      r5,r0
00001a  f8b02360          LDRH     r2,[r0,#0x360]
;;;265        uint8 *pCmd = AVOProtocolCB.tx.cmdQueue[head].buff;
00001e  f5007130          ADD      r1,r0,#0x2c0
;;;266        uint16 localDeviceID = AVOProtocolCB.tx.cmdQueue[head].deviceID;
000022  f8b002be          LDRH     r0,[r0,#0x2be]
;;;267    
;;;268        // 发送缓冲区为空，说明无数据
;;;269        if (head == end)
000026  42b3              CMP      r3,r6
000028  d014              BEQ      |L16.84|
;;;270        {
;;;271            return;
;;;272        }
;;;273    
;;;274        // 发送函数没有注册直接返回
;;;275        if (NULL == AVOProtocolCB.sendDataThrowService)
00002a  f8d434b4          LDR      r3,[r4,#0x4b4]  ; AVOProtocolCB
00002e  2b00              CMP      r3,#0
000030  d010              BEQ      |L16.84|
;;;276        {
;;;277            return;
;;;278        }
;;;279    
;;;280        // 协议层有数据需要发送到驱动层
;;;281        if (!(*AVOProtocolCB.sendDataThrowService)(localDeviceID, pCmd, length))
000032  4798              BLX      r3
000034  2800              CMP      r0,#0
000036  d00d              BEQ      |L16.84|
;;;282        {
;;;283            return;
;;;284        }
;;;285    
;;;286        // 发送环形队列更新位置
;;;287        AVOProtocolCB.tx.cmdQueue[head].length = 0;
000038  2000              MOVS     r0,#0
00003a  f8a50360          STRH     r0,[r5,#0x360]
;;;288        AVOProtocolCB.tx.head++;
00003e  f8b404aa          LDRH     r0,[r4,#0x4aa]  ; AVOProtocolCB
000042  1c40              ADDS     r0,r0,#1
000044  b280              UXTH     r0,r0
;;;289        AVOProtocolCB.tx.head %= AVO_PROTOCOL_TX_QUEUE_SIZE;
000046  2103              MOVS     r1,#3
000048  fbb0f2f1          UDIV     r2,r0,r1
00004c  fb010012          MLS      r0,r1,r2,r0
000050  f8a404aa          STRH     r0,[r4,#0x4aa]
                  |L16.84|
;;;290    }
000054  bd70              POP      {r4-r6,pc}
;;;291    
                          ENDP

000056  0000              DCW      0x0000
                  |L16.88|
                          DCD      ||.bss||

                          AREA ||i.SysRest||, CODE, READONLY, ALIGN=2

                  SysRest PROC
;;;556    
;;;557    void SysRest(uint32 param)
000000  2001              MOVS     r0,#1
000002  f3808813          MSR      FAULTMASK,r0
000006  f3bf8f4f          DSB      
00000a  4805              LDR      r0,|L17.32|
00000c  6801              LDR      r1,[r0,#0]
00000e  4a05              LDR      r2,|L17.36|
000010  f40161e0          AND      r1,r1,#0x700
000014  4311              ORRS     r1,r1,r2
000016  6001              STR      r1,[r0,#0]
000018  f3bf8f4f          DSB      
                  |L17.28|
00001c  e7fe              B        |L17.28|
;;;558    {
;;;559        __set_FAULTMASK(1); // 关闭所有中断
;;;560        NVIC_SystemReset(); // 复位
;;;561    }
;;;562    
                          ENDP

00001e  0000              DCW      0x0000
                  |L17.32|
                          DCD      0xe000ed0c
                  |L17.36|
                          DCD      0x05fa0004

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  AVOProtocolCB
                          %        1228

                          AREA ||.data||, DATA, ALIGN=2

                  headlight_cnt
000000  00                DCB      0x00
                  gnd_cnt
000001  000000            DCB      0x00,0x00,0x00
                  measure
                          DCD      0x00000000
                  ohm
                          DCD      0x00000000
                  avoTestMsgBuff
00000c  4d656173          DCB      0x4d,0x65,0x61,0x73
000010  20436f6d          DCB      0x20,0x43,0x6f,0x6d
000014  706c6574          DCB      0x70,0x6c,0x65,0x74
000018  65640000          DCB      0x65,0x64,0x00,0x00
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "User\\AvoProtocol.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_AvoProtocol_c_04dd50a9____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___13_AvoProtocol_c_04dd50a9____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_AvoProtocol_c_04dd50a9____REVSH|
#line 128
|__asm___13_AvoProtocol_c_04dd50a9____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
