; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\keymsgprocess.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\keymsgprocess.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -I.\User\qrencode -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.3\Device\Include -D__MICROLIB -D__UVISION_VERSION=539 -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\keymsgprocess.crf User\keyMsgProcess.c]
                          THUMB

                          AREA ||i.KEYMSG_CALLBACK_Scan||, CODE, READONLY, ALIGN=2

                  KEYMSG_CALLBACK_Scan PROC
;;;218    // 【接口功能】按键处理回调函数，在定时器控制下，被周期调用，实现按键扫描
;;;219    void KEYMSG_CALLBACK_Scan(uint32 param)
000000  4901              LDR      r1,|L1.8|
;;;220    {
;;;221    	keyMsgCB.scanRequest = TRUE;
000002  2001              MOVS     r0,#1
000004  7008              STRB     r0,[r1,#0]
;;;222    }
000006  4770              BX       lr
;;;223    
                          ENDP

                  |L1.8|
                          DCD      ||.bss||

                          AREA ||i.KEYMSG_ClearGlobalMaskRequest||, CODE, READONLY, ALIGN=2

                  KEYMSG_ClearGlobalMaskRequest PROC
;;;569    // 清除全局屏蔽请求
;;;570    void KEYMSG_ClearGlobalMaskRequest(void)
000000  4902              LDR      r1,|L2.12|
;;;571    {
;;;572    	keyMsgCB.globalMaskRequest = FALSE;
000002  2000              MOVS     r0,#0
000004  f881004c          STRB     r0,[r1,#0x4c]
;;;573    }
000008  4770              BX       lr
;;;574    
                          ENDP

00000a  0000              DCW      0x0000
                  |L2.12|
                          DCD      ||.bss||

                          AREA ||i.KEYMSG_ClearMaskRequest||, CODE, READONLY, ALIGN=2

                  KEYMSG_ClearMaskRequest PROC
;;;557    // 清除指定按键的指定消息的屏蔽请求
;;;558    void KEYMSG_ClearMaskRequest(KEY_NAME_E keyName, KEY_MSG_E keyMsg)
000000  4b03              LDR      r3,|L3.16|
;;;559    {
;;;560    	keyMsgCB.msgMaskRequest[keyName][keyMsg] = FALSE;
000002  2200              MOVS     r2,#0
000004  eb030080          ADD      r0,r3,r0,LSL #2
000008  4408              ADD      r0,r0,r1
00000a  f8802048          STRB     r2,[r0,#0x48]
;;;561    }
00000e  4770              BX       lr
;;;562    
                          ENDP

                  |L3.16|
                          DCD      ||.bss||

                          AREA ||i.KEYMSG_Init||, CODE, READONLY, ALIGN=2

                  KEYMSG_Init PROC
;;;84     // 【使用方法】在 main 中大循环之前调用，注意，在调用本接口之前，必须完成定时器模块初始化
;;;85     void KEYMSG_Init(void)
000000  b57c              PUSH     {r2-r6,lr}
;;;86     {
;;;87     	uint8 i,j;
;;;88     
;;;89     	// 数据结构初始化
;;;90     	for(i=0; i<KEY_NAME_MAX; i++)
000002  2100              MOVS     r1,#0
;;;91     	{
;;;92     	  //将按键消息信息结构体中的end成员初始化为0
;;;93     		keyMsgCB.keyMsgInfo[i].end = 0;
000004  4d22              LDR      r5,|L4.144|
;;;94     		
;;;95     		//循环遍历按键状态计数器数组
;;;96     		for(j=0; j<KEY_INFO_SIZE; j++)
;;;97     		{
;;;98     		  //循环遍历按键状态计数器数组
;;;99     			keyMsgCB.keyMsgInfo[i].stateCount[j] = KEY_STATE_MASK;
000006  f44f4200          MOV      r2,#0x8000
00000a  2400              MOVS     r4,#0
                  |L4.12|
00000c  eb010081          ADD      r0,r1,r1,LSL #2       ;93
000010  eb0503c0          ADD      r3,r5,r0,LSL #3       ;93
000014  711c              STRB     r4,[r3,#4]            ;93
000016  2000              MOVS     r0,#0                 ;96
                  |L4.24|
000018  eb030640          ADD      r6,r3,r0,LSL #1
00001c  80f2              STRH     r2,[r6,#6]
00001e  1c40              ADDS     r0,r0,#1              ;96
000020  b2c0              UXTB     r0,r0                 ;96
000022  2802              CMP      r0,#2                 ;96
000024  d3f8              BCC      |L4.24|
;;;100    		}
;;;101    
;;;102    		// 清除所有消息的屏蔽请求
;;;103    		for(j=0; j<KEY_MSG_MAX; j++)
000026  2000              MOVS     r0,#0
;;;104    		{
;;;105    			keyMsgCB.msgMaskRequest[i][j] = FALSE;
000028  eb050381          ADD      r3,r5,r1,LSL #2
                  |L4.44|
00002c  181e              ADDS     r6,r3,r0
00002e  f8864048          STRB     r4,[r6,#0x48]
000032  1c40              ADDS     r0,r0,#1              ;103
000034  b2c0              UXTB     r0,r0                 ;103
000036  2804              CMP      r0,#4                 ;103
000038  d3f8              BCC      |L4.44|
00003a  1c49              ADDS     r1,r1,#1              ;90
00003c  b2c9              UXTB     r1,r1                 ;90
00003e  2900              CMP      r1,#0                 ;90
000040  d0e4              BEQ      |L4.12|
;;;106    		}
;;;107    	}
;;;108    	for(i=0; i<sizeof(keyMsgCB.keyValue); i++)
000042  2000              MOVS     r0,#0
;;;109    	{
;;;110    	  // 初始化每个按键数值为0xFF
;;;111    		keyMsgCB.keyValue[i] = 0xFF;
000044  21ff              MOVS     r1,#0xff
                  |L4.70|
000046  182a              ADDS     r2,r5,r0
000048  7051              STRB     r1,[r2,#1]
00004a  1c40              ADDS     r0,r0,#1              ;108
00004c  b2c0              UXTB     r0,r0                 ;108
00004e  2800              CMP      r0,#0                 ;108
000050  d0f9              BEQ      |L4.70|
;;;112    		#if 0==KEY_MSG_THROW_KEY_UP_AFTER_REPEAT
;;;113    		keyMsgCB.keyUpMsgMaskBit[i] = 0x00;
;;;114    		#endif
;;;115    	}
;;;116    	
;;;117    	// 消息环形队列初始化
;;;118    	keyMsgCB.msgQueue.head = 0;
000052  f885402c          STRB     r4,[r5,#0x2c]
;;;119    	keyMsgCB.msgQueue.end  = 0;
000056  f885402d          STRB     r4,[r5,#0x2d]
;;;120    	for(i=0; i<KEY_MSG_QUEUE_SIZE; i++)
00005a  2000              MOVS     r0,#0
;;;121    	{
;;;122    		keyMsgCB.msgQueue.node[i].keyName = KEY_NAME_NULL;
00005c  2202              MOVS     r2,#2
;;;123    		keyMsgCB.msgQueue.node[i].keyMsg = KEY_MSG_NULL;
00005e  2305              MOVS     r3,#5
                  |L4.96|
000060  eb050140          ADD      r1,r5,r0,LSL #1       ;122
000064  f8012f2e          STRB     r2,[r1,#0x2e]!        ;122
000068  704b              STRB     r3,[r1,#1]
00006a  1c40              ADDS     r0,r0,#1              ;120
00006c  b2c0              UXTB     r0,r0                 ;120
00006e  280a              CMP      r0,#0xa               ;120
000070  d3f6              BCC      |L4.96|
;;;124    	}
;;;125    	
;;;126    	keyMsgCB.scanRequest = FALSE;
000072  702c              STRB     r4,[r5,#0]
;;;127     
;;;128    	// 按键消息服务初始化
;;;129    	KEYMSG_StopAllService();
000074  f7fffffe          BL       KEYMSG_StopAllService
;;;130    	
;;;131    	// 按键刷新函数接口初始化
;;;132    	keyMsgCB.KeyUpdate = NULL;
000078  646c              STR      r4,[r5,#0x44]  ; keyMsgCB
;;;133    	
;;;134    	// 启动按键扫描 启动按键扫描定时器任务，定时扫描按键状态并执行按键处理回调函数
;;;135    	TIMER_AddTask(TIMER_ID_KEY_SCAN,   //按键扫描任务
00007a  f04f30ff          MOV      r0,#0xffffffff
00007e  e9cd0400          STRD     r0,r4,[sp,#0]
000082  2300              MOVS     r3,#0
000084  4a03              LDR      r2,|L4.148|
000086  2114              MOVS     r1,#0x14
000088  200c              MOVS     r0,#0xc
00008a  f7fffffe          BL       TIMER_AddTask
;;;136    					KEY_SCAN_TIME,             //20ms 
;;;137    					KEYMSG_CALLBACK_Scan,      //按键处理回调函数 	keyMsgCB.scanRequest = TRUE;     
;;;138    					0,                         //回调函数参数
;;;139    					TIMER_LOOP_FOREVER,        //无限循环
;;;140    					ACTION_MODE_DO_AT_ONCE);   //立即执行
;;;141    }
00008e  bd7c              POP      {r2-r6,pc}
;;;142    
                          ENDP

                  |L4.144|
                          DCD      ||.bss||
                  |L4.148|
                          DCD      KEYMSG_CALLBACK_Scan

                          AREA ||i.KEYMSG_MsgProcess||, CODE, READONLY, ALIGN=2

                  KEYMSG_MsgProcess PROC
;;;303    // 【接口功能】按键消息处理
;;;304    void KEYMSG_MsgProcess(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;305    {
;;;306    	uint8 i;
;;;307    	KEYMSG_INFO_CB* pKeyInfo = NULL;
;;;308    	uint16 currentCount = 0;	// 当前按键状态计数值
;;;309    	uint16 currentState = 0;	// 当前按键状态
;;;310    	uint16* pStateCount = NULL;	// 当前操作中的状态计数值
;;;311    	
;;;312    	// 遍历当前的状态，根据需要抛出按键消息，添加到按键环形队列中
;;;313    	// 本段用于DOWN / HOLD / REPEAT / UP四个消息的判断与抛出
;;;314    	for(i=0; i<KEY_NAME_MAX; i++)
000002  2500              MOVS     r5,#0
;;;315    	{
;;;316    		// 获取当前按键信息结构体指针
;;;317    		pKeyInfo = &keyMsgCB.keyMsgInfo[i];
000004  4f2a              LDR      r7,|L5.176|
;;;318    		
;;;319    		// 获取当前操作中的按键状态计数值指针
;;;320    		pStateCount = &(pKeyInfo->stateCount[pKeyInfo->end]);
;;;321    		
;;;322    		// 获取当前按键状态
;;;323    		currentState = (*pStateCount) & KEY_STATE_MASK;
;;;324    		
;;;325    		// 获取当前按键状态计数值z
;;;326    		currentCount = (*pStateCount) & (~KEY_STATE_MASK);
;;;327    		
;;;328    		// 最高位为0，说明当前状态为按键按下
;;;329    		if(0 == currentState)
;;;330    		{
;;;331    			////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
;;;332    			// 当前状态计数值为1，说明当前状态为第一次出现，需要抛出按下消息
;;;333    			if(1 == currentCount)
;;;334    			{
;;;335    			#if 1==KEY_MSG_SWITCH_DOWN
;;;336    			
;;;337    				// 抛出按键按下消息
;;;338    				KEYMSG_ThrowMsg((KEY_NAME_E)i, KEY_MSG_DOWN);
;;;339    			#endif
;;;340    			#if 0==KEY_MSG_THROW_KEY_UP_AFTER_REPEAT	// KEY_UP 屏蔽位置位时，不抛出 KEY_UP 消息
;;;341    				keyMsgCB.keyUpMsgMaskBit[i/8] &= (0x01<<(i%8));	// 按键按下时解除 KEY_UP 限制
;;;342    			#endif
;;;343    				// 计数值清零，即代表已抛出消息
;;;344    				(*pStateCount) &= KEY_STATE_MASK;
;;;345    			}
;;;346    			////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
;;;347    			// 当前状态计数值大于1，则判断是否达到长按门限
;;;348    			else if(currentCount > 1)
;;;349    			{
;;;350    				// 达到长按门限，抛出长按消息，注意这里的判断条件，不能用>，否则将不断抛出长按消息
;;;351    			#if 0==KEY_MSG_USE_SAME_HOLD_THRESHOLD
;;;352    				if(currentCount*KEY_SCAN_TIME == keyHoldThreshHold[i])	// 每个按键使用单独的长按门限
000006  4e2b              LDR      r6,|L5.180|
                  |L5.8|
000008  eb050085          ADD      r0,r5,r5,LSL #2       ;317
00000c  eb0700c0          ADD      r0,r7,r0,LSL #3       ;317
000010  1d00              ADDS     r0,r0,#4              ;317
000012  7801              LDRB     r1,[r0,#0]            ;320
000014  eb000441          ADD      r4,r0,r1,LSL #1       ;320
000018  1ca4              ADDS     r4,r4,#2              ;320
00001a  8820              LDRH     r0,[r4,#0]            ;323
00001c  f4004100          AND      r1,r0,#0x8000         ;323
000020  f4204000          BIC      r0,r0,#0x8000         ;326
000024  b111              CBZ      r1,|L5.44|
;;;353    			#else
;;;354    				if(currentCount*KEY_SCAN_TIME == KEY_HOLD_TIME) // 所有按键使用统一的长按门限
;;;355    			#endif
;;;356    				{
;;;357    				#if 1==KEY_MSG_SWITCH_HOLD
;;;358    				
;;;359    					// 抛出按键长按消息
;;;360    					KEYMSG_ThrowMsg((KEY_NAME_E)i, KEY_MSG_HOLD);
;;;361    
;;;362    					// 当 + 键或 - 键长按时，屏蔽 UP 消息
;;;363    //					if((KEY_NAME_ADD == i)||(KEY_NAME_DEC == i))
;;;364    //					{
;;;365    //						KEYMSG_SetMaskRequest((KEY_NAME_E)i, KEY_MSG_UP);
;;;366    //					}
;;;367    				#endif
;;;368    				#if 0==KEY_MSG_THROW_KEY_UP_AFTER_REPEAT	// KEY_UP 屏蔽位置位时，不抛出 KEY_UP 消息
;;;369    					keyMsgCB.keyUpMsgMaskBit[i/8] |= (0x01<<(i%8));	// 按键长按时设置 KEY_UP 限制
;;;370    				#endif
;;;371    					// 计数值增加1，防止下一次重复抛出长按消息
;;;372    					(*pStateCount)++;
;;;373    				}
;;;374    				// 超出长按门限，判断是否达到重复抛出门限
;;;375    			#if 0==KEY_MSG_USE_SAME_HOLD_THRESHOLD
;;;376    				else if(currentCount*KEY_SCAN_TIME >= keyHoldThreshHold[i] + keyRepeatTime[i])	// 每个按键使用单独的长按门限
;;;377    			#else
;;;378    				else if(currentCount*KEY_SCAN_TIME >= KEY_HOLD_TIME + KEY_RETHROW_TIME) // 所有按键使用统一的长按门限
;;;379    			#endif
;;;380    				{
;;;381    				#if 1==KEY_MSG_SWITCH_REPEAT
;;;382    					// 抛出按键重复消息 
;;;383    					KEYMSG_ThrowMsg((KEY_NAME_E)i, KEY_MSG_REPEAT);
;;;384    				#endif
;;;385    					
;;;386    					// 将计数值设置为长按门限+1，为下次抛出重复消息做准备
;;;387    					(*pStateCount) &= KEY_STATE_MASK;
;;;388    				#if 0==KEY_MSG_USE_SAME_HOLD_THRESHOLD
;;;389    					(*pStateCount) += (keyHoldThreshHold[i]/KEY_SCAN_TIME) + 1; // 每个按键使用单独的长按门限
;;;390    				#else
;;;391    					(*pStateCount) += (KEY_HOLD_TIME/KEY_SCAN_TIME) + 1;	// 所有按键使用统一的长按门限
;;;392    				#endif
;;;393    				}
;;;394    				// 未达到长按门限，不予处理
;;;395    				else
;;;396    				{}
;;;397    			}
;;;398    			////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
;;;399    			// 当前状态计数值为0，说明已抛出边沿消息，不再予以处理
;;;400    			else
;;;401    			{}
;;;402    		}
;;;403    		// 最高位为1，说明当前状态为按键释放
;;;404    		else
;;;405    		{
;;;406    			// 当前状态计数值为1，说明当前状态为第一次出现，需要抛出释放消息
;;;407    			if(1 == currentCount)
000026  2801              CMP      r0,#1
000028  d034              BEQ      |L5.148|
00002a  e03b              B        |L5.164|
                  |L5.44|
00002c  2801              CMP      r0,#1                 ;333
00002e  d00f              BEQ      |L5.80|
000030  d938              BLS      |L5.164|
000032  f8361015          LDRH     r1,[r6,r5,LSL #1]     ;352
000036  eb000080          ADD      r0,r0,r0,LSL #2       ;352
00003a  ebb10f80          CMP      r1,r0,LSL #2          ;352
00003e  d110              BNE      |L5.98|
000040  2102              MOVS     r1,#2                 ;360
000042  4628              MOV      r0,r5                 ;360
000044  f7fffffe          BL       KEYMSG_ThrowMsg
000048  8820              LDRH     r0,[r4,#0]            ;372
00004a  1c40              ADDS     r0,r0,#1              ;372
00004c  8020              STRH     r0,[r4,#0]            ;372
00004e  e029              B        |L5.164|
                  |L5.80|
000050  2100              MOVS     r1,#0                 ;338
000052  4628              MOV      r0,r5                 ;338
000054  f7fffffe          BL       KEYMSG_ThrowMsg
000058  8820              LDRH     r0,[r4,#0]            ;344
00005a  f4004000          AND      r0,r0,#0x8000         ;344
00005e  8020              STRH     r0,[r4,#0]            ;344
000060  e020              B        |L5.164|
                  |L5.98|
000062  4a14              LDR      r2,|L5.180|
000064  1c92              ADDS     r2,r2,#2              ;376
000066  f8322015          LDRH     r2,[r2,r5,LSL #1]     ;376
00006a  4411              ADD      r1,r1,r2              ;376
00006c  ebb10f80          CMP      r1,r0,LSL #2          ;376
000070  d818              BHI      |L5.164|
000072  2103              MOVS     r1,#3                 ;383
000074  4628              MOV      r0,r5                 ;383
000076  f7fffffe          BL       KEYMSG_ThrowMsg
00007a  8820              LDRH     r0,[r4,#0]            ;387
00007c  f4004000          AND      r0,r0,#0x8000         ;387
000080  8020              STRH     r0,[r4,#0]            ;387
000082  f8361015          LDRH     r1,[r6,r5,LSL #1]     ;389
000086  2214              MOVS     r2,#0x14              ;389
000088  fbb1f1f2          UDIV     r1,r1,r2              ;389
00008c  1c49              ADDS     r1,r1,#1              ;389
00008e  4408              ADD      r0,r0,r1              ;389
000090  8020              STRH     r0,[r4,#0]            ;389
000092  e007              B        |L5.164|
                  |L5.148|
;;;408    			{
;;;409    			#if 1==KEY_MSG_SWITCH_UP
;;;410    				// 抛出按键释放消息 保存在消息环形队列中
;;;411    				KEYMSG_ThrowMsg((KEY_NAME_E)i, KEY_MSG_UP);
000094  2101              MOVS     r1,#1
000096  4628              MOV      r0,r5
000098  f7fffffe          BL       KEYMSG_ThrowMsg
;;;412    			#endif
;;;413    				
;;;414    				// 计数值清零，即代表已抛出消息
;;;415    				(*pStateCount) &= KEY_STATE_MASK;
00009c  8820              LDRH     r0,[r4,#0]
00009e  f4004000          AND      r0,r0,#0x8000
0000a2  8020              STRH     r0,[r4,#0]
                  |L5.164|
0000a4  1c6d              ADDS     r5,r5,#1              ;314
0000a6  b2ed              UXTB     r5,r5                 ;314
0000a8  2d00              CMP      r5,#0                 ;314
0000aa  d0ad              BEQ      |L5.8|
;;;416    			}
;;;417    			// 计数值为0时，说明已抛出边沿消息，不再予以处理
;;;418    			// 计数值>1时，为按键释放状态下计数，不予处理
;;;419    			else
;;;420    			{}
;;;421    		}
;;;422    	}
;;;423    }
0000ac  bdf0              POP      {r4-r7,pc}
;;;424    
                          ENDP

0000ae  0000              DCW      0x0000
                  |L5.176|
                          DCD      ||.bss||
                  |L5.180|
                          DCD      ||.constdata||

                          AREA ||i.KEYMSG_Process||, CODE, READONLY, ALIGN=1

                  KEYMSG_Process PROC
;;;463    // 【使用方法】在 main 中大循环内调用
;;;464    void KEYMSG_Process(void)
000000  b510              PUSH     {r4,lr}
;;;465    {
;;;466    	// 按键扫描处理
;;;467    	KEYMSG_ScanProcess();
000002  f7fffffe          BL       KEYMSG_ScanProcess
;;;468    	
;;;469    	// 按键消息处理
;;;470    	KEYMSG_MsgProcess();
000006  f7fffffe          BL       KEYMSG_MsgProcess
;;;471    	
;;;472    	// 按键服务处理
;;;473    	KEYMSG_ServiceProcess();
00000a  e8bd4010          POP      {r4,lr}
00000e  f7ffbffe          B.W      KEYMSG_ServiceProcess
;;;474    }
;;;475    
                          ENDP


                          AREA ||i.KEYMSG_RegisterKeyScanCallback||, CODE, READONLY, ALIGN=2

                  KEYMSG_RegisterKeyScanCallback PROC
;;;147    //             并通过此接口向本模块注册，需要注意的是：按键按下为0，按键释放为1
;;;148    void KEYMSG_RegisterKeyScanCallback(void(*fun)(uint8* p8bitKeyValueArray))
000000  4901              LDR      r1,|L7.8|
;;;149    {
;;;150      //这段代码是将接受相同参数的函数指针 fun 赋值给了结构体 keyMsgCB 中的函数指针 KeyUpdate。这样，函数指针 KeyUpdate 就指向了传入的函数 fun。
;;;151    	keyMsgCB.KeyUpdate = fun;
000002  6448              STR      r0,[r1,#0x44]  ; keyMsgCB
;;;152    }
000004  4770              BX       lr
;;;153    uint8 keyuiui;
                          ENDP

000006  0000              DCW      0x0000
                  |L7.8|
                          DCD      ||.bss||

                          AREA ||i.KEYMSG_RegisterMsgService||, CODE, READONLY, ALIGN=2

                  KEYMSG_RegisterMsgService PROC
;;;157    // 【使用方法】用于注册按键消息服务，执行之前无须先注销，可直接调用本接口改变消息服务，注册的服务函数的形式必须与本接口中形参一致
;;;158    void KEYMSG_RegisterMsgService(KEY_NAME_E keyName, KEY_MSG_E keyMsg, void(*service)(uint32 param), uint32 param)
000000  2800              CMP      r0,#0
;;;159    {
000002  d108              BNE      |L8.22|
;;;160    	// 参数合法性检验
;;;161    	if(keyName >= KEY_NAME_MAX)
;;;162    	{
;;;163    		return ;
;;;164    	}
;;;165    	if(keyMsg >= KEY_MSG_MAX)
000004  2904              CMP      r1,#4
000006  d206              BCS      |L8.22|
;;;166    	{
;;;167    		return ;
;;;168    	}
;;;169    	if(!service)
000008  2a00              CMP      r2,#0
00000a  d004              BEQ      |L8.22|
;;;170    	{
;;;171    		return ;
;;;172    	}
;;;173    
;;;174    	// 配置按键服务
;;;175    	keyMsgCB.keyMsgInfo[keyName].service[keyMsg] = service;
00000c  4802              LDR      r0,|L8.24|
00000e  eb000081          ADD      r0,r0,r1,LSL #2
000012  60c2              STR      r2,[r0,#0xc]
;;;176    	keyMsgCB.keyMsgInfo[keyName].param[keyMsg] = param;
000014  61c3              STR      r3,[r0,#0x1c]
                  |L8.22|
;;;177    }
000016  4770              BX       lr
;;;178    
                          ENDP

                  |L8.24|
                          DCD      ||.bss||

                          AREA ||i.KEYMSG_ScanProcess||, CODE, READONLY, ALIGN=2

                  KEYMSG_ScanProcess PROC
;;;225    // 【接口功能】按键扫描处理
;;;226    void KEYMSG_ScanProcess(void)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;227    {
;;;228    	uint8 i;
;;;229    	KEYMSG_INFO_CB* pKeyInfo = NULL;
;;;230    	uint16 currentKeyBit = 0;	// 当前按键状态，无论哪个按键，都需要把按键值移动到最高位，以便与状态队列中的数值进行比较
;;;231    	
;;;232    	uint16 currentCount = 0;	// 当前按键状态计数值
;;;233    	uint16 currentState = 0;	// 当前按键状态
;;;234    	uint16* pStateCount = NULL;	// 当前操作中的状态计数值
;;;235    
;;;236    	if(!keyMsgCB.scanRequest)
000004  4f22              LDR      r7,|L9.144|
000006  7838              LDRB     r0,[r7,#0]  ; keyMsgCB
000008  2800              CMP      r0,#0
00000a  d03e              BEQ      |L9.138|
;;;237    	{
;;;238    		return ;
;;;239    	}
;;;240    	
;;;241    	keyMsgCB.scanRequest = FALSE;
00000c  2000              MOVS     r0,#0
00000e  7038              STRB     r0,[r7,#0]
;;;242    	
;;;243    	// 调用回调函数读取按键值，未注册回调函数时退出
;;;244    	if(NULL == keyMsgCB.KeyUpdate)
000010  6c79              LDR      r1,[r7,#0x44]  ; keyMsgCB
000012  2900              CMP      r1,#0
000014  d039              BEQ      |L9.138|
;;;245    	{
;;;246    		return ;
;;;247    	}
;;;248    
;;;249    	//在KEY_Init()中已经注册了KEY_CALLBACK_Scan函数，在这里调用，将里面的*p8bitKeyValueArray = keyValue;等于keyMsgCB.keyValue= keyValue获取键值
;;;250    	(*keyMsgCB.KeyUpdate)(keyMsgCB.keyValue);
000016  1c78              ADDS     r0,r7,#1
000018  4788              BLX      r1
;;;251    	
;;;252    	// 对每个按键当前的状态进行处理，将按键状态放入各自的按键信息节点中
;;;253    	for(i=0; i<KEY_NAME_MAX; i++)
00001a  2100              MOVS     r1,#0
;;;254    	{
;;;255    		// 获取当前按键信息结构体指针
;;;256    		pKeyInfo = &keyMsgCB.keyMsgInfo[i];
;;;257    		
;;;258    		// 获取当前操作中的按键状态计数值指针stateCount[KEY_INFO_SIZE];
;;;259    		pStateCount = &(pKeyInfo->stateCount[pKeyInfo->end]);
;;;260    		
;;;261    		// 获取当前按键状态
;;;262    		currentState = (*pStateCount) & KEY_STATE_MASK;
;;;263    		
;;;264    		// 获取当前按键状态计数值
;;;265    		currentCount = (*pStateCount) & (~KEY_STATE_MASK);
;;;266    		
;;;267    		// 获取当前读取到的按键状态，并移位
;;;268    		currentKeyBit = keyMsgCB.keyValue[i/8]&(0x01<<(i%8));	// 屏蔽其它按键值，只保留当前按键值
00001c  f04f0801          MOV      r8,#1
                  |L9.32|
000020  eb010081          ADD      r0,r1,r1,LSL #2       ;256
000024  eb0702c0          ADD      r2,r7,r0,LSL #3       ;256
000028  f812cf04          LDRB     r12,[r2,#4]!          ;259
00002c  eb02034c          ADD      r3,r2,r12,LSL #1      ;259
000030  1c9b              ADDS     r3,r3,#2              ;259
000032  881c              LDRH     r4,[r3,#0]            ;262
000034  f4044900          AND      r9,r4,#0x8000         ;262
000038  f4244600          BIC      r6,r4,#0x8000         ;265
00003c  eb0700d1          ADD      r0,r7,r1,LSR #3
000040  7845              LDRB     r5,[r0,#1]
000042  f0010007          AND      r0,r1,#7
000046  fa08fa00          LSL      r10,r8,r0
00004a  ea05050a          AND      r5,r5,r10
;;;269    		currentKeyBit <<= 7 + 8 - (i%8);					// 将按键值移位到16bit的最高位
00004e  f1c0000f          RSB      r0,r0,#0xf
000052  4085              LSLS     r5,r5,r0
000054  b2ad              UXTH     r5,r5
;;;270    
;;;271    		// 如果当前按键状态与上一次状态相同，则最后一个状态计数值递增
;;;272    		if(currentKeyBit == currentState)
000056  454d              CMP      r5,r9
000058  d10a              BNE      |L9.112|
;;;273    		{ 
;;;274    			// 次数未溢出时，可以递增，否则不变
;;;275    			if(currentCount < (KEY_STATE_MASK-1))
00005a  f64770ff          MOV      r0,#0x7fff
00005e  4286              CMP      r6,r0
000060  d20f              BCS      |L9.130|
;;;276    			{
;;;277    				// 【计数值处理方法说明】
;;;278    				// 计数值为0，说明当前计数值为1，并且已抛出边沿消息；
;;;279    				// 计数值为1，说明当前计数值为1，但未抛出边沿消息；
;;;280    				// 计数值 >1，代表实际的计数值
;;;281    				// 因此遇到计数值为0时，说明前面已经抛出了边沿消息，计数值需要增加2，以避免重复抛出边沿消息
;;;282    				if(0 == currentCount)
000062  b116              CBZ      r6,|L9.106|
;;;283    				{
;;;284    					(*pStateCount) += 2;
;;;285    				}
;;;286    				else
;;;287    				{
;;;288    					(*pStateCount) ++;
000064  1c64              ADDS     r4,r4,#1
000066  801c              STRH     r4,[r3,#0]
000068  e00b              B        |L9.130|
                  |L9.106|
00006a  1ca4              ADDS     r4,r4,#2              ;284
00006c  801c              STRH     r4,[r3,#0]            ;284
00006e  e008              B        |L9.130|
                  |L9.112|
;;;289    				}
;;;290    			}
;;;291    		}
;;;292    		// 当前按键状态与上一次状态不同，则新增状态，同时触发对应消息
;;;293    		else
;;;294    		{
;;;295    			pKeyInfo->end ++;
000070  f10c0c01          ADD      r12,r12,#1
;;;296    			pKeyInfo->end %= KEY_INFO_SIZE;
000074  f00c0001          AND      r0,r12,#1
000078  7010              STRB     r0,[r2,#0]
;;;297    			pKeyInfo->stateCount[pKeyInfo->end] = currentKeyBit + 1;	// 当前状态添加到队列末尾，并且计数值赋1
00007a  eb020040          ADD      r0,r2,r0,LSL #1
00007e  1c6d              ADDS     r5,r5,#1
000080  8045              STRH     r5,[r0,#2]
                  |L9.130|
000082  1c49              ADDS     r1,r1,#1              ;253
000084  b2c9              UXTB     r1,r1                 ;253
000086  2900              CMP      r1,#0                 ;253
000088  d0ca              BEQ      |L9.32|
                  |L9.138|
;;;298    		}
;;;299    	}
;;;300    }
00008a  e8bd87f0          POP      {r4-r10,pc}
;;;301    
                          ENDP

00008e  0000              DCW      0x0000
                  |L9.144|
                          DCD      ||.bss||

                          AREA ||i.KEYMSG_ServiceDoNothing||, CODE, READONLY, ALIGN=1

                  KEYMSG_ServiceDoNothing PROC
;;;75     // 【使用方法】空函数，什么也不做
;;;76     void KEYMSG_ServiceDoNothing(uint32 param)
000000  4770              BX       lr
;;;77     {
;;;78     	return ;
;;;79     }
;;;80     
                          ENDP


                          AREA ||i.KEYMSG_ServiceProcess||, CODE, READONLY, ALIGN=2

                  KEYMSG_ServiceProcess PROC
;;;426    // 【接口功能】按键服务处理
;;;427    void KEYMSG_ServiceProcess(void)
000000  b510              PUSH     {r4,lr}
;;;428    {
;;;429    	KEY_NAME_E keyName;
;;;430    	KEY_MSG_E keyMsg;
;;;431    	void (*service)(uint32 param) = 0;
;;;432    	
;;;433    	// 消息队列为空，退出
;;;434    	if(keyMsgCB.msgQueue.head == keyMsgCB.msgQueue.end)
000002  4c10              LDR      r4,|L11.68|
000004  f894002c          LDRB     r0,[r4,#0x2c]  ; keyMsgCB
000008  f894102d          LDRB     r1,[r4,#0x2d]  ; keyMsgCB
00000c  4288              CMP      r0,r1
00000e  d017              BEQ      |L11.64|
;;;435    	{
;;;436    		return ;
;;;437    	}
;;;438    	
;;;439    	// 取出最早的消息执行
;;;440    	keyName  = keyMsgCB.msgQueue.node[keyMsgCB.msgQueue.head].keyName;
000010  eb040040          ADD      r0,r4,r0,LSL #1
000014  f8101f2e          LDRB     r1,[r0,#0x2e]!
;;;441    	keyMsg = keyMsgCB.msgQueue.node[keyMsgCB.msgQueue.head].keyMsg;
000018  7840              LDRB     r0,[r0,#1]
;;;442    	
;;;443    	if(keyName >= KEY_NAME_MAX)
00001a  2900              CMP      r1,#0
00001c  d110              BNE      |L11.64|
;;;444    	{
;;;445    		return ;
;;;446    	}
;;;447    	if(keyMsg >= KEY_MSG_MAX)
00001e  2804              CMP      r0,#4
000020  d20e              BCS      |L11.64|
;;;448    	{
;;;449    		return ;
;;;450    	}
;;;451    	
;;;452    	// 执行已注册的按键消息服务
;;;453    	service = keyMsgCB.keyMsgInfo[keyName].service[keyMsg];
000022  eb040080          ADD      r0,r4,r0,LSL #2
000026  68c1              LDR      r1,[r0,#0xc]
;;;454    	(*service)(keyMsgCB.keyMsgInfo[keyName].param[keyMsg]);
000028  69c0              LDR      r0,[r0,#0x1c]
00002a  4788              BLX      r1
;;;455    	
;;;456    	keyMsgCB.msgQueue.head ++;
00002c  f8140f2c          LDRB     r0,[r4,#0x2c]!  ; keyMsgCB
000030  1c40              ADDS     r0,r0,#1
000032  b2c0              UXTB     r0,r0
;;;457    	keyMsgCB.msgQueue.head %= KEY_MSG_QUEUE_SIZE;
000034  210a              MOVS     r1,#0xa
000036  fbb0f2f1          UDIV     r2,r0,r1
00003a  fb010012          MLS      r0,r1,r2,r0
00003e  7020              STRB     r0,[r4,#0]
                  |L11.64|
;;;458    }
000040  bd10              POP      {r4,pc}
;;;459    
                          ENDP

000042  0000              DCW      0x0000
                  |L11.68|
                          DCD      ||.bss||

                          AREA ||i.KEYMSG_SetGlobalMaskRequest||, CODE, READONLY, ALIGN=2

                  KEYMSG_SetGlobalMaskRequest PROC
;;;563    // 设置全局屏蔽请求
;;;564    void KEYMSG_SetGlobalMaskRequest(void)
000000  4902              LDR      r1,|L12.12|
;;;565    {
;;;566    	keyMsgCB.globalMaskRequest = TRUE;
000002  2001              MOVS     r0,#1
000004  f881004c          STRB     r0,[r1,#0x4c]
;;;567    }
000008  4770              BX       lr
;;;568    
                          ENDP

00000a  0000              DCW      0x0000
                  |L12.12|
                          DCD      ||.bss||

                          AREA ||i.KEYMSG_SetMaskRequest||, CODE, READONLY, ALIGN=2

                  KEYMSG_SetMaskRequest PROC
;;;551    // 设置指定按键的指定消息的屏蔽请求
;;;552    void KEYMSG_SetMaskRequest(KEY_NAME_E keyName, KEY_MSG_E keyMsg)
000000  4b03              LDR      r3,|L13.16|
;;;553    {
;;;554    	keyMsgCB.msgMaskRequest[keyName][keyMsg] = TRUE;
000002  2201              MOVS     r2,#1
000004  eb030080          ADD      r0,r3,r0,LSL #2
000008  4408              ADD      r0,r0,r1
00000a  f8802048          STRB     r2,[r0,#0x48]
;;;555    }
00000e  4770              BX       lr
;;;556    
                          ENDP

                  |L13.16|
                          DCD      ||.bss||

                          AREA ||i.KEYMSG_StopAllService||, CODE, READONLY, ALIGN=2

                  KEYMSG_StopAllService PROC
;;;202    // 【使用方法】停止所有按键所有消息的响应
;;;203    void KEYMSG_StopAllService(void)
000000  b530              PUSH     {r4,r5,lr}
;;;204    {
;;;205    	uint8 i,j;
;;;206    	
;;;207    	// 按键消息服务初始化
;;;208    	for(i=0; i<KEY_NAME_MAX; i++)
000002  2100              MOVS     r1,#0
;;;209    	{
;;;210    		for(j=0; j<KEY_MSG_MAX; j++)
;;;211    		{
;;;212    			keyMsgCB.keyMsgInfo[i].service[j] = KEYMSG_ServiceDoNothing;
000004  4a09              LDR      r2,|L14.44|
000006  4d0a              LDR      r5,|L14.48|
                  |L14.8|
000008  2000              MOVS     r0,#0                 ;210
00000a  eb010381          ADD      r3,r1,r1,LSL #2
00000e  eb0503c3          ADD      r3,r5,r3,LSL #3
                  |L14.18|
000012  eb030480          ADD      r4,r3,r0,LSL #2
000016  60e2              STR      r2,[r4,#0xc]
000018  1c40              ADDS     r0,r0,#1              ;210
00001a  b2c0              UXTB     r0,r0                 ;210
00001c  2804              CMP      r0,#4                 ;210
00001e  d3f8              BCC      |L14.18|
000020  1c49              ADDS     r1,r1,#1              ;208
000022  b2c9              UXTB     r1,r1                 ;208
000024  2900              CMP      r1,#0                 ;208
000026  d0ef              BEQ      |L14.8|
;;;213    		}
;;;214    	}
;;;215    }
000028  bd30              POP      {r4,r5,pc}
;;;216    
                          ENDP

00002a  0000              DCW      0x0000
                  |L14.44|
                          DCD      KEYMSG_ServiceDoNothing
                  |L14.48|
                          DCD      ||.bss||

                          AREA ||i.KEYMSG_StopService||, CODE, READONLY, ALIGN=2

                  KEYMSG_StopService PROC
;;;182    // 【使用方法】需要停止按键消息响应时，通过本接口停止对指定按键的指定消息的响应
;;;183    void KEYMSG_StopService(KEY_NAME_E keyName, KEY_MSG_E keyMsg)
000000  2800              CMP      r0,#0
;;;184    {
000002  d106              BNE      |L15.18|
;;;185    	// 参数合法性检验
;;;186    	if(keyName >= KEY_NAME_MAX)
;;;187    	{
;;;188    		return ;
;;;189    	}
;;;190    	if(keyMsg >= KEY_MSG_MAX)
000004  2904              CMP      r1,#4
000006  d204              BCS      |L15.18|
;;;191    	{
;;;192    		return ;
;;;193    	}
;;;194    	
;;;195    	// 将对应按键的对应服务设置为空
;;;196    	keyMsgCB.keyMsgInfo[keyName].service[keyMsg] = KEYMSG_ServiceDoNothing;
000008  4803              LDR      r0,|L15.24|
00000a  4a02              LDR      r2,|L15.20|
00000c  eb000081          ADD      r0,r0,r1,LSL #2
000010  60c2              STR      r2,[r0,#0xc]
                  |L15.18|
;;;197    }
000012  4770              BX       lr
;;;198    
                          ENDP

                  |L15.20|
                          DCD      KEYMSG_ServiceDoNothing
                  |L15.24|
                          DCD      ||.bss||

                          AREA ||i.KEYMSG_ThrowMsg||, CODE, READONLY, ALIGN=2

                  KEYMSG_ThrowMsg PROC
;;;477    // 【接口功能】抛出按键消息，保存在消息环形队列中
;;;478    uint8 KEYMSG_ThrowMsg(KEY_NAME_E keyName, KEY_MSG_E keyMsg)
000000  b570              PUSH     {r4-r6,lr}
;;;479    {
;;;480    	// 当前按键的当前消息有屏蔽请求，则不添加，并清除屏蔽请求
;;;481    	if(keyMsgCB.msgMaskRequest[keyName][keyMsg])
000002  4a1d              LDR      r2,|L16.120|
000004  eb020380          ADD      r3,r2,r0,LSL #2
000008  440b              ADD      r3,r3,r1
00000a  f8934048          LDRB     r4,[r3,#0x48]
00000e  2c00              CMP      r4,#0
000010  d003              BEQ      |L16.26|
;;;482    	{
;;;483    		keyMsgCB.msgMaskRequest[keyName][keyMsg] = FALSE;
000012  2000              MOVS     r0,#0
000014  f8830048          STRB     r0,[r3,#0x48]
;;;484    
;;;485    		return 0;
;;;486    	}
;;;487    
;;;488    	// 有全局屏蔽请求，则退出
;;;489    	if(keyMsgCB.globalMaskRequest)
;;;490    	{
;;;491    		return 0;
;;;492    	}
;;;493    	
;;;494    	// 消息队列满，禁止添加
;;;495    	if(((keyMsgCB.msgQueue.end+1)%KEY_MSG_QUEUE_SIZE) == keyMsgCB.msgQueue.head)
;;;496    	{
;;;497    #if 0==KEY_MSG_PRIORITY	// 旧消息优先时，队列满禁止添加
;;;498    	  
;;;499    		return 0;
;;;500    		
;;;501    #else	// 新消息优先时，队列满，删除最早的消息
;;;502    		
;;;503    		keyMsgCB.msgQueue.head ++;
;;;504    		keyMsgCB.msgQueue.head %= KEY_MSG_QUEUE_SIZE;
;;;505    #endif
;;;506    	}
;;;507    	
;;;508    #if 0==KEY_MSG_THROW_KEY_UP_AFTER_REPEAT	// KEY_REPEAT 消息后禁止抛出 KEY_UP 消息
;;;509    	// KEY_UP 屏蔽位置位时，不抛出 KEY_UP 消息，并且清除屏蔽位
;;;510    	if((KEY_MSG_UP == keyMsg) && (keyMsgCB.keyUpMsgMaskBit[keyName/8] & (0x01<<(keyName%8))))
;;;511    	{
;;;512    		keyMsgCB.keyUpMsgMaskBit[keyName/8] &= (0x01<<(keyName%8));
;;;513    	}
;;;514    	else
;;;515    	{
;;;516    		// 添加到队列中
;;;517    		keyMsgCB.msgQueue.node[keyMsgCB.msgQueue.end].keyName  = keyName;
;;;518    		keyMsgCB.msgQueue.node[keyMsgCB.msgQueue.end].keyMsg = keyMsg;
;;;519    		// 队尾后移
;;;520    		keyMsgCB.msgQueue.end ++;
;;;521    		keyMsgCB.msgQueue.end %= KEY_MSG_QUEUE_SIZE;
;;;522    	}
;;;523    #else	// 无论何种情况，按键释放时均抛出 KEY_UP 消息
;;;524    	// 添加到队列中
;;;525    	keyMsgCB.msgQueue.node[keyMsgCB.msgQueue.end].keyName  = keyName;
;;;526    	keyMsgCB.msgQueue.node[keyMsgCB.msgQueue.end].keyMsg = keyMsg;
;;;527    	
;;;528    	// 队尾后移
;;;529    	keyMsgCB.msgQueue.end ++;
;;;530    	keyMsgCB.msgQueue.end %= KEY_MSG_QUEUE_SIZE;
;;;531    #endif
;;;532    
;;;533    	return 1;
;;;534    }
000018  bd70              POP      {r4-r6,pc}
                  |L16.26|
00001a  f892304c          LDRB     r3,[r2,#0x4c]         ;489  ; keyMsgCB
00001e  b10b              CBZ      r3,|L16.36|
000020  2000              MOVS     r0,#0                 ;491
000022  bd70              POP      {r4-r6,pc}
                  |L16.36|
000024  f892402d          LDRB     r4,[r2,#0x2d]         ;495  ; keyMsgCB
000028  230a              MOVS     r3,#0xa               ;495
00002a  4625              MOV      r5,r4                 ;495
00002c  1c64              ADDS     r4,r4,#1              ;495
00002e  fbb4f6f3          UDIV     r6,r4,r3              ;495
000032  fb034616          MLS      r6,r3,r6,r4           ;495
000036  f892402c          LDRB     r4,[r2,#0x2c]         ;495  ; keyMsgCB
00003a  42a6              CMP      r6,r4                 ;495
00003c  d107              BNE      |L16.78|
00003e  1c64              ADDS     r4,r4,#1              ;503
000040  b2e4              UXTB     r4,r4                 ;503
000042  fbb4f6f3          UDIV     r6,r4,r3              ;504
000046  fb034416          MLS      r4,r3,r6,r4           ;504
00004a  f882402c          STRB     r4,[r2,#0x2c]         ;504
                  |L16.78|
00004e  eb020445          ADD      r4,r2,r5,LSL #1       ;525
000052  f884002e          STRB     r0,[r4,#0x2e]         ;525
000056  f892002d          LDRB     r0,[r2,#0x2d]         ;526  ; keyMsgCB
00005a  eb020040          ADD      r0,r2,r0,LSL #1       ;526
00005e  f880102f          STRB     r1,[r0,#0x2f]         ;526
000062  f8120f2d          LDRB     r0,[r2,#0x2d]!        ;529  ; keyMsgCB
000066  1c40              ADDS     r0,r0,#1              ;529
000068  b2c0              UXTB     r0,r0                 ;529
00006a  fbb0f1f3          UDIV     r1,r0,r3              ;530
00006e  fb030011          MLS      r0,r3,r1,r0           ;530
000072  7010              STRB     r0,[r2,#0]            ;530
000074  2001              MOVS     r0,#1                 ;533
000076  bd70              POP      {r4-r6,pc}
;;;535    
                          ENDP

                  |L16.120|
                          DCD      ||.bss||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  keyMsgCB
                          %        80

                          AREA ||.constdata||, DATA, READONLY, ALIGN=1

                  keyHoldThreshHold
000000  03e8              DCW      0x03e8
                  keyRepeatTime
000002  0064              DCW      0x0064

                          AREA ||.data||, DATA, ALIGN=0

                  keyuiui
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "User\\keyMsgProcess.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_keyMsgProcess_c_7077c383____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___15_keyMsgProcess_c_7077c383____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_keyMsgProcess_c_7077c383____REVSH|
#line 128
|__asm___15_keyMsgProcess_c_7077c383____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
