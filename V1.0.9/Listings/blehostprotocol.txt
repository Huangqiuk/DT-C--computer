; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\blehostprotocol.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\blehostprotocol.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -I.\User\qrencode -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.1\Device\Include -D__MICROLIB -D__UVISION_VERSION=534 -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\blehostprotocol.crf User\BleHostProtocol.c]
                          THUMB

                          AREA ||i.BLE_HOST_PROTOCOL_CheckSUM||, CODE, READONLY, ALIGN=1

                  BLE_HOST_PROTOCOL_CheckSUM PROC
;;;501    // 对传入的命令帧进行校验，返回校验结果
;;;502    BOOL BLE_HOST_PROTOCOL_CheckSUM(BLE_HOST_PROTOCOL_RX_CMD_FRAME* pCmdFrame)
000000  b530              PUSH     {r4,r5,lr}
;;;503    {
;;;504    	uint8 cc = 0;
000002  2200              MOVS     r2,#0
;;;505    	uint16 i = 0;
000004  2100              MOVS     r1,#0
;;;506    	
;;;507    	if(NULL == pCmdFrame)
000006  2800              CMP      r0,#0
000008  d003              BEQ      |L1.18|
;;;508    	{
;;;509    		return FALSE;
;;;510    	}
;;;511    
;;;512    	// 从命令头开始，到校验码之前的一个字节，依次进行异或运算
;;;513    	for(i=0; i<pCmdFrame->length-1; i++)
00000a  f8b05066          LDRH     r5,[r0,#0x66]
00000e  1e6b              SUBS     r3,r5,#1
000010  e006              B        |L1.32|
                  |L1.18|
000012  2000              MOVS     r0,#0                 ;509
;;;514    	{
;;;515    		cc ^= pCmdFrame->buff[i];
;;;516    	}
;;;517    
;;;518    	cc = ~cc;
;;;519    	
;;;520    	// 判断计算得到的校验码与命令帧中的校验码是否相同
;;;521    	if(pCmdFrame->buff[pCmdFrame->length-1] != cc)
;;;522    	{
;;;523    		return FALSE;
;;;524    	}
;;;525    	
;;;526    	return TRUE;
;;;527    }
000014  bd30              POP      {r4,r5,pc}
                  |L1.22|
000016  1844              ADDS     r4,r0,r1              ;515
000018  78a4              LDRB     r4,[r4,#2]            ;515
00001a  4062              EORS     r2,r2,r4              ;515
00001c  1c49              ADDS     r1,r1,#1              ;513
00001e  b289              UXTH     r1,r1                 ;513
                  |L1.32|
000020  428b              CMP      r3,r1                 ;513
000022  dcf8              BGT      |L1.22|
000024  43d1              MVNS     r1,r2                 ;518
000026  b2c9              UXTB     r1,r1                 ;518
000028  1c40              ADDS     r0,r0,#1              ;521
00002a  5c28              LDRB     r0,[r5,r0]            ;521
00002c  4288              CMP      r0,r1                 ;521
00002e  d001              BEQ      |L1.52|
000030  2000              MOVS     r0,#0                 ;523
000032  bd30              POP      {r4,r5,pc}
                  |L1.52|
000034  2001              MOVS     r0,#1                 ;526
000036  bd30              POP      {r4,r5,pc}
;;;528    
                          ENDP


                          AREA ||i.BLE_HOST_PROTOCOL_CmdFrameProcess||, CODE, READONLY, ALIGN=2

                  BLE_HOST_PROTOCOL_CmdFrameProcess PROC
;;;529    // BLE命令帧缓冲区处理
;;;530    void BLE_HOST_PROTOCOL_CmdFrameProcess(BLE_HOST_PROTOCOL_CB* pCB)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;531    {
000004  4606              MOV      r6,r0
;;;532    	BLE_HOST_PROTOCOL_CMD cmd = BLE_HOST_CMD_MAX;
;;;533    	BLE_HOST_PROTOCOL_RX_CMD_FRAME* pCmdFrame = NULL;
;;;534    	uint8 i = 0;
000006  2500              MOVS     r5,#0
;;;535    	
;;;536    	// 参数合法性检验
;;;537    	if(NULL == pCB)
000008  2e00              CMP      r6,#0
00000a  d018              BEQ      |L2.62|
;;;538    	{
;;;539    		return;
;;;540    	}
;;;541    
;;;542    	// 命令帧缓冲区为空，退出
;;;543    	if(pCB->rx.head == pCB->rx.end)
00000c  f8b602d6          LDRH     r0,[r6,#0x2d6]
000010  f8b612d8          LDRH     r1,[r6,#0x2d8]
000014  4288              CMP      r0,r1
000016  d012              BEQ      |L2.62|
;;;544    	{
;;;545    		return;
;;;546    	}
;;;547    
;;;548    	// 获取当前要处理的命令帧指针
;;;549    	pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.head];
000018  eb000180          ADD      r1,r0,r0,LSL #2
00001c  eb0101c0          ADD      r1,r1,r0,LSL #3
000020  eb0604c1          ADD      r4,r6,r1,LSL #3
000024  34ce              ADDS     r4,r4,#0xce
;;;550    	
;;;551    	// 命令头非法，退出
;;;552    	if(BLE_HOST_PROTOCOL_CMD_HEAD != pCmdFrame->buff[BLE_HOST_PROTOCOL_CMD_HEAD_INDEX])
;;;553    	{
;;;554    		// 删除命令帧
;;;555    		pCB->rx.head ++;
;;;556    		pCB->rx.head %= BLE_HOST_PROTOCOL_RX_QUEUE_SIZE;
000026  2705              MOVS     r7,#5
000028  78a1              LDRB     r1,[r4,#2]            ;552
00002a  2955              CMP      r1,#0x55              ;552
00002c  d009              BEQ      |L2.66|
00002e  1c40              ADDS     r0,r0,#1              ;555
000030  b280              UXTH     r0,r0                 ;555
000032  fbb0f1f7          UDIV     r1,r0,r7
000036  fb070011          MLS      r0,r7,r1,r0
00003a  f8a602d6          STRH     r0,[r6,#0x2d6]
                  |L2.62|
;;;557    		return;
;;;558    	}
;;;559    
;;;560    	// 命令头合法，则提取命令
;;;561    	cmd = (BLE_HOST_PROTOCOL_CMD)pCmdFrame->buff[BLE_HOST_PROTOCOL_CMD_CMD_INDEX];
;;;562    	
;;;563    	// 执行命令帧
;;;564    	switch (cmd)
;;;565    	{
;;;566    		// 头盔控制命令
;;;567    		case BLE_OUTFIT_PROTOCOL_CMD_HELMET:
;;;568    
;;;569    			// 转向灯
;;;570    			if (0x01 == pCmdFrame->buff[BLE_HOST_PROTOCOL_CMD_DATA1_INDEX])
;;;571    			{
;;;572    				PARAM_SetTurnState((TRUN_STATE)pCmdFrame->buff[BLE_HOST_PROTOCOL_CMD_DATA3_INDEX]);
;;;573    			}
;;;574    
;;;575    			break;
;;;576    
;;;577    		// 头盔状态
;;;578    		case BLE_OUTFIT_PROTOCOL_CMD_HELMET_STATE:
;;;579    			
;;;580    			// 头盔电量百分比获取
;;;581    			if (0x01 == pCmdFrame->buff[BLE_HOST_PROTOCOL_CMD_DATA1_INDEX])
;;;582    			{
;;;583    				PARAM_SetHelmetBattery(pCmdFrame->buff[BLE_HOST_PROTOCOL_CMD_DATA2_INDEX]);
;;;584    			}
;;;585    			// 播放状态,音量值
;;;586    			else if (0x02 == pCmdFrame->buff[BLE_HOST_PROTOCOL_CMD_DATA1_INDEX])
;;;587    			{
;;;588    				paramCB.runtime.musicState = pCmdFrame->buff[BLE_HOST_PROTOCOL_CMD_DATA2_INDEX];
;;;589    				paramCB.runtime.musicVolume = pCmdFrame->buff[BLE_HOST_PROTOCOL_CMD_DATA4_INDEX];				
;;;590    			}
;;;591    	
;;;592    			break;
;;;593    			
;;;594    		// 头盔来电提醒命令
;;;595    		case BLE_OUTFIT_PROTOCOL_CMD_HELMET_PHONE:
;;;596    
;;;597    			PARAM_SetHelmetCaller(pCmdFrame->buff[BLE_HOST_PROTOCOL_CMD_DATA1_INDEX]);
;;;598    
;;;599    			// 接听或者挂断清除忽略标识
;;;600    			if ((0x01 == PARAM_GetHelmetCaller()) || (0x02 == PARAM_GetHelmetCaller()))
;;;601    			{
;;;602    				PARAM_SetCallerIgnoreState(FALSE);
;;;603    			}
;;;604    			
;;;605    			memset(callringBuff, 0xFF, sizeof((char *)callringBuff));
;;;606    			for (i = 0; i < 11; i++)
;;;607    			{
;;;608    				callringBuff[i] = pCmdFrame->buff[BLE_HOST_PROTOCOL_CMD_DATA2_INDEX + i] - '0';
;;;609    			} 
;;;610    			break;
;;;611    			
;;;612    		default:
;;;613    			break;
;;;614    	}
;;;615    
;;;616    	// 启动UART总线通讯超时判断
;;;617    	BLE_HOST_PROTOCOL_StartTimeoutCheckTask();
;;;618    	
;;;619    	// 删除命令帧
;;;620    	pCB->rx.head ++;
;;;621    	pCB->rx.head %= BLE_HOST_PROTOCOL_RX_QUEUE_SIZE;
;;;622    }
00003e  e8bd81f0          POP      {r4-r8,pc}
                  |L2.66|
000042  78e0              LDRB     r0,[r4,#3]            ;561
000044  4922              LDR      r1,|L2.208|
000046  28b1              CMP      r0,#0xb1              ;564
000048  d004              BEQ      |L2.84|
00004a  28b2              CMP      r0,#0xb2              ;564
00004c  d009              BEQ      |L2.98|
00004e  28b3              CMP      r0,#0xb3              ;564
000050  d130              BNE      |L2.180|
000052  e017              B        |L2.132|
                  |L2.84|
000054  7960              LDRB     r0,[r4,#5]            ;570
000056  2801              CMP      r0,#1                 ;570
000058  d12c              BNE      |L2.180|
00005a  79e0              LDRB     r0,[r4,#7]            ;572
00005c  f8810208          STRB     r0,[r1,#0x208]        ;572
000060  e028              B        |L2.180|
                  |L2.98|
000062  7960              LDRB     r0,[r4,#5]            ;581
000064  2801              CMP      r0,#1                 ;581
000066  d002              BEQ      |L2.110|
000068  2802              CMP      r0,#2                 ;586
00006a  d004              BEQ      |L2.118|
00006c  e022              B        |L2.180|
                  |L2.110|
00006e  79a0              LDRB     r0,[r4,#6]            ;583
000070  f881020e          STRB     r0,[r1,#0x20e]        ;583
000074  e01e              B        |L2.180|
                  |L2.118|
000076  79a0              LDRB     r0,[r4,#6]            ;588
000078  f8810213          STRB     r0,[r1,#0x213]        ;588
00007c  7a20              LDRB     r0,[r4,#8]            ;589
00007e  f8810214          STRB     r0,[r1,#0x214]        ;589
000082  e017              B        |L2.180|
                  |L2.132|
000084  7960              LDRB     r0,[r4,#5]            ;597
000086  f881020b          STRB     r0,[r1,#0x20b]        ;597
00008a  2801              CMP      r0,#1                 ;600
00008c  d001              BEQ      |L2.146|
00008e  2802              CMP      r0,#2                 ;600
000090  d102              BNE      |L2.152|
                  |L2.146|
000092  2000              MOVS     r0,#0                 ;602
000094  f881020c          STRB     r0,[r1,#0x20c]        ;602
                  |L2.152|
000098  22ff              MOVS     r2,#0xff              ;605
00009a  2104              MOVS     r1,#4                 ;605
00009c  480d              LDR      r0,|L2.212|
00009e  f7fffffe          BL       __aeabi_memset
0000a2  480c              LDR      r0,|L2.212|
                  |L2.164|
0000a4  1961              ADDS     r1,r4,r5              ;608
0000a6  7989              LDRB     r1,[r1,#6]            ;608
0000a8  3930              SUBS     r1,r1,#0x30           ;608
0000aa  5541              STRB     r1,[r0,r5]            ;608
0000ac  1c6d              ADDS     r5,r5,#1              ;606
0000ae  b2ed              UXTB     r5,r5                 ;606
0000b0  2d0b              CMP      r5,#0xb               ;606
0000b2  d3f7              BCC      |L2.164|
                  |L2.180|
0000b4  f7fffffe          BL       BLE_HOST_PROTOCOL_StartTimeoutCheckTask
0000b8  f8b602d6          LDRH     r0,[r6,#0x2d6]        ;620
0000bc  1c40              ADDS     r0,r0,#1              ;620
0000be  b280              UXTH     r0,r0                 ;620
0000c0  fbb0f1f7          UDIV     r1,r0,r7              ;621
0000c4  fb070011          MLS      r0,r7,r1,r0           ;621
0000c8  f8a602d6          STRH     r0,[r6,#0x2d6]        ;621
0000cc  e7b7              B        |L2.62|
;;;623    
                          ENDP

0000ce  0000              DCW      0x0000
                  |L2.208|
                          DCD      paramCB
                  |L2.212|
                          DCD      callringBuff

                          AREA ||i.BLE_HOST_PROTOCOL_ConfirmTempCmdFrameBuff||, CODE, READONLY, ALIGN=1

                  BLE_HOST_PROTOCOL_ConfirmTempCmdFrameBuff PROC
;;;282    // 将临时缓冲区添加到命令帧缓冲区中，其本质操作是承认临时缓冲区数据有效
;;;283    BOOL BLE_HOST_PROTOCOL_ConfirmTempCmdFrameBuff(BLE_HOST_PROTOCOL_CB* pCB)
000000  2800              CMP      r0,#0
;;;284    {
000002  d01e              BEQ      |L3.66|
;;;285    	BLE_HOST_PROTOCOL_RX_CMD_FRAME* pCmdFrame = NULL;
;;;286    	
;;;287    	// 参数合法性检验
;;;288    	if(NULL == pCB)
;;;289    	{
;;;290    		return FALSE;
;;;291    	}
;;;292    
;;;293    	// 临时缓冲区为空，不予添加
;;;294    	pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.end];
000004  f8b012d8          LDRH     r1,[r0,#0x2d8]
000008  eb010281          ADD      r2,r1,r1,LSL #2
00000c  eb0202c1          ADD      r2,r2,r1,LSL #3
000010  eb0002c2          ADD      r2,r0,r2,LSL #3
;;;295    	if(0 == pCmdFrame->length)
000014  f8b22134          LDRH     r2,[r2,#0x134]
000018  b1aa              CBZ      r2,|L3.70|
;;;296    	{
;;;297    		return FALSE;
;;;298    	}
;;;299    
;;;300    	// 添加
;;;301    	pCB->rx.end ++;
00001a  1c49              ADDS     r1,r1,#1
00001c  b289              UXTH     r1,r1
;;;302    	pCB->rx.end %= BLE_HOST_PROTOCOL_RX_QUEUE_SIZE;
00001e  2205              MOVS     r2,#5
000020  fbb1f3f2          UDIV     r3,r1,r2
000024  fb021113          MLS      r1,r2,r3,r1
000028  f8a012d8          STRH     r1,[r0,#0x2d8]
;;;303    	pCB->rx.cmdQueue[pCB->rx.end].length = 0;	// 该行的作用是将新的添加位置有效数据个数清零，以便将这个位置当做临时帧缓冲区
00002c  eb010381          ADD      r3,r1,r1,LSL #2
000030  eb0301c1          ADD      r1,r3,r1,LSL #3
000034  eb0000c1          ADD      r0,r0,r1,LSL #3
000038  2200              MOVS     r2,#0
00003a  f8a02134          STRH     r2,[r0,#0x134]
;;;304    	
;;;305    	return TRUE;
00003e  2001              MOVS     r0,#1
;;;306    }
000040  4770              BX       lr
                  |L3.66|
000042  2000              MOVS     r0,#0                 ;290
000044  4770              BX       lr
                  |L3.70|
000046  2000              MOVS     r0,#0                 ;297
000048  4770              BX       lr
;;;307    
                          ENDP


                          AREA ||i.BLE_HOST_PROTOCOL_DataStructInit||, CODE, READONLY, ALIGN=1

                  BLE_HOST_PROTOCOL_DataStructInit PROC
;;;210    // 数据结构初始化
;;;211    void BLE_HOST_PROTOCOL_DataStructInit(BLE_HOST_PROTOCOL_CB* pCB)
000000  2800              CMP      r0,#0
;;;212    {
000002  d033              BEQ      |L4.108|
;;;213    	uint16 i;
;;;214    	
;;;215    	// 参数合法性检验
;;;216    	if (NULL == pCB)
;;;217    	{
;;;218    		return;
;;;219    	}
;;;220    
;;;221    	pCB->tx.txBusy = FALSE;
000004  2200              MOVS     r2,#0
000006  f88024e8          STRB     r2,[r0,#0x4e8]
;;;222    	pCB->tx.index = 0;
00000a  f8a024e6          STRH     r2,[r0,#0x4e6]
;;;223    	pCB->tx.head = 0;
00000e  f8a024e2          STRH     r2,[r0,#0x4e2]
;;;224    	pCB->tx.end = 0;
000012  f8a024e4          STRH     r2,[r0,#0x4e4]
;;;225    	for(i = 0; i < BLE_HOST_PROTOCOL_TX_QUEUE_SIZE; i++)
000016  2100              MOVS     r1,#0
                  |L4.24|
;;;226    	{
;;;227    		pCB->tx.cmdQueue[i].length = 0;
000018  eb010381          ADD      r3,r1,r1,LSL #2
00001c  eb0303c1          ADD      r3,r3,r1,LSL #3
000020  eb0003c3          ADD      r3,r0,r3,LSL #3
000024  f8a32340          STRH     r2,[r3,#0x340]
000028  1c49              ADDS     r1,r1,#1              ;225
00002a  b289              UXTH     r1,r1                 ;225
00002c  2905              CMP      r1,#5                 ;225
00002e  d3f3              BCC      |L4.24|
;;;228    	}
;;;229    
;;;230    	pCB->rxFIFO.head = 0;
000030  f8202fc8          STRH     r2,[r0,#0xc8]!
;;;231    	pCB->rxFIFO.end = 0;
000034  8042              STRH     r2,[r0,#2]
;;;232    	pCB->rxFIFO.currentProcessIndex = 0;
000036  8082              STRH     r2,[r0,#4]
;;;233    
;;;234    	pCB->rx.head = 0;
000038  f8a0220e          STRH     r2,[r0,#0x20e]
;;;235    	pCB->rx.end  = 0;
00003c  f8a02210          STRH     r2,[r0,#0x210]
000040  38c8              SUBS     r0,r0,#0xc8
;;;236    	for(i=0; i<BLE_HOST_PROTOCOL_RX_QUEUE_SIZE; i++)
000042  2100              MOVS     r1,#0
                  |L4.68|
;;;237    	{
;;;238    		pCB->rx.cmdQueue[i].length = 0;
000044  eb010381          ADD      r3,r1,r1,LSL #2
000048  eb0303c1          ADD      r3,r3,r1,LSL #3
00004c  eb0003c3          ADD      r3,r0,r3,LSL #3
000050  f8a32134          STRH     r2,[r3,#0x134]
000054  1c49              ADDS     r1,r1,#1              ;236
000056  b289              UXTH     r1,r1                 ;236
000058  2905              CMP      r1,#5                 ;236
00005a  d3f3              BCC      |L4.68|
;;;239    	}
;;;240    
;;;241    	pCB->isTimeCheck = FALSE;
00005c  f88024f4          STRB     r2,[r0,#0x4f4]
;;;242    	
;;;243    	pCB->pair.state = BLE_PAIR_INIT;
000060  f8802704          STRB     r2,[r0,#0x704]
;;;244    	pCB->pair.preState = BLE_PAIR_INIT;
000064  f8802705          STRB     r2,[r0,#0x705]
;;;245    	pCB->pair.mode = BLE_NORMAL_MODE;
000068  f880271d          STRB     r2,[r0,#0x71d]
                  |L4.108|
;;;246    }
00006c  4770              BX       lr
;;;247    
                          ENDP


                          AREA ||i.BLE_HOST_PROTOCOL_Init||, CODE, READONLY, ALIGN=2

                  BLE_HOST_PROTOCOL_Init PROC
;;;77     // 协议初始化
;;;78     void BLE_HOST_PROTOCOL_Init(void)
000000  b510              PUSH     {r4,lr}
;;;79     {
;;;80     	// 协议层数据结构初始化
;;;81     	BLE_HOST_PROTOCOL_DataStructInit(&bleHostProtocolCB);
000002  4807              LDR      r0,|L5.32|
000004  f7fffffe          BL       BLE_HOST_PROTOCOL_DataStructInit
;;;82     
;;;83     	// 向驱动层注册数据接收接口
;;;84     	BLE_HOST_UART_RegisterDataSendService(BLE_HOST_PROTOCOL_MacProcess);
000008  4806              LDR      r0,|L5.36|
00000a  f7fffffe          BL       BLE_HOST_UART_RegisterDataSendService
;;;85     
;;;86     	// 向驱动层注册数据发送接口
;;;87     	BLE_HOST_PROTOCOL_RegisterDataSendService(BLE_HOST_UART_AddTxArray);
00000e  4806              LDR      r0,|L5.40|
000010  f7fffffe          BL       BLE_HOST_PROTOCOL_RegisterDataSendService
;;;88     
;;;89     	// 上电进入蓝牙配对初始化
;;;90     	BLE_PairEnterState(BLE_PAIR_INIT);	
000014  e8bd4010          POP      {r4,lr}
000018  2000              MOVS     r0,#0
00001a  f7ffbffe          B.W      BLE_PairEnterState
;;;91     }
;;;92     
                          ENDP

00001e  0000              DCW      0x0000
                  |L5.32|
                          DCD      ||.bss||
                  |L5.36|
                          DCD      BLE_HOST_PROTOCOL_MacProcess
                  |L5.40|
                          DCD      BLE_HOST_UART_AddTxArray

                          AREA ||i.BLE_HOST_PROTOCOL_MacProcess||, CODE, READONLY, ALIGN=2

                  BLE_HOST_PROTOCOL_MacProcess PROC
;;;248    // UART报文接收处理函数(注意根据具体模块修改)
;;;249    void BLE_HOST_PROTOCOL_MacProcess(uint16 standarID, uint8* pData, uint16 length)
000000  e92d03f0          PUSH     {r4-r9}
;;;250    {
;;;251    	uint16 end = bleHostProtocolCB.rxFIFO.end;
000004  4b10              LDR      r3,|L6.72|
000006  f8b340ca          LDRH     r4,[r3,#0xca]  ; bleHostProtocolCB
;;;252    	uint16 head = bleHostProtocolCB.rxFIFO.head;
00000a  f8b370c8          LDRH     r7,[r3,#0xc8]  ; bleHostProtocolCB
;;;253    	uint8 rxdata = 0x00;
;;;254    	
;;;255    	// 接收数据
;;;256    	rxdata = *pData;
00000e  f891c000          LDRB     r12,[r1,#0]
;;;257    
;;;258    	// 一级缓冲区已满，不予接收
;;;259    	if((end + 1)%BLE_HOST_PROTOCOL_RX_FIFO_SIZE == head)
000012  1c65              ADDS     r5,r4,#1
000014  26c8              MOVS     r6,#0xc8
000016  fbb5f8f6          UDIV     r8,r5,r6
00001a  fb065518          MLS      r5,r6,r8,r5
00001e  42bd              CMP      r5,r7
000020  d00f              BEQ      |L6.66|
;;;260    	{
;;;261    		return;
;;;262    	}
;;;263    	// 一级缓冲区未满，接收 
;;;264    	else
;;;265    	{
;;;266    		// 将接收到的数据放到临时缓冲区中
;;;267    		bleHostProtocolCB.rxFIFO.buff[end] = rxdata;
000022  f803c004          STRB     r12,[r3,r4]
;;;268    		bleHostProtocolCB.rxFIFO.end ++;
000026  f8334fca          LDRH     r4,[r3,#0xca]!  ; bleHostProtocolCB
00002a  1c64              ADDS     r4,r4,#1
00002c  801c              STRH     r4,[r3,#0]
;;;269    		bleHostProtocolCB.rxFIFO.end %= BLE_HOST_PROTOCOL_RX_FIFO_SIZE;
00002e  881c              LDRH     r4,[r3,#0]  ; bleHostProtocolCB
000030  fbb4f5f6          UDIV     r5,r4,r6
000034  fb064415          MLS      r4,r6,r5,r4
000038  801c              STRH     r4,[r3,#0]
;;;270    	}
;;;271    
;;;272    	// 嵌一套协议
;;;273    	BLE_PROTOCOL1_MacProcess(standarID, pData, length);
00003a  e8bd03f0          POP      {r4-r9}
00003e  f7ffbffe          B.W      BLE_PROTOCOL1_MacProcess
                  |L6.66|
;;;274    }
000042  e8bd03f0          POP      {r4-r9}
000046  4770              BX       lr
;;;275    
                          ENDP

                  |L6.72|
                          DCD      ||.bss||

                          AREA ||i.BLE_HOST_PROTOCOL_Process||, CODE, READONLY, ALIGN=2

                  BLE_HOST_PROTOCOL_Process PROC
;;;93     // BLE协议层过程处理
;;;94     void BLE_HOST_PROTOCOL_Process(void)
000000  b510              PUSH     {r4,lr}
;;;95     {
;;;96     	// BLE接收FIFO缓冲区处理
;;;97     	BLE_HOST_PROTOCOL_RxFIFOProcess(&bleHostProtocolCB);
000002  4806              LDR      r0,|L7.28|
000004  f7fffffe          BL       BLE_HOST_PROTOCOL_RxFIFOProcess
;;;98     
;;;99     	// BLE接收命令缓冲区处理
;;;100    	BLE_HOST_PROTOCOL_CmdFrameProcess(&bleHostProtocolCB);
000008  4804              LDR      r0,|L7.28|
00000a  f7fffffe          BL       BLE_HOST_PROTOCOL_CmdFrameProcess
;;;101    	
;;;102    	// BLE协议层发送处理过程
;;;103    	BLE_HOST_PROTOCOL_TxStateProcess();
00000e  f7fffffe          BL       BLE_HOST_PROTOCOL_TxStateProcess
;;;104    	
;;;105    	// 蓝牙配对处理过程
;;;106    	BLE_PairProcess();
000012  e8bd4010          POP      {r4,lr}
000016  f7ffbffe          B.W      BLE_PairProcess
;;;107    }
;;;108    
                          ENDP

00001a  0000              DCW      0x0000
                  |L7.28|
                          DCD      ||.bss||

                          AREA ||i.BLE_HOST_PROTOCOL_RegisterDataSendService||, CODE, READONLY, ALIGN=2

                  BLE_HOST_PROTOCOL_RegisterDataSendService PROC
;;;276    // UART协议层向驱动层注册数据发送接口
;;;277    void BLE_HOST_PROTOCOL_RegisterDataSendService(BOOL (*service)(uint16 id, uint8 *pData, uint16 length))
000000  4901              LDR      r1,|L8.8|
;;;278    {		
;;;279    	bleHostProtocolCB.sendDataThrowService = service;
000002  f8c104ec          STR      r0,[r1,#0x4ec]  ; bleHostProtocolCB
;;;280    }
000006  4770              BX       lr
;;;281    
                          ENDP

                  |L8.8|
                          DCD      ||.bss||

                          AREA ||i.BLE_HOST_PROTOCOL_RxFIFOProcess||, CODE, READONLY, ALIGN=1

                  BLE_HOST_PROTOCOL_RxFIFOProcess PROC
;;;341    // 一级接收缓冲区处理，从一级接收缓冲区中取出一个字节添加到命令帧缓冲区中
;;;342    void BLE_HOST_PROTOCOL_RxFIFOProcess(BLE_HOST_PROTOCOL_CB* pCB)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;343    {
000004  4604              MOV      r4,r0
;;;344    	uint16 end = pCB->rxFIFO.end;
000006  f8b410ca          LDRH     r1,[r4,#0xca]
;;;345    	uint16 head = pCB->rxFIFO.head;
00000a  f8b400c8          LDRH     r0,[r4,#0xc8]
;;;346    	BLE_HOST_PROTOCOL_RX_CMD_FRAME* pCmdFrame = NULL;
;;;347    	uint16 length = 0;
;;;348    	uint8 currentData = 0;
;;;349    	
;;;350    	// 参数合法性检验
;;;351    	if(NULL == pCB)
00000e  2c00              CMP      r4,#0
000010  d023              BEQ      |L9.90|
;;;352    	{
;;;353    		return;
;;;354    	}
;;;355    	
;;;356    	// 一级缓冲区为空，退出
;;;357    	if(head == end)
000012  4288              CMP      r0,r1
000014  d021              BEQ      |L9.90|
;;;358    	{
;;;359    		return;
;;;360    	}
;;;361    
;;;362    	// 获取临时缓冲区指针
;;;363    	pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.end];
000016  f8b402d8          LDRH     r0,[r4,#0x2d8]
00001a  eb000280          ADD      r2,r0,r0,LSL #2
00001e  eb0202c0          ADD      r2,r2,r0,LSL #3
000022  eb0405c2          ADD      r5,r4,r2,LSL #3
000026  35ce              ADDS     r5,r5,#0xce
;;;364    	// 取出当前要处理的字节
;;;365    	currentData = pCB->rxFIFO.buff[pCB->rxFIFO.currentProcessIndex];
000028  f8b420cc          LDRH     r2,[r4,#0xcc]
00002c  5ca2              LDRB     r2,[r4,r2]
;;;366    	
;;;367    	// 临时缓冲区长度为0时，搜索首字节
;;;368    	if(0 == pCmdFrame->length)
00002e  f8b53066          LDRH     r3,[r5,#0x66]
;;;369    	{
;;;370    		// 命令头错误，删除当前字节并退出
;;;371    		if(BLE_HOST_PROTOCOL_CMD_HEAD != currentData)
;;;372    		{
;;;373    			pCB->rxFIFO.head ++;
;;;374    			pCB->rxFIFO.head %= BLE_HOST_PROTOCOL_RX_FIFO_SIZE;
000032  27c8              MOVS     r7,#0xc8
000034  b19b              CBZ      r3,|L9.94|
;;;375    			pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;376    
;;;377    			return;
;;;378    		}
;;;379    		
;;;380    		// 命令头正确，但无临时缓冲区可用，退出
;;;381    		if((pCB->rx.end + 1)%BLE_HOST_PROTOCOL_RX_QUEUE_SIZE == pCB->rx.head)
;;;382    		{
;;;383    			return;
;;;384    		}
;;;385    
;;;386    		// 添加UART通讯超时时间设置-2016.1.5增加
;;;387    #if BLE_HOST_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;388    		TIMER_AddTask(TIMER_ID_UART_RX_TIME_OUT_CONTROL,
;;;389    						BLE_HOST_PROTOCOL_BUS_UNIDIRECTIONAL_TIME_OUT,
;;;390    						BLE_HOST_PROTOCOL_CALLBACK_RxTimeOut,
;;;391    						0,
;;;392    						1,
;;;393    						ACTION_MODE_ADD_TO_QUEUE);
;;;394    #endif
;;;395    		
;;;396    		// 命令头正确，有临时缓冲区可用，则将其添加到命令帧临时缓冲区中
;;;397    		pCmdFrame->buff[pCmdFrame->length++]= currentData;
;;;398    		pCB->rxFIFO.currentProcessIndex ++;
;;;399    		pCB->rxFIFO.currentProcessIndex %= BLE_HOST_PROTOCOL_RX_FIFO_SIZE;
;;;400    	}
;;;401    	// 非首字节，将数据添加到命令帧临时缓冲区中，但暂不删除当前数据
;;;402    	else
;;;403    	{
;;;404    		// 临时缓冲区溢出，说明当前正在接收的命令帧是错误的，正确的命令帧不会出现长度溢出的情况
;;;405    		if(pCmdFrame->length >= BLE_HOST_PROTOCOL_RX_CMD_FRAME_LENGTH_MAX)
000036  f04f0800          MOV      r8,#0
00003a  2b64              CMP      r3,#0x64
00003c  d37e              BCC      |L9.316|
;;;406    		{
;;;407    #if BLE_HOST_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;408    			// 停止RX通讯超时检测
;;;409    			BLE_HOST_PROTOCOL_StopRxTimeOutCheck();
;;;410    #endif
;;;411    
;;;412    			// 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;413    			pCmdFrame->length = 0;	// 2016.1.5增加
00003e  f8a58066          STRH     r8,[r5,#0x66]
;;;414    			// 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;415    			pCB->rxFIFO.head ++;
000042  f8340fc8          LDRH     r0,[r4,#0xc8]!
000046  1c40              ADDS     r0,r0,#1
000048  8020              STRH     r0,[r4,#0]
;;;416    			pCB->rxFIFO.head %= BLE_HOST_PROTOCOL_RX_FIFO_SIZE;
00004a  8820              LDRH     r0,[r4,#0]
00004c  fbb0f1f7          UDIV     r1,r0,r7
000050  fb070011          MLS      r0,r7,r1,r0
000054  8020              STRH     r0,[r4,#0]
;;;417    			pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
000056  8820              LDRH     r0,[r4,#0]
000058  80a0              STRH     r0,[r4,#4]
                  |L9.90|
;;;418    
;;;419    			return;
;;;420    		}
;;;421    
;;;422    		// 一直取到末尾
;;;423    		while(end != pCB->rxFIFO.currentProcessIndex)
;;;424    		{
;;;425    			// 取出当前要处理的字节
;;;426    			currentData = pCB->rxFIFO.buff[pCB->rxFIFO.currentProcessIndex];
;;;427    			// 缓冲区未溢出，正常接收，将数据添加到临时缓冲区中
;;;428    			pCmdFrame->buff[pCmdFrame->length++] = currentData;
;;;429    			pCB->rxFIFO.currentProcessIndex ++;
;;;430    			pCB->rxFIFO.currentProcessIndex %= BLE_HOST_PROTOCOL_RX_FIFO_SIZE;
;;;431    
;;;432    			// ■■接下来，需要检查命令帧是否完整，如果完整，则将命令帧临时缓冲区扶正 ■■
;;;433    						
;;;434    			// 首先判断命令帧最小长度，一个完整的命令字至少包括4个字节: 命令帧最小长度，包含:命令头、命令字、数据长度、校验和，因此不足4个字节的必定不完整
;;;435    			if(pCmdFrame->length < BLE_HOST_PROTOCOL_CMD_FRAME_LENGTH_MIN)
;;;436    			{
;;;437    				// 继续接收
;;;438    				continue;
;;;439    			}
;;;440    
;;;441    			// 命令帧长度数值越界，说明当前命令帧错误，停止接收
;;;442    			if(pCmdFrame->buff[BLE_HOST_PROTOCOL_CMD_LENGTH_INDEX] > (BLE_HOST_PROTOCOL_RX_CMD_FRAME_LENGTH_MAX - BLE_HOST_PROTOCOL_CMD_FRAME_LENGTH_MIN))
;;;443    			{
;;;444    #if BLE_HOST_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;445    				// 停止RX通讯超时检测
;;;446    				BLE_HOST_PROTOCOL_StopRxTimeOutCheck();
;;;447    #endif
;;;448    			
;;;449    				// 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;450    				pCmdFrame->length = 0;
;;;451    				// 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;452    				pCB->rxFIFO.head ++;
;;;453    				pCB->rxFIFO.head %= BLE_HOST_PROTOCOL_RX_FIFO_SIZE;
;;;454    				pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;455    
;;;456    				return;
;;;457    			}
;;;458    
;;;459    			// 命令帧长度校验
;;;460    			length = pCmdFrame->length;
;;;461    			if(length < pCmdFrame->buff[BLE_HOST_PROTOCOL_CMD_LENGTH_INDEX] + BLE_HOST_PROTOCOL_CMD_FRAME_LENGTH_MIN)
;;;462    			{
;;;463    				// 长度要求不一致，说明未接收完毕，退出继续
;;;464    				continue;
;;;465    			}
;;;466    
;;;467    			// 命令帧长度OK，则进行校验，失败时删除命令头
;;;468    			if(!BLE_HOST_PROTOCOL_CheckSUM(pCmdFrame))
;;;469    			{
;;;470    #if BLE_HOST_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;471    				// 停止RX通讯超时检测
;;;472    				BLE_HOST_PROTOCOL_StopRxTimeOutCheck();
;;;473    #endif
;;;474    				
;;;475    				// 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;476    				pCmdFrame->length = 0;
;;;477    				// 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;478    				pCB->rxFIFO.head ++;
;;;479    				pCB->rxFIFO.head %= BLE_HOST_PROTOCOL_RX_FIFO_SIZE;
;;;480    				pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;481    				
;;;482    				return;
;;;483    			}
;;;484    
;;;485    #if BLE_HOST_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;486    			// 停止RX通讯超时检测
;;;487    			BLE_HOST_PROTOCOL_StopRxTimeOutCheck();
;;;488    #endif
;;;489    			
;;;490    			// 执行到这里，即说明接收到了一个完整并且正确的命令帧，此时需将处理过的数据从一级缓冲区中删除，并将该命令帧扶正
;;;491    			pCB->rxFIFO.head += length;
;;;492    			pCB->rxFIFO.head %= BLE_HOST_PROTOCOL_RX_FIFO_SIZE;
;;;493    			pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;494    			BLE_HOST_PROTOCOL_ConfirmTempCmdFrameBuff(pCB);
;;;495    
;;;496    			return;
;;;497    		}
;;;498    	}
;;;499    }
00005a  e8bd81f0          POP      {r4-r8,pc}
                  |L9.94|
00005e  2a55              CMP      r2,#0x55              ;371
000060  d00c              BEQ      |L9.124|
000062  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;373
000066  1c40              ADDS     r0,r0,#1              ;373
000068  8020              STRH     r0,[r4,#0]            ;373
00006a  8820              LDRH     r0,[r4,#0]            ;374
00006c  fbb0f1f7          UDIV     r1,r0,r7              ;374
000070  fb070011          MLS      r0,r7,r1,r0           ;374
000074  8020              STRH     r0,[r4,#0]            ;374
000076  8820              LDRH     r0,[r4,#0]            ;375
000078  80a0              STRH     r0,[r4,#4]            ;375
00007a  e7ee              B        |L9.90|
                  |L9.124|
00007c  1c40              ADDS     r0,r0,#1              ;381
00007e  2105              MOVS     r1,#5                 ;381
000080  fbb0f3f1          UDIV     r3,r0,r1              ;381
000084  fb010013          MLS      r0,r1,r3,r0           ;381
000088  f8b412d6          LDRH     r1,[r4,#0x2d6]        ;381
00008c  4288              CMP      r0,r1                 ;381
00008e  d0e4              BEQ      |L9.90|
000090  2001              MOVS     r0,#1                 ;397
000092  f8a50066          STRH     r0,[r5,#0x66]         ;397
000096  70aa              STRB     r2,[r5,#2]            ;397
000098  f8340fcc          LDRH     r0,[r4,#0xcc]!        ;398
00009c  1c40              ADDS     r0,r0,#1              ;398
00009e  b280              UXTH     r0,r0                 ;398
0000a0  fbb0f1f7          UDIV     r1,r0,r7              ;399
0000a4  fb070011          MLS      r0,r7,r1,r0           ;399
0000a8  8020              STRH     r0,[r4,#0]            ;399
0000aa  e7d6              B        |L9.90|
                  |L9.172|
0000ac  5c22              LDRB     r2,[r4,r0]            ;426
0000ae  f8b50066          LDRH     r0,[r5,#0x66]         ;428
0000b2  1c43              ADDS     r3,r0,#1              ;428
0000b4  4428              ADD      r0,r0,r5              ;428
0000b6  f8a53066          STRH     r3,[r5,#0x66]         ;428
0000ba  7082              STRB     r2,[r0,#2]            ;428
0000bc  f8b400cc          LDRH     r0,[r4,#0xcc]         ;429
0000c0  1c40              ADDS     r0,r0,#1              ;429
0000c2  b280              UXTH     r0,r0                 ;429
0000c4  fbb0f2f7          UDIV     r2,r0,r7              ;430
0000c8  fb070012          MLS      r0,r7,r2,r0           ;430
0000cc  f8a400cc          STRH     r0,[r4,#0xcc]         ;430
0000d0  f8b56066          LDRH     r6,[r5,#0x66]         ;435
0000d4  2e04              CMP      r6,#4                 ;435
0000d6  d33b              BCC      |L9.336|
0000d8  7928              LDRB     r0,[r5,#4]            ;442
0000da  2860              CMP      r0,#0x60              ;442
0000dc  d90e              BLS      |L9.252|
0000de  f8a58066          STRH     r8,[r5,#0x66]         ;450
0000e2  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;452
0000e6  1c40              ADDS     r0,r0,#1              ;452
0000e8  8020              STRH     r0,[r4,#0]            ;452
0000ea  8820              LDRH     r0,[r4,#0]            ;453
0000ec  fbb0f1f7          UDIV     r1,r0,r7              ;453
0000f0  fb070011          MLS      r0,r7,r1,r0           ;453
0000f4  8020              STRH     r0,[r4,#0]            ;453
0000f6  8820              LDRH     r0,[r4,#0]            ;454
0000f8  80a0              STRH     r0,[r4,#4]            ;454
0000fa  e7ae              B        |L9.90|
                  |L9.252|
0000fc  1d00              ADDS     r0,r0,#4              ;461
0000fe  42b0              CMP      r0,r6                 ;461
000100  d826              BHI      |L9.336|
000102  4628              MOV      r0,r5                 ;468
000104  f7fffffe          BL       BLE_HOST_PROTOCOL_CheckSUM
000108  b188              CBZ      r0,|L9.302|
00010a  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;491
00010e  4430              ADD      r0,r0,r6              ;491
000110  8020              STRH     r0,[r4,#0]            ;491
000112  8820              LDRH     r0,[r4,#0]            ;492
000114  fbb0f1f7          UDIV     r1,r0,r7              ;492
000118  fb070011          MLS      r0,r7,r1,r0           ;492
00011c  8020              STRH     r0,[r4,#0]            ;492
00011e  8820              LDRH     r0,[r4,#0]            ;493
000120  80a0              STRH     r0,[r4,#4]            ;493
000122  3cc8              SUBS     r4,r4,#0xc8           ;493
000124  4620              MOV      r0,r4                 ;494
000126  e8bd41f0          POP      {r4-r8,lr}            ;494
00012a  f7ffbffe          B.W      BLE_HOST_PROTOCOL_ConfirmTempCmdFrameBuff
                  |L9.302|
00012e  f8a58066          STRH     r8,[r5,#0x66]         ;476
000132  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;478
000136  1c40              ADDS     r0,r0,#1              ;478
000138  8020              STRH     r0,[r4,#0]            ;478
00013a  e000              B        |L9.318|
                  |L9.316|
00013c  e008              B        |L9.336|
                  |L9.318|
00013e  8820              LDRH     r0,[r4,#0]            ;479
000140  fbb0f1f7          UDIV     r1,r0,r7              ;479
000144  fb070011          MLS      r0,r7,r1,r0           ;479
000148  8020              STRH     r0,[r4,#0]            ;479
00014a  8820              LDRH     r0,[r4,#0]            ;480
00014c  80a0              STRH     r0,[r4,#4]            ;480
00014e  e784              B        |L9.90|
                  |L9.336|
000150  f8b400cc          LDRH     r0,[r4,#0xcc]         ;423
000154  4288              CMP      r0,r1                 ;423
000156  d1a9              BNE      |L9.172|
000158  e77f              B        |L9.90|
;;;500    
                          ENDP


                          AREA ||i.BLE_HOST_PROTOCOL_SendCmdControlMp3||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                  BLE_HOST_PROTOCOL_SendCmdControlMp3 PROC
;;;884    // 多媒体控制功能
;;;885    void BLE_HOST_PROTOCOL_SendCmdControlMp3(uint32 param)
000000  b530              PUSH     {r4,r5,lr}
;;;886    {
000002  b0ab              SUB      sp,sp,#0xac
000004  4605              MOV      r5,r0
;;;887    	uint8 i = 0;
000006  2400              MOVS     r4,#0
;;;888    	uint8 Index = 0;
;;;889    	uint8 Buff[100] = {0};
000008  2164              MOVS     r1,#0x64
00000a  a812              ADD      r0,sp,#0x48
00000c  f7fffffe          BL       __aeabi_memclr4
;;;890    	uint8 str1[9] = {0x55, 0xB1, 0x03, 0x08, 0x00, 0x01, 0x11, 0x0D, 0x0A};	// 播放
000010  a044              ADR      r0,|L10.292|
000012  e9d01200          LDRD     r1,r2,[r0,#0]
000016  6880              LDR      r0,[r0,#8]
000018  e9cd120f          STRD     r1,r2,[sp,#0x3c]
00001c  9011              STR      r0,[sp,#0x44]
;;;891    	uint8 str2[9] = {0x55, 0xB1, 0x03, 0x08, 0x00, 0x02, 0x12, 0x0D, 0x0A}; // 暂停
00001e  a044              ADR      r0,|L10.304|
000020  e9d02100          LDRD     r2,r1,[r0,#0]
000024  6880              LDR      r0,[r0,#8]
000026  e9cd210c          STRD     r2,r1,[sp,#0x30]
00002a  900e              STR      r0,[sp,#0x38]
;;;892    	uint8 str3[9] = {0x55, 0xB1, 0x03, 0x08, 0x00, 0x03, 0x13, 0x0D, 0x0A}; // 上一曲
00002c  a043              ADR      r0,|L10.316|
00002e  e9d02100          LDRD     r2,r1,[r0,#0]
000032  6880              LDR      r0,[r0,#8]
000034  e9cd2109          STRD     r2,r1,[sp,#0x24]
000038  900b              STR      r0,[sp,#0x2c]
;;;893    	uint8 str4[9] = {0x55, 0xB1, 0x03, 0x08, 0x00, 0x04, 0x14, 0x0D, 0x0A}; // 下一曲
00003a  a043              ADR      r0,|L10.328|
00003c  e9d02100          LDRD     r2,r1,[r0,#0]
000040  6880              LDR      r0,[r0,#8]
000042  e9cd2106          STRD     r2,r1,[sp,#0x18]
000046  9008              STR      r0,[sp,#0x20]
;;;894    	uint8 str5[9] = {0x55, 0xB1, 0x03, 0x08, 0x00, 0x08, 0x18, 0x0D, 0x0A}; // 音量+
000048  a042              ADR      r0,|L10.340|
00004a  e9d01200          LDRD     r1,r2,[r0,#0]
00004e  6880              LDR      r0,[r0,#8]
000050  e9cd1203          STRD     r1,r2,[sp,#0xc]
000054  9005              STR      r0,[sp,#0x14]
;;;895    	uint8 str6[9] = {0x55, 0xB1, 0x03, 0x08, 0x00, 0x09, 0x19, 0x0D, 0x0A}; // 音量-
000056  a042              ADR      r0,|L10.352|
000058  e9d02100          LDRD     r2,r1,[r0,#0]
00005c  6880              LDR      r0,[r0,#8]
00005e  e9cd2100          STRD     r2,r1,[sp,#0]
000062  9002              STR      r0,[sp,#8]
;;;896    	
;;;897    	// 无连接不发送
;;;898    	if (!PARAM_GetHelmetConnectState())
000064  4841              LDR      r0,|L10.364|
000066  f890020d          LDRB     r0,[r0,#0x20d]  ; paramCB
00006a  2800              CMP      r0,#0
00006c  d057              BEQ      |L10.286|
;;;899    	{
;;;900    		return;
;;;901    	}
;;;902    
;;;903    	sprintf((char *)Buff, (char *)"TTM:SEND=%s,", PARAM_GetHelmetMacBuff());
00006e  4a40              LDR      r2,|L10.368|
000070  a140              ADR      r1,|L10.372|
000072  a812              ADD      r0,sp,#0x48
000074  f7fffffe          BL       __2sprintf
;;;904    	Index = strlen((char *)Buff);
000078  a812              ADD      r0,sp,#0x48
00007a  f7fffffe          BL       strlen
00007e  b2c1              UXTB     r1,r0
000080  aa12              ADD      r2,sp,#0x48           ;889
;;;905    	
;;;906    	switch (param)
000082  2d0a              CMP      r5,#0xa
000084  d247              BCS      |L10.278|
000086  e8dff005          TBB      [pc,r5]
00008a  4605              DCB      0x46,0x05
00008c  101b2646          DCB      0x10,0x1b,0x26,0x46
000090  4646313c          DCB      0x46,0x46,0x31,0x3c
000094  a80f              ADD      r0,sp,#0x3c           ;890
                  |L10.150|
;;;907    	{
;;;908    		// 播放
;;;909    		case BLE_MUSIC_PLAY:
;;;910    			for (i = 0; i < sizeof(str1); i++)
;;;911    			{
;;;912    				Buff[Index++] = str1[i];
000096  460b              MOV      r3,r1
000098  5d05              LDRB     r5,[r0,r4]
00009a  1c49              ADDS     r1,r1,#1
00009c  b2c9              UXTB     r1,r1
00009e  54d5              STRB     r5,[r2,r3]
0000a0  1c64              ADDS     r4,r4,#1              ;910
0000a2  b2e4              UXTB     r4,r4                 ;910
0000a4  2c09              CMP      r4,#9                 ;910
0000a6  d3f6              BCC      |L10.150|
0000a8  e035              B        |L10.278|
0000aa  a80c              ADD      r0,sp,#0x30           ;891
                  |L10.172|
;;;913    			}
;;;914    			break;
;;;915    		
;;;916    		// 暂停	
;;;917    		case BLE_MUSIC_PAUSE:
;;;918    			for (i = 0; i < sizeof(str2); i++)
;;;919    			{
;;;920    				Buff[Index++] = str2[i];
0000ac  460b              MOV      r3,r1
0000ae  5d05              LDRB     r5,[r0,r4]
0000b0  1c49              ADDS     r1,r1,#1
0000b2  b2c9              UXTB     r1,r1
0000b4  54d5              STRB     r5,[r2,r3]
0000b6  1c64              ADDS     r4,r4,#1              ;918
0000b8  b2e4              UXTB     r4,r4                 ;918
0000ba  2c09              CMP      r4,#9                 ;918
0000bc  d3f6              BCC      |L10.172|
0000be  e02a              B        |L10.278|
0000c0  a809              ADD      r0,sp,#0x24           ;892
                  |L10.194|
;;;921    			}
;;;922    			break;
;;;923    		
;;;924    		// 上一曲	
;;;925    		case BLE_MUSIC_UP:
;;;926    			for (i = 0; i < sizeof(str3); i++)
;;;927    			{
;;;928    				Buff[Index++] = str3[i];
0000c2  460b              MOV      r3,r1
0000c4  5d05              LDRB     r5,[r0,r4]
0000c6  1c49              ADDS     r1,r1,#1
0000c8  b2c9              UXTB     r1,r1
0000ca  54d5              STRB     r5,[r2,r3]
0000cc  1c64              ADDS     r4,r4,#1              ;926
0000ce  b2e4              UXTB     r4,r4                 ;926
0000d0  2c09              CMP      r4,#9                 ;926
0000d2  d3f6              BCC      |L10.194|
0000d4  e01f              B        |L10.278|
0000d6  a806              ADD      r0,sp,#0x18           ;893
                  |L10.216|
;;;929    			}
;;;930    			break;
;;;931    		
;;;932    		// 下一曲			
;;;933    		case BLE_MUSIC_NEXT:
;;;934    			for (i = 0; i < sizeof(str4); i++)
;;;935    			{
;;;936    				Buff[Index++] = str4[i];
0000d8  460b              MOV      r3,r1
0000da  5d05              LDRB     r5,[r0,r4]
0000dc  1c49              ADDS     r1,r1,#1
0000de  b2c9              UXTB     r1,r1
0000e0  54d5              STRB     r5,[r2,r3]
0000e2  1c64              ADDS     r4,r4,#1              ;934
0000e4  b2e4              UXTB     r4,r4                 ;934
0000e6  2c09              CMP      r4,#9                 ;934
0000e8  d3f6              BCC      |L10.216|
0000ea  e014              B        |L10.278|
0000ec  ab03              ADD      r3,sp,#0xc            ;894
                  |L10.238|
;;;937    			}
;;;938    			break;
;;;939    		
;;;940    		// 音量+	
;;;941    		case BLE_MUSIC_ADD:
;;;942    			for (i = 0; i < sizeof(str5); i++)
;;;943    			{
;;;944    				Buff[Index++] = str5[i];
0000ee  4608              MOV      r0,r1
0000f0  5d1d              LDRB     r5,[r3,r4]
0000f2  1c49              ADDS     r1,r1,#1
0000f4  b2c9              UXTB     r1,r1
0000f6  5415              STRB     r5,[r2,r0]
0000f8  1c64              ADDS     r4,r4,#1              ;942
0000fa  b2e4              UXTB     r4,r4                 ;942
0000fc  2c09              CMP      r4,#9                 ;942
0000fe  d3f6              BCC      |L10.238|
000100  e009              B        |L10.278|
000102  4668              MOV      r0,sp                 ;895
                  |L10.260|
;;;945    			}
;;;946    			break;	
;;;947    		
;;;948    		// 音量-		
;;;949    		case BLE_MUSIC_DEC:
;;;950    			for (i = 0; i < sizeof(str6); i++)
;;;951    			{
;;;952    				Buff[Index++] = str6[i];
000104  460b              MOV      r3,r1
000106  5d05              LDRB     r5,[r0,r4]
000108  1c49              ADDS     r1,r1,#1
00010a  b2c9              UXTB     r1,r1
00010c  54d5              STRB     r5,[r2,r3]
00010e  1c64              ADDS     r4,r4,#1              ;950
000110  b2e4              UXTB     r4,r4                 ;950
000112  2c09              CMP      r4,#9                 ;950
000114  d3f6              BCC      |L10.260|
                  |L10.278|
;;;953    			}
;;;954    			break;	
;;;955    			
;;;956    		default:
;;;957    			break;
;;;958    		
;;;959    	}
;;;960    	
;;;961    	// 添加到队列发送
;;;962    	BLE_HOST_PROTOCOL_TxAddTtmCmd(Buff, Index, 0x00);
000116  2200              MOVS     r2,#0
000118  a812              ADD      r0,sp,#0x48
00011a  f7fffffe          BL       BLE_HOST_PROTOCOL_TxAddTtmCmd
                  |L10.286|
;;;963    }
00011e  b02b              ADD      sp,sp,#0xac
000120  bd30              POP      {r4,r5,pc}
;;;964    
                          ENDP

000122  0000              DCW      0x0000
                  |L10.292|
000124  55b10308          DCB      "U",177,3,"\b",0
000128  00      
000129  01110d0a          DCB      1,17,"\r\n",0
00012d  00      
00012e  00                DCB      0
00012f  00                DCB      0
                  |L10.304|
000130  55b10308          DCB      "U",177,3,"\b",0
000134  00      
000135  02120d0a          DCB      2,18,"\r\n",0
000139  00      
00013a  00                DCB      0
00013b  00                DCB      0
                  |L10.316|
00013c  55b10308          DCB      "U",177,3,"\b",0
000140  00      
000141  03130d0a          DCB      3,19,"\r\n",0
000145  00      
000146  00                DCB      0
000147  00                DCB      0
                  |L10.328|
000148  55b10308          DCB      "U",177,3,"\b",0
00014c  00      
00014d  04140d0a          DCB      4,20,"\r\n",0
000151  00      
000152  00                DCB      0
000153  00                DCB      0
                  |L10.340|
000154  55b10308          DCB      "U",177,3,"\b",0
000158  00      
000159  08180d0a          DCB      "\b",24,"\r\n",0
00015d  00      
00015e  00                DCB      0
00015f  00                DCB      0
                  |L10.352|
000160  55b10308          DCB      "U",177,3,"\b",0
000164  00      
000165  09190d0a          DCB      "\t",25,"\r\n",0
000169  00      
00016a  00                DCB      0
00016b  00                DCB      0
                  |L10.364|
                          DCD      paramCB
                  |L10.368|
                          DCD      paramCB+0x2ce
                  |L10.372|
000174  54544d3a          DCB      "TTM:SEND=%s,",0
000178  53454e44
00017c  3d25732c
000180  00      
000181  00                DCB      0
000182  00                DCB      0
000183  00                DCB      0

                          AREA ||i.BLE_HOST_PROTOCOL_SendCmdControlPhone||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                  BLE_HOST_PROTOCOL_SendCmdControlPhone PROC
;;;821    // 来电控制功能
;;;822    void BLE_HOST_PROTOCOL_SendCmdControlPhone(uint32 param)
000000  b530              PUSH     {r4,r5,lr}
;;;823    {
000002  b09f              SUB      sp,sp,#0x7c
000004  4605              MOV      r5,r0
;;;824    	uint8 i = 0;
000006  2400              MOVS     r4,#0
;;;825    	uint8 Index = 0;
;;;826    	uint8 Buff[100] = {0};
000008  2164              MOVS     r1,#0x64
00000a  a806              ADD      r0,sp,#0x18
00000c  f7fffffe          BL       __aeabi_memclr4
;;;827    	uint8 str1[9] = {0x55, 0xB1, 0x03, 0x07, 0x00, 0x01, 0x1E, 0x0D, 0x0A};		// 接听
000010  a11c              ADR      r1,|L11.132|
000012  e9d10200          LDRD     r0,r2,[r1,#0]
000016  6889              LDR      r1,[r1,#8]
000018  9003              STR      r0,[sp,#0xc]
00001a  e9cd2104          STRD     r2,r1,[sp,#0x10]
;;;828    	uint8 str2[9] = {0x55, 0xB1, 0x03, 0x07, 0x00, 0x03, 0x1C, 0x0D, 0x0A};		// 挂断
00001e  a11c              ADR      r1,|L11.144|
000020  e9d10200          LDRD     r0,r2,[r1,#0]
000024  6889              LDR      r1,[r1,#8]
000026  e9cd2101          STRD     r2,r1,[sp,#4]
00002a  9000              STR      r0,[sp,#0]
;;;829    
;;;830    	// 无连接不发送
;;;831    	if (!PARAM_GetHelmetConnectState())
00002c  481b              LDR      r0,|L11.156|
00002e  f890020d          LDRB     r0,[r0,#0x20d]  ; paramCB
000032  2800              CMP      r0,#0
000034  d019              BEQ      |L11.106|
;;;832    	{
;;;833    		return;
;;;834    	}
;;;835    
;;;836    	sprintf((char *)Buff, (char *)"TTM:SEND=%s,", PARAM_GetHelmetMacBuff());
000036  4a1a              LDR      r2,|L11.160|
000038  a11a              ADR      r1,|L11.164|
00003a  a806              ADD      r0,sp,#0x18
00003c  f7fffffe          BL       __2sprintf
;;;837    	Index = strlen((char *)Buff);
000040  a806              ADD      r0,sp,#0x18
000042  f7fffffe          BL       strlen
000046  b2c1              UXTB     r1,r0
000048  aa06              ADD      r2,sp,#0x18           ;826
;;;838    	
;;;839    	if (1 == param)
00004a  2d01              CMP      r5,#1
00004c  d00f              BEQ      |L11.110|
00004e  4668              MOV      r0,sp                 ;828
                  |L11.80|
;;;840    	{
;;;841    		for (i = 0; i < sizeof(str1); i++)
;;;842    		{
;;;843    			Buff[Index++] = str1[i];
;;;844    		}
;;;845    	}
;;;846    	else
;;;847    	{
;;;848    		for (i = 0; i < sizeof(str2); i++)
;;;849    		{
;;;850    			Buff[Index++] = str2[i];
000050  460b              MOV      r3,r1
000052  5d05              LDRB     r5,[r0,r4]
000054  1c49              ADDS     r1,r1,#1
000056  b2c9              UXTB     r1,r1
000058  54d5              STRB     r5,[r2,r3]
00005a  1c64              ADDS     r4,r4,#1              ;848
00005c  b2e4              UXTB     r4,r4                 ;848
00005e  2c09              CMP      r4,#9                 ;848
000060  d3f6              BCC      |L11.80|
                  |L11.98|
;;;851    		}
;;;852    	}
;;;853    
;;;854    	// 添加到队列发送
;;;855    	BLE_HOST_PROTOCOL_TxAddTtmCmd(Buff, Index, 0x00);
000062  2200              MOVS     r2,#0
000064  a806              ADD      r0,sp,#0x18
000066  f7fffffe          BL       BLE_HOST_PROTOCOL_TxAddTtmCmd
                  |L11.106|
;;;856    }
00006a  b01f              ADD      sp,sp,#0x7c
00006c  bd30              POP      {r4,r5,pc}
                  |L11.110|
00006e  a803              ADD      r0,sp,#0xc            ;827
                  |L11.112|
000070  460b              MOV      r3,r1                 ;843
000072  5d05              LDRB     r5,[r0,r4]            ;843
000074  1c49              ADDS     r1,r1,#1              ;843
000076  b2c9              UXTB     r1,r1                 ;843
000078  54d5              STRB     r5,[r2,r3]            ;843
00007a  1c64              ADDS     r4,r4,#1              ;841
00007c  b2e4              UXTB     r4,r4                 ;841
00007e  2c09              CMP      r4,#9                 ;841
000080  d3f6              BCC      |L11.112|
000082  e7ee              B        |L11.98|
;;;857    
                          ENDP

                  |L11.132|
000084  55b10307          DCB      "U",177,3,"\a",0
000088  00      
000089  011e0d0a          DCB      1,30,"\r\n",0
00008d  00      
00008e  00                DCB      0
00008f  00                DCB      0
                  |L11.144|
000090  55b10307          DCB      "U",177,3,"\a",0
000094  00      
000095  031c0d0a          DCB      3,28,"\r\n",0
000099  00      
00009a  00                DCB      0
00009b  00                DCB      0
                  |L11.156|
                          DCD      paramCB
                  |L11.160|
                          DCD      paramCB+0x2ce
                  |L11.164|
0000a4  54544d3a          DCB      "TTM:SEND=%s,",0
0000a8  53454e44
0000ac  3d25732c
0000b0  00      
0000b1  00                DCB      0
0000b2  00                DCB      0
0000b3  00                DCB      0

                          AREA ||i.BLE_HOST_PROTOCOL_SendCmdGetHeadInfoPhone||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                  BLE_HOST_PROTOCOL_SendCmdGetHeadInfoPhone PROC
;;;784    // 头盔信息查询
;;;785    void BLE_HOST_PROTOCOL_SendCmdGetHeadInfoPhone(uint32 param)
000000  b530              PUSH     {r4,r5,lr}
;;;786    {
000002  b09d              SUB      sp,sp,#0x74
000004  4605              MOV      r5,r0
;;;787    	uint8 i = 0;
000006  2400              MOVS     r4,#0
;;;788    	uint8 Index = 0;
;;;789    	uint8 Buff[100] = {0};
000008  2164              MOVS     r1,#0x64
00000a  a804              ADD      r0,sp,#0x10
00000c  f7fffffe          BL       __aeabi_memclr4
;;;790    	uint8 str1[7] = {0x55, 0xB2, 0x01, 0x01, 0x18, 0x0D, 0x0A};		// 获取状态组序号1
000010  a119              ADR      r1,|L12.120|
000012  c903              LDM      r1,{r0,r1}
000014  e9cd0102          STRD     r0,r1,[sp,#8]
;;;791    	uint8 str2[7] = {0x55, 0xB2, 0x01, 0x02, 0x1B, 0x0D, 0x0A};		// 获取状态组序号2
000018  a119              ADR      r1,|L12.128|
00001a  c903              LDM      r1,{r0,r1}
00001c  e9cd0100          STRD     r0,r1,[sp,#0]
;;;792    
;;;793    	// 无连接不发送
;;;794    	if (!PARAM_GetHelmetConnectState())
000020  4819              LDR      r0,|L12.136|
000022  f890020d          LDRB     r0,[r0,#0x20d]  ; paramCB
000026  2800              CMP      r0,#0
000028  d019              BEQ      |L12.94|
;;;795    	{
;;;796    		return;
;;;797    	}
;;;798    
;;;799    	sprintf((char *)Buff, (char *)"TTM:SEND=%s,", PARAM_GetHelmetMacBuff());
00002a  4a18              LDR      r2,|L12.140|
00002c  a118              ADR      r1,|L12.144|
00002e  a804              ADD      r0,sp,#0x10
000030  f7fffffe          BL       __2sprintf
;;;800    	Index = strlen((char *)Buff);
000034  a804              ADD      r0,sp,#0x10
000036  f7fffffe          BL       strlen
00003a  b2c1              UXTB     r1,r0
00003c  aa04              ADD      r2,sp,#0x10           ;789
;;;801    	
;;;802    	if (1 == param)
00003e  2d01              CMP      r5,#1
000040  d00f              BEQ      |L12.98|
000042  4668              MOV      r0,sp                 ;791
                  |L12.68|
;;;803    	{
;;;804    		for (i = 0; i < sizeof(str1); i++)
;;;805    		{
;;;806    			Buff[Index++] = str1[i];
;;;807    		}
;;;808    	}
;;;809    	else
;;;810    	{
;;;811    		for (i = 0; i < sizeof(str2); i++)
;;;812    		{
;;;813    			Buff[Index++] = str2[i];
000044  460b              MOV      r3,r1
000046  5d05              LDRB     r5,[r0,r4]
000048  1c49              ADDS     r1,r1,#1
00004a  b2c9              UXTB     r1,r1
00004c  54d5              STRB     r5,[r2,r3]
00004e  1c64              ADDS     r4,r4,#1              ;811
000050  b2e4              UXTB     r4,r4                 ;811
000052  2c07              CMP      r4,#7                 ;811
000054  d3f6              BCC      |L12.68|
                  |L12.86|
;;;814    		}
;;;815    	}
;;;816    
;;;817    	// 添加到队列发送
;;;818    	BLE_HOST_PROTOCOL_TxAddTtmCmd(Buff, Index, 0x00);
000056  2200              MOVS     r2,#0
000058  a804              ADD      r0,sp,#0x10
00005a  f7fffffe          BL       BLE_HOST_PROTOCOL_TxAddTtmCmd
                  |L12.94|
;;;819    }
00005e  b01d              ADD      sp,sp,#0x74
000060  bd30              POP      {r4,r5,pc}
                  |L12.98|
000062  a802              ADD      r0,sp,#8              ;790
                  |L12.100|
000064  460b              MOV      r3,r1                 ;806
000066  5d05              LDRB     r5,[r0,r4]            ;806
000068  1c49              ADDS     r1,r1,#1              ;806
00006a  b2c9              UXTB     r1,r1                 ;806
00006c  54d5              STRB     r5,[r2,r3]            ;806
00006e  1c64              ADDS     r4,r4,#1              ;804
000070  b2e4              UXTB     r4,r4                 ;804
000072  2c07              CMP      r4,#7                 ;804
000074  d3f6              BCC      |L12.100|
000076  e7ee              B        |L12.86|
;;;820    
                          ENDP

                  |L12.120|
000078  55b20101          DCB      "U",178,1,1,24,"\r\n",0
00007c  180d0a00
                  |L12.128|
000080  55b20102          DCB      "U",178,1,2,27,"\r\n",0
000084  1b0d0a00
                  |L12.136|
                          DCD      paramCB
                  |L12.140|
                          DCD      paramCB+0x2ce
                  |L12.144|
000090  54544d3a          DCB      "TTM:SEND=%s,",0
000094  53454e44
000098  3d25732c
00009c  00      
00009d  00                DCB      0
00009e  00                DCB      0
00009f  00                DCB      0

                          AREA ||i.BLE_HOST_PROTOCOL_SendCmdGetKey||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                  BLE_HOST_PROTOCOL_SendCmdGetKey PROC
;;;1039   // 电子锁控制
;;;1040   void BLE_HOST_PROTOCOL_SendCmdGetKey(uint32 param)
000000  b530              PUSH     {r4,r5,lr}
;;;1041   {
000002  b09f              SUB      sp,sp,#0x7c
;;;1042   	uint8 i = 0;
000004  2400              MOVS     r4,#0
;;;1043   	uint8 Index = 0;
;;;1044   	uint8 Buff[100] = {0};
000006  2164              MOVS     r1,#0x64
000008  a806              ADD      r0,sp,#0x18
00000a  f7fffffe          BL       __aeabi_memclr4
;;;1045   	uint8 str1[17] = {0xA3, 0xA4, 0x08, 0x50, 0x1E, 0x1F, 0x67, 0x51, 0x4A, 0x73, 0x55, 0x2B, 0x2E, 0x64, 0x00, 0x0D, 0x0A};
00000e  2214              MOVS     r2,#0x14
000010  a111              ADR      r1,|L13.88|
000012  a801              ADD      r0,sp,#4
000014  f7fffffe          BL       __aeabi_memcpy4
;;;1046   
;;;1047   	// 无连接不发送
;;;1048   	if (!PARAM_GetLockConnectState())
000018  4814              LDR      r0,|L13.108|
00001a  f890020f          LDRB     r0,[r0,#0x20f]  ; paramCB
00001e  2800              CMP      r0,#0
000020  d017              BEQ      |L13.82|
;;;1049   	{
;;;1050   		return;
;;;1051   	}
;;;1052   
;;;1053   	sprintf((char *)Buff, (char *)"TTM:SEND=%s,", PARAM_GetLockMacBuff());
000022  4a13              LDR      r2,|L13.112|
000024  a113              ADR      r1,|L13.116|
000026  a806              ADD      r0,sp,#0x18
000028  f7fffffe          BL       __2sprintf
;;;1054   	Index = strlen((char *)Buff);
00002c  a806              ADD      r0,sp,#0x18
00002e  f7fffffe          BL       strlen
000032  b2c1              UXTB     r1,r0
000034  aa06              ADD      r2,sp,#0x18           ;1044
000036  a801              ADD      r0,sp,#4              ;1045
                  |L13.56|
;;;1055   	
;;;1056   	for (i = 0; i < sizeof(str1); i++)
;;;1057   	{
;;;1058   		Buff[Index++] = str1[i];
000038  460b              MOV      r3,r1
00003a  5d05              LDRB     r5,[r0,r4]
00003c  1c49              ADDS     r1,r1,#1
00003e  b2c9              UXTB     r1,r1
000040  54d5              STRB     r5,[r2,r3]
000042  1c64              ADDS     r4,r4,#1              ;1056
000044  b2e4              UXTB     r4,r4                 ;1056
000046  2c11              CMP      r4,#0x11              ;1056
000048  d3f6              BCC      |L13.56|
;;;1059   	}
;;;1060   	
;;;1061   	// 添加到队列发送
;;;1062   	BLE_HOST_PROTOCOL_TxAddTtmCmd(Buff, Index, BLE_OUTFIT_LOCK_ID);
00004a  2202              MOVS     r2,#2
00004c  a806              ADD      r0,sp,#0x18
00004e  f7fffffe          BL       BLE_HOST_PROTOCOL_TxAddTtmCmd
                  |L13.82|
;;;1063   }
000052  b01f              ADD      sp,sp,#0x7c
000054  bd30              POP      {r4,r5,pc}
;;;1064   
                          ENDP

000056  0000              DCW      0x0000
                  |L13.88|
000058  a3a40850          DCB      163,164,"\bP",30,31,"gQJsU+.d",0
00005c  1e1f6751
000060  4a73552b
000064  2e6400  
000067  0d0a00            DCB      "\r\n",0
00006a  00                DCB      0
00006b  00                DCB      0
                  |L13.108|
                          DCD      paramCB
                  |L13.112|
                          DCD      paramCB+0x2e3
                  |L13.116|
000074  54544d3a          DCB      "TTM:SEND=%s,",0
000078  53454e44
00007c  3d25732c
000080  00      
000081  00                DCB      0
000082  00                DCB      0
000083  00                DCB      0

                          AREA ||i.BLE_HOST_PROTOCOL_SendCmdLeftTurnLight||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                  BLE_HOST_PROTOCOL_SendCmdLeftTurnLight PROC
;;;965    // 左转向灯控制
;;;966    void BLE_HOST_PROTOCOL_SendCmdLeftTurnLight(uint32 param)
000000  b530              PUSH     {r4,r5,lr}
;;;967    {
000002  b09f              SUB      sp,sp,#0x7c
000004  4605              MOV      r5,r0
;;;968    	uint8 i = 0;
000006  2400              MOVS     r4,#0
;;;969    	uint8 Index = 0;
;;;970    	uint8 Buff[100] = {0};
000008  2164              MOVS     r1,#0x64
00000a  a806              ADD      r0,sp,#0x18
00000c  f7fffffe          BL       __aeabi_memclr4
;;;971    	uint8 str1[9] = {0x55, 0xB1, 0x03, 0x01, 0x00, 0x01, 0x18, 0x0D, 0x0A};
000010  a11c              ADR      r1,|L14.132|
000012  e9d10200          LDRD     r0,r2,[r1,#0]
000016  6889              LDR      r1,[r1,#8]
000018  9003              STR      r0,[sp,#0xc]
00001a  e9cd2104          STRD     r2,r1,[sp,#0x10]
;;;972    	uint8 str2[9] = {0x55, 0xB1, 0x03, 0x01, 0x00, 0x00, 0x19, 0x0D, 0x0A};
00001e  a11c              ADR      r1,|L14.144|
000020  e9d10200          LDRD     r0,r2,[r1,#0]
000024  6889              LDR      r1,[r1,#8]
000026  e9cd2101          STRD     r2,r1,[sp,#4]
00002a  9000              STR      r0,[sp,#0]
;;;973    
;;;974    	// 无连接不发送
;;;975    	if (!PARAM_GetHelmetConnectState())
00002c  481b              LDR      r0,|L14.156|
00002e  f890020d          LDRB     r0,[r0,#0x20d]  ; paramCB
000032  2800              CMP      r0,#0
000034  d023              BEQ      |L14.126|
;;;976    	{
;;;977    		return;
;;;978    	}
;;;979    
;;;980    	sprintf((char *)Buff, (char *)"TTM:SEND=%s,", PARAM_GetHelmetMacBuff());
000036  4a1a              LDR      r2,|L14.160|
000038  a11a              ADR      r1,|L14.164|
00003a  a806              ADD      r0,sp,#0x18
00003c  f7fffffe          BL       __2sprintf
;;;981    	Index = strlen((char *)Buff);
000040  a806              ADD      r0,sp,#0x18
000042  f7fffffe          BL       strlen
000046  b2c1              UXTB     r1,r0
000048  aa06              ADD      r2,sp,#0x18           ;970
;;;982    	
;;;983    	if (param)
00004a  b155              CBZ      r5,|L14.98|
00004c  a803              ADD      r0,sp,#0xc            ;971
                  |L14.78|
;;;984    	{
;;;985    		for (i = 0; i < sizeof(str1); i++)
;;;986    		{
;;;987    			Buff[Index++] = str1[i];
00004e  460b              MOV      r3,r1
000050  5d05              LDRB     r5,[r0,r4]
000052  1c49              ADDS     r1,r1,#1
000054  b2c9              UXTB     r1,r1
000056  54d5              STRB     r5,[r2,r3]
000058  1c64              ADDS     r4,r4,#1              ;985
00005a  b2e4              UXTB     r4,r4                 ;985
00005c  2c09              CMP      r4,#9                 ;985
00005e  d3f6              BCC      |L14.78|
000060  e009              B        |L14.118|
                  |L14.98|
000062  4668              MOV      r0,sp                 ;972
                  |L14.100|
;;;988    		}
;;;989    	}
;;;990    	else
;;;991    	{
;;;992    		for (i = 0; i < sizeof(str2); i++)
;;;993    		{
;;;994    			Buff[Index++] = str2[i];
000064  460b              MOV      r3,r1
000066  5d05              LDRB     r5,[r0,r4]
000068  1c49              ADDS     r1,r1,#1
00006a  b2c9              UXTB     r1,r1
00006c  54d5              STRB     r5,[r2,r3]
00006e  1c64              ADDS     r4,r4,#1              ;992
000070  b2e4              UXTB     r4,r4                 ;992
000072  2c09              CMP      r4,#9                 ;992
000074  d3f6              BCC      |L14.100|
                  |L14.118|
;;;995    		}
;;;996    	}
;;;997    
;;;998    	// 添加到队列发送
;;;999    	BLE_HOST_PROTOCOL_TxAddTtmCmd(Buff, Index, 0x00);
000076  2200              MOVS     r2,#0
000078  a806              ADD      r0,sp,#0x18
00007a  f7fffffe          BL       BLE_HOST_PROTOCOL_TxAddTtmCmd
                  |L14.126|
;;;1000   }
00007e  b01f              ADD      sp,sp,#0x7c
000080  bd30              POP      {r4,r5,pc}
;;;1001   
                          ENDP

000082  0000              DCW      0x0000
                  |L14.132|
000084  55b10301          DCB      "U",177,3,1,0
000088  00      
000089  01180d0a          DCB      1,24,"\r\n",0
00008d  00      
00008e  00                DCB      0
00008f  00                DCB      0
                  |L14.144|
000090  55b10301          DCB      "U",177,3,1,0
000094  00      
000095  00                DCB      0
000096  190d0a00          DCB      25,"\r\n",0
00009a  00                DCB      0
00009b  00                DCB      0
                  |L14.156|
                          DCD      paramCB
                  |L14.160|
                          DCD      paramCB+0x2ce
                  |L14.164|
0000a4  54544d3a          DCB      "TTM:SEND=%s,",0
0000a8  53454e44
0000ac  3d25732c
0000b0  00      
0000b1  00                DCB      0
0000b2  00                DCB      0
0000b3  00                DCB      0

                          AREA ||i.BLE_HOST_PROTOCOL_SendCmdLockOpen||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                  BLE_HOST_PROTOCOL_SendCmdLockOpen PROC
;;;1065   // 打开电子锁
;;;1066   void BLE_HOST_PROTOCOL_SendCmdLockOpen(uint32 param)
000000  b570              PUSH     {r4-r6,lr}
;;;1067   {
000002  b0b2              SUB      sp,sp,#0xc8
;;;1068   	uint8 i = 0;
000004  2400              MOVS     r4,#0
;;;1069   	uint8 Index = 0;
;;;1070   	uint8 Buff[100] = {0};
000006  2164              MOVS     r1,#0x64
000008  a819              ADD      r0,sp,#0x64
00000a  f7fffffe          BL       __aeabi_memclr4
;;;1071   	uint8 str1[100] = {0};
00000e  2164              MOVS     r1,#0x64
000010  4668              MOV      r0,sp
000012  f7fffffe          BL       __aeabi_memclr4
;;;1072   	uint8 length = 0;
;;;1073   		
;;;1074   	// 无连接不发送
;;;1075   	if (!PARAM_GetLockConnectState())
000016  4e2f              LDR      r6,|L15.212|
000018  f896020f          LDRB     r0,[r6,#0x20f]  ; paramCB
00001c  2800              CMP      r0,#0
00001e  d057              BEQ      |L15.208|
;;;1076   	{
;;;1077   		return;
;;;1078   	}
;;;1079   
;;;1080   	sprintf((char *)Buff, (char *)"TTM:SEND=%s,", PARAM_GetLockMacBuff());
000020  f20622e3          ADD      r2,r6,#0x2e3
000024  a12c              ADR      r1,|L15.216|
000026  a819              ADD      r0,sp,#0x64
000028  f7fffffe          BL       __2sprintf
;;;1081   	Index = strlen((char *)Buff);
00002c  a819              ADD      r0,sp,#0x64
00002e  f7fffffe          BL       strlen
000032  b2c5              UXTB     r5,r0
;;;1082   
;;;1083   	BLE_PROTOCOL1_TxAddData(BLE_PROTOCOL1_CMD_HEAD);
000034  20a3              MOVS     r0,#0xa3
000036  f7fffffe          BL       BLE_PROTOCOL1_TxAddData
;;;1084   	BLE_PROTOCOL1_TxAddData(BLE_PROTOCOL1_CMD_HEAD1);
00003a  20a4              MOVS     r0,#0xa4
00003c  f7fffffe          BL       BLE_PROTOCOL1_TxAddData
;;;1085   	BLE_PROTOCOL1_TxAddData(0x00);								// 长度
000040  2000              MOVS     r0,#0
000042  f7fffffe          BL       BLE_PROTOCOL1_TxAddData
;;;1086   	BLE_PROTOCOL1_TxAddData(0x1E);								// 随机数
000046  201e              MOVS     r0,#0x1e
000048  f7fffffe          BL       BLE_PROTOCOL1_TxAddData
;;;1087   	BLE_PROTOCOL1_TxAddData(PARAM_GetLockKey());				// 秘钥
00004c  f8960211          LDRB     r0,[r6,#0x211]  ; paramCB
000050  f7fffffe          BL       BLE_PROTOCOL1_TxAddData
;;;1088   	BLE_PROTOCOL1_TxAddData(BLE_PROTOCOL1_OPEN_LOCK_CMD);		// 开锁
000054  2005              MOVS     r0,#5
000056  f7fffffe          BL       BLE_PROTOCOL1_TxAddData
;;;1089   	BLE_PROTOCOL1_TxAddData(0x01);								// 数据
00005a  2001              MOVS     r0,#1
00005c  f7fffffe          BL       BLE_PROTOCOL1_TxAddData
;;;1090   	BLE_PROTOCOL1_TxAddData(0x00);
000060  2000              MOVS     r0,#0
000062  f7fffffe          BL       BLE_PROTOCOL1_TxAddData
;;;1091   	BLE_PROTOCOL1_TxAddData(0x00);
000066  2000              MOVS     r0,#0
000068  f7fffffe          BL       BLE_PROTOCOL1_TxAddData
;;;1092   	BLE_PROTOCOL1_TxAddData(0x00);
00006c  2000              MOVS     r0,#0
00006e  f7fffffe          BL       BLE_PROTOCOL1_TxAddData
;;;1093   	BLE_PROTOCOL1_TxAddData(0x01);
000072  2001              MOVS     r0,#1
000074  f7fffffe          BL       BLE_PROTOCOL1_TxAddData
;;;1094   	BLE_PROTOCOL1_TxAddData(0x00);
000078  2000              MOVS     r0,#0
00007a  f7fffffe          BL       BLE_PROTOCOL1_TxAddData
;;;1095   	BLE_PROTOCOL1_TxAddData(0x00);
00007e  2000              MOVS     r0,#0
000080  f7fffffe          BL       BLE_PROTOCOL1_TxAddData
;;;1096   	BLE_PROTOCOL1_TxAddData(0x00);
000084  2000              MOVS     r0,#0
000086  f7fffffe          BL       BLE_PROTOCOL1_TxAddData
;;;1097   	BLE_PROTOCOL1_TxAddData(0x01);
00008a  2001              MOVS     r0,#1
00008c  f7fffffe          BL       BLE_PROTOCOL1_TxAddData
;;;1098   	BLE_PROTOCOL1_TxAddData(0x00);
000090  2000              MOVS     r0,#0
000092  f7fffffe          BL       BLE_PROTOCOL1_TxAddData
;;;1099   	
;;;1100   	length = BLE_PROTOCOL1_TxAddFrame(str1);
000096  4668              MOV      r0,sp
000098  f7fffffe          BL       BLE_PROTOCOL1_TxAddFrame
;;;1101   	
;;;1102   	str1[length++] = 0x0D;
00009c  230d              MOVS     r3,#0xd
00009e  1c41              ADDS     r1,r0,#1
0000a0  b2ca              UXTB     r2,r1
0000a2  4669              MOV      r1,sp
0000a4  f80d3000          STRB     r3,[sp,r0]
;;;1103   	str1[length++] = 0x0A;
0000a8  230a              MOVS     r3,#0xa
0000aa  1c50              ADDS     r0,r2,#1
0000ac  b2c0              UXTB     r0,r0
0000ae  548b              STRB     r3,[r1,r2]
0000b0  aa19              ADD      r2,sp,#0x64           ;1070
;;;1104   	
;;;1105   	for (i = 0; i < length; i++)
0000b2  e006              B        |L15.194|
                  |L15.180|
;;;1106   	{
;;;1107   		Buff[Index++] = str1[i];
0000b4  462b              MOV      r3,r5
0000b6  5d0e              LDRB     r6,[r1,r4]
0000b8  1c6d              ADDS     r5,r5,#1
0000ba  b2ed              UXTB     r5,r5
0000bc  54d6              STRB     r6,[r2,r3]
0000be  1c64              ADDS     r4,r4,#1              ;1105
0000c0  b2e4              UXTB     r4,r4                 ;1105
                  |L15.194|
0000c2  4284              CMP      r4,r0                 ;1105
0000c4  d3f6              BCC      |L15.180|
;;;1108   	}
;;;1109   	
;;;1110   	// 添加到队列发送
;;;1111   	BLE_HOST_PROTOCOL_TxAddTtmCmd(Buff, Index, BLE_OUTFIT_LOCK_ID);
0000c6  2202              MOVS     r2,#2
0000c8  4629              MOV      r1,r5
0000ca  a819              ADD      r0,sp,#0x64
0000cc  f7fffffe          BL       BLE_HOST_PROTOCOL_TxAddTtmCmd
                  |L15.208|
;;;1112   }
0000d0  b032              ADD      sp,sp,#0xc8
0000d2  bd70              POP      {r4-r6,pc}
;;;1113   
                          ENDP

                  |L15.212|
                          DCD      paramCB
                  |L15.216|
0000d8  54544d3a          DCB      "TTM:SEND=%s,",0
0000dc  53454e44
0000e0  3d25732c
0000e4  00      
0000e5  00                DCB      0
0000e6  00                DCB      0
0000e7  00                DCB      0

                          AREA ||i.BLE_HOST_PROTOCOL_SendCmdRightTurnLight||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                  BLE_HOST_PROTOCOL_SendCmdRightTurnLight PROC
;;;1002   // 右转向灯控制
;;;1003   void BLE_HOST_PROTOCOL_SendCmdRightTurnLight(uint32 param)
000000  b530              PUSH     {r4,r5,lr}
;;;1004   {
000002  b09f              SUB      sp,sp,#0x7c
000004  4605              MOV      r5,r0
;;;1005   	uint8 i = 0;
000006  2400              MOVS     r4,#0
;;;1006   	uint8 Index = 0;
;;;1007   	uint8 Buff[100] = {0};
000008  2164              MOVS     r1,#0x64
00000a  a806              ADD      r0,sp,#0x18
00000c  f7fffffe          BL       __aeabi_memclr4
;;;1008   	uint8 str1[9] = {0x55, 0xB1, 0x03, 0x01, 0x00, 0x02, 0x1B, 0x0D, 0x0A};
000010  a11c              ADR      r1,|L16.132|
000012  e9d10200          LDRD     r0,r2,[r1,#0]
000016  6889              LDR      r1,[r1,#8]
000018  9003              STR      r0,[sp,#0xc]
00001a  e9cd2104          STRD     r2,r1,[sp,#0x10]
;;;1009   	uint8 str2[9] = {0x55, 0xB1, 0x03, 0x01, 0x00, 0x00, 0x19, 0x0D, 0x0A};
00001e  a11c              ADR      r1,|L16.144|
000020  e9d10200          LDRD     r0,r2,[r1,#0]
000024  6889              LDR      r1,[r1,#8]
000026  e9cd2101          STRD     r2,r1,[sp,#4]
00002a  9000              STR      r0,[sp,#0]
;;;1010   
;;;1011   	// 无连接不发送
;;;1012   	if (!PARAM_GetHelmetConnectState())
00002c  481b              LDR      r0,|L16.156|
00002e  f890020d          LDRB     r0,[r0,#0x20d]  ; paramCB
000032  2800              CMP      r0,#0
000034  d023              BEQ      |L16.126|
;;;1013   	{
;;;1014   		return;
;;;1015   	}
;;;1016   
;;;1017   	sprintf((char *)Buff, (char *)"TTM:SEND=%s,", PARAM_GetHelmetMacBuff());
000036  4a1a              LDR      r2,|L16.160|
000038  a11a              ADR      r1,|L16.164|
00003a  a806              ADD      r0,sp,#0x18
00003c  f7fffffe          BL       __2sprintf
;;;1018   	Index = strlen((char *)Buff);
000040  a806              ADD      r0,sp,#0x18
000042  f7fffffe          BL       strlen
000046  b2c1              UXTB     r1,r0
000048  aa06              ADD      r2,sp,#0x18           ;1007
;;;1019   	
;;;1020   	if (param)
00004a  b155              CBZ      r5,|L16.98|
00004c  a803              ADD      r0,sp,#0xc            ;1008
                  |L16.78|
;;;1021   	{
;;;1022   		for (i = 0; i < sizeof(str1); i++)
;;;1023   		{
;;;1024   			Buff[Index++] = str1[i];
00004e  460b              MOV      r3,r1
000050  5d05              LDRB     r5,[r0,r4]
000052  1c49              ADDS     r1,r1,#1
000054  b2c9              UXTB     r1,r1
000056  54d5              STRB     r5,[r2,r3]
000058  1c64              ADDS     r4,r4,#1              ;1022
00005a  b2e4              UXTB     r4,r4                 ;1022
00005c  2c09              CMP      r4,#9                 ;1022
00005e  d3f6              BCC      |L16.78|
000060  e009              B        |L16.118|
                  |L16.98|
000062  4668              MOV      r0,sp                 ;1009
                  |L16.100|
;;;1025   		}
;;;1026   	}
;;;1027   	else
;;;1028   	{
;;;1029   		for (i = 0; i < sizeof(str2); i++)
;;;1030   		{
;;;1031   			Buff[Index++] = str2[i];
000064  460b              MOV      r3,r1
000066  5d05              LDRB     r5,[r0,r4]
000068  1c49              ADDS     r1,r1,#1
00006a  b2c9              UXTB     r1,r1
00006c  54d5              STRB     r5,[r2,r3]
00006e  1c64              ADDS     r4,r4,#1              ;1029
000070  b2e4              UXTB     r4,r4                 ;1029
000072  2c09              CMP      r4,#9                 ;1029
000074  d3f6              BCC      |L16.100|
                  |L16.118|
;;;1032   		}
;;;1033   	}
;;;1034   
;;;1035   	// 添加到队列发送
;;;1036   	BLE_HOST_PROTOCOL_TxAddTtmCmd(Buff, Index, 0x00);
000076  2200              MOVS     r2,#0
000078  a806              ADD      r0,sp,#0x18
00007a  f7fffffe          BL       BLE_HOST_PROTOCOL_TxAddTtmCmd
                  |L16.126|
;;;1037   }
00007e  b01f              ADD      sp,sp,#0x7c
000080  bd30              POP      {r4,r5,pc}
;;;1038   
                          ENDP

000082  0000              DCW      0x0000
                  |L16.132|
000084  55b10301          DCB      "U",177,3,1,0
000088  00      
000089  021b0d0a          DCB      2,27,"\r\n",0
00008d  00      
00008e  00                DCB      0
00008f  00                DCB      0
                  |L16.144|
000090  55b10301          DCB      "U",177,3,1,0
000094  00      
000095  00                DCB      0
000096  190d0a00          DCB      25,"\r\n",0
00009a  00                DCB      0
00009b  00                DCB      0
                  |L16.156|
                          DCD      paramCB
                  |L16.160|
                          DCD      paramCB+0x2ce
                  |L16.164|
0000a4  54544d3a          DCB      "TTM:SEND=%s,",0
0000a8  53454e44
0000ac  3d25732c
0000b0  00      
0000b1  00                DCB      0
0000b2  00                DCB      0
0000b3  00                DCB      0

                          AREA ||i.BLE_HOST_PROTOCOL_SendCmdToHeadConnectState||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                  BLE_HOST_PROTOCOL_SendCmdToHeadConnectState PROC
;;;858    // 连接设备后第一时间发给头盔
;;;859    void BLE_HOST_PROTOCOL_SendCmdToHeadConnectState(uint32 param)
000000  b530              PUSH     {r4,r5,lr}
;;;860    {
000002  b09d              SUB      sp,sp,#0x74
;;;861    	uint8 i = 0;
000004  2400              MOVS     r4,#0
;;;862    	uint8 Index = 0;
;;;863    	uint8 Buff[100] = {0};
000006  2164              MOVS     r1,#0x64
000008  a804              ADD      r0,sp,#0x10
00000a  f7fffffe          BL       __aeabi_memclr4
;;;864    	uint8 str1[9] = {0x55, 0xB1, 0x03, 0x09, 0x00, 0x02, 0x13, 0x0D, 0x0A};		// 仪表
00000e  a013              ADR      r0,|L17.92|
000010  e9d01200          LDRD     r1,r2,[r0,#0]
000014  6880              LDR      r0,[r0,#8]
000016  e9cd1201          STRD     r1,r2,[sp,#4]
00001a  9003              STR      r0,[sp,#0xc]
;;;865    	
;;;866    	// 无连接不发送
;;;867    	if (!PARAM_GetHelmetConnectState())
00001c  4812              LDR      r0,|L17.104|
00001e  f890020d          LDRB     r0,[r0,#0x20d]  ; paramCB
000022  2800              CMP      r0,#0
000024  d017              BEQ      |L17.86|
;;;868    	{
;;;869    		return;
;;;870    	}
;;;871    
;;;872    	sprintf((char *)Buff, (char *)"TTM:SEND=%s,", PARAM_GetHelmetMacBuff());
000026  4a11              LDR      r2,|L17.108|
000028  a111              ADR      r1,|L17.112|
00002a  a804              ADD      r0,sp,#0x10
00002c  f7fffffe          BL       __2sprintf
;;;873    	Index = strlen((char *)Buff);
000030  a804              ADD      r0,sp,#0x10
000032  f7fffffe          BL       strlen
000036  b2c1              UXTB     r1,r0
000038  a804              ADD      r0,sp,#0x10           ;863
00003a  aa01              ADD      r2,sp,#4              ;864
                  |L17.60|
;;;874    	
;;;875    	for (i = 0; i < sizeof(str1); i++)
;;;876    	{
;;;877    		Buff[Index++] = str1[i];
00003c  460b              MOV      r3,r1
00003e  5d15              LDRB     r5,[r2,r4]
000040  1c49              ADDS     r1,r1,#1
000042  b2c9              UXTB     r1,r1
000044  54c5              STRB     r5,[r0,r3]
000046  1c64              ADDS     r4,r4,#1              ;875
000048  b2e4              UXTB     r4,r4                 ;875
00004a  2c09              CMP      r4,#9                 ;875
00004c  d3f6              BCC      |L17.60|
;;;878    	}
;;;879    
;;;880    	// 添加到队列发送
;;;881    	BLE_HOST_PROTOCOL_TxAddTtmCmd(Buff, Index, 0x00);
00004e  2200              MOVS     r2,#0
000050  a804              ADD      r0,sp,#0x10
000052  f7fffffe          BL       BLE_HOST_PROTOCOL_TxAddTtmCmd
                  |L17.86|
;;;882    }
000056  b01d              ADD      sp,sp,#0x74
000058  bd30              POP      {r4,r5,pc}
;;;883    
                          ENDP

00005a  0000              DCW      0x0000
                  |L17.92|
00005c  55b10309          DCB      "U",177,3,"\t",0
000060  00      
000061  02130d0a          DCB      2,19,"\r\n",0
000065  00      
000066  00                DCB      0
000067  00                DCB      0
                  |L17.104|
                          DCD      paramCB
                  |L17.108|
                          DCD      paramCB+0x2ce
                  |L17.112|
000070  54544d3a          DCB      "TTM:SEND=%s,",0
000074  53454e44
000078  3d25732c
00007c  00      
00007d  00                DCB      0
00007e  00                DCB      0
00007f  00                DCB      0

                          AREA ||i.BLE_HOST_PROTOCOL_StartTimeoutCheckTask||, CODE, READONLY, ALIGN=1

                  BLE_HOST_PROTOCOL_StartTimeoutCheckTask PROC
;;;71     // 启动通讯超时判断任务
;;;72     void BLE_HOST_PROTOCOL_StartTimeoutCheckTask(void)
000000  4770              BX       lr
;;;73     {
;;;74     }
;;;75     
                          ENDP


                          AREA ||i.BLE_HOST_PROTOCOL_TxAddData||, CODE, READONLY, ALIGN=2

                  BLE_HOST_PROTOCOL_TxAddData PROC
;;;109    // 向发送命令帧队列中添加数据
;;;110    void BLE_HOST_PROTOCOL_TxAddData(uint8 data)
000000  b530              PUSH     {r4,r5,lr}
;;;111    {
;;;112    	uint16 head = bleHostProtocolCB.tx.head;
000002  4910              LDR      r1,|L19.68|
000004  f8b144e2          LDRH     r4,[r1,#0x4e2]  ; bleHostProtocolCB
;;;113    	uint16 end =  bleHostProtocolCB.tx.end;
000008  f8b124e4          LDRH     r2,[r1,#0x4e4]  ; bleHostProtocolCB
;;;114    	BLE_HOST_PROTOCOL_TX_CMD_FRAME* pCmdFrame = &bleHostProtocolCB.tx.cmdQueue[bleHostProtocolCB.tx.end];
00000c  eb020382          ADD      r3,r2,r2,LSL #2
000010  eb0303c2          ADD      r3,r3,r2,LSL #3
000014  eb0101c3          ADD      r1,r1,r3,LSL #3
000018  f20121da          ADD      r1,r1,#0x2da
;;;115    
;;;116    	// 发送缓冲区已满，不予接收
;;;117    	if((end + 1) % BLE_HOST_PROTOCOL_TX_QUEUE_SIZE == head)
00001c  1c52              ADDS     r2,r2,#1
00001e  2305              MOVS     r3,#5
000020  fbb2f5f3          UDIV     r5,r2,r3
000024  fb032215          MLS      r2,r3,r5,r2
000028  42a2              CMP      r2,r4
00002a  d009              BEQ      |L19.64|
;;;118    	{
;;;119    		return;
;;;120    	}
;;;121    	
;;;122    	// 队尾命令帧已满，退出
;;;123    	if(pCmdFrame->length >= BLE_HOST_PROTOCOL_TX_CMD_FRAME_LENGTH_MAX)
00002c  f8b12066          LDRH     r2,[r1,#0x66]
000030  2a64              CMP      r2,#0x64
000032  d205              BCS      |L19.64|
;;;124    	{
;;;125    		return;
;;;126    	}
;;;127    
;;;128    	// 数据添加到帧末尾，并更新帧长度
;;;129    	pCmdFrame->buff[pCmdFrame->length] = data;
000034  1c8b              ADDS     r3,r1,#2
000036  54d0              STRB     r0,[r2,r3]
;;;130    	pCmdFrame->length ++;
000038  f8310f66          LDRH     r0,[r1,#0x66]!
00003c  1c40              ADDS     r0,r0,#1
00003e  8008              STRH     r0,[r1,#0]
                  |L19.64|
;;;131    }
000040  bd30              POP      {r4,r5,pc}
;;;132    
                          ENDP

000042  0000              DCW      0x0000
                  |L19.68|
                          DCD      ||.bss||

                          AREA ||i.BLE_HOST_PROTOCOL_TxAddFrame||, CODE, READONLY, ALIGN=2

                  BLE_HOST_PROTOCOL_TxAddFrame PROC
;;;133    // 确认添加命令帧，即承认之前填充的数据为命令帧，将其添加到发送队列中，由main进行调度发送，本函数内会自动校正命令长度，并添加校验码
;;;134    void BLE_HOST_PROTOCOL_TxAddFrame(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;135    {
;;;136    	uint16 cc = 0;
000002  2300              MOVS     r3,#0
;;;137    	uint16 i = 0;
000004  2100              MOVS     r1,#0
;;;138    	uint16 head = bleHostProtocolCB.tx.head;
000006  4d1d              LDR      r5,|L20.124|
000008  f8b574e2          LDRH     r7,[r5,#0x4e2]  ; bleHostProtocolCB
;;;139    	uint16 end  = bleHostProtocolCB.tx.end;
00000c  f8b544e4          LDRH     r4,[r5,#0x4e4]  ; bleHostProtocolCB
;;;140    	BLE_HOST_PROTOCOL_TX_CMD_FRAME* pCmdFrame = &bleHostProtocolCB.tx.cmdQueue[bleHostProtocolCB.tx.end];
000010  eb040084          ADD      r0,r4,r4,LSL #2
000014  eb0000c4          ADD      r0,r0,r4,LSL #3
000018  eb0500c0          ADD      r0,r5,r0,LSL #3
00001c  f20020da          ADD      r0,r0,#0x2da
;;;141    	uint16 length = pCmdFrame->length;
000020  f8b02066          LDRH     r2,[r0,#0x66]
;;;142    
;;;143    	// 发送缓冲区已满，不予接收
;;;144    	if((end + 1) % BLE_HOST_PROTOCOL_TX_QUEUE_SIZE == head)
000024  1c64              ADDS     r4,r4,#1
000026  2605              MOVS     r6,#5
000028  fbb4fcf6          UDIV     r12,r4,r6
00002c  fb06441c          MLS      r4,r6,r12,r4
000030  42bc              CMP      r4,r7
000032  d003              BEQ      |L20.60|
;;;145    	{
;;;146    		return;
;;;147    	}
;;;148    	
;;;149    	// 命令帧长度不足，清除已填充的数据，退出
;;;150    	if(BLE_HOST_PROTOCOL_CMD_FRAME_LENGTH_MIN-1 > length)	// 减去"校验和"1个字节
000034  2a03              CMP      r2,#3
000036  d202              BCS      |L20.62|
;;;151    	{
;;;152    		pCmdFrame->length = 0;
000038  f8a01066          STRH     r1,[r0,#0x66]
                  |L20.60|
;;;153    		
;;;154    		return;
;;;155    	}
;;;156    
;;;157    	// 队尾命令帧已满，退出
;;;158    	if(length >= BLE_HOST_PROTOCOL_TX_CMD_FRAME_LENGTH_MAX)
;;;159    	{
;;;160    		return;
;;;161    	}
;;;162    
;;;163    	// 重新设置数据长度，系统在准备数据时，填充的"数据长度"可以为任意值，并且不需要添加校验码，在这里重新设置为正确的值
;;;164    	pCmdFrame->buff[BLE_HOST_PROTOCOL_CMD_LENGTH_INDEX] = length - 3;	// 重设数据长度
;;;165    
;;;166    	for(i=0; i<length; i++)
;;;167    	{
;;;168    		cc ^= pCmdFrame->buff[i];
;;;169    	}
;;;170    	pCmdFrame->buff[pCmdFrame->length++] = ~cc ;
;;;171    
;;;172    	bleHostProtocolCB.tx.end ++;
;;;173    	bleHostProtocolCB.tx.end %= BLE_HOST_PROTOCOL_TX_QUEUE_SIZE;
;;;174    	//pCB->tx.cmdQueue[pCB->tx.end].length = 0;   //2015.12.2修改
;;;175    }
00003c  bdf0              POP      {r4-r7,pc}
                  |L20.62|
00003e  2a64              CMP      r2,#0x64              ;158
000040  d2fc              BCS      |L20.60|
000042  1ed4              SUBS     r4,r2,#3              ;164
000044  7104              STRB     r4,[r0,#4]            ;164
000046  e004              B        |L20.82|
                  |L20.72|
000048  1844              ADDS     r4,r0,r1              ;168
00004a  78a4              LDRB     r4,[r4,#2]            ;168
00004c  4063              EORS     r3,r3,r4              ;168
00004e  1c49              ADDS     r1,r1,#1              ;166
000050  b289              UXTH     r1,r1                 ;166
                  |L20.82|
000052  4291              CMP      r1,r2                 ;166
000054  d3f8              BCC      |L20.72|
000056  f8b01066          LDRH     r1,[r0,#0x66]         ;170
00005a  43db              MVNS     r3,r3                 ;170
00005c  1c4a              ADDS     r2,r1,#1              ;170
00005e  f8a02066          STRH     r2,[r0,#0x66]         ;170
000062  4408              ADD      r0,r0,r1              ;170
000064  7083              STRB     r3,[r0,#2]            ;170
000066  f8b504e4          LDRH     r0,[r5,#0x4e4]        ;172  ; bleHostProtocolCB
00006a  1c40              ADDS     r0,r0,#1              ;172
00006c  b280              UXTH     r0,r0                 ;172
00006e  fbb0f1f6          UDIV     r1,r0,r6              ;173
000072  fb060011          MLS      r0,r6,r1,r0           ;173
000076  f8a504e4          STRH     r0,[r5,#0x4e4]        ;173
00007a  bdf0              POP      {r4-r7,pc}
;;;176    
                          ENDP

                  |L20.124|
                          DCD      ||.bss||

                          AREA ||i.BLE_HOST_PROTOCOL_TxAddTtmCmd||, CODE, READONLY, ALIGN=2

                  BLE_HOST_PROTOCOL_TxAddTtmCmd PROC
;;;177    // 添加TTM命令
;;;178    void BLE_HOST_PROTOCOL_TxAddTtmCmd(uint8 data[], uint16 length, uint16 id)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;179    {
;;;180    	uint16 i = 0;
000004  2300              MOVS     r3,#0
;;;181    	uint16 head = bleHostProtocolCB.ttmTx.head;
000006  4e18              LDR      r6,|L21.104|
000008  f8b6c6fe          LDRH     r12,[r6,#0x6fe]  ; bleHostProtocolCB
;;;182    	uint16 end  = bleHostProtocolCB.ttmTx.end;
00000c  f8b65700          LDRH     r5,[r6,#0x700]  ; bleHostProtocolCB
;;;183    	BLE_HOST_PROTOCOL_TX_CMD_FRAME* pCmdFrame = &bleHostProtocolCB.ttmTx.cmdQueue[bleHostProtocolCB.ttmTx.end];
000010  eb050485          ADD      r4,r5,r5,LSL #2
000014  eb0404c5          ADD      r4,r4,r5,LSL #3
000018  eb0604c4          ADD      r4,r6,r4,LSL #3
00001c  f20444f6          ADD      r4,r4,#0x4f6
;;;184    
;;;185    	// 发送缓冲区已满，不予接收
;;;186    	if((end + 1) % BLE_HOST_PROTOCOL_TX_QUEUE_SIZE == head)
000020  1c6d              ADDS     r5,r5,#1
000022  2705              MOVS     r7,#5
000024  fbb5f8f7          UDIV     r8,r5,r7
000028  fb075518          MLS      r5,r7,r8,r5
00002c  4565              CMP      r5,r12
00002e  d018              BEQ      |L21.98|
;;;187    	{
;;;188    		return;
;;;189    	}
;;;190    	
;;;191    	// 队尾命令帧已满，退出
;;;192    	if(length >= BLE_HOST_PROTOCOL_TX_CMD_FRAME_LENGTH_MAX)
000030  2964              CMP      r1,#0x64
000032  d216              BCS      |L21.98|
000034  e006              B        |L21.68|
                  |L21.54|
;;;193    	{
;;;194    		return;
;;;195    	}
;;;196    
;;;197    	for (i = 0; i < length; i++)
;;;198    	{
;;;199    		pCmdFrame->buff[i] = data[i];
000036  eb040c03          ADD      r12,r4,r3
00003a  5cc5              LDRB     r5,[r0,r3]
00003c  f88c5002          STRB     r5,[r12,#2]
000040  1c5b              ADDS     r3,r3,#1              ;197
000042  b29b              UXTH     r3,r3                 ;197
                  |L21.68|
000044  428b              CMP      r3,r1                 ;197
000046  d3f6              BCC      |L21.54|
;;;200    	}
;;;201    	
;;;202    	pCmdFrame->length = length;
000048  f8a41066          STRH     r1,[r4,#0x66]
;;;203    
;;;204    	pCmdFrame->deviceID = id;
00004c  8022              STRH     r2,[r4,#0]
;;;205    
;;;206    	bleHostProtocolCB.ttmTx.end ++;
00004e  f8b60700          LDRH     r0,[r6,#0x700]  ; bleHostProtocolCB
000052  1c40              ADDS     r0,r0,#1
000054  b280              UXTH     r0,r0
;;;207    	bleHostProtocolCB.ttmTx.end %= BLE_HOST_PROTOCOL_TX_QUEUE_SIZE;
000056  fbb0f1f7          UDIV     r1,r0,r7
00005a  fb070011          MLS      r0,r7,r1,r0
00005e  f8a60700          STRH     r0,[r6,#0x700]
                  |L21.98|
;;;208    }
000062  e8bd81f0          POP      {r4-r8,pc}
;;;209    
                          ENDP

000066  0000              DCW      0x0000
                  |L21.104|
                          DCD      ||.bss||

                          AREA ||i.BLE_HOST_PROTOCOL_TxStateProcess||, CODE, READONLY, ALIGN=2

                  BLE_HOST_PROTOCOL_TxStateProcess PROC
;;;308    // 协议层发送处理过程
;;;309    void BLE_HOST_PROTOCOL_TxStateProcess(void)
000000  b570              PUSH     {r4-r6,lr}
;;;310    {
;;;311    	uint16 head = bleHostProtocolCB.tx.head;
000002  4c15              LDR      r4,|L22.88|
000004  f8b434e2          LDRH     r3,[r4,#0x4e2]  ; bleHostProtocolCB
;;;312    	uint16 end =  bleHostProtocolCB.tx.end;
000008  f8b464e4          LDRH     r6,[r4,#0x4e4]  ; bleHostProtocolCB
;;;313    	uint16 length = bleHostProtocolCB.tx.cmdQueue[head].length;
00000c  eb030083          ADD      r0,r3,r3,LSL #2
000010  eb0000c3          ADD      r0,r0,r3,LSL #3
000014  eb0400c0          ADD      r0,r4,r0,LSL #3
000018  4605              MOV      r5,r0
00001a  f8b02340          LDRH     r2,[r0,#0x340]
;;;314    	uint8* pCmd = bleHostProtocolCB.tx.cmdQueue[head].buff;
00001e  f5007137          ADD      r1,r0,#0x2dc
;;;315    	uint16 localDeviceID = bleHostProtocolCB.tx.cmdQueue[head].deviceID;
000022  f8b002da          LDRH     r0,[r0,#0x2da]
;;;316    
;;;317    	// 发送缓冲区为空，说明无数据
;;;318    	if (head == end)
000026  42b3              CMP      r3,r6
000028  d014              BEQ      |L22.84|
;;;319    	{
;;;320    		return;
;;;321    	}
;;;322    
;;;323    	// 发送函数没有注册直接返回
;;;324    	if (NULL == bleHostProtocolCB.sendDataThrowService)
00002a  f8d434ec          LDR      r3,[r4,#0x4ec]  ; bleHostProtocolCB
00002e  2b00              CMP      r3,#0
000030  d010              BEQ      |L22.84|
;;;325    	{
;;;326    		return;
;;;327    	}
;;;328    
;;;329    	// 协议层有数据需要发送到驱动层		
;;;330    	if (!(*bleHostProtocolCB.sendDataThrowService)(localDeviceID, pCmd, length))
000032  4798              BLX      r3
000034  2800              CMP      r0,#0
000036  d00d              BEQ      |L22.84|
;;;331    	{
;;;332    		return;
;;;333    	}
;;;334    
;;;335    	// 发送环形队列更新位置
;;;336    	bleHostProtocolCB.tx.cmdQueue[head].length = 0;
000038  2000              MOVS     r0,#0
00003a  f8a50340          STRH     r0,[r5,#0x340]
;;;337    	bleHostProtocolCB.tx.head ++;
00003e  f8b404e2          LDRH     r0,[r4,#0x4e2]  ; bleHostProtocolCB
000042  1c40              ADDS     r0,r0,#1
000044  b280              UXTH     r0,r0
;;;338    	bleHostProtocolCB.tx.head %= BLE_HOST_PROTOCOL_TX_QUEUE_SIZE;
000046  2105              MOVS     r1,#5
000048  fbb0f2f1          UDIV     r2,r0,r1
00004c  fb010012          MLS      r0,r1,r2,r0
000050  f8a404e2          STRH     r0,[r4,#0x4e2]
                  |L22.84|
;;;339    }
000054  bd70              POP      {r4-r6,pc}
;;;340    
                          ENDP

000056  0000              DCW      0x0000
                  |L22.88|
                          DCD      ||.bss||

                          AREA ||i.BLE_HOST_UART_CALLBALL_OutfitConnect||, CODE, READONLY, ALIGN=1

                  BLE_HOST_UART_CALLBALL_OutfitConnect PROC
;;;771    // 定时器回调发送设备连接指令
;;;772    void  BLE_HOST_UART_CALLBALL_OutfitConnect(uint32 param)
000000  2800              CMP      r0,#0
;;;773    {
000002  d002              BEQ      |L23.10|
;;;774    	if (param)
;;;775    	{
;;;776    		BLE_HOST_UART_SendCmdConnectHelmet(TRUE);
000004  2001              MOVS     r0,#1
000006  f7ffbffe          B.W      BLE_HOST_UART_SendCmdConnectHelmet
                  |L23.10|
;;;777    	}
;;;778    	else
;;;779    	{
;;;780    		BLE_HOST_UART_SendCmdConnectKey(TRUE);
00000a  2001              MOVS     r0,#1
00000c  f7ffbffe          B.W      BLE_HOST_UART_SendCmdConnectKey
;;;781    	}
;;;782    }
;;;783    
                          ENDP


                          AREA ||i.BLE_HOST_UART_SendCmdConnectHelmet||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                  BLE_HOST_UART_SendCmdConnectHelmet PROC
;;;680    // 连接头盔
;;;681    void BLE_HOST_UART_SendCmdConnectHelmet(uint32 param)
000000  b500              PUSH     {lr}
;;;682    {
000002  b099              SUB      sp,sp,#0x64
;;;683    	uint8 bleStr[100] = "TTM:CONNECT=55:34:FF:93:58:44,66,13\r\n";
000004  2264              MOVS     r2,#0x64
000006  490c              LDR      r1,|L24.56|
000008  4668              MOV      r0,sp
00000a  f7fffffe          BL       __aeabi_memcpy4
;;;684    
;;;685    	// 头盔无配对不处理
;;;686    	if (!PARAM_GetHelmetPairState())
00000e  480b              LDR      r0,|L24.60|
000010  f89002e2          LDRB     r0,[r0,#0x2e2]  ; paramCB
000014  2800              CMP      r0,#0
000016  d00c              BEQ      |L24.50|
;;;687    	{
;;;688    //		TIMER_KillTask(TIMER_ID_BLE_HELMET_PAIR);
;;;689    		return;
;;;690    	}
;;;691    			
;;;692    	// 读写handle固定
;;;693    	sprintf((char *)bleStr, "TTM:CONNECT=%s,66,13\r\n", PARAM_GetHelmetMacBuff());
000018  4a09              LDR      r2,|L24.64|
00001a  a10a              ADR      r1,|L24.68|
00001c  4668              MOV      r0,sp
00001e  f7fffffe          BL       __2sprintf
;;;694    	
;;;695    	// 添加到队列发送
;;;696    	BLE_HOST_PROTOCOL_TxAddTtmCmd(bleStr, strlen((char *)bleStr), BLE_OUTFIT_HELMET_ID);
000022  4668              MOV      r0,sp
000024  f7fffffe          BL       strlen
000028  b281              UXTH     r1,r0
00002a  2201              MOVS     r2,#1
00002c  4668              MOV      r0,sp
00002e  f7fffffe          BL       BLE_HOST_PROTOCOL_TxAddTtmCmd
                  |L24.50|
;;;697    }
000032  b019              ADD      sp,sp,#0x64
000034  bd00              POP      {pc}
;;;698    
                          ENDP

000036  0000              DCW      0x0000
                  |L24.56|
                          DCD      ||.constdata||+0x64
                  |L24.60|
                          DCD      paramCB
                  |L24.64|
                          DCD      paramCB+0x2ce
                  |L24.68|
000044  54544d3a          DCB      "TTM:CONNECT=%s,66,13\r\n",0
000048  434f4e4e
00004c  4543543d
000050  25732c36
000054  362c3133
000058  0d0a00  
00005b  00                DCB      0

                          AREA ||i.BLE_HOST_UART_SendCmdConnectKey||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                  BLE_HOST_UART_SendCmdConnectKey PROC
;;;718    // 连接无线按键
;;;719    void BLE_HOST_UART_SendCmdConnectKey(uint32 param)
000000  b500              PUSH     {lr}
;;;720    {
000002  b099              SUB      sp,sp,#0x64
;;;721    	uint8 bleStr[100] = "TTM:CONNECT=7C:69:6B:52:24:24,17,13\r\n";
000004  2264              MOVS     r2,#0x64
000006  490c              LDR      r1,|L25.56|
000008  4668              MOV      r0,sp
00000a  f7fffffe          BL       __aeabi_memcpy4
;;;722    
;;;723    	// 按键无配对不处理
;;;724    	if (!PARAM_GetLockPairState())
00000e  480b              LDR      r0,|L25.60|
000010  f89002f7          LDRB     r0,[r0,#0x2f7]  ; paramCB
000014  2800              CMP      r0,#0
000016  d00c              BEQ      |L25.50|
;;;725    	{
;;;726    //		TIMER_KillTask(TIMER_ID_BLE_LOCK_PAIR);
;;;727    		return;
;;;728    	}
;;;729    	
;;;730    	// 读写handle固定
;;;731    	sprintf((char *)bleStr, "TTM:CONNECT=%s,14,11\r\n", PARAM_GetLockMacBuff());
000018  4a09              LDR      r2,|L25.64|
00001a  a10a              ADR      r1,|L25.68|
00001c  4668              MOV      r0,sp
00001e  f7fffffe          BL       __2sprintf
;;;732    	
;;;733    	// 添加到队列发送
;;;734    	BLE_HOST_PROTOCOL_TxAddTtmCmd(bleStr, strlen((char *)bleStr), BLE_OUTFIT_LOCK_ID);
000022  4668              MOV      r0,sp
000024  f7fffffe          BL       strlen
000028  b281              UXTH     r1,r0
00002a  2202              MOVS     r2,#2
00002c  4668              MOV      r0,sp
00002e  f7fffffe          BL       BLE_HOST_PROTOCOL_TxAddTtmCmd
                  |L25.50|
;;;735    }
000032  b019              ADD      sp,sp,#0x64
000034  bd00              POP      {pc}
;;;736    
                          ENDP

000036  0000              DCW      0x0000
                  |L25.56|
                          DCD      ||.constdata||+0x12c
                  |L25.60|
                          DCD      paramCB
                  |L25.64|
                          DCD      paramCB+0x2e3
                  |L25.68|
000044  54544d3a          DCB      "TTM:CONNECT=%s,14,11\r\n",0
000048  434f4e4e
00004c  4543543d
000050  25732c31
000054  342c3131
000058  0d0a00  
00005b  00                DCB      0

                          AREA ||i.BLE_HOST_UART_SendCmdDisconnectHelmet||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                  BLE_HOST_UART_SendCmdDisconnectHelmet PROC
;;;661    // 上电断开头盔连接
;;;662    void BLE_HOST_UART_SendCmdDisconnectHelmet(uint32 param)
000000  b500              PUSH     {lr}
;;;663    {
000002  b099              SUB      sp,sp,#0x64
;;;664    	uint8 bleStr[100] = "TTM:DISCONNECT=55:34:FF:93:58:44\r\n";
000004  2264              MOVS     r2,#0x64
000006  490c              LDR      r1,|L26.56|
000008  4668              MOV      r0,sp
00000a  f7fffffe          BL       __aeabi_memcpy4
;;;665    
;;;666    	// 头盔无配对不处理
;;;667    	if (!PARAM_GetHelmetPairState())
00000e  480b              LDR      r0,|L26.60|
000010  f89002e2          LDRB     r0,[r0,#0x2e2]  ; paramCB
000014  2800              CMP      r0,#0
000016  d00c              BEQ      |L26.50|
;;;668    	{
;;;669    //		TIMER_KillTask(TIMER_ID_BLE_HELMET_PAIR);
;;;670    		return;
;;;671    	}
;;;672    	
;;;673    	// 读写handle固定
;;;674    	sprintf((char *)bleStr, "TTM:DISCONNECT=%s\r\n", PARAM_GetHelmetMacBuff());
000018  4a09              LDR      r2,|L26.64|
00001a  a10a              ADR      r1,|L26.68|
00001c  4668              MOV      r0,sp
00001e  f7fffffe          BL       __2sprintf
;;;675    
;;;676    	// 添加到队列发送
;;;677    	BLE_HOST_PROTOCOL_TxAddTtmCmd(bleStr, strlen((char *)bleStr), BLE_OUTFIT_HELMET_ID);
000022  4668              MOV      r0,sp
000024  f7fffffe          BL       strlen
000028  b281              UXTH     r1,r0
00002a  2201              MOVS     r2,#1
00002c  4668              MOV      r0,sp
00002e  f7fffffe          BL       BLE_HOST_PROTOCOL_TxAddTtmCmd
                  |L26.50|
;;;678    }
000032  b019              ADD      sp,sp,#0x64
000034  bd00              POP      {pc}
;;;679    
                          ENDP

000036  0000              DCW      0x0000
                  |L26.56|
                          DCD      ||.constdata||
                  |L26.60|
                          DCD      paramCB
                  |L26.64|
                          DCD      paramCB+0x2ce
                  |L26.68|
000044  54544d3a          DCB      "TTM:DISCONNECT=%s\r\n",0
000048  44495343
00004c  4f4e4e45
000050  43543d25
000054  730d0a00

                          AREA ||i.BLE_HOST_UART_SendCmdDisconnectKey||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                  BLE_HOST_UART_SendCmdDisconnectKey PROC
;;;699    // 上电断开无线按键连接
;;;700    void BLE_HOST_UART_SendCmdDisconnectKey(uint32 param)
000000  b500              PUSH     {lr}
;;;701    {
000002  b099              SUB      sp,sp,#0x64
;;;702    	uint8 bleStr[100] = "TTM:DISCONNECT=7C:69:6B:52:24:24\r\n";
000004  2264              MOVS     r2,#0x64
000006  490c              LDR      r1,|L27.56|
000008  4668              MOV      r0,sp
00000a  f7fffffe          BL       __aeabi_memcpy4
;;;703    
;;;704    	// 按键无配对不处理
;;;705    	if (!PARAM_GetLockPairState())
00000e  480b              LDR      r0,|L27.60|
000010  f89002f7          LDRB     r0,[r0,#0x2f7]  ; paramCB
000014  2800              CMP      r0,#0
000016  d00c              BEQ      |L27.50|
;;;706    	{
;;;707    //		TIMER_KillTask(TIMER_ID_BLE_LOCK_PAIR);
;;;708    		return;
;;;709    	}
;;;710    	
;;;711    	// 读写handle固定
;;;712    	sprintf((char *)bleStr, "TTM:DISCONNECT=%s\r\n", PARAM_GetLockMacBuff());
000018  4a09              LDR      r2,|L27.64|
00001a  a10a              ADR      r1,|L27.68|
00001c  4668              MOV      r0,sp
00001e  f7fffffe          BL       __2sprintf
;;;713    	
;;;714    	// 添加到队列发送
;;;715    	BLE_HOST_PROTOCOL_TxAddTtmCmd(bleStr, strlen((char *)bleStr), BLE_OUTFIT_LOCK_ID);
000022  4668              MOV      r0,sp
000024  f7fffffe          BL       strlen
000028  b281              UXTH     r1,r0
00002a  2202              MOVS     r2,#2
00002c  4668              MOV      r0,sp
00002e  f7fffffe          BL       BLE_HOST_PROTOCOL_TxAddTtmCmd
                  |L27.50|
;;;716    }
000032  b019              ADD      sp,sp,#0x64
000034  bd00              POP      {pc}
;;;717    
                          ENDP

000036  0000              DCW      0x0000
                  |L27.56|
                          DCD      ||.constdata||+0xc8
                  |L27.60|
                          DCD      paramCB
                  |L27.64|
                          DCD      paramCB+0x2e3
                  |L27.68|
000044  54544d3a          DCB      "TTM:DISCONNECT=%s\r\n",0
000048  44495343
00004c  4f4e4e45
000050  43543d25
000054  730d0a00

                          AREA ||i.BLE_HOST_UART_SendConnectBleDevice||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  BLE_HOST_UART_SendConnectBleDevice PROC
;;;748    // 连接设备
;;;749    void BLE_HOST_UART_SendConnectBleDevice(BLE_PAIR_DEVICE device, uint8 macBuff[])
000000  b530              PUSH     {r4,r5,lr}
;;;750    {
000002  b099              SUB      sp,sp,#0x64
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;751    	uint8 bleStr[100] = "TTM:CONNECT=7C:69:6B:52:24:24,17,13\r\n";
000008  2264              MOVS     r2,#0x64
00000a  4912              LDR      r1,|L28.84|
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       __aeabi_memcpy4
;;;752    
;;;753    	if (BLE_HELMET_DEVICE == device)
000012  b184              CBZ      r4,|L28.54|
;;;754    	{
;;;755    		// 读写handle固定
;;;756    		sprintf((char *)bleStr,  (char *)"TTM:CONNECT=%s,66,13\r\n", macBuff);
;;;757    		
;;;758    		// 添加到队列发送
;;;759    		BLE_HOST_PROTOCOL_TxAddTtmCmd(bleStr, strlen((char *)bleStr), 0x00);
;;;760    	}
;;;761    	else if (BLE_LOCK_DEVICE == device)
000014  2c01              CMP      r4,#1
000016  d10c              BNE      |L28.50|
;;;762    	{
;;;763    		// 读写handle固定
;;;764    		sprintf((char *)bleStr, "TTM:CONNECT=%s,17,13\r\n", macBuff);
000018  462a              MOV      r2,r5
00001a  a10f              ADR      r1,|L28.88|
00001c  4668              MOV      r0,sp
00001e  f7fffffe          BL       __2sprintf
;;;765    		
;;;766    		// 添加到队列发送
;;;767    		BLE_HOST_PROTOCOL_TxAddTtmCmd(bleStr, strlen((char *)bleStr), 0x00);
000022  4668              MOV      r0,sp
000024  f7fffffe          BL       strlen
000028  b281              UXTH     r1,r0
00002a  2200              MOVS     r2,#0
00002c  4668              MOV      r0,sp
00002e  f7fffffe          BL       BLE_HOST_PROTOCOL_TxAddTtmCmd
                  |L28.50|
;;;768    	}
;;;769    }
000032  b019              ADD      sp,sp,#0x64
000034  bd30              POP      {r4,r5,pc}
                  |L28.54|
000036  462a              MOV      r2,r5                 ;756
000038  a10d              ADR      r1,|L28.112|
00003a  4668              MOV      r0,sp                 ;756
00003c  f7fffffe          BL       __2sprintf
000040  4668              MOV      r0,sp                 ;759
000042  f7fffffe          BL       strlen
000046  b281              UXTH     r1,r0                 ;759
000048  2200              MOVS     r2,#0                 ;759
00004a  4668              MOV      r0,sp                 ;759
00004c  f7fffffe          BL       BLE_HOST_PROTOCOL_TxAddTtmCmd
000050  e7ef              B        |L28.50|
;;;770    
                          ENDP

000052  0000              DCW      0x0000
                  |L28.84|
                          DCD      ||.constdata||+0x1f4
                  |L28.88|
000058  54544d3a          DCB      "TTM:CONNECT=%s,17,13\r\n",0
00005c  434f4e4e
000060  4543543d
000064  25732c31
000068  372c3133
00006c  0d0a00  
00006f  00                DCB      0
                  |L28.112|
000070  54544d3a          DCB      "TTM:CONNECT=%s,66,13\r\n",0
000074  434f4e4e
000078  4543543d
00007c  25732c36
000080  362c3133
000084  0d0a00  
000087  00                DCB      0

                          AREA ||i.BLE_HOST_UART_SendScanBleDevice||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_sizespec
                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  BLE_HOST_UART_SendScanBleDevice PROC
;;;737    // 扫描蓝牙设备
;;;738    void BLE_HOST_UART_SendScanBleDevice(uint32 param)
000000  b510              PUSH     {r4,lr}
;;;739    {
000002  b09a              SUB      sp,sp,#0x68
000004  4604              MOV      r4,r0
;;;740    	uint8 bleStr[100] = "TTM:SCAN=1,5\r\n";
000006  2264              MOVS     r2,#0x64
000008  4909              LDR      r1,|L29.48|
00000a  a801              ADD      r0,sp,#4
00000c  f7fffffe          BL       __aeabi_memcpy4
;;;741    	
;;;742    	sprintf((char *)bleStr, "TTM:SCAN=1,%ld\r\n", param);
000010  4622              MOV      r2,r4
000012  a108              ADR      r1,|L29.52|
000014  a801              ADD      r0,sp,#4
000016  f7fffffe          BL       __2sprintf
;;;743    	
;;;744    	// 添加到队列发送
;;;745    	BLE_HOST_PROTOCOL_TxAddTtmCmd(bleStr, strlen((char *)bleStr), 0x00);
00001a  a801              ADD      r0,sp,#4
00001c  f7fffffe          BL       strlen
000020  b281              UXTH     r1,r0
000022  2200              MOVS     r2,#0
000024  a801              ADD      r0,sp,#4
000026  f7fffffe          BL       BLE_HOST_PROTOCOL_TxAddTtmCmd
;;;746    }
00002a  b01a              ADD      sp,sp,#0x68
00002c  bd10              POP      {r4,pc}
;;;747    
                          ENDP

00002e  0000              DCW      0x0000
                  |L29.48|
                          DCD      ||.constdata||+0x190
                  |L29.52|
000034  54544d3a          DCB      "TTM:SCAN=1,%ld\r\n",0
000038  5343414e
00003c  3d312c25
000040  6c640d0a
000044  00      
000045  00                DCB      0
000046  00                DCB      0
000047  00                DCB      0

                          AREA ||i.BLE_HOST_UART_TTM_AnalysisCmd||, CODE, READONLY, ALIGN=2

                  BLE_HOST_UART_TTM_AnalysisCmd PROC
;;;1114   // 解析蓝牙收到的TTM命令
;;;1115   void BLE_HOST_UART_TTM_AnalysisCmd(uint8 buff[], uint8 length)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1116   {
000004  4605              MOV      r5,r0
;;;1117   	uint8 bleIndex = 0;
;;;1118   	uint16 macIndex = 0;
;;;1119   		
;;;1120   	if((-1 != STRING_Find(buff, (uint8 *)"OK"))    ||
000006  a18b              ADR      r1,|L30.564|
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       STRING_Find
;;;1121   	   (-1 != STRING_Find(buff, (uint8 *)"ERROR")) ||
;;;1122   	   (-1 != STRING_Find(buff, (uint8 *)"FAIL")))
;;;1123   	{
;;;1124   		bleHostProtocolCB.sendCmd.Flag = TRUE;
00000e  f8df8228          LDR      r8,|L30.568|
000012  1c40              ADDS     r0,r0,#1              ;1120
000014  f04f0701          MOV      r7,#1
000018  d10b              BNE      |L30.50|
00001a  a188              ADR      r1,|L30.572|
00001c  4628              MOV      r0,r5                 ;1121
00001e  f7fffffe          BL       STRING_Find
000022  1c40              ADDS     r0,r0,#1              ;1121
000024  d105              BNE      |L30.50|
000026  a187              ADR      r1,|L30.580|
000028  4628              MOV      r0,r5                 ;1122
00002a  f7fffffe          BL       STRING_Find
00002e  1c40              ADDS     r0,r0,#1              ;1122
000030  d001              BEQ      |L30.54|
                  |L30.50|
000032  f8887728          STRB     r7,[r8,#0x728]
                  |L30.54|
;;;1125   	}
;;;1126   
;;;1127   	// 配对模式
;;;1128   	if (BLE_PAIR_MODE == bleHostProtocolCB.pair.mode)
000036  f898071d          LDRB     r0,[r8,#0x71d]  ; bleHostProtocolCB
00003a  2600              MOVS     r6,#0
;;;1129   	{
;;;1130   		if (-1 != STRING_Find(buff, (uint8 *)"TTM:SCAN="))
;;;1131   		{
;;;1132   			// 扫描成功不再处理
;;;1133   			if (bleHostProtocolCB.pair.scanFlag)
;;;1134   			{
;;;1135   				return;
;;;1136   			}
;;;1137   
;;;1138   			switch (bleHostProtocolCB.pair.device)
;;;1139   			{
;;;1140   				case BLE_HELMET_DEVICE:
;;;1141   
;;;1142   					// 根据协议来，头盔配对状态下蓝牙名称为：PDTT-XXXXXXXXXXXX
;;;1143   					if (-1 != STRING_Find(buff, (uint8 *)"PDTT"))
;;;1144   					{
;;;1145   						bleIndex = STRING_Find(buff, (uint8 *)"PDTT");
;;;1146   						
;;;1147   						// 截取mac地址
;;;1148   						STRING_Left(&buff[bleIndex - 18], 17, bleHostProtocolCB.pair.macBuff);
;;;1149   						bleHostProtocolCB.pair.scanFlag = TRUE;
;;;1150   					}
;;;1151   					break;
;;;1152   
;;;1153   				case BLE_LOCK_DEVICE:
;;;1154   
;;;1155   					// 根据协议来，按键配对状态下蓝牙名称为：PDTK-XXXXXXXXXXXX
;;;1156   					if (-1 != STRING_Find(buff, (uint8 *)"PDTK"))
;;;1157   					{
;;;1158   						bleIndex = STRING_Find(buff, (uint8 *)"PDTK");
;;;1159   						
;;;1160   						// 截取mac地址
;;;1161   						STRING_Left(&buff[bleIndex - 18], 17, bleHostProtocolCB.pair.macBuff);
;;;1162   						bleHostProtocolCB.pair.scanFlag = TRUE;
;;;1163   					}
;;;1164   					break;
;;;1165   
;;;1166   				default:
;;;1167   					break;
;;;1168   			}
;;;1169   		}
;;;1170   		else if (-1 != STRING_Find(buff, (uint8 *)"TTM:CONNECT="))
;;;1171   		{
;;;1172   			if (-1 != STRING_Find(buff, bleHostProtocolCB.pair.macBuff))
;;;1173   			{
;;;1174   				macIndex = STRING_FindCh(buff, ',');
;;;1175   				switch (bleHostProtocolCB.pair.device)
;;;1176   				{
;;;1177   					case BLE_HELMET_DEVICE:
;;;1178   
;;;1179   						if ('0' == buff[macIndex+1])
;;;1180   						{
;;;1181   							PARAM_SetHelmetConnectState(FALSE);
00003c  4c83              LDR      r4,|L30.588|
00003e  2801              CMP      r0,#1                 ;1128
000040  d01c              BEQ      |L30.124|
;;;1182   						}
;;;1183   						else if ('1' == buff[macIndex+1])
;;;1184   						{
;;;1185   							PARAM_SetHelmetConnectState(TRUE);
;;;1186   						}	
;;;1187   						break;
;;;1188   
;;;1189   					case BLE_LOCK_DEVICE:
;;;1190   
;;;1191   						if ('0' == buff[macIndex+1])
;;;1192   						{
;;;1193   							PARAM_SetLockConnectState(FALSE);
;;;1194   						}
;;;1195   						else if ('1' == buff[macIndex+1])
;;;1196   						{
;;;1197   							PARAM_SetLockConnectState(TRUE);
;;;1198   						}	
;;;1199   						break;
;;;1200   
;;;1201   					default:
;;;1202   						break;
;;;1203   				}
;;;1204   			}
;;;1205   		}
;;;1206   		else if ((-1 != STRING_Find(buff, (uint8 *)"TTM:DISCONNECTED=")) 
;;;1207   			    &&(-1 != STRING_Find(buff, bleHostProtocolCB.pair.macBuff)))
;;;1208   		{
;;;1209   			switch (bleHostProtocolCB.pair.device)
;;;1210   			{
;;;1211   				case BLE_HELMET_DEVICE:
;;;1212   
;;;1213   					PARAM_SetHelmetConnectState(FALSE);
;;;1214   					PARAM_SetTurnState(NO_TRUN);
;;;1215   					break;
;;;1216   
;;;1217   				case BLE_LOCK_DEVICE:
;;;1218   
;;;1219   					PARAM_SetLockConnectState(FALSE);
;;;1220   					break;
;;;1221   
;;;1222   				default:
;;;1223   					break;
;;;1224   			}
;;;1225   		}
;;;1226   	}
;;;1227   	else
;;;1228   	{
;;;1229   		// 从设备连接状态
;;;1230   		if (-1 != STRING_Find(buff, (uint8 *)"TTM:CONNECT="))
000042  a183              ADR      r1,|L30.592|
000044  4628              MOV      r0,r5
000046  f7fffffe          BL       STRING_Find
00004a  46a1              MOV      r9,r4                 ;1181
;;;1231   		{
;;;1232   			if (-1 != STRING_Find(buff, (uint8 *)PARAM_GetHelmetMacBuff()))
00004c  f20928ce          ADD      r8,r9,#0x2ce
000050  1c40              ADDS     r0,r0,#1              ;1230
;;;1233   			{
;;;1234   				macIndex = STRING_FindCh(buff, ',');
;;;1235   				if ('0' == buff[macIndex+1])
;;;1236   				{
;;;1237   					PARAM_SetHelmetConnectState(FALSE);
;;;1238   				}
;;;1239   				else if ('1' == buff[macIndex+1])
;;;1240   				{
;;;1241   					PARAM_SetHelmetConnectState(TRUE);
;;;1242   //					TIMER_KillTask(TIMER_ID_BLE_HELMET_PAIR);
;;;1243   
;;;1244   					// 连接设备后第一时间发给头盔
;;;1245   					BLE_HOST_PROTOCOL_SendCmdToHeadConnectState(1);
;;;1246   				}	
;;;1247   			}
;;;1248   			else if (-1 != STRING_Find(buff, (uint8 *)PARAM_GetLockMacBuff()))
000052  f20929e3          ADD      r9,r9,#0x2e3
000056  d073              BEQ      |L30.320|
000058  4641              MOV      r1,r8                 ;1232
00005a  4628              MOV      r0,r5                 ;1232
00005c  f7fffffe          BL       STRING_Find
000060  1c40              ADDS     r0,r0,#1              ;1232
000062  d06e              BEQ      |L30.322|
000064  212c              MOVS     r1,#0x2c              ;1234
000066  4628              MOV      r0,r5                 ;1234
000068  f7fffffe          BL       STRING_FindCh
00006c  b280              UXTH     r0,r0                 ;1234
00006e  4428              ADD      r0,r0,r5              ;1235
000070  7840              LDRB     r0,[r0,#1]            ;1235
000072  2830              CMP      r0,#0x30              ;1235
000074  d07e              BEQ      |L30.372|
000076  2831              CMP      r0,#0x31              ;1239
000078  d07d              BEQ      |L30.374|
00007a  e0a5              B        |L30.456|
                  |L30.124|
00007c  a178              ADR      r1,|L30.608|
00007e  4628              MOV      r0,r5                 ;1130
000080  f7fffffe          BL       STRING_Find
000084  f8df91e4          LDR      r9,|L30.620|
000088  1c40              ADDS     r0,r0,#1              ;1130
00008a  d031              BEQ      |L30.240|
00008c  f898071c          LDRB     r0,[r8,#0x71c]        ;1133  ; bleHostProtocolCB
000090  2800              CMP      r0,#0                 ;1133
000092  d117              BNE      |L30.196|
000094  f8980706          LDRB     r0,[r8,#0x706]        ;1138  ; bleHostProtocolCB
000098  b1b0              CBZ      r0,|L30.200|
00009a  2801              CMP      r0,#1                 ;1138
00009c  d112              BNE      |L30.196|
00009e  a174              ADR      r1,|L30.624|
0000a0  4628              MOV      r0,r5                 ;1156
0000a2  f7fffffe          BL       STRING_Find
0000a6  1c40              ADDS     r0,r0,#1              ;1156
0000a8  d00c              BEQ      |L30.196|
0000aa  a171              ADR      r1,|L30.624|
0000ac  4628              MOV      r0,r5                 ;1158
0000ae  f7fffffe          BL       STRING_Find
0000b2  b2c0              UXTB     r0,r0                 ;1158
0000b4  4428              ADD      r0,r0,r5              ;1161
0000b6  3812              SUBS     r0,r0,#0x12           ;1161
0000b8  464a              MOV      r2,r9                 ;1161
0000ba  2111              MOVS     r1,#0x11              ;1161
0000bc  f7fffffe          BL       STRING_Left
0000c0  f888771c          STRB     r7,[r8,#0x71c]        ;1162
                  |L30.196|
;;;1249   			{
;;;1250   				macIndex = STRING_FindCh(buff, ',');
;;;1251   				if ('0' == buff[macIndex+1])
;;;1252   				{
;;;1253   					PARAM_SetLockConnectState(FALSE);
;;;1254   				}
;;;1255   				else if ('1' == buff[macIndex+1])
;;;1256   				{
;;;1257   					PARAM_SetLockConnectState(TRUE);
;;;1258   //					TIMER_KillTask(TIMER_ID_BLE_LOCK_PAIR);
;;;1259   
;;;1260   					// 获取电子锁key
;;;1261   //					TIMER_AddTask(TIMER_ID_BLE_LOCK_PAIR,
;;;1262   //							1000,
;;;1263   //							BLE_HOST_PROTOCOL_SendCmdGetKey,
;;;1264   //							TRUE,
;;;1265   //							BLE_OUTFIT_PAIR_COUNT,
;;;1266   //							ACTION_MODE_DO_AT_ONCE);	
;;;1267   				}	
;;;1268   			}
;;;1269   			
;;;1270   			if (-1 != STRING_Find(buff, (uint8 *)"TTM:DISCONNECTED="))
;;;1271   			{
;;;1272   				// 头盔
;;;1273   				if (-1 != STRING_Find(buff, (uint8 *)PARAM_GetHelmetMacBuff()))
;;;1274   				{
;;;1275   					PARAM_SetCallerIgnoreState(FALSE);
;;;1276   					PARAM_SetHelmetConnectState(FALSE);
;;;1277   					PARAM_SetTurnState(NO_TRUN);
;;;1278   					
;;;1279   //					TIMER_AddTask(TIMER_ID_BLE_HELMET_PAIR,
;;;1280   //							BLE_OUTFIT_CONNECT_TIME,
;;;1281   //							BLE_HOST_UART_CALLBALL_OutfitConnect,
;;;1282   //							TRUE,
;;;1283   //							BLE_OUTFIT_PAIR_COUNT,
;;;1284   //							ACTION_MODE_DO_AT_ONCE);	
;;;1285   				}
;;;1286   				// 无线按键
;;;1287   				else if (-1 != STRING_Find(buff, (uint8 *)PARAM_GetLockMacBuff()))
;;;1288   				{
;;;1289   					PARAM_SetLockConnectState(FALSE);
;;;1290   
;;;1291   //					TIMER_AddTask(TIMER_ID_BLE_LOCK_PAIR,
;;;1292   //							BLE_OUTFIT_CONNECT_TIME,
;;;1293   //							BLE_HOST_UART_CALLBALL_OutfitConnect,
;;;1294   //							FALSE,
;;;1295   //							BLE_OUTFIT_PAIR_COUNT,
;;;1296   //							ACTION_MODE_DO_AT_ONCE);	
;;;1297   				}
;;;1298   			}
;;;1299   		}
;;;1300   		// 从设备连接状态
;;;1301   		else if (-1 != STRING_Find(buff, (uint8 *)"TTM:DISCONNECTED="))
;;;1302   		{
;;;1303   			// 头盔
;;;1304   			if (-1 != STRING_Find(buff, (uint8 *)PARAM_GetHelmetMacBuff()))
;;;1305   			{
;;;1306   				PARAM_SetCallerIgnoreState(FALSE);
;;;1307   				PARAM_SetHelmetConnectState(FALSE);
;;;1308   				PARAM_SetTurnState(NO_TRUN);
;;;1309   				
;;;1310   //				TIMER_AddTask(TIMER_ID_BLE_HELMET_PAIR,
;;;1311   //						BLE_OUTFIT_CONNECT_TIME,
;;;1312   //						BLE_HOST_UART_CALLBALL_OutfitConnect,
;;;1313   //						TRUE,
;;;1314   //						BLE_OUTFIT_PAIR_COUNT,
;;;1315   //						ACTION_MODE_DO_AT_ONCE);	
;;;1316   			}
;;;1317   			// 无线按键
;;;1318   			else if (-1 != STRING_Find(buff, (uint8 *)PARAM_GetLockMacBuff()))
;;;1319   			{
;;;1320   				PARAM_SetLockConnectState(FALSE);
;;;1321   
;;;1322   //				TIMER_AddTask(TIMER_ID_BLE_LOCK_PAIR,
;;;1323   //						BLE_OUTFIT_CONNECT_TIME,
;;;1324   //						BLE_HOST_UART_CALLBALL_OutfitConnect,
;;;1325   //						FALSE,
;;;1326   //						BLE_OUTFIT_PAIR_COUNT,
;;;1327   //						ACTION_MODE_DO_AT_ONCE);	
;;;1328   			}
;;;1329   		}
;;;1330   	}
;;;1331   }
0000c4  e8bd87f0          POP      {r4-r10,pc}
                  |L30.200|
0000c8  a16b              ADR      r1,|L30.632|
0000ca  4628              MOV      r0,r5                 ;1143
0000cc  f7fffffe          BL       STRING_Find
0000d0  1c40              ADDS     r0,r0,#1              ;1143
0000d2  d0f7              BEQ      |L30.196|
0000d4  a168              ADR      r1,|L30.632|
0000d6  4628              MOV      r0,r5                 ;1145
0000d8  f7fffffe          BL       STRING_Find
0000dc  b2c0              UXTB     r0,r0                 ;1145
0000de  4428              ADD      r0,r0,r5              ;1148
0000e0  3812              SUBS     r0,r0,#0x12           ;1148
0000e2  464a              MOV      r2,r9                 ;1148
0000e4  2111              MOVS     r1,#0x11              ;1148
0000e6  f7fffffe          BL       STRING_Left
0000ea  f888771c          STRB     r7,[r8,#0x71c]        ;1149
                  |L30.238|
0000ee  e7e9              B        |L30.196|
                  |L30.240|
0000f0  a157              ADR      r1,|L30.592|
0000f2  4628              MOV      r0,r5                 ;1170
0000f4  f7fffffe          BL       STRING_Find
0000f8  1c40              ADDS     r0,r0,#1              ;1170
0000fa  d029              BEQ      |L30.336|
0000fc  4649              MOV      r1,r9                 ;1172
0000fe  4628              MOV      r0,r5                 ;1172
000100  f7fffffe          BL       STRING_Find
000104  1c40              ADDS     r0,r0,#1              ;1172
000106  d0dd              BEQ      |L30.196|
000108  212c              MOVS     r1,#0x2c              ;1174
00010a  4628              MOV      r0,r5                 ;1174
00010c  f7fffffe          BL       STRING_FindCh
000110  b280              UXTH     r0,r0                 ;1174
000112  f8981706          LDRB     r1,[r8,#0x706]        ;1175  ; bleHostProtocolCB
000116  b151              CBZ      r1,|L30.302|
000118  2901              CMP      r1,#1                 ;1175
00011a  d1d3              BNE      |L30.196|
00011c  4428              ADD      r0,r0,r5              ;1191
00011e  7840              LDRB     r0,[r0,#1]            ;1191
000120  2830              CMP      r0,#0x30              ;1191
000122  d012              BEQ      |L30.330|
000124  2831              CMP      r0,#0x31              ;1195
000126  d1cd              BNE      |L30.196|
000128  f884720f          STRB     r7,[r4,#0x20f]        ;1197
                  |L30.300|
00012c  e7ca              B        |L30.196|
                  |L30.302|
00012e  4428              ADD      r0,r0,r5              ;1179
000130  7840              LDRB     r0,[r0,#1]            ;1179
000132  2830              CMP      r0,#0x30              ;1179
000134  d006              BEQ      |L30.324|
000136  2831              CMP      r0,#0x31              ;1183
000138  d1c4              BNE      |L30.196|
00013a  f884720d          STRB     r7,[r4,#0x20d]        ;1185
                  |L30.318|
00013e  e7c1              B        |L30.196|
                  |L30.320|
000140  e05d              B        |L30.510|
                  |L30.322|
000142  e02a              B        |L30.410|
                  |L30.324|
000144  f884620d          STRB     r6,[r4,#0x20d]        ;1181
000148  e7bc              B        |L30.196|
                  |L30.330|
00014a  f884620f          STRB     r6,[r4,#0x20f]        ;1193
00014e  e7b9              B        |L30.196|
                  |L30.336|
000150  a14b              ADR      r1,|L30.640|
000152  4628              MOV      r0,r5                 ;1206
000154  f7fffffe          BL       STRING_Find
000158  1c40              ADDS     r0,r0,#1              ;1206
00015a  d0b3              BEQ      |L30.196|
00015c  4649              MOV      r1,r9                 ;1207
00015e  4628              MOV      r0,r5                 ;1207
000160  f7fffffe          BL       STRING_Find
000164  1c40              ADDS     r0,r0,#1              ;1207
000166  d0ad              BEQ      |L30.196|
000168  f8980706          LDRB     r0,[r8,#0x706]        ;1209  ; bleHostProtocolCB
00016c  b138              CBZ      r0,|L30.382|
00016e  2801              CMP      r0,#1                 ;1209
000170  d1a8              BNE      |L30.196|
000172  e001              B        |L30.376|
                  |L30.372|
000174  e008              B        |L30.392|
                  |L30.374|
000176  e00a              B        |L30.398|
                  |L30.376|
000178  f884620f          STRB     r6,[r4,#0x20f]        ;1219
00017c  e7a2              B        |L30.196|
                  |L30.382|
00017e  f884620d          STRB     r6,[r4,#0x20d]        ;1213
000182  f8846208          STRB     r6,[r4,#0x208]        ;1214
000186  e79d              B        |L30.196|
                  |L30.392|
000188  f884620d          STRB     r6,[r4,#0x20d]        ;1237
00018c  e01c              B        |L30.456|
                  |L30.398|
00018e  f884720d          STRB     r7,[r4,#0x20d]        ;1241
000192  2001              MOVS     r0,#1                 ;1245
000194  f7fffffe          BL       BLE_HOST_PROTOCOL_SendCmdToHeadConnectState
000198  e016              B        |L30.456|
                  |L30.410|
00019a  4649              MOV      r1,r9                 ;1248
00019c  4628              MOV      r0,r5                 ;1248
00019e  f7fffffe          BL       STRING_Find
0001a2  1c40              ADDS     r0,r0,#1              ;1248
0001a4  d010              BEQ      |L30.456|
0001a6  212c              MOVS     r1,#0x2c              ;1250
0001a8  4628              MOV      r0,r5                 ;1250
0001aa  f7fffffe          BL       STRING_FindCh
0001ae  b280              UXTH     r0,r0                 ;1250
0001b0  4428              ADD      r0,r0,r5              ;1251
0001b2  7840              LDRB     r0,[r0,#1]            ;1251
0001b4  2830              CMP      r0,#0x30              ;1251
0001b6  d002              BEQ      |L30.446|
0001b8  2831              CMP      r0,#0x31              ;1255
0001ba  d003              BEQ      |L30.452|
0001bc  e004              B        |L30.456|
                  |L30.446|
0001be  f884620f          STRB     r6,[r4,#0x20f]        ;1253
0001c2  e001              B        |L30.456|
                  |L30.452|
0001c4  f884720f          STRB     r7,[r4,#0x20f]        ;1257
                  |L30.456|
0001c8  a12d              ADR      r1,|L30.640|
0001ca  4628              MOV      r0,r5                 ;1270
0001cc  f7fffffe          BL       STRING_Find
0001d0  1c40              ADDS     r0,r0,#1              ;1270
0001d2  d08c              BEQ      |L30.238|
0001d4  4641              MOV      r1,r8                 ;1273
0001d6  4628              MOV      r0,r5                 ;1273
0001d8  f7fffffe          BL       STRING_Find
0001dc  1c40              ADDS     r0,r0,#1              ;1273
0001de  d005              BEQ      |L30.492|
0001e0  f5047402          ADD      r4,r4,#0x208          ;1275
0001e4  7126              STRB     r6,[r4,#4]            ;1275
0001e6  7166              STRB     r6,[r4,#5]            ;1276
0001e8  7026              STRB     r6,[r4,#0]            ;1277
0001ea  e76b              B        |L30.196|
                  |L30.492|
0001ec  4649              MOV      r1,r9                 ;1287
0001ee  4628              MOV      r0,r5                 ;1287
0001f0  f7fffffe          BL       STRING_Find
0001f4  1c40              ADDS     r0,r0,#1              ;1287
0001f6  d099              BEQ      |L30.300|
0001f8  f884620f          STRB     r6,[r4,#0x20f]        ;1289
0001fc  e762              B        |L30.196|
                  |L30.510|
0001fe  a120              ADR      r1,|L30.640|
000200  4628              MOV      r0,r5                 ;1301
000202  f7fffffe          BL       STRING_Find
000206  1c40              ADDS     r0,r0,#1              ;1301
000208  d090              BEQ      |L30.300|
00020a  4641              MOV      r1,r8                 ;1304
00020c  4628              MOV      r0,r5                 ;1304
00020e  f7fffffe          BL       STRING_Find
000212  1c40              ADDS     r0,r0,#1              ;1304
000214  d005              BEQ      |L30.546|
000216  f5047402          ADD      r4,r4,#0x208          ;1306
00021a  7126              STRB     r6,[r4,#4]            ;1306
00021c  7166              STRB     r6,[r4,#5]            ;1307
00021e  7026              STRB     r6,[r4,#0]            ;1308
000220  e750              B        |L30.196|
                  |L30.546|
000222  4649              MOV      r1,r9                 ;1318
000224  4628              MOV      r0,r5                 ;1318
000226  f7fffffe          BL       STRING_Find
00022a  1c40              ADDS     r0,r0,#1              ;1318
00022c  d087              BEQ      |L30.318|
00022e  f884620f          STRB     r6,[r4,#0x20f]        ;1320
000232  e747              B        |L30.196|
;;;1332   
                          ENDP

                  |L30.564|
000234  4f4b00            DCB      "OK",0
000237  00                DCB      0
                  |L30.568|
                          DCD      ||.bss||
                  |L30.572|
00023c  4552524f          DCB      "ERROR",0
000240  5200    
000242  00                DCB      0
000243  00                DCB      0
                  |L30.580|
000244  4641494c          DCB      "FAIL",0
000248  00      
000249  00                DCB      0
00024a  00                DCB      0
00024b  00                DCB      0
                  |L30.588|
                          DCD      paramCB
                  |L30.592|
000250  54544d3a          DCB      "TTM:CONNECT=",0
000254  434f4e4e
000258  4543543d
00025c  00      
00025d  00                DCB      0
00025e  00                DCB      0
00025f  00                DCB      0
                  |L30.608|
000260  54544d3a          DCB      "TTM:SCAN=",0
000264  5343414e
000268  3d00    
00026a  00                DCB      0
00026b  00                DCB      0
                  |L30.620|
                          DCD      ||.bss||+0x707
                  |L30.624|
000270  5044544b          DCB      "PDTK",0
000274  00      
000275  00                DCB      0
000276  00                DCB      0
000277  00                DCB      0
                  |L30.632|
000278  50445454          DCB      "PDTT",0
00027c  00      
00027d  00                DCB      0
00027e  00                DCB      0
00027f  00                DCB      0
                  |L30.640|
000280  54544d3a          DCB      "TTM:DISCONNECTED=",0
000284  44495343
000288  4f4e4e45
00028c  43544544
000290  3d00    
000292  00                DCB      0
000293  00                DCB      0

                          AREA ||i.BLE_PairEnterState||, CODE, READONLY, ALIGN=2

                  BLE_PairEnterState PROC
;;;1454   // 状态迁移
;;;1455   void BLE_PairEnterState(uint32 state)
000000  b570              PUSH     {r4-r6,lr}
;;;1456   {
000002  4602              MOV      r2,r0
                  |L31.4|
;;;1457   	// 让当前的状态成为历史
;;;1458   	bleHostProtocolCB.pair.preState = bleHostProtocolCB.pair.state;
000004  4c32              LDR      r4,|L31.208|
000006  f8940704          LDRB     r0,[r4,#0x704]  ; bleHostProtocolCB
00000a  f8840705          STRB     r0,[r4,#0x705]
;;;1459   
;;;1460   	// 设置新的状态
;;;1461   	bleHostProtocolCB.pair.state = (BLE_PAIR_STATE)state;	
00000e  f8842704          STRB     r2,[r4,#0x704]
000012  4620              MOV      r0,r4                 ;1458
;;;1462   
;;;1463   	switch (state)
;;;1464   	{
;;;1465   		// 初始化状态
;;;1466   		case BLE_PAIR_INIT:
;;;1467   			
;;;1468   			// 头盔设备固定死
;;;1469   			//PARAM_SetHelmetPairState(TRUE);
;;;1470   			//sprintf((char*)PARAM_GetHelmetMacBuff(), "%s", (char*)"16:F0:0E:EC:F6:3F");
;;;1471   			
;;;1472   			// 电子锁设备固定死
;;;1473   //			PARAM_SetLockPairState(TRUE);
;;;1474   //			sprintf((char*)PARAM_GetLockMacBuff(), "%s", (char*)"F3:52:6E:C8:E9:3B");
;;;1475   //			sprintf((char*)PARAM_GetLockMacBuff(), "%s", (char*)"F3:52:6E:C8:E9:3B");
;;;1476   			
;;;1477   			// 上电断开头盔设备
;;;1478   			BLE_HOST_UART_SendCmdDisconnectHelmet(TRUE);
;;;1479   
;;;1480   			// 上电断开无线按键设备
;;;1481   			BLE_HOST_UART_SendCmdDisconnectKey(TRUE);
;;;1482   			
;;;1483   			// 上电查询配对设备
;;;1484   //			TIMER_AddTask(TIMER_ID_BLE_HELMET_PAIR,
;;;1485   //							BLE_OUTFIT_CONNECT_TIME,
;;;1486   //							BLE_HOST_UART_CALLBALL_OutfitConnect,
;;;1487   //							TRUE,
;;;1488   //							BLE_OUTFIT_PAIR_COUNT,
;;;1489   //							ACTION_MODE_DO_AT_ONCE);
;;;1490   
;;;1491   //			TIMER_AddTask(TIMER_ID_BLE_LOCK_PAIR,
;;;1492   //							BLE_OUTFIT_CONNECT_TIME,
;;;1493   //							BLE_HOST_UART_CALLBALL_OutfitConnect,
;;;1494   //							FALSE,
;;;1495   //							BLE_OUTFIT_PAIR_COUNT,
;;;1496   //							ACTION_MODE_DO_AT_ONCE);
;;;1497   
;;;1498   			// 正常模式
;;;1499   			bleHostProtocolCB.pair.mode = BLE_NORMAL_MODE;
;;;1500   			bleHostProtocolCB.pair.scanFlag = FALSE;
;;;1501   			bleHostProtocolCB.pair.count = 0;
;;;1502   			
;;;1503   			// 跳转待机状态
;;;1504   			BLE_PairEnterState(BLE_PAIR_STANDBY);
;;;1505   			break;
;;;1506   
;;;1507   		// 待机状态
;;;1508   		case BLE_PAIR_STANDBY:
;;;1509   			break;
;;;1510   			
;;;1511   		// 扫描状态
;;;1512   		case BLE_PAIR_SCAN:
;;;1513   
;;;1514   			bleHostProtocolCB.pair.scanFlag = FALSE;
;;;1515   				
;;;1516   			// 发送扫描命令
;;;1517   			BLE_HOST_UART_SendScanBleDevice(BLE_OUTFIT_PAIR_SCAN_TIME);
;;;1518   
;;;1519   			// 扫描完成进入连接状态
;;;1520   //			TIMER_AddTask(TIMER_ID_BLE_LOCK_PAIR,
;;;1521   //							(BLE_OUTFIT_PAIR_SCAN_TIME+1)*1000,
;;;1522   //							BLE_PairEnterState,
;;;1523   //							BLE_PAIR_CONNECT,
;;;1524   //							1,
;;;1525   //							ACTION_MODE_DO_AT_ONCE);
;;;1526   			break;
;;;1527   
;;;1528   		// 连接状态
;;;1529   		case BLE_PAIR_CONNECT:
;;;1530   
;;;1531   			if (!bleHostProtocolCB.pair.scanFlag)
;;;1532   			{
;;;1533   				BLE_PairEnterState(BLE_PAIR_FAILURE);
;;;1534   				break;
;;;1535   			}
;;;1536   			
;;;1537   			// 发送连接命令
;;;1538   			BLE_HOST_UART_SendConnectBleDevice(bleHostProtocolCB.pair.device, bleHostProtocolCB.pair.macBuff);
000014  f2007107          ADD      r1,r0,#0x707
000018  2500              MOVS     r5,#0                 ;1463
00001a  f8900706          LDRB     r0,[r0,#0x706]
00001e  2a07              CMP      r2,#7                 ;1463
000020  d254              BCS      |L31.204|
000022  e8dff002          TBB      [pc,r2]               ;1463
000026  0453              DCB      0x04,0x53
000028  131a253e          DCB      0x13,0x1a,0x25,0x3e
00002c  4a00              DCB      0x4a,0x00
00002e  2001              MOVS     r0,#1                 ;1478
000030  f7fffffe          BL       BLE_HOST_UART_SendCmdDisconnectHelmet
000034  2001              MOVS     r0,#1                 ;1481
000036  f7fffffe          BL       BLE_HOST_UART_SendCmdDisconnectKey
00003a  f204741b          ADD      r4,r4,#0x71b          ;1499
00003e  70a5              STRB     r5,[r4,#2]            ;1499
000040  7065              STRB     r5,[r4,#1]            ;1500
000042  7025              STRB     r5,[r4,#0]            ;1501
000044  e8bd4070          POP      {r4-r6,lr}            ;1504
000048  2001              MOVS     r0,#1                 ;1504
00004a  e7fe              B        BLE_PairEnterState
00004c  f884571c          STRB     r5,[r4,#0x71c]        ;1514
000050  e8bd4070          POP      {r4-r6,lr}            ;1517
000054  2005              MOVS     r0,#5                 ;1517
000056  f7ffbffe          B.W      BLE_HOST_UART_SendScanBleDevice
00005a  f894271c          LDRB     r2,[r4,#0x71c]        ;1531  ; bleHostProtocolCB
00005e  b11a              CBZ      r2,|L31.104|
000060  e8bd4070          POP      {r4-r6,lr}
000064  f7ffbffe          B.W      BLE_HOST_UART_SendConnectBleDevice
                  |L31.104|
000068  e8bd4070          POP      {r4-r6,lr}            ;1533
00006c  2005              MOVS     r0,#5                 ;1533
00006e  e7fe              B        BLE_PairEnterState
;;;1539   			
;;;1540   			// 连接超时就跳转失败处理
;;;1541   //			TIMER_AddTask(TIMER_ID_BLE_LOCK_PAIR,
;;;1542   //							3000,
;;;1543   //							BLE_PairEnterState,
;;;1544   //							BLE_PAIR_FAILURE,
;;;1545   //							1,
;;;1546   //							ACTION_MODE_DO_AT_ONCE);
;;;1547   			break;
;;;1548   
;;;1549   		// 配对成功状态
;;;1550   		case BLE_PAIR_SUCCEED:
;;;1551   			
;;;1552   			switch (bleHostProtocolCB.pair.device)
;;;1553   			{
;;;1554   				case BLE_HELMET_DEVICE:
;;;1555   
;;;1556   					// 保存配对mac地址
;;;1557   					strcpy((char *)PARAM_GetHelmetMacBuff(), (char *)bleHostProtocolCB.pair.macBuff);
000070  4c18              LDR      r4,|L31.212|
000072  2501              MOVS     r5,#1                 ;1456
000074  b110              CBZ      r0,|L31.124|
000076  2801              CMP      r0,#1                 ;1552
000078  d10c              BNE      |L31.148|
00007a  e005              B        |L31.136|
                  |L31.124|
00007c  4816              LDR      r0,|L31.216|
00007e  f7fffffe          BL       strcpy
;;;1558   					PARAM_SetHelmetPairState(TRUE);
000082  f88452e2          STRB     r5,[r4,#0x2e2]
;;;1559   					break;
000086  e005              B        |L31.148|
                  |L31.136|
;;;1560   
;;;1561   				case BLE_LOCK_DEVICE:
;;;1562   
;;;1563   					// 保存配对mac地址
;;;1564   					strcpy((char *)PARAM_GetLockMacBuff(), (char *)bleHostProtocolCB.pair.macBuff);
000088  4813              LDR      r0,|L31.216|
00008a  3015              ADDS     r0,r0,#0x15
00008c  f7fffffe          BL       strcpy
;;;1565   					PARAM_SetLockPairState(TRUE);
000090  f88452f7          STRB     r5,[r4,#0x2f7]
                  |L31.148|
;;;1566   					break;
;;;1567   					
;;;1568   				default:
;;;1569   					break;
;;;1570   			}
;;;1571   
;;;1572   			NVM_SetDirtyFlag(TRUE);
000094  2001              MOVS     r0,#1
000096  f7fffffe          BL       NVM_SetDirtyFlag
;;;1573   
;;;1574   			BLE_PairEnterState(BLE_PAIR_STOP);
00009a  e8bd4070          POP      {r4-r6,lr}
00009e  2006              MOVS     r0,#6
0000a0  e7fe              B        BLE_PairEnterState
;;;1575   			break;
;;;1576   
;;;1577   		// 配对失败状态
;;;1578   		case BLE_PAIR_FAILURE:
;;;1579   
;;;1580   			bleHostProtocolCB.pair.count++;
0000a2  f894071b          LDRB     r0,[r4,#0x71b]  ; bleHostProtocolCB
0000a6  1c40              ADDS     r0,r0,#1
0000a8  b2c0              UXTB     r0,r0
0000aa  f884071b          STRB     r0,[r4,#0x71b]
;;;1581   			if (BLE_OUTFIT_PAIR_COUNT <= bleHostProtocolCB.pair.count)
0000ae  280a              CMP      r0,#0xa
0000b0  d301              BCC      |L31.182|
;;;1582   			{
;;;1583   				BLE_PairEnterState(BLE_PAIR_STOP);
0000b2  2206              MOVS     r2,#6
0000b4  e7a6              B        |L31.4|
                  |L31.182|
;;;1584   			}
;;;1585   			else
;;;1586   			{
;;;1587   				BLE_PairEnterState(BLE_PAIR_SCAN);
0000b6  2202              MOVS     r2,#2
0000b8  e7a4              B        |L31.4|
;;;1588   			}
;;;1589   			break;
;;;1590   
;;;1591   		// 配对停止状态
;;;1592   		case BLE_PAIR_STOP:
;;;1593   
;;;1594   //			TIMER_KillTask(TIMER_ID_BLE_HELMET_PAIR);
;;;1595   	//		TIMER_KillTask(TIMER_ID_BLE_LOCK_PAIR);
;;;1596   			
;;;1597   			bleHostProtocolCB.pair.count = 0;
0000ba  f204741b          ADD      r4,r4,#0x71b
0000be  7025              STRB     r5,[r4,#0]
;;;1598   			bleHostProtocolCB.pair.scanFlag = FALSE;
0000c0  7065              STRB     r5,[r4,#1]
;;;1599   			bleHostProtocolCB.pair.mode = BLE_NORMAL_MODE;
0000c2  70a5              STRB     r5,[r4,#2]
;;;1600   
;;;1601   			BLE_PairEnterState(BLE_PAIR_STANDBY);
0000c4  e8bd4070          POP      {r4-r6,lr}
0000c8  2001              MOVS     r0,#1
0000ca  e7fe              B        BLE_PairEnterState
                  |L31.204|
;;;1602   
;;;1603   			// 配对设备断开连接就继续发指令去重连
;;;1604   //			TIMER_AddTask(TIMER_ID_BLE_HELMET_PAIR,
;;;1605   //							BLE_OUTFIT_CONNECT_TIME,
;;;1606   //							BLE_HOST_UART_CALLBALL_OutfitConnect,
;;;1607   //							TRUE,
;;;1608   //							BLE_OUTFIT_PAIR_COUNT,
;;;1609   //							ACTION_MODE_DO_AT_ONCE);
;;;1610   
;;;1611   //			TIMER_AddTask(TIMER_ID_BLE_LOCK_PAIR,
;;;1612   //							BLE_OUTFIT_CONNECT_TIME,
;;;1613   //							BLE_HOST_UART_CALLBALL_OutfitConnect,
;;;1614   //							FALSE,
;;;1615   //							BLE_OUTFIT_PAIR_COUNT,
;;;1616   //							ACTION_MODE_DO_AT_ONCE);
;;;1617   			break;
;;;1618   
;;;1619   		default:
;;;1620   			break;
;;;1621   	}
;;;1622   }
0000cc  bd70              POP      {r4-r6,pc}
;;;1623   
                          ENDP

0000ce  0000              DCW      0x0000
                  |L31.208|
                          DCD      ||.bss||
                  |L31.212|
                          DCD      paramCB
                  |L31.216|
                          DCD      paramCB+0x2ce

                          AREA ||i.BLE_PairProcess||, CODE, READONLY, ALIGN=2

                  BLE_PairProcess PROC
;;;1624   // 状态机处理
;;;1625   void BLE_PairProcess(void)
000000  b510              PUSH     {r4,lr}
;;;1626   {
;;;1627   	// 模块发送命令和接受命令处理
;;;1628   	BLE_SendAndRevCmdHandle();
000002  f7fffffe          BL       BLE_SendAndRevCmdHandle
;;;1629   
;;;1630   	switch(bleHostProtocolCB.pair.state)
000006  491a              LDR      r1,|L32.112|
000008  f8910704          LDRB     r0,[r1,#0x704]  ; bleHostProtocolCB
00000c  2801              CMP      r0,#1
00000e  d010              BEQ      |L32.50|
000010  2802              CMP      r0,#2
000012  d019              BEQ      |L32.72|
000014  2803              CMP      r0,#3
000016  d129              BNE      |L32.108|
;;;1631   	{
;;;1632   		// 待机状态
;;;1633   		case BLE_PAIR_STANDBY:
;;;1634   			
;;;1635   			switch (bleHostProtocolCB.pair.mode)
;;;1636   			{
;;;1637   				// 正常模式
;;;1638   				case BLE_NORMAL_MODE:
;;;1639   					break;
;;;1640   
;;;1641   				// 配对模式
;;;1642   				case BLE_PAIR_MODE:
;;;1643   					
;;;1644   					BLE_PairEnterState(BLE_PAIR_SCAN);
;;;1645   					break;
;;;1646   
;;;1647   				default:
;;;1648   					break;
;;;1649   			}
;;;1650   			break;
;;;1651   			
;;;1652   		// 扫描状态
;;;1653   		case BLE_PAIR_SCAN:
;;;1654   
;;;1655   			if (BLE_PAIR_MODE != bleHostProtocolCB.pair.mode)
;;;1656   			{
;;;1657   				BLE_PairEnterState(BLE_PAIR_STOP);
;;;1658   			}
;;;1659   			break;
;;;1660   
;;;1661   		// 连接状态
;;;1662   		case BLE_PAIR_CONNECT:
;;;1663   
;;;1664   			if (BLE_HELMET_DEVICE == bleHostProtocolCB.pair.device)
000018  f8911706          LDRB     r1,[r1,#0x706]  ; bleHostProtocolCB
;;;1665   			{
;;;1666   				if (PARAM_GetHelmetConnectState())
00001c  4815              LDR      r0,|L32.116|
00001e  b1e1              CBZ      r1,|L32.90|
;;;1667   				{
;;;1668   					BLE_PairEnterState(BLE_PAIR_SUCCEED);
;;;1669   				}
;;;1670   			}
;;;1671   			else
;;;1672   			{
;;;1673   				if (PARAM_GetLockConnectState())
000020  f890020f          LDRB     r0,[r0,#0x20f]  ; paramCB
000024  2800              CMP      r0,#0
000026  d021              BEQ      |L32.108|
;;;1674   				{
;;;1675   					BLE_PairEnterState(BLE_PAIR_SUCCEED);
000028  e8bd4010          POP      {r4,lr}
00002c  2004              MOVS     r0,#4
00002e  f7ffbffe          B.W      BLE_PairEnterState
                  |L32.50|
000032  f891071d          LDRB     r0,[r1,#0x71d]        ;1635  ; bleHostProtocolCB
000036  2800              CMP      r0,#0                 ;1635
000038  d018              BEQ      |L32.108|
00003a  2801              CMP      r0,#1                 ;1635
00003c  d116              BNE      |L32.108|
00003e  e8bd4010          POP      {r4,lr}               ;1644
000042  2002              MOVS     r0,#2                 ;1644
000044  f7ffbffe          B.W      BLE_PairEnterState
                  |L32.72|
000048  f891071d          LDRB     r0,[r1,#0x71d]        ;1655  ; bleHostProtocolCB
00004c  2801              CMP      r0,#1                 ;1655
00004e  d00d              BEQ      |L32.108|
000050  e8bd4010          POP      {r4,lr}               ;1657
000054  2006              MOVS     r0,#6                 ;1657
000056  f7ffbffe          B.W      BLE_PairEnterState
                  |L32.90|
00005a  f890020d          LDRB     r0,[r0,#0x20d]        ;1666  ; paramCB
00005e  2800              CMP      r0,#0                 ;1666
000060  d004              BEQ      |L32.108|
000062  e8bd4010          POP      {r4,lr}               ;1668
000066  2004              MOVS     r0,#4                 ;1668
000068  f7ffbffe          B.W      BLE_PairEnterState
                  |L32.108|
;;;1676   				}
;;;1677   			}
;;;1678   			break;
;;;1679   			
;;;1680   		default:
;;;1681   			break;
;;;1682   	}
;;;1683   }
00006c  bd10              POP      {r4,pc}
;;;1684   
                          ENDP

00006e  0000              DCW      0x0000
                  |L32.112|
                          DCD      ||.bss||
                  |L32.116|
                          DCD      paramCB

                          AREA ||i.BLE_PairStop||, CODE, READONLY, ALIGN=1

                  BLE_PairStop PROC
;;;1735   // 取消配对
;;;1736   void BLE_PairStop(void)
000000  2006              MOVS     r0,#6
;;;1737   {
;;;1738   	BLE_PairEnterState(BLE_PAIR_STOP);
000002  f7ffbffe          B.W      BLE_PairEnterState
;;;1739   }
;;;1740   
                          ENDP


                          AREA ||i.BLE_SendAndRevCmdHandle||, CODE, READONLY, ALIGN=2

                  BLE_SendAndRevCmdHandle PROC
;;;1339   // 模块发送命令和接受命令处理
;;;1340   void BLE_SendAndRevCmdHandle(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1341   {
;;;1342   	uint16 head = bleHostProtocolCB.ttmTx.head;
000004  4d3b              LDR      r5,|L34.244|
000006  f8b526fe          LDRH     r2,[r5,#0x6fe]  ; bleHostProtocolCB
;;;1343   	uint16 end = bleHostProtocolCB.ttmTx.end;
00000a  f8b51700          LDRH     r1,[r5,#0x700]  ; bleHostProtocolCB
;;;1344   	uint16 index = bleHostProtocolCB.ttmTx.index;
00000e  f8b50702          LDRH     r0,[r5,#0x702]  ; bleHostProtocolCB
;;;1345   
;;;1346   	switch (bleHostProtocolCB.sendCmd.sendCmdStep)
000012  f8956720          LDRB     r6,[r5,#0x720]  ; bleHostProtocolCB
000016  2300              MOVS     r3,#0
;;;1347   	{						
;;;1348   		// 空闲状态
;;;1349   		case BLE_SEND_CMD_IDE:
;;;1350   			
;;;1351   			// 队列为空，不处理
;;;1352   			if(head == end)
;;;1353   			{
;;;1354   				return;
;;;1355   			}
;;;1356   			else
;;;1357   			{
;;;1358   				BLE_SendCmdSwitchStep(BLE_SEND_CMD_SEND);
;;;1359   			}
;;;1360   			break;
;;;1361   			
;;;1362   		// 发送命令 发送
;;;1363   		case BLE_SEND_CMD_SEND:
;;;1364   			
;;;1365   			// 设置等待的标志位位等待状态
;;;1366   			bleHostProtocolCB.sendCmd.Flag = FALSE;
;;;1367   			
;;;1368   			// 当前命令帧未发送完时，持续发送
;;;1369   			while(index < bleHostProtocolCB.ttmTx.cmdQueue[head].length)
;;;1370   			{
;;;1371   				// 一直填充发送
;;;1372   				BLE_HOST_UART_BC_SendData(bleHostProtocolCB.ttmTx.cmdQueue[head].buff[bleHostProtocolCB.ttmTx.index++]);
;;;1373   				
;;;1374   				index = bleHostProtocolCB.ttmTx.index;
;;;1375   			}
;;;1376   
;;;1377   			if (BLE_OUTFIT_HELMET_ID == bleHostProtocolCB.ttmTx.cmdQueue[head].deviceID ||
;;;1378   				BLE_OUTFIT_LOCK_ID == bleHostProtocolCB.ttmTx.cmdQueue[head].deviceID)
;;;1379   			{
;;;1380   				// 创建定时器任务，等待指定时间进入异常处理
;;;1381   //				TIMER_AddTask(TIMER_ID_BLE_SEND_CMD,
;;;1382   //								1000,
;;;1383   //								BLE_SendCmdSwitchStep,
;;;1384   //								BLE_SEND_CMD_TIMOUT,
;;;1385   //								1,
;;;1386   //								ACTION_MODE_DO_AT_ONCE);
;;;1387   
;;;1388   				// 切换去等结果
;;;1389   				BLE_SendCmdSwitchStep(BLE_SEND_CMD_DELAY);
;;;1390   			}
;;;1391   			else
;;;1392   			{
;;;1393   				// 创建定时器任务，等待指定时间进入异常处理
;;;1394   //				TIMER_AddTask(TIMER_ID_BLE_SEND_CMD,
;;;1395   //								BLE_SEND_CMD_TIMEOUT,
;;;1396   //								BLE_SendCmdSwitchStep,
;;;1397   //								BLE_SEND_CMD_TIMOUT,
;;;1398   //								1,
;;;1399   //								ACTION_MODE_DO_AT_ONCE);
;;;1400   				// 切换去等结果
;;;1401   				BLE_SendCmdSwitchStep(BLE_SEND_CMD_WAIT);
;;;1402   			}
;;;1403   			break;
;;;1404   			
;;;1405   		// 发送命令 等待结果
;;;1406   		case BLE_SEND_CMD_WAIT:
;;;1407   
;;;1408   			if(bleHostProtocolCB.sendCmd.Flag)
;;;1409   			{
;;;1410   				// 及时注销定时器
;;;1411   //				TIMER_KillTask(TIMER_ID_BLE_SEND_CMD);
;;;1412   				
;;;1413   				// 设置发送命令标志位
;;;1414   				bleHostProtocolCB.sendCmd.Flag = FALSE;
;;;1415   				
;;;1416   				// 跳转到空闲
;;;1417   				BLE_SendCmdSwitchStep(BLE_SEND_CMD_IDE);
;;;1418   
;;;1419   				// 当前命令帧发送完时，删除之
;;;1420   				bleHostProtocolCB.ttmTx.cmdQueue[head].length = 0;
;;;1421   				bleHostProtocolCB.ttmTx.head ++;
;;;1422   				bleHostProtocolCB.ttmTx.head %= BLE_HOST_PROTOCOL_TX_QUEUE_SIZE;
000018  2405              MOVS     r4,#5
00001a  2e04              CMP      r6,#4                 ;1346
00001c  d24f              BCS      |L34.190|
00001e  e8dff006          TBB      [pc,r6]               ;1346
000022  0209              DCB      0x02,0x09
000024  3250              DCB      0x32,0x50
000026  428a              CMP      r2,r1                 ;1352
000028  d049              BEQ      |L34.190|
00002a  e8bd41f0          POP      {r4-r8,lr}            ;1358
00002e  2001              MOVS     r0,#1                 ;1358
000030  f7ffbffe          B.W      BLE_SendCmdSwitchStep
000034  f8853728          STRB     r3,[r5,#0x728]        ;1366
000038  eb020182          ADD      r1,r2,r2,LSL #2       ;1372
00003c  eb0101c2          ADD      r1,r1,r2,LSL #3       ;1372
000040  eb0504c1          ADD      r4,r5,r1,LSL #3       ;1372
000044  e00b              B        |L34.94|
                  |L34.70|
000046  f8b50702          LDRH     r0,[r5,#0x702]        ;1372  ; bleHostProtocolCB
00004a  1c41              ADDS     r1,r0,#1              ;1372
00004c  4420              ADD      r0,r0,r4              ;1372
00004e  f8a51702          STRH     r1,[r5,#0x702]        ;1372
000052  f89004f8          LDRB     r0,[r0,#0x4f8]        ;1372
000056  f7fffffe          BL       BLE_HOST_UART_BC_SendData
00005a  f8b50702          LDRH     r0,[r5,#0x702]        ;1374  ; bleHostProtocolCB
                  |L34.94|
00005e  f8b4155c          LDRH     r1,[r4,#0x55c]        ;1369
000062  4281              CMP      r1,r0                 ;1369
000064  d8ef              BHI      |L34.70|
000066  f8b404f6          LDRH     r0,[r4,#0x4f6]        ;1377
00006a  2801              CMP      r0,#1                 ;1377
00006c  d006              BEQ      |L34.124|
00006e  2802              CMP      r0,#2                 ;1378
000070  d004              BEQ      |L34.124|
000072  e8bd41f0          POP      {r4-r8,lr}            ;1401
000076  2002              MOVS     r0,#2                 ;1401
000078  f7ffbffe          B.W      BLE_SendCmdSwitchStep
                  |L34.124|
00007c  e8bd41f0          POP      {r4-r8,lr}            ;1389
000080  2004              MOVS     r0,#4                 ;1389
000082  f7ffbffe          B.W      BLE_SendCmdSwitchStep
000086  f8950728          LDRB     r0,[r5,#0x728]        ;1408  ; bleHostProtocolCB
00008a  2800              CMP      r0,#0                 ;1408
00008c  d017              BEQ      |L34.190|
00008e  f8853728          STRB     r3,[r5,#0x728]        ;1414
000092  2000              MOVS     r0,#0                 ;1417
000094  f7fffffe          BL       BLE_SendCmdSwitchStep
000098  eb020082          ADD      r0,r2,r2,LSL #2       ;1420
00009c  eb0000c2          ADD      r0,r0,r2,LSL #3       ;1420
0000a0  eb0500c0          ADD      r0,r5,r0,LSL #3       ;1420
0000a4  f8a0355c          STRH     r3,[r0,#0x55c]        ;1420
0000a8  f20565fe          ADD      r5,r5,#0x6fe          ;1421
0000ac  8828              LDRH     r0,[r5,#0]            ;1421  ; bleHostProtocolCB
0000ae  1c40              ADDS     r0,r0,#1              ;1421
0000b0  b280              UXTH     r0,r0                 ;1421
0000b2  fbb0f1f4          UDIV     r1,r0,r4
0000b6  fb040011          MLS      r0,r4,r1,r0
0000ba  8028              STRH     r0,[r5,#0]
;;;1423   				bleHostProtocolCB.ttmTx.index = 0;
0000bc  80ab              STRH     r3,[r5,#4]
                  |L34.190|
;;;1424   			}
;;;1425   			
;;;1426   		 	break;
;;;1427   		
;;;1428   		// 发送命令 等待超时
;;;1429   		case BLE_SEND_CMD_TIMOUT:
;;;1430   			
;;;1431   			// 跳转到空闲
;;;1432   			BLE_SendCmdSwitchStep(BLE_SEND_CMD_IDE);
;;;1433   
;;;1434   			// 设置发送命令标志位
;;;1435   			bleHostProtocolCB.sendCmd.Flag = FALSE;
;;;1436   			
;;;1437   			// 当前命令帧发送完时，删除之
;;;1438   			bleHostProtocolCB.ttmTx.cmdQueue[head].length = 0;
;;;1439   			bleHostProtocolCB.ttmTx.head ++;
;;;1440   			bleHostProtocolCB.ttmTx.head %= BLE_HOST_PROTOCOL_TX_QUEUE_SIZE;
;;;1441   			bleHostProtocolCB.ttmTx.index = 0;
;;;1442   			break;
;;;1443   
;;;1444   		// 延时等待
;;;1445   		case BLE_SEND_CMD_DELAY:
;;;1446   			break;
;;;1447   			
;;;1448   		default: 
;;;1449   			break;
;;;1450   	}
;;;1451   }
0000be  e8bd81f0          POP      {r4-r8,pc}
0000c2  2000              MOVS     r0,#0                 ;1432
0000c4  f7fffffe          BL       BLE_SendCmdSwitchStep
0000c8  f8853728          STRB     r3,[r5,#0x728]        ;1435
0000cc  eb020082          ADD      r0,r2,r2,LSL #2       ;1438
0000d0  eb0000c2          ADD      r0,r0,r2,LSL #3       ;1438
0000d4  eb0500c0          ADD      r0,r5,r0,LSL #3       ;1438
0000d8  f8a0355c          STRH     r3,[r0,#0x55c]        ;1438
0000dc  f20565fe          ADD      r5,r5,#0x6fe          ;1439
0000e0  8828              LDRH     r0,[r5,#0]            ;1439  ; bleHostProtocolCB
0000e2  1c40              ADDS     r0,r0,#1              ;1439
0000e4  b280              UXTH     r0,r0                 ;1439
0000e6  fbb0f1f4          UDIV     r1,r0,r4              ;1440
0000ea  fb040011          MLS      r0,r4,r1,r0           ;1440
0000ee  8028              STRH     r0,[r5,#0]            ;1440
0000f0  80ab              STRH     r3,[r5,#4]            ;1441
0000f2  e7e4              B        |L34.190|
;;;1452   
                          ENDP

                  |L34.244|
                          DCD      ||.bss||

                          AREA ||i.BLE_SendCmdSwitchStep||, CODE, READONLY, ALIGN=2

                  BLE_SendCmdSwitchStep PROC
;;;1333   // 切换发送命令工作步骤
;;;1334   void BLE_SendCmdSwitchStep(uint32 param)
000000  4901              LDR      r1,|L35.8|
;;;1335   {
;;;1336   	bleHostProtocolCB.sendCmd.sendCmdStep = (BLE_SEND_CMD_STEP)param;
000002  f8810720          STRB     r0,[r1,#0x720]
;;;1337   }
000006  4770              BX       lr
;;;1338   
                          ENDP

                  |L35.8|
                          DCD      ||.bss||

                          AREA ||i.BLE_SwitchPairMode||, CODE, READONLY, ALIGN=2

                  BLE_SwitchPairMode PROC
;;;1685   // 切换成配对模式
;;;1686   BOOL BLE_SwitchPairMode(BLE_PAIR_DEVICE device)
000000  b510              PUSH     {r4,lr}
;;;1687   {
;;;1688   	if (BLE_PAIR_STANDBY != bleHostProtocolCB.pair.state)
000002  4912              LDR      r1,|L36.76|
000004  f8912704          LDRB     r2,[r1,#0x704]  ; bleHostProtocolCB
000008  2a01              CMP      r2,#1
00000a  d001              BEQ      |L36.16|
;;;1689   	{
;;;1690   		return FALSE;
00000c  2000              MOVS     r0,#0
;;;1691   	}
;;;1692   
;;;1693   	switch (device)
;;;1694   	{
;;;1695   		case BLE_HELMET_DEVICE:
;;;1696   
;;;1697   			// 已连接状态不进行配对
;;;1698   			if (PARAM_GetHelmetConnectState())
;;;1699   			{
;;;1700   				return FALSE;
;;;1701   			}
;;;1702   
;;;1703   			// 进入配对状态后取消之前的配对
;;;1704   			PARAM_SetHelmetPairState(FALSE);
;;;1705   			break;
;;;1706   
;;;1707   		case BLE_LOCK_DEVICE:
;;;1708   
;;;1709   			// 已连接状态不进行配对
;;;1710   			if (PARAM_GetLockConnectState())
;;;1711   			{
;;;1712   				return FALSE;
;;;1713   			}
;;;1714   
;;;1715   			// 进入配对状态后取消之前的配对
;;;1716   			PARAM_SetLockPairState(FALSE);
;;;1717   			break;
;;;1718   
;;;1719   		default:
;;;1720   
;;;1721   			break;
;;;1722   	}
;;;1723   		
;;;1724   	bleHostProtocolCB.pair.count = 0;
;;;1725   	bleHostProtocolCB.pair.scanFlag = FALSE;
;;;1726   	bleHostProtocolCB.pair.device = device;
;;;1727   	bleHostProtocolCB.pair.mode = BLE_PAIR_MODE;
;;;1728   
;;;1729   //	TIMER_KillTask(TIMER_ID_BLE_HELMET_PAIR);
;;;1730   //	TIMER_KillTask(TIMER_ID_BLE_LOCK_PAIR);
;;;1731   	
;;;1732   	return TRUE;
;;;1733   }
00000e  bd10              POP      {r4,pc}
                  |L36.16|
000010  4b0f              LDR      r3,|L36.80|
000012  2200              MOVS     r2,#0                 ;1698
000014  b110              CBZ      r0,|L36.28|
000016  2801              CMP      r0,#1                 ;1693
000018  d10f              BNE      |L36.58|
00001a  e007              B        |L36.44|
                  |L36.28|
00001c  f893420d          LDRB     r4,[r3,#0x20d]        ;1698  ; paramCB
000020  b10c              CBZ      r4,|L36.38|
000022  2000              MOVS     r0,#0                 ;1700
000024  bd10              POP      {r4,pc}
                  |L36.38|
000026  f88322e2          STRB     r2,[r3,#0x2e2]        ;1704
00002a  e006              B        |L36.58|
                  |L36.44|
00002c  f893420f          LDRB     r4,[r3,#0x20f]        ;1710  ; paramCB
000030  b10c              CBZ      r4,|L36.54|
000032  2000              MOVS     r0,#0                 ;1712
000034  bd10              POP      {r4,pc}
                  |L36.54|
000036  f88322f7          STRB     r2,[r3,#0x2f7]        ;1716
                  |L36.58|
00003a  f2017106          ADD      r1,r1,#0x706          ;1724
00003e  754a              STRB     r2,[r1,#0x15]         ;1724
000040  758a              STRB     r2,[r1,#0x16]         ;1725
000042  7008              STRB     r0,[r1,#0]            ;1726
000044  2001              MOVS     r0,#1                 ;1727
000046  75c8              STRB     r0,[r1,#0x17]         ;1727
000048  bd10              POP      {r4,pc}
;;;1734   
                          ENDP

00004a  0000              DCW      0x0000
                  |L36.76|
                          DCD      ||.bss||
                  |L36.80|
                          DCD      paramCB

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  bleHostProtocolCB
                          %        1836

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

000000  54544d3a          DCB      0x54,0x54,0x4d,0x3a
000004  44495343          DCB      0x44,0x49,0x53,0x43
000008  4f4e4e45          DCB      0x4f,0x4e,0x4e,0x45
00000c  43543d35          DCB      0x43,0x54,0x3d,0x35
000010  353a3334          DCB      0x35,0x3a,0x33,0x34
000014  3a46463a          DCB      0x3a,0x46,0x46,0x3a
000018  39333a35          DCB      0x39,0x33,0x3a,0x35
00001c  383a3434          DCB      0x38,0x3a,0x34,0x34
000020  0d0a0000          DCB      0x0d,0x0a,0x00,0x00
                          %        64
000064  54544d3a          DCB      0x54,0x54,0x4d,0x3a
000068  434f4e4e          DCB      0x43,0x4f,0x4e,0x4e
00006c  4543543d          DCB      0x45,0x43,0x54,0x3d
000070  35353a33          DCB      0x35,0x35,0x3a,0x33
000074  343a4646          DCB      0x34,0x3a,0x46,0x46
000078  3a39333a          DCB      0x3a,0x39,0x33,0x3a
00007c  35383a34          DCB      0x35,0x38,0x3a,0x34
000080  342c3636          DCB      0x34,0x2c,0x36,0x36
000084  2c31330d          DCB      0x2c,0x31,0x33,0x0d
000088  0a000000          DCB      0x0a,0x00,0x00,0x00
                          %        60
0000c8  54544d3a          DCB      0x54,0x54,0x4d,0x3a
0000cc  44495343          DCB      0x44,0x49,0x53,0x43
0000d0  4f4e4e45          DCB      0x4f,0x4e,0x4e,0x45
0000d4  43543d37          DCB      0x43,0x54,0x3d,0x37
0000d8  433a3639          DCB      0x43,0x3a,0x36,0x39
0000dc  3a36423a          DCB      0x3a,0x36,0x42,0x3a
0000e0  35323a32          DCB      0x35,0x32,0x3a,0x32
0000e4  343a3234          DCB      0x34,0x3a,0x32,0x34
0000e8  0d0a0000          DCB      0x0d,0x0a,0x00,0x00
                          %        64
00012c  54544d3a          DCB      0x54,0x54,0x4d,0x3a
000130  434f4e4e          DCB      0x43,0x4f,0x4e,0x4e
000134  4543543d          DCB      0x45,0x43,0x54,0x3d
000138  37433a36          DCB      0x37,0x43,0x3a,0x36
00013c  393a3642          DCB      0x39,0x3a,0x36,0x42
000140  3a35323a          DCB      0x3a,0x35,0x32,0x3a
000144  32343a32          DCB      0x32,0x34,0x3a,0x32
000148  342c3137          DCB      0x34,0x2c,0x31,0x37
00014c  2c31330d          DCB      0x2c,0x31,0x33,0x0d
000150  0a000000          DCB      0x0a,0x00,0x00,0x00
                          %        60
000190  54544d3a          DCB      0x54,0x54,0x4d,0x3a
000194  5343414e          DCB      0x53,0x43,0x41,0x4e
000198  3d312c35          DCB      0x3d,0x31,0x2c,0x35
00019c  0d0a0000          DCB      0x0d,0x0a,0x00,0x00
                          %        84
0001f4  54544d3a          DCB      0x54,0x54,0x4d,0x3a
0001f8  434f4e4e          DCB      0x43,0x4f,0x4e,0x4e
0001fc  4543543d          DCB      0x45,0x43,0x54,0x3d
000200  37433a36          DCB      0x37,0x43,0x3a,0x36
000204  393a3642          DCB      0x39,0x3a,0x36,0x42
000208  3a35323a          DCB      0x3a,0x35,0x32,0x3a
00020c  32343a32          DCB      0x32,0x34,0x3a,0x32
000210  342c3137          DCB      0x34,0x2c,0x31,0x37
000214  2c31330d          DCB      0x2c,0x31,0x33,0x0d
000218  0a000000          DCB      0x0a,0x00,0x00,0x00
                          %        60

;*** Start embedded assembler ***

#line 1 "User\\BleHostProtocol.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___17_BleHostProtocol_c_1225c4d8____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___17_BleHostProtocol_c_1225c4d8____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___17_BleHostProtocol_c_1225c4d8____REVSH|
#line 128
|__asm___17_BleHostProtocol_c_1225c4d8____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
