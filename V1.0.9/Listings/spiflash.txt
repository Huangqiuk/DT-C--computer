; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\spiflash.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\spiflash.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -I.\User\qrencode -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.3\Device\Include -D__MICROLIB -D__UVISION_VERSION=539 -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\spiflash.crf User\spiflash.c]
                          THUMB

                          AREA ||i.DMA0_Channel1_IRQHandler||, CODE, READONLY, ALIGN=2

                  DMA0_Channel1_IRQHandler PROC
;;;841    // DMA接收中断RX
;;;842    void DMA0_Channel1_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;843    {
;;;844        if (dma_interrupt_flag_get(DMA0, DMA_CH1, DMA_INT_FLAG_FTF))
000002  4c0f              LDR      r4,|L1.64|
000004  2202              MOVS     r2,#2
000006  2101              MOVS     r1,#1
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       dma_interrupt_flag_get
00000e  2800              CMP      r0,#0
000010  d014              BEQ      |L1.60|
;;;845        {
;;;846    #if STM32_DMA_SPI_DIRECTION
;;;847            dma_interrupt_flag_clear(DMA0, DMA_CH1, DMA_INT_FLAG_FTF);
000012  2202              MOVS     r2,#2
000014  2101              MOVS     r1,#1
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       dma_interrupt_flag_clear
;;;848    
;;;849            // 禁止SPI
;;;850            // spi_disable(STM32_SPIx_NUM_DEF);
;;;851            // 关闭接收DMA
;;;852            dma_channel_disable(DMA0, DMA_CH1);
00001c  2101              MOVS     r1,#1
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       dma_channel_disable
;;;853    
;;;854            // 禁止接收TC中断
;;;855            dma_interrupt_disable(DMA0, DMA_CH1, DMA_INT_FTF);
000024  2202              MOVS     r2,#2
000026  2101              MOVS     r1,#1
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       dma_interrupt_disable
;;;856    
;;;857            SPI_FLASH_CS_H(); // 结束片选
00002e  2102              MOVS     r1,#2
000030  4804              LDR      r0,|L1.68|
000032  f7fffffe          BL       gpio_bit_set
;;;858    
;;;859            // 设置DMA完成标识
;;;860            spiCB.dmaFinished = TRUE;
000036  4904              LDR      r1,|L1.72|
000038  2001              MOVS     r0,#1
00003a  7008              STRB     r0,[r1,#0]
                  |L1.60|
;;;861    #else
;;;862    
;;;863            dma_interrupt_flag_clear(DMA0, DMA_CH1, DMA_INT_FLAG_FTF);
;;;864            // 注意:当设置模式为双线只接收或单线接收模式下，不能在此加入忙BSY的判断死等，此时该标志已失效
;;;865            // 传输的完成就已经是彻底的接收完成，无需别的动作
;;;866    
;;;867            // 禁止SPI
;;;868            spi_disable(STM32_SPIx_NUM_DEF);
;;;869            // 关闭接收DMA
;;;870            dma_channel_disable(DMA0, DMA_CH1);
;;;871            // 禁止接收TC中断
;;;872            dma_interrupt_disable(DMA0, DMA_CH1, DMA_INT_FTF);
;;;873    
;;;874            SPI_FLASH_CS_H(); // 结束片选
;;;875    
;;;876            // 设置DMA完成标识
;;;877            spiCB.dmaFinished = TRUE;
;;;878    #endif
;;;879        }
;;;880    }
00003c  bd10              POP      {r4,pc}
;;;881    
                          ENDP

00003e  0000              DCW      0x0000
                  |L1.64|
                          DCD      0x40020000
                  |L1.68|
                          DCD      0x40011800
                  |L1.72|
                          DCD      ||.data||+0x4

                          AREA ||i.DMA0_Channel2_IRQHandler||, CODE, READONLY, ALIGN=2

                  DMA0_Channel2_IRQHandler PROC
;;;882    // DMA发送中断TX
;;;883    void DMA0_Channel2_IRQHandler(void)
000000  b570              PUSH     {r4-r6,lr}
;;;884    {
;;;885        if (dma_interrupt_flag_get(DMA0, DMA_CH2, DMA_INT_FLAG_FTF))
000002  4c10              LDR      r4,|L2.68|
000004  2202              MOVS     r2,#2
000006  4611              MOV      r1,r2
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       dma_interrupt_flag_get
00000e  2800              CMP      r0,#0
000010  d017              BEQ      |L2.66|
;;;886        {
;;;887            dma_interrupt_flag_clear(DMA0, DMA_CH2, DMA_INT_FLAG_FTF);
000012  2202              MOVS     r2,#2
000014  4611              MOV      r1,r2
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       dma_interrupt_flag_clear
;;;888    
;;;889            // 注意:上面为止DMA已经将所有的数据搬运到SPI_DR，但是，但是，但是实际上SPI数据还没全发送出去
;;;890            // 因此，软件等待忙标志，确保所有数据都发送出去才能将其关闭
;;;891            while (spi_i2s_flag_get(STM32_SPIx_NUM_DEF, I2S_FLAG_TRANS) != RESET)
00001c  4d0a              LDR      r5,|L2.72|
                  |L2.30|
00001e  2180              MOVS     r1,#0x80
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       spi_i2s_flag_get
000026  2800              CMP      r0,#0
000028  d1f9              BNE      |L2.30|
;;;892                ;
;;;893    
;;;894            // 关闭发送DMA
;;;895            spi_dma_disable(SPI0, SPI_DMA_TRANSMIT);
00002a  2100              MOVS     r1,#0
00002c  4807              LDR      r0,|L2.76|
00002e  f7fffffe          BL       spi_dma_disable
;;;896            // 关闭发送TC中断
;;;897            dma_interrupt_disable(DMA0, DMA_CH2, DMA_INT_FTF);
000032  2202              MOVS     r2,#2
000034  4611              MOV      r1,r2
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       dma_interrupt_disable
;;;898    
;;;899    #if STM32_DMA_SPI_DIRECTION
;;;900            spiCB.tx_dmaFinished = TRUE;
00003c  4904              LDR      r1,|L2.80|
00003e  2001              MOVS     r0,#1
000040  7048              STRB     r0,[r1,#1]
                  |L2.66|
;;;901    #endif
;;;902        }
;;;903    }
000042  bd70              POP      {r4-r6,pc}
;;;904    
                          ENDP

                  |L2.68|
                          DCD      0x40020000
                  |L2.72|
                          DCD      0x40003c00
                  |L2.76|
                          DCD      0x40013000
                  |L2.80|
                          DCD      ||.data||+0x4

                          AREA ||i.DMAy_SPIx_Configuration||, CODE, READONLY, ALIGN=2

                  DMAy_SPIx_Configuration PROC
;;;779    // DMA硬件初始化
;;;780    void DMAy_SPIx_Configuration(void)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;781    {
;;;782        static uint16 txByte = 0xFF; // 初始一个虚拟地址
;;;783        static uint16 rxByte = 0xFF; // 初始一个虚拟地址
;;;784    
;;;785        // 使能时钟DMAy
;;;786        rcu_periph_clock_enable(RCU_DMA0);
000004  f44f60a0          MOV      r0,#0x500
000008  f7fffffe          BL       rcu_periph_clock_enable
;;;787    
;;;788        // SPIx Rx DMA
;;;789        dma_deinit(DMA0, DMA_CH1);
00000c  f8df90e0          LDR      r9,|L3.240|
000010  2101              MOVS     r1,#1
000012  4648              MOV      r0,r9
000014  f7fffffe          BL       dma_deinit
;;;790        dma_rx_init_struct.periph_addr = STM32_SPIx_DR_Addr;          // 设置SPI发送外设地址(源地址)
000018  4c37              LDR      r4,|L3.248|
00001a  f8df80d8          LDR      r8,|L3.244|
00001e  f8c48000          STR      r8,[r4,#0]  ; dma_rx_init_struct
;;;791        dma_rx_init_struct.memory_addr = (uint32)(&rxByte);           // 设置SRAM存储地址(目的地址)
000022  4836              LDR      r0,|L3.252|
000024  60a0              STR      r0,[r4,#8]  ; dma_rx_init_struct
;;;792        dma_rx_init_struct.direction = DMA_PERIPHERAL_TO_MEMORY;      // 传输方向外设-内存
000026  2500              MOVS     r5,#0
000028  76a5              STRB     r5,[r4,#0x1a]
;;;793        dma_rx_init_struct.number = 0;                                // 设置SPI发送长度
00002a  6125              STR      r5,[r4,#0x10]  ; dma_rx_init_struct
;;;794        dma_rx_init_struct.periph_inc = DMA_PERIPH_INCREASE_DISABLE;  // 外设地址不增加
00002c  7625              STRB     r5,[r4,#0x18]
;;;795        dma_rx_init_struct.memory_inc = DMA_MEMORY_INCREASE_DISABLE;  // 内存地址不增加
00002e  7665              STRB     r5,[r4,#0x19]
;;;796        dma_rx_init_struct.periph_width = DMA_PERIPHERAL_WIDTH_16BIT; // 外设的传输数据宽度16位
000030  f44f7780          MOV      r7,#0x100
000034  6067              STR      r7,[r4,#4]  ; dma_rx_init_struct
;;;797        dma_rx_init_struct.memory_width = DMA_MEMORY_WIDTH_16BIT;     // 存储器的传输数据宽度16位
000036  00be              LSLS     r6,r7,#2
000038  60e6              STR      r6,[r4,#0xc]  ; dma_rx_init_struct
;;;798        dma_circulation_disable(DMA0, DMA_CH1);                       // 不循环
00003a  2101              MOVS     r1,#1
00003c  4648              MOV      r0,r9
00003e  f7fffffe          BL       dma_circulation_disable
;;;799        dma_rx_init_struct.priority = DMA_PRIORITY_ULTRA_HIGH;        // 通道优先级为高
000042  f44f5040          MOV      r0,#0x3000
000046  6160              STR      r0,[r4,#0x14]  ; dma_rx_init_struct
;;;800        dma_memory_to_memory_disable(DMA0, DMA_CH1);                  // 失能内存到内存模式
000048  2101              MOVS     r1,#1
00004a  4648              MOV      r0,r9
00004c  f7fffffe          BL       dma_memory_to_memory_disable
;;;801        dma_init(DMA0, DMA_CH1, &dma_rx_init_struct);                 // 初始化DMA0
000050  4622              MOV      r2,r4
000052  2101              MOVS     r1,#1
000054  4648              MOV      r0,r9
000056  f7fffffe          BL       dma_init
;;;802    
;;;803        // SPIx Tx DMA
;;;804        dma_deinit(DMA0, DMA_CH2);
00005a  2102              MOVS     r1,#2
00005c  4648              MOV      r0,r9
00005e  f7fffffe          BL       dma_deinit
;;;805        dma_tx_init_struct.periph_addr = STM32_SPIx_DR_Addr;          // 设置SPI发送外设地址(源地址)
000062  3c1c              SUBS     r4,r4,#0x1c
000064  f8c48000          STR      r8,[r4,#0]  ; dma_tx_init_struct
;;;806        dma_tx_init_struct.memory_addr = (uint32)(&txByte);           // 设置SRAM存储地址(目的地址)
000068  4824              LDR      r0,|L3.252|
00006a  1e80              SUBS     r0,r0,#2
00006c  60a0              STR      r0,[r4,#8]  ; dma_tx_init_struct
;;;807        dma_tx_init_struct.direction = DMA_MEMORY_TO_PERIPHERAL;      // 传输方向内存-外设
00006e  2001              MOVS     r0,#1
000070  76a0              STRB     r0,[r4,#0x1a]
;;;808        dma_tx_init_struct.number = 0;                                // 设置SPI发送长度
000072  6125              STR      r5,[r4,#0x10]  ; dma_tx_init_struct
;;;809        dma_tx_init_struct.periph_inc = DMA_PERIPH_INCREASE_DISABLE;  // 外设地址不增加
000074  7625              STRB     r5,[r4,#0x18]
;;;810        dma_tx_init_struct.memory_inc = DMA_MEMORY_INCREASE_DISABLE;  // 内存地址不增加
000076  7665              STRB     r5,[r4,#0x19]
;;;811        dma_tx_init_struct.memory_width = DMA_MEMORY_WIDTH_16BIT;     // 存储器的传输数据宽度16位
000078  60e6              STR      r6,[r4,#0xc]  ; dma_tx_init_struct
;;;812        dma_tx_init_struct.periph_width = DMA_PERIPHERAL_WIDTH_16BIT; // 外设的传输数据宽度16位
00007a  6067              STR      r7,[r4,#4]  ; dma_tx_init_struct
;;;813        dma_circulation_disable(DMA0, DMA_CH2);                       // 不循环
00007c  2102              MOVS     r1,#2
00007e  4648              MOV      r0,r9
000080  f7fffffe          BL       dma_circulation_disable
;;;814        dma_tx_init_struct.priority = DMA_PRIORITY_MEDIUM;            // 中断方式
000084  00b0              LSLS     r0,r6,#2
000086  6160              STR      r0,[r4,#0x14]  ; dma_tx_init_struct
;;;815        dma_memory_to_memory_disable(DMA0, DMA_CH2);                  // 失能内存到内存模式
000088  2102              MOVS     r1,#2
00008a  4648              MOV      r0,r9
00008c  f7fffffe          BL       dma_memory_to_memory_disable
;;;816        dma_init(DMA0, DMA_CH2, &dma_tx_init_struct);                 // 初始化DMA0
000090  4622              MOV      r2,r4
000092  2102              MOVS     r1,#2
000094  4648              MOV      r0,r9
000096  f7fffffe          BL       dma_init
;;;817    
;;;818        // 关闭DMA发送/接收中断，清DMA标记，禁止DMA1_TX，RX的传输完成中断
;;;819        spi_dma_disable(STM32_SPIx_NUM_DEF, SPI_DMA_TRANSMIT);
00009a  4c16              LDR      r4,|L3.244|
00009c  2100              MOVS     r1,#0
00009e  3c0c              SUBS     r4,r4,#0xc
0000a0  4620              MOV      r0,r4
0000a2  f7fffffe          BL       spi_dma_disable
;;;820        spi_dma_disable(STM32_SPIx_NUM_DEF, SPI_DMA_RECEIVE);
0000a6  2101              MOVS     r1,#1
0000a8  4620              MOV      r0,r4
0000aa  f7fffffe          BL       spi_dma_disable
;;;821        dma_flag_clear(DMA0, DMA_CH1, DMA_FLAG_G);
0000ae  2201              MOVS     r2,#1
0000b0  4611              MOV      r1,r2
0000b2  4648              MOV      r0,r9
0000b4  f7fffffe          BL       dma_flag_clear
;;;822        dma_flag_clear(DMA0, DMA_CH2, DMA_FLAG_G);
0000b8  2201              MOVS     r2,#1
0000ba  2102              MOVS     r1,#2
0000bc  4648              MOV      r0,r9
0000be  f7fffffe          BL       dma_flag_clear
;;;823        dma_interrupt_disable(DMA0, DMA_CH1, DMA_INT_FTF);
0000c2  2202              MOVS     r2,#2
0000c4  2101              MOVS     r1,#1
0000c6  4648              MOV      r0,r9
0000c8  f7fffffe          BL       dma_interrupt_disable
;;;824        dma_interrupt_disable(DMA0, DMA_CH2, DMA_INT_FTF);
0000cc  2202              MOVS     r2,#2
0000ce  4611              MOV      r1,r2
0000d0  4648              MOV      r0,r9
0000d2  f7fffffe          BL       dma_interrupt_disable
;;;825    
;;;826        // 使能SPIx的DMA发送，接收请求
;;;827        spi_dma_enable(STM32_SPIx_NUM_DEF, SPI_DMA_TRANSMIT);
0000d6  2100              MOVS     r1,#0
0000d8  4620              MOV      r0,r4
0000da  f7fffffe          BL       spi_dma_enable
;;;828        spi_dma_enable(STM32_SPIx_NUM_DEF, SPI_DMA_RECEIVE);
0000de  2101              MOVS     r1,#1
0000e0  4620              MOV      r0,r4
0000e2  f7fffffe          BL       spi_dma_enable
;;;829    
;;;830        // 使能NVIC中断
;;;831        NVIC_DMAy_Configuration();
0000e6  e8bd47f0          POP      {r4-r10,lr}
0000ea  f7ffbffe          B.W      NVIC_DMAy_Configuration
;;;832    }
;;;833    
                          ENDP

0000ee  0000              DCW      0x0000
                  |L3.240|
                          DCD      0x40020000
                  |L3.244|
                          DCD      0x40003c0c
                  |L3.248|
                          DCD      ||.bss||+0x38
                  |L3.252|
                          DCD      ||.data||+0x2

                          AREA ||i.NVIC_DMAy_Configuration||, CODE, READONLY, ALIGN=1

                  NVIC_DMAy_Configuration PROC
;;;834    // 配置DMA通道中断
;;;835    static void NVIC_DMAy_Configuration(void)
000000  b510              PUSH     {r4,lr}
;;;836    {
;;;837        nvic_irq_enable(DMA0_Channel1_IRQn, 2, 0); // 设置中断优先级
000002  2200              MOVS     r2,#0
000004  2102              MOVS     r1,#2
000006  200c              MOVS     r0,#0xc
000008  f7fffffe          BL       nvic_irq_enable
;;;838        nvic_irq_enable(DMA0_Channel2_IRQn, 2, 0); // 设置中断优先级
00000c  2200              MOVS     r2,#0
00000e  2102              MOVS     r1,#2
000010  e8bd4010          POP      {r4,lr}
000014  200d              MOVS     r0,#0xd
000016  f7ffbffe          B.W      nvic_irq_enable
;;;839    }
;;;840    
                          ENDP


                          AREA ||i.SPI_FLASH_EraseBlock||, CODE, READONLY, ALIGN=2

                  SPI_FLASH_EraseBlock PROC
;;;156    // 擦除块
;;;157    void SPI_FLASH_EraseBlock(uint32 BlockAddr)
000000  b570              PUSH     {r4-r6,lr}
;;;158    {
000002  4604              MOV      r4,r0
;;;159        // 使能写入操作
;;;160        SPI_FLASH_WriteEnable();
000004  f7fffffe          BL       SPI_FLASH_WriteEnable
;;;161    
;;;162        // 片选
;;;163        SPI_FLASH_CS_L();
000008  4d0d              LDR      r5,|L5.64|
00000a  2102              MOVS     r1,#2
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       gpio_bit_reset
;;;164    
;;;165        // 发送64K擦除命令
;;;166        SPI_FLASH_SendByte(CMD_BLOCK_ERASE_64K);
000012  20d8              MOVS     r0,#0xd8
000014  f7fffffe          BL       SPI_FLASH_SendByte
;;;167    
;;;168        // 发送24位地址
;;;169        SPI_FLASH_SendByte((BlockAddr & 0xFF0000) >> 16);
000018  f3c44007          UBFX     r0,r4,#16,#8
00001c  f7fffffe          BL       SPI_FLASH_SendByte
;;;170        SPI_FLASH_SendByte((BlockAddr & 0xFF00) >> 8);
000020  f3c42007          UBFX     r0,r4,#8,#8
000024  f7fffffe          BL       SPI_FLASH_SendByte
;;;171        SPI_FLASH_SendByte(BlockAddr & 0xFF);
000028  b2e0              UXTB     r0,r4
00002a  f7fffffe          BL       SPI_FLASH_SendByte
;;;172    
;;;173        // 释放
;;;174        SPI_FLASH_CS_H();
00002e  2102              MOVS     r1,#2
000030  4628              MOV      r0,r5
000032  f7fffffe          BL       gpio_bit_set
;;;175    
;;;176        // 等待写入完成
;;;177        SPI_FLASH_WaitForWriteEnd();
000036  e8bd4070          POP      {r4-r6,lr}
00003a  f7ffbffe          B.W      SPI_FLASH_WaitForWriteEnd
;;;178    }
;;;179    
                          ENDP

00003e  0000              DCW      0x0000
                  |L5.64|
                          DCD      0x40011800

                          AREA ||i.SPI_FLASH_EraseChip||, CODE, READONLY, ALIGN=2

                  SPI_FLASH_EraseChip PROC
;;;180    // 擦除整个Flash
;;;181    void SPI_FLASH_EraseChip(void)
000000  b510              PUSH     {r4,lr}
;;;182    {
;;;183        // 使能写入操作
;;;184        SPI_FLASH_WriteEnable();
000002  f7fffffe          BL       SPI_FLASH_WriteEnable
;;;185    
;;;186        // 片选
;;;187        SPI_FLASH_CS_L();
000006  4c08              LDR      r4,|L6.40|
000008  2102              MOVS     r1,#2
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       gpio_bit_reset
;;;188    
;;;189        // 发送片擦除命令
;;;190        SPI_FLASH_SendByte(CMD_CHIP_ERASE);
000010  20c7              MOVS     r0,#0xc7
000012  f7fffffe          BL       SPI_FLASH_SendByte
;;;191    
;;;192        // 释放
;;;193        SPI_FLASH_CS_H();
000016  2102              MOVS     r1,#2
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       gpio_bit_set
;;;194    
;;;195        // 等待写入完成
;;;196        SPI_FLASH_WaitForWriteEnd();
00001e  e8bd4010          POP      {r4,lr}
000022  f7ffbffe          B.W      SPI_FLASH_WaitForWriteEnd
;;;197    }
;;;198    
                          ENDP

000026  0000              DCW      0x0000
                  |L6.40|
                          DCD      0x40011800

                          AREA ||i.SPI_FLASH_EraseRoom||, CODE, READONLY, ALIGN=1

                  SPI_FLASH_EraseRoom PROC
;;;519    // 擦除指定空间 先擦扇区再擦块再擦扇区
;;;520    void SPI_FLASH_EraseRoom(uint32 Addr, uint32 size)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;521    {
000004  4605              MOV      r5,r0
000006  4688              MOV      r8,r1
;;;522    
;;;523        uint16 blockStartNum = 0;     // 块号
;;;524        uint16 blockCount = 0;        // 需要擦除块的数量
;;;525        uint16 blockSectorOffset = 0; // 块内扇区偏移量
;;;526        uint16 i;
;;;527    
;;;528        blockSectorOffset = Addr / SPI_FLASH_SECTOR_SIZE % SPI_FLASH_BLOCK_PER_16SECTORS;
000008  f3c53003          UBFX     r0,r5,#12,#4
;;;529    
;;;530        if (blockSectorOffset) // 擦除扇区在块内存在偏移量
00000c  2800              CMP      r0,#0
00000e  d004              BEQ      |L7.26|
;;;531        {
;;;532            blockStartNum = Addr / SPI_FLASH_BLOCK_SIZE + 1;
000010  2101              MOVS     r1,#1
000012  eb014115          ADD      r1,r1,r5,LSR #16
000016  b28e              UXTH     r6,r1
000018  e000              B        |L7.28|
                  |L7.26|
;;;533        }
;;;534        else // 擦除开始地址等于块的起始地址，不存在偏移
;;;535        {
;;;536            blockStartNum = Addr / SPI_FLASH_BLOCK_SIZE;
00001a  0c2e              LSRS     r6,r5,#16
                  |L7.28|
;;;537        }
;;;538    
;;;539        // 擦除起始块内扇区偏移
;;;540        for (i = 0; i < SPI_FLASH_BLOCK_PER_16SECTORS - blockSectorOffset; i++)
00001c  2400              MOVS     r4,#0
00001e  f1c00710          RSB      r7,r0,#0x10
000022  e006              B        |L7.50|
                  |L7.36|
;;;541        {
;;;542            SPI_FLASH_EraseSector((Addr / SPI_FLASH_SECTOR_SIZE + i) * SPI_FLASH_SECTOR_SIZE);
000024  eb043015          ADD      r0,r4,r5,LSR #12
000028  0300              LSLS     r0,r0,#12
00002a  f7fffffe          BL       SPI_FLASH_EraseSector
00002e  1c64              ADDS     r4,r4,#1              ;540
000030  b2a4              UXTH     r4,r4                 ;540
                  |L7.50|
000032  42a7              CMP      r7,r4                 ;540
000034  dcf6              BGT      |L7.36|
;;;543        }
;;;544    
;;;545        // 计算出需要擦除的块的数量
;;;546        blockCount = ((size / SPI_FLASH_SECTOR_SIZE) - (SPI_FLASH_BLOCK_PER_16SECTORS - blockSectorOffset)) / SPI_FLASH_BLOCK_PER_16SECTORS;
000036  ebc73718          RSB      r7,r7,r8,LSR #12
00003a  f3c7150f          UBFX     r5,r7,#4,#16
;;;547    
;;;548        // 擦除块
;;;549        for (i = 0; i < blockCount; i++)
00003e  2400              MOVS     r4,#0
000040  e005              B        |L7.78|
                  |L7.66|
;;;550        {
;;;551            SPI_FLASH_EraseBlock((blockStartNum + i) * SPI_FLASH_BLOCK_SIZE);
000042  1930              ADDS     r0,r6,r4
000044  0400              LSLS     r0,r0,#16
000046  f7fffffe          BL       SPI_FLASH_EraseBlock
00004a  1c64              ADDS     r4,r4,#1              ;549
00004c  b2a4              UXTH     r4,r4                 ;549
                  |L7.78|
00004e  42ac              CMP      r4,r5                 ;549
000050  d3f7              BCC      |L7.66|
;;;552        }
;;;553    
;;;554        // 擦除剩余扇区,剩余的扇区不满一个块
;;;555        for (i = 0; i < ((size / SPI_FLASH_SECTOR_SIZE) - (SPI_FLASH_BLOCK_PER_16SECTORS - blockSectorOffset)) % SPI_FLASH_BLOCK_PER_16SECTORS; i++)
000052  2400              MOVS     r4,#0
;;;556        {
;;;557            SPI_FLASH_EraseSector((blockStartNum + blockCount) * SPI_FLASH_BLOCK_SIZE + i * SPI_FLASH_SECTOR_SIZE);
000054  1970              ADDS     r0,r6,r5
000056  0405              LSLS     r5,r0,#16
000058  f007060f          AND      r6,r7,#0xf            ;555
00005c  e005              B        |L7.106|
                  |L7.94|
00005e  eb053004          ADD      r0,r5,r4,LSL #12
000062  f7fffffe          BL       SPI_FLASH_EraseSector
000066  1c64              ADDS     r4,r4,#1              ;555
000068  b2a4              UXTH     r4,r4                 ;555
                  |L7.106|
00006a  42a6              CMP      r6,r4                 ;555
00006c  d8f7              BHI      |L7.94|
;;;558        }
;;;559    }
00006e  e8bd81f0          POP      {r4-r8,pc}
;;;560    
                          ENDP


                          AREA ||i.SPI_FLASH_EraseSector||, CODE, READONLY, ALIGN=2

                  SPI_FLASH_EraseSector PROC
;;;132    // 擦除扇区
;;;133    void SPI_FLASH_EraseSector(uint32 SectorAddr)
000000  b570              PUSH     {r4-r6,lr}
;;;134    {
000002  4604              MOV      r4,r0
;;;135        // 使能写入操作
;;;136        SPI_FLASH_WriteEnable();
000004  f7fffffe          BL       SPI_FLASH_WriteEnable
;;;137    
;;;138        // 片选
;;;139        SPI_FLASH_CS_L();
000008  4d0d              LDR      r5,|L8.64|
00000a  2102              MOVS     r1,#2
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       gpio_bit_reset
;;;140    
;;;141        // 发送扇区擦除命令
;;;142        SPI_FLASH_SendByte(CMD_SECTOR_ERASE_4K);
000012  2020              MOVS     r0,#0x20
000014  f7fffffe          BL       SPI_FLASH_SendByte
;;;143    
;;;144        // 发送24位地址
;;;145        SPI_FLASH_SendByte((SectorAddr & 0xFF0000) >> 16);
000018  f3c44007          UBFX     r0,r4,#16,#8
00001c  f7fffffe          BL       SPI_FLASH_SendByte
;;;146        SPI_FLASH_SendByte((SectorAddr & 0xFF00) >> 8);
000020  f3c42007          UBFX     r0,r4,#8,#8
000024  f7fffffe          BL       SPI_FLASH_SendByte
;;;147        SPI_FLASH_SendByte(SectorAddr & 0xFF);
000028  b2e0              UXTB     r0,r4
00002a  f7fffffe          BL       SPI_FLASH_SendByte
;;;148    
;;;149        // 释放
;;;150        SPI_FLASH_CS_H();
00002e  2102              MOVS     r1,#2
000030  4628              MOV      r0,r5
000032  f7fffffe          BL       gpio_bit_set
;;;151    
;;;152        // 等待写入完成
;;;153        SPI_FLASH_WaitForWriteEnd();
000036  e8bd4070          POP      {r4-r6,lr}
00003a  f7ffbffe          B.W      SPI_FLASH_WaitForWriteEnd
;;;154    }
;;;155    
                          ENDP

00003e  0000              DCW      0x0000
                  |L8.64|
                          DCD      0x40011800

                          AREA ||i.SPI_FLASH_ReadArray||, CODE, READONLY, ALIGN=2

                  SPI_FLASH_ReadArray PROC
;;;362    // 读取数据至指定缓冲区，数据个数最大可以为整片容量
;;;363    void SPI_FLASH_ReadArray(uint8 *pBuffer, uint32 ReadAddr, uint16 NumByteToRead)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;364    {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
;;;365        // 片选
;;;366        SPI_FLASH_CS_H();
00000a  4e16              LDR      r6,|L9.100|
00000c  2102              MOVS     r1,#2
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       gpio_bit_set
;;;367    
;;;368        // 指针非空判断
;;;369        if (NULL == pBuffer)
000014  2c00              CMP      r4,#0
000016  d022              BEQ      |L9.94|
;;;370        {
;;;371            return;
;;;372        }
;;;373    
;;;374        // 要读取的数据量为0，退出
;;;375        if (0 == NumByteToRead)
000018  2d00              CMP      r5,#0
00001a  d020              BEQ      |L9.94|
;;;376        {
;;;377            return;
;;;378        }
;;;379    
;;;380        // 片选
;;;381        SPI_FLASH_CS_L();
00001c  2102              MOVS     r1,#2
00001e  4630              MOV      r0,r6
000020  f7fffffe          BL       gpio_bit_reset
;;;382    
;;;383        // 发送读取命令
;;;384        SPI_FLASH_SendByte(CMD_READ_BYTE);
000024  2003              MOVS     r0,#3
000026  f7fffffe          BL       SPI_FLASH_SendByte
;;;385    
;;;386        // 发送24位起始地址
;;;387        SPI_FLASH_SendByte((ReadAddr & 0xFF0000) >> 16);
00002a  f3c74007          UBFX     r0,r7,#16,#8
00002e  f7fffffe          BL       SPI_FLASH_SendByte
;;;388        SPI_FLASH_SendByte((ReadAddr & 0xFF00) >> 8);
000032  f3c72007          UBFX     r0,r7,#8,#8
000036  f7fffffe          BL       SPI_FLASH_SendByte
;;;389        SPI_FLASH_SendByte(ReadAddr & 0xFF);
00003a  b2f8              UXTB     r0,r7
00003c  f7fffffe          BL       SPI_FLASH_SendByte
;;;390    
;;;391        // 一直读取完指定的数量为止
;;;392        while (NumByteToRead--)
000040  e004              B        |L9.76|
                  |L9.66|
;;;393        {
;;;394            // 读取一个字节
;;;395            *(pBuffer++) = SPI_FLASH_SendByte(0);
000042  2000              MOVS     r0,#0
000044  f7fffffe          BL       SPI_FLASH_SendByte
000048  f8040b01          STRB     r0,[r4],#1
                  |L9.76|
00004c  1e6d              SUBS     r5,r5,#1              ;392
00004e  b2ad              UXTH     r5,r5                 ;392
000050  d2f7              BCS      |L9.66|
;;;396        }
;;;397    
;;;398        // 释放
;;;399        SPI_FLASH_CS_H();
000052  4630              MOV      r0,r6
000054  e8bd41f0          POP      {r4-r8,lr}
000058  2102              MOVS     r1,#2
00005a  f7ffbffe          B.W      gpio_bit_set
                  |L9.94|
;;;400    }
00005e  e8bd81f0          POP      {r4-r8,pc}
;;;401    
                          ENDP

000062  0000              DCW      0x0000
                  |L9.100|
                          DCD      0x40011800

                          AREA ||i.SPI_FLASH_ReadByte||, CODE, READONLY, ALIGN=1

                  SPI_FLASH_ReadByte PROC
;;;334    
;;;335    uint8 SPI_FLASH_ReadByte(uint32 ReadAddr)
000000  b508              PUSH     {r3,lr}
;;;336    {
;;;337        uint8 buff[4];
;;;338    
;;;339        SPI_FLASH_ReadArray(buff, ReadAddr, 4);
000002  4601              MOV      r1,r0
000004  2204              MOVS     r2,#4
000006  4668              MOV      r0,sp
000008  f7fffffe          BL       SPI_FLASH_ReadArray
;;;340    
;;;341        return buff[0];
00000c  f89d0000          LDRB     r0,[sp,#0]
;;;342    }
000010  bd08              POP      {r3,pc}
;;;343    
                          ENDP


                          AREA ||i.SPI_FLASH_ReadChipID||, CODE, READONLY, ALIGN=2

                  SPI_FLASH_ReadChipID PROC
;;;402    // 读取芯片ID
;;;403    uint16 SPI_FLASH_ReadChipID(void)
000000  b570              PUSH     {r4-r6,lr}
;;;404    {
;;;405        uint16 W25xXX_ID = 0;
;;;406    
;;;407        // 使能写入操作
;;;408        SPI_FLASH_WriteEnable();
000002  f7fffffe          BL       SPI_FLASH_WriteEnable
;;;409    
;;;410        SPI_FLASH_CS_L();
000006  4d11              LDR      r5,|L11.76|
000008  2102              MOVS     r1,#2
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       gpio_bit_reset
;;;411    
;;;412        // 发送读取ID命令
;;;413        SPI_FLASH_SendByte(CMD_MANUFACT_DEVICE_ID);
000010  2090              MOVS     r0,#0x90
000012  f7fffffe          BL       SPI_FLASH_SendByte
;;;414    
;;;415        // 发送24位的地址
;;;416        SPI_FLASH_SendByte(0x00); // dummy
000016  2000              MOVS     r0,#0
000018  f7fffffe          BL       SPI_FLASH_SendByte
;;;417        SPI_FLASH_SendByte(0x00); // dummy
00001c  2000              MOVS     r0,#0
00001e  f7fffffe          BL       SPI_FLASH_SendByte
;;;418        SPI_FLASH_SendByte(0x00); // 0x00
000022  2000              MOVS     r0,#0
000024  f7fffffe          BL       SPI_FLASH_SendByte
;;;419    
;;;420        // 读取返回的16位值
;;;421        W25xXX_ID = SPI_FLASH_SendByte(0xFF); // 高8位数据
000028  20ff              MOVS     r0,#0xff
00002a  f7fffffe          BL       SPI_FLASH_SendByte
;;;422        W25xXX_ID <<= 8;
00002e  f64f71ff          MOV      r1,#0xffff
000032  ea012400          AND      r4,r1,r0,LSL #8
;;;423        W25xXX_ID += SPI_FLASH_SendByte(0xFF); // 底8位数据
000036  20ff              MOVS     r0,#0xff
000038  f7fffffe          BL       SPI_FLASH_SendByte
00003c  4420              ADD      r0,r0,r4
00003e  b284              UXTH     r4,r0
;;;424    
;;;425        SPI_FLASH_CS_H();
000040  2102              MOVS     r1,#2
000042  4628              MOV      r0,r5
000044  f7fffffe          BL       gpio_bit_set
;;;426    
;;;427        return W25xXX_ID;
000048  4620              MOV      r0,r4
;;;428    }
00004a  bd70              POP      {r4-r6,pc}
;;;429    
                          ENDP

                  |L11.76|
                          DCD      0x40011800

                          AREA ||i.SPI_FLASH_ReadHalfWord||, CODE, READONLY, ALIGN=1

                  SPI_FLASH_ReadHalfWord PROC
;;;343    
;;;344    uint16 SPI_FLASH_ReadHalfWord(uint32 ReadAddr)
000000  b508              PUSH     {r3,lr}
;;;345    {
;;;346        uint8 buff[4];
;;;347    
;;;348        SPI_FLASH_ReadArray(buff, ReadAddr, 4);
000002  4601              MOV      r1,r0
000004  2204              MOVS     r2,#4
000006  4668              MOV      r0,sp
000008  f7fffffe          BL       SPI_FLASH_ReadArray
;;;349    
;;;350        return ((uint16)buff[0] << 8) + buff[1];
00000c  f89d0001          LDRB     r0,[sp,#1]
000010  f89d1000          LDRB     r1,[sp,#0]
000014  eb002001          ADD      r0,r0,r1,LSL #8
000018  b280              UXTH     r0,r0
;;;351    }
00001a  bd08              POP      {r3,pc}
;;;352    
                          ENDP


                          AREA ||i.SPI_FLASH_ReadWord||, CODE, READONLY, ALIGN=1

                  SPI_FLASH_ReadWord PROC
;;;352    
;;;353    uint32 SPI_FLASH_ReadWord(uint32 ReadAddr)
000000  b508              PUSH     {r3,lr}
;;;354    {
;;;355        uint8 buff[4];
;;;356    
;;;357        SPI_FLASH_ReadArray(buff, ReadAddr, 4);
000002  4601              MOV      r1,r0
000004  2204              MOVS     r2,#4
000006  4668              MOV      r0,sp
000008  f7fffffe          BL       SPI_FLASH_ReadArray
;;;358    
;;;359        return ((uint32)buff[0] << 24) + ((uint32)buff[1] << 16) + ((uint32)buff[2] << 8) + buff[3];
00000c  f89d0003          LDRB     r0,[sp,#3]
000010  f89d1000          LDRB     r1,[sp,#0]
000014  f89d2002          LDRB     r2,[sp,#2]
000018  eb006001          ADD      r0,r0,r1,LSL #24
00001c  f89d1001          LDRB     r1,[sp,#1]
000020  0409              LSLS     r1,r1,#16
000022  eb012102          ADD      r1,r1,r2,LSL #8
000026  4408              ADD      r0,r0,r1
;;;360    }
000028  bd08              POP      {r3,pc}
;;;361    
                          ENDP


                          AREA ||i.SPI_FLASH_SendByte||, CODE, READONLY, ALIGN=2

                  SPI_FLASH_SendByte PROC
;;;430    // 发送一个字节
;;;431    uint8 SPI_FLASH_SendByte(uint8 byte)
000000  b570              PUSH     {r4-r6,lr}
;;;432    {
000002  4605              MOV      r5,r0
;;;433        // 发送寄存器不为空，等待
;;;434        uint16 spiRetryTime = 0;
000004  2400              MOVS     r4,#0
;;;435    
;;;436        while (spi_i2s_flag_get(STM32_SPIx_NUM_DEF, SPI_STAT_TBE) == RESET)
000006  4e14              LDR      r6,|L14.88|
000008  e006              B        |L14.24|
                  |L14.10|
;;;437        {
;;;438            if (spiRetryTime++ > SPI_FLASH_RETRY_READ_TIME)
00000a  4620              MOV      r0,r4
00000c  1c64              ADDS     r4,r4,#1
00000e  b2a4              UXTH     r4,r4
000010  28c8              CMP      r0,#0xc8
000012  d901              BLS      |L14.24|
;;;439            {
;;;440                return 0x00;
000014  2000              MOVS     r0,#0
;;;441            }
;;;442        }
;;;443        // 发送
;;;444        spi_i2s_data_transmit(STM32_SPIx_NUM_DEF, byte);
;;;445    
;;;446        // 接收寄存器为空，等待
;;;447        spiRetryTime = 0;
;;;448        while (spi_i2s_flag_get(STM32_SPIx_NUM_DEF, SPI_STAT_RBNE) == RESET)
;;;449        {
;;;450            if (spiRetryTime++ > SPI_FLASH_RETRY_READ_TIME)
;;;451            {
;;;452                return 0x00;
;;;453            }
;;;454        }
;;;455    
;;;456        // 返回接收到的值
;;;457        return spi_i2s_data_receive(STM32_SPIx_NUM_DEF);
;;;458    }
000016  bd70              POP      {r4-r6,pc}
                  |L14.24|
000018  2102              MOVS     r1,#2                 ;436
00001a  4630              MOV      r0,r6                 ;436
00001c  f7fffffe          BL       spi_i2s_flag_get
000020  2800              CMP      r0,#0                 ;436
000022  d0f2              BEQ      |L14.10|
000024  4629              MOV      r1,r5                 ;444
000026  4635              MOV      r5,r6                 ;444
000028  4628              MOV      r0,r5                 ;444
00002a  f7fffffe          BL       spi_i2s_data_transmit
00002e  2400              MOVS     r4,#0                 ;447
000030  e006              B        |L14.64|
                  |L14.50|
000032  4620              MOV      r0,r4                 ;450
000034  1c64              ADDS     r4,r4,#1              ;450
000036  b2a4              UXTH     r4,r4                 ;450
000038  28c8              CMP      r0,#0xc8              ;450
00003a  d901              BLS      |L14.64|
00003c  2000              MOVS     r0,#0                 ;452
00003e  bd70              POP      {r4-r6,pc}
                  |L14.64|
000040  2101              MOVS     r1,#1                 ;448
000042  4628              MOV      r0,r5                 ;448
000044  f7fffffe          BL       spi_i2s_flag_get
000048  2800              CMP      r0,#0                 ;448
00004a  d0f2              BEQ      |L14.50|
00004c  4628              MOV      r0,r5                 ;457
00004e  f7fffffe          BL       spi_i2s_data_receive
000052  b2c0              UXTB     r0,r0                 ;457
000054  bd70              POP      {r4-r6,pc}
;;;459    
                          ENDP

000056  0000              DCW      0x0000
                  |L14.88|
                          DCD      0x40003c00

                          AREA ||i.SPI_FLASH_WaitForWriteEnd||, CODE, READONLY, ALIGN=2

                  SPI_FLASH_WaitForWriteEnd PROC
;;;496    // 等待写入操作完成
;;;497    void SPI_FLASH_WaitForWriteEnd(void)
000000  b510              PUSH     {r4,lr}
;;;498    {
;;;499        uint8 flashstatus = 0;
;;;500    
;;;501        // 片选
;;;502        SPI_FLASH_CS_L();
000002  4c09              LDR      r4,|L15.40|
000004  2102              MOVS     r1,#2
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       gpio_bit_reset
;;;503    
;;;504        // 发送读取状态寄存器1的命令
;;;505        SPI_FLASH_SendByte(CMD_READ_STATUS_REGISTER1);
00000c  2005              MOVS     r0,#5
00000e  f7fffffe          BL       SPI_FLASH_SendByte
                  |L15.18|
;;;506    
;;;507        // 写入中，持续等待
;;;508        do
;;;509        {
;;;510            // 发送一个假数据，即可产生SPI时钟
;;;511            flashstatus = SPI_FLASH_SendByte(0);
000012  2000              MOVS     r0,#0
000014  f7fffffe          BL       SPI_FLASH_SendByte
;;;512        }
;;;513        while ((flashstatus & BUSY_FLAG) == BUSY_FLAG);
000018  07c0              LSLS     r0,r0,#31
00001a  d1fa              BNE      |L15.18|
;;;514    
;;;515        // 释放
;;;516        SPI_FLASH_CS_H();
00001c  4620              MOV      r0,r4
00001e  e8bd4010          POP      {r4,lr}
000022  2102              MOVS     r1,#2
000024  f7ffbffe          B.W      gpio_bit_set
;;;517    }
;;;518    
                          ENDP

                  |L15.40|
                          DCD      0x40011800

                          AREA ||i.SPI_FLASH_WriteArray||, CODE, READONLY, ALIGN=1

                  SPI_FLASH_WriteArray PROC
;;;238    // 将指定缓冲区的数据写入指定开始地址的区域
;;;239    void SPI_FLASH_WriteArray(uint8 *pBuffer, uint32 WriteAddr, uint16 NumByteToWrite)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;240    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4690              MOV      r8,r2
;;;241        uint8 NumOfPage = 0, NumOfRestByte = 0, StartAddrOffset = 0, RestSpace = 0, temp = 0;
;;;242    
;;;243        // 指针非空判断
;;;244        if (NULL == pBuffer)
00000a  2d00              CMP      r5,#0
00000c  d065              BEQ      |L16.218|
;;;245        {
;;;246            return;
;;;247        }
;;;248    
;;;249        // 写入数据量为0，退出
;;;250        if (0 == NumByteToWrite)
00000e  f1b80f00          CMP      r8,#0
000012  d062              BEQ      |L16.218|
;;;251        {
;;;252            return;
;;;253        }
;;;254    
;;;255        StartAddrOffset = WriteAddr % SPI_FLASH_PAGE_SIZE;
000014  b2f0              UXTB     r0,r6
;;;256        RestSpace = SPI_FLASH_PAGE_SIZE - StartAddrOffset;
000016  4241              RSBS     r1,r0,#0
000018  b2cf              UXTB     r7,r1
;;;257        NumOfPage = NumByteToWrite / SPI_FLASH_PAGE_SIZE;
00001a  ea4f2418          LSR      r4,r8,#8
;;;258        NumOfRestByte = NumByteToWrite % SPI_FLASH_PAGE_SIZE;
00001e  f0080aff          AND      r10,r8,#0xff
;;;259    
;;;260        // 起始地址刚好位于当前页的起点
;;;261        if (StartAddrOffset == 0)
;;;262        {
;;;263            // 数据量不足一页，直接写入
;;;264            if (NumOfPage == 0)
;;;265            {
;;;266                SPI_FLASH_WritePage(pBuffer, WriteAddr, NumByteToWrite);
;;;267            }
;;;268            // 数据量超出一页
;;;269            else
;;;270            {
;;;271                // 整页的部分，直接写入整页
;;;272                while (NumOfPage--)
;;;273                {
;;;274                    // 在当前页写满
;;;275                    SPI_FLASH_WritePage(pBuffer, WriteAddr, SPI_FLASH_PAGE_SIZE);
000022  f44f7980          MOV      r9,#0x100
000026  b190              CBZ      r0,|L16.78|
000028  b2f0              UXTB     r0,r6                 ;255
00002a  4240              RSBS     r0,r0,#0              ;256
00002c  b2c0              UXTB     r0,r0                 ;256
;;;276    
;;;277                    WriteAddr += SPI_FLASH_PAGE_SIZE;
;;;278                    pBuffer += SPI_FLASH_PAGE_SIZE;
;;;279                }
;;;280    
;;;281                // 写入不足一页的部分
;;;282                SPI_FLASH_WritePage(pBuffer, WriteAddr, NumOfRestByte);
;;;283            }
;;;284        }
;;;285        // 起始地址不是当前页的起点，即从中间插入写入
;;;286        else
;;;287        {
;;;288            // 数据量不足一页，直接写入
;;;289            if (NumOfPage == 0)
;;;290            {
;;;291                // 要写入的数据量超过了当前页剩余空间，则分开两次写入
;;;292                if (NumOfRestByte > RestSpace)
;;;293                {
;;;294                    // 先将当前页填满
;;;295                    temp = NumOfRestByte - RestSpace;
;;;296    
;;;297                    SPI_FLASH_WritePage(pBuffer, WriteAddr, RestSpace);
;;;298                    WriteAddr += RestSpace;
00002e  eb060b00          ADD      r11,r6,r0
000032  b33c              CBZ      r4,|L16.132|
;;;299                    pBuffer += RestSpace;
;;;300    
;;;301                    // 再将剩余的数据写入下一页
;;;302                    SPI_FLASH_WritePage(pBuffer, WriteAddr, temp);
;;;303                }
;;;304                // 要写入的数据量不超过当前页的剩余空间，则直接写入
;;;305                else
;;;306                {
;;;307                    SPI_FLASH_WritePage(pBuffer, WriteAddr, NumByteToWrite);
;;;308                }
;;;309            }
;;;310            // 数据量超过一页
;;;311            else
;;;312            {
;;;313                // 先将当前页填满
;;;314                SPI_FLASH_WritePage(pBuffer, WriteAddr, RestSpace);
000034  463a              MOV      r2,r7
000036  4631              MOV      r1,r6
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       SPI_FLASH_WritePage
;;;315                WriteAddr += RestSpace;
00003e  465e              MOV      r6,r11
;;;316                pBuffer += RestSpace;
000040  443d              ADD      r5,r5,r7
;;;317    
;;;318                // 剩余的数据，写入起点就是下一页的起点了，和上面第一种情况相同的处理
;;;319                NumByteToWrite -= RestSpace;
000042  eba80007          SUB      r0,r8,r7
000046  b280              UXTH     r0,r0
;;;320                NumOfPage = NumByteToWrite / SPI_FLASH_PAGE_SIZE;
000048  0a04              LSRS     r4,r0,#8
;;;321                NumOfRestByte = NumByteToWrite % SPI_FLASH_PAGE_SIZE;
00004a  b2c7              UXTB     r7,r0
;;;322    
;;;323                while (NumOfPage--)
00004c  e03b              B        |L16.198|
                  |L16.78|
00004e  b97c              CBNZ     r4,|L16.112|
000050  4642              MOV      r2,r8                 ;266
000052  4631              MOV      r1,r6                 ;266
000054  4628              MOV      r0,r5                 ;266
000056  e8bd5ff0          POP      {r4-r12,lr}           ;266
00005a  f7ffbffe          B.W      SPI_FLASH_WritePage
                  |L16.94|
00005e  464a              MOV      r2,r9                 ;275
000060  4631              MOV      r1,r6                 ;275
000062  4628              MOV      r0,r5                 ;275
000064  f7fffffe          BL       SPI_FLASH_WritePage
000068  f5067680          ADD      r6,r6,#0x100          ;277
00006c  f5057580          ADD      r5,r5,#0x100          ;278
                  |L16.112|
000070  1e64              SUBS     r4,r4,#1              ;272
000072  b2e4              UXTB     r4,r4                 ;272
000074  d2f3              BCS      |L16.94|
000076  4652              MOV      r2,r10                ;282
000078  4631              MOV      r1,r6                 ;282
00007a  4628              MOV      r0,r5                 ;282
00007c  e8bd5ff0          POP      {r4-r12,lr}           ;282
000080  f7ffbffe          B.W      SPI_FLASH_WritePage
                  |L16.132|
000084  45ba              CMP      r10,r7                ;292
000086  d90e              BLS      |L16.166|
000088  ebaa0007          SUB      r0,r10,r7             ;295
00008c  b2c4              UXTB     r4,r0                 ;295
00008e  463a              MOV      r2,r7                 ;297
000090  4631              MOV      r1,r6                 ;297
000092  4628              MOV      r0,r5                 ;297
000094  f7fffffe          BL       SPI_FLASH_WritePage
000098  4659              MOV      r1,r11                ;298
00009a  19e8              ADDS     r0,r5,r7              ;299
00009c  4622              MOV      r2,r4                 ;302
00009e  e8bd5ff0          POP      {r4-r12,lr}           ;302
0000a2  f7ffbffe          B.W      SPI_FLASH_WritePage
                  |L16.166|
0000a6  4642              MOV      r2,r8                 ;307
0000a8  4631              MOV      r1,r6                 ;307
0000aa  4628              MOV      r0,r5                 ;307
0000ac  e8bd5ff0          POP      {r4-r12,lr}           ;307
0000b0  f7ffbffe          B.W      SPI_FLASH_WritePage
                  |L16.180|
;;;324                {
;;;325                    SPI_FLASH_WritePage(pBuffer, WriteAddr, SPI_FLASH_PAGE_SIZE);
0000b4  464a              MOV      r2,r9
0000b6  4631              MOV      r1,r6
0000b8  4628              MOV      r0,r5
0000ba  f7fffffe          BL       SPI_FLASH_WritePage
;;;326                    WriteAddr += SPI_FLASH_PAGE_SIZE;
0000be  f5067680          ADD      r6,r6,#0x100
;;;327                    pBuffer += SPI_FLASH_PAGE_SIZE;
0000c2  f5057580          ADD      r5,r5,#0x100
                  |L16.198|
0000c6  1e64              SUBS     r4,r4,#1              ;323
0000c8  b2e4              UXTB     r4,r4                 ;323
0000ca  d2f3              BCS      |L16.180|
;;;328                }
;;;329    
;;;330                SPI_FLASH_WritePage(pBuffer, WriteAddr, NumOfRestByte);
0000cc  463a              MOV      r2,r7
0000ce  4631              MOV      r1,r6
0000d0  4628              MOV      r0,r5
0000d2  e8bd5ff0          POP      {r4-r12,lr}
0000d6  f7ffbffe          B.W      SPI_FLASH_WritePage
                  |L16.218|
;;;331            }
;;;332        }
;;;333    }
0000da  e8bd9ff0          POP      {r4-r12,pc}
;;;334    
                          ENDP


                          AREA ||i.SPI_FLASH_WriteByte||, CODE, READONLY, ALIGN=1

                  SPI_FLASH_WriteByte PROC
;;;643    
;;;644    void SPI_FLASH_WriteByte(uint32 WriteAddr, uint8 data)
000000  b508              PUSH     {r3,lr}
;;;645    {
;;;646        uint8 buff[4];
;;;647    
;;;648        buff[0] = (data) & 0xFF;
000002  f88d1000          STRB     r1,[sp,#0]
;;;649    
;;;650        SPI_FLASH_WriteWithErase(buff, WriteAddr, 1);
000006  4601              MOV      r1,r0
000008  2201              MOVS     r2,#1
00000a  4668              MOV      r0,sp
00000c  f7fffffe          BL       SPI_FLASH_WriteWithErase
;;;651    }
000010  bd08              POP      {r3,pc}
;;;652    
                          ENDP


                          AREA ||i.SPI_FLASH_WriteEnable||, CODE, READONLY, ALIGN=2

                  SPI_FLASH_WriteEnable PROC
;;;460    // 发送写入使能指令
;;;461    void SPI_FLASH_WriteEnable(void)
000000  b510              PUSH     {r4,lr}
;;;462    {
;;;463        // 片选
;;;464        SPI_FLASH_CS_L();
000002  4c07              LDR      r4,|L18.32|
000004  2102              MOVS     r1,#2
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       gpio_bit_reset
;;;465    
;;;466        // 发送写入使能指令
;;;467        SPI_FLASH_SendByte(CMD_WRITE_ENABLE);
00000c  2006              MOVS     r0,#6
00000e  f7fffffe          BL       SPI_FLASH_SendByte
;;;468    
;;;469        // 释放
;;;470        SPI_FLASH_CS_H();
000012  4620              MOV      r0,r4
000014  e8bd4010          POP      {r4,lr}
000018  2102              MOVS     r1,#2
00001a  f7ffbffe          B.W      gpio_bit_set
;;;471    }
;;;472    
                          ENDP

00001e  0000              DCW      0x0000
                  |L18.32|
                          DCD      0x40011800

                          AREA ||i.SPI_FLASH_WriteHalfWord||, CODE, READONLY, ALIGN=1

                  SPI_FLASH_WriteHalfWord PROC
;;;652    
;;;653    void SPI_FLASH_WriteHalfWord(uint32 WriteAddr, uint16 data)
000000  b508              PUSH     {r3,lr}
;;;654    {
;;;655        uint8 buff[4];
;;;656    
;;;657        buff[0] = (data >> 8) & 0xFF;
000002  0a0a              LSRS     r2,r1,#8
000004  f88d2000          STRB     r2,[sp,#0]
;;;658        buff[1] = (data) & 0xFF;
000008  f88d1001          STRB     r1,[sp,#1]
;;;659    
;;;660        SPI_FLASH_WriteWithErase(buff, WriteAddr, 2);
00000c  4601              MOV      r1,r0
00000e  2202              MOVS     r2,#2
000010  4668              MOV      r0,sp
000012  f7fffffe          BL       SPI_FLASH_WriteWithErase
;;;661    }
000016  bd08              POP      {r3,pc}
;;;662    
                          ENDP


                          AREA ||i.SPI_FLASH_WritePage||, CODE, READONLY, ALIGN=2

                  SPI_FLASH_WritePage PROC
;;;199    // 页写入
;;;200    void SPI_FLASH_WritePage(uint8 *pBuffer, uint32 WriteAddr, uint16 NumByteToWrite)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;201    {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
;;;202        // 写入数据量为0，退出
;;;203        if (0 == NumByteToWrite)
00000a  2c00              CMP      r4,#0
00000c  d024              BEQ      |L20.88|
;;;204        {
;;;205            return;
;;;206        }
;;;207    
;;;208        // 使能写入操作
;;;209        SPI_FLASH_WriteEnable();
00000e  f7fffffe          BL       SPI_FLASH_WriteEnable
;;;210    
;;;211        // 片选
;;;212        SPI_FLASH_CS_L();
000012  4e12              LDR      r6,|L20.92|
000014  2102              MOVS     r1,#2
000016  4630              MOV      r0,r6
000018  f7fffffe          BL       gpio_bit_reset
;;;213    
;;;214        // 发送页写入命令
;;;215        SPI_FLASH_SendByte(CMD_PAGE_WRITE);
00001c  2002              MOVS     r0,#2
00001e  f7fffffe          BL       SPI_FLASH_SendByte
;;;216    
;;;217        // 写入24位起始地址
;;;218        SPI_FLASH_SendByte((WriteAddr >> 16) & 0xFF);
000022  f3c74007          UBFX     r0,r7,#16,#8
000026  f7fffffe          BL       SPI_FLASH_SendByte
;;;219        SPI_FLASH_SendByte((WriteAddr >> 8) & 0xFF);
00002a  f3c72007          UBFX     r0,r7,#8,#8
00002e  f7fffffe          BL       SPI_FLASH_SendByte
;;;220        SPI_FLASH_SendByte(WriteAddr & 0xFF);
000032  b2f8              UXTB     r0,r7
000034  f7fffffe          BL       SPI_FLASH_SendByte
;;;221    
;;;222        // 连续写入指定数量的数据
;;;223        while (NumByteToWrite--)
000038  e003              B        |L20.66|
                  |L20.58|
;;;224        {
;;;225            /// 写入一个字节
;;;226            SPI_FLASH_SendByte(*pBuffer);
00003a  7828              LDRB     r0,[r5,#0]
00003c  f7fffffe          BL       SPI_FLASH_SendByte
;;;227    
;;;228            pBuffer++;
000040  1c6d              ADDS     r5,r5,#1
                  |L20.66|
000042  1e64              SUBS     r4,r4,#1              ;223
000044  b2a4              UXTH     r4,r4                 ;223
000046  d2f8              BCS      |L20.58|
;;;229        }
;;;230    
;;;231        // 释放
;;;232        SPI_FLASH_CS_H();
000048  2102              MOVS     r1,#2
00004a  4630              MOV      r0,r6
00004c  f7fffffe          BL       gpio_bit_set
;;;233    
;;;234        // 等待写入完成
;;;235        SPI_FLASH_WaitForWriteEnd();
000050  e8bd41f0          POP      {r4-r8,lr}
000054  f7ffbffe          B.W      SPI_FLASH_WaitForWriteEnd
                  |L20.88|
;;;236    }
000058  e8bd81f0          POP      {r4-r8,pc}
;;;237    
                          ENDP

                  |L20.92|
                          DCD      0x40011800

                          AREA ||i.SPI_FLASH_WriteStatus||, CODE, READONLY, ALIGN=2

                  SPI_FLASH_WriteStatus PROC
;;;473    // 写状态寄存器
;;;474    void SPI_FLASH_WriteStatus(uint8 data)
000000  b570              PUSH     {r4-r6,lr}
;;;475    {
000002  4605              MOV      r5,r0
;;;476        // 片选
;;;477        SPI_FLASH_CS_L();
000004  4c0d              LDR      r4,|L21.60|
000006  2102              MOVS     r1,#2
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       gpio_bit_reset
;;;478    
;;;479        // 允许写状态寄存器
;;;480        SPI_FLASH_SendByte(CMD_WRITE_REGISTER_ENABLE);
00000e  2050              MOVS     r0,#0x50
000010  f7fffffe          BL       SPI_FLASH_SendByte
;;;481    
;;;482        // 释放
;;;483        SPI_FLASH_CS_H();
000014  2102              MOVS     r1,#2
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       gpio_bit_set
;;;484    
;;;485        // 片选
;;;486        SPI_FLASH_CS_L();
00001c  2102              MOVS     r1,#2
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       gpio_bit_reset
;;;487    
;;;488        // 允许写状态寄存器
;;;489        SPI_FLASH_SendByte(CMD_WRITE_STATUS_REGISTER);
000024  2001              MOVS     r0,#1
000026  f7fffffe          BL       SPI_FLASH_SendByte
;;;490        SPI_FLASH_SendByte(data);
00002a  4628              MOV      r0,r5
00002c  f7fffffe          BL       SPI_FLASH_SendByte
;;;491    
;;;492        // 释放
;;;493        SPI_FLASH_CS_H();
000030  4620              MOV      r0,r4
000032  e8bd4070          POP      {r4-r6,lr}
000036  2102              MOVS     r1,#2
000038  f7ffbffe          B.W      gpio_bit_set
;;;494    }
;;;495    
                          ENDP

                  |L21.60|
                          DCD      0x40011800

                          AREA ||i.SPI_FLASH_WriteWithCheck||, CODE, READONLY, ALIGN=1

                  SPI_FLASH_WriteWithCheck PROC
;;;561    // 数据写入接口，返回写入结果
;;;562    BOOL SPI_FLASH_WriteWithCheck(uint8 *pBuffer, uint32 WriteAddr, uint16 NumByteToWrite)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;563    {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4617              MOV      r7,r2
;;;564        uint16 NumOfInt = 0;
;;;565        uint16 NumOfRestByte = 0;
;;;566        uint16 i;
;;;567        uint8 *pFlashBuff = NULL; // 保存读取扇区的数据
;;;568    
;;;569        if ((NULL == pBuffer) || (0 == NumByteToWrite))
00000a  2c00              CMP      r4,#0
00000c  d00e              BEQ      |L22.44|
00000e  b16f              CBZ      r7,|L22.44|
;;;570        {
;;;571            return FALSE;
;;;572        }
;;;573    
;;;574        // 申请4096Byte空间保存扇区数据
;;;575        pFlashBuff = (uint8 *)malloc(SPI_FLASH_SECTOR_SIZE);
000010  f44f5980          MOV      r9,#0x1000
000014  4648              MOV      r0,r9
000016  f7fffffe          BL       malloc
00001a  4605              MOV      r5,r0
;;;576    
;;;577        // 指针非空判断
;;;578        if (NULL == pFlashBuff)
00001c  0028              MOVS     r0,r5
00001e  d008              BEQ      |L22.50|
;;;579        {
;;;580            return FALSE;
;;;581        }
;;;582    
;;;583        if (NumByteToWrite > SPI_FLASH_SECTOR_SIZE)
000020  454f              CMP      r7,r9
000022  d941              BLS      |L22.168|
;;;584        {
;;;585            NumOfInt = NumByteToWrite / SPI_FLASH_SECTOR_SIZE;
000024  0b3e              LSRS     r6,r7,#12
;;;586            NumOfRestByte = NumByteToWrite % SPI_FLASH_SECTOR_SIZE;
000026  f3c7070b          UBFX     r7,r7,#0,#12
;;;587    
;;;588            while (NumOfInt--)
00002a  e020              B        |L22.110|
                  |L22.44|
00002c  2000              MOVS     r0,#0                 ;571
                  |L22.46|
;;;589            {
;;;590                // 执行写入
;;;591                SPI_FLASH_WriteArray(pBuffer, WriteAddr, SPI_FLASH_SECTOR_SIZE);
;;;592                // 执行读取
;;;593                SPI_FLASH_ReadArray(pFlashBuff, WriteAddr, SPI_FLASH_SECTOR_SIZE);
;;;594    
;;;595                for (i = 0; i < SPI_FLASH_SECTOR_SIZE; i++)
;;;596                {
;;;597                    if (pBuffer[i] != pFlashBuff[i])
;;;598                    {
;;;599                        free(pFlashBuff);
;;;600                        return FALSE;
;;;601                    }
;;;602                }
;;;603    
;;;604                WriteAddr += SPI_FLASH_SECTOR_SIZE;
;;;605                pBuffer += SPI_FLASH_SECTOR_SIZE;
;;;606            }
;;;607    
;;;608            // 执行写入
;;;609            SPI_FLASH_WriteArray(pBuffer, WriteAddr, NumOfRestByte);
;;;610            // 执行读取
;;;611            SPI_FLASH_ReadArray(pFlashBuff, WriteAddr, NumOfRestByte);
;;;612    
;;;613            for (i = 0; i < NumOfRestByte; i++)
;;;614            {
;;;615                if (pBuffer[i] != pFlashBuff[i])
;;;616                {
;;;617                    free(pFlashBuff);
;;;618                    return FALSE;
;;;619                }
;;;620            }
;;;621        }
;;;622        else
;;;623        {
;;;624            // 执行写入
;;;625            SPI_FLASH_WriteArray(pBuffer, WriteAddr, NumByteToWrite);
;;;626            // 执行读取
;;;627            SPI_FLASH_ReadArray(pFlashBuff, WriteAddr, NumByteToWrite);
;;;628    
;;;629            for (i = 0; i < NumByteToWrite; i++)
;;;630            {
;;;631                if (pBuffer[i] != pFlashBuff[i])
;;;632                {
;;;633                    free(pFlashBuff);
;;;634                    return FALSE;
;;;635                }
;;;636            }
;;;637        }
;;;638    
;;;639        free(pFlashBuff);
;;;640    
;;;641        return TRUE;
;;;642    }
00002e  e8bd87f0          POP      {r4-r10,pc}
                  |L22.50|
000032  2000              MOVS     r0,#0                 ;580
000034  e7fb              B        |L22.46|
                  |L22.54|
000036  464a              MOV      r2,r9                 ;591
000038  4641              MOV      r1,r8                 ;591
00003a  4620              MOV      r0,r4                 ;591
00003c  f7fffffe          BL       SPI_FLASH_WriteArray
000040  464a              MOV      r2,r9                 ;593
000042  4641              MOV      r1,r8                 ;593
000044  4628              MOV      r0,r5                 ;593
000046  f7fffffe          BL       SPI_FLASH_ReadArray
00004a  2000              MOVS     r0,#0                 ;595
                  |L22.76|
00004c  5c21              LDRB     r1,[r4,r0]            ;597
00004e  5c2a              LDRB     r2,[r5,r0]            ;597
000050  4291              CMP      r1,r2                 ;597
000052  d004              BEQ      |L22.94|
000054  4628              MOV      r0,r5                 ;599
000056  f7fffffe          BL       free
00005a  2000              MOVS     r0,#0                 ;600
00005c  e7e7              B        |L22.46|
                  |L22.94|
00005e  1c40              ADDS     r0,r0,#1              ;595
000060  b280              UXTH     r0,r0                 ;595
000062  4548              CMP      r0,r9                 ;595
000064  d3f2              BCC      |L22.76|
000066  f5085880          ADD      r8,r8,#0x1000         ;604
00006a  f5045480          ADD      r4,r4,#0x1000         ;605
                  |L22.110|
00006e  1e76              SUBS     r6,r6,#1              ;588
000070  b2b6              UXTH     r6,r6                 ;588
000072  d2e0              BCS      |L22.54|
000074  463a              MOV      r2,r7                 ;609
000076  4641              MOV      r1,r8                 ;609
000078  4620              MOV      r0,r4                 ;609
00007a  f7fffffe          BL       SPI_FLASH_WriteArray
00007e  463a              MOV      r2,r7                 ;611
000080  4641              MOV      r1,r8                 ;611
000082  4628              MOV      r0,r5                 ;611
000084  f7fffffe          BL       SPI_FLASH_ReadArray
000088  2000              MOVS     r0,#0                 ;613
00008a  e00a              B        |L22.162|
                  |L22.140|
00008c  5c21              LDRB     r1,[r4,r0]            ;615
00008e  5c2a              LDRB     r2,[r5,r0]            ;615
000090  4291              CMP      r1,r2                 ;615
000092  d004              BEQ      |L22.158|
000094  4628              MOV      r0,r5                 ;617
000096  f7fffffe          BL       free
00009a  2000              MOVS     r0,#0                 ;618
00009c  e7c7              B        |L22.46|
                  |L22.158|
00009e  1c40              ADDS     r0,r0,#1              ;613
0000a0  b280              UXTH     r0,r0                 ;613
                  |L22.162|
0000a2  42b8              CMP      r0,r7                 ;613
0000a4  d3f2              BCC      |L22.140|
0000a6  e018              B        |L22.218|
                  |L22.168|
0000a8  463a              MOV      r2,r7                 ;625
0000aa  4641              MOV      r1,r8                 ;625
0000ac  4620              MOV      r0,r4                 ;625
0000ae  f7fffffe          BL       SPI_FLASH_WriteArray
0000b2  463a              MOV      r2,r7                 ;627
0000b4  4641              MOV      r1,r8                 ;627
0000b6  4628              MOV      r0,r5                 ;627
0000b8  f7fffffe          BL       SPI_FLASH_ReadArray
0000bc  2000              MOVS     r0,#0                 ;629
0000be  e00a              B        |L22.214|
                  |L22.192|
0000c0  5c21              LDRB     r1,[r4,r0]            ;631
0000c2  5c2a              LDRB     r2,[r5,r0]            ;631
0000c4  4291              CMP      r1,r2                 ;631
0000c6  d004              BEQ      |L22.210|
0000c8  4628              MOV      r0,r5                 ;633
0000ca  f7fffffe          BL       free
0000ce  2000              MOVS     r0,#0                 ;634
0000d0  e7ad              B        |L22.46|
                  |L22.210|
0000d2  1c40              ADDS     r0,r0,#1              ;629
0000d4  b280              UXTH     r0,r0                 ;629
                  |L22.214|
0000d6  42b8              CMP      r0,r7                 ;629
0000d8  d3f2              BCC      |L22.192|
                  |L22.218|
0000da  4628              MOV      r0,r5                 ;639
0000dc  f7fffffe          BL       free
0000e0  2001              MOVS     r0,#1                 ;641
0000e2  e7a4              B        |L22.46|
;;;643    
                          ENDP


                          AREA ||i.SPI_FLASH_WriteWithErase||, CODE, READONLY, ALIGN=1

                  SPI_FLASH_WriteWithErase PROC
;;;688    **********************************************************************/
;;;689    void SPI_FLASH_WriteWithErase(uint8 *pBuffer, uint32 WriteAddr, uint16 NumByteToWrite)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;690    {
000004  4607              MOV      r7,r0
000006  468b              MOV      r11,r1
000008  4615              MOV      r5,r2
;;;691        uint32 sectPos = 0;
;;;692        uint16 sectOff = 0;
;;;693        uint16 sectRemain = 0;
;;;694        uint16 i = 0;
;;;695        uint8 *pFlashBuff = NULL; // 保存读取扇区的数据
;;;696    
;;;697        if ((NULL == pBuffer) || (0 == NumByteToWrite))
00000a  2f00              CMP      r7,#0
00000c  d054              BEQ      |L23.184|
00000e  2d00              CMP      r5,#0
000010  d052              BEQ      |L23.184|
;;;698        {
;;;699            return;
;;;700        }
;;;701    
;;;702        // 申请4096Byte空间保存扇区数据
;;;703        pFlashBuff = (uint8 *)malloc(SPI_FLASH_SECTOR_SIZE);
000012  f44f5080          MOV      r0,#0x1000
000016  f7fffffe          BL       malloc
00001a  4680              MOV      r8,r0
;;;704    
;;;705        if (NULL == pFlashBuff)
00001c  ea5f0008          MOVS     r0,r8
000020  d04a              BEQ      |L23.184|
;;;706        {
;;;707            return;
;;;708        }
;;;709    
;;;710        sectPos = WriteAddr / SPI_FLASH_SECTOR_SIZE;  // 扇区地址
000022  ea4f391b          LSR      r9,r11,#12
;;;711        sectOff = WriteAddr % SPI_FLASH_SECTOR_SIZE;  // 在扇区内的偏移
000026  f3cb060b          UBFX     r6,r11,#0,#12
;;;712        sectRemain = SPI_FLASH_SECTOR_SIZE - sectOff; // 扇区剩余空间大小
00002a  f5c65480          RSB      r4,r6,#0x1000
;;;713    
;;;714        if (NumByteToWrite <= sectRemain)
00002e  42a5              CMP      r5,r4
000030  d838              BHI      |L23.164|
;;;715        {
;;;716            sectRemain = NumByteToWrite; // 不大于4096个字节
000032  462c              MOV      r4,r5
000034  e036              B        |L23.164|
                  |L23.54|
;;;717        }
;;;718    
;;;719        while (1)
;;;720        {
;;;721            // 读出整个扇区的内容
;;;722            SPI_FLASH_ReadArray(pFlashBuff, sectPos * SPI_FLASH_SECTOR_SIZE, SPI_FLASH_SECTOR_SIZE);
;;;723    
;;;724            for (i = 0; i < sectRemain; i++) // 校验数据
;;;725            {
;;;726                if (pFlashBuff[sectOff + i] != 0xFF)
000036  1831              ADDS     r1,r6,r0
000038  f8181001          LDRB     r1,[r8,r1]
00003c  29ff              CMP      r1,#0xff
00003e  d103              BNE      |L23.72|
000040  1c40              ADDS     r0,r0,#1              ;724
000042  b280              UXTH     r0,r0                 ;724
                  |L23.68|
000044  42a0              CMP      r0,r4                 ;724
000046  d3f6              BCC      |L23.54|
                  |L23.72|
;;;727                {
;;;728                    break; // 需要擦除
;;;729                }
;;;730            }
;;;731    
;;;732            if (i < sectRemain) // 需要擦除
000048  42a0              CMP      r0,r4
00004a  d213              BCS      |L23.116|
;;;733            {
;;;734                SPI_FLASH_EraseSector(sectPos * SPI_FLASH_SECTOR_SIZE); // 擦除这个扇区
00004c  4650              MOV      r0,r10
00004e  f7fffffe          BL       SPI_FLASH_EraseSector
;;;735    
;;;736                // 复制
;;;737                for (i = 0; i < sectRemain; i++)
000052  2000              MOVS     r0,#0
000054  e005              B        |L23.98|
                  |L23.86|
;;;738                {
;;;739                    pFlashBuff[i + sectOff] = pBuffer[i];
000056  1982              ADDS     r2,r0,r6
000058  5c39              LDRB     r1,[r7,r0]
00005a  f8081002          STRB     r1,[r8,r2]
00005e  1c40              ADDS     r0,r0,#1              ;737
000060  b280              UXTH     r0,r0                 ;737
                  |L23.98|
000062  42a0              CMP      r0,r4                 ;737
000064  d3f7              BCC      |L23.86|
;;;740                }
;;;741    
;;;742                // 写入整个扇区
;;;743                SPI_FLASH_WriteArray(pFlashBuff, sectPos * SPI_FLASH_SECTOR_SIZE, SPI_FLASH_SECTOR_SIZE);
000066  4651              MOV      r1,r10
000068  f44f5280          MOV      r2,#0x1000
00006c  4640              MOV      r0,r8
00006e  f7fffffe          BL       SPI_FLASH_WriteArray
000072  e004              B        |L23.126|
                  |L23.116|
;;;744            }
;;;745            else
;;;746            {
;;;747                // 写已经擦除了的,直接写入扇区剩余区间.
;;;748                SPI_FLASH_WriteArray(pBuffer, WriteAddr, sectRemain);
000074  4622              MOV      r2,r4
000076  4659              MOV      r1,r11
000078  4638              MOV      r0,r7
00007a  f7fffffe          BL       SPI_FLASH_WriteArray
                  |L23.126|
;;;749            }
;;;750    
;;;751            if (NumByteToWrite == sectRemain)
00007e  42a5              CMP      r5,r4
000080  d104              BNE      |L23.140|
;;;752            {
;;;753                break; // 写入结束了
;;;754            }
;;;755            else // 写入未结束
;;;756            {
;;;757                sectPos++;   // 扇区地址增1
;;;758                sectOff = 0; // 偏移位置为0
;;;759    
;;;760                pBuffer += sectRemain;        // 指针偏移
;;;761                WriteAddr += sectRemain;      // 写地址偏移
;;;762                NumByteToWrite -= sectRemain; // 字节数递减
;;;763    
;;;764                if (NumByteToWrite > SPI_FLASH_SECTOR_SIZE)
;;;765                {
;;;766                    sectRemain = SPI_FLASH_SECTOR_SIZE; // 下一个扇区还是写不完
;;;767                }
;;;768                else
;;;769                {
;;;770                    sectRemain = NumByteToWrite; // 下一个扇区可以写完了
;;;771                }
;;;772            }
;;;773        }
;;;774    
;;;775        // 释放数据缓存区
;;;776        free(pFlashBuff);
000082  4640              MOV      r0,r8
000084  e8bd5ff0          POP      {r4-r12,lr}
000088  f7ffbffe          B.W      free
                  |L23.140|
00008c  f1090901          ADD      r9,r9,#1              ;757
000090  2600              MOVS     r6,#0                 ;758
000092  4427              ADD      r7,r7,r4              ;760
000094  44a3              ADD      r11,r11,r4            ;761
000096  1b28              SUBS     r0,r5,r4              ;762
000098  b285              UXTH     r5,r0                 ;762
00009a  f44f5480          MOV      r4,#0x1000            ;764
00009e  42a5              CMP      r5,r4                 ;764
0000a0  d800              BHI      |L23.164|
0000a2  462c              MOV      r4,r5                 ;770
                  |L23.164|
0000a4  ea4f3a09          LSL      r10,r9,#12            ;722
0000a8  f44f5280          MOV      r2,#0x1000            ;722
0000ac  4651              MOV      r1,r10                ;722
0000ae  4640              MOV      r0,r8                 ;722
0000b0  f7fffffe          BL       SPI_FLASH_ReadArray
0000b4  2000              MOVS     r0,#0                 ;724
0000b6  e7c5              B        |L23.68|
                  |L23.184|
;;;777    }
0000b8  e8bd9ff0          POP      {r4-r12,pc}
;;;778    
                          ENDP


                          AREA ||i.SPI_FLASH_WriteWord||, CODE, READONLY, ALIGN=1

                  SPI_FLASH_WriteWord PROC
;;;662    
;;;663    void SPI_FLASH_WriteWord(uint32 WriteAddr, uint32 data)
000000  b508              PUSH     {r3,lr}
;;;664    {
;;;665        uint8 buff[4];
;;;666    
;;;667        buff[0] = (data >> 24) & 0xFF;
000002  0e0a              LSRS     r2,r1,#24
000004  f88d2000          STRB     r2,[sp,#0]
;;;668        buff[1] = (data >> 16) & 0xFF;
000008  0c0a              LSRS     r2,r1,#16
00000a  f88d2001          STRB     r2,[sp,#1]
;;;669        buff[2] = (data >> 8) & 0xFF;
00000e  0a0a              LSRS     r2,r1,#8
000010  f88d2002          STRB     r2,[sp,#2]
;;;670        buff[3] = (data) & 0xFF;
000014  f88d1003          STRB     r1,[sp,#3]
;;;671    
;;;672        SPI_FLASH_WriteWithErase(buff, WriteAddr, 4);
000018  4601              MOV      r1,r0
00001a  2204              MOVS     r2,#4
00001c  4668              MOV      r0,sp
00001e  f7fffffe          BL       SPI_FLASH_WriteWithErase
;;;673    }
000022  bd08              POP      {r3,pc}
;;;674    
                          ENDP


                          AREA ||i.SPI_FlashReadForCrc8||, CODE, READONLY, ALIGN=1

                  SPI_FlashReadForCrc8 PROC
;;;1228    *******************************************************************************/
;;;1229   uint8 SPI_FlashReadForCrc8(uint32 datalen)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1230   {
000002  4601              MOV      r1,r0
;;;1231       uint8 crc = 0;
000004  2000              MOVS     r0,#0
;;;1232       uint8 i, j;
;;;1233       uint8 buf[4] = {0};
000006  2200              MOVS     r2,#0
000008  9200              STR      r2,[sp,#0]
;;;1234       uint32 addrIndex = 0;
;;;1235       uint32 dataTemp;
;;;1236       uint32 len = datalen / 4;
00000a  088c              LSRS     r4,r1,#2
00000c  e01e              B        |L25.76|
                  |L25.14|
;;;1237   
;;;1238       while (len--)
;;;1239       {
;;;1240           //      dataTemp = SPI_FLASH_ReadWord(SPI_FLASH_APP_DATA_ADDEESS + addrIndex);
;;;1241           addrIndex += 4;
;;;1242   
;;;1243           // 大端模式
;;;1244           buf[0] = (uint8)(dataTemp >> 24);
00000e  0e19              LSRS     r1,r3,#24
000010  f88d1000          STRB     r1,[sp,#0]
;;;1245           buf[1] = (uint8)(dataTemp >> 16);
000014  0c19              LSRS     r1,r3,#16
000016  f88d1001          STRB     r1,[sp,#1]
;;;1246           buf[2] = (uint8)(dataTemp >> 8);
00001a  0a19              LSRS     r1,r3,#8
00001c  f88d1002          STRB     r1,[sp,#2]
;;;1247           buf[3] = (uint8)dataTemp;
000020  f88d3003          STRB     r3,[sp,#3]
;;;1248   
;;;1249           for (j = 0; j < 4; j++)
000024  2200              MOVS     r2,#0
000026  466e              MOV      r6,sp                 ;1233
;;;1250           {
;;;1251               crc ^= buf[j];
;;;1252   
;;;1253               for (i = 0; i < 8; i++)
;;;1254               {
;;;1255                   if (crc & 0x01)
;;;1256                   {
;;;1257                       crc = (crc >> 1) ^ 0x8C;
000028  258c              MOVS     r5,#0x8c
                  |L25.42|
00002a  5cb1              LDRB     r1,[r6,r2]            ;1251
00002c  4048              EORS     r0,r0,r1              ;1251
00002e  2100              MOVS     r1,#0                 ;1253
                  |L25.48|
000030  07c7              LSLS     r7,r0,#31             ;1255
000032  d002              BEQ      |L25.58|
000034  ea850050          EOR      r0,r5,r0,LSR #1
000038  e000              B        |L25.60|
                  |L25.58|
;;;1258                   }
;;;1259                   else
;;;1260                   {
;;;1261                       crc >>= 1;
00003a  0840              LSRS     r0,r0,#1
                  |L25.60|
00003c  1c49              ADDS     r1,r1,#1              ;1253
00003e  b2c9              UXTB     r1,r1                 ;1253
000040  2908              CMP      r1,#8                 ;1253
000042  d3f5              BCC      |L25.48|
000044  1c52              ADDS     r2,r2,#1              ;1249
000046  b2d2              UXTB     r2,r2                 ;1249
000048  2a04              CMP      r2,#4                 ;1249
00004a  d3ee              BCC      |L25.42|
                  |L25.76|
00004c  1e64              SUBS     r4,r4,#1              ;1238
00004e  1c61              ADDS     r1,r4,#1              ;1238
000050  d1dd              BNE      |L25.14|
;;;1262                   }
;;;1263               }
;;;1264           }
;;;1265       }
;;;1266       return crc;
;;;1267   }
000052  bdf8              POP      {r3-r7,pc}
                          ENDP


                          AREA ||i.SPIx_ConfigureWorkMode||, CODE, READONLY, ALIGN=2

                  SPIx_ConfigureWorkMode PROC
;;;1211   // 配置SPI工作模式
;;;1212   void SPIx_ConfigureWorkMode(uint16 SpiDirection, uint16 SpiDataSize)
000000  b510              PUSH     {r4,lr}
;;;1213   {
;;;1214       spi_init_struct.trans_mode = SpiDirection;
000002  4a08              LDR      r2,|L26.36|
000004  6050              STR      r0,[r2,#4]  ; spi_init_struct
;;;1215       spi_init_struct.frame_size = SpiDataSize;
000006  6091              STR      r1,[r2,#8]  ; spi_init_struct
;;;1216   
;;;1217       spi_init(STM32_SPIx_NUM_DEF, &spi_init_struct);
000008  4c07              LDR      r4,|L26.40|
00000a  4611              MOV      r1,r2
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       spi_init
;;;1218       spi_enable(STM32_SPIx_NUM_DEF);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       spi_enable
;;;1219   
;;;1220       spi_i2s_data_receive(STM32_SPIx_NUM_DEF);
000018  4620              MOV      r0,r4
00001a  e8bd4010          POP      {r4,lr}
00001e  f7ffbffe          B.W      spi_i2s_data_receive
;;;1221   }
;;;1222   
                          ENDP

000022  0000              DCW      0x0000
                  |L26.36|
                          DCD      ||.bss||
                  |L26.40|
                          DCD      0x40003c00

                          AREA ||i.SPIx_DMAy_Read||, CODE, READONLY, ALIGN=2

                  SPIx_DMAy_Read PROC
;;;977    // 启动DMA方式读取
;;;978    void SPIx_DMAy_Read(uint32 srcAddr, uint32 dstAddr, uint16 count)
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;979    {
000004  4607              MOV      r7,r0
000006  4690              MOV      r8,r2
;;;980        // uint32 number = 0;
;;;981    
;;;982        // 片选
;;;983        SPI_FLASH_CS_H();
000008  2102              MOVS     r1,#2
00000a  4856              LDR      r0,|L27.356|
00000c  f7fffffe          BL       gpio_bit_set
;;;984    
;;;985    #if STM32_DMA_SPI_DIRECTION
;;;986    
;;;987        // 入参检查
;;;988        if (0 == count)
000010  f1b80f00          CMP      r8,#0
000014  d07e              BEQ      |L27.276|
;;;989        {
;;;990            return;
;;;991        }
;;;992    
;;;993        // 设置DMA完成标识
;;;994        spiCB.dmaFinished = FALSE;
000016  4e54              LDR      r6,|L27.360|
000018  2500              MOVS     r5,#0
00001a  7035              STRB     r5,[r6,#0]
;;;995        spiCB.tx_dmaFinished = FALSE;
00001c  7075              STRB     r5,[r6,#1]
;;;996        // 先禁止SPI以修改配置
;;;997        spi_disable(STM32_SPIx_NUM_DEF);
00001e  4853              LDR      r0,|L27.364|
000020  f7fffffe          BL       spi_disable
;;;998    
;;;999        // 关闭DMA
;;;1000       dma_channel_disable(DMA0, DMA_CH1);
000024  2101              MOVS     r1,#1
000026  4852              LDR      r0,|L27.368|
000028  f7fffffe          BL       dma_channel_disable
;;;1001       dma_channel_disable(DMA0, DMA_CH2);
00002c  2102              MOVS     r1,#2
00002e  4850              LDR      r0,|L27.368|
000030  f7fffffe          BL       dma_channel_disable
;;;1002   
;;;1003       spi_i2s_deinit(STM32_SPIx_NUM_DEF);
000034  484d              LDR      r0,|L27.364|
000036  f7fffffe          BL       spi_i2s_deinit
;;;1004   
;;;1005       spi_init_struct.trans_mode = SPI_TRANSMODE_FULLDUPLEX;
00003a  4c4e              LDR      r4,|L27.372|
00003c  6065              STR      r5,[r4,#4]  ; spi_init_struct
;;;1006       spi_init_struct.device_mode = SPI_MASTER;
00003e  f44f7982          MOV      r9,#0x104
000042  f8c49000          STR      r9,[r4,#0]  ; spi_init_struct
;;;1007       spi_init_struct.frame_size = SPI_FRAMESIZE_8BIT;
000046  60a5              STR      r5,[r4,#8]  ; spi_init_struct
;;;1008       spi_init_struct.clock_polarity_phase = SPI_CK_PL_LOW_PH_1EDGE; // 空闲时CLK拉底，在第一个时钟跳变沿采集第一个数据
000048  6165              STR      r5,[r4,#0x14]  ; spi_init_struct
;;;1009       spi_init_struct.nss = SPI_NSS_SOFT;                            // 片选软件控制
00004a  f44f7a00          MOV      r10,#0x200
00004e  f8c4a00c          STR      r10,[r4,#0xc]  ; spi_init_struct
;;;1010   
;;;1011       // APB2 - SPI0 - 72M
;;;1012       // APB1 - SPI1/SPI2 - 36M
;;;1013       spi_init_struct.prescale = SPI_PSC_4;    // 72/4=18M
000052  f04f0b08          MOV      r11,#8
000056  f8c4b018          STR      r11,[r4,#0x18]  ; spi_init_struct
;;;1014       spi_init_struct.endian = SPI_ENDIAN_MSB; // 先发送高位
00005a  6125              STR      r5,[r4,#0x10]  ; spi_init_struct
;;;1015       spi_init(STM32_SPIx_NUM_DEF, &spi_init_struct);
00005c  4621              MOV      r1,r4
00005e  4843              LDR      r0,|L27.364|
000060  f7fffffe          BL       spi_init
;;;1016   
;;;1017       // 重新配置接收地址以及接收数量
;;;1018       dma_rx_init_struct.memory_inc = DMA_MEMORY_INCREASE_ENABLE; // 内存地址增量变化
000064  f1040038          ADD      r0,r4,#0x38
000068  2101              MOVS     r1,#1
00006a  7641              STRB     r1,[r0,#0x19]
;;;1019       dma_rx_init_struct.memory_addr = (uint32)dstAddr;
00006c  9901              LDR      r1,[sp,#4]
00006e  6081              STR      r1,[r0,#8]  ; dma_rx_init_struct
;;;1020       dma_rx_init_struct.number = count;
000070  f8c08010          STR      r8,[r0,#0x10]  ; dma_rx_init_struct
;;;1021       dma_init(DMA0, DMA_CH1, &dma_rx_init_struct);
000074  4602              MOV      r2,r0
000076  2101              MOVS     r1,#1
000078  483d              LDR      r0,|L27.368|
00007a  f7fffffe          BL       dma_init
;;;1022   
;;;1023       // 发送为dummy
;;;1024       dma_tx_init_struct.memory_inc = DMA_MEMORY_INCREASE_DISABLE; // 内存地址增量不变化
00007e  f104001c          ADD      r0,r4,#0x1c
000082  7645              STRB     r5,[r0,#0x19]
;;;1025       dma_tx_init_struct.memory_addr = (uint32)(&dstAddr);
000084  a901              ADD      r1,sp,#4
000086  6081              STR      r1,[r0,#8]  ; dma_tx_init_struct
;;;1026       dma_tx_init_struct.number = count;
000088  f8c08010          STR      r8,[r0,#0x10]  ; dma_tx_init_struct
;;;1027       dma_init(DMA0, DMA_CH2, &dma_tx_init_struct);
00008c  4602              MOV      r2,r0
00008e  2102              MOVS     r1,#2
000090  4837              LDR      r0,|L27.368|
000092  f7fffffe          BL       dma_init
;;;1028   
;;;1029       // 使能SPI，使用双工模式发送命令和地址
;;;1030       spi_enable(STM32_SPIx_NUM_DEF);
000096  4835              LDR      r0,|L27.364|
000098  f7fffffe          BL       spi_enable
;;;1031   
;;;1032       // 片选
;;;1033       SPI_FLASH_CS_L();
00009c  2102              MOVS     r1,#2
00009e  4831              LDR      r0,|L27.356|
0000a0  f7fffffe          BL       gpio_bit_reset
;;;1034       // 发送读取命令
;;;1035       SPI_FLASH_SendByte(CMD_READ_BYTE);
0000a4  2003              MOVS     r0,#3
0000a6  f7fffffe          BL       SPI_FLASH_SendByte
;;;1036       // 发送24位起始地址
;;;1037       SPI_FLASH_SendByte((srcAddr & 0xFF0000) >> 16);
0000aa  f3c74007          UBFX     r0,r7,#16,#8
0000ae  f7fffffe          BL       SPI_FLASH_SendByte
;;;1038       SPI_FLASH_SendByte((srcAddr & 0xFF00) >> 8);
0000b2  f3c72007          UBFX     r0,r7,#8,#8
0000b6  f7fffffe          BL       SPI_FLASH_SendByte
;;;1039       SPI_FLASH_SendByte(srcAddr & 0xFF);
0000ba  b2f8              UXTB     r0,r7
0000bc  f7fffffe          BL       SPI_FLASH_SendByte
;;;1040       // 接收前读一次数据DR，保证接收缓冲区为空
;;;1041       spi_i2s_data_receive(STM32_SPIx_NUM_DEF);
0000c0  482a              LDR      r0,|L27.364|
0000c2  f7fffffe          BL       spi_i2s_data_receive
;;;1042       // 再次禁止SPI以修改配置为只接收模式
;;;1043       spi_disable(STM32_SPIx_NUM_DEF);
0000c6  4829              LDR      r0,|L27.364|
0000c8  f7fffffe          BL       spi_disable
;;;1044   
;;;1045       spi_i2s_deinit(STM32_SPIx_NUM_DEF);
0000cc  4827              LDR      r0,|L27.364|
0000ce  f7fffffe          BL       spi_i2s_deinit
;;;1046   
;;;1047       // 配置为只接收16位模式
;;;1048       spi_init_struct.trans_mode = SPI_TRANSMODE_FULLDUPLEX;
0000d2  6065              STR      r5,[r4,#4]  ; spi_init_struct
;;;1049       spi_init_struct.device_mode = SPI_MASTER;
0000d4  f8c49000          STR      r9,[r4,#0]  ; spi_init_struct
;;;1050       spi_init_struct.frame_size = SPI_FRAMESIZE_16BIT;
0000d8  f44f6000          MOV      r0,#0x800
0000dc  60a0              STR      r0,[r4,#8]  ; spi_init_struct
;;;1051       spi_init_struct.clock_polarity_phase = SPI_CK_PL_LOW_PH_1EDGE; // 空闲时CLK拉底，在第一个时钟跳变沿采集第一个数据
0000de  6165              STR      r5,[r4,#0x14]  ; spi_init_struct
;;;1052       spi_init_struct.nss = SPI_NSS_SOFT;                            // 片选软件控制
0000e0  f8c4a00c          STR      r10,[r4,#0xc]  ; spi_init_struct
;;;1053   
;;;1054       // APB2 - SPI0 - 72M
;;;1055       // APB1 - SPI1/SPI2 - 36M
;;;1056       spi_init_struct.prescale = SPI_PSC_4;    // 72/4=18M
0000e4  f8c4b018          STR      r11,[r4,#0x18]  ; spi_init_struct
;;;1057       spi_init_struct.endian = SPI_ENDIAN_MSB; // 先发送高位
0000e8  6125              STR      r5,[r4,#0x10]  ; spi_init_struct
;;;1058       spi_init(STM32_SPIx_NUM_DEF, &spi_init_struct);
0000ea  4621              MOV      r1,r4
0000ec  481f              LDR      r0,|L27.364|
0000ee  f7fffffe          BL       spi_init
;;;1059   
;;;1060       // 清DMA标记
;;;1061       dma_flag_clear(DMA0, DMA_CH1, DMA_FLAG_G); // 清RX全局中断标志
0000f2  2201              MOVS     r2,#1
0000f4  4611              MOV      r1,r2
0000f6  481e              LDR      r0,|L27.368|
0000f8  f7fffffe          BL       dma_flag_clear
;;;1062       dma_flag_clear(DMA0, DMA_CH2, DMA_FLAG_G); // 清RX全局中断标志
0000fc  2201              MOVS     r2,#1
0000fe  2102              MOVS     r1,#2
000100  481b              LDR      r0,|L27.368|
000102  f7fffffe          BL       dma_flag_clear
;;;1063   
;;;1064       // 使能RX的TC中断
;;;1065       dma_interrupt_enable(DMA0, DMA_CH1, DMA_INT_FTF);
000106  2202              MOVS     r2,#2
000108  2101              MOVS     r1,#1
00010a  4819              LDR      r0,|L27.368|
00010c  f7fffffe          BL       dma_interrupt_enable
;;;1066       dma_interrupt_enable(DMA0, DMA_CH2, DMA_INT_FTF);
000110  2202              MOVS     r2,#2
000112  e000              B        |L27.278|
                  |L27.276|
000114  e023              B        |L27.350|
                  |L27.278|
000116  4611              MOV      r1,r2
000118  4815              LDR      r0,|L27.368|
00011a  f7fffffe          BL       dma_interrupt_enable
;;;1067   
;;;1068       // 重新使能SPI，SCK时钟立刻开始输出，开始接收数据
;;;1069       spi_enable(STM32_SPIx_NUM_DEF);
00011e  4813              LDR      r0,|L27.364|
000120  f7fffffe          BL       spi_enable
;;;1070       spi_i2s_data_receive(STM32_SPIx_NUM_DEF);
000124  4811              LDR      r0,|L27.364|
000126  f7fffffe          BL       spi_i2s_data_receive
;;;1071   
;;;1072       spi_dma_enable(STM32_SPIx_NUM_DEF, SPI_DMA_RECEIVE);
00012a  2101              MOVS     r1,#1
00012c  480f              LDR      r0,|L27.364|
00012e  f7fffffe          BL       spi_dma_enable
;;;1073       spi_dma_enable(STM32_SPIx_NUM_DEF, SPI_DMA_TRANSMIT);
000132  2100              MOVS     r1,#0
000134  480d              LDR      r0,|L27.364|
000136  f7fffffe          BL       spi_dma_enable
;;;1074   
;;;1075       // 开启DMA通道DMA0_Channel1
;;;1076       dma_channel_enable(DMA0, DMA_CH1);
00013a  2101              MOVS     r1,#1
00013c  480c              LDR      r0,|L27.368|
00013e  f7fffffe          BL       dma_channel_enable
;;;1077       dma_channel_enable(DMA0, DMA_CH2);
000142  2102              MOVS     r1,#2
000144  480a              LDR      r0,|L27.368|
000146  f7fffffe          BL       dma_channel_enable
                  |L27.330|
;;;1078   
;;;1079       while (!(spiCB.dmaFinished && spiCB.tx_dmaFinished))
00014a  7830              LDRB     r0,[r6,#0]  ; spiCB
00014c  2800              CMP      r0,#0
00014e  d0fc              BEQ      |L27.330|
000150  7870              LDRB     r0,[r6,#1]  ; spiCB
000152  2800              CMP      r0,#0
000154  d0f9              BEQ      |L27.330|
;;;1080           ;
;;;1081   
;;;1082       // DMA读完后，模式重新复位
;;;1083       SPIx_ConfigureWorkMode(SPI_TRANSMODE_FULLDUPLEX, SPI_FRAMESIZE_8BIT);
000156  2100              MOVS     r1,#0
000158  4608              MOV      r0,r1
00015a  f7fffffe          BL       SPIx_ConfigureWorkMode
                  |L27.350|
;;;1084   
;;;1085   #else
;;;1086   
;;;1087       // 入参检查
;;;1088       if (0 == count)
;;;1089       {
;;;1090           return;
;;;1091       }
;;;1092   
;;;1093       // 设置DMA完成标识
;;;1094       spiCB.dmaFinished = FALSE;
;;;1095   
;;;1096       // 先禁止SPI以修改配置
;;;1097       spi_disable(STM32_SPIx_NUM_DEF);
;;;1098   
;;;1099       // 关闭DMA
;;;1100       dma_channel_disable(DMA0, DMA_CH1);
;;;1101   
;;;1102       // 先配置全双工模式，以在DMA之前写命令和地址
;;;1103       spi_init_struct.trans_mode = SPI_TRANSMODE_FULLDUPLEX;
;;;1104       spi_init_struct.frame_size = SPI_FRAMESIZE_8BIT;
;;;1105       spi_init(STM32_SPIx_NUM_DEF, &spi_init_struct);
;;;1106   
;;;1107       // 重新配置接收地址以及接收数量
;;;1108       dma_rx_init_struct.memory_inc = DMA_MEMORY_INCREASE_ENABLE; // 内存地址增量变化
;;;1109       dma_rx_init_struct.memory_addr = (uint32)dstAddr;
;;;1110       dma_rx_init_struct.number = count;
;;;1111       dma_init(DMA0, DMA_CH1, &dma_rx_init_struct);
;;;1112   
;;;1113       // 使能SPI，使用双工模式发送命令和地址
;;;1114       spi_enable(STM32_SPIx_NUM_DEF);
;;;1115       // 片选
;;;1116       SPI_FLASH_CS_L();
;;;1117       // 发送读取命令
;;;1118       SPI_FLASH_SendByte(CMD_READ_BYTE);
;;;1119       // 发送24位起始地址
;;;1120       SPI_FLASH_SendByte((srcAddr & 0xFF0000) >> 16);
;;;1121       SPI_FLASH_SendByte((srcAddr & 0xFF00) >> 8);
;;;1122       SPI_FLASH_SendByte(srcAddr & 0xFF);
;;;1123       // 接收前读一次数据DR，保证接收缓冲区为空
;;;1124       spi_i2s_data_receive(STM32_SPIx_NUM_DEF);
;;;1125       // 再次禁止SPI以修改配置为只接收模式
;;;1126       spi_disable(STM32_SPIx_NUM_DEF);
;;;1127       // 配置为只接收16位模式
;;;1128       spi_init_struct.trans_mode = SPI_TRANSMODE_RECEIVEONLY;
;;;1129       spi_init_struct.frame_size = SPI_FRAMESIZE_16BIT;
;;;1130       spi_init(STM32_SPIx_NUM_DEF, &spi_init_struct);
;;;1131   
;;;1132       // 清DMA标记
;;;1133       dma_flag_clear(DMA0, DMA_CH1, DMA_FLAG_G); // 清RX全局中断标志
;;;1134       // 使能RX的TC中断
;;;1135       dma_interrupt_enable(DMA0, DMA_CH1, DMA_INT_FTF);
;;;1136   
;;;1137       // 重新使能SPI，SCK时钟立刻开始输出，开始接收数据
;;;1138       spi_enable(STM32_SPIx_NUM_DEF);
;;;1139       spi_i2s_data_receive(STM32_SPIx_NUM_DEF);
;;;1140   
;;;1141       // 开启DMA通道DMA0_Channel1
;;;1142       dma_channel_enable(DMA0, DMA_CH1);
;;;1143   
;;;1144       while (!spiCB.dmaFinished)
;;;1145       {
;;;1146   // DMA搬运做超时处理，超过门限则再次进行数据搬运，防止死机
;;;1147   // "#define _DMA_MOVE_BYTES_COUNT_TOP_          0xE000"超时值跟此宏密切相关，与主频也有关联，不可随意修改
;;;1148   #warning "此处计算需要注意主频与_DMA_MOVE_BYTES_COUNT_TOP_大小"
;;;1149           if (number++ > 280000)
;;;1150           {
;;;1151               number = 0;
;;;1152   
;;;1153               // 设置DMA完成标识
;;;1154               spiCB.dmaFinished = FALSE;
;;;1155   
;;;1156               // 先禁止SPI以修改配置
;;;1157               spi_disable(STM32_SPIx_NUM_DEF);
;;;1158   
;;;1159               // 关闭DMA
;;;1160               dma_channel_disable(DMA0, DMA_CH1);
;;;1161   
;;;1162               // 先配置全双工模式，以在DMA之前写命令和地址
;;;1163               spi_init_struct.trans_mode = SPI_TRANSMODE_FULLDUPLEX;
;;;1164               spi_init_struct.frame_size = SPI_FRAMESIZE_8BIT;
;;;1165               spi_init(STM32_SPIx_NUM_DEF, &spi_init_struct);
;;;1166   
;;;1167               // 重新配置接收地址以及接收数量
;;;1168               dma_rx_init_struct.memory_inc = DMA_MEMORY_INCREASE_ENABLE; // 内存地址增量变化
;;;1169               dma_rx_init_struct.memory_addr = (uint32)dstAddr;
;;;1170               dma_rx_init_struct.number = count;
;;;1171               dma_init(DMA0, DMA_CH1, &dma_rx_init_struct);
;;;1172   
;;;1173               // 使能SPI，使用双工模式发送命令和地址
;;;1174               spi_enable(STM32_SPIx_NUM_DEF);
;;;1175               // 片选
;;;1176               SPI_FLASH_CS_L();
;;;1177               // 发送读取命令
;;;1178               SPI_FLASH_SendByte(CMD_READ_BYTE);
;;;1179               // 发送24位起始地址
;;;1180               SPI_FLASH_SendByte((srcAddr & 0xFF0000) >> 16);
;;;1181               SPI_FLASH_SendByte((srcAddr & 0xFF00) >> 8);
;;;1182               SPI_FLASH_SendByte(srcAddr & 0xFF);
;;;1183               // 接收前读一次数据DR，保证接收缓冲区为空
;;;1184               spi_i2s_data_receive(STM32_SPIx_NUM_DEF);
;;;1185               // 再次禁止SPI以修改配置为只接收模式
;;;1186               spi_disable(STM32_SPIx_NUM_DEF);
;;;1187               // 配置为只接收16位模式
;;;1188               spi_init_struct.trans_mode = SPI_TRANSMODE_RECEIVEONLY;
;;;1189               spi_init_struct.frame_size = SPI_FRAMESIZE_16BIT;
;;;1190               spi_init(STM32_SPIx_NUM_DEF, &spi_init_struct);
;;;1191   
;;;1192               // 清DMA标记
;;;1193               dma_flag_clear(DMA0, DMA_CH1, DMA_FLAG_G); // 清RX全局中断标志
;;;1194               // 使能RX的TC中断
;;;1195               dma_interrupt_enable(DMA0, DMA_CH1, DMA_INT_FTF);
;;;1196   
;;;1197               // 重新使能SPI，SCK时钟立刻开始输出，开始接收数据
;;;1198               spi_enable(STM32_SPIx_NUM_DEF);
;;;1199               spi_i2s_data_receive(STM32_SPIx_NUM_DEF);
;;;1200   
;;;1201               // 开启DMA通道DMA0_Channel1
;;;1202               dma_channel_enable(DMA0, DMA_CH1);
;;;1203           }
;;;1204       }
;;;1205   
;;;1206       // DMA读完后，模式重新复位
;;;1207       SPIx_ConfigureWorkMode(SPI_TRANSMODE_FULLDUPLEX, SPI_FRAMESIZE_8BIT);
;;;1208   #endif
;;;1209   }
00015e  e8bd8ffe          POP      {r1-r11,pc}
;;;1210   
                          ENDP

000162  0000              DCW      0x0000
                  |L27.356|
                          DCD      0x40011800
                  |L27.360|
                          DCD      ||.data||+0x4
                  |L27.364|
                          DCD      0x40003c00
                  |L27.368|
                          DCD      0x40020000
                  |L27.372|
                          DCD      ||.bss||

                          AREA ||i.SPIx_DMAy_SendBuffer||, CODE, READONLY, ALIGN=2

                  SPIx_DMAy_SendBuffer PROC
;;;905    // DMA发送(只支持也写256Byte)
;;;906    void SPIx_DMAy_SendBuffer(uint8 *sendBuffer, uint32 WriteAddr, uint16 ndtr)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;907    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
;;;908    #if STM32_DMA_SPI_DIRECTION
;;;909        // 关闭DMA
;;;910        spi_dma_disable(SPI0, SPI_DMA_TRANSMIT);
00000a  4f19              LDR      r7,|L28.112|
00000c  2100              MOVS     r1,#0
00000e  4638              MOV      r0,r7
000010  f7fffffe          BL       spi_dma_disable
;;;911    
;;;912        dma_tx_init_struct.memory_inc = DMA_MEMORY_INCREASE_ENABLE;
000014  4917              LDR      r1,|L28.116|
000016  2001              MOVS     r0,#1
000018  7648              STRB     r0,[r1,#0x19]
;;;913        dma_tx_init_struct.memory_addr = (uint32)sendBuffer;
00001a  608d              STR      r5,[r1,#8]  ; dma_tx_init_struct
;;;914        dma_tx_init_struct.number = ndtr;
00001c  610e              STR      r6,[r1,#0x10]  ; dma_tx_init_struct
;;;915        dma_init(DMA0, DMA_CH2, &dma_tx_init_struct);
00001e  4d16              LDR      r5,|L28.120|
000020  460a              MOV      r2,r1
000022  2102              MOVS     r1,#2
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       dma_init
;;;916    
;;;917        // 片选
;;;918        SPI_FLASH_CS_L();
00002a  2102              MOVS     r1,#2
00002c  4813              LDR      r0,|L28.124|
00002e  f7fffffe          BL       gpio_bit_reset
;;;919        // 发送页写入命令
;;;920        SPI_FLASH_SendByte(CMD_PAGE_WRITE);
000032  2002              MOVS     r0,#2
000034  f7fffffe          BL       SPI_FLASH_SendByte
;;;921        // 写入24位起始地址
;;;922        SPI_FLASH_SendByte((WriteAddr >> 16) & 0xFF);
000038  f3c44007          UBFX     r0,r4,#16,#8
00003c  f7fffffe          BL       SPI_FLASH_SendByte
;;;923        SPI_FLASH_SendByte((WriteAddr >> 8) & 0xFF);
000040  f3c42007          UBFX     r0,r4,#8,#8
000044  f7fffffe          BL       SPI_FLASH_SendByte
;;;924        SPI_FLASH_SendByte(WriteAddr & 0xFF);
000048  b2e0              UXTB     r0,r4
00004a  f7fffffe          BL       SPI_FLASH_SendByte
;;;925    
;;;926        // 清DMA标记
;;;927        dma_flag_clear(DMA0, DMA_CH2, DMA_FLAG_G);
00004e  2201              MOVS     r2,#1
000050  2102              MOVS     r1,#2
000052  4628              MOV      r0,r5
000054  f7fffffe          BL       dma_flag_clear
;;;928    
;;;929        // 使能TX的TC中断
;;;930        dma_interrupt_enable(DMA0, DMA_CH2, DMA_INT_FTF);
000058  2202              MOVS     r2,#2
00005a  4611              MOV      r1,r2
00005c  4628              MOV      r0,r5
00005e  f7fffffe          BL       dma_interrupt_enable
;;;931    
;;;932        // 开启DMA通道DMA0_Channel2
;;;933        spi_dma_enable(SPI0, SPI_DMA_TRANSMIT);
000062  4638              MOV      r0,r7
000064  e8bd41f0          POP      {r4-r8,lr}
000068  2100              MOVS     r1,#0
00006a  f7ffbffe          B.W      spi_dma_enable
;;;934    
;;;935    #else
;;;936    
;;;937        // 先禁止SPI以修改配置
;;;938        spi_disable(STM32_SPIx_NUM_DEF);
;;;939    
;;;940        // 关闭DMA
;;;941        spi_dma_disable(SPI0, SPI_DMA_TRANSMIT);
;;;942    
;;;943        // 全双工发送接收模式，此时不用理会接收的数据
;;;944        // 数据的开始以填数据进SPI_DR为启动时刻
;;;945        spi_init_struct.trans_mode = SPI_TRANSMODE_FULLDUPLEX;
;;;946        spi_init(STM32_SPIx_NUM_DEF, &spi_init_struct);
;;;947    
;;;948        dma_tx_init_struct.memory_inc = DMA_MEMORY_INCREASE_ENABLE;
;;;949        dma_tx_init_struct.memory_addr = (uint32)sendBuffer;
;;;950        dma_tx_init_struct.number = ndtr;
;;;951        dma_init(DMA0, DMA_CH2, &dma_tx_init_struct);
;;;952    
;;;953        // 使能SPI，使用双工模式发送命令和地址
;;;954        spi_enable(STM32_SPIx_NUM_DEF);
;;;955    
;;;956        // 片选
;;;957        SPI_FLASH_CS_L();
;;;958        // 发送页写入命令
;;;959        SPI_FLASH_SendByte(CMD_PAGE_WRITE);
;;;960        // 写入24位起始地址
;;;961        SPI_FLASH_SendByte((WriteAddr >> 16) & 0xFF);
;;;962        SPI_FLASH_SendByte((WriteAddr >> 8) & 0xFF);
;;;963        SPI_FLASH_SendByte(WriteAddr & 0xFF);
;;;964    
;;;965        // 清DMA标记
;;;966        dma_flag_clear(DMA0, DMA_CH2, DMA_FLAG_G);
;;;967    
;;;968        // 使能TX的TC中断
;;;969        dma_interrupt_enable(DMA0, DMA_CH2, DMA_INT_FTF);
;;;970    
;;;971        // 开启DMA通道DMA0_Channel2
;;;972        spi_dma_enable(SPI0, SPI_DMA_TRANSMIT);
;;;973    
;;;974    #endif
;;;975    }
;;;976    
                          ENDP

00006e  0000              DCW      0x0000
                  |L28.112|
                          DCD      0x40013000
                  |L28.116|
                          DCD      ||.bss||+0x1c
                  |L28.120|
                          DCD      0x40020000
                  |L28.124|
                          DCD      0x40011800

                          AREA ||i.SPIx_FLASH_Init||, CODE, READONLY, ALIGN=2

                  SPIx_FLASH_Init PROC
;;;74     // 初始化SPI Flash驱动端口
;;;75     void SPIx_FLASH_Init(void)
000000  b570              PUSH     {r4-r6,lr}
;;;76     {
;;;77         // GD32 - SPI
;;;78         /*
;;;79          * PB3 --> SPI1 SCK             Mode: GPIO_Mode_AF_PP
;;;80          * PB5 --> SPI1 MOSI Write  Mode: GPIO_Mode_AF_PP
;;;81          * PB4 --> SPI1 MISO Read   Mode: GPIO_Mode_IPU
;;;82          * PE1 --> SPI1 CS          Mode: GPIO_Mode_Out_PP
;;;83          */
;;;84     
;;;85         // 使能GPIO时钟
;;;86         rcu_periph_clock_enable(RCU_GPIOB);
000002  f2406003          MOV      r0,#0x603
000006  f7fffffe          BL       rcu_periph_clock_enable
;;;87         rcu_periph_clock_enable(RCU_GPIOE);
00000a  f2406006          MOV      r0,#0x606
00000e  f7fffffe          BL       rcu_periph_clock_enable
;;;88         rcu_periph_clock_enable(RCU_SPI2);
000012  f240700f          MOV      r0,#0x70f
000016  f7fffffe          BL       rcu_periph_clock_enable
;;;89         rcu_periph_clock_enable(RCU_AF);
00001a  f44f60c0          MOV      r0,#0x600
00001e  f7fffffe          BL       rcu_periph_clock_enable
;;;90     
;;;91         //禁用JTAG引脚功能，操作的是AF寄存器，所以要先使能AF时钟
;;;92         gpio_pin_remap_config(GPIO_SWJ_SWDPENABLE_REMAP, ENABLE);
000022  2101              MOVS     r1,#1
000024  4818              LDR      r0,|L29.136|
000026  f7fffffe          BL       gpio_pin_remap_config
;;;93     
;;;94         // SPI0 GPIO config: SCK/PB3, MOSI/PB5
;;;95         gpio_init(GPIOB, GPIO_MODE_AF_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_3 | GPIO_PIN_5);
00002a  4c18              LDR      r4,|L29.140|
00002c  2328              MOVS     r3,#0x28
00002e  2203              MOVS     r2,#3
000030  2118              MOVS     r1,#0x18
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       gpio_init
;;;96     
;;;97         // SPI0 GPIO config: MISO/PB4
;;;98         gpio_init(GPIOB, GPIO_MODE_IPU, GPIO_OSPEED_50MHZ, GPIO_PIN_4);
000038  2310              MOVS     r3,#0x10
00003a  2203              MOVS     r2,#3
00003c  2148              MOVS     r1,#0x48
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       gpio_init
;;;99     
;;;100        // SPI0 GPIO config: NSS/PE1
;;;101        gpio_init(GPIOE, GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_1);
000044  2302              MOVS     r3,#2
000046  2203              MOVS     r2,#3
000048  2110              MOVS     r1,#0x10
00004a  4811              LDR      r0,|L29.144|
00004c  f7fffffe          BL       gpio_init
;;;102    
;;;103        // SPIx配置选项
;;;104    
;;;105        spi_i2s_deinit(STM32_SPIx_NUM_DEF);
000050  4d10              LDR      r5,|L29.148|
000052  4628              MOV      r0,r5
000054  f7fffffe          BL       spi_i2s_deinit
;;;106    
;;;107        spi_init_struct.trans_mode = SPI_TRANSMODE_FULLDUPLEX;
000058  490f              LDR      r1,|L29.152|
00005a  2400              MOVS     r4,#0
00005c  604c              STR      r4,[r1,#4]  ; spi_init_struct
;;;108        spi_init_struct.device_mode = SPI_MASTER;
00005e  f44f7082          MOV      r0,#0x104
000062  6008              STR      r0,[r1,#0]  ; spi_init_struct
;;;109        spi_init_struct.frame_size = SPI_FRAMESIZE_8BIT;
000064  608c              STR      r4,[r1,#8]  ; spi_init_struct
;;;110        spi_init_struct.clock_polarity_phase = SPI_CK_PL_LOW_PH_1EDGE; // 空闲时CLK拉底，在第一个时钟跳变沿采集第一个数据
000066  614c              STR      r4,[r1,#0x14]  ; spi_init_struct
;;;111        spi_init_struct.nss = SPI_NSS_SOFT;                            // 片选软件控制
000068  1568              ASRS     r0,r5,#21
00006a  60c8              STR      r0,[r1,#0xc]  ; spi_init_struct
;;;112    
;;;113        // APB2 - SPI0 - 72M
;;;114        // APB1 - SPI1/SPI2 - 36M
;;;115        spi_init_struct.prescale = SPI_PSC_4;    // 72/4=18M
00006c  2008              MOVS     r0,#8
00006e  6188              STR      r0,[r1,#0x18]  ; spi_init_struct
;;;116        spi_init_struct.endian = SPI_ENDIAN_MSB; // 先发送高位
000070  610c              STR      r4,[r1,#0x10]  ; spi_init_struct
;;;117        spi_init(STM32_SPIx_NUM_DEF, &spi_init_struct);
000072  4628              MOV      r0,r5
000074  f7fffffe          BL       spi_init
;;;118    
;;;119        // 使能SPIx
;;;120        spi_enable(STM32_SPIx_NUM_DEF);
000078  4628              MOV      r0,r5
00007a  f7fffffe          BL       spi_enable
;;;121    
;;;122        // 使能DMA功能
;;;123        DMAy_SPIx_Configuration();
00007e  f7fffffe          BL       DMAy_SPIx_Configuration
;;;124    
;;;125        spiCB.dmaFinished = FALSE;
000082  4806              LDR      r0,|L29.156|
000084  7004              STRB     r4,[r0,#0]
;;;126    
;;;127    #if SPI_FLASH_UNIT_TEST
;;;128        SPI_FLASH_UnitTest();
;;;129    #endif
;;;130    }
000086  bd70              POP      {r4-r6,pc}
;;;131    
                          ENDP

                  |L29.136|
                          DCD      0x00300200
                  |L29.140|
                          DCD      0x40010c00
                  |L29.144|
                          DCD      0x40011800
                  |L29.148|
                          DCD      0x40003c00
                  |L29.152|
                          DCD      ||.bss||
                  |L29.156|
                          DCD      ||.data||+0x4

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  spi_init_struct
                          %        28
                  dma_tx_init_struct
                          %        28
                  dma_rx_init_struct
                          %        28

                          AREA ||.data||, DATA, ALIGN=1

                  txByte
000000  00ff              DCW      0x00ff
                  rxByte
000002  00ff              DCW      0x00ff
                  spiCB
000004  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "User\\spiflash.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_spiflash_c_de66f17a____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___10_spiflash_c_de66f17a____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_spiflash_c_de66f17a____REVSH|
#line 128
|__asm___10_spiflash_c_de66f17a____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
