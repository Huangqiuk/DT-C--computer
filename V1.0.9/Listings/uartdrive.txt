; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\uartdrive.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\uartdrive.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -I.\User\qrencode -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.3\Device\Include -D__MICROLIB -D__UVISION_VERSION=539 -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\uartdrive.crf User\UartDrive.c]
                          THUMB

                          AREA ||i.UART_DRIVE_AddTxArray||, CODE, READONLY, ALIGN=2

                  UART_DRIVE_AddTxArray PROC
;;;318    // 向发送缓冲区中添加一条待发送序列
;;;319    BOOL UART_DRIVE_AddTxArray(uint16 id, uint8 *pArray, uint16 length)
000000  b5f0              PUSH     {r4-r7,lr}
;;;320    {
000002  4605              MOV      r5,r0
;;;321    	uint16 i;
;;;322    	uint16 head = uartDriveCB.tx.head;
000004  482b              LDR      r0,|L1.180|
000006  f8b064d4          LDRH     r6,[r0,#0x4d4]
;;;323    	uint16 end = uartDriveCB.tx.end;
00000a  f8b044d6          LDRH     r4,[r0,#0x4d6]
;;;324    
;;;325    	// 参数检验
;;;326    	if ((NULL == pArray) || (0 == length))
00000e  b101              CBZ      r1,|L1.18|
000010  b90a              CBNZ     r2,|L1.22|
                  |L1.18|
;;;327    	{
;;;328    		return FALSE;
000012  2000              MOVS     r0,#0
                  |L1.20|
;;;329    	}
;;;330    
;;;331    	// 发送缓冲区已满，不予接收
;;;332    	if ((end + 1) % UART_DRIVE_TX_QUEUE_SIZE == head)
;;;333    	{
;;;334    		return FALSE;
;;;335    	}
;;;336    
;;;337    	uartDriveCB.tx.cmdQueue[end].deviceID = id;
;;;338    	for (i = 0; i < length; i++)
;;;339    	{
;;;340    		uartDriveCB.tx.cmdQueue[end].buff[i] = *pArray++;
;;;341    	}
;;;342    	uartDriveCB.tx.cmdQueue[end].length = length;
;;;343    
;;;344    	// 发送环形队列更新位置
;;;345    	uartDriveCB.tx.end++;
;;;346    	uartDriveCB.tx.end %= UART_DRIVE_TX_QUEUE_SIZE;
;;;347    	uartDriveCB.tx.cmdQueue[uartDriveCB.tx.end].length = 0;
;;;348    
;;;349    	return TRUE;
;;;350    }
000014  bdf0              POP      {r4-r7,pc}
                  |L1.22|
000016  1c60              ADDS     r0,r4,#1              ;332
000018  17c7              ASRS     r7,r0,#31             ;332
00001a  eb007757          ADD      r7,r0,r7,LSR #29      ;332
00001e  10ff              ASRS     r7,r7,#3              ;332
000020  eba007c7          SUB      r7,r0,r7,LSL #3       ;332
000024  42b7              CMP      r7,r6                 ;332
000026  d101              BNE      |L1.44|
000028  2000              MOVS     r0,#0                 ;334
00002a  e7f3              B        |L1.20|
                  |L1.44|
00002c  204d              MOVS     r0,#0x4d              ;337
00002e  4360              MULS     r0,r4,r0              ;337
000030  4f20              LDR      r7,|L1.180|
000032  1d3f              ADDS     r7,r7,#4              ;337
000034  f8275010          STRH     r5,[r7,r0,LSL #1]     ;337
000038  2300              MOVS     r3,#0                 ;338
00003a  e00c              B        |L1.86|
                  |L1.60|
00003c  f811cb01          LDRB     r12,[r1],#1           ;340
000040  204d              MOVS     r0,#0x4d              ;340
000042  4360              MULS     r0,r4,r0              ;340
000044  4f1b              LDR      r7,|L1.180|
000046  1d3f              ADDS     r7,r7,#4              ;340
000048  eb070040          ADD      r0,r7,r0,LSL #1       ;340
00004c  1c80              ADDS     r0,r0,#2              ;340
00004e  f800c003          STRB     r12,[r0,r3]           ;340
000052  1c58              ADDS     r0,r3,#1              ;338
000054  b283              UXTH     r3,r0                 ;338
                  |L1.86|
000056  4293              CMP      r3,r2                 ;338
000058  dbf0              BLT      |L1.60|
00005a  204d              MOVS     r0,#0x4d              ;342
00005c  4360              MULS     r0,r4,r0              ;342
00005e  4f15              LDR      r7,|L1.180|
000060  1d3f              ADDS     r7,r7,#4              ;342
000062  eb070040          ADD      r0,r7,r0,LSL #1       ;342
000066  f8a02098          STRH     r2,[r0,#0x98]         ;342
00006a  1f38              SUBS     r0,r7,#4              ;345
00006c  f8b004d6          LDRH     r0,[r0,#0x4d6]        ;345
000070  1c40              ADDS     r0,r0,#1              ;345
000072  b287              UXTH     r7,r0                 ;345
000074  480f              LDR      r0,|L1.180|
000076  f8a074d6          STRH     r7,[r0,#0x4d6]        ;345
00007a  4607              MOV      r7,r0                 ;346
00007c  f8b704d6          LDRH     r0,[r7,#0x4d6]        ;346
000080  17c7              ASRS     r7,r0,#31             ;346
000082  eb007757          ADD      r7,r0,r7,LSR #29      ;346
000086  10ff              ASRS     r7,r7,#3              ;346
000088  eba007c7          SUB      r7,r0,r7,LSL #3       ;346
00008c  fa1ffc87          UXTH     r12,r7                ;346
000090  4f08              LDR      r7,|L1.180|
000092  f8a7c4d6          STRH     r12,[r7,#0x4d6]       ;346
000096  f04f0c00          MOV      r12,#0                ;347
00009a  4638              MOV      r0,r7                 ;347
00009c  f8b004d6          LDRH     r0,[r0,#0x4d6]        ;347
0000a0  274d              MOVS     r7,#0x4d              ;347
0000a2  4378              MULS     r0,r7,r0              ;347
0000a4  4f03              LDR      r7,|L1.180|
0000a6  1d3f              ADDS     r7,r7,#4              ;347
0000a8  eb070040          ADD      r0,r7,r0,LSL #1       ;347
0000ac  f8a0c098          STRH     r12,[r0,#0x98]        ;347
0000b0  2001              MOVS     r0,#1                 ;349
0000b2  e7af              B        |L1.20|
                          ENDP

                  |L1.180|
                          DCD      uartDriveCB

                          AREA ||i.UART_DRIVE_BC_SendData||, CODE, READONLY, ALIGN=2

                  UART_DRIVE_BC_SendData PROC
;;;224    // 阻塞发送一个字节数据
;;;225    void UART_DRIVE_BC_SendData(uint8 data)
000000  b510              PUSH     {r4,lr}
;;;226    {
000002  4604              MOV      r4,r0
;;;227    	// 防止丢失第一个字节(清除空标志位,务必加)
;;;228    	usart_flag_get(UART_DRIVE_TYPE_DEF, USART_FLAG_TC);
000004  2106              MOVS     r1,#6
000006  4807              LDR      r0,|L2.36|
000008  f7fffffe          BL       usart_flag_get
;;;229    
;;;230    	// 填充数据
;;;231    	usart_data_transmit(UART_DRIVE_TYPE_DEF, data);
00000c  4621              MOV      r1,r4
00000e  4805              LDR      r0,|L2.36|
000010  f7fffffe          BL       usart_data_transmit
;;;232    
;;;233    	// 未发送完，持续等待
;;;234    	while (usart_flag_get(UART_DRIVE_TYPE_DEF, USART_FLAG_TC) != SET)
000014  bf00              NOP      
                  |L2.22|
000016  2106              MOVS     r1,#6
000018  4802              LDR      r0,|L2.36|
00001a  f7fffffe          BL       usart_flag_get
00001e  2801              CMP      r0,#1
000020  d1f9              BNE      |L2.22|
;;;235    		;
;;;236    }
000022  bd10              POP      {r4,pc}
;;;237    
                          ENDP

                  |L2.36|
                          DCD      0x40013800

                          AREA ||i.UART_DRIVE_BC_StartTx||, CODE, READONLY, ALIGN=1

                  UART_DRIVE_BC_StartTx PROC
;;;238    // 启动阻塞发送
;;;239    void UART_DRIVE_BC_StartTx(UART_DRIVE_CB *pCB)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;240    {
000004  4604              MOV      r4,r0
;;;241    	uint16 index = pCB->tx.index;
000006  f8b464d8          LDRH     r6,[r4,#0x4d8]
;;;242    	uint16 head = pCB->tx.head;
00000a  f8b454d4          LDRH     r5,[r4,#0x4d4]
;;;243    	uint16 end = pCB->tx.end;
00000e  f8b484d6          LDRH     r8,[r4,#0x4d6]
;;;244    
;;;245    	// 参数合法性检验
;;;246    	if (NULL == pCB)
000012  b90c              CBNZ     r4,|L3.24|
                  |L3.20|
;;;247    	{
;;;248    		return;
;;;249    	}
;;;250    
;;;251    	// 队列为空，不处理
;;;252    	if (head == end)
;;;253    	{
;;;254    		return;
;;;255    	}
;;;256    
;;;257    	// 当前命令帧未发送完时，持续发送
;;;258    	while (index < pCB->tx.cmdQueue[head].length)
;;;259    	{
;;;260    		// 一直填充发送
;;;261    		UART_DRIVE_BC_SendData(pCB->tx.cmdQueue[head].buff[pCB->tx.index++]);
;;;262    
;;;263    		index = pCB->tx.index;
;;;264    	}
;;;265    
;;;266    	// 当前命令帧发送完时，删除之
;;;267    	pCB->tx.cmdQueue[head].length = 0;
;;;268    	pCB->tx.head++;
;;;269    	pCB->tx.head %= UART_DRIVE_TX_QUEUE_SIZE;
;;;270    	pCB->tx.index = 0;
;;;271    }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L3.24|
000018  4545              CMP      r5,r8                 ;252
00001a  d100              BNE      |L3.30|
00001c  e7fa              B        |L3.20|
                  |L3.30|
00001e  e00f              B        |L3.64|
                  |L3.32|
000020  f8b474d8          LDRH     r7,[r4,#0x4d8]        ;261
000024  1c79              ADDS     r1,r7,#1              ;261
000026  f8a414d8          STRH     r1,[r4,#0x4d8]        ;261
00002a  214d              MOVS     r1,#0x4d              ;261
00002c  4369              MULS     r1,r5,r1              ;261
00002e  1d22              ADDS     r2,r4,#4              ;261
000030  eb020141          ADD      r1,r2,r1,LSL #1       ;261
000034  1c89              ADDS     r1,r1,#2              ;261
000036  5dc8              LDRB     r0,[r1,r7]            ;261
000038  f7fffffe          BL       UART_DRIVE_BC_SendData
00003c  f8b464d8          LDRH     r6,[r4,#0x4d8]        ;263
                  |L3.64|
000040  204d              MOVS     r0,#0x4d              ;258
000042  4368              MULS     r0,r5,r0              ;258
000044  1d21              ADDS     r1,r4,#4              ;258
000046  eb010040          ADD      r0,r1,r0,LSL #1       ;258
00004a  f8b00098          LDRH     r0,[r0,#0x98]         ;258
00004e  42b0              CMP      r0,r6                 ;258
000050  dce6              BGT      |L3.32|
000052  2200              MOVS     r2,#0                 ;267
000054  204d              MOVS     r0,#0x4d              ;267
000056  4368              MULS     r0,r5,r0              ;267
000058  eb010040          ADD      r0,r1,r0,LSL #1       ;267
00005c  f8a02098          STRH     r2,[r0,#0x98]         ;267
000060  f8b404d4          LDRH     r0,[r4,#0x4d4]        ;268
000064  1c40              ADDS     r0,r0,#1              ;268
000066  f8a404d4          STRH     r0,[r4,#0x4d4]        ;268
00006a  f8b404d4          LDRH     r0,[r4,#0x4d4]        ;269
00006e  17c1              ASRS     r1,r0,#31             ;269
000070  eb007151          ADD      r1,r0,r1,LSR #29      ;269
000074  10c9              ASRS     r1,r1,#3              ;269
000076  eba001c1          SUB      r1,r0,r1,LSL #3       ;269
00007a  f8a414d4          STRH     r1,[r4,#0x4d4]        ;269
00007e  2100              MOVS     r1,#0                 ;270
000080  f8a414d8          STRH     r1,[r4,#0x4d8]        ;270
000084  bf00              NOP      
000086  e7c5              B        |L3.20|
;;;272    
                          ENDP


                          AREA ||i.UART_DRIVE_DataStructInit||, CODE, READONLY, ALIGN=1

                  UART_DRIVE_DataStructInit PROC
;;;62     // 数据结构初始化
;;;63     void UART_DRIVE_DataStructInit(UART_DRIVE_CB *pCB)
000000  b510              PUSH     {r4,lr}
;;;64     {
;;;65     	uint16 i;
;;;66     
;;;67     	// 参数合法性检验
;;;68     	if (NULL == pCB)
000002  b900              CBNZ     r0,|L4.6|
                  |L4.4|
;;;69     	{
;;;70     		return;
;;;71     	}
;;;72     
;;;73     	pCB->tx.txBusy = FALSE;
;;;74     	pCB->tx.index = 0;
;;;75     	pCB->tx.head = 0;
;;;76     	pCB->tx.end = 0;
;;;77     	for (i = 0; i < UART_DRIVE_TX_QUEUE_SIZE; i++)
;;;78     	{
;;;79     		pCB->tx.cmdQueue[i].length = 0;
;;;80     	}
;;;81     }
000004  bd10              POP      {r4,pc}
                  |L4.6|
000006  2300              MOVS     r3,#0                 ;73
000008  f88034da          STRB     r3,[r0,#0x4da]        ;73
00000c  f8a034d8          STRH     r3,[r0,#0x4d8]        ;74
000010  f8a034d4          STRH     r3,[r0,#0x4d4]        ;75
000014  f8a034d6          STRH     r3,[r0,#0x4d6]        ;76
000018  2100              MOVS     r1,#0                 ;77
00001a  e009              B        |L4.48|
                  |L4.28|
00001c  2400              MOVS     r4,#0                 ;79
00001e  224d              MOVS     r2,#0x4d              ;79
000020  434a              MULS     r2,r1,r2              ;79
000022  1d03              ADDS     r3,r0,#4              ;79
000024  eb030242          ADD      r2,r3,r2,LSL #1       ;79
000028  f8a24098          STRH     r4,[r2,#0x98]         ;79
00002c  1c4a              ADDS     r2,r1,#1              ;77
00002e  b291              UXTH     r1,r2                 ;77
                  |L4.48|
000030  2908              CMP      r1,#8                 ;77
000032  dbf3              BLT      |L4.28|
000034  bf00              NOP      
000036  e7e5              B        |L4.4|
;;;82     
                          ENDP


                          AREA ||i.UART_DRIVE_HwInit||, CODE, READONLY, ALIGN=2

                  UART_DRIVE_HwInit PROC
;;;83     // UART初始化
;;;84     void UART_DRIVE_HwInit(uint32 baud)
000000  b510              PUSH     {r4,lr}
;;;85     {
000002  4604              MOV      r4,r0
;;;86     	// GD32
;;;87     	// 时钟配置
;;;88     	rcu_periph_clock_enable(RCU_GPIOA);
000004  f2406002          MOV      r0,#0x602
000008  f7fffffe          BL       rcu_periph_clock_enable
;;;89     
;;;90     	// GPIO配置
;;;91     	gpio_init(GPIOA, GPIO_MODE_AF_PP, GPIO_OSPEED_2MHZ, GPIO_PIN_9); // 复用推挽
00000c  f44f7300          MOV      r3,#0x200
000010  2202              MOVS     r2,#2
000012  2118              MOVS     r1,#0x18
000014  4824              LDR      r0,|L5.168|
000016  f7fffffe          BL       gpio_init
;;;92     
;;;93     	gpio_init(GPIOA, GPIO_MODE_IPU, GPIO_OSPEED_2MHZ, GPIO_PIN_10); // 上拉输入
00001a  f44f6380          MOV      r3,#0x400
00001e  2202              MOVS     r2,#2
000020  2148              MOVS     r1,#0x48
000022  4821              LDR      r0,|L5.168|
000024  f7fffffe          BL       gpio_init
;;;94     
;;;95     	// UART时钟配置
;;;96     	rcu_periph_clock_enable(RCU_USART0); // 时能USART时钟
000028  f240600e          MOV      r0,#0x60e
00002c  f7fffffe          BL       rcu_periph_clock_enable
;;;97     	usart_deinit(UART_DRIVE_TYPE_DEF);	 // 复位串口
000030  481e              LDR      r0,|L5.172|
000032  f7fffffe          BL       usart_deinit
;;;98     
;;;99     	// 时钟配置
;;;100    	rcu_periph_clock_enable(RCU_GPIOB);
000036  f2406003          MOV      r0,#0x603
00003a  f7fffffe          BL       rcu_periph_clock_enable
;;;101    	gpio_init(GPIOB, GPIO_MODE_OUT_PP, GPIO_OSPEED_2MHZ, GPIO_PIN_14);
00003e  f44f4380          MOV      r3,#0x4000
000042  2202              MOVS     r2,#2
000044  2110              MOVS     r1,#0x10
000046  481a              LDR      r0,|L5.176|
000048  f7fffffe          BL       gpio_init
;;;102    
;;;103    	// 串口电平切换 3.3/5V
;;;104    	//	if (PARAM_GetUartLevel())
;;;105    	//	{
;;;106    	//		gpio_bit_reset(GPIOB, GPIO_PIN_14);
;;;107    	//	}
;;;108    	//	else
;;;109    	//	{
;;;110    	//		gpio_bit_set(GPIOB, GPIO_PIN_14);
;;;111    	//	}
;;;112    
;;;113    	// 串口配置
;;;114    	usart_baudrate_set(UART_DRIVE_TYPE_DEF, baud);							// 波特率
00004c  4621              MOV      r1,r4
00004e  4817              LDR      r0,|L5.172|
000050  f7fffffe          BL       usart_baudrate_set
;;;115    	usart_word_length_set(UART_DRIVE_TYPE_DEF, USART_WL_8BIT);				// 8位数据位
000054  2100              MOVS     r1,#0
000056  4815              LDR      r0,|L5.172|
000058  f7fffffe          BL       usart_word_length_set
;;;116    	usart_stop_bit_set(UART_DRIVE_TYPE_DEF, USART_STB_1BIT);				// 一个停止位
00005c  2100              MOVS     r1,#0
00005e  4813              LDR      r0,|L5.172|
000060  f7fffffe          BL       usart_stop_bit_set
;;;117    	usart_parity_config(UART_DRIVE_TYPE_DEF, USART_PM_NONE);				// 无奇偶校验
000064  2100              MOVS     r1,#0
000066  4811              LDR      r0,|L5.172|
000068  f7fffffe          BL       usart_parity_config
;;;118    	usart_hardware_flow_rts_config(UART_DRIVE_TYPE_DEF, USART_RTS_DISABLE); // 无硬件数据流控制
00006c  2100              MOVS     r1,#0
00006e  480f              LDR      r0,|L5.172|
000070  f7fffffe          BL       usart_hardware_flow_rts_config
;;;119    	usart_hardware_flow_cts_config(UART_DRIVE_TYPE_DEF, USART_CTS_DISABLE);
000074  2100              MOVS     r1,#0
000076  480d              LDR      r0,|L5.172|
000078  f7fffffe          BL       usart_hardware_flow_cts_config
;;;120    	usart_transmit_config(UART_DRIVE_TYPE_DEF, USART_TRANSMIT_ENABLE); // 使能发射
00007c  2108              MOVS     r1,#8
00007e  480b              LDR      r0,|L5.172|
000080  f7fffffe          BL       usart_transmit_config
;;;121    	usart_receive_config(UART_DRIVE_TYPE_DEF, USART_RECEIVE_ENABLE);   // 使能接收
000084  2104              MOVS     r1,#4
000086  4809              LDR      r0,|L5.172|
000088  f7fffffe          BL       usart_receive_config
;;;122    
;;;123    	// 中断配置
;;;124    	nvic_irq_enable(UART_DRIVE_IRQn_DEF, 2, 1);
00008c  2201              MOVS     r2,#1
00008e  2102              MOVS     r1,#2
000090  2025              MOVS     r0,#0x25
000092  f7fffffe          BL       nvic_irq_enable
;;;125    
;;;126    	usart_interrupt_enable(UART_DRIVE_TYPE_DEF, USART_INT_RBNE); // 开启中断
000096  f2403105          MOV      r1,#0x305
00009a  4804              LDR      r0,|L5.172|
00009c  f7fffffe          BL       usart_interrupt_enable
;;;127    
;;;128    	usart_enable(UART_DRIVE_TYPE_DEF); // 使能串口
0000a0  4802              LDR      r0,|L5.172|
0000a2  f7fffffe          BL       usart_enable
;;;129    }
0000a6  bd10              POP      {r4,pc}
;;;130    
                          ENDP

                  |L5.168|
                          DCD      0x40010800
                  |L5.172|
                          DCD      0x40013800
                  |L5.176|
                          DCD      0x40010c00

                          AREA ||i.UART_DRIVE_IR_StartSendData||, CODE, READONLY, ALIGN=2

                  UART_DRIVE_IR_StartSendData PROC
;;;211    // 启动中断字节发送
;;;212    void UART_DRIVE_IR_StartSendData(uint8 data)
000000  b510              PUSH     {r4,lr}
;;;213    {
000002  4604              MOV      r4,r0
;;;214    	// 先读SR，再填充DR会把TC标志清掉
;;;215    	usart_flag_get(UART_DRIVE_TYPE_DEF, USART_FLAG_TC);
000004  2106              MOVS     r1,#6
000006  4806              LDR      r0,|L6.32|
000008  f7fffffe          BL       usart_flag_get
;;;216    
;;;217    	// 发送一个字节
;;;218    	usart_data_transmit(UART_DRIVE_TYPE_DEF, data);
00000c  4621              MOV      r1,r4
00000e  4804              LDR      r0,|L6.32|
000010  f7fffffe          BL       usart_data_transmit
;;;219    
;;;220    	// 打开发送完成中断
;;;221    	usart_interrupt_enable(UART_DRIVE_TYPE_DEF, USART_INT_TC);
000014  f2403106          MOV      r1,#0x306
000018  4801              LDR      r0,|L6.32|
00001a  f7fffffe          BL       usart_interrupt_enable
;;;222    }
00001e  bd10              POP      {r4,pc}
;;;223    
                          ENDP

                  |L6.32|
                          DCD      0x40013800

                          AREA ||i.UART_DRIVE_Init||, CODE, READONLY, ALIGN=2

                  UART_DRIVE_Init PROC
;;;30     // UART初始化
;;;31     void UART_DRIVE_Init(void)
000000  b510              PUSH     {r4,lr}
;;;32     {
;;;33     	// 硬件UART配置
;;;34     	UART_DRIVE_HwInit(UART_DRIVE_BAUD_RATE);
000002  f44f30e1          MOV      r0,#0x1c200
000006  f7fffffe          BL       UART_DRIVE_HwInit
;;;35     
;;;36     	// UART数据结构初始化
;;;37     	UART_DRIVE_DataStructInit(&uartDriveCB);
00000a  4802              LDR      r0,|L7.20|
00000c  f7fffffe          BL       UART_DRIVE_DataStructInit
;;;38     }
000010  bd10              POP      {r4,pc}
;;;39     
                          ENDP

000012  0000              DCW      0x0000
                  |L7.20|
                          DCD      uartDriveCB

                          AREA ||i.UART_DRIVE_InitSelect||, CODE, READONLY, ALIGN=2

                  UART_DRIVE_InitSelect PROC
;;;39     
;;;40     void UART_DRIVE_InitSelect(uint32 baud)
000000  b510              PUSH     {r4,lr}
;;;41     {
000002  4604              MOV      r4,r0
;;;42     	// 硬件UART配置
;;;43     	UART_DRIVE_HwInit(baud);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       UART_DRIVE_HwInit
;;;44     
;;;45     	// UART数据结构初始化
;;;46     	UART_DRIVE_DataStructInit(&uartDriveCB);
00000a  4802              LDR      r0,|L8.20|
00000c  f7fffffe          BL       UART_DRIVE_DataStructInit
;;;47     }
000010  bd10              POP      {r4,pc}
;;;48     
                          ENDP

000012  0000              DCW      0x0000
                  |L8.20|
                          DCD      uartDriveCB

                          AREA ||i.UART_DRIVE_Process||, CODE, READONLY, ALIGN=2

                  UART_DRIVE_Process PROC
;;;49     // UART模块处理入口
;;;50     void UART_DRIVE_Process(void)
000000  b510              PUSH     {r4,lr}
;;;51     {
;;;52     	// 内部通讯接口的发送处理
;;;53     	UART_DRIVE_TxProcess(&uartDriveCB);
000002  4802              LDR      r0,|L9.12|
000004  f7fffffe          BL       UART_DRIVE_TxProcess
;;;54     }
000008  bd10              POP      {r4,pc}
;;;55     
                          ENDP

00000a  0000              DCW      0x0000
                  |L9.12|
                          DCD      uartDriveCB

                          AREA ||i.UART_DRIVE_RegisterDataSendService||, CODE, READONLY, ALIGN=2

                  UART_DRIVE_RegisterDataSendService PROC
;;;56     // 向协议层注册数据接收接口
;;;57     void UART_DRIVE_RegisterDataSendService(void (*service)(uint16 id, uint8 *pData, uint16 length))
000000  4901              LDR      r1,|L10.8|
;;;58     {
;;;59     	uartDriveCB.receiveDataThrowService = service;
000002  6008              STR      r0,[r1,#0]  ; uartDriveCB
;;;60     }
000004  4770              BX       lr
;;;61     
                          ENDP

000006  0000              DCW      0x0000
                  |L10.8|
                          DCD      uartDriveCB

                          AREA ||i.UART_DRIVE_TxProcess||, CODE, READONLY, ALIGN=1

                  UART_DRIVE_TxProcess PROC
;;;273    // 发送处理,发现发送缓冲区非空时,启动中断发送
;;;274    void UART_DRIVE_TxProcess(UART_DRIVE_CB *pCB)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;275    {
000004  4604              MOV      r4,r0
;;;276    // 中断方式
;;;277    #if (UART_DRIVE_TX_MODE == UART_DRIVE_INTERRUPT_TX_MODE)
;;;278    	uint16 index = pCB->tx.index;						   // 当前发送数据的索引号
000006  f8b474d8          LDRH     r7,[r4,#0x4d8]
;;;279    	uint16 length = pCB->tx.cmdQueue[pCB->tx.head].length; // 当前发送的命令帧的长度
00000a  f8b404d4          LDRH     r0,[r4,#0x4d4]
00000e  214d              MOVS     r1,#0x4d
000010  4348              MULS     r0,r1,r0
000012  1d21              ADDS     r1,r4,#4
000014  eb010040          ADD      r0,r1,r0,LSL #1
000018  f8b08098          LDRH     r8,[r0,#0x98]
;;;280    	uint16 head = pCB->tx.head;							   // 发送命令帧队列头索引号
00001c  f8b454d4          LDRH     r5,[r4,#0x4d4]
;;;281    	uint16 end = pCB->tx.end;							   // 发送命令帧队列尾索引号
000020  f8b494d6          LDRH     r9,[r4,#0x4d6]
;;;282    
;;;283    	// 参数合法性检验
;;;284    	if (NULL == pCB)
000024  b90c              CBNZ     r4,|L11.42|
                  |L11.38|
;;;285    	{
;;;286    		return;
;;;287    	}
;;;288    
;;;289    	// 队列为空，不处理
;;;290    	if (head == end)
;;;291    	{
;;;292    		return;
;;;293    	}
;;;294    
;;;295    	// 发送忙，退出
;;;296    	if (pCB->tx.txBusy)
;;;297    	{
;;;298    		return;
;;;299    	}
;;;300    
;;;301    	// ■■执行到这里，说明队列非空■■
;;;302    
;;;303    	// 当前命令帧未发送完时，取出一个字节放到发送寄存器中
;;;304    	if (index < length)
;;;305    	{
;;;306    		UART_DRIVE_IR_StartSendData(pCB->tx.cmdQueue[head].buff[pCB->tx.index++]);
;;;307    
;;;308    		// 设置发送忙状态
;;;309    		pCB->tx.txBusy = TRUE;
;;;310    	}
;;;311    
;;;312    // 阻塞方式时启动发送
;;;313    #else
;;;314    	UART_DRIVE_BC_StartTx(pCB);
;;;315    #endif
;;;316    }
000026  e8bd87f0          POP      {r4-r10,pc}
                  |L11.42|
00002a  454d              CMP      r5,r9                 ;290
00002c  d100              BNE      |L11.48|
00002e  e7fa              B        |L11.38|
                  |L11.48|
000030  f89404da          LDRB     r0,[r4,#0x4da]        ;296
000034  b100              CBZ      r0,|L11.56|
000036  e7f6              B        |L11.38|
                  |L11.56|
000038  4547              CMP      r7,r8                 ;304
00003a  da10              BGE      |L11.94|
00003c  f8b464d8          LDRH     r6,[r4,#0x4d8]        ;306
000040  1c71              ADDS     r1,r6,#1              ;306
000042  f8a414d8          STRH     r1,[r4,#0x4d8]        ;306
000046  214d              MOVS     r1,#0x4d              ;306
000048  4369              MULS     r1,r5,r1              ;306
00004a  1d22              ADDS     r2,r4,#4              ;306
00004c  eb020141          ADD      r1,r2,r1,LSL #1       ;306
000050  1c89              ADDS     r1,r1,#2              ;306
000052  5d88              LDRB     r0,[r1,r6]            ;306
000054  f7fffffe          BL       UART_DRIVE_IR_StartSendData
000058  2101              MOVS     r1,#1                 ;309
00005a  f88414da          STRB     r1,[r4,#0x4da]        ;309
                  |L11.94|
00005e  bf00              NOP      
000060  e7e1              B        |L11.38|
;;;317    
                          ENDP


                          AREA ||i.USART0_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART0_IRQHandler PROC
;;;137     *************************************************************/
;;;138    void USART0_IRQHandler(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;139    {
;;;140    	// 判断DR是否有数据，中断接收
;;;141    	if (usart_interrupt_flag_get(UART_DRIVE_TYPE_DEF, USART_INT_FLAG_RBNE) != RESET)
000002  494b              LDR      r1,|L12.304|
000004  484b              LDR      r0,|L12.308|
000006  f7fffffe          BL       usart_interrupt_flag_get
00000a  b188              CBZ      r0,|L12.48|
;;;142    	{
;;;143    		uint8 rxdata = 0x00;
00000c  2000              MOVS     r0,#0
00000e  9000              STR      r0,[sp,#0]
;;;144    
;;;145    		// 接收数据
;;;146    		rxdata = (uint8)usart_data_receive(UART_DRIVE_TYPE_DEF);
000010  4848              LDR      r0,|L12.308|
000012  f7fffffe          BL       usart_data_receive
000016  b2c0              UXTB     r0,r0
000018  9000              STR      r0,[sp,#0]
;;;147    
;;;148    		if (NULL != uartDriveCB.receiveDataThrowService)
00001a  4847              LDR      r0,|L12.312|
00001c  6800              LDR      r0,[r0,#0]  ; uartDriveCB
00001e  b130              CBZ      r0,|L12.46|
;;;149    		{
;;;150    			(*uartDriveCB.receiveDataThrowService)(0xFFF, &rxdata, 1);
000020  4845              LDR      r0,|L12.312|
000022  2201              MOVS     r2,#1
000024  4669              MOV      r1,sp
000026  6803              LDR      r3,[r0,#0]  ; uartDriveCB
000028  f64070ff          MOV      r0,#0xfff
00002c  4798              BLX      r3
                  |L12.46|
;;;151    		}
;;;152    	}
00002e  bf00              NOP      
                  |L12.48|
;;;153    
;;;154    // 中断模式发送
;;;155    #if (UART_DRIVE_TX_MODE == UART_DRIVE_INTERRUPT_TX_MODE)
;;;156    	// 判断DR是否有数据，中断发送
;;;157    	if (usart_interrupt_flag_get(UART_DRIVE_TYPE_DEF, USART_INT_FLAG_TC) != RESET)
000030  4942              LDR      r1,|L12.316|
000032  4840              LDR      r0,|L12.308|
000034  f7fffffe          BL       usart_interrupt_flag_get
000038  2800              CMP      r0,#0
00003a  d06c              BEQ      |L12.278|
;;;158    	{
;;;159    		uint16 head = uartDriveCB.tx.head;
00003c  483e              LDR      r0,|L12.312|
00003e  f8b044d4          LDRH     r4,[r0,#0x4d4]
;;;160    		uint16 end;
;;;161    		uint16 index = uartDriveCB.tx.index;
000042  f8b074d8          LDRH     r7,[r0,#0x4d8]
;;;162    		uint8 txdata = 0x00;
000046  2500              MOVS     r5,#0
;;;163    
;;;164    		// 执行到这里，说明上一个数据已经发送完毕，当前命令帧未发送完时，取出一个字节放到发送寄存器中
;;;165    		if (index < uartDriveCB.tx.cmdQueue[head].length)
000048  204d              MOVS     r0,#0x4d
00004a  4360              MULS     r0,r4,r0
00004c  493a              LDR      r1,|L12.312|
00004e  1d09              ADDS     r1,r1,#4
000050  eb010040          ADD      r0,r1,r0,LSL #1
000054  f8b00098          LDRH     r0,[r0,#0x98]
000058  42b8              CMP      r0,r7
00005a  dd14              BLE      |L12.134|
;;;166    		{
;;;167    			txdata = uartDriveCB.tx.cmdQueue[head].buff[uartDriveCB.tx.index++];
00005c  1f09              SUBS     r1,r1,#4
00005e  f8b104d8          LDRH     r0,[r1,#0x4d8]
000062  1c41              ADDS     r1,r0,#1
000064  b28a              UXTH     r2,r1
000066  4934              LDR      r1,|L12.312|
000068  f8a124d8          STRH     r2,[r1,#0x4d8]
00006c  214d              MOVS     r1,#0x4d
00006e  4361              MULS     r1,r4,r1
000070  4a31              LDR      r2,|L12.312|
000072  1d12              ADDS     r2,r2,#4
000074  eb020141          ADD      r1,r2,r1,LSL #1
000078  1c89              ADDS     r1,r1,#2
00007a  5c0d              LDRB     r5,[r1,r0]
;;;168    
;;;169    			// 填充数据
;;;170    			usart_data_transmit(UART_DRIVE_TYPE_DEF, txdata);
00007c  4629              MOV      r1,r5
00007e  482d              LDR      r0,|L12.308|
000080  f7fffffe          BL       usart_data_transmit
000084  e046              B        |L12.276|
                  |L12.134|
;;;171    		}
;;;172    		// 当前命令帧发送完时，删除之
;;;173    		else
;;;174    		{
;;;175    			uartDriveCB.tx.cmdQueue[head].length = 0;
000086  2200              MOVS     r2,#0
000088  204d              MOVS     r0,#0x4d
00008a  fb04f100          MUL      r1,r4,r0
00008e  482a              LDR      r0,|L12.312|
000090  1d00              ADDS     r0,r0,#4
000092  eb000041          ADD      r0,r0,r1,LSL #1
000096  f8a02098          STRH     r2,[r0,#0x98]
;;;176    			uartDriveCB.tx.head++;
00009a  4827              LDR      r0,|L12.312|
00009c  f8b004d4          LDRH     r0,[r0,#0x4d4]
0000a0  1c40              ADDS     r0,r0,#1
0000a2  b281              UXTH     r1,r0
0000a4  4824              LDR      r0,|L12.312|
0000a6  f8a014d4          STRH     r1,[r0,#0x4d4]
;;;177    			uartDriveCB.tx.head %= UART_DRIVE_TX_QUEUE_SIZE;
0000aa  4601              MOV      r1,r0
0000ac  f8b104d4          LDRH     r0,[r1,#0x4d4]
0000b0  17c1              ASRS     r1,r0,#31
0000b2  eb007151          ADD      r1,r0,r1,LSR #29
0000b6  10c9              ASRS     r1,r1,#3
0000b8  eba001c1          SUB      r1,r0,r1,LSL #3
0000bc  b28a              UXTH     r2,r1
0000be  491e              LDR      r1,|L12.312|
0000c0  f8a124d4          STRH     r2,[r1,#0x4d4]
;;;178    			uartDriveCB.tx.index = 0;
0000c4  2100              MOVS     r1,#0
0000c6  481c              LDR      r0,|L12.312|
0000c8  f8a014d8          STRH     r1,[r0,#0x4d8]
;;;179    
;;;180    			head = uartDriveCB.tx.head;
0000cc  f8b044d4          LDRH     r4,[r0,#0x4d4]
;;;181    			end = uartDriveCB.tx.end;
0000d0  f8b064d6          LDRH     r6,[r0,#0x4d6]
;;;182    
;;;183    			// 命令帧队列非空，继续发送下一个命令帧
;;;184    			if (head != end)
0000d4  42b4              CMP      r4,r6
0000d6  d014              BEQ      |L12.258|
;;;185    			{
;;;186    				txdata = uartDriveCB.tx.cmdQueue[head].buff[uartDriveCB.tx.index++];
0000d8  4601              MOV      r1,r0
0000da  f8b104d8          LDRH     r0,[r1,#0x4d8]
0000de  1c41              ADDS     r1,r0,#1
0000e0  b28a              UXTH     r2,r1
0000e2  4915              LDR      r1,|L12.312|
0000e4  f8a124d8          STRH     r2,[r1,#0x4d8]
0000e8  214d              MOVS     r1,#0x4d
0000ea  4361              MULS     r1,r4,r1
0000ec  4a12              LDR      r2,|L12.312|
0000ee  1d12              ADDS     r2,r2,#4
0000f0  eb020141          ADD      r1,r2,r1,LSL #1
0000f4  1c89              ADDS     r1,r1,#2
0000f6  5c0d              LDRB     r5,[r1,r0]
;;;187    
;;;188    				// 填充数据
;;;189    				usart_data_transmit(UART_DRIVE_TYPE_DEF, txdata);
0000f8  4629              MOV      r1,r5
0000fa  480e              LDR      r0,|L12.308|
0000fc  f7fffffe          BL       usart_data_transmit
000100  e008              B        |L12.276|
                  |L12.258|
;;;190    			}
;;;191    			// 命令帧队列为空停止发送，设置空闲
;;;192    			else
;;;193    			{
;;;194    				// 关闭发送空中断
;;;195    				usart_interrupt_disable(UART_DRIVE_TYPE_DEF, USART_INT_TC);
000102  f2403106          MOV      r1,#0x306
000106  480b              LDR      r0,|L12.308|
000108  f7fffffe          BL       usart_interrupt_disable
;;;196    
;;;197    				uartDriveCB.tx.txBusy = FALSE;
00010c  2100              MOVS     r1,#0
00010e  480a              LDR      r0,|L12.312|
000110  f88014da          STRB     r1,[r0,#0x4da]
                  |L12.276|
;;;198    			}
;;;199    		}
;;;200    	}
000114  bf00              NOP      
                  |L12.278|
;;;201    #endif
;;;202    
;;;203    	// Other USARTx interrupts handler can go here ...
;;;204    	if (usart_interrupt_flag_get(UART_DRIVE_TYPE_DEF, USART_INT_FLAG_ERR_ORERR) != RESET) //----------------------- 接收溢出中断
000116  490a              LDR      r1,|L12.320|
000118  4806              LDR      r0,|L12.308|
00011a  f7fffffe          BL       usart_interrupt_flag_get
00011e  b130              CBZ      r0,|L12.302|
;;;205    	{
;;;206    		usart_flag_get(UART_DRIVE_TYPE_DEF, USART_FLAG_ORERR); //----------------------- 清除接收溢出中断标志位
000120  2103              MOVS     r1,#3
000122  4804              LDR      r0,|L12.308|
000124  f7fffffe          BL       usart_flag_get
;;;207    		usart_data_receive(UART_DRIVE_TYPE_DEF);			   //----------------------- 清空寄存器
000128  4802              LDR      r0,|L12.308|
00012a  f7fffffe          BL       usart_data_receive
                  |L12.302|
;;;208    	}
;;;209    }
00012e  bdf8              POP      {r3-r7,pc}
;;;210    
                          ENDP

                  |L12.304|
                          DCD      0x00050305
                  |L12.308|
                          DCD      0x40013800
                  |L12.312|
                          DCD      uartDriveCB
                  |L12.316|
                          DCD      0x00060306
                  |L12.320|
                          DCD      0x00030500

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  uartDriveCB
                          %        1244

;*** Start embedded assembler ***

#line 1 "User\\UartDrive.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_UartDrive_c_14601980____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___11_UartDrive_c_14601980____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_UartDrive_c_14601980____REVSH|
#line 128
|__asm___11_UartDrive_c_14601980____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
