; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\uartprotocolxm.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\uartprotocolxm.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -I.\User\qrencode -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.3\Device\Include -D__MICROLIB -D__UVISION_VERSION=539 -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\uartprotocolxm.crf User\UartProtocolXM.c]
                          THUMB

                          AREA ||i.UART_PROTOCOL_XM_CheckSUM||, CODE, READONLY, ALIGN=1

                  UART_PROTOCOL_XM_CheckSUM PROC
;;;511    // 对传入的命令帧进行校验，返回校验结果
;;;512    BOOL UART_PROTOCOL_XM_CheckSUM(UART_PROTOCOL_XM_RX_CMD_FRAME *pCmdFrame)
000000  b510              PUSH     {r4,lr}
;;;513    {
000002  4604              MOV      r4,r0
;;;514        uint16 cc = 0;
;;;515        uint16 checkValue = 0;
;;;516    
;;;517        if (NULL == pCmdFrame)
000004  2c00              CMP      r4,#0
000006  d011              BEQ      |L1.44|
;;;518        {
;;;519            return FALSE;
;;;520        }
;;;521    
;;;522        // CRC校验
;;;523        checkValue = calCrc16(pCmdFrame->buff, pCmdFrame->length - 2);
000008  f8b41052          LDRH     r1,[r4,#0x52]
00000c  1ca0              ADDS     r0,r4,#2
00000e  1e89              SUBS     r1,r1,#2
000010  f7fffffe          BL       calCrc16
000014  4601              MOV      r1,r0
;;;524    
;;;525        cc = ((uint16)pCmdFrame->buff[pCmdFrame->length - 2] << 8) | (uint16)pCmdFrame->buff[pCmdFrame->length - 1];
000016  f8b40052          LDRH     r0,[r4,#0x52]
00001a  1c62              ADDS     r2,r4,#1
00001c  5c82              LDRB     r2,[r0,r2]
00001e  5c20              LDRB     r0,[r4,r0]
000020  ea422200          ORR      r2,r2,r0,LSL #8
;;;526    
;;;527        if (cc != checkValue)
000024  428a              CMP      r2,r1
000026  d003              BEQ      |L1.48|
;;;528        {
;;;529            return FALSE;
000028  2000              MOVS     r0,#0
;;;530        }
;;;531    
;;;532        return TRUE;
;;;533    }
00002a  bd10              POP      {r4,pc}
                  |L1.44|
00002c  2000              MOVS     r0,#0                 ;519
00002e  bd10              POP      {r4,pc}
                  |L1.48|
000030  2001              MOVS     r0,#1                 ;532
000032  bd10              POP      {r4,pc}
;;;534    
                          ENDP


                          AREA ||i.UART_PROTOCOL_XM_CmdFrameProcess||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL_XM_CmdFrameProcess PROC
;;;538    // UART命令帧缓冲区处理
;;;539    void UART_PROTOCOL_XM_CmdFrameProcess(UART_PROTOCOL_XM_CB *pCB)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;540    {
000004  b09b              SUB      sp,sp,#0x6c
000006  4606              MOV      r6,r0
;;;541        UART_PROTOCOL_XM_CMD cmd = UART_PROTOCOL_XM_CMD_NULL;
;;;542        UART_PROTOCOL_XM_RX_CMD_FRAME *pCmdFrame = NULL;
;;;543    
;;;544        uint8 switch_state = 0;
;;;545        uint8 Peripheral_type = 0;
;;;546        uint8 calibration_result = 0;
;;;547        uint8 turn_item = 0;
;;;548        uint8 turn_state = 0;
;;;549        uint8 buffFlag[4] = {0xFF};
000008  48f7              LDR      r0,|L2.1000|
00000a  6800              LDR      r0,[r0,#0]  ; <Data2>
00000c  901a              STR      r0,[sp,#0x68]
;;;550        uint8 i =  0;
00000e  2400              MOVS     r4,#0
;;;551        uint8_t verType = 0;
;;;552        char  verBuff[100] = {0};
000010  2164              MOVS     r1,#0x64
000012  a801              ADD      r0,sp,#4
000014  f7fffffe          BL       __aeabi_memclr4
;;;553        BOOL testResult = 0;
000018  2300              MOVS     r3,#0
;;;554    
;;;555        // 参数合法性检验
;;;556        if (NULL == pCB)
00001a  2e00              CMP      r6,#0
00001c  d018              BEQ      |L2.80|
;;;557        {
;;;558            return;
;;;559        }
;;;560    
;;;561        // 命令帧缓冲区为空，退出
;;;562        if (pCB->rx.head == pCB->rx.end)
00001e  f8b60274          LDRH     r0,[r6,#0x274]
000022  f8b61276          LDRH     r1,[r6,#0x276]
000026  4288              CMP      r0,r1
000028  d012              BEQ      |L2.80|
;;;563        {
;;;564            return;
;;;565        }
;;;566    
;;;567        // 获取当前要处理的命令帧指针
;;;568        pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.head];
00002a  ebc001c0          RSB      r1,r0,r0,LSL #3
00002e  eb010141          ADD      r1,r1,r1,LSL #1
000032  eb060781          ADD      r7,r6,r1,LSL #2
000036  37d0              ADDS     r7,r7,#0xd0
;;;569    
;;;570        // 命令头非法，退出
;;;571        if (UART_PROTOCOL_XM_CMD_HEAD != pCmdFrame->buff[UART_PROTOCOL_XM_CMD_HEAD_INDEX])
000038  78b9              LDRB     r1,[r7,#2]
00003a  295a              CMP      r1,#0x5a
00003c  d00b              BEQ      |L2.86|
;;;572        {
;;;573            // 删除命令帧
;;;574            pCB->rx.head++;
00003e  1c40              ADDS     r0,r0,#1
000040  b280              UXTH     r0,r0
;;;575            pCB->rx.head %= UART_PROTOCOL_XM_RX_QUEUE_SIZE;
000042  2105              MOVS     r1,#5
000044  fbb0f2f1          UDIV     r2,r0,r1
000048  fb010012          MLS      r0,r1,r2,r0
00004c  f8a60274          STRH     r0,[r6,#0x274]
                  |L2.80|
;;;576            return;
;;;577        }
;;;578    
;;;579        // 命令头合法，则提取命令
;;;580        cmd = (UART_PROTOCOL_XM_CMD)pCmdFrame->buff[UART_PROTOCOL_XM_CMD_CMD_INDEX];
;;;581    
;;;582        // 执行命令帧
;;;583        switch (cmd)
;;;584        {
;;;585            // 空命令，不予执行
;;;586            case UART_PROTOCOL_XM_CMD_NULL:
;;;587                break;
;;;588    
;;;589            // 收到大灯应答
;;;590            case UART_PROTOCOL_XM_CMD_TEST_LIGHT:
;;;591                switch_state = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA1_INDEX];   // 执行结果
;;;592                light_cnt++;
;;;593    
;;;594                // 执行失败
;;;595                if (0x00 == switch_state)
;;;596                {
;;;597                    STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_MULTIPLE_TEST, FALSE);
;;;598                    TIMER_KillTask(TIMER_ID_DUT_TIMEOUT);
;;;599                }
;;;600    
;;;601                // 执行成功
;;;602                if (0x01 == (switch_state & 0x01))
;;;603                {
;;;604                    if (light_cnt == 1)
;;;605                    {
;;;606                        STATE_SwitchStep(STEP_HEADLIGHT_UART_TEST_OPEN);
;;;607                    }
;;;608                    if (light_cnt == 2)
;;;609                    {
;;;610                        STATE_SwitchStep(STEP_HEADLIGHT_UART_TEST_COMPLETE);
;;;611                        light_cnt = 0;
;;;612                    }
;;;613                }
;;;614                break;
;;;615                
;;;616            // 获取油门/刹车的模拟数字值
;;;617            case UART_PROTOCOL_XM_CMD_TEST_Throttle_Break:                      
;;;618    
;;;619                dut_info.throttleAd = pCmdFrame->buff[UART_PROTOCOL_XM_CMD_DATA1_INDEX];
;;;620                dut_info.brakeAd = pCmdFrame->buff[UART_PROTOCOL_XM_CMD_DATA2_INDEX];
;;;621    
;;;622                // 油门
;;;623                if (TEST_TYPE_XM_THROTTLE == dut_info.test)
;;;624                {
;;;625                    // 获取油门AD值
;;;626                    cnt++;
;;;627    
;;;628                    switch (cnt)
;;;629                    {
;;;630                        case 0:
;;;631                            break;
;;;632    
;;;633                        case 1:
;;;634                            STATE_SwitchStep(STEP_THROTTLE_UART_TEST_CHECK_DAC1_VALUE);
;;;635                            break;
;;;636    
;;;637                        case 2:
;;;638                            STATE_SwitchStep(STEP_THROTTLE_UART_TEST_CHECK_DAC3_VALUE);
;;;639                            break;
;;;640    
;;;641                        case 3:
;;;642                            STATE_SwitchStep(STEP_THROTTLE_UART_TEST_CHECK_DAC5_VALUE);
;;;643                            cnt = 0;
;;;644                            break;
;;;645    
;;;646                        default:
;;;647                            break;
;;;648                    }
;;;649                }
;;;650    
;;;651                // 刹把
;;;652                if (TEST_TYPE_XM_BRAKE == dut_info.test)
;;;653                {
;;;654                    // 获取刹把AD值
;;;655                    brake_cnt++;
;;;656    
;;;657                    switch (brake_cnt)
;;;658                    {
;;;659                        case 0:
;;;660                            break;
;;;661    
;;;662                        case 1:
;;;663                            STATE_SwitchStep(STEP_BRAKE_UART_TEST_CHECK_DAC1_VALUE);
;;;664                            break;
;;;665    
;;;666                        case 2:
;;;667                            STATE_SwitchStep(STEP_BRAKE_UART_TEST_CHECK_DAC3_VALUE);
;;;668                            break;
;;;669    
;;;670                        case 3:
;;;671                            STATE_SwitchStep(STEP_BRAKE_UART_TEST_CHECK_DAC5_VALUE);
;;;672                            brake_cnt = 0;
;;;673                            break;
;;;674    
;;;675                        default:
;;;676                            break;
;;;677                    }
;;;678                }
;;;679    
;;;680                break;
;;;681    
;;;682            // 转向灯控制
;;;683            case UART_PROTOCOL_XM_CMD_TEST_TURN_LIGHT:
;;;684                turn_item = pCmdFrame->buff[UART_PROTOCOL_XM_CMD_DATA1_INDEX];   // 转向灯类型
;;;685                light_cnt++;
;;;686    
;;;687                // 左转向灯
;;;688                if ((dut_info.test == TEST_TYPE_XM_LEFT_TURN_SIGNAL) && (1 == turn_item))
;;;689                {
;;;690                    if (light_cnt == 1)
;;;691                    {
;;;692                        STATE_SwitchStep(STEP_LEFT_TURN_SIGNAL_UART_TEST_OPEN);
;;;693                    }
;;;694                }
;;;695    
;;;696                // 右转向灯
;;;697                if ((dut_info.test == TEST_TYPE_XM_RIGHT_TURN_SIGNAL) && (2 == turn_item))
;;;698                {
;;;699                    if (light_cnt == 1)
;;;700                    {
;;;701                        STATE_SwitchStep(STEP_RIGHT_TURN_SIGNAL_UART_TEST_OPEN);
;;;702                    }
;;;703                }
;;;704    
;;;705                // 关灯
;;;706                if ((dut_info.test == TEST_TYPE_XM_LEFT_TURN_SIGNAL) && (0 == turn_item))
;;;707                {
;;;708                    if (light_cnt == 2)
;;;709                    {
;;;710                        STATE_SwitchStep(STEP_LEFT_TURN_SIGNAL_UART_TEST_COMPLETE);
;;;711                        light_cnt = 0;
;;;712                    }
;;;713                }
;;;714                // 关灯
;;;715                if ((dut_info.test == TEST_TYPE_XM_RIGHT_TURN_SIGNAL) && (0 == turn_item))
;;;716                {
;;;717                    if (light_cnt == 2)
;;;718                    {
;;;719                        STATE_SwitchStep(STEP_RIGHT_TURN_SIGNAL_UART_TEST_COMPLETE);
;;;720                        light_cnt = 0;
;;;721                    }
;;;722                }
;;;723                break;
;;;724    
;;;725            // 笔段屏/数码管显示测试
;;;726            case UART_PROTOCOL_XM_CMD_TEST_LED:
;;;727                 STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_DISPLAY_TEST, TRUE);
;;;728                break;
;;;729    
;;;730            // 测试按键
;;;731            case UART_PROTOCOL_XM_CMD_TEST_KEY:
;;;732                if(keyValue == pCmdFrame->buff[UART_PROTOCOL_XM_CMD_DATA1_INDEX])
;;;733                {
;;;734                     testResult = TRUE;
;;;735                }
;;;736                else
;;;737                {
;;;738                     testResult = FALSE;
;;;739                }
;;;740                STS_PROTOCOL_SendCmdParamTwoAck(STS_PROTOCOL_CMD_SIMULATION_KEY_TEST, testResult, pCmdFrame->buff[UART_PROTOCOL_XM_CMD_DATA1_INDEX]);
;;;741                break;
;;;742    
;;;743            // 蜂鸣器测试
;;;744            case UART_PROTOCOL_XM_CMD_TEST_BEEP:
;;;745                 STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_BUZZER_TEST, TRUE);
;;;746                break;
;;;747    
;;;748            // 在线检测
;;;749            case UART_PROTOCOL_XM_CMD_CONTORY_UP:
;;;750                online_detection_cnt++;
;;;751                TIMER_ResetTimer(TIMER_ID_ONLINE_DETECT);
;;;752    
;;;753                if(1 == online_detection_cnt)
;;;754                {
;;;755                   // 上报仪表启动状态
;;;756                   STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_ONLINE_DETECTION,TRUE);
;;;757                }
;;;758                break;
;;;759    
;;;760            // 读取标志区数据
;;;761            case UART_PROTOCOL_XM_CMD_READ_FLAG_DATA:
;;;762                TIMER_KillTask(TIMER_ID_WRITE_FLAG_TIMEOUT);
;;;763    
;;;764                // 读取标志区数据
;;;765                 buffFlag[0] = pCmdFrame->buff[stationNumber + 5];
;;;766    
;;;767                // 校验标志区数据
;;;768                if (buffFlag[0] == 2)
;;;769                {
;;;770                    STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_CHECK_STATION_FLAG, TRUE);
;;;771                }
;;;772                else
;;;773                {
;;;774                    STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_CHECK_STATION_FLAG, FALSE);
;;;775                }
;;;776                break;
;;;777    
;;;778            // 写入标志区数据
;;;779            case UART_PROTOCOL_XM_CMD_WRITE_FLAG_DATA:
;;;780    
;;;781                // 关闭写入超时定时器
;;;782                TIMER_ResetTimer(TIMER_ID_WRITE_FLAG_TIMEOUT);
;;;783    
;;;784                // 收到写入成功再读取出来进行校验
;;;785                if (pCmdFrame->buff[STS_PROTOCOL_CMD_DATA1_INDEX])
;;;786                {
;;;787                    UART_PROTOCOL_XM_SendCmdAck(UART_PROTOCOL_XM_CMD_READ_FLAG_DATA);
;;;788                }
;;;789                else
;;;790                {
;;;791                    STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_CHECK_STATION_FLAG, FALSE);
;;;792                }
;;;793                break;
;;;794    
;;;795            // 写入版本类型数据
;;;796            case UART_PROTOCOL_XM_CMD_WRITE_VERSION_TYPE:
;;;797    
;;;798                // 关闭定时器
;;;799                TIMER_ResetTimer(TIMER_ID_OPERATE_VER_TIMEOUT);
;;;800    
;;;801                // 获取类型
;;;802                verType =  pCmdFrame->buff[UART_PROTOCOL_XM_CMD_DATA1_INDEX];
;;;803    
;;;804                // 类型正确并且执行成功，上报STS
;;;805                if ((dutverType == verType) && (pCmdFrame->buff[UART_PROTOCOL_XM_CMD_DATA2_INDEX]))
;;;806                {
;;;807                    // 读取版本类型信息
;;;808                    UART_PROTOCOL_XM_SendCmdParamAck(UART_PROTOCOL_XM_CMD_READ_VERSION_TYPE, dutverType);
;;;809                }
;;;810                else
;;;811                {
;;;812                    STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_CHECK_VERSION_INFO, FALSE);
;;;813                }
;;;814                break;
;;;815    
;;;816            // 读取版本类型信息
;;;817            case UART_PROTOCOL_XM_CMD_READ_VERSION_TYPE:
;;;818                TIMER_KillTask(TIMER_ID_OPERATE_VER_TIMEOUT);
;;;819    
;;;820                // 获取类型
;;;821                verType =  pCmdFrame->buff[UART_PROTOCOL_XM_CMD_DATA1_INDEX];
;;;822    
;;;823                // 获取信息长度
;;;824                infoLen = pCmdFrame->buff[UART_PROTOCOL_XM_CMD_DATA2_INDEX];
;;;825    
;;;826                // 获取类型信息
;;;827                strcpy(verBuff, (const char *)&pCmdFrame->buff[UART_PROTOCOL_XM_CMD_DATA3_INDEX]);                        
;;;828                
;;;829                verBuff[infoLen] = 0;
;;;830                if(3 == verType)
;;;831                {
;;;832                     verBuff[infoLen - 1] = 0;            
;;;833                }
;;;834    
;;;835                // 只读取
;;;836                if (verreadFlag)
;;;837                {
;;;838                    if (verType == 1)
;;;839                    {
;;;840                        verType = 0;
;;;841                    }
;;;842                    else if (verType == 2)
;;;843                    {
;;;844                        verType = 1;
;;;845                    }
;;;846                    else if (verType == 3)
;;;847                    {
;;;848                        verType = 2;
;;;849                    }
;;;850                    else if (verType == 4)
;;;851                    {
;;;852                        verType = 4;
;;;853                    }
;;;854                    STS_PROTOCOL_TxAddData(STS_PROTOCOL_CMD_HEAD);
;;;855                    STS_PROTOCOL_TxAddData(STS_PROTOCOL_CMD_CHECK_VERSION_INFO);
;;;856                    STS_PROTOCOL_TxAddData(0x00);       // 数据长度
;;;857                    STS_PROTOCOL_TxAddData(1);          // 校验读取结果
;;;858                    STS_PROTOCOL_TxAddData(verType);    // 版本类型
;;;859                    
;;;860                    if(2 == verType)
;;;861                    {
;;;862                        STS_PROTOCOL_TxAddData(infoLen - 1);    // 信息长度
;;;863    
;;;864                        // 类型信息
;;;865                        for (i = 0; i < (infoLen - 1); i++)
;;;866                        {
;;;867                            STS_PROTOCOL_TxAddData(verBuff[i]);
;;;868                        }                
;;;869                    }
;;;870                    else
;;;871                    {
;;;872                        STS_PROTOCOL_TxAddData(infoLen);    // 信息长度
;;;873    
;;;874                        // 类型信息
;;;875                        for (i = 0; i < (infoLen); i++)
;;;876                        {
;;;877                            STS_PROTOCOL_TxAddData(verBuff[i]);
;;;878                        }                 
;;;879                    }
;;;880    
;;;881                    STS_PROTOCOL_TxAddFrame();     // 版本类型
;;;882                    verreadFlag = FALSE;
;;;883                }
;;;884    
;;;885                // 写入对比
;;;886                if (verwriteFlag)
;;;887                {
;;;888                    // 版本对比
;;;889                    if ((dutverType == verType) && (strstr((const char *)dutverBuff, (char *)verBuff) != NULL))
;;;890                    {
;;;891                        if (verType == 1)
;;;892                        {
;;;893                            verType = 0;
;;;894                        }
;;;895                        else if (verType == 2)
;;;896                        {
;;;897                            verType = 1;
;;;898                        }
;;;899                        else if (verType == 3)
;;;900                        {
;;;901                            verType = 2;
;;;902                        }
;;;903                        else if (verType == 4)
;;;904                        {
;;;905                            verType = 4;
;;;906                        }
;;;907                        STS_PROTOCOL_TxAddData(STS_PROTOCOL_CMD_HEAD);
;;;908                        STS_PROTOCOL_TxAddData(STS_PROTOCOL_CMD_CHECK_VERSION_INFO);
;;;909                        STS_PROTOCOL_TxAddData(0x00);       // 数据长度
;;;910                        STS_PROTOCOL_TxAddData(1);          // 校验读取结果
;;;911                        STS_PROTOCOL_TxAddData(verType);    // 版本类型
;;;912                        STS_PROTOCOL_TxAddData(infoLen);    // 信息长度
;;;913    
;;;914                        // 类型信息
;;;915                        for (i = 0; i < infoLen; i++)
;;;916                        {
;;;917                            STS_PROTOCOL_TxAddData(verBuff[i]);
;;;918                        }
;;;919                        STS_PROTOCOL_TxAddFrame();     // 版本类型
;;;920                    }
;;;921                    else
;;;922                    {
;;;923                        if (verType == 1)
;;;924                        {
;;;925                            verType = 0;
;;;926                        }
;;;927                        else if (verType == 2)
;;;928                        {
;;;929                            verType = 1;
;;;930                        }
;;;931                        else if (verType == 3)
;;;932                        {
;;;933                            verType = 2;
;;;934                        }
;;;935                        else if (verType == 4)
;;;936                        {
;;;937                            verType = 4;
;;;938                        }
;;;939                        STS_PROTOCOL_TxAddData(STS_PROTOCOL_CMD_HEAD);
;;;940                        STS_PROTOCOL_TxAddData(STS_PROTOCOL_CMD_CHECK_VERSION_INFO);
;;;941                        STS_PROTOCOL_TxAddData(0x00);       // 数据长度
;;;942                        STS_PROTOCOL_TxAddData(0);          // 校验读取结果
;;;943                        STS_PROTOCOL_TxAddData(verType);    // 版本类型
;;;944                        STS_PROTOCOL_TxAddData(infoLen);    // 信息长度
;;;945    
;;;946                        // 类型信息
;;;947                        for (i = 0; i < infoLen; i++)
;;;948                        {
;;;949                            STS_PROTOCOL_TxAddData(verBuff[i]);
;;;950                        }
;;;951                        STS_PROTOCOL_TxAddFrame();     // 版本类型
;;;952                    }
;;;953                    verwriteFlag = FALSE;
;;;954                }
;;;955    
;;;956                break;
;;;957    
;;;958            // 蓝牙测试
;;;959            case UART_PROTOCOL_XM_CMD_GET_OOB_PARAM:
;;;960    
;;;961                // 版本比对成功将MAC地址发给电源板连接
;;;962                if (checkMark)
;;;963                {
;;;964                    POWER_PROTOCOL_TxAddData(POWER_PROTOCOL_CMD_HEAD);
;;;965                    POWER_PROTOCOL_TxAddData(POWER_PROTOCOL_CMD_DEVICE_ADDR);
;;;966                    POWER_PROTOCOL_TxAddData(POWER_PROTOCOL_CMD_BLUETOOTH_CONNECT);
;;;967                    POWER_PROTOCOL_TxAddData(12);
;;;968                    POWER_PROTOCOL_TxAddData(HexToCharHigh(pCmdFrame->buff[UART_PROTOCOL_XM_CMD_DATA17_INDEX]));
;;;969                    POWER_PROTOCOL_TxAddData(HexToCharLow(pCmdFrame->buff[UART_PROTOCOL_XM_CMD_DATA17_INDEX]));
;;;970                    POWER_PROTOCOL_TxAddData(HexToCharHigh(pCmdFrame->buff[UART_PROTOCOL_XM_CMD_DATA18_INDEX]));
;;;971                    POWER_PROTOCOL_TxAddData(HexToCharLow(pCmdFrame->buff[UART_PROTOCOL_XM_CMD_DATA18_INDEX]));
;;;972                    POWER_PROTOCOL_TxAddData(HexToCharHigh(pCmdFrame->buff[UART_PROTOCOL_XM_CMD_DATA19_INDEX]));
;;;973                    POWER_PROTOCOL_TxAddData(HexToCharLow(pCmdFrame->buff[UART_PROTOCOL_XM_CMD_DATA19_INDEX]));
;;;974                    POWER_PROTOCOL_TxAddData(HexToCharHigh(pCmdFrame->buff[UART_PROTOCOL_XM_CMD_DATA20_INDEX]));
;;;975                    POWER_PROTOCOL_TxAddData(HexToCharLow(pCmdFrame->buff[UART_PROTOCOL_XM_CMD_DATA20_INDEX]));
;;;976                    POWER_PROTOCOL_TxAddData(HexToCharHigh(pCmdFrame->buff[UART_PROTOCOL_XM_CMD_DATA21_INDEX]));
;;;977                    POWER_PROTOCOL_TxAddData(HexToCharLow(pCmdFrame->buff[UART_PROTOCOL_XM_CMD_DATA21_INDEX]));
;;;978                    POWER_PROTOCOL_TxAddData(HexToCharHigh(pCmdFrame->buff[UART_PROTOCOL_XM_CMD_DATA22_INDEX]));
;;;979                    POWER_PROTOCOL_TxAddData(HexToCharLow(pCmdFrame->buff[UART_PROTOCOL_XM_CMD_DATA22_INDEX]));
;;;980                    POWER_PROTOCOL_TxAddFrame();
;;;981                }
;;;982    
;;;983                // 版本比对失败上报STS
;;;984                if (!checkMark)
;;;985                {
;;;986                    STS_PROTOCOL_TxAddData(STS_PROTOCOL_CMD_HEAD);
;;;987                    STS_PROTOCOL_TxAddData(STS_PROTOCOL_CMD_BLE_TEST);
;;;988                    STS_PROTOCOL_TxAddData(7 + verLenght);
;;;989                    STS_PROTOCOL_TxAddData(1);
;;;990                    STS_PROTOCOL_TxAddData(pCmdFrame->buff[UART_PROTOCOL_XM_CMD_DATA17_INDEX]);
;;;991                    STS_PROTOCOL_TxAddData(pCmdFrame->buff[UART_PROTOCOL_XM_CMD_DATA18_INDEX]);
;;;992                    STS_PROTOCOL_TxAddData(pCmdFrame->buff[UART_PROTOCOL_XM_CMD_DATA19_INDEX]);
;;;993                    STS_PROTOCOL_TxAddData(pCmdFrame->buff[UART_PROTOCOL_XM_CMD_DATA20_INDEX]);
;;;994                    STS_PROTOCOL_TxAddData(pCmdFrame->buff[UART_PROTOCOL_XM_CMD_DATA21_INDEX]);
;;;995                    STS_PROTOCOL_TxAddData(pCmdFrame->buff[UART_PROTOCOL_XM_CMD_DATA22_INDEX]);
;;;996                    
;;;997    //                // 上报正确版本
;;;998    //                for(i = 0 ; i < verLenght ; i++)
;;;999    //                {
;;;1000   //                    STS_PROTOCOL_TxAddData(conVer[i]);
;;;1001   //                }
;;;1002                   
;;;1003                   STS_PROTOCOL_TxAddFrame();
;;;1004               }
;;;1005               break;
;;;1006   
;;;1007           // 获取蓝牙固件版本
;;;1008           case UART_PROTOCOL_XM_CMD_TEST_BLE_VERSION:
;;;1009   
;;;1010               verLenght = pCmdFrame->buff[UART_PROTOCOL_XM_CMD_LENGTH_INDEX];
;;;1011               
;;;1012               // 存储转换后的MAC地址
;;;1013               for (i = 0; i < pCmdFrame->buff[UART_PROTOCOL_XM_CMD_LENGTH_INDEX]; i++)
;;;1014               {
;;;1015                   conVer[i * 2] = HexToCharHigh(pCmdFrame->buff[UART_PROTOCOL_XM_CMD_DATA1_INDEX + i]);
;;;1016                   conVer[i * 2 + 1] = HexToCharLow(pCmdFrame->buff[UART_PROTOCOL_XM_CMD_DATA1_INDEX + i]);
;;;1017               }
;;;1018               
;;;1019               // 版本一致就查询MAC地址
;;;1020               for (i = 0; i < pCmdFrame->buff[UART_PROTOCOL_XM_CMD_LENGTH_INDEX]; i++)
;;;1021               {
;;;1022                   if (verBle[i] != conVer[i])
;;;1023                   {
;;;1024                       checkMark = FALSE;  // 发现不匹配，设置标志为假
;;;1025                       break;              // 跳出循环
;;;1026                   }
;;;1027                   else
;;;1028                   {
;;;1029                       checkMark = TRUE;   // 所有元素都匹配，设置标志为真
;;;1030                   }                    
;;;1031               }
;;;1032                           
;;;1033               // 查询MAC地址
;;;1034               UART_PROTOCOL_XM_TxAddData(UART_PROTOCOL_XM_CMD_HEAD);
;;;1035               UART_PROTOCOL_XM_TxAddData(UART_PROTOCOL_XM_CMD_DEVICE);                
;;;1036               UART_PROTOCOL_XM_TxAddData(UART_PROTOCOL_XM_CMD_GET_OOB_PARAM);
;;;1037               UART_PROTOCOL_XM_TxAddData(0x00);         // 数据长度
;;;1038               UART_PROTOCOL_XM_TxAddFrame(); 
;;;1039               break;
;;;1040               
;;;1041           default:
;;;1042               break;
;;;1043       }
;;;1044   
;;;1045       // 删除命令帧
;;;1046       pCB->rx.head++;
;;;1047       pCB->rx.head %= UART_PROTOCOL_XM_RX_QUEUE_SIZE;
;;;1048   }
000050  b01b              ADD      sp,sp,#0x6c
000052  e8bd8ff0          POP      {r4-r11,pc}
                  |L2.86|
000056  7938              LDRB     r0,[r7,#4]            ;580
000058  4de4              LDR      r5,|L2.1004|
00005a  f8df8394          LDR      r8,|L2.1008|
00005e  f04f0900          MOV      r9,#0                 ;592
000062  7829              LDRB     r1,[r5,#0]            ;592
000064  1c49              ADDS     r1,r1,#1              ;592
000066  b2c9              UXTB     r1,r1                 ;592
000068  2886              CMP      r0,#0x86              ;583
00006a  d026              BEQ      |L2.186|
00006c  dc12              BGT      |L2.148|
00006e  2882              CMP      r0,#0x82              ;583
000070  d072              BEQ      |L2.344|
000072  dc06              BGT      |L2.130|
000074  2800              CMP      r0,#0                 ;583
                  |L2.118|
000076  d03a              BEQ      |L2.238|
000078  2820              CMP      r0,#0x20              ;583
00007a  d06e              BEQ      |L2.346|
00007c  2881              CMP      r0,#0x81              ;583
                  |L2.126|
00007e  d136              BNE      |L2.238|
000080  e0d7              B        |L2.562|
                  |L2.130|
000082  f8dfa370          LDR      r10,|L2.1012|
000086  2883              CMP      r0,#0x83              ;583
000088  d068              BEQ      |L2.348|
00008a  2884              CMP      r0,#0x84              ;583
00008c  d067              BEQ      |L2.350|
00008e  2885              CMP      r0,#0x85              ;583
000090  d1f5              BNE      |L2.126|
000092  e0aa              B        |L2.490|
                  |L2.148|
000094  2890              CMP      r0,#0x90              ;583
000096  d071              BEQ      |L2.380|
000098  dc0a              BGT      |L2.176|
00009a  f8df835c          LDR      r8,|L2.1016|
00009e  2887              CMP      r0,#0x87              ;583
0000a0  f8982017          LDRB     r2,[r8,#0x17]         ;623
0000a4  d024              BEQ      |L2.240|
0000a6  2888              CMP      r0,#0x88              ;583
0000a8  d06a              BEQ      |L2.384|
0000aa  2889              CMP      r0,#0x89              ;583
0000ac  d1e7              BNE      |L2.126|
0000ae  e0a1              B        |L2.500|
                  |L2.176|
0000b0  2895              CMP      r0,#0x95              ;583
0000b2  d07d              BEQ      |L2.432|
0000b4  289a              CMP      r0,#0x9a              ;583
0000b6  d1e2              BNE      |L2.126|
0000b8  e0a7              B        |L2.522|
                  |L2.186|
0000ba  797c              LDRB     r4,[r7,#5]            ;591
0000bc  7029              STRB     r1,[r5,#0]            ;592
0000be  b934              CBNZ     r4,|L2.206|
0000c0  2100              MOVS     r1,#0                 ;597
0000c2  200b              MOVS     r0,#0xb               ;597
0000c4  f7fffffe          BL       STS_PROTOCOL_SendCmdParamAck
0000c8  2008              MOVS     r0,#8                 ;598
0000ca  f7fffffe          BL       TIMER_KillTask
                  |L2.206|
0000ce  07e0              LSLS     r0,r4,#31             ;602
0000d0  d0d1              BEQ      |L2.118|
0000d2  7828              LDRB     r0,[r5,#0]            ;604  ; light_cnt
0000d4  2801              CMP      r0,#1                 ;604
0000d6  d102              BNE      |L2.222|
0000d8  2013              MOVS     r0,#0x13              ;606
0000da  f7fffffe          BL       STATE_SwitchStep
                  |L2.222|
0000de  7828              LDRB     r0,[r5,#0]            ;608  ; light_cnt
0000e0  2802              CMP      r0,#2                 ;608
0000e2  d1cc              BNE      |L2.126|
0000e4  2016              MOVS     r0,#0x16              ;610
0000e6  f7fffffe          BL       STATE_SwitchStep
0000ea  f8859000          STRB     r9,[r5,#0]            ;611
                  |L2.238|
0000ee  e266              B        |L2.1470|
                  |L2.240|
0000f0  79b8              LDRB     r0,[r7,#6]            ;619
0000f2  f8a80040          STRH     r0,[r8,#0x40]         ;619
0000f6  79f8              LDRB     r0,[r7,#7]            ;620
0000f8  f8a80042          STRH     r0,[r8,#0x42]         ;620
0000fc  2a13              CMP      r2,#0x13              ;623
0000fe  d119              BNE      |L2.308|
000100  4cbe              LDR      r4,|L2.1020|
000102  7820              LDRB     r0,[r4,#0]            ;626  ; cnt
000104  1c40              ADDS     r0,r0,#1              ;626
000106  b2c0              UXTB     r0,r0                 ;626
000108  7020              STRB     r0,[r4,#0]            ;626
00010a  b198              CBZ      r0,|L2.308|
00010c  2801              CMP      r0,#1                 ;628
00010e  d004              BEQ      |L2.282|
000110  2802              CMP      r0,#2                 ;628
000112  d006              BEQ      |L2.290|
000114  2803              CMP      r0,#3                 ;628
000116  d10d              BNE      |L2.308|
000118  e007              B        |L2.298|
                  |L2.282|
00011a  203f              MOVS     r0,#0x3f              ;634
00011c  f7fffffe          BL       STATE_SwitchStep
000120  e008              B        |L2.308|
                  |L2.290|
000122  2040              MOVS     r0,#0x40              ;638
000124  f7fffffe          BL       STATE_SwitchStep
000128  e004              B        |L2.308|
                  |L2.298|
00012a  2041              MOVS     r0,#0x41              ;642
00012c  f7fffffe          BL       STATE_SwitchStep
000130  f8849000          STRB     r9,[r4,#0]            ;643
                  |L2.308|
000134  f8980017          LDRB     r0,[r8,#0x17]         ;652  ; dut_info
000138  2814              CMP      r0,#0x14              ;652
00013a  d1d8              BNE      |L2.238|
00013c  4cb0              LDR      r4,|L2.1024|
00013e  7820              LDRB     r0,[r4,#0]            ;655  ; brake_cnt
000140  1c40              ADDS     r0,r0,#1              ;655
000142  b2c0              UXTB     r0,r0                 ;655
000144  7020              STRB     r0,[r4,#0]            ;655
000146  2800              CMP      r0,#0                 ;657
000148  d0d1              BEQ      |L2.238|
00014a  2801              CMP      r0,#1                 ;657
00014c  d008              BEQ      |L2.352|
00014e  2802              CMP      r0,#2                 ;657
000150  d00a              BEQ      |L2.360|
000152  2803              CMP      r0,#3                 ;657
000154  d1cb              BNE      |L2.238|
000156  e00b              B        |L2.368|
                  |L2.344|
000158  e080              B        |L2.604|
                  |L2.346|
00015a  e05b              B        |L2.532|
                  |L2.348|
00015c  e08c              B        |L2.632|
                  |L2.350|
00015e  e09e              B        |L2.670|
                  |L2.352|
000160  2048              MOVS     r0,#0x48              ;663
000162  f7fffffe          BL       STATE_SwitchStep
                  |L2.358|
000166  e22a              B        |L2.1470|
                  |L2.360|
000168  2049              MOVS     r0,#0x49              ;667
00016a  f7fffffe          BL       STATE_SwitchStep
00016e  e226              B        |L2.1470|
                  |L2.368|
000170  204a              MOVS     r0,#0x4a              ;671
000172  f7fffffe          BL       STATE_SwitchStep
000176  f8849000          STRB     r9,[r4,#0]            ;672
00017a  e220              B        |L2.1470|
                  |L2.380|
00017c  e1e8              B        |L2.1360|
00017e  e7ff              B        |L2.384|
                  |L2.384|
000180  79bc              LDRB     r4,[r7,#6]            ;684
000182  7029              STRB     r1,[r5,#0]            ;685
000184  2a11              CMP      r2,#0x11              ;688
000186  d106              BNE      |L2.406|
000188  2c01              CMP      r4,#1                 ;688
00018a  d104              BNE      |L2.406|
00018c  2901              CMP      r1,#1                 ;690
00018e  d102              BNE      |L2.406|
000190  202b              MOVS     r0,#0x2b              ;692
000192  f7fffffe          BL       STATE_SwitchStep
                  |L2.406|
000196  f8980017          LDRB     r0,[r8,#0x17]         ;697  ; dut_info
00019a  2812              CMP      r0,#0x12              ;697
00019c  d107              BNE      |L2.430|
00019e  2c02              CMP      r4,#2                 ;697
0001a0  d105              BNE      |L2.430|
0001a2  7828              LDRB     r0,[r5,#0]            ;699  ; light_cnt
0001a4  2801              CMP      r0,#1                 ;699
0001a6  d102              BNE      |L2.430|
0001a8  2034              MOVS     r0,#0x34              ;701
0001aa  f7fffffe          BL       STATE_SwitchStep
                  |L2.430|
0001ae  e000              B        |L2.434|
                  |L2.432|
0001b0  e158              B        |L2.1124|
                  |L2.434|
0001b2  f8980017          LDRB     r0,[r8,#0x17]         ;706  ; dut_info
0001b6  2811              CMP      r0,#0x11              ;706
0001b8  d108              BNE      |L2.460|
0001ba  b93c              CBNZ     r4,|L2.460|
0001bc  7828              LDRB     r0,[r5,#0]            ;708  ; light_cnt
0001be  2802              CMP      r0,#2                 ;708
0001c0  d104              BNE      |L2.460|
0001c2  202f              MOVS     r0,#0x2f              ;710
0001c4  f7fffffe          BL       STATE_SwitchStep
0001c8  f8859000          STRB     r9,[r5,#0]            ;711
                  |L2.460|
0001cc  f8980017          LDRB     r0,[r8,#0x17]         ;715  ; dut_info
0001d0  2812              CMP      r0,#0x12              ;715
0001d2  d18c              BNE      |L2.238|
0001d4  2c00              CMP      r4,#0                 ;715
0001d6  d18a              BNE      |L2.238|
0001d8  7828              LDRB     r0,[r5,#0]            ;717  ; light_cnt
0001da  2802              CMP      r0,#2                 ;717
0001dc  d187              BNE      |L2.238|
0001de  2039              MOVS     r0,#0x39              ;719
0001e0  f7fffffe          BL       STATE_SwitchStep
0001e4  f8859000          STRB     r9,[r5,#0]            ;720
0001e8  e1e9              B        |L2.1470|
                  |L2.490|
0001ea  2101              MOVS     r1,#1                 ;727
0001ec  2006              MOVS     r0,#6                 ;727
0001ee  f7fffffe          BL       STS_PROTOCOL_SendCmdParamAck
0001f2  e1e4              B        |L2.1470|
                  |L2.500|
0001f4  4883              LDR      r0,|L2.1028|
0001f6  79ba              LDRB     r2,[r7,#6]            ;732
0001f8  7800              LDRB     r0,[r0,#0]            ;732  ; keyValue
0001fa  4282              CMP      r2,r0                 ;732
0001fc  d100              BNE      |L2.512|
0001fe  2301              MOVS     r3,#1                 ;734
                  |L2.512|
000200  4619              MOV      r1,r3                 ;740
000202  201e              MOVS     r0,#0x1e              ;740
000204  f7fffffe          BL       STS_PROTOCOL_SendCmdParamTwoAck
000208  e1d9              B        |L2.1470|
                  |L2.522|
00020a  2101              MOVS     r1,#1                 ;745
00020c  2007              MOVS     r0,#7                 ;745
00020e  f7fffffe          BL       STS_PROTOCOL_SendCmdParamAck
000212  e1d4              B        |L2.1470|
                  |L2.532|
000214  4c7c              LDR      r4,|L2.1032|
000216  6820              LDR      r0,[r4,#0]            ;750  ; online_detection_cnt
000218  1c40              ADDS     r0,r0,#1              ;750
00021a  6020              STR      r0,[r4,#0]            ;750  ; online_detection_cnt
00021c  2011              MOVS     r0,#0x11              ;751
00021e  f7fffffe          BL       TIMER_ResetTimer
000222  6820              LDR      r0,[r4,#0]            ;753  ; online_detection_cnt
000224  2801              CMP      r0,#1                 ;753
000226  d19e              BNE      |L2.358|
000228  2101              MOVS     r1,#1                 ;756
00022a  2018              MOVS     r0,#0x18              ;756
00022c  f7fffffe          BL       STS_PROTOCOL_SendCmdParamAck
000230  e1c5              B        |L2.1470|
                  |L2.562|
000232  2012              MOVS     r0,#0x12              ;762
000234  f7fffffe          BL       TIMER_KillTask
000238  4874              LDR      r0,|L2.1036|
00023a  7800              LDRB     r0,[r0,#0]            ;765  ; stationNumber
00023c  4438              ADD      r0,r0,r7              ;765
00023e  79c0              LDRB     r0,[r0,#7]            ;765
000240  f88d0068          STRB     r0,[sp,#0x68]         ;765
000244  2802              CMP      r0,#2                 ;768
000246  d004              BEQ      |L2.594|
000248  2100              MOVS     r1,#0                 ;774
00024a  2001              MOVS     r0,#1                 ;774
00024c  f7fffffe          BL       STS_PROTOCOL_SendCmdParamAck
000250  e1b5              B        |L2.1470|
                  |L2.594|
000252  2101              MOVS     r1,#1                 ;770
000254  4608              MOV      r0,r1                 ;770
000256  f7fffffe          BL       STS_PROTOCOL_SendCmdParamAck
00025a  e1b0              B        |L2.1470|
                  |L2.604|
00025c  2012              MOVS     r0,#0x12              ;782
00025e  f7fffffe          BL       TIMER_ResetTimer
000262  7978              LDRB     r0,[r7,#5]            ;785
000264  b118              CBZ      r0,|L2.622|
000266  2081              MOVS     r0,#0x81              ;787
000268  f7fffffe          BL       UART_PROTOCOL_XM_SendCmdAck
00026c  e1a7              B        |L2.1470|
                  |L2.622|
00026e  2100              MOVS     r1,#0                 ;791
000270  2001              MOVS     r0,#1                 ;791
000272  f7fffffe          BL       STS_PROTOCOL_SendCmdParamAck
                  |L2.630|
000276  e1a2              B        |L2.1470|
                  |L2.632|
000278  2013              MOVS     r0,#0x13              ;799
00027a  f7fffffe          BL       TIMER_ResetTimer
00027e  79b8              LDRB     r0,[r7,#6]            ;802
000280  f89a1000          LDRB     r1,[r10,#0]           ;805  ; dutverType
000284  4281              CMP      r1,r0                 ;805
000286  d105              BNE      |L2.660|
000288  79f8              LDRB     r0,[r7,#7]            ;805
00028a  b118              CBZ      r0,|L2.660|
00028c  2084              MOVS     r0,#0x84              ;808
00028e  f7fffffe          BL       UART_PROTOCOL_XM_SendCmdParamAck
000292  e194              B        |L2.1470|
                  |L2.660|
000294  2100              MOVS     r1,#0                 ;812
000296  2002              MOVS     r0,#2                 ;812
000298  f7fffffe          BL       STS_PROTOCOL_SendCmdParamAck
00029c  e18f              B        |L2.1470|
                  |L2.670|
00029e  2013              MOVS     r0,#0x13              ;818
0002a0  f7fffffe          BL       TIMER_KillTask
0002a4  79bd              LDRB     r5,[r7,#6]            ;821
0002a6  79f8              LDRB     r0,[r7,#7]            ;824
0002a8  f8880001          STRB     r0,[r8,#1]            ;824
0002ac  f1070108          ADD      r1,r7,#8              ;827
0002b0  a801              ADD      r0,sp,#4              ;827
0002b2  f7fffffe          BL       strcpy
0002b6  f8980001          LDRB     r0,[r8,#1]            ;829  ; infoLen
0002ba  af01              ADD      r7,sp,#4              ;829
0002bc  f8079000          STRB     r9,[r7,r0]            ;829
0002c0  2d03              CMP      r5,#3                 ;830
0002c2  d102              BNE      |L2.714|
0002c4  4438              ADD      r0,r0,r7              ;832
0002c6  f8009c01          STRB     r9,[r0,#-1]           ;832
                  |L2.714|
0002ca  f8dfb144          LDR      r11,|L2.1040|
0002ce  f89b0000          LDRB     r0,[r11,#0]           ;836  ; verreadFlag
0002d2  b398              CBZ      r0,|L2.828|
0002d4  2d01              CMP      r5,#1                 ;838
0002d6  d004              BEQ      |L2.738|
0002d8  2d02              CMP      r5,#2                 ;842
0002da  d004              BEQ      |L2.742|
0002dc  2d03              CMP      r5,#3                 ;846
0002de  d004              BEQ      |L2.746|
0002e0  e004              B        |L2.748|
                  |L2.738|
0002e2  2500              MOVS     r5,#0                 ;840
0002e4  e002              B        |L2.748|
                  |L2.742|
0002e6  2501              MOVS     r5,#1                 ;844
0002e8  e000              B        |L2.748|
                  |L2.746|
0002ea  2502              MOVS     r5,#2                 ;848
                  |L2.748|
0002ec  2055              MOVS     r0,#0x55              ;854
0002ee  f7fffffe          BL       STS_PROTOCOL_TxAddData
0002f2  2002              MOVS     r0,#2                 ;855
0002f4  f7fffffe          BL       STS_PROTOCOL_TxAddData
0002f8  2000              MOVS     r0,#0                 ;856
0002fa  f7fffffe          BL       STS_PROTOCOL_TxAddData
0002fe  2001              MOVS     r0,#1                 ;857
000300  f7fffffe          BL       STS_PROTOCOL_TxAddData
000304  4628              MOV      r0,r5                 ;858
000306  f7fffffe          BL       STS_PROTOCOL_TxAddData
00030a  2d02              CMP      r5,#2                 ;860
00030c  d004              BEQ      |L2.792|
00030e  f8980001          LDRB     r0,[r8,#1]            ;872  ; infoLen
000312  f7fffffe          BL       STS_PROTOCOL_TxAddData
000316  e017              B        |L2.840|
                  |L2.792|
000318  f8980001          LDRB     r0,[r8,#1]            ;862  ; infoLen
00031c  1e40              SUBS     r0,r0,#1              ;862
00031e  b2c0              UXTB     r0,r0                 ;862
000320  f7fffffe          BL       STS_PROTOCOL_TxAddData
000324  e004              B        |L2.816|
                  |L2.806|
000326  5d38              LDRB     r0,[r7,r4]            ;867
000328  f7fffffe          BL       STS_PROTOCOL_TxAddData
00032c  1c64              ADDS     r4,r4,#1              ;865
00032e  b2e4              UXTB     r4,r4                 ;865
                  |L2.816|
000330  f8980001          LDRB     r0,[r8,#1]            ;865  ; infoLen
000334  1e40              SUBS     r0,r0,#1              ;865
000336  4284              CMP      r4,r0                 ;865
000338  dbf5              BLT      |L2.806|
00033a  e009              B        |L2.848|
                  |L2.828|
00033c  e00c              B        |L2.856|
                  |L2.830|
00033e  5d38              LDRB     r0,[r7,r4]            ;877
000340  f7fffffe          BL       STS_PROTOCOL_TxAddData
000344  1c64              ADDS     r4,r4,#1              ;875
000346  b2e4              UXTB     r4,r4                 ;875
                  |L2.840|
000348  f8980001          LDRB     r0,[r8,#1]            ;875  ; infoLen
00034c  4284              CMP      r4,r0                 ;875
00034e  d3f6              BCC      |L2.830|
                  |L2.848|
000350  f7fffffe          BL       STS_PROTOCOL_TxAddFrame
000354  f88b9000          STRB     r9,[r11,#0]           ;882
                  |L2.856|
000358  f8dfb0b8          LDR      r11,|L2.1044|
00035c  f89b0000          LDRB     r0,[r11,#0]           ;886  ; verwriteFlag
000360  2800              CMP      r0,#0                 ;886
000362  d088              BEQ      |L2.630|
000364  f89a0000          LDRB     r0,[r10,#0]           ;889  ; dutverType
000368  42a8              CMP      r0,r5                 ;889
00036a  d131              BNE      |L2.976|
00036c  a901              ADD      r1,sp,#4              ;889
00036e  482a              LDR      r0,|L2.1048|
000370  f7fffffe          BL       strstr
000374  b360              CBZ      r0,|L2.976|
000376  2d01              CMP      r5,#1                 ;891
000378  d004              BEQ      |L2.900|
00037a  2d02              CMP      r5,#2                 ;895
00037c  d004              BEQ      |L2.904|
00037e  2d03              CMP      r5,#3                 ;899
000380  d004              BEQ      |L2.908|
000382  e004              B        |L2.910|
                  |L2.900|
000384  2500              MOVS     r5,#0                 ;893
000386  e002              B        |L2.910|
                  |L2.904|
000388  2501              MOVS     r5,#1                 ;897
00038a  e000              B        |L2.910|
                  |L2.908|
00038c  2502              MOVS     r5,#2                 ;901
                  |L2.910|
00038e  2055              MOVS     r0,#0x55              ;907
000390  f7fffffe          BL       STS_PROTOCOL_TxAddData
000394  2002              MOVS     r0,#2                 ;908
000396  f7fffffe          BL       STS_PROTOCOL_TxAddData
00039a  2000              MOVS     r0,#0                 ;909
00039c  f7fffffe          BL       STS_PROTOCOL_TxAddData
0003a0  2001              MOVS     r0,#1                 ;910
0003a2  f7fffffe          BL       STS_PROTOCOL_TxAddData
0003a6  4628              MOV      r0,r5                 ;911
0003a8  f7fffffe          BL       STS_PROTOCOL_TxAddData
0003ac  f8980001          LDRB     r0,[r8,#1]            ;912  ; infoLen
0003b0  f7fffffe          BL       STS_PROTOCOL_TxAddData
0003b4  2400              MOVS     r4,#0                 ;915
0003b6  e004              B        |L2.962|
                  |L2.952|
0003b8  5d38              LDRB     r0,[r7,r4]            ;917
0003ba  f7fffffe          BL       STS_PROTOCOL_TxAddData
0003be  1c64              ADDS     r4,r4,#1              ;915
0003c0  b2e4              UXTB     r4,r4                 ;915
                  |L2.962|
0003c2  f8980001          LDRB     r0,[r8,#1]            ;915  ; infoLen
0003c6  4284              CMP      r4,r0                 ;915
0003c8  d3f6              BCC      |L2.952|
0003ca  f7fffffe          BL       STS_PROTOCOL_TxAddFrame
0003ce  e046              B        |L2.1118|
                  |L2.976|
0003d0  2d01              CMP      r5,#1                 ;923
0003d2  d004              BEQ      |L2.990|
0003d4  2d02              CMP      r5,#2                 ;927
0003d6  d004              BEQ      |L2.994|
0003d8  2d03              CMP      r5,#3                 ;931
0003da  d01f              BEQ      |L2.1052|
0003dc  e01f              B        |L2.1054|
                  |L2.990|
0003de  2500              MOVS     r5,#0                 ;925
0003e0  e01d              B        |L2.1054|
                  |L2.994|
0003e2  2501              MOVS     r5,#1                 ;929
0003e4  e01b              B        |L2.1054|
0003e6  0000              DCW      0x0000
                  |L2.1000|
                          DCD      ||.constdata||
                  |L2.1004|
                          DCD      light_cnt
                  |L2.1008|
                          DCD      ||.data||
                  |L2.1012|
                          DCD      dutverType
                  |L2.1016|
                          DCD      dut_info
                  |L2.1020|
                          DCD      ||cnt||
                  |L2.1024|
                          DCD      brake_cnt
                  |L2.1028|
                          DCD      keyValue
                  |L2.1032|
                          DCD      online_detection_cnt
                  |L2.1036|
                          DCD      stationNumber
                  |L2.1040|
                          DCD      verreadFlag
                  |L2.1044|
                          DCD      verwriteFlag
                  |L2.1048|
                          DCD      dutverBuff
                  |L2.1052|
00041c  2502              MOVS     r5,#2                 ;933
                  |L2.1054|
00041e  2055              MOVS     r0,#0x55              ;939
000420  f7fffffe          BL       STS_PROTOCOL_TxAddData
000424  2002              MOVS     r0,#2                 ;940
000426  f7fffffe          BL       STS_PROTOCOL_TxAddData
00042a  2000              MOVS     r0,#0                 ;941
00042c  f7fffffe          BL       STS_PROTOCOL_TxAddData
000430  2000              MOVS     r0,#0                 ;942
000432  f7fffffe          BL       STS_PROTOCOL_TxAddData
000436  4628              MOV      r0,r5                 ;943
000438  f7fffffe          BL       STS_PROTOCOL_TxAddData
00043c  f8980001          LDRB     r0,[r8,#1]            ;944  ; infoLen
000440  f7fffffe          BL       STS_PROTOCOL_TxAddData
000444  2400              MOVS     r4,#0                 ;947
000446  e004              B        |L2.1106|
                  |L2.1096|
000448  5d38              LDRB     r0,[r7,r4]            ;949
00044a  f7fffffe          BL       STS_PROTOCOL_TxAddData
00044e  1c64              ADDS     r4,r4,#1              ;947
000450  b2e4              UXTB     r4,r4                 ;947
                  |L2.1106|
000452  f8980001          LDRB     r0,[r8,#1]            ;947  ; infoLen
000456  4284              CMP      r4,r0                 ;947
000458  d3f6              BCC      |L2.1096|
00045a  f7fffffe          BL       STS_PROTOCOL_TxAddFrame
                  |L2.1118|
00045e  f88b9000          STRB     r9,[r11,#0]           ;953
000462  e0ac              B        |L2.1470|
                  |L2.1124|
000464  f8980002          LDRB     r0,[r8,#2]            ;962  ; checkMark
000468  b3f0              CBZ      r0,|L2.1256|
00046a  203a              MOVS     r0,#0x3a              ;964
00046c  f7fffffe          BL       POWER_PROTOCOL_TxAddData
000470  201a              MOVS     r0,#0x1a              ;965
000472  f7fffffe          BL       POWER_PROTOCOL_TxAddData
000476  2006              MOVS     r0,#6                 ;966
000478  f7fffffe          BL       POWER_PROTOCOL_TxAddData
00047c  200c              MOVS     r0,#0xc               ;967
00047e  f7fffffe          BL       POWER_PROTOCOL_TxAddData
000482  7db8              LDRB     r0,[r7,#0x16]         ;968
000484  f7fffffe          BL       HexToCharHigh
000488  f7fffffe          BL       POWER_PROTOCOL_TxAddData
00048c  7db8              LDRB     r0,[r7,#0x16]         ;969
00048e  f7fffffe          BL       HexToCharLow
000492  f7fffffe          BL       POWER_PROTOCOL_TxAddData
000496  7df8              LDRB     r0,[r7,#0x17]         ;970
000498  f7fffffe          BL       HexToCharHigh
00049c  f7fffffe          BL       POWER_PROTOCOL_TxAddData
0004a0  7df8              LDRB     r0,[r7,#0x17]         ;971
0004a2  f7fffffe          BL       HexToCharLow
0004a6  f7fffffe          BL       POWER_PROTOCOL_TxAddData
0004aa  7e38              LDRB     r0,[r7,#0x18]         ;972
0004ac  f7fffffe          BL       HexToCharHigh
0004b0  f7fffffe          BL       POWER_PROTOCOL_TxAddData
0004b4  7e38              LDRB     r0,[r7,#0x18]         ;973
0004b6  f7fffffe          BL       HexToCharLow
0004ba  f7fffffe          BL       POWER_PROTOCOL_TxAddData
0004be  7e78              LDRB     r0,[r7,#0x19]         ;974
0004c0  f7fffffe          BL       HexToCharHigh
0004c4  f7fffffe          BL       POWER_PROTOCOL_TxAddData
0004c8  7e78              LDRB     r0,[r7,#0x19]         ;975
0004ca  f7fffffe          BL       HexToCharLow
0004ce  f7fffffe          BL       POWER_PROTOCOL_TxAddData
0004d2  7eb8              LDRB     r0,[r7,#0x1a]         ;976
0004d4  f7fffffe          BL       HexToCharHigh
0004d8  f7fffffe          BL       POWER_PROTOCOL_TxAddData
0004dc  7eb8              LDRB     r0,[r7,#0x1a]         ;977
0004de  f7fffffe          BL       HexToCharLow
0004e2  f7fffffe          BL       POWER_PROTOCOL_TxAddData
0004e6  e000              B        |L2.1258|
                  |L2.1256|
0004e8  e00b              B        |L2.1282|
                  |L2.1258|
0004ea  7ef8              LDRB     r0,[r7,#0x1b]         ;978
0004ec  f7fffffe          BL       HexToCharHigh
0004f0  f7fffffe          BL       POWER_PROTOCOL_TxAddData
0004f4  7ef8              LDRB     r0,[r7,#0x1b]         ;979
0004f6  f7fffffe          BL       HexToCharLow
0004fa  f7fffffe          BL       POWER_PROTOCOL_TxAddData
0004fe  f7fffffe          BL       POWER_PROTOCOL_TxAddFrame
                  |L2.1282|
000502  f8980002          LDRB     r0,[r8,#2]            ;984  ; checkMark
000506  bb10              CBNZ     r0,|L2.1358|
000508  2055              MOVS     r0,#0x55              ;986
00050a  f7fffffe          BL       STS_PROTOCOL_TxAddData
00050e  200c              MOVS     r0,#0xc               ;987
000510  f7fffffe          BL       STS_PROTOCOL_TxAddData
000514  f8980000          LDRB     r0,[r8,#0]            ;988  ; verLenght
000518  1dc0              ADDS     r0,r0,#7              ;988
00051a  b2c0              UXTB     r0,r0                 ;988
00051c  f7fffffe          BL       STS_PROTOCOL_TxAddData
000520  2001              MOVS     r0,#1                 ;989
000522  f7fffffe          BL       STS_PROTOCOL_TxAddData
000526  7db8              LDRB     r0,[r7,#0x16]         ;990
000528  f7fffffe          BL       STS_PROTOCOL_TxAddData
00052c  7df8              LDRB     r0,[r7,#0x17]         ;991
00052e  f7fffffe          BL       STS_PROTOCOL_TxAddData
000532  7e38              LDRB     r0,[r7,#0x18]         ;992
000534  f7fffffe          BL       STS_PROTOCOL_TxAddData
000538  7e78              LDRB     r0,[r7,#0x19]         ;993
00053a  f7fffffe          BL       STS_PROTOCOL_TxAddData
00053e  7eb8              LDRB     r0,[r7,#0x1a]         ;994
000540  f7fffffe          BL       STS_PROTOCOL_TxAddData
000544  7ef8              LDRB     r0,[r7,#0x1b]         ;995
000546  f7fffffe          BL       STS_PROTOCOL_TxAddData
00054a  f7fffffe          BL       STS_PROTOCOL_TxAddFrame
                  |L2.1358|
00054e  e036              B        |L2.1470|
                  |L2.1360|
000550  7978              LDRB     r0,[r7,#5]            ;1010
000552  f8880000          STRB     r0,[r8,#0]            ;1010
000556  f8dfa080          LDR      r10,|L2.1496|
00055a  e00d              B        |L2.1400|
                  |L2.1372|
00055c  193d              ADDS     r5,r7,r4              ;1015
00055e  79a8              LDRB     r0,[r5,#6]            ;1015
000560  f7fffffe          BL       HexToCharHigh
000564  f80a0014          STRB     r0,[r10,r4,LSL #1]    ;1015
000568  79a8              LDRB     r0,[r5,#6]            ;1016
00056a  f7fffffe          BL       HexToCharLow
00056e  eb0a0144          ADD      r1,r10,r4,LSL #1      ;1016
000572  7048              STRB     r0,[r1,#1]            ;1016
000574  1c64              ADDS     r4,r4,#1              ;1013
000576  b2e4              UXTB     r4,r4                 ;1013
                  |L2.1400|
000578  7979              LDRB     r1,[r7,#5]            ;1013
00057a  42a1              CMP      r1,r4                 ;1013
00057c  d8ee              BHI      |L2.1372|
00057e  2000              MOVS     r0,#0                 ;1020
000580  4b16              LDR      r3,|L2.1500|
000582  2201              MOVS     r2,#1                 ;592
000584  e00b              B        |L2.1438|
                  |L2.1414|
000586  5c1c              LDRB     r4,[r3,r0]            ;1022
000588  f81a5000          LDRB     r5,[r10,r0]           ;1022
00058c  42ac              CMP      r4,r5                 ;1022
00058e  d002              BEQ      |L2.1430|
000590  f8889002          STRB     r9,[r8,#2]            ;1024
000594  e005              B        |L2.1442|
                  |L2.1430|
000596  f8882002          STRB     r2,[r8,#2]            ;1029
00059a  1c40              ADDS     r0,r0,#1              ;1020
00059c  b2c0              UXTB     r0,r0                 ;1020
                  |L2.1438|
00059e  4281              CMP      r1,r0                 ;1020
0005a0  d8f1              BHI      |L2.1414|
                  |L2.1442|
0005a2  205a              MOVS     r0,#0x5a              ;1034
0005a4  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
0005a8  2012              MOVS     r0,#0x12              ;1035
0005aa  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
0005ae  2095              MOVS     r0,#0x95              ;1036
0005b0  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
0005b4  2000              MOVS     r0,#0                 ;1037
0005b6  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
0005ba  f7fffffe          BL       UART_PROTOCOL_XM_TxAddFrame
                  |L2.1470|
0005be  f8b60274          LDRH     r0,[r6,#0x274]        ;1046
0005c2  1c40              ADDS     r0,r0,#1              ;1046
0005c4  b280              UXTH     r0,r0                 ;1046
0005c6  2105              MOVS     r1,#5                 ;1047
0005c8  fbb0f2f1          UDIV     r2,r0,r1              ;1047
0005cc  fb010012          MLS      r0,r1,r2,r0           ;1047
0005d0  f8a60274          STRH     r0,[r6,#0x274]        ;1047
0005d4  e53c              B        |L2.80|
;;;1049   
                          ENDP

0005d6  0000              DCW      0x0000
                  |L2.1496|
                          DCD      ||.bss||+0x594
                  |L2.1500|
                          DCD      verBle

                          AREA ||i.UART_PROTOCOL_XM_ConfirmTempCmdFrameBuff||, CODE, READONLY, ALIGN=1

                  UART_PROTOCOL_XM_ConfirmTempCmdFrameBuff PROC
;;;282    // 将临时缓冲区添加到命令帧缓冲区中，其本质操作是承认临时缓冲区数据有效
;;;283    BOOL UART_PROTOCOL_XM_ConfirmTempCmdFrameBuff(UART_PROTOCOL_XM_CB *pCB)
000000  2800              CMP      r0,#0
;;;284    {
000002  d01e              BEQ      |L3.66|
;;;285        UART_PROTOCOL_XM_RX_CMD_FRAME *pCmdFrame = NULL;
;;;286    
;;;287        // 参数合法性检验
;;;288        if (NULL == pCB)
;;;289        {
;;;290            return FALSE;
;;;291        }
;;;292    
;;;293        // 临时缓冲区为空，不予添加
;;;294        pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.end];
000004  f8b01276          LDRH     r1,[r0,#0x276]
000008  ebc102c1          RSB      r2,r1,r1,LSL #3
00000c  eb020242          ADD      r2,r2,r2,LSL #1
000010  eb000282          ADD      r2,r0,r2,LSL #2
;;;295        if (0 == pCmdFrame->length)
000014  f8b22122          LDRH     r2,[r2,#0x122]
000018  b1aa              CBZ      r2,|L3.70|
;;;296        {
;;;297            return FALSE;
;;;298        }
;;;299    
;;;300        // 添加
;;;301        pCB->rx.end++;
00001a  1c49              ADDS     r1,r1,#1
00001c  b289              UXTH     r1,r1
;;;302        pCB->rx.end %= UART_PROTOCOL_XM_RX_QUEUE_SIZE;
00001e  2205              MOVS     r2,#5
000020  fbb1f3f2          UDIV     r3,r1,r2
000024  fb021113          MLS      r1,r2,r3,r1
000028  f8a01276          STRH     r1,[r0,#0x276]
;;;303        pCB->rx.cmdQueue[pCB->rx.end].length = 0; // 该行的作用是将新的添加位置有效数据个数清零，以便将这个位置当做临时帧缓冲区
00002c  ebc101c1          RSB      r1,r1,r1,LSL #3
000030  eb010141          ADD      r1,r1,r1,LSL #1
000034  eb000081          ADD      r0,r0,r1,LSL #2
000038  2200              MOVS     r2,#0
00003a  f8a02122          STRH     r2,[r0,#0x122]
;;;304    
;;;305        return TRUE;
00003e  2001              MOVS     r0,#1
;;;306    }
000040  4770              BX       lr
                  |L3.66|
000042  2000              MOVS     r0,#0                 ;290
000044  4770              BX       lr
                  |L3.70|
000046  2000              MOVS     r0,#0                 ;297
000048  4770              BX       lr
;;;307    
                          ENDP


                          AREA ||i.UART_PROTOCOL_XM_DataStructInit||, CODE, READONLY, ALIGN=1

                  UART_PROTOCOL_XM_DataStructInit PROC
;;;214    // 数据结构初始化
;;;215    void UART_PROTOCOL_XM_DataStructInit(UART_PROTOCOL_XM_CB *pCB)
000000  2800              CMP      r0,#0
;;;216    {
000002  d029              BEQ      |L4.88|
;;;217        uint16 i;
;;;218    
;;;219        // 参数合法性检验
;;;220        if (NULL == pCB)
;;;221        {
;;;222            return;
;;;223        }
;;;224    
;;;225        pCB->tx.txBusy = FALSE;
000004  2300              MOVS     r3,#0
000006  f8803580          STRB     r3,[r0,#0x580]
;;;226        pCB->tx.index = 0;
00000a  f8a0357e          STRH     r3,[r0,#0x57e]
;;;227        pCB->tx.head = 0;
00000e  f8a0357a          STRH     r3,[r0,#0x57a]
;;;228        pCB->tx.end = 0;
000012  f8a0357c          STRH     r3,[r0,#0x57c]
;;;229        for (i = 0; i < UART_PROTOCOL_XM_TX_QUEUE_SIZE; i++)
000016  2100              MOVS     r1,#0
                  |L4.24|
;;;230        {
;;;231            pCB->tx.cmdQueue[i].length = 0;
000018  224d              MOVS     r2,#0x4d
00001a  434a              MULS     r2,r1,r2
00001c  eb000242          ADD      r2,r0,r2,LSL #1
000020  f8a23310          STRH     r3,[r2,#0x310]
000024  1c49              ADDS     r1,r1,#1              ;229
000026  b289              UXTH     r1,r1                 ;229
000028  2905              CMP      r1,#5                 ;229
00002a  d3f5              BCC      |L4.24|
;;;232        }
;;;233    
;;;234        pCB->rxFIFO.head = 0;
00002c  f8203fc8          STRH     r3,[r0,#0xc8]!
;;;235        pCB->rxFIFO.end = 0;
000030  8043              STRH     r3,[r0,#2]
;;;236        pCB->rxFIFO.currentProcessIndex = 0;
000032  8083              STRH     r3,[r0,#4]
;;;237    
;;;238        pCB->rx.head = 0;
000034  f8a031ac          STRH     r3,[r0,#0x1ac]
;;;239        pCB->rx.end = 0;
000038  f8a031ae          STRH     r3,[r0,#0x1ae]
00003c  38c8              SUBS     r0,r0,#0xc8
;;;240        for (i = 0; i < UART_PROTOCOL_XM_RX_QUEUE_SIZE; i++)
00003e  2100              MOVS     r1,#0
                  |L4.64|
;;;241        {
;;;242            pCB->rx.cmdQueue[i].length = 0;
000040  ebc102c1          RSB      r2,r1,r1,LSL #3
000044  eb020242          ADD      r2,r2,r2,LSL #1
000048  eb000282          ADD      r2,r0,r2,LSL #2
00004c  f8a23122          STRH     r3,[r2,#0x122]
000050  1c49              ADDS     r1,r1,#1              ;240
000052  b289              UXTH     r1,r1                 ;240
000054  2905              CMP      r1,#5                 ;240
000056  d3f3              BCC      |L4.64|
                  |L4.88|
;;;243        }
;;;244    }
000058  4770              BX       lr
;;;245    
                          ENDP


                          AREA ||i.UART_PROTOCOL_XM_Init||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL_XM_Init PROC
;;;117    // 协议初始化
;;;118    void UART_PROTOCOL_XM_Init(void)
000000  b510              PUSH     {r4,lr}
;;;119    {
;;;120        // 协议层数据结构初始化
;;;121        UART_PROTOCOL_XM_DataStructInit(&uartProtocolCB5);
000002  4805              LDR      r0,|L5.24|
000004  f7fffffe          BL       UART_PROTOCOL_XM_DataStructInit
;;;122    
;;;123        // 向驱动层注册数据接收接口
;;;124        UART_DRIVE_RegisterDataSendService(UART_PROTOCOL_XM_MacProcess);
000008  4804              LDR      r0,|L5.28|
00000a  f7fffffe          BL       UART_DRIVE_RegisterDataSendService
;;;125    
;;;126        // 向驱动层注册数据发送接口
;;;127        UART_PROTOCOL_XM_RegisterDataSendService(UART_DRIVE_AddTxArray);
00000e  e8bd4010          POP      {r4,lr}
000012  4803              LDR      r0,|L5.32|
000014  f7ffbffe          B.W      UART_PROTOCOL_XM_RegisterDataSendService
;;;128    }
;;;129    
                          ENDP

                  |L5.24|
                          DCD      ||.bss||
                  |L5.28|
                          DCD      UART_PROTOCOL_XM_MacProcess
                  |L5.32|
                          DCD      UART_DRIVE_AddTxArray

                          AREA ||i.UART_PROTOCOL_XM_MacProcess||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL_XM_MacProcess PROC
;;;246    // UART报文接收处理函数(注意根据具体模块修改)
;;;247    void UART_PROTOCOL_XM_MacProcess(uint16 standarID, uint8 *pData, uint16 length)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;248    {
000004  4681              MOV      r9,r0
000006  4688              MOV      r8,r1
000008  4692              MOV      r10,r2
;;;249        uint16 end = uartProtocolCB5.rxFIFO.end;
00000a  4c13              LDR      r4,|L6.88|
00000c  f8b450ca          LDRH     r5,[r4,#0xca]  ; uartProtocolCB5
;;;250        uint16 head = uartProtocolCB5.rxFIFO.head;
000010  f8b460c8          LDRH     r6,[r4,#0xc8]  ; uartProtocolCB5
;;;251        uint8 rxdata = 0x00;
;;;252    
;;;253        // 接收数据
;;;254        rxdata = *pData;
000014  f8987000          LDRB     r7,[r8,#0]
;;;255    
;;;256        // 借用KM5S协议解析
;;;257       UART_PROTOCOL_MacProcess(standarID, pData, length);
000018  4652              MOV      r2,r10
00001a  4641              MOV      r1,r8
00001c  4648              MOV      r0,r9
00001e  f7fffffe          BL       UART_PROTOCOL_MacProcess
;;;258       DUT_PROTOCOL_MacProcess(standarID, pData, length);
000022  4652              MOV      r2,r10
000024  4641              MOV      r1,r8
000026  4648              MOV      r0,r9
000028  f7fffffe          BL       DUT_PROTOCOL_MacProcess
;;;259    //   UART_PROTOCOL4_MacProcess(standarID, pData, length);
;;;260    
;;;261        // 一级缓冲区已满，不予接收
;;;262        if ((end + 1) % UART_PROTOCOL_XM_RX_FIFO_SIZE == head)
00002c  1c6b              ADDS     r3,r5,#1
00002e  20c8              MOVS     r0,#0xc8
000030  fbb3f1f0          UDIV     r1,r3,r0
000034  fb003111          MLS      r1,r0,r1,r3
000038  42b1              CMP      r1,r6
00003a  d00a              BEQ      |L6.82|
;;;263        {
;;;264            return;
;;;265        }
;;;266        // 一级缓冲区未满，接收
;;;267        else
;;;268        {
;;;269            // 将接收到的数据放到临时缓冲区中
;;;270            uartProtocolCB5.rxFIFO.buff[end] = rxdata;
00003c  5567              STRB     r7,[r4,r5]
;;;271            uartProtocolCB5.rxFIFO.end++;
00003e  f8341fca          LDRH     r1,[r4,#0xca]!  ; uartProtocolCB5
000042  1c49              ADDS     r1,r1,#1
000044  8021              STRH     r1,[r4,#0]
;;;272            uartProtocolCB5.rxFIFO.end %= UART_PROTOCOL_XM_RX_FIFO_SIZE;
000046  8821              LDRH     r1,[r4,#0]  ; uartProtocolCB5
000048  fbb1f2f0          UDIV     r2,r1,r0
00004c  fb001012          MLS      r0,r0,r2,r1
000050  8020              STRH     r0,[r4,#0]
                  |L6.82|
;;;273        }
;;;274    }
000052  e8bd87f0          POP      {r4-r10,pc}
;;;275    
                          ENDP

000056  0000              DCW      0x0000
                  |L6.88|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOL_XM_Process||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL_XM_Process PROC
;;;130    // UART协议层过程处理
;;;131    void UART_PROTOCOL_XM_Process(void)
000000  b510              PUSH     {r4,lr}
;;;132    {
;;;133        // UART接收FIFO缓冲区处理
;;;134        UART_PROTOCOL_XM_RxFIFOProcess(&uartProtocolCB5);
000002  4805              LDR      r0,|L7.24|
000004  f7fffffe          BL       UART_PROTOCOL_XM_RxFIFOProcess
;;;135    
;;;136        // UART接收命令缓冲区处理
;;;137        UART_PROTOCOL_XM_CmdFrameProcess(&uartProtocolCB5);
000008  4803              LDR      r0,|L7.24|
00000a  f7fffffe          BL       UART_PROTOCOL_XM_CmdFrameProcess
;;;138    
;;;139        // UART协议层发送处理过程
;;;140        UART_PROTOCOL_XM_TxStateProcess();
00000e  e8bd4010          POP      {r4,lr}
000012  f7ffbffe          B.W      UART_PROTOCOL_XM_TxStateProcess
;;;141    }
;;;142    
                          ENDP

000016  0000              DCW      0x0000
                  |L7.24|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOL_XM_RegisterDataSendService||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL_XM_RegisterDataSendService PROC
;;;276    // UART协议层向驱动层注册数据发送接口
;;;277    void UART_PROTOCOL_XM_RegisterDataSendService(BOOL (*service)(uint16 id, uint8 *pData, uint16 length))
000000  4901              LDR      r1,|L8.8|
;;;278    {
;;;279        uartProtocolCB5.sendDataThrowService = service;
000002  f8c10584          STR      r0,[r1,#0x584]  ; uartProtocolCB5
;;;280    }
000006  4770              BX       lr
;;;281    
                          ENDP

                  |L8.8|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOL_XM_RxFIFOProcess||, CODE, READONLY, ALIGN=1

                  UART_PROTOCOL_XM_RxFIFOProcess PROC
;;;341    // 一级接收缓冲区处理，从一级接收缓冲区中取出一个字节添加到命令帧缓冲区中
;;;342    void UART_PROTOCOL_XM_RxFIFOProcess(UART_PROTOCOL_XM_CB *pCB)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;343    {
000004  4604              MOV      r4,r0
;;;344        uint16 end = pCB->rxFIFO.end;
000006  f8b410ca          LDRH     r1,[r4,#0xca]
;;;345        uint16 head = pCB->rxFIFO.head;
00000a  f8b400c8          LDRH     r0,[r4,#0xc8]
;;;346        UART_PROTOCOL_XM_RX_CMD_FRAME *pCmdFrame = NULL;
;;;347        uint16 length = 0;
;;;348        uint8 currentData = 0;
;;;349    
;;;350        // 参数合法性检验
;;;351        if (NULL == pCB)
00000e  2c00              CMP      r4,#0
000010  d023              BEQ      |L9.90|
;;;352        {
;;;353            return;
;;;354        }
;;;355    
;;;356        // 一级缓冲区为空，退出
;;;357        if (head == end)
000012  4288              CMP      r0,r1
000014  d021              BEQ      |L9.90|
;;;358        {
;;;359            return;
;;;360        }
;;;361    
;;;362        // 获取临时缓冲区指针
;;;363        pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.end];
000016  f8b42276          LDRH     r2,[r4,#0x276]
00001a  ebc200c2          RSB      r0,r2,r2,LSL #3
00001e  eb000040          ADD      r0,r0,r0,LSL #1
000022  eb040580          ADD      r5,r4,r0,LSL #2
000026  35d0              ADDS     r5,r5,#0xd0
;;;364    
;;;365        // 取出当前要处理的字节
;;;366        currentData = pCB->rxFIFO.buff[pCB->rxFIFO.currentProcessIndex];
000028  f8b400cc          LDRH     r0,[r4,#0xcc]
00002c  5c20              LDRB     r0,[r4,r0]
;;;367    
;;;368        // 临时缓冲区长度为0时，搜索首字节
;;;369        if (0 == pCmdFrame->length)
00002e  f8b53052          LDRH     r3,[r5,#0x52]
;;;370        {
;;;371            // 命令头错误，删除当前字节并退出
;;;372            if (UART_PROTOCOL_XM_CMD_HEAD != currentData)
;;;373            {
;;;374                pCB->rxFIFO.head++;
;;;375                pCB->rxFIFO.head %= UART_PROTOCOL_XM_RX_FIFO_SIZE;
000032  26c8              MOVS     r6,#0xc8
000034  b19b              CBZ      r3,|L9.94|
;;;376                pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;377    
;;;378    			// 取出当前要处理的字节
;;;379    			currentData = pCB->rxFIFO.buff[pCB->rxFIFO.currentProcessIndex];
;;;380    			
;;;381    			// 一级缓冲区为空，退出
;;;382    			if(pCB->rxFIFO.head == pCB->rxFIFO.end)
;;;383    			{
;;;384    				return;
;;;385    			}
;;;386            }
;;;387    
;;;388            // 命令头正确，但无临时缓冲区可用，退出
;;;389            if ((pCB->rx.end + 1) % UART_PROTOCOL_XM_RX_QUEUE_SIZE == pCB->rx.head)
;;;390            {
;;;391                return;
;;;392            }
;;;393    
;;;394            // 添加UART通讯超时时间设置-2016.1.5增加
;;;395    #if UART_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;396            TIMER_AddTask(TIMER_ID_UART_RX_TIME_OUT_CONTROL,
;;;397                          UART_PROTOCOL_BUS_UNIDIRECTIONAL_TIME_OUT,
;;;398                          UART_PROTOCOL_CALLBACK_RxTimeOut,
;;;399                          0,
;;;400                          1,
;;;401                          ACTION_MODE_ADD_TO_QUEUE);
;;;402    #endif
;;;403    
;;;404            // 命令头正确，有临时缓冲区可用，则将其添加到命令帧临时缓冲区中
;;;405            pCmdFrame->buff[pCmdFrame->length++] = currentData;
;;;406            pCB->rxFIFO.currentProcessIndex++;
;;;407            pCB->rxFIFO.currentProcessIndex %= UART_PROTOCOL_XM_RX_FIFO_SIZE;
;;;408        }
;;;409        // 非首字节，将数据添加到命令帧临时缓冲区中，但暂不删除当前数据
;;;410        else
;;;411        {
;;;412            // 临时缓冲区溢出，说明当前正在接收的命令帧是错误的，正确的命令帧不会出现长度溢出的情况
;;;413            if (pCmdFrame->length >= UART_PROTOCOL_XM_RX_CMD_FRAME_LENGTH_MAX)
000036  f04f0800          MOV      r8,#0
00003a  2b96              CMP      r3,#0x96
00003c  d37e              BCC      |L9.316|
;;;414            {
;;;415    #if UART_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;416                // 停止RX通讯超时检测
;;;417                UART_PROTOCOL_StopRxTimeOutCheck();
;;;418    #endif
;;;419    
;;;420                // 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;421                pCmdFrame->length = 0; // 2016.1.5增加
00003e  f8a58052          STRH     r8,[r5,#0x52]
;;;422                // 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;423                pCB->rxFIFO.head++;
000042  f8340fc8          LDRH     r0,[r4,#0xc8]!
000046  1c40              ADDS     r0,r0,#1
000048  8020              STRH     r0,[r4,#0]
;;;424                pCB->rxFIFO.head %= UART_PROTOCOL_XM_RX_FIFO_SIZE;
00004a  8820              LDRH     r0,[r4,#0]
00004c  fbb0f1f6          UDIV     r1,r0,r6
000050  fb060011          MLS      r0,r6,r1,r0
000054  8020              STRH     r0,[r4,#0]
;;;425                pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
000056  8820              LDRH     r0,[r4,#0]
000058  80a0              STRH     r0,[r4,#4]
                  |L9.90|
;;;426    
;;;427                return;
;;;428            }
;;;429    
;;;430            // 一直取到末尾
;;;431            while (end != pCB->rxFIFO.currentProcessIndex)
;;;432            {
;;;433                // 取出当前要处理的字节
;;;434                currentData = pCB->rxFIFO.buff[pCB->rxFIFO.currentProcessIndex];
;;;435                
;;;436                // 缓冲区未溢出，正常接收，将数据添加到临时缓冲区中
;;;437                pCmdFrame->buff[pCmdFrame->length++] = currentData;
;;;438                pCB->rxFIFO.currentProcessIndex++;
;;;439                pCB->rxFIFO.currentProcessIndex %= UART_PROTOCOL_XM_RX_FIFO_SIZE;
;;;440    
;;;441                // ■■接下来，需要检查命令帧是否完整，如果完整，则将命令帧临时缓冲区扶正■■
;;;442    
;;;443                // 首先判断命令帧最小长度，一个完整的命令字至少包括6个字节: 命令帧最小长度，包含:命令头、设备号、命令字、帧长度、校验码L、校验码H，因此不足6个字节的必定不完整
;;;444                if (pCmdFrame->length < UART_PROTOCOL_XM_CMD_FRAME_LENGTH_MIN)
;;;445                {
;;;446                    // 继续接收
;;;447                    continue;
;;;448                }
;;;449    
;;;450                // 命令帧长度数值越界，说明当前命令帧错误，停止接收
;;;451                if ((uint16)pCmdFrame->buff[UART_PROTOCOL_XM_CMD_LENGTH_INDEX] + UART_PROTOCOL_XM_CMD_FRAME_LENGTH_MIN > UART_PROTOCOL_XM_RX_CMD_FRAME_LENGTH_MAX)
;;;452                {
;;;453    #if UART_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;454                    // 停止RX通讯超时检测
;;;455                    UART_PROTOCOL_StopRxTimeOutCheck();
;;;456    #endif
;;;457    
;;;458                    // 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;459                    pCmdFrame->length = 0;
;;;460    
;;;461                    // 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;462                    pCB->rxFIFO.head++;
;;;463                    pCB->rxFIFO.head %= UART_PROTOCOL_XM_RX_FIFO_SIZE;
;;;464                    pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;465    
;;;466                    return;
;;;467                }
;;;468    
;;;469                // 命令帧长度校验，在命令长度描述字的数值上，增加命令头、设备地址、命令字、数据长度、校验和L、校验和H、结束标识0xD、结束标识OxA，即为命令帧实际长度
;;;470                length = pCmdFrame->length;
;;;471                if (length < pCmdFrame->buff[UART_PROTOCOL_XM_CMD_LENGTH_INDEX] + UART_PROTOCOL_XM_CMD_FRAME_LENGTH_MIN)
;;;472                {
;;;473                    // 长度要求不一致，说明未接收完毕，退出继续
;;;474                    continue;
;;;475                }
;;;476    
;;;477                // 命令帧长度OK，则进行校验，失败时删除命令头
;;;478                if (!UART_PROTOCOL_XM_CheckSUM(pCmdFrame))
;;;479                {
;;;480    #if UART_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;481                    // 停止RX通讯超时检测
;;;482                    UART_PROTOCOL_StopRxTimeOutCheck();
;;;483    #endif
;;;484    
;;;485                    // 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;486                    pCmdFrame->length = 0;
;;;487                    // 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;488                    pCB->rxFIFO.head++;
;;;489                    pCB->rxFIFO.head %= UART_PROTOCOL_XM_RX_FIFO_SIZE;
;;;490                    pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;491    
;;;492                    return;
;;;493                }
;;;494    
;;;495    #if UART_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;496                // 停止RX通讯超时检测
;;;497                UART_PROTOCOL_StopRxTimeOutCheck();
;;;498    #endif
;;;499    
;;;500                // 执行到这里，即说明接收到了一个完整并且正确的命令帧，此时需将处理过的数据从一级缓冲区中删除，并将该命令帧扶正
;;;501                pCB->rxFIFO.head += length;
;;;502                pCB->rxFIFO.head %= UART_PROTOCOL_XM_RX_FIFO_SIZE;
;;;503                pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;504                UART_PROTOCOL_XM_ConfirmTempCmdFrameBuff(pCB);
;;;505    
;;;506                return;
;;;507            }
;;;508        }
;;;509    }
00005a  e8bd81f0          POP      {r4-r8,pc}
                  |L9.94|
00005e  285a              CMP      r0,#0x5a              ;372
000060  d014              BEQ      |L9.140|
000062  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;374
000066  1c40              ADDS     r0,r0,#1              ;374
000068  8020              STRH     r0,[r4,#0]            ;374
00006a  8820              LDRH     r0,[r4,#0]            ;375
00006c  fbb0f1f6          UDIV     r1,r0,r6              ;375
000070  fb060011          MLS      r0,r6,r1,r0           ;375
000074  8020              STRH     r0,[r4,#0]            ;375
000076  8820              LDRH     r0,[r4,#0]            ;376
000078  80a0              STRH     r0,[r4,#4]            ;376
00007a  88a0              LDRH     r0,[r4,#4]            ;379
00007c  3cc8              SUBS     r4,r4,#0xc8           ;379
00007e  5c20              LDRB     r0,[r4,r0]            ;379
000080  f8b410c8          LDRH     r1,[r4,#0xc8]         ;382
000084  f8b430ca          LDRH     r3,[r4,#0xca]         ;382
000088  4299              CMP      r1,r3                 ;382
00008a  d0e6              BEQ      |L9.90|
                  |L9.140|
00008c  1c52              ADDS     r2,r2,#1              ;389
00008e  2105              MOVS     r1,#5                 ;389
000090  fbb2f3f1          UDIV     r3,r2,r1              ;389
000094  fb012113          MLS      r1,r1,r3,r2           ;389
000098  f8b42274          LDRH     r2,[r4,#0x274]        ;389
00009c  4291              CMP      r1,r2                 ;389
00009e  d0dc              BEQ      |L9.90|
0000a0  f8b51052          LDRH     r1,[r5,#0x52]         ;405
0000a4  1c4a              ADDS     r2,r1,#1              ;405
0000a6  4429              ADD      r1,r1,r5              ;405
0000a8  f8a52052          STRH     r2,[r5,#0x52]         ;405
0000ac  7088              STRB     r0,[r1,#2]            ;405
0000ae  f8340fcc          LDRH     r0,[r4,#0xcc]!        ;406
0000b2  1c40              ADDS     r0,r0,#1              ;406
0000b4  b280              UXTH     r0,r0                 ;406
0000b6  fbb0f1f6          UDIV     r1,r0,r6              ;407
0000ba  fb060011          MLS      r0,r6,r1,r0           ;407
0000be  8020              STRH     r0,[r4,#0]            ;407
0000c0  e7cb              B        |L9.90|
                  |L9.194|
0000c2  5c22              LDRB     r2,[r4,r0]            ;434
0000c4  f8b50052          LDRH     r0,[r5,#0x52]         ;437
0000c8  1c43              ADDS     r3,r0,#1              ;437
0000ca  4428              ADD      r0,r0,r5              ;437
0000cc  f8a53052          STRH     r3,[r5,#0x52]         ;437
0000d0  7082              STRB     r2,[r0,#2]            ;437
0000d2  f8b400cc          LDRH     r0,[r4,#0xcc]         ;438
0000d6  1c40              ADDS     r0,r0,#1              ;438
0000d8  b280              UXTH     r0,r0                 ;438
0000da  fbb0f2f6          UDIV     r2,r0,r6              ;439
0000de  fb060012          MLS      r0,r6,r2,r0           ;439
0000e2  f8a400cc          STRH     r0,[r4,#0xcc]         ;439
0000e6  f8b57052          LDRH     r7,[r5,#0x52]         ;444
0000ea  2f06              CMP      r7,#6                 ;444
0000ec  d33b              BCC      |L9.358|
0000ee  7968              LDRB     r0,[r5,#5]            ;451
0000f0  1d80              ADDS     r0,r0,#6              ;451
0000f2  2896              CMP      r0,#0x96              ;451
0000f4  d90e              BLS      |L9.276|
0000f6  f8a58052          STRH     r8,[r5,#0x52]         ;459
0000fa  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;462
0000fe  1c40              ADDS     r0,r0,#1              ;462
000100  8020              STRH     r0,[r4,#0]            ;462
000102  8820              LDRH     r0,[r4,#0]            ;463
000104  fbb0f1f6          UDIV     r1,r0,r6              ;463
000108  fb060011          MLS      r0,r6,r1,r0           ;463
00010c  8020              STRH     r0,[r4,#0]            ;463
00010e  8820              LDRH     r0,[r4,#0]            ;464
000110  80a0              STRH     r0,[r4,#4]            ;464
000112  e7a2              B        |L9.90|
                  |L9.276|
000114  42b8              CMP      r0,r7                 ;471
000116  d826              BHI      |L9.358|
000118  4628              MOV      r0,r5                 ;478
00011a  f7fffffe          BL       UART_PROTOCOL_XM_CheckSUM
00011e  b198              CBZ      r0,|L9.328|
000120  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;501
000124  4438              ADD      r0,r0,r7              ;501
000126  8020              STRH     r0,[r4,#0]            ;501
000128  8820              LDRH     r0,[r4,#0]            ;502
00012a  fbb0f1f6          UDIV     r1,r0,r6              ;502
00012e  fb060011          MLS      r0,r6,r1,r0           ;502
000132  8020              STRH     r0,[r4,#0]            ;502
000134  8820              LDRH     r0,[r4,#0]            ;503
000136  80a0              STRH     r0,[r4,#4]            ;503
000138  3cc8              SUBS     r4,r4,#0xc8           ;503
00013a  e000              B        |L9.318|
                  |L9.316|
00013c  e013              B        |L9.358|
                  |L9.318|
00013e  4620              MOV      r0,r4                 ;504
000140  e8bd41f0          POP      {r4-r8,lr}            ;504
000144  f7ffbffe          B.W      UART_PROTOCOL_XM_ConfirmTempCmdFrameBuff
                  |L9.328|
000148  f8a58052          STRH     r8,[r5,#0x52]         ;486
00014c  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;488
000150  1c40              ADDS     r0,r0,#1              ;488
000152  8020              STRH     r0,[r4,#0]            ;488
000154  8820              LDRH     r0,[r4,#0]            ;489
000156  fbb0f1f6          UDIV     r1,r0,r6              ;489
00015a  fb060011          MLS      r0,r6,r1,r0           ;489
00015e  8020              STRH     r0,[r4,#0]            ;489
000160  8820              LDRH     r0,[r4,#0]            ;490
000162  80a0              STRH     r0,[r4,#4]            ;490
000164  e779              B        |L9.90|
                  |L9.358|
000166  f8b400cc          LDRH     r0,[r4,#0xcc]         ;431
00016a  4288              CMP      r0,r1                 ;431
00016c  d1a9              BNE      |L9.194|
00016e  e774              B        |L9.90|
;;;510    
                          ENDP


                          AREA ||i.UART_PROTOCOL_XM_SendCmdAck||, CODE, READONLY, ALIGN=1

                  UART_PROTOCOL_XM_SendCmdAck PROC
;;;1050   // 发送命令回复
;;;1051   void UART_PROTOCOL_XM_SendCmdAck(uint8 ackCmd)
000000  b510              PUSH     {r4,lr}
;;;1052   {
000002  4604              MOV      r4,r0
;;;1053       UART_PROTOCOL_XM_TxAddData(UART_PROTOCOL_XM_CMD_HEAD);
000004  205a              MOVS     r0,#0x5a
000006  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
;;;1054       UART_PROTOCOL_XM_TxAddData(UART_PROTOCOL_XM_CMD_DEVICE);
00000a  2012              MOVS     r0,#0x12
00000c  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
;;;1055   
;;;1056       UART_PROTOCOL_XM_TxAddData(ackCmd);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
;;;1057       UART_PROTOCOL_XM_TxAddData(0x00);         // 数据长度
000016  2000              MOVS     r0,#0
000018  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
;;;1058       UART_PROTOCOL_XM_TxAddFrame();
00001c  e8bd4010          POP      {r4,lr}
000020  f7ffbffe          B.W      UART_PROTOCOL_XM_TxAddFrame
;;;1059   }
;;;1060   
                          ENDP


                          AREA ||i.UART_PROTOCOL_XM_SendCmdParamAck||, CODE, READONLY, ALIGN=1

                  UART_PROTOCOL_XM_SendCmdParamAck PROC
;;;1061   // 发送命令回复，带一个参数
;;;1062   void UART_PROTOCOL_XM_SendCmdParamAck(uint8 ackCmd, uint8 ackParam)
000000  b530              PUSH     {r4,r5,lr}
;;;1063   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1064   
;;;1065       UART_PROTOCOL_XM_TxAddData(UART_PROTOCOL_XM_CMD_HEAD);
000006  205a              MOVS     r0,#0x5a
000008  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
;;;1066       UART_PROTOCOL_XM_TxAddData(UART_PROTOCOL_XM_CMD_DEVICE);
00000c  2012              MOVS     r0,#0x12
00000e  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
;;;1067   
;;;1068       UART_PROTOCOL_XM_TxAddData(ackCmd);
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
;;;1069       UART_PROTOCOL_XM_TxAddData(0x01);
000018  2001              MOVS     r0,#1
00001a  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
;;;1070   
;;;1071       UART_PROTOCOL_XM_TxAddData(ackParam);
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
;;;1072       UART_PROTOCOL_XM_TxAddFrame();
000024  e8bd4030          POP      {r4,r5,lr}
000028  f7ffbffe          B.W      UART_PROTOCOL_XM_TxAddFrame
;;;1073   }
;;;1074   
                          ENDP


                          AREA ||i.UART_PROTOCOL_XM_SendCmdTwoParamAck||, CODE, READONLY, ALIGN=1

                  UART_PROTOCOL_XM_SendCmdTwoParamAck PROC
;;;1075   // 发送命令回复，带两个个参数
;;;1076   void UART_PROTOCOL_XM_SendCmdTwoParamAck(uint8 ackCmd, uint8 ackParam, uint8 two_ackParam)
000000  b570              PUSH     {r4-r6,lr}
;;;1077   {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;1078       UART_PROTOCOL_XM_TxAddData(UART_PROTOCOL_XM_CMD_HEAD);
000008  205a              MOVS     r0,#0x5a
00000a  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
;;;1079       UART_PROTOCOL_XM_TxAddData(UART_PROTOCOL_XM_CMD_DEVICE);
00000e  2012              MOVS     r0,#0x12
000010  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
;;;1080       UART_PROTOCOL_XM_TxAddData(ackCmd);
000014  4630              MOV      r0,r6
000016  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
;;;1081       UART_PROTOCOL_XM_TxAddData(0x02);
00001a  2002              MOVS     r0,#2
00001c  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
;;;1082   
;;;1083       UART_PROTOCOL_XM_TxAddData(ackParam);
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
;;;1084       UART_PROTOCOL_XM_TxAddData(two_ackParam);
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
;;;1085       UART_PROTOCOL_XM_TxAddFrame();
00002c  e8bd4070          POP      {r4-r6,lr}
000030  f7ffbffe          B.W      UART_PROTOCOL_XM_TxAddFrame
;;;1086   }
;;;1087   
                          ENDP


                          AREA ||i.UART_PROTOCOL_XM_Test||, CODE, READONLY, ALIGN=1

                  UART_PROTOCOL_XM_Test PROC
;;;1112   // 发送命令回复
;;;1113   void UART_PROTOCOL_XM_Test(uint32 param)
000000  b500              PUSH     {lr}
;;;1114   {
;;;1115       UART_PROTOCOL_XM_TxAddData(UART_PROTOCOL_XM_CMD_HEAD);
000002  205a              MOVS     r0,#0x5a
000004  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
;;;1116       UART_PROTOCOL_XM_TxAddData(UART_PROTOCOL_XM_CMD_DEVICE);
000008  2012              MOVS     r0,#0x12
00000a  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
;;;1117   
;;;1118       UART_PROTOCOL_XM_TxAddData(UART_PROTOCOL_XM_CMD_GET_OOB_PARAM);
00000e  2095              MOVS     r0,#0x95
000010  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
;;;1119       UART_PROTOCOL_XM_TxAddData(0x00);         // 数据长度
000014  2000              MOVS     r0,#0
000016  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
;;;1120       UART_PROTOCOL_XM_TxAddFrame();
00001a  f85deb04          POP      {lr}
00001e  f7ffbffe          B.W      UART_PROTOCOL_XM_TxAddFrame
;;;1121   }
;;;1122   
                          ENDP


                          AREA ||i.UART_PROTOCOL_XM_TxAddData||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL_XM_TxAddData PROC
;;;143    // 向发送命令帧队列中添加数据
;;;144    void UART_PROTOCOL_XM_TxAddData(uint8 data)
000000  b530              PUSH     {r4,r5,lr}
;;;145    {
;;;146        uint16 head = uartProtocolCB5.tx.head;
000002  490f              LDR      r1,|L14.64|
000004  f8b1457a          LDRH     r4,[r1,#0x57a]  ; uartProtocolCB5
;;;147        uint16 end = uartProtocolCB5.tx.end;
000008  f8b1257c          LDRH     r2,[r1,#0x57c]  ; uartProtocolCB5
;;;148        UART_PROTOCOL_XM_TX_CMD_FRAME *pCmdFrame = &uartProtocolCB5.tx.cmdQueue[uartProtocolCB5.tx.end];
00000c  234d              MOVS     r3,#0x4d
00000e  4353              MULS     r3,r2,r3
000010  eb010143          ADD      r1,r1,r3,LSL #1
000014  f501711e          ADD      r1,r1,#0x278
;;;149    
;;;150        // 发送缓冲区已满，不予接收
;;;151        if ((end + 1) % UART_PROTOCOL_XM_TX_QUEUE_SIZE == head)
000018  1c52              ADDS     r2,r2,#1
00001a  2305              MOVS     r3,#5
00001c  fbb2f5f3          UDIV     r5,r2,r3
000020  fb032215          MLS      r2,r3,r5,r2
000024  42a2              CMP      r2,r4
000026  d009              BEQ      |L14.60|
;;;152        {
;;;153            return;
;;;154        }
;;;155    
;;;156        // 队尾命令帧已满，退出
;;;157        if (pCmdFrame->length >= UART_PROTOCOL_XM_TX_CMD_FRAME_LENGTH_MAX)
000028  f8b12098          LDRH     r2,[r1,#0x98]
00002c  2a96              CMP      r2,#0x96
00002e  d205              BCS      |L14.60|
;;;158        {
;;;159            return;
;;;160        }
;;;161    
;;;162        // 数据添加到帧末尾，并更新帧长度
;;;163        pCmdFrame->buff[pCmdFrame->length] = data;
000030  1c8b              ADDS     r3,r1,#2
000032  54d0              STRB     r0,[r2,r3]
;;;164        pCmdFrame->length++;
000034  f8310f98          LDRH     r0,[r1,#0x98]!
000038  1c40              ADDS     r0,r0,#1
00003a  8008              STRH     r0,[r1,#0]
                  |L14.60|
;;;165    }
00003c  bd30              POP      {r4,r5,pc}
;;;166    
                          ENDP

00003e  0000              DCW      0x0000
                  |L14.64|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOL_XM_TxAddFrame||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL_XM_TxAddFrame PROC
;;;167    // 确认添加命令帧，即承认之前填充的数据为命令帧，将其添加到发送队列中，由main进行调度发送，本函数内会自动校正命令长度，并添加校验码
;;;168    void UART_PROTOCOL_XM_TxAddFrame(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;169    {
;;;170        uint16 checkSum = 0;
;;;171        uint16 i = 0;
;;;172        uint16 head = uartProtocolCB5.tx.head;
000002  4d1e              LDR      r5,|L15.124|
000004  f8b5257a          LDRH     r2,[r5,#0x57a]  ; uartProtocolCB5
;;;173        uint16 end = uartProtocolCB5.tx.end;
000008  f8b5057c          LDRH     r0,[r5,#0x57c]  ; uartProtocolCB5
;;;174        UART_PROTOCOL_XM_TX_CMD_FRAME *pCmdFrame = &uartProtocolCB5.tx.cmdQueue[uartProtocolCB5.tx.end];
00000c  214d              MOVS     r1,#0x4d
00000e  4341              MULS     r1,r0,r1
000010  eb050441          ADD      r4,r5,r1,LSL #1
000014  f504741e          ADD      r4,r4,#0x278
;;;175        uint16 length = pCmdFrame->length;
000018  f8b41098          LDRH     r1,[r4,#0x98]
;;;176    
;;;177        // 发送缓冲区已满，不予接收
;;;178        if ((end + 1) % UART_PROTOCOL_XM_TX_QUEUE_SIZE == head)
00001c  1c40              ADDS     r0,r0,#1
00001e  2605              MOVS     r6,#5
000020  fbb0f3f6          UDIV     r3,r0,r6
000024  fb060013          MLS      r0,r6,r3,r0
000028  4290              CMP      r0,r2
00002a  d004              BEQ      |L15.54|
;;;179        {
;;;180            return;
;;;181        }
;;;182    
;;;183        // 命令帧长度不足，清除已填充的数据，退出
;;;184        if (UART_PROTOCOL_XM_CMD_FRAME_LENGTH_MIN - 2 > length) // 减去"CRC校验位H,L"2个字节
00002c  2904              CMP      r1,#4
00002e  d203              BCS      |L15.56|
;;;185        {
;;;186            pCmdFrame->length = 0;
000030  2000              MOVS     r0,#0
000032  f8a40098          STRH     r0,[r4,#0x98]
                  |L15.54|
;;;187    
;;;188            return;
;;;189        }
;;;190    
;;;191    
;;;192        // 队尾命令帧已满，退出
;;;193        if ((length + 2 >= UART_PROTOCOL_XM_TX_CMD_FRAME_LENGTH_MAX)) // 留出2个字节给"校验和、结束码"
;;;194        {
;;;195            return;
;;;196        }
;;;197    
;;;198        // 重新设置数据长度，系统在准备数据时，填充的"数据长度"可以为任意值，并且不需要添加校验码，在这里重新设置为正确的值
;;;199        // 重设数据长度，需要减4=("1头+1设备号+1命令+1长度")
;;;200        pCmdFrame->buff[UART_PROTOCOL_XM_CMD_LENGTH_INDEX] = length - 4;    // 重设数据长度
;;;201    
;;;202        checkSum = calCrc16(pCmdFrame->buff, length);
;;;203    
;;;204        pCmdFrame->buff[pCmdFrame->length] = (uint8)((checkSum >> 8) & 0xFF);
;;;205        pCmdFrame->length ++;
;;;206    
;;;207        pCmdFrame->buff[pCmdFrame->length] = (uint8)(checkSum & 0xFF);
;;;208        pCmdFrame->length ++;
;;;209    
;;;210        uartProtocolCB5.tx.end ++;
;;;211        uartProtocolCB5.tx.end %= UART_PROTOCOL_XM_TX_QUEUE_SIZE;
;;;212    }
000036  bdf0              POP      {r4-r7,pc}
                  |L15.56|
000038  1c88              ADDS     r0,r1,#2              ;193
00003a  2896              CMP      r0,#0x96              ;193
00003c  d2fb              BCS      |L15.54|
00003e  1f08              SUBS     r0,r1,#4              ;200
000040  7160              STRB     r0,[r4,#5]            ;200
000042  1ca0              ADDS     r0,r4,#2              ;202
000044  f7fffffe          BL       calCrc16
000048  0a03              LSRS     r3,r0,#8              ;204
00004a  f8b47098          LDRH     r7,[r4,#0x98]         ;204
00004e  1ca1              ADDS     r1,r4,#2              ;204
000050  460a              MOV      r2,r1                 ;204
000052  547b              STRB     r3,[r7,r1]            ;204
000054  f8341f98          LDRH     r1,[r4,#0x98]!        ;205
000058  1c49              ADDS     r1,r1,#1              ;205
00005a  b289              UXTH     r1,r1                 ;205
00005c  8021              STRH     r1,[r4,#0]            ;205
00005e  5488              STRB     r0,[r1,r2]            ;207
000060  8820              LDRH     r0,[r4,#0]            ;208
000062  1c40              ADDS     r0,r0,#1              ;208
000064  8020              STRH     r0,[r4,#0]            ;208
000066  f8b5057c          LDRH     r0,[r5,#0x57c]        ;210  ; uartProtocolCB5
00006a  1c40              ADDS     r0,r0,#1              ;210
00006c  b280              UXTH     r0,r0                 ;210
00006e  fbb0f1f6          UDIV     r1,r0,r6              ;211
000072  fb060011          MLS      r0,r6,r1,r0           ;211
000076  f8a5057c          STRH     r0,[r5,#0x57c]        ;211
00007a  bdf0              POP      {r4-r7,pc}
;;;213    
                          ENDP

                  |L15.124|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOL_XM_TxStateProcess||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL_XM_TxStateProcess PROC
;;;308    // 协议层发送处理过程
;;;309    void UART_PROTOCOL_XM_TxStateProcess(void)
000000  b570              PUSH     {r4-r6,lr}
;;;310    {
;;;311        uint16 head = uartProtocolCB5.tx.head;
000002  4c14              LDR      r4,|L16.84|
000004  f8b4357a          LDRH     r3,[r4,#0x57a]  ; uartProtocolCB5
;;;312        uint16 end = uartProtocolCB5.tx.end;
000008  f8b4657c          LDRH     r6,[r4,#0x57c]  ; uartProtocolCB5
;;;313        uint16 length = uartProtocolCB5.tx.cmdQueue[head].length;
00000c  204d              MOVS     r0,#0x4d
00000e  4358              MULS     r0,r3,r0
000010  eb040040          ADD      r0,r4,r0,LSL #1
000014  4605              MOV      r5,r0
000016  f8b02310          LDRH     r2,[r0,#0x310]
;;;314        uint8 *pCmd = uartProtocolCB5.tx.cmdQueue[head].buff;
00001a  f200217a          ADD      r1,r0,#0x27a
;;;315        uint16 localDeviceID = uartProtocolCB5.tx.cmdQueue[head].deviceID;
00001e  f8b00278          LDRH     r0,[r0,#0x278]
;;;316    
;;;317        // 发送缓冲区为空，说明无数据
;;;318        if (head == end)
000022  42b3              CMP      r3,r6
000024  d014              BEQ      |L16.80|
;;;319        {
;;;320            return;
;;;321        }
;;;322    
;;;323        // 发送函数没有注册直接返回
;;;324        if (NULL == uartProtocolCB5.sendDataThrowService)
000026  f8d43584          LDR      r3,[r4,#0x584]  ; uartProtocolCB5
00002a  2b00              CMP      r3,#0
00002c  d010              BEQ      |L16.80|
;;;325        {
;;;326            return;
;;;327        }
;;;328    
;;;329        // 协议层有数据需要发送到驱动层
;;;330        if (!(*uartProtocolCB5.sendDataThrowService)(localDeviceID, pCmd, length))
00002e  4798              BLX      r3
000030  2800              CMP      r0,#0
000032  d00d              BEQ      |L16.80|
;;;331        {
;;;332            return;
;;;333        }
;;;334    
;;;335        // 发送环形队列更新位置
;;;336        uartProtocolCB5.tx.cmdQueue[head].length = 0;
000034  2000              MOVS     r0,#0
000036  f8a50310          STRH     r0,[r5,#0x310]
;;;337        uartProtocolCB5.tx.head++;
00003a  f8b4057a          LDRH     r0,[r4,#0x57a]  ; uartProtocolCB5
00003e  1c40              ADDS     r0,r0,#1
000040  b280              UXTH     r0,r0
;;;338        uartProtocolCB5.tx.head %= UART_PROTOCOL_XM_TX_QUEUE_SIZE;
000042  2105              MOVS     r1,#5
000044  fbb0f2f1          UDIV     r2,r0,r1
000048  fb010012          MLS      r0,r1,r2,r0
00004c  f8a4057a          STRH     r0,[r4,#0x57a]
                  |L16.80|
;;;339    }
000050  bd70              POP      {r4-r6,pc}
;;;340    
                          ENDP

000052  0000              DCW      0x0000
                  |L16.84|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOL_XM_WriteFlag||, CODE, READONLY, ALIGN=1

                  UART_PROTOCOL_XM_WriteFlag PROC
;;;1094   // 写入标志区数据
;;;1095   void UART_PROTOCOL_XM_WriteFlag(uint8 placeParam, uint8 shutdownFlagParam)
000000  b530              PUSH     {r4,r5,lr}
;;;1096   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1097   
;;;1098       UART_PROTOCOL_XM_TxAddData(UART_PROTOCOL_XM_CMD_HEAD);
000006  205a              MOVS     r0,#0x5a
000008  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
;;;1099       UART_PROTOCOL_XM_TxAddData(UART_PROTOCOL_XM_CMD_DEVICE);
00000c  2012              MOVS     r0,#0x12
00000e  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
;;;1100       UART_PROTOCOL_XM_TxAddData(UART_PROTOCOL_XM_CMD_WRITE_FLAG_DATA);
000012  2082              MOVS     r0,#0x82
000014  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
;;;1101       UART_PROTOCOL_XM_TxAddData(0x06);
000018  2006              MOVS     r0,#6
00001a  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
;;;1102   
;;;1103       UART_PROTOCOL_XM_TxAddData(placeParam);
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
;;;1104       UART_PROTOCOL_XM_TxAddData(0x00);
000024  2000              MOVS     r0,#0
000026  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
;;;1105       UART_PROTOCOL_XM_TxAddData(0x00);
00002a  2000              MOVS     r0,#0
00002c  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
;;;1106       UART_PROTOCOL_XM_TxAddData(0x00);
000030  2000              MOVS     r0,#0
000032  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
;;;1107       UART_PROTOCOL_XM_TxAddData(0x02);
000036  2002              MOVS     r0,#2
000038  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
;;;1108       UART_PROTOCOL_XM_TxAddData(shutdownFlagParam);
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
;;;1109       UART_PROTOCOL_XM_TxAddFrame();
000042  e8bd4030          POP      {r4,r5,lr}
000046  f7ffbffe          B.W      UART_PROTOCOL_XM_TxAddFrame
;;;1110   }
;;;1111   
                          ENDP


                          AREA ||i.calCrc16||, CODE, READONLY, ALIGN=2

                  calCrc16 PROC
;;;102    
;;;103    uint16 calCrc16(unsigned char *buf, int len)
000000  b530              PUSH     {r4,r5,lr}
;;;104    {
000002  4603              MOV      r3,r0
;;;105        int i;
;;;106        unsigned short cksum;
;;;107    
;;;108        cksum = 0;
000004  2000              MOVS     r0,#0
;;;109        for (i = 0; i < len; i++)
000006  2200              MOVS     r2,#0
;;;110        {
;;;111            cksum = crc16Tab[((cksum >> 8) ^ *buf++) & 0xFF] ^ (cksum << 8);
000008  4c07              LDR      r4,|L18.40|
00000a  e009              B        |L18.32|
                  |L18.12|
00000c  f8135b01          LDRB     r5,[r3],#1
000010  ea852510          EOR      r5,r5,r0,LSR #8
000014  f8345015          LDRH     r5,[r4,r5,LSL #1]
000018  ea852000          EOR      r0,r5,r0,LSL #8
00001c  b280              UXTH     r0,r0
00001e  1c52              ADDS     r2,r2,#1              ;109
                  |L18.32|
000020  428a              CMP      r2,r1                 ;109
000022  dbf3              BLT      |L18.12|
;;;112        }
;;;113    
;;;114        return cksum;
;;;115    }
000024  bd30              POP      {r4,r5,pc}
;;;116    
                          ENDP

000026  0000              DCW      0x0000
                  |L18.40|
                          DCD      ||.constdata||+0x4

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  uartProtocolCB5
                          %        1428
                  conVer
                          %        20

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

000000  ff000000          DCB      0xff,0x00,0x00,0x00
                  crc16Tab
000004  00001021          DCW      0x0000,0x1021
000008  20423063          DCW      0x2042,0x3063
00000c  408450a5          DCW      0x4084,0x50a5
000010  60c670e7          DCW      0x60c6,0x70e7
000014  81089129          DCW      0x8108,0x9129
000018  a14ab16b          DCW      0xa14a,0xb16b
00001c  c18cd1ad          DCW      0xc18c,0xd1ad
000020  e1cef1ef          DCW      0xe1ce,0xf1ef
000024  12310210          DCW      0x1231,0x0210
000028  32732252          DCW      0x3273,0x2252
00002c  52b54294          DCW      0x52b5,0x4294
000030  72f762d6          DCW      0x72f7,0x62d6
000034  93398318          DCW      0x9339,0x8318
000038  b37ba35a          DCW      0xb37b,0xa35a
00003c  d3bdc39c          DCW      0xd3bd,0xc39c
000040  f3ffe3de          DCW      0xf3ff,0xe3de
000044  24623443          DCW      0x2462,0x3443
000048  04201401          DCW      0x0420,0x1401
00004c  64e674c7          DCW      0x64e6,0x74c7
000050  44a45485          DCW      0x44a4,0x5485
000054  a56ab54b          DCW      0xa56a,0xb54b
000058  85289509          DCW      0x8528,0x9509
00005c  e5eef5cf          DCW      0xe5ee,0xf5cf
000060  c5acd58d          DCW      0xc5ac,0xd58d
000064  36532672          DCW      0x3653,0x2672
000068  16110630          DCW      0x1611,0x0630
00006c  76d766f6          DCW      0x76d7,0x66f6
000070  569546b4          DCW      0x5695,0x46b4
000074  b75ba77a          DCW      0xb75b,0xa77a
000078  97198738          DCW      0x9719,0x8738
00007c  f7dfe7fe          DCW      0xf7df,0xe7fe
000080  d79dc7bc          DCW      0xd79d,0xc7bc
000084  48c458e5          DCW      0x48c4,0x58e5
000088  688678a7          DCW      0x6886,0x78a7
00008c  08401861          DCW      0x0840,0x1861
000090  28023823          DCW      0x2802,0x3823
000094  c9ccd9ed          DCW      0xc9cc,0xd9ed
000098  e98ef9af          DCW      0xe98e,0xf9af
00009c  89489969          DCW      0x8948,0x9969
0000a0  a90ab92b          DCW      0xa90a,0xb92b
0000a4  5af54ad4          DCW      0x5af5,0x4ad4
0000a8  7ab76a96          DCW      0x7ab7,0x6a96
0000ac  1a710a50          DCW      0x1a71,0x0a50
0000b0  3a332a12          DCW      0x3a33,0x2a12
0000b4  dbfdcbdc          DCW      0xdbfd,0xcbdc
0000b8  fbbfeb9e          DCW      0xfbbf,0xeb9e
0000bc  9b798b58          DCW      0x9b79,0x8b58
0000c0  bb3bab1a          DCW      0xbb3b,0xab1a
0000c4  6ca67c87          DCW      0x6ca6,0x7c87
0000c8  4ce45cc5          DCW      0x4ce4,0x5cc5
0000cc  2c223c03          DCW      0x2c22,0x3c03
0000d0  0c601c41          DCW      0x0c60,0x1c41
0000d4  edaefd8f          DCW      0xedae,0xfd8f
0000d8  cdecddcd          DCW      0xcdec,0xddcd
0000dc  ad2abd0b          DCW      0xad2a,0xbd0b
0000e0  8d689d49          DCW      0x8d68,0x9d49
0000e4  7e976eb6          DCW      0x7e97,0x6eb6
0000e8  5ed54ef4          DCW      0x5ed5,0x4ef4
0000ec  3e132e32          DCW      0x3e13,0x2e32
0000f0  1e510e70          DCW      0x1e51,0x0e70
0000f4  ff9fefbe          DCW      0xff9f,0xefbe
0000f8  dfddcffc          DCW      0xdfdd,0xcffc
0000fc  bf1baf3a          DCW      0xbf1b,0xaf3a
000100  9f598f78          DCW      0x9f59,0x8f78
000104  918881a9          DCW      0x9188,0x81a9
000108  b1caa1eb          DCW      0xb1ca,0xa1eb
00010c  d10cc12d          DCW      0xd10c,0xc12d
000110  f14ee16f          DCW      0xf14e,0xe16f
000114  108000a1          DCW      0x1080,0x00a1
000118  30c220e3          DCW      0x30c2,0x20e3
00011c  50044025          DCW      0x5004,0x4025
000120  70466067          DCW      0x7046,0x6067
000124  83b99398          DCW      0x83b9,0x9398
000128  a3fbb3da          DCW      0xa3fb,0xb3da
00012c  c33dd31c          DCW      0xc33d,0xd31c
000130  e37ff35e          DCW      0xe37f,0xf35e
000134  02b11290          DCW      0x02b1,0x1290
000138  22f332d2          DCW      0x22f3,0x32d2
00013c  42355214          DCW      0x4235,0x5214
000140  62777256          DCW      0x6277,0x7256
000144  b5eaa5cb          DCW      0xb5ea,0xa5cb
000148  95a88589          DCW      0x95a8,0x8589
00014c  f56ee54f          DCW      0xf56e,0xe54f
000150  d52cc50d          DCW      0xd52c,0xc50d
000154  34e224c3          DCW      0x34e2,0x24c3
000158  14a00481          DCW      0x14a0,0x0481
00015c  74666447          DCW      0x7466,0x6447
000160  54244405          DCW      0x5424,0x4405
000164  a7dbb7fa          DCW      0xa7db,0xb7fa
000168  879997b8          DCW      0x8799,0x97b8
00016c  e75ff77e          DCW      0xe75f,0xf77e
000170  c71dd73c          DCW      0xc71d,0xd73c
000174  26d336f2          DCW      0x26d3,0x36f2
000178  069116b0          DCW      0x0691,0x16b0
00017c  66577676          DCW      0x6657,0x7676
000180  46155634          DCW      0x4615,0x5634
000184  d94cc96d          DCW      0xd94c,0xc96d
000188  f90ee92f          DCW      0xf90e,0xe92f
00018c  99c889e9          DCW      0x99c8,0x89e9
000190  b98aa9ab          DCW      0xb98a,0xa9ab
000194  58444865          DCW      0x5844,0x4865
000198  78066827          DCW      0x7806,0x6827
00019c  18c008e1          DCW      0x18c0,0x08e1
0001a0  388228a3          DCW      0x3882,0x28a3
0001a4  cb7ddb5c          DCW      0xcb7d,0xdb5c
0001a8  eb3ffb1e          DCW      0xeb3f,0xfb1e
0001ac  8bf99bd8          DCW      0x8bf9,0x9bd8
0001b0  abbbbb9a          DCW      0xabbb,0xbb9a
0001b4  4a755a54          DCW      0x4a75,0x5a54
0001b8  6a377a16          DCW      0x6a37,0x7a16
0001bc  0af11ad0          DCW      0x0af1,0x1ad0
0001c0  2ab33a92          DCW      0x2ab3,0x3a92
0001c4  fd2eed0f          DCW      0xfd2e,0xed0f
0001c8  dd6ccd4d          DCW      0xdd6c,0xcd4d
0001cc  bdaaad8b          DCW      0xbdaa,0xad8b
0001d0  9de88dc9          DCW      0x9de8,0x8dc9
0001d4  7c266c07          DCW      0x7c26,0x6c07
0001d8  5c644c45          DCW      0x5c64,0x4c45
0001dc  3ca22c83          DCW      0x3ca2,0x2c83
0001e0  1ce00cc1          DCW      0x1ce0,0x0cc1
0001e4  ef1fff3e          DCW      0xef1f,0xff3e
0001e8  cf5ddf7c          DCW      0xcf5d,0xdf7c
0001ec  af9bbfba          DCW      0xaf9b,0xbfba
0001f0  8fd99ff8          DCW      0x8fd9,0x9ff8
0001f4  6e177e36          DCW      0x6e17,0x7e36
0001f8  4e555e74          DCW      0x4e55,0x5e74
0001fc  2e933eb2          DCW      0x2e93,0x3eb2
000200  0ed11ef0          DCW      0x0ed1,0x1ef0

                          AREA ||.data||, DATA, ALIGN=0

                  verLenght
000000  00                DCB      0x00
                  infoLen
000001  00                DCB      0x00
                  checkMark
000002  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "User\\UartProtocolXM.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_UartProtocolXM_c_c329fa19____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___16_UartProtocolXM_c_c329fa19____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_UartProtocolXM_c_c329fa19____REVSH|
#line 128
|__asm___16_UartProtocolXM_c_c329fa19____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
