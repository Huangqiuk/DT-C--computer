; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\uartprotocoliot.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\uartprotocoliot.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -I.\User\qrencode -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.1\Device\Include -D__MICROLIB -D__UVISION_VERSION=534 -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\uartprotocoliot.crf User\UartProtocolIOT.c]
                          THUMB

                          AREA ||i.UART_PROTOCOLIOT_CALLBACK_UartBusError||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOLIOT_CALLBACK_UartBusError PROC
;;;692    // 	UART总线超时错误处理
;;;693    void UART_PROTOCOLIOT_CALLBACK_UartBusError(uint32 param)
000000  4902              LDR      r1,|L1.12|
;;;694    {
;;;695    	PARAM_SetErrorCode(ERROR_TYPE_COMMUNICATION_TIME_OUT);
000002  2030              MOVS     r0,#0x30
000004  f8810221          STRB     r0,[r1,#0x221]
;;;696    }
000008  4770              BX       lr
;;;697    
                          ENDP

00000a  0000              DCW      0x0000
                  |L1.12|
                          DCD      paramCB

                          AREA ||i.UART_PROTOCOLIOT_CheckSUM||, CODE, READONLY, ALIGN=1

                  UART_PROTOCOLIOT_CheckSUM PROC
;;;477    // 对传入的命令帧进行校验，返回校验结果
;;;478    BOOL UART_PROTOCOLIOT_CheckSUM(UART_PROTOCOLIOT_RX_CMD_FRAME* pCmdFrame)
000000  b530              PUSH     {r4,r5,lr}
;;;479    {
;;;480    	uint8 checkSum = 0;
000002  2200              MOVS     r2,#0
;;;481    	uint16 i = 0;
000004  2100              MOVS     r1,#0
;;;482    	
;;;483    	if(NULL == pCmdFrame)
000006  2800              CMP      r0,#0
000008  d003              BEQ      |L2.18|
;;;484    	{
;;;485    		return FALSE;
;;;486    	}
;;;487    
;;;488    	// 从命令头开始，到校验码之前的一个字节，依次进行异或运算
;;;489    	for(i=0; i<pCmdFrame->length-1; i++)
00000a  f8b05098          LDRH     r5,[r0,#0x98]
00000e  1e6b              SUBS     r3,r5,#1
000010  e006              B        |L2.32|
                  |L2.18|
000012  2000              MOVS     r0,#0                 ;485
;;;490    	{
;;;491    		checkSum ^= pCmdFrame->buff[i];
;;;492    	}
;;;493    
;;;494    	checkSum = ~checkSum;
;;;495    		
;;;496    	// 判断计算得到的校验码与命令帧中的校验码是否相同
;;;497    	if(pCmdFrame->buff[pCmdFrame->length-1] != checkSum)
;;;498    	{
;;;499    		return FALSE;
;;;500    	}
;;;501    	
;;;502    	return TRUE;
;;;503    }
000014  bd30              POP      {r4,r5,pc}
                  |L2.22|
000016  1844              ADDS     r4,r0,r1              ;491
000018  78a4              LDRB     r4,[r4,#2]            ;491
00001a  4062              EORS     r2,r2,r4              ;491
00001c  1c49              ADDS     r1,r1,#1              ;489
00001e  b289              UXTH     r1,r1                 ;489
                  |L2.32|
000020  428b              CMP      r3,r1                 ;489
000022  dcf8              BGT      |L2.22|
000024  43d1              MVNS     r1,r2                 ;494
000026  b2c9              UXTB     r1,r1                 ;494
000028  1c40              ADDS     r0,r0,#1              ;497
00002a  5c28              LDRB     r0,[r5,r0]            ;497
00002c  4288              CMP      r0,r1                 ;497
00002e  d001              BEQ      |L2.52|
000030  2000              MOVS     r0,#0                 ;499
000032  bd30              POP      {r4,r5,pc}
                  |L2.52|
000034  2001              MOVS     r0,#1                 ;502
000036  bd30              POP      {r4,r5,pc}
;;;504    
                          ENDP


                          AREA ||i.UART_PROTOCOLIOT_CmdFrameProcess||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOLIOT_CmdFrameProcess PROC
;;;505    // UART命令帧缓冲区处理
;;;506    void UART_PROTOCOLIOT_CmdFrameProcess(UART_PROTOCOLIOT_CB* pCB)
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;507    {
000004  4604              MOV      r4,r0
;;;508    	UART_PROTOCOLIOT_CMD cmd = UART_PROTOCOLIOT_CMD_MAX;
;;;509    	UART_PROTOCOLIOT_RX_CMD_FRAME* pCmdFrame = NULL;
;;;510    	uint16 i;
;;;511    	TIME_E time;
;;;512    	
;;;513    	// 参数合法性检验
;;;514    	if(NULL == pCB)
000006  2c00              CMP      r4,#0
000008  d016              BEQ      |L3.56|
;;;515    	{
;;;516    		return;
;;;517    	}
;;;518    
;;;519    	// 命令帧缓冲区为空，退出
;;;520    	if(pCB->rx.head == pCB->rx.end)
00000a  f8b403d0          LDRH     r0,[r4,#0x3d0]
00000e  f8b413d2          LDRH     r1,[r4,#0x3d2]
000012  4288              CMP      r0,r1
000014  d010              BEQ      |L3.56|
;;;521    	{
;;;522    		return;
;;;523    	}
;;;524    
;;;525    	// 获取当前要处理的命令帧指针
;;;526    	pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.head];
000016  214d              MOVS     r1,#0x4d
000018  4341              MULS     r1,r0,r1
00001a  eb040141          ADD      r1,r4,r1,LSL #1
00001e  31ce              ADDS     r1,r1,#0xce
;;;527    	
;;;528    	// 命令头非法，退出
;;;529    	if(UART_PROTOCOLIOT_CMD_HEAD != pCmdFrame->buff[UART_PROTOCOLIOT_CMD_HEAD_INDEX])
;;;530    	{
;;;531    		// 删除命令帧
;;;532    		pCB->rx.head ++;
;;;533    		pCB->rx.head %= UART_PROTOCOLIOT_RX_QUEUE_SIZE;
000020  2505              MOVS     r5,#5
000022  788a              LDRB     r2,[r1,#2]            ;529
000024  2a55              CMP      r2,#0x55              ;529
000026  d009              BEQ      |L3.60|
000028  1c40              ADDS     r0,r0,#1              ;532
00002a  b280              UXTH     r0,r0                 ;532
00002c  fbb0f1f5          UDIV     r1,r0,r5
000030  fb050011          MLS      r0,r5,r1,r0
000034  f8a403d0          STRH     r0,[r4,#0x3d0]
                  |L3.56|
;;;534    		return;
;;;535    	}
;;;536    
;;;537    	// 命令头合法，则提取命令
;;;538    	cmd = (UART_PROTOCOLIOT_CMD)pCmdFrame->buff[UART_PROTOCOLIOT_CMD_CMD_INDEX];
;;;539    
;;;540    	// 执行命令帧
;;;541    	switch(cmd)
;;;542    	{
;;;543    		// 仪表获取IOT状态
;;;544    		case UART_PROTOCOLIOT_CMD_GET_STATE:
;;;545    			// GPS信号值
;;;546    			paramCB.runtime.iot.signalGps = pCmdFrame->buff[UART_PROTOCOLIOT_CMD_DATA1_INDEX];
;;;547    		
;;;548    			// GPS搜星数
;;;549    			paramCB.runtime.iot.starGps = pCmdFrame->buff[UART_PROTOCOLIOT_CMD_DATA2_INDEX];
;;;550    		
;;;551    			// 4G信号值
;;;552    			paramCB.runtime.iot.signal4G = pCmdFrame->buff[UART_PROTOCOLIOT_CMD_DATA3_INDEX];
;;;553    		
;;;554    			// 插卡状态
;;;555    			paramCB.runtime.iot.cardState = pCmdFrame->buff[UART_PROTOCOLIOT_CMD_DATA4_INDEX];
;;;556    		
;;;557    			// 设备状态
;;;558    			paramCB.runtime.iot.iotState = pCmdFrame->buff[UART_PROTOCOLIOT_CMD_DATA5_INDEX];
;;;559    			break;
;;;560    		
;;;561    		// 仪表获取IOT上报自身信息展示
;;;562    		case UART_PROTOCOLIOT_CMD_GET_INFO:
;;;563    			
;;;564    			// SIM卡号
;;;565    			for (i = 0;i < 11;i++)
;;;566    			{
;;;567    				paramCB.runtime.iot.simNumber[i] = pCmdFrame->buff[UART_PROTOCOLIOT_CMD_DATA1_INDEX + i];
;;;568    			}
;;;569    			
;;;570    			// IMEI号
;;;571    			for (i = 0;i < 13;i++)
;;;572    			{
;;;573    				paramCB.runtime.iot.imeiNumber[i] = pCmdFrame->buff[UART_PROTOCOLIOT_CMD_DATA1_INDEX + 11 + i];
;;;574    			}
;;;575    			
;;;576    			// IOT型号编码
;;;577    			for (i = 0;i < 3;i++)
;;;578    			{
;;;579    				paramCB.runtime.iot.iotModel[i] = pCmdFrame->buff[UART_PROTOCOLIOT_CMD_DATA1_INDEX + 11 + 13 + i];
;;;580    			}
;;;581    			
;;;582    			// IOT版本号
;;;583    			for (i = 0;i < 3;i++)
;;;584    			{
;;;585    				paramCB.runtime.iot.iotVersion[i] = pCmdFrame->buff[UART_PROTOCOLIOT_CMD_DATA1_INDEX + 11 + 13 + 3 + i];
;;;586    			}
;;;587    			break;
;;;588    		
;;;589    		// IOT获取状态数据命令
;;;590    		case UART_PROTOCOLIOT_CMD_GET_CONDATA:
;;;591    			
;;;592    			switch (pCmdFrame->buff[UART_PROTOCOLIOT_CMD_DATA1_INDEX])
;;;593    			{
;;;594    				case 1:
;;;595    					uartProtocolCBIOT.cmdStyle |= 0x01;
;;;596    					//UART_PROTOCOLIOT_SendCmdState1Data();
;;;597    					break;
;;;598    				
;;;599    				case 2:
;;;600    					uartProtocolCBIOT.cmdStyle |= 0x02;
;;;601    					//UART_PROTOCOLIOT_SendCmdState2Data();
;;;602    					break;
;;;603    				
;;;604    				case 3:
;;;605    					uartProtocolCBIOT.cmdStyle |= 0x04;
;;;606    					//UART_PROTOCOLIOT_SendCmdState3Data();
;;;607    					break;
;;;608    				
;;;609    				case 4:
;;;610    					uartProtocolCBIOT.cmdStyle |= 0x08;
;;;611    					//UART_PROTOCOLIOT_SendCmdState4Data();
;;;612    					break;
;;;613    				default:
;;;614    					break;
;;;615    			}
;;;616    			break;
;;;617    		
;;;618    		// HMI上报历史运动数据
;;;619    		case UART_PROTOCOLIOT_CMD_GET_HISTORY_DATA:
;;;620    			break;
;;;621    		
;;;622    		// 获取整车系统数据
;;;623    		case UART_PROTOCOLIOT_CMD_GET_BIKE_INFO:
;;;624    			uartProtocolCBIOT.cmdStyle |= 0x10;
;;;625    			//UART_PROTOCOLIOT_SendCmdSystemData();
;;;626    			break;
;;;627    		
;;;628    		// 给仪表授时命令s
;;;629    		case UART_PROTOCOLIOT_CMD_SET_TIME:
;;;630    			
;;;631    			time.year = 2000 + pCmdFrame->buff[UART_PROTOCOLIOT_CMD_DATA2_INDEX];
;;;632    			time.month = pCmdFrame->buff[UART_PROTOCOLIOT_CMD_DATA3_INDEX];
;;;633    			time.day = pCmdFrame->buff[UART_PROTOCOLIOT_CMD_DATA4_INDEX];
;;;634    			time.hour = pCmdFrame->buff[UART_PROTOCOLIOT_CMD_DATA5_INDEX];
;;;635    			time.minute = pCmdFrame->buff[UART_PROTOCOLIOT_CMD_DATA6_INDEX];
;;;636    			time.second = pCmdFrame->buff[UART_PROTOCOLIOT_CMD_DATA7_INDEX];
;;;637    			
;;;638    			// 设置时间
;;;639    			DS1302_SetDate(time.year, time.month, time.day, time.hour, time.minute, time.second);
;;;640    			break;
;;;641    		
;;;642    		// 控制及设置命令
;;;643    		case UART_PROTOCOLIOT_CMD_SET_PARAM:
;;;644    			uartProtocolCBIOT.cmdStyle |= 0x20;
;;;645    			
;;;646    			uartProtocolCBIOT.setParamCmd = pCmdFrame->buff[UART_PROTOCOLIOT_CMD_DATA1_INDEX];
;;;647    			
;;;648    			// 仪表控制命令
;;;649    			UART_PROTOCOLIOT_ControlParam(pCmdFrame->buff[UART_PROTOCOLIOT_CMD_DATA1_INDEX], &pCmdFrame->buff[UART_PROTOCOLIOT_CMD_DATA2_INDEX]);
;;;650    			break;
;;;651    		
;;;652    		// 远程诊断命令
;;;653    		case UART_PROTOCOLIOT_CMD_DIAGNOSIS:
;;;654    			uartProtocolCBIOT.cmdStyle |= 0x40;
;;;655    			break;
;;;656    		
;;;657    		default:
;;;658    			break;
;;;659    	}
;;;660    
;;;661    	// 启动UART总线通讯超时判断
;;;662    	UART_PROTOCOLIOT_StartTimeoutCheckTask();
;;;663    	
;;;664    	// 删除命令帧
;;;665    	pCB->rx.head ++;
;;;666    	pCB->rx.head %= UART_PROTOCOLIOT_RX_QUEUE_SIZE;
;;;667    }
000038  e8bd81ff          POP      {r0-r8,pc}
                  |L3.60|
00003c  790a              LDRB     r2,[r1,#4]            ;538
00003e  4b53              LDR      r3,|L3.396|
000040  2a05              CMP      r2,#5                 ;541
000042  f8b306ee          LDRH     r0,[r3,#0x6ee]        ;595
000046  d064              BEQ      |L3.274|
000048  dc07              BGT      |L3.90|
00004a  4e51              LDR      r6,|L3.400|
00004c  2a01              CMP      r2,#1                 ;541
00004e  d00b              BEQ      |L3.104|
000050  2a02              CMP      r2,#2                 ;541
000052  d016              BEQ      |L3.130|
000054  2a03              CMP      r2,#3                 ;541
000056  d113              BNE      |L3.128|
000058  e03d              B        |L3.214|
                  |L3.90|
00005a  2a06              CMP      r2,#6                 ;541
00005c  d05e              BEQ      |L3.284|
00005e  2a07              CMP      r2,#7                 ;541
000060  d077              BEQ      |L3.338|
000062  2a30              CMP      r2,#0x30              ;541
000064  d10c              BNE      |L3.128|
000066  e080              B        |L3.362|
                  |L3.104|
000068  f50676be          ADD      r6,r6,#0x17c          ;546
00006c  7988              LDRB     r0,[r1,#6]            ;546
00006e  7030              STRB     r0,[r6,#0]            ;546
000070  79c8              LDRB     r0,[r1,#7]            ;549
000072  7070              STRB     r0,[r6,#1]            ;549
000074  7a08              LDRB     r0,[r1,#8]            ;552
000076  70b0              STRB     r0,[r6,#2]            ;552
000078  7a48              LDRB     r0,[r1,#9]            ;555
00007a  70f0              STRB     r0,[r6,#3]            ;555
00007c  7a88              LDRB     r0,[r1,#0xa]          ;558
00007e  7130              STRB     r0,[r6,#4]            ;558
                  |L3.128|
000080  e077              B        |L3.370|
                  |L3.130|
000082  2200              MOVS     r2,#0                 ;565
                  |L3.132|
000084  1888              ADDS     r0,r1,r2              ;567
000086  18b3              ADDS     r3,r6,r2              ;567
000088  7980              LDRB     r0,[r0,#6]            ;567
00008a  f8830181          STRB     r0,[r3,#0x181]        ;567
00008e  1c52              ADDS     r2,r2,#1              ;565
000090  b292              UXTH     r2,r2                 ;565
000092  2a0b              CMP      r2,#0xb               ;565
000094  d3f6              BCC      |L3.132|
000096  2200              MOVS     r2,#0                 ;571
                  |L3.152|
000098  1888              ADDS     r0,r1,r2              ;573
00009a  18b3              ADDS     r3,r6,r2              ;573
00009c  7c40              LDRB     r0,[r0,#0x11]         ;573
00009e  f883018c          STRB     r0,[r3,#0x18c]        ;573
0000a2  1c52              ADDS     r2,r2,#1              ;571
0000a4  b292              UXTH     r2,r2                 ;571
0000a6  2a0d              CMP      r2,#0xd               ;571
0000a8  d3f6              BCC      |L3.152|
0000aa  2200              MOVS     r2,#0                 ;577
                  |L3.172|
0000ac  1888              ADDS     r0,r1,r2              ;579
0000ae  18b3              ADDS     r3,r6,r2              ;579
0000b0  7f80              LDRB     r0,[r0,#0x1e]         ;579
0000b2  f8830199          STRB     r0,[r3,#0x199]        ;579
0000b6  1c52              ADDS     r2,r2,#1              ;577
0000b8  b292              UXTH     r2,r2                 ;577
0000ba  2a03              CMP      r2,#3                 ;577
0000bc  d3f6              BCC      |L3.172|
0000be  2200              MOVS     r2,#0                 ;583
                  |L3.192|
0000c0  1888              ADDS     r0,r1,r2              ;585
0000c2  18b3              ADDS     r3,r6,r2              ;585
0000c4  f8900021          LDRB     r0,[r0,#0x21]         ;585
0000c8  f883019c          STRB     r0,[r3,#0x19c]        ;585
0000cc  1c52              ADDS     r2,r2,#1              ;583
0000ce  b292              UXTH     r2,r2                 ;583
0000d0  2a03              CMP      r2,#3                 ;583
0000d2  d3f5              BCC      |L3.192|
0000d4  e04d              B        |L3.370|
                  |L3.214|
0000d6  7989              LDRB     r1,[r1,#6]            ;592
0000d8  2901              CMP      r1,#1                 ;592
0000da  d006              BEQ      |L3.234|
0000dc  2902              CMP      r1,#2                 ;592
0000de  d009              BEQ      |L3.244|
0000e0  2903              CMP      r1,#3                 ;592
0000e2  d00c              BEQ      |L3.254|
0000e4  2904              CMP      r1,#4                 ;592
0000e6  d144              BNE      |L3.370|
0000e8  e00e              B        |L3.264|
                  |L3.234|
0000ea  f0400001          ORR      r0,r0,#1              ;595
0000ee  f8a306ee          STRH     r0,[r3,#0x6ee]        ;595
0000f2  e03e              B        |L3.370|
                  |L3.244|
0000f4  f0400002          ORR      r0,r0,#2              ;600
0000f8  f8a306ee          STRH     r0,[r3,#0x6ee]        ;600
0000fc  e039              B        |L3.370|
                  |L3.254|
0000fe  f0400004          ORR      r0,r0,#4              ;605
000102  f8a306ee          STRH     r0,[r3,#0x6ee]        ;605
000106  e034              B        |L3.370|
                  |L3.264|
000108  f0400008          ORR      r0,r0,#8              ;610
00010c  f8a306ee          STRH     r0,[r3,#0x6ee]        ;610
000110  e02f              B        |L3.370|
                  |L3.274|
000112  f0400010          ORR      r0,r0,#0x10           ;624
000116  f8a306ee          STRH     r0,[r3,#0x6ee]        ;624
00011a  e02a              B        |L3.370|
                  |L3.284|
00011c  79c8              LDRB     r0,[r1,#7]            ;631
00011e  f50060fa          ADD      r0,r0,#0x7d0          ;631
000122  f8ad0008          STRH     r0,[sp,#8]            ;631
000126  7a0f              LDRB     r7,[r1,#8]            ;632
000128  f88d700a          STRB     r7,[sp,#0xa]          ;632
00012c  7a4a              LDRB     r2,[r1,#9]            ;633
00012e  f88d200b          STRB     r2,[sp,#0xb]          ;633
000132  7a8b              LDRB     r3,[r1,#0xa]          ;634
000134  f88d300c          STRB     r3,[sp,#0xc]          ;634
000138  7ace              LDRB     r6,[r1,#0xb]          ;635
00013a  f88d600d          STRB     r6,[sp,#0xd]          ;635
00013e  7b09              LDRB     r1,[r1,#0xc]          ;636
000140  f88d100e          STRB     r1,[sp,#0xe]          ;636
000144  e9cd6100          STRD     r6,r1,[sp,#0]         ;639
000148  4639              MOV      r1,r7                 ;639
00014a  f7fffffe          BL       DS1302_SetDate
00014e  e010              B        |L3.370|
000150  e7ff              B        |L3.338|
                  |L3.338|
000152  f0400020          ORR      r0,r0,#0x20           ;644
000156  f8a306ee          STRH     r0,[r3,#0x6ee]        ;644
00015a  7988              LDRB     r0,[r1,#6]            ;646
00015c  f88306f0          STRB     r0,[r3,#0x6f0]        ;646
000160  7988              LDRB     r0,[r1,#6]            ;649
000162  1dc9              ADDS     r1,r1,#7              ;649
000164  f7fffffe          BL       UART_PROTOCOLIOT_ControlParam
000168  e003              B        |L3.370|
                  |L3.362|
00016a  f0400040          ORR      r0,r0,#0x40           ;654
00016e  f8a306ee          STRH     r0,[r3,#0x6ee]        ;654
                  |L3.370|
000172  f7fffffe          BL       UART_PROTOCOLIOT_StartTimeoutCheckTask
000176  f8b403d0          LDRH     r0,[r4,#0x3d0]        ;665
00017a  1c40              ADDS     r0,r0,#1              ;665
00017c  b280              UXTH     r0,r0                 ;665
00017e  fbb0f1f5          UDIV     r1,r0,r5              ;666
000182  fb050011          MLS      r0,r5,r1,r0           ;666
000186  f8a403d0          STRH     r0,[r4,#0x3d0]        ;666
00018a  e755              B        |L3.56|
;;;668    
                          ENDP

                  |L3.396|
                          DCD      ||.bss||
                  |L3.400|
                          DCD      paramCB

                          AREA ||i.UART_PROTOCOLIOT_ConfirmTempCmdFrameBuff||, CODE, READONLY, ALIGN=1

                  UART_PROTOCOLIOT_ConfirmTempCmdFrameBuff PROC
;;;258    // 将临时缓冲区添加到命令帧缓冲区中，其本质操作是承认临时缓冲区数据有效
;;;259    BOOL UART_PROTOCOLIOT_ConfirmTempCmdFrameBuff(UART_PROTOCOLIOT_CB* pCB)
000000  2800              CMP      r0,#0
;;;260    {
000002  d01a              BEQ      |L4.58|
;;;261    	UART_PROTOCOLIOT_RX_CMD_FRAME* pCmdFrame = NULL;
;;;262    	
;;;263    	// 参数合法性检验
;;;264    	if(NULL == pCB)
;;;265    	{
;;;266    		return FALSE;
;;;267    	}
;;;268    
;;;269    	// 临时缓冲区为空，不予添加
;;;270    	pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.end];
000004  f8b013d2          LDRH     r1,[r0,#0x3d2]
000008  224d              MOVS     r2,#0x4d
00000a  434a              MULS     r2,r1,r2
00000c  eb000242          ADD      r2,r0,r2,LSL #1
;;;271    	if(0 == pCmdFrame->length)
000010  f8b22166          LDRH     r2,[r2,#0x166]
000014  b19a              CBZ      r2,|L4.62|
;;;272    	{
;;;273    		return FALSE;
;;;274    	}
;;;275    
;;;276    	// 添加
;;;277    	pCB->rx.end ++;
000016  1c49              ADDS     r1,r1,#1
000018  b289              UXTH     r1,r1
;;;278    	pCB->rx.end %= UART_PROTOCOLIOT_RX_QUEUE_SIZE;
00001a  2205              MOVS     r2,#5
00001c  fbb1f3f2          UDIV     r3,r1,r2
000020  fb021113          MLS      r1,r2,r3,r1
000024  f8a013d2          STRH     r1,[r0,#0x3d2]
;;;279    	pCB->rx.cmdQueue[pCB->rx.end].length = 0;	// 该行的作用是将新的添加位置有效数据个数清零，以便将这个位置当做临时帧缓冲区
000028  2200              MOVS     r2,#0
00002a  234d              MOVS     r3,#0x4d
00002c  4359              MULS     r1,r3,r1
00002e  eb000041          ADD      r0,r0,r1,LSL #1
000032  f8a02166          STRH     r2,[r0,#0x166]
;;;280    	
;;;281    	return TRUE;
000036  2001              MOVS     r0,#1
;;;282    }
000038  4770              BX       lr
                  |L4.58|
00003a  2000              MOVS     r0,#0                 ;266
00003c  4770              BX       lr
                  |L4.62|
00003e  2000              MOVS     r0,#0                 ;273
000040  4770              BX       lr
;;;283    
                          ENDP


                          AREA ||i.UART_PROTOCOLIOT_ControlParam||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOLIOT_ControlParam PROC
;;;1252   // 仪表控制命令回复
;;;1253   void UART_PROTOCOLIOT_ControlParam(uint8 controlCmd, uint8 *data)
000000  b570              PUSH     {r4-r6,lr}
;;;1254   {	
000002  460c              MOV      r4,r1
000004  2601              MOVS     r6,#1
;;;1255   	uint8 val1,val2;
;;;1256   
;;;1257   	switch (controlCmd)
;;;1258   	{
;;;1259   		case IOT_LIGHT:
;;;1260   			if(0x00 == data[0])
;;;1261   			{
;;;1262   				// 关灯
;;;1263   				PARAM_SetLightSwitch(FALSE);
000006  4d58              LDR      r5,|L5.360|
000008  280c              CMP      r0,#0xc               ;1257
00000a  d265              BCS      |L5.216|
00000c  e8dff000          TBB      [pc,r0]               ;1257
000010  6406303a          DCB      0x64,0x06,0x30,0x3a
000014  454d6479          DCB      0x45,0x4d,0x64,0x79
000018  848c989c          DCB      0x84,0x8c,0x98,0x9c
00001c  7820              LDRB     r0,[r4,#0]            ;1260
00001e  b190              CBZ      r0,|L5.70|
;;;1264   
;;;1265   				// 大灯关闭后，恢复之前的背光等级
;;;1266   				BACK_LIGHT_Start( (BACK_LIGHT_LEVEL_E)PARAM_GetBrightness() );
;;;1267   			}
;;;1268   			else
;;;1269   			{
;;;1270   				// 开灯
;;;1271   				PARAM_SetLightSwitch(TRUE);	
000020  f8856202          STRB     r6,[r5,#0x202]
000024  2001              MOVS     r0,#1
000026  f7fffffe          BL       UART_PROTOCOL_SetTxAtOnceRequest
00002a  2001              MOVS     r0,#1
00002c  f7fffffe          BL       UART_PROTOCOL1_SetTxAtOnceRequest
000030  2001              MOVS     r0,#1
000032  f7fffffe          BL       UART_PROTOCOL2_SetTxAtOnceRequest
000036  2001              MOVS     r0,#1
000038  f7fffffe          BL       UART_PROTOCOL3_SetTxAtOnceRequest
;;;1272   
;;;1273   				// 大灯开启后，屏幕亮度变为最暗
;;;1274   				BACK_LIGHT_Start(BACK_LIGHT_LEVEL_20_100);
00003c  e8bd4070          POP      {r4-r6,lr}
000040  2001              MOVS     r0,#1
000042  f7ffbffe          B.W      BACK_LIGHT_Start
                  |L5.70|
000046  2000              MOVS     r0,#0                 ;1263
000048  f8850202          STRB     r0,[r5,#0x202]        ;1263
00004c  2001              MOVS     r0,#1                 ;1263
00004e  f7fffffe          BL       UART_PROTOCOL_SetTxAtOnceRequest
000052  2001              MOVS     r0,#1                 ;1263
000054  f7fffffe          BL       UART_PROTOCOL1_SetTxAtOnceRequest
000058  2001              MOVS     r0,#1                 ;1263
00005a  f7fffffe          BL       UART_PROTOCOL2_SetTxAtOnceRequest
00005e  2001              MOVS     r0,#1                 ;1263
000060  f7fffffe          BL       UART_PROTOCOL3_SetTxAtOnceRequest
000064  f8950320          LDRB     r0,[r5,#0x320]        ;1266  ; paramCB
000068  e8bd4070          POP      {r4-r6,lr}            ;1266
00006c  f7ffbffe          B.W      BACK_LIGHT_Start
;;;1275   			}
;;;1276   			val1 = PARAM_GetLightSwitch();
;;;1277   			break;
;;;1278   		
;;;1279   		case IOT_AUTO_SHUTDOWN_TIME:
;;;1280   			PARAM_SetPowerOffTime(data[0]);
000070  7820              LDRB     r0,[r4,#0]
000072  f8850321          STRB     r0,[r5,#0x321]
;;;1281   
;;;1282   //			TIMER_KillTask(TIMER_ID_AUTO_POWER_OFF);
;;;1283   		
;;;1284   			// 重置自动关机任务
;;;1285   			STATE_ResetAutoPowerOffControl();
000076  f7fffffe          BL       STATE_ResetAutoPowerOffControl
;;;1286   		
;;;1287   			// NVM更新，立即写入
;;;1288   			NVM_SetDirtyFlag(TRUE);
00007a  e8bd4070          POP      {r4-r6,lr}
00007e  2001              MOVS     r0,#1
000080  f7ffbffe          B.W      NVM_SetDirtyFlag
;;;1289   			val1 = PARAM_GetPowerOffTime();
;;;1290   			break;
;;;1291   		
;;;1292   		case IOT_SPEED_LIMIT:
;;;1293   			PARAM_SetSpeedLimit((uint16)data[0] * 10);
000084  7820              LDRB     r0,[r4,#0]
000086  eb000080          ADD      r0,r0,r0,LSL #2
00008a  0040              LSLS     r0,r0,#1
00008c  f8a50334          STRH     r0,[r5,#0x334]
;;;1294   
;;;1295   			// NVM更新，立即写入
;;;1296   			NVM_SetDirtyFlag(TRUE);
000090  e8bd4070          POP      {r4-r6,lr}
000094  2001              MOVS     r0,#1
000096  f7ffbffe          B.W      NVM_SetDirtyFlag
;;;1297   			val1 = data[0];
;;;1298   			break;
;;;1299   		
;;;1300   		case IOT_UNIT:
;;;1301   			PARAM_SetUnit((UNIT_E)data[0]);
00009a  7820              LDRB     r0,[r4,#0]
00009c  f8850319          STRB     r0,[r5,#0x319]
;;;1302   
;;;1303   			// NVM更新，立即写入
;;;1304   			NVM_SetDirtyFlag(TRUE);
0000a0  e8bd4070          POP      {r4-r6,lr}
0000a4  2001              MOVS     r0,#1
0000a6  f7ffbffe          B.W      NVM_SetDirtyFlag
;;;1305   			val1 = data[0];
;;;1306   			break;
;;;1307   		
;;;1308   		case IOT_ASSIST:
;;;1309   			
;;;1310   			// 获取当前助力值
;;;1311   			val1 = (uint8)paramCB.runtime.assist;
0000aa  f8950228          LDRB     r0,[r5,#0x228]  ; paramCB
;;;1312   		
;;;1313   			if(0 == data[0])
0000ae  7821              LDRB     r1,[r4,#0]
0000b0  b199              CBZ      r1,|L5.218|
;;;1314   			{
;;;1315   				if(val1 > 0)
;;;1316   				{
;;;1317   					val1--;
;;;1318   					PARAM_SetAssistLevel((ASSIST_ID_E)val1);
;;;1319   				}
;;;1320   			}
;;;1321   			else
;;;1322   			{
;;;1323   				if(val1 < 5)
0000b2  2805              CMP      r0,#5
0000b4  d210              BCS      |L5.216|
;;;1324   				{
;;;1325   					val1++;
0000b6  1c40              ADDS     r0,r0,#1
;;;1326   					PARAM_SetAssistLevel((ASSIST_ID_E)val1);
0000b8  f8850228          STRB     r0,[r5,#0x228]
0000bc  2001              MOVS     r0,#1
0000be  f7fffffe          BL       UART_PROTOCOL_SetTxAtOnceRequest
0000c2  2001              MOVS     r0,#1
0000c4  f7fffffe          BL       UART_PROTOCOL1_SetTxAtOnceRequest
0000c8  2001              MOVS     r0,#1
0000ca  f7fffffe          BL       UART_PROTOCOL2_SetTxAtOnceRequest
0000ce  2001              MOVS     r0,#1
0000d0  f7fffffe          BL       UART_PROTOCOL3_SetTxAtOnceRequest
0000d4  f8856255          STRB     r6,[r5,#0x255]
                  |L5.216|
;;;1327   				}
;;;1328   			}
;;;1329   			val1 = (uint8)paramCB.runtime.assist;
;;;1330   			break;
;;;1331   		
;;;1332   		case IOT_LOCK:
;;;1333   
;;;1334   			
;;;1335   			val1 = 0;
;;;1336   			val2 = 0;
;;;1337   			break;
;;;1338   
;;;1339   		case IOT_BACKLIGHT:
;;;1340   			
;;;1341   			// 更改背光亮度
;;;1342   			BACK_LIGHT_Start((BACK_LIGHT_LEVEL_E)data[0]);
;;;1343   			PARAM_SetBrightness((BACK_LIGHT_LEVEL_E)data[0]);
;;;1344   			
;;;1345   			// NVM更新，立即写入
;;;1346   			NVM_SetDirtyFlag(TRUE);
;;;1347   
;;;1348   			val1 = data[0];
;;;1349   			break;
;;;1350   
;;;1351   		case IOT_START_STYLE:
;;;1352   
;;;1353   			PARAM_SetZeroStartOrNot((BOOL)data[0]);
;;;1354   			
;;;1355   			// NVM更新，立即写入
;;;1356   			NVM_SetDirtyFlag(TRUE);
;;;1357   
;;;1358   			val1 = data[0];
;;;1359   			break;
;;;1360   
;;;1361   		case IOT_CURISE:
;;;1362   
;;;1363   			PARAM_SetCruiseEnableSwitch((BOOL)!data[0]);
;;;1364   			
;;;1365   			// NVM更新，立即写入
;;;1366   			NVM_SetDirtyFlag(TRUE);
;;;1367   
;;;1368   			val1 = data[0];
;;;1369   			break;
;;;1370   
;;;1371   		case IOT_FACTORY:
;;;1372   
;;;1373   			// 恢复出厂数据
;;;1374   			NVM_Load_FactoryReset();
;;;1375   		
;;;1376   			val1 = data[0];
;;;1377   			break;
;;;1378   
;;;1379   		case IOT_POWER_ON_OFF:
;;;1380   
;;;1381   			PARAM_SetPowerState((BOOL)data[0]);
;;;1382   			
;;;1383   			// 关机
;;;1384   			if(0x00 == data[0])
;;;1385   			{
;;;1386   				STATE_EnterState(STATE_SHOW_POWER_OFF);	
;;;1387   			}
;;;1388   			// 开机
;;;1389   			else
;;;1390   			{
;;;1391   				STATE_EnterState(STATE_ENTRY);
;;;1392   
;;;1393   				// 设置电源键释放标识
;;;1394   //				TIMER_AddTask(TIMER_ID_STARTING_UP,
;;;1395   //								1500,
;;;1396   //								STATE_PowerOnKeyUpFlag,
;;;1397   //								TRUE,
;;;1398   //								1,
;;;1399   //								ACTION_MODE_DO_AT_ONCE);
;;;1400   			}
;;;1401   			val1 = data[0];
;;;1402   			break;
;;;1403   
;;;1404   		case IOT_BRAKE:
;;;1405   			break;
;;;1406   
;;;1407   		case IOT_POWER_PASSWORD:
;;;1408   			break;
;;;1409   			
;;;1410   		default:
;;;1411   			break;
;;;1412   	}	
;;;1413   }
0000d8  bd70              POP      {r4-r6,pc}
                  |L5.218|
0000da  2800              CMP      r0,#0                 ;1315
0000dc  d0fc              BEQ      |L5.216|
0000de  1e40              SUBS     r0,r0,#1              ;1317
0000e0  f8850228          STRB     r0,[r5,#0x228]        ;1318
0000e4  2001              MOVS     r0,#1                 ;1318
0000e6  f7fffffe          BL       UART_PROTOCOL_SetTxAtOnceRequest
0000ea  2001              MOVS     r0,#1                 ;1318
0000ec  f7fffffe          BL       UART_PROTOCOL1_SetTxAtOnceRequest
0000f0  2001              MOVS     r0,#1                 ;1318
0000f2  f7fffffe          BL       UART_PROTOCOL2_SetTxAtOnceRequest
0000f6  2001              MOVS     r0,#1                 ;1318
0000f8  f7fffffe          BL       UART_PROTOCOL3_SetTxAtOnceRequest
0000fc  f8856255          STRB     r6,[r5,#0x255]        ;1318
000100  bd70              POP      {r4-r6,pc}
000102  7820              LDRB     r0,[r4,#0]            ;1342
000104  f7fffffe          BL       BACK_LIGHT_Start
000108  7820              LDRB     r0,[r4,#0]            ;1343
00010a  f8850320          STRB     r0,[r5,#0x320]        ;1343
00010e  e8bd4070          POP      {r4-r6,lr}            ;1346
000112  2001              MOVS     r0,#1                 ;1346
000114  f7ffbffe          B.W      NVM_SetDirtyFlag
000118  7820              LDRB     r0,[r4,#0]            ;1353
00011a  f8850305          STRB     r0,[r5,#0x305]        ;1353
00011e  e8bd4070          POP      {r4-r6,lr}            ;1356
000122  2001              MOVS     r0,#1                 ;1356
000124  f7ffbffe          B.W      NVM_SetDirtyFlag
000128  7820              LDRB     r0,[r4,#0]            ;1363
00012a  b138              CBZ      r0,|L5.316|
00012c  2000              MOVS     r0,#0                 ;1363
                  |L5.302|
00012e  f8850316          STRB     r0,[r5,#0x316]        ;1363
000132  e8bd4070          POP      {r4-r6,lr}            ;1366
000136  2001              MOVS     r0,#1                 ;1366
000138  f7ffbffe          B.W      NVM_SetDirtyFlag
                  |L5.316|
00013c  2001              MOVS     r0,#1                 ;1363
00013e  e7f6              B        |L5.302|
000140  e8bd4070          POP      {r4-r6,lr}            ;1374
000144  f7ffbffe          B.W      NVM_Load_FactoryReset
000148  7820              LDRB     r0,[r4,#0]            ;1381
00014a  f8850216          STRB     r0,[r5,#0x216]        ;1381
00014e  7820              LDRB     r0,[r4,#0]            ;1384
000150  b120              CBZ      r0,|L5.348|
000152  e8bd4070          POP      {r4-r6,lr}            ;1391
000156  2001              MOVS     r0,#1                 ;1391
000158  f7ffbffe          B.W      STATE_EnterState
                  |L5.348|
00015c  e8bd4070          POP      {r4-r6,lr}            ;1386
000160  2007              MOVS     r0,#7                 ;1386
000162  f7ffbffe          B.W      STATE_EnterState
;;;1414   
                          ENDP

000166  0000              DCW      0x0000
                  |L5.360|
                          DCD      paramCB

                          AREA ||i.UART_PROTOCOLIOT_DataStructInit||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOLIOT_DataStructInit PROC
;;;193    // 数据结构初始化
;;;194    void UART_PROTOCOLIOT_DataStructInit(UART_PROTOCOLIOT_CB* pCB)
000000  2800              CMP      r0,#0
;;;195    {
000002  d02a              BEQ      |L6.90|
;;;196    	uint16 i;
;;;197    	
;;;198    	// 参数合法性检验
;;;199    	if (NULL == pCB)
;;;200    	{
;;;201    		return;
;;;202    	}
;;;203    
;;;204    	pCB->tx.txBusy = FALSE;
000004  2200              MOVS     r2,#0
000006  f88026dc          STRB     r2,[r0,#0x6dc]
;;;205    	pCB->tx.index = 0;
00000a  f8a026da          STRH     r2,[r0,#0x6da]
;;;206    	pCB->tx.head = 0;
00000e  f8a026d6          STRH     r2,[r0,#0x6d6]
;;;207    	pCB->tx.end = 0;
000012  f8a026d8          STRH     r2,[r0,#0x6d8]
;;;208    	for(i = 0; i < UART_PROTOCOLIOT_TX_QUEUE_SIZE; i++)
000016  2100              MOVS     r1,#0
                  |L6.24|
;;;209    	{
;;;210    		pCB->tx.cmdQueue[i].length = 0;
000018  234d              MOVS     r3,#0x4d
00001a  434b              MULS     r3,r1,r3
00001c  eb000343          ADD      r3,r0,r3,LSL #1
000020  f8a3246c          STRH     r2,[r3,#0x46c]
000024  1c49              ADDS     r1,r1,#1              ;208
000026  b289              UXTH     r1,r1                 ;208
000028  2905              CMP      r1,#5                 ;208
00002a  d3f5              BCC      |L6.24|
;;;211    	}
;;;212    
;;;213    	pCB->rxFIFO.head = 0;
00002c  f8202fc8          STRH     r2,[r0,#0xc8]!
;;;214    	pCB->rxFIFO.end = 0;
000030  8042              STRH     r2,[r0,#2]
;;;215    	pCB->rxFIFO.currentProcessIndex = 0;
000032  8082              STRH     r2,[r0,#4]
;;;216    
;;;217    	pCB->rx.head = 0;
000034  f8a02308          STRH     r2,[r0,#0x308]
;;;218    	pCB->rx.end  = 0;
000038  f8a0230a          STRH     r2,[r0,#0x30a]
00003c  38c8              SUBS     r0,r0,#0xc8
;;;219    	for(i=0; i<UART_PROTOCOLIOT_RX_QUEUE_SIZE; i++)
00003e  2100              MOVS     r1,#0
                  |L6.64|
;;;220    	{
;;;221    		pCB->rx.cmdQueue[i].length = 0;
000040  234d              MOVS     r3,#0x4d
000042  434b              MULS     r3,r1,r3
000044  eb000343          ADD      r3,r0,r3,LSL #1
000048  f8a32166          STRH     r2,[r3,#0x166]
00004c  1c49              ADDS     r1,r1,#1              ;219
00004e  b289              UXTH     r1,r1                 ;219
000050  2905              CMP      r1,#5                 ;219
000052  d3f5              BCC      |L6.64|
;;;222    	}
;;;223    	
;;;224    	uartProtocolCBIOT.cmdStyle = 0;
000054  4801              LDR      r0,|L6.92|
000056  f8a026ee          STRH     r2,[r0,#0x6ee]
                  |L6.90|
;;;225    }
00005a  4770              BX       lr
;;;226    
                          ENDP

                  |L6.92|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOLIOT_Init||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOLIOT_Init PROC
;;;99     // 协议初始化
;;;100    void UART_PROTOCOLIOT_Init(void)
000000  b500              PUSH     {lr}
;;;101    {
;;;102    	// 协议层数据结构初始化
;;;103    	UART_PROTOCOLIOT_DataStructInit(&uartProtocolCBIOT);
000002  4804              LDR      r0,|L7.20|
000004  f7fffffe          BL       UART_PROTOCOLIOT_DataStructInit
;;;104    
;;;105    //	// 向驱动层注册数据接收接口
;;;106    //	UART_DRIVE_RegisterDataSendService(UART_PROTOCOLIOT_MacProcess);
;;;107    
;;;108    	// 向驱动层注册数据发送接口
;;;109    	UART_PROTOCOLIOT_RegisterDataSendService(UART_DRIVE_AddTxArray);
000008  4803              LDR      r0,|L7.24|
00000a  f85deb04          POP      {lr}
00000e  f7ffbffe          B.W      UART_PROTOCOLIOT_RegisterDataSendService
;;;110    }
;;;111    
                          ENDP

000012  0000              DCW      0x0000
                  |L7.20|
                          DCD      ||.bss||
                  |L7.24|
                          DCD      UART_DRIVE_AddTxArray

                          AREA ||i.UART_PROTOCOLIOT_MacProcess||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOLIOT_MacProcess PROC
;;;227    // UART报文接收处理函数(注意根据具体模块修改)
;;;228    void UART_PROTOCOLIOT_MacProcess(uint16 standarID, uint8* pData, uint16 length)
000000  b570              PUSH     {r4-r6,lr}
;;;229    {
;;;230    	uint16 end = uartProtocolCBIOT.rxFIFO.end;
000002  480d              LDR      r0,|L8.56|
000004  f8b020ca          LDRH     r2,[r0,#0xca]  ; uartProtocolCBIOT
;;;231    	uint16 head = uartProtocolCBIOT.rxFIFO.head;
000008  f8b040c8          LDRH     r4,[r0,#0xc8]  ; uartProtocolCBIOT
;;;232    	uint8 rxdata = 0x00;
;;;233    	
;;;234    	// 接收数据
;;;235    	rxdata = *pData;
00000c  780d              LDRB     r5,[r1,#0]
;;;236    
;;;237    	// 一级缓冲区已满，不予接收
;;;238    	if((end + 1)%UART_PROTOCOLIOT_RX_FIFO_SIZE == head)
00000e  1c53              ADDS     r3,r2,#1
000010  21c8              MOVS     r1,#0xc8
000012  fbb3f6f1          UDIV     r6,r3,r1
000016  fb013316          MLS      r3,r1,r6,r3
00001a  42a3              CMP      r3,r4
00001c  d00a              BEQ      |L8.52|
;;;239    	{
;;;240    		return;
;;;241    	}
;;;242    	// 一级缓冲区未满，接收 
;;;243    	else
;;;244    	{
;;;245    		// 将接收到的数据放到临时缓冲区中
;;;246    		uartProtocolCBIOT.rxFIFO.buff[end] = rxdata;
00001e  5485              STRB     r5,[r0,r2]
;;;247    		uartProtocolCBIOT.rxFIFO.end ++;
000020  f8302fca          LDRH     r2,[r0,#0xca]!  ; uartProtocolCBIOT
000024  1c52              ADDS     r2,r2,#1
000026  8002              STRH     r2,[r0,#0]
;;;248    		uartProtocolCBIOT.rxFIFO.end %= UART_PROTOCOLIOT_RX_FIFO_SIZE;
000028  8802              LDRH     r2,[r0,#0]  ; uartProtocolCBIOT
00002a  fbb2f3f1          UDIV     r3,r2,r1
00002e  fb012113          MLS      r1,r1,r3,r2
000032  8001              STRH     r1,[r0,#0]
                  |L8.52|
;;;249    	}	
;;;250    }
000034  bd70              POP      {r4-r6,pc}
;;;251    
                          ENDP

000036  0000              DCW      0x0000
                  |L8.56|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOLIOT_Process||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOLIOT_Process PROC
;;;112    // UART协议层过程处理
;;;113    void UART_PROTOCOLIOT_Process(void)
000000  b510              PUSH     {r4,lr}
;;;114    {
;;;115    	// UART接收FIFO缓冲区处理
;;;116    	UART_PROTOCOLIOT_RxFIFOProcess(&uartProtocolCBIOT);
000002  4805              LDR      r0,|L9.24|
000004  f7fffffe          BL       UART_PROTOCOLIOT_RxFIFOProcess
;;;117    
;;;118    	// UART接收命令缓冲区处理
;;;119    	UART_PROTOCOLIOT_CmdFrameProcess(&uartProtocolCBIOT);
000008  4803              LDR      r0,|L9.24|
00000a  f7fffffe          BL       UART_PROTOCOLIOT_CmdFrameProcess
;;;120    	
;;;121    	// UART协议层发送处理过程
;;;122    	UART_PROTOCOLIOT_TxStateProcess();
00000e  e8bd4010          POP      {r4,lr}
000012  f7ffbffe          B.W      UART_PROTOCOLIOT_TxStateProcess
;;;123    }
;;;124    
                          ENDP

000016  0000              DCW      0x0000
                  |L9.24|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOLIOT_RegisterDataSendService||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOLIOT_RegisterDataSendService PROC
;;;252    // UART协议层向驱动层注册数据发送接口
;;;253    void UART_PROTOCOLIOT_RegisterDataSendService(BOOL (*service)(uint16 id, uint8 *pData, uint16 length))
000000  4901              LDR      r1,|L10.8|
;;;254    {		
;;;255    	uartProtocolCBIOT.sendDataThrowService = service;
000002  f8c106e0          STR      r0,[r1,#0x6e0]  ; uartProtocolCBIOT
;;;256    }
000006  4770              BX       lr
;;;257    
                          ENDP

                  |L10.8|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOLIOT_RxFIFOProcess||, CODE, READONLY, ALIGN=1

                  UART_PROTOCOLIOT_RxFIFOProcess PROC
;;;317    // 一级接收缓冲区处理，从一级接收缓冲区中取出一个字节添加到命令帧缓冲区中
;;;318    void UART_PROTOCOLIOT_RxFIFOProcess(UART_PROTOCOLIOT_CB* pCB)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;319    {
000004  4604              MOV      r4,r0
;;;320    	uint16 end = pCB->rxFIFO.end;
000006  f8b410ca          LDRH     r1,[r4,#0xca]
;;;321    	uint16 head = pCB->rxFIFO.head;
00000a  f8b400c8          LDRH     r0,[r4,#0xc8]
;;;322    	UART_PROTOCOLIOT_RX_CMD_FRAME* pCmdFrame = NULL;
;;;323    	uint16 length = 0;
;;;324    	uint8 currentData = 0;
;;;325    	
;;;326    	// 参数合法性检验
;;;327    	if(NULL == pCB)
00000e  2c00              CMP      r4,#0
000010  d021              BEQ      |L11.86|
;;;328    	{
;;;329    		return;
;;;330    	}
;;;331    	
;;;332    	// 一级缓冲区为空，退出
;;;333    	if(head == end)
000012  4288              CMP      r0,r1
000014  d01f              BEQ      |L11.86|
;;;334    	{
;;;335    		return;
;;;336    	}
;;;337    
;;;338    	// 获取临时缓冲区指针
;;;339    	pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.end];
000016  f8b423d2          LDRH     r2,[r4,#0x3d2]
00001a  204d              MOVS     r0,#0x4d
00001c  4350              MULS     r0,r2,r0
00001e  eb040540          ADD      r5,r4,r0,LSL #1
000022  35ce              ADDS     r5,r5,#0xce
;;;340    	// 取出当前要处理的字节
;;;341    	currentData = pCB->rxFIFO.buff[pCB->rxFIFO.currentProcessIndex];
000024  f8b400cc          LDRH     r0,[r4,#0xcc]
000028  5c20              LDRB     r0,[r4,r0]
;;;342    	
;;;343    	// 临时缓冲区长度为0时，搜索首字节
;;;344    	if(0 == pCmdFrame->length)
00002a  f8b53098          LDRH     r3,[r5,#0x98]
;;;345    	{
;;;346    		// 命令头错误，删除当前字节并退出
;;;347    		if(UART_PROTOCOLIOT_CMD_HEAD != currentData)
;;;348    		{
;;;349    			pCB->rxFIFO.head ++;
;;;350    			pCB->rxFIFO.head %= UART_PROTOCOLIOT_RX_FIFO_SIZE;
00002e  27c8              MOVS     r7,#0xc8
000030  b19b              CBZ      r3,|L11.90|
;;;351    			pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;352    
;;;353    			return;
;;;354    		}
;;;355    		
;;;356    		// 命令头正确，但无临时缓冲区可用，退出
;;;357    		if((pCB->rx.end + 1)%UART_PROTOCOLIOT_RX_QUEUE_SIZE == pCB->rx.head)
;;;358    		{
;;;359    			return;
;;;360    		}
;;;361    
;;;362    		// 添加UART通讯超时时间设置-2016.1.5增加
;;;363    #if UART_PROTOCOLIOT_RX_TIME_OUT_CHECK_ENABLE
;;;364    		TIMER_AddTask(TIMER_ID_UART_RX_TIME_OUT_CONTROL,
;;;365    						UART_PROTOCOLIOT_BUS_UNIDIRECTIONAL_TIME_OUT,
;;;366    						UART_PROTOCOLIOT_CALLBACK_RxTimeOut,
;;;367    						0,
;;;368    						1,
;;;369    						ACTION_MODE_ADD_TO_QUEUE);
;;;370    #endif
;;;371    		
;;;372    		// 命令头正确，有临时缓冲区可用，则将其添加到命令帧临时缓冲区中
;;;373    		pCmdFrame->buff[pCmdFrame->length++]= currentData;
;;;374    		pCB->rxFIFO.currentProcessIndex ++;
;;;375    		pCB->rxFIFO.currentProcessIndex %= UART_PROTOCOLIOT_RX_FIFO_SIZE;
;;;376    	}
;;;377    	// 非首字节，将数据添加到命令帧临时缓冲区中，但暂不删除当前数据
;;;378    	else
;;;379    	{
;;;380    		// 临时缓冲区溢出，说明当前正在接收的命令帧是错误的，正确的命令帧不会出现长度溢出的情况
;;;381    		if(pCmdFrame->length >= UART_PROTOCOLIOT_RX_CMD_FRAME_LENGTH_MAX)
000032  f04f0800          MOV      r8,#0
000036  2b96              CMP      r3,#0x96
000038  d37e              BCC      |L11.312|
;;;382    		{
;;;383    #if UART_PROTOCOLIOT_RX_TIME_OUT_CHECK_ENABLE
;;;384    			// 停止RX通讯超时检测
;;;385    			UART_PROTOCOLIOT_StopRxTimeOutCheck();
;;;386    #endif
;;;387    
;;;388    			// 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;389    			pCmdFrame->length = 0;	// 2016.1.5增加
00003a  f8a58098          STRH     r8,[r5,#0x98]
;;;390    			// 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;391    			pCB->rxFIFO.head ++;
00003e  f8340fc8          LDRH     r0,[r4,#0xc8]!
000042  1c40              ADDS     r0,r0,#1
000044  8020              STRH     r0,[r4,#0]
;;;392    			pCB->rxFIFO.head %= UART_PROTOCOLIOT_RX_FIFO_SIZE;
000046  8820              LDRH     r0,[r4,#0]
000048  fbb0f1f7          UDIV     r1,r0,r7
00004c  fb070011          MLS      r0,r7,r1,r0
000050  8020              STRH     r0,[r4,#0]
;;;393    			pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
000052  8820              LDRH     r0,[r4,#0]
000054  80a0              STRH     r0,[r4,#4]
                  |L11.86|
;;;394    
;;;395    			return;
;;;396    		}
;;;397    
;;;398    		// 一直取到末尾
;;;399    		while(end != pCB->rxFIFO.currentProcessIndex)
;;;400    		{
;;;401    			// 取出当前要处理的字节
;;;402    			currentData = pCB->rxFIFO.buff[pCB->rxFIFO.currentProcessIndex];
;;;403    			// 缓冲区未溢出，正常接收，将数据添加到临时缓冲区中
;;;404    			pCmdFrame->buff[pCmdFrame->length++] = currentData;
;;;405    			pCB->rxFIFO.currentProcessIndex ++;
;;;406    			pCB->rxFIFO.currentProcessIndex %= UART_PROTOCOLIOT_RX_FIFO_SIZE;
;;;407    
;;;408    			// ■■接下来，需要检查命令帧是否完整，如果完整，则将命令帧临时缓冲区扶正■■
;;;409    			
;;;410    			// 首先判断命令帧最小长度，一个完整的命令字至少包括5个字节: 命令头、设备地址、命令字、数据长度、校验，因此不足5个字节的必定不完整
;;;411    			if(pCmdFrame->length < UART_PROTOCOLIOT_CMD_FRAME_LENGTH_MIN)
;;;412    			{
;;;413    				// 继续接收
;;;414    				continue;
;;;415    			}
;;;416    
;;;417    			// 命令帧长度数值越界，说明当前命令帧错误，停止接收
;;;418    			if(pCmdFrame->buff[UART_PROTOCOLIOT_CMD_LENGTH_INDEX] > UART_PROTOCOLIOT_RX_CMD_FRAME_LENGTH_MAX-UART_PROTOCOLIOT_CMD_FRAME_LENGTH_MIN)
;;;419    			{
;;;420    #if UART_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;421    				// 停止RX通讯超时检测
;;;422    				UART_PROTOCOLIOT_StopRxTimeOutCheck();
;;;423    #endif
;;;424    			
;;;425    				// 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;426    				pCmdFrame->length = 0;
;;;427    				// 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;428    				pCB->rxFIFO.head ++;
;;;429    				pCB->rxFIFO.head %= UART_PROTOCOLIOT_RX_FIFO_SIZE;
;;;430    				pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;431    
;;;432    				return;
;;;433    			}
;;;434    
;;;435    			// 命令帧长度校验，在命令长度描述字的数值上，增加命令头、设备地址、命令字、数据长度、校验和L、校验和H、结束标识0xD、结束标识OxA，即为命令帧实际长度
;;;436    			length = pCmdFrame->length;
;;;437    			if(length < pCmdFrame->buff[UART_PROTOCOLIOT_CMD_LENGTH_INDEX] + UART_PROTOCOLIOT_CMD_FRAME_LENGTH_MIN)
;;;438    			{
;;;439    				// 长度要求不一致，说明未接收完毕，退出继续
;;;440    				continue;
;;;441    			}
;;;442    
;;;443    			// 命令帧长度OK，则进行校验，失败时删除命令头
;;;444    			if(!UART_PROTOCOLIOT_CheckSUM(pCmdFrame))
;;;445    			{
;;;446    #if UART_PROTOCOLIOT_RX_TIME_OUT_CHECK_ENABLE
;;;447    				// 停止RX通讯超时检测
;;;448    				UART_PROTOCOLIOT_StopRxTimeOutCheck();
;;;449    #endif
;;;450    				
;;;451    				// 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;452    				pCmdFrame->length = 0;
;;;453    				// 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;454    				pCB->rxFIFO.head ++;
;;;455    				pCB->rxFIFO.head %= UART_PROTOCOLIOT_RX_FIFO_SIZE;
;;;456    				pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;457    				
;;;458    				return;
;;;459    			}
;;;460    
;;;461    #if UART_PROTOCOLIOT_RX_TIME_OUT_CHECK_ENABLE
;;;462    			// 停止RX通讯超时检测
;;;463    			UART_PROTOCOLIOT_StopRxTimeOutCheck();
;;;464    #endif
;;;465    			
;;;466    			// 执行到这里，即说明接收到了一个完整并且正确的命令帧，此时需将处理过的数据从一级缓冲区中删除，并将该命令帧扶正
;;;467    			pCB->rxFIFO.head += length;
;;;468    			pCB->rxFIFO.head %= UART_PROTOCOLIOT_RX_FIFO_SIZE;
;;;469    			pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;470    			UART_PROTOCOLIOT_ConfirmTempCmdFrameBuff(pCB);
;;;471    
;;;472    			return;
;;;473    		}
;;;474    	}
;;;475    }
000056  e8bd81f0          POP      {r4-r8,pc}
                  |L11.90|
00005a  2855              CMP      r0,#0x55              ;347
00005c  d00c              BEQ      |L11.120|
00005e  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;349
000062  1c40              ADDS     r0,r0,#1              ;349
000064  8020              STRH     r0,[r4,#0]            ;349
000066  8820              LDRH     r0,[r4,#0]            ;350
000068  fbb0f1f7          UDIV     r1,r0,r7              ;350
00006c  fb070011          MLS      r0,r7,r1,r0           ;350
000070  8020              STRH     r0,[r4,#0]            ;350
000072  8820              LDRH     r0,[r4,#0]            ;351
000074  80a0              STRH     r0,[r4,#4]            ;351
000076  e7ee              B        |L11.86|
                  |L11.120|
000078  1c52              ADDS     r2,r2,#1              ;357
00007a  2105              MOVS     r1,#5                 ;357
00007c  fbb2f3f1          UDIV     r3,r2,r1              ;357
000080  fb012113          MLS      r1,r1,r3,r2           ;357
000084  f8b423d0          LDRH     r2,[r4,#0x3d0]        ;357
000088  4291              CMP      r1,r2                 ;357
00008a  d0e4              BEQ      |L11.86|
00008c  2101              MOVS     r1,#1                 ;373
00008e  f8a51098          STRH     r1,[r5,#0x98]         ;373
000092  70a8              STRB     r0,[r5,#2]            ;373
000094  f8340fcc          LDRH     r0,[r4,#0xcc]!        ;374
000098  1c40              ADDS     r0,r0,#1              ;374
00009a  b280              UXTH     r0,r0                 ;374
00009c  fbb0f1f7          UDIV     r1,r0,r7              ;375
0000a0  fb070011          MLS      r0,r7,r1,r0           ;375
0000a4  8020              STRH     r0,[r4,#0]            ;375
0000a6  e7d6              B        |L11.86|
                  |L11.168|
0000a8  5c22              LDRB     r2,[r4,r0]            ;402
0000aa  f8b50098          LDRH     r0,[r5,#0x98]         ;404
0000ae  1c43              ADDS     r3,r0,#1              ;404
0000b0  4428              ADD      r0,r0,r5              ;404
0000b2  f8a53098          STRH     r3,[r5,#0x98]         ;404
0000b6  7082              STRB     r2,[r0,#2]            ;404
0000b8  f8b400cc          LDRH     r0,[r4,#0xcc]         ;405
0000bc  1c40              ADDS     r0,r0,#1              ;405
0000be  b280              UXTH     r0,r0                 ;405
0000c0  fbb0f2f7          UDIV     r2,r0,r7              ;406
0000c4  fb070012          MLS      r0,r7,r2,r0           ;406
0000c8  f8a400cc          STRH     r0,[r4,#0xcc]         ;406
0000cc  f8b56098          LDRH     r6,[r5,#0x98]         ;411
0000d0  2e05              CMP      r6,#5                 ;411
0000d2  d33b              BCC      |L11.332|
0000d4  7968              LDRB     r0,[r5,#5]            ;418
0000d6  2891              CMP      r0,#0x91              ;418
0000d8  d90e              BLS      |L11.248|
0000da  f8a58098          STRH     r8,[r5,#0x98]         ;426
0000de  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;428
0000e2  1c40              ADDS     r0,r0,#1              ;428
0000e4  8020              STRH     r0,[r4,#0]            ;428
0000e6  8820              LDRH     r0,[r4,#0]            ;429
0000e8  fbb0f1f7          UDIV     r1,r0,r7              ;429
0000ec  fb070011          MLS      r0,r7,r1,r0           ;429
0000f0  8020              STRH     r0,[r4,#0]            ;429
0000f2  8820              LDRH     r0,[r4,#0]            ;430
0000f4  80a0              STRH     r0,[r4,#4]            ;430
0000f6  e7ae              B        |L11.86|
                  |L11.248|
0000f8  1d40              ADDS     r0,r0,#5              ;437
0000fa  42b0              CMP      r0,r6                 ;437
0000fc  d826              BHI      |L11.332|
0000fe  4628              MOV      r0,r5                 ;444
000100  f7fffffe          BL       UART_PROTOCOLIOT_CheckSUM
000104  b188              CBZ      r0,|L11.298|
000106  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;467
00010a  4430              ADD      r0,r0,r6              ;467
00010c  8020              STRH     r0,[r4,#0]            ;467
00010e  8820              LDRH     r0,[r4,#0]            ;468
000110  fbb0f1f7          UDIV     r1,r0,r7              ;468
000114  fb070011          MLS      r0,r7,r1,r0           ;468
000118  8020              STRH     r0,[r4,#0]            ;468
00011a  8820              LDRH     r0,[r4,#0]            ;469
00011c  80a0              STRH     r0,[r4,#4]            ;469
00011e  3cc8              SUBS     r4,r4,#0xc8           ;469
000120  4620              MOV      r0,r4                 ;470
000122  e8bd41f0          POP      {r4-r8,lr}            ;470
000126  f7ffbffe          B.W      UART_PROTOCOLIOT_ConfirmTempCmdFrameBuff
                  |L11.298|
00012a  f8a58098          STRH     r8,[r5,#0x98]         ;452
00012e  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;454
000132  1c40              ADDS     r0,r0,#1              ;454
000134  8020              STRH     r0,[r4,#0]            ;454
000136  e000              B        |L11.314|
                  |L11.312|
000138  e008              B        |L11.332|
                  |L11.314|
00013a  8820              LDRH     r0,[r4,#0]            ;455
00013c  fbb0f1f7          UDIV     r1,r0,r7              ;455
000140  fb070011          MLS      r0,r7,r1,r0           ;455
000144  8020              STRH     r0,[r4,#0]            ;455
000146  8820              LDRH     r0,[r4,#0]            ;456
000148  80a0              STRH     r0,[r4,#4]            ;456
00014a  e784              B        |L11.86|
                  |L11.332|
00014c  f8b400cc          LDRH     r0,[r4,#0xcc]         ;399
000150  4288              CMP      r0,r1                 ;399
000152  d1a9              BNE      |L11.168|
000154  e77f              B        |L11.86|
;;;476    
                          ENDP


                          AREA ||i.UART_PROTOCOLIOT_SendCmdCheckError||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOLIOT_SendCmdCheckError PROC
;;;1415   // 检测故障问题
;;;1416   void UART_PROTOCOLIOT_SendCmdCheckError(void)
000000  b510              PUSH     {r4,lr}
;;;1417   {
;;;1418   	uartProtocolCBIOT.cmdStyle &= (~0x40);
000002  483a              LDR      r0,|L12.236|
000004  f8b016ee          LDRH     r1,[r0,#0x6ee]  ; uartProtocolCBIOT
000008  f0210140          BIC      r1,r1,#0x40
00000c  f8a016ee          STRH     r1,[r0,#0x6ee]
;;;1419   	UART_PROTOCOLIOT_TxAddData(UART_PROTOCOLIOT_CMD_HEAD); 		
000010  2055              MOVS     r0,#0x55
000012  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1420   	UART_PROTOCOLIOT_TxAddData((UART_PROTOCOLIOT_HMI_DDR << 4) | (UART_PROTOCOLIOT_IOT_ADD));
000016  2009              MOVS     r0,#9
000018  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1421   	UART_PROTOCOLIOT_TxAddData(UART_PROTOCOLIOT_CMD_DIAGNOSIS); 	
00001c  2030              MOVS     r0,#0x30
00001e  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1422   	UART_PROTOCOLIOT_TxAddData(0x02);
000022  2002              MOVS     r0,#2
000024  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1423   	
;;;1424   	// 电压检测
;;;1425   	UART_PROTOCOLIOT_TxAddData(0x01);
000028  2001              MOVS     r0,#1
00002a  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1426   	if (ERROR_TYPE_OVER_VOLTAGE_ERROR == PARAM_GetErrorCode())
00002e  4c30              LDR      r4,|L12.240|
000030  f8940221          LDRB     r0,[r4,#0x221]  ; paramCB
000034  2829              CMP      r0,#0x29
000036  d040              BEQ      |L12.186|
;;;1427   	{
;;;1428   		UART_PROTOCOLIOT_TxAddData(1);
;;;1429   	}
;;;1430   	else
;;;1431   	{
;;;1432   		UART_PROTOCOLIOT_TxAddData(0);
000038  2000              MOVS     r0,#0
00003a  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
                  |L12.62|
;;;1433   	}
;;;1434   	
;;;1435   	// 刹车指拨
;;;1436   	UART_PROTOCOLIOT_TxAddData(0x02);
00003e  2002              MOVS     r0,#2
000040  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1437   	if ((ERROR_TYPE_THROTTLE_ERROR == PARAM_GetErrorCode()) || (ERROR_TYPE_BRAKE_ERROR == PARAM_GetErrorCode()))
000044  f8940221          LDRB     r0,[r4,#0x221]  ; paramCB
000048  2822              CMP      r0,#0x22
00004a  d03a              BEQ      |L12.194|
00004c  2825              CMP      r0,#0x25
00004e  d038              BEQ      |L12.194|
;;;1438   	{
;;;1439   		UART_PROTOCOLIOT_TxAddData(1);
;;;1440   	}
;;;1441   	else
;;;1442   	{
;;;1443   		UART_PROTOCOLIOT_TxAddData(0);
000050  2000              MOVS     r0,#0
000052  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
                  |L12.86|
;;;1444   	}
;;;1445   	
;;;1446   	// 电机霍尔
;;;1447   	UART_PROTOCOLIOT_TxAddData(0x03);
000056  2003              MOVS     r0,#3
000058  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1448   	if (ERROR_TYPE_HALL_SENSOR_ERROR == PARAM_GetErrorCode())
00005c  f8940221          LDRB     r0,[r4,#0x221]  ; paramCB
000060  2824              CMP      r0,#0x24
000062  d032              BEQ      |L12.202|
;;;1449   	{
;;;1450   		UART_PROTOCOLIOT_TxAddData(1);
;;;1451   	}
;;;1452   	else
;;;1453   	{
;;;1454   		UART_PROTOCOLIOT_TxAddData(0);
000064  2000              MOVS     r0,#0
000066  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
                  |L12.106|
;;;1455   	}
;;;1456   	
;;;1457   	// 通讯检测
;;;1458   	UART_PROTOCOLIOT_TxAddData(0x04);
00006a  2004              MOVS     r0,#4
00006c  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1459   	if (ERROR_TYPE_COMMUNICATION_TIME_OUT == PARAM_GetErrorCode())
000070  f8940221          LDRB     r0,[r4,#0x221]  ; paramCB
000074  2830              CMP      r0,#0x30
000076  d02c              BEQ      |L12.210|
;;;1460   	{
;;;1461   		UART_PROTOCOLIOT_TxAddData(1);
;;;1462   	}
;;;1463   	else
;;;1464   	{
;;;1465   		UART_PROTOCOLIOT_TxAddData(0);
000078  2000              MOVS     r0,#0
00007a  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
                  |L12.126|
;;;1466   	}
;;;1467   	
;;;1468   	// 过温检测
;;;1469   	UART_PROTOCOLIOT_TxAddData(0x05);
00007e  2005              MOVS     r0,#5
000080  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1470   	if (ERROR_TYPE_TEMP_ERROR == PARAM_GetErrorCode())
000084  f8940221          LDRB     r0,[r4,#0x221]  ; paramCB
000088  2826              CMP      r0,#0x26
00008a  d026              BEQ      |L12.218|
;;;1471   	{
;;;1472   		UART_PROTOCOLIOT_TxAddData(1);
;;;1473   	}
;;;1474   	else
;;;1475   	{
;;;1476   		UART_PROTOCOLIOT_TxAddData(0);
00008c  2000              MOVS     r0,#0
00008e  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
                  |L12.146|
;;;1477   	}
;;;1478   	
;;;1479   	// 控制器
;;;1480   	UART_PROTOCOLIOT_TxAddData(0x06);
000092  2006              MOVS     r0,#6
000094  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1481   	UART_PROTOCOLIOT_TxAddData(0);
000098  2000              MOVS     r0,#0
00009a  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1482   	
;;;1483   	// 过流检测
;;;1484   	UART_PROTOCOLIOT_TxAddData(0x07);
00009e  2007              MOVS     r0,#7
0000a0  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1485   	if (ERROR_TYPE_CURRENT_ERROR == PARAM_GetErrorCode())
0000a4  f8940221          LDRB     r0,[r4,#0x221]  ; paramCB
0000a8  2821              CMP      r0,#0x21
0000aa  d01a              BEQ      |L12.226|
;;;1486   	{
;;;1487   		UART_PROTOCOLIOT_TxAddData(1);
;;;1488   	}
;;;1489   	else
;;;1490   	{
;;;1491   		UART_PROTOCOLIOT_TxAddData(0);
0000ac  2000              MOVS     r0,#0
0000ae  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
                  |L12.178|
;;;1492   	}
;;;1493   	
;;;1494   	
;;;1495   	UART_PROTOCOLIOT_TxAddFrame();
0000b2  e8bd4010          POP      {r4,lr}
0000b6  f7ffbffe          B.W      UART_PROTOCOLIOT_TxAddFrame
                  |L12.186|
0000ba  2001              MOVS     r0,#1                 ;1428
0000bc  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
0000c0  e7bd              B        |L12.62|
                  |L12.194|
0000c2  2001              MOVS     r0,#1                 ;1439
0000c4  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
0000c8  e7c5              B        |L12.86|
                  |L12.202|
0000ca  2001              MOVS     r0,#1                 ;1450
0000cc  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
0000d0  e7cb              B        |L12.106|
                  |L12.210|
0000d2  2001              MOVS     r0,#1                 ;1461
0000d4  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
0000d8  e7d1              B        |L12.126|
                  |L12.218|
0000da  2001              MOVS     r0,#1                 ;1472
0000dc  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
0000e0  e7d7              B        |L12.146|
                  |L12.226|
0000e2  2001              MOVS     r0,#1                 ;1487
0000e4  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
0000e8  e7e3              B        |L12.178|
;;;1496   }
;;;1497   
                          ENDP

0000ea  0000              DCW      0x0000
                  |L12.236|
                          DCD      ||.bss||
                  |L12.240|
                          DCD      paramCB

                          AREA ||i.UART_PROTOCOLIOT_SendCmdControlParamAck||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOLIOT_SendCmdControlParamAck PROC
;;;1168   
;;;1169   void UART_PROTOCOLIOT_SendCmdControlParamAck(void)
000000  b570              PUSH     {r4-r6,lr}
;;;1170   {
;;;1171   	uint8 val1 = 0x00;
000002  2400              MOVS     r4,#0
;;;1172   	
;;;1173   	uartProtocolCBIOT.cmdStyle &= (~0x20);
000004  4d25              LDR      r5,|L13.156|
000006  f8b506ee          LDRH     r0,[r5,#0x6ee]  ; uartProtocolCBIOT
00000a  f0200020          BIC      r0,r0,#0x20
00000e  f8a506ee          STRH     r0,[r5,#0x6ee]
;;;1174   	
;;;1175   	UART_PROTOCOLIOT_TxAddData(UART_PROTOCOLIOT_CMD_HEAD); 		
000012  2055              MOVS     r0,#0x55
000014  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1176   	UART_PROTOCOLIOT_TxAddData((UART_PROTOCOLIOT_HMI_DDR << 4) | (UART_PROTOCOLIOT_IOT_ADD));
000018  2009              MOVS     r0,#9
00001a  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1177   	UART_PROTOCOLIOT_TxAddData(UART_PROTOCOLIOT_CMD_SET_PARAM); 	
00001e  2007              MOVS     r0,#7
000020  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1178   	UART_PROTOCOLIOT_TxAddData(0x02);	
000024  2002              MOVS     r0,#2
000026  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1179   	
;;;1180   	switch (uartProtocolCBIOT.setParamCmd)
00002a  f89516f0          LDRB     r1,[r5,#0x6f0]  ; uartProtocolCBIOT
;;;1181   	{
;;;1182   		case IOT_LIGHT:
;;;1183   			
;;;1184   			val1 = PARAM_GetLightSwitch();
00002e  481c              LDR      r0,|L13.160|
000030  290c              CMP      r1,#0xc               ;1180
000032  d228              BCS      |L13.134|
000034  e8dff001          TBB      [pc,r1]               ;1180
000038  2706090c          DCB      0x27,0x06,0x09,0x0c
00003c  10132716          DCB      0x10,0x13,0x27,0x16
000040  191c2325          DCB      0x19,0x1c,0x23,0x25
000044  f8904202          LDRB     r4,[r0,#0x202]  ; paramCB
;;;1185   			break;
000048  e01d              B        |L13.134|
;;;1186   		
;;;1187   		case IOT_AUTO_SHUTDOWN_TIME:
;;;1188   			
;;;1189   			val1 = PARAM_GetPowerOffTime();
00004a  f8904321          LDRB     r4,[r0,#0x321]  ; paramCB
;;;1190   			break;
00004e  e01a              B        |L13.134|
;;;1191   		
;;;1192   		case IOT_SPEED_LIMIT:
;;;1193   			
;;;1194   			val1 = PARAM_GetSpeedLimit();
000050  f7fffffe          BL       PARAM_GetSpeedLimit
000054  b2c4              UXTB     r4,r0
;;;1195   			break;
000056  e016              B        |L13.134|
;;;1196   		
;;;1197   		case IOT_UNIT:
;;;1198   		
;;;1199   			val1 = PARAM_GetUnit();
000058  f8904319          LDRB     r4,[r0,#0x319]  ; paramCB
;;;1200   			break;
00005c  e013              B        |L13.134|
;;;1201   		
;;;1202   		case IOT_ASSIST:
;;;1203   			
;;;1204   			val1 = (uint8)paramCB.runtime.assist;
00005e  f8904228          LDRB     r4,[r0,#0x228]  ; paramCB
;;;1205   			break;
000062  e010              B        |L13.134|
;;;1206   		
;;;1207   		case IOT_LOCK:
;;;1208   			val1 = 0;
;;;1209   			break;
;;;1210   
;;;1211   		case IOT_BACKLIGHT:
;;;1212   		
;;;1213   			val1 = PARAM_GetBrightness();
000064  f8904320          LDRB     r4,[r0,#0x320]  ; paramCB
;;;1214   			break;
000068  e00d              B        |L13.134|
;;;1215   
;;;1216   		case IOT_START_STYLE:
;;;1217   		
;;;1218   			val1 = PARAM_GetZeroStartOrNot();
00006a  f8904305          LDRB     r4,[r0,#0x305]  ; paramCB
;;;1219   			break;
00006e  e00a              B        |L13.134|
;;;1220   			
;;;1221   		case IOT_CURISE:
;;;1222   	
;;;1223   			val1 = !PARAM_GetCruiseEnableSwitch();
000070  f8900316          LDRB     r0,[r0,#0x316]  ; paramCB
000074  b108              CBZ      r0,|L13.122|
000076  2400              MOVS     r4,#0
000078  e005              B        |L13.134|
                  |L13.122|
00007a  2401              MOVS     r4,#1
00007c  e003              B        |L13.134|
;;;1224   			break;
;;;1225   
;;;1226   		case IOT_FACTORY:
;;;1227   	
;;;1228   			val1 = 0x01;
00007e  2401              MOVS     r4,#1
;;;1229   			break;
000080  e001              B        |L13.134|
;;;1230   
;;;1231   		case IOT_POWER_ON_OFF:
;;;1232   	
;;;1233   			val1 = PARAM_GetPowerState();
000082  f8904216          LDRB     r4,[r0,#0x216]  ; paramCB
                  |L13.134|
;;;1234   			break;
;;;1235   
;;;1236   		case IOT_BRAKE:
;;;1237   			break;
;;;1238   
;;;1239   		case IOT_POWER_PASSWORD:
;;;1240   			break;
;;;1241   	
;;;1242   		default:
;;;1243   			break;
;;;1244   	}
;;;1245   	
;;;1246   	UART_PROTOCOLIOT_TxAddData(uartProtocolCBIOT.setParamCmd);	
000086  f89506f0          LDRB     r0,[r5,#0x6f0]  ; uartProtocolCBIOT
00008a  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1247   	UART_PROTOCOLIOT_TxAddData(val1);	
00008e  4620              MOV      r0,r4
000090  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1248   	
;;;1249   	UART_PROTOCOLIOT_TxAddFrame();
000094  e8bd4070          POP      {r4-r6,lr}
000098  f7ffbffe          B.W      UART_PROTOCOLIOT_TxAddFrame
;;;1250   }
;;;1251   
                          ENDP

                  |L13.156|
                          DCD      ||.bss||
                  |L13.160|
                          DCD      paramCB

                          AREA ||i.UART_PROTOCOLIOT_SendCmdHeart||, CODE, READONLY, ALIGN=1

                  UART_PROTOCOLIOT_SendCmdHeart PROC
;;;741    // 发送仪表心跳
;;;742    void UART_PROTOCOLIOT_SendCmdHeart(void)
000000  b500              PUSH     {lr}
;;;743    {
;;;744    	// 添加命令头
;;;745    	UART_PROTOCOLIOT_TxAddData(UART_PROTOCOLIOT_CMD_HEAD);
000002  2055              MOVS     r0,#0x55
000004  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;746    
;;;747    	// 添加设备地址
;;;748    	UART_PROTOCOLIOT_TxAddData((UART_PROTOCOLIOT_HMI_DDR << 4) | (UART_PROTOCOLIOT_IOT_ADD));
000008  2009              MOVS     r0,#9
00000a  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;749    
;;;750    	// 添加命令字
;;;751    	UART_PROTOCOLIOT_TxAddData(UART_PROTOCOLIOT_CMD_HEART);
00000e  2000              MOVS     r0,#0
000010  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;752    	
;;;753    	UART_PROTOCOLIOT_TxAddData(0);		// 数据长度
000014  2000              MOVS     r0,#0
000016  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;754    	
;;;755    	UART_PROTOCOLIOT_TxAddFrame();
00001a  f85deb04          POP      {lr}
00001e  f7ffbffe          B.W      UART_PROTOCOLIOT_TxAddFrame
;;;756    }
;;;757    
                          ENDP


                          AREA ||i.UART_PROTOCOLIOT_SendCmdNoResult||, CODE, READONLY, ALIGN=1

                  UART_PROTOCOLIOT_SendCmdNoResult PROC
;;;718    // 发送命令无结果
;;;719    void UART_PROTOCOLIOT_SendCmdNoResult(uint8 cmdWord)
000000  b510              PUSH     {r4,lr}
;;;720    {
000002  4604              MOV      r4,r0
;;;721    	// 添加命令头
;;;722    	UART_PROTOCOLIOT_TxAddData(UART_PROTOCOLIOT_CMD_HEAD);
000004  2055              MOVS     r0,#0x55
000006  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;723    
;;;724    	// 添加设备地址
;;;725    	UART_PROTOCOLIOT_TxAddData((UART_PROTOCOLIOT_HMI_DDR << 4) | (UART_PROTOCOLIOT_IOT_ADD));
00000a  2009              MOVS     r0,#9
00000c  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;726    
;;;727    	// 添加命令字
;;;728    	UART_PROTOCOLIOT_TxAddData(cmdWord);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;729    	
;;;730    	UART_PROTOCOLIOT_TxAddData(0);		// 数据长度
000016  2000              MOVS     r0,#0
000018  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;731    	
;;;732    	UART_PROTOCOLIOT_TxAddFrame();
00001c  e8bd4010          POP      {r4,lr}
000020  f7ffbffe          B.W      UART_PROTOCOLIOT_TxAddFrame
;;;733    }
;;;734    
                          ENDP


                          AREA ||i.UART_PROTOCOLIOT_SendCmdState1Data||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOLIOT_SendCmdState1Data PROC
;;;758    // 状态组1数据回复
;;;759    void UART_PROTOCOLIOT_SendCmdState1Data(void)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;760    {
;;;761    	uint8 val1, val2, val3, val4;
;;;762    	uint32 valTemp;
;;;763    	
;;;764    	uartProtocolCBIOT.cmdStyle &= (~0x01);
000004  48a5              LDR      r0,|L16.668|
000006  f8b016ee          LDRH     r1,[r0,#0x6ee]  ; uartProtocolCBIOT
00000a  f0210101          BIC      r1,r1,#1
00000e  f8a016ee          STRH     r1,[r0,#0x6ee]
;;;765    	
;;;766    	UART_PROTOCOLIOT_TxAddData(UART_PROTOCOLIOT_CMD_HEAD); 		
000012  2055              MOVS     r0,#0x55
000014  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;767    	UART_PROTOCOLIOT_TxAddData((UART_PROTOCOLIOT_HMI_DDR << 4) | (UART_PROTOCOLIOT_IOT_ADD));
000018  2009              MOVS     r0,#9
00001a  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;768    	UART_PROTOCOLIOT_TxAddData(UART_PROTOCOLIOT_CMD_GET_CONDATA); 	
00001e  2003              MOVS     r0,#3
000020  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;769    	UART_PROTOCOLIOT_TxAddData(0x02);
000024  2002              MOVS     r0,#2
000026  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;770    	
;;;771    	// 状态组1编号
;;;772    	UART_PROTOCOLIOT_TxAddData(0x01);
00002a  2001              MOVS     r0,#1
00002c  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;773    	
;;;774    	// 骑行总里程
;;;775    	valTemp = paramCB.nvm.param.common.record.total.distance;
000030  4c9b              LDR      r4,|L16.672|
000032  6821              LDR      r1,[r4,#0]  ; paramCB
;;;776    	val1 = (uint8)((valTemp >> 24) & 0xFF);
000034  0e08              LSRS     r0,r1,#24
;;;777    	val2 = (uint8)((valTemp >> 16) & 0xFF);
000036  f3c14607          UBFX     r6,r1,#16,#8
;;;778    	val3 = (uint8)((valTemp >> 8) & 0xFF);
00003a  f3c12507          UBFX     r5,r1,#8,#8
;;;779    	val4 = (uint8)(valTemp & 0xFF);
00003e  b2cf              UXTB     r7,r1
;;;780    	UART_PROTOCOLIOT_TxAddData(val1);
000040  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;781    	UART_PROTOCOLIOT_TxAddData(val2);
000044  4630              MOV      r0,r6
000046  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;782    	UART_PROTOCOLIOT_TxAddData(val3);
00004a  4628              MOV      r0,r5
00004c  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;783    	UART_PROTOCOLIOT_TxAddData(val4);
000050  4638              MOV      r0,r7
000052  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;784    	
;;;785    	// 总时间
;;;786    	valTemp = PARAM_GetTotalRidingTime();
000056  68e1              LDR      r1,[r4,#0xc]  ; paramCB
;;;787    	val1 = (uint8)((valTemp >> 24) & 0xFF);
000058  0e08              LSRS     r0,r1,#24
;;;788    	val2 = (uint8)((valTemp >> 16) & 0xFF);
00005a  f3c14507          UBFX     r5,r1,#16,#8
;;;789    	val3 = (uint8)((valTemp >> 8) & 0xFF);
00005e  f3c12607          UBFX     r6,r1,#8,#8
;;;790    	val4 = (uint8)(valTemp & 0xFF);
000062  b2cf              UXTB     r7,r1
;;;791    	UART_PROTOCOLIOT_TxAddData(val1);
000064  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;792    	UART_PROTOCOLIOT_TxAddData(val2);
000068  4628              MOV      r0,r5
00006a  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;793    	UART_PROTOCOLIOT_TxAddData(val3);
00006e  4630              MOV      r0,r6
000070  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;794    	UART_PROTOCOLIOT_TxAddData(val4);
000074  4638              MOV      r0,r7
000076  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;795    	
;;;796    	// 总卡路里
;;;797    	valTemp = PARAM_GetTotalCalories();
00007a  6921              LDR      r1,[r4,#0x10]  ; paramCB
;;;798    	val1 = (uint8)((valTemp >> 24) & 0xFF);
00007c  0e08              LSRS     r0,r1,#24
;;;799    	val2 = (uint8)((valTemp >> 16) & 0xFF);
00007e  f3c14507          UBFX     r5,r1,#16,#8
;;;800    	val3 = (uint8)((valTemp >> 8) & 0xFF);
000082  f3c12607          UBFX     r6,r1,#8,#8
;;;801    	val4 = (uint8)(valTemp & 0xFF);
000086  b2cf              UXTB     r7,r1
;;;802    	UART_PROTOCOLIOT_TxAddData(val1);
000088  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;803    	UART_PROTOCOLIOT_TxAddData(val2);
00008c  4628              MOV      r0,r5
00008e  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;804    	UART_PROTOCOLIOT_TxAddData(val3);
000092  4630              MOV      r0,r6
000094  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;805    	UART_PROTOCOLIOT_TxAddData(val4);
000098  4638              MOV      r0,r7
00009a  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;806    	
;;;807    	// 最大速度（总）
;;;808    	valTemp = 0;
;;;809    	val1 = ((valTemp >> 8) & 0xFF);
00009e  2500              MOVS     r5,#0
;;;810    	val2 = (valTemp & 0xFF);
0000a0  2600              MOVS     r6,#0
;;;811    	UART_PROTOCOLIOT_TxAddData(val1);
0000a2  4628              MOV      r0,r5
0000a4  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;812    	UART_PROTOCOLIOT_TxAddData(val2);
0000a8  4630              MOV      r0,r6
0000aa  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;813    	
;;;814    	// 平均速度（总）
;;;815    	valTemp = 0;
;;;816    	val1 = ((valTemp >> 8) & 0xFF);
;;;817    	val2 = (valTemp & 0xFF);
;;;818    	UART_PROTOCOLIOT_TxAddData(val1);
0000ae  4628              MOV      r0,r5
0000b0  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;819    	UART_PROTOCOLIOT_TxAddData(val2);
0000b4  4630              MOV      r0,r6
0000b6  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;820    	
;;;821    	// 总碳排放
;;;822    	valTemp = paramCB.nvm.param.common.record.total.distance * 0.174f;
0000ba  6820              LDR      r0,[r4,#0]  ; paramCB
0000bc  f7fffffe          BL       __aeabi_ui2f
0000c0  4d78              LDR      r5,|L16.676|
0000c2  4629              MOV      r1,r5
0000c4  f7fffffe          BL       __aeabi_fmul
0000c8  f7fffffe          BL       __aeabi_f2uiz
;;;823    	val1 = ((valTemp >> 24) & 0xFF);
0000cc  0e01              LSRS     r1,r0,#24
;;;824    	val2 = ((valTemp >> 16) & 0xFF);
0000ce  f3c04607          UBFX     r6,r0,#16,#8
;;;825    	val3 = ((valTemp >> 8) & 0xFF);
0000d2  f3c02707          UBFX     r7,r0,#8,#8
;;;826    	val4 = (valTemp & 0xFF);
0000d6  f00008ff          AND      r8,r0,#0xff
;;;827    	UART_PROTOCOLIOT_TxAddData(val1);
0000da  4608              MOV      r0,r1
0000dc  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;828    	UART_PROTOCOLIOT_TxAddData(val2);
0000e0  4630              MOV      r0,r6
0000e2  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;829    	UART_PROTOCOLIOT_TxAddData(val3);
0000e6  4638              MOV      r0,r7
0000e8  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;830    	UART_PROTOCOLIOT_TxAddData(val4);
0000ec  4640              MOV      r0,r8
0000ee  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;831    
;;;832    	// 总节约树
;;;833    	valTemp = paramCB.nvm.param.common.record.total.distance * 0.0136f;
0000f2  6820              LDR      r0,[r4,#0]  ; paramCB
0000f4  f7fffffe          BL       __aeabi_ui2f
0000f8  4e6b              LDR      r6,|L16.680|
0000fa  4631              MOV      r1,r6
0000fc  f7fffffe          BL       __aeabi_fmul
000100  f7fffffe          BL       __aeabi_f2uiz
;;;834    	val1 = ((valTemp >> 8) & 0xFF);
000104  f3c02107          UBFX     r1,r0,#8,#8
;;;835    	val2 = (valTemp & 0xFF);
000108  b2c7              UXTB     r7,r0
;;;836    	UART_PROTOCOLIOT_TxAddData(val1);
00010a  4608              MOV      r0,r1
00010c  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;837    	UART_PROTOCOLIOT_TxAddData(val2);
000110  4638              MOV      r0,r7
000112  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;838    	
;;;839    	// TRIPA
;;;840    	// 单次骑行里程
;;;841    	valTemp = paramCB.nvm.param.common.record.trip.distance;
000116  6962              LDR      r2,[r4,#0x14]  ; paramCB
;;;842    	val1 = (uint8)((valTemp >> 24) & 0xFF);
000118  0e10              LSRS     r0,r2,#24
;;;843    	val2 = (uint8)((valTemp >> 16) & 0xFF);
00011a  f3c24707          UBFX     r7,r2,#16,#8
;;;844    	val3 = (uint8)((valTemp >> 8) & 0xFF);
00011e  f3c22807          UBFX     r8,r2,#8,#8
;;;845    	val4 = (uint8)(valTemp & 0xFF);
000122  f00209ff          AND      r9,r2,#0xff
;;;846    	UART_PROTOCOLIOT_TxAddData(val1);
000126  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;847    	UART_PROTOCOLIOT_TxAddData(val2);
00012a  4638              MOV      r0,r7
00012c  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;848    	UART_PROTOCOLIOT_TxAddData(val3);
000130  4640              MOV      r0,r8
000132  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;849    	UART_PROTOCOLIOT_TxAddData(val4);
000136  4648              MOV      r0,r9
000138  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;850    
;;;851    	// 单次骑行时间
;;;852    	valTemp = paramCB.nvm.param.common.record.trip.ridingTime;
00013c  6a22              LDR      r2,[r4,#0x20]  ; paramCB
;;;853    	val1 = (uint8)((valTemp >> 24) & 0xFF);
00013e  0e10              LSRS     r0,r2,#24
;;;854    	val2 = (uint8)((valTemp >> 16) & 0xFF);
000140  f3c24707          UBFX     r7,r2,#16,#8
;;;855    	val3 = (uint8)((valTemp >> 8) & 0xFF);
000144  f3c22807          UBFX     r8,r2,#8,#8
;;;856    	val4 = (uint8)(valTemp & 0xFF);
000148  f00209ff          AND      r9,r2,#0xff
;;;857    	UART_PROTOCOLIOT_TxAddData(val1);
00014c  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;858    	UART_PROTOCOLIOT_TxAddData(val2);
000150  4638              MOV      r0,r7
000152  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;859    	UART_PROTOCOLIOT_TxAddData(val3);
000156  4640              MOV      r0,r8
000158  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;860    	UART_PROTOCOLIOT_TxAddData(val4);
00015c  4648              MOV      r0,r9
00015e  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;861    
;;;862    	// 单次骑行卡路里
;;;863    	valTemp = paramCB.nvm.param.common.record.trip.calories;
000162  69a2              LDR      r2,[r4,#0x18]  ; paramCB
;;;864    	val1 = (uint8)((valTemp >> 24) & 0xFF);
000164  0e10              LSRS     r0,r2,#24
;;;865    	val2 = (uint8)((valTemp >> 16) & 0xFF);
000166  f3c24707          UBFX     r7,r2,#16,#8
;;;866    	val3 = (uint8)((valTemp >> 8) & 0xFF);
00016a  f3c22807          UBFX     r8,r2,#8,#8
;;;867    	val4 = (uint8)(valTemp & 0xFF);
00016e  f00209ff          AND      r9,r2,#0xff
;;;868    	UART_PROTOCOLIOT_TxAddData(val1);
000172  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;869    	UART_PROTOCOLIOT_TxAddData(val2);
000176  4638              MOV      r0,r7
000178  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;870    	UART_PROTOCOLIOT_TxAddData(val3);
00017c  4640              MOV      r0,r8
00017e  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;871    	UART_PROTOCOLIOT_TxAddData(val4);
000182  4648              MOV      r0,r9
000184  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;872    
;;;873    	// 单次骑行碳排放
;;;874    	valTemp = paramCB.nvm.param.common.record.trip.distance * 0.174f;
000188  6960              LDR      r0,[r4,#0x14]  ; paramCB
00018a  f7fffffe          BL       __aeabi_ui2f
00018e  4629              MOV      r1,r5
000190  f7fffffe          BL       __aeabi_fmul
000194  f7fffffe          BL       __aeabi_f2uiz
;;;875    	val1 = (uint8)((valTemp >> 24) & 0xFF);
000198  0e01              LSRS     r1,r0,#24
;;;876    	val2 = (uint8)((valTemp >> 16) & 0xFF);
00019a  f3c04707          UBFX     r7,r0,#16,#8
;;;877    	val3 = (uint8)((valTemp >> 8) & 0xFF);
00019e  f3c02507          UBFX     r5,r0,#8,#8
;;;878    	val4 = (uint8)(valTemp & 0xFF);
0001a2  f00008ff          AND      r8,r0,#0xff
;;;879    	UART_PROTOCOLIOT_TxAddData(val1);
0001a6  4608              MOV      r0,r1
0001a8  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;880    	UART_PROTOCOLIOT_TxAddData(val2);
0001ac  4638              MOV      r0,r7
0001ae  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;881    	UART_PROTOCOLIOT_TxAddData(val3);
0001b2  4628              MOV      r0,r5
0001b4  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;882    	UART_PROTOCOLIOT_TxAddData(val4);
0001b8  4640              MOV      r0,r8
0001ba  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;883    
;;;884    	// 单次骑行节约树
;;;885    	valTemp = paramCB.nvm.param.common.record.trip.distance * 0.0136f;
0001be  6960              LDR      r0,[r4,#0x14]  ; paramCB
0001c0  f7fffffe          BL       __aeabi_ui2f
0001c4  4631              MOV      r1,r6
0001c6  f7fffffe          BL       __aeabi_fmul
0001ca  f7fffffe          BL       __aeabi_f2uiz
;;;886    	val1 = ((valTemp >> 8) & 0xFF);
0001ce  f3c02107          UBFX     r1,r0,#8,#8
;;;887    	val2 = (valTemp & 0xFF);
0001d2  b2c5              UXTB     r5,r0
;;;888    	UART_PROTOCOLIOT_TxAddData(val1);
0001d4  4608              MOV      r0,r1
0001d6  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;889    	UART_PROTOCOLIOT_TxAddData(val2);
0001da  4628              MOV      r0,r5
0001dc  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;890    	
;;;891    	// 单次骑行最大速度
;;;892    	valTemp = paramCB.nvm.param.common.record.trip.speedMax;
0001e0  8ba0              LDRH     r0,[r4,#0x1c]  ; paramCB
;;;893    	val1 = ((valTemp >> 8) & 0xFF);
0001e2  0a01              LSRS     r1,r0,#8
;;;894    	val2 = (valTemp & 0xFF);
0001e4  b2c5              UXTB     r5,r0
;;;895    	UART_PROTOCOLIOT_TxAddData(val1);
0001e6  4608              MOV      r0,r1
0001e8  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;896    	UART_PROTOCOLIOT_TxAddData(val2);
0001ec  4628              MOV      r0,r5
0001ee  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;897    	
;;;898    	// 单次骑行平均速度
;;;899    	valTemp = paramCB.runtime.trip.speedAverage;
0001f2  f8340ce2          LDRH     r0,[r4,#-0xe2]  ; paramCB
;;;900    	val1 = ((valTemp >> 8) & 0xFF);
0001f6  0a01              LSRS     r1,r0,#8
;;;901    	val2 = (valTemp & 0xFF);
0001f8  b2c4              UXTB     r4,r0
;;;902    	UART_PROTOCOLIOT_TxAddData(val1);
0001fa  4608              MOV      r0,r1
0001fc  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;903    	UART_PROTOCOLIOT_TxAddData(val2);
000200  4620              MOV      r0,r4
000202  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;904    	
;;;905    	// TRIPB
;;;906    	// 上电以来里程
;;;907    	valTemp = 0;
;;;908    	val1 = (uint8)((valTemp >> 24) & 0xFF);
000206  2400              MOVS     r4,#0
;;;909    	val2 = (uint8)((valTemp >> 16) & 0xFF);
000208  2500              MOVS     r5,#0
;;;910    	val3 = (uint8)((valTemp >> 8) & 0xFF);
00020a  2600              MOVS     r6,#0
;;;911    	val4 = (uint8)(valTemp & 0xFF);
00020c  2700              MOVS     r7,#0
;;;912    	UART_PROTOCOLIOT_TxAddData(val1);
00020e  4620              MOV      r0,r4
000210  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;913    	UART_PROTOCOLIOT_TxAddData(val2);
000214  4628              MOV      r0,r5
000216  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;914    	UART_PROTOCOLIOT_TxAddData(val3);
00021a  4630              MOV      r0,r6
00021c  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;915    	UART_PROTOCOLIOT_TxAddData(val4);
000220  4638              MOV      r0,r7
000222  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;916    
;;;917    	// 上电以来时间
;;;918    	valTemp = 0;
;;;919    	val1 = (uint8)((valTemp >> 24) & 0xFF);
;;;920    	val2 = (uint8)((valTemp >> 16) & 0xFF);
;;;921    	val3 = (uint8)((valTemp >> 8) & 0xFF);
;;;922    	val4 = (uint8)(valTemp & 0xFF);
;;;923    	UART_PROTOCOLIOT_TxAddData(val1);
000226  4620              MOV      r0,r4
000228  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;924    	UART_PROTOCOLIOT_TxAddData(val2);
00022c  4628              MOV      r0,r5
00022e  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;925    	UART_PROTOCOLIOT_TxAddData(val3);
000232  4630              MOV      r0,r6
000234  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;926    	UART_PROTOCOLIOT_TxAddData(val4);
000238  4638              MOV      r0,r7
00023a  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;927    
;;;928    	// 上电以来卡路里
;;;929    	valTemp = 0;
;;;930    	val1 = (uint8)((valTemp >> 24) & 0xFF);
;;;931    	val2 = (uint8)((valTemp >> 16) & 0xFF);
;;;932    	val3 = (uint8)((valTemp >> 8) & 0xFF);
;;;933    	val4 = (uint8)(valTemp & 0xFF);
;;;934    	UART_PROTOCOLIOT_TxAddData(val1);
00023e  4620              MOV      r0,r4
000240  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;935    	UART_PROTOCOLIOT_TxAddData(val2);
000244  4628              MOV      r0,r5
000246  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;936    	UART_PROTOCOLIOT_TxAddData(val3);
00024a  4630              MOV      r0,r6
00024c  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;937    	UART_PROTOCOLIOT_TxAddData(val4);
000250  4638              MOV      r0,r7
000252  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;938    
;;;939    	// 上电以来碳排放
;;;940    	valTemp = 0;
;;;941    	val1 = (uint8)((valTemp >> 24) & 0xFF);
;;;942    	val2 = (uint8)((valTemp >> 16) & 0xFF);
;;;943    	val3 = (uint8)((valTemp >> 8) & 0xFF);
;;;944    	val4 = (uint8)(valTemp & 0xFF);
;;;945    	UART_PROTOCOLIOT_TxAddData(val1);
000256  4620              MOV      r0,r4
000258  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;946    	UART_PROTOCOLIOT_TxAddData(val2);
00025c  4628              MOV      r0,r5
00025e  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;947    	UART_PROTOCOLIOT_TxAddData(val3);
000262  4630              MOV      r0,r6
000264  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;948    	UART_PROTOCOLIOT_TxAddData(val4);
000268  4638              MOV      r0,r7
00026a  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;949    
;;;950    	// 上电以来节约树
;;;951    	valTemp = 0;
;;;952    	val1 = ((valTemp >> 8) & 0xFF);
;;;953    	val2 = (valTemp & 0xFF);
;;;954    	UART_PROTOCOLIOT_TxAddData(val1);
00026e  4620              MOV      r0,r4
000270  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;955    	UART_PROTOCOLIOT_TxAddData(val2);
000274  4628              MOV      r0,r5
000276  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;956    	
;;;957    	// 上电以来最大速度
;;;958    	valTemp = 0;
;;;959    	val1 = ((valTemp >> 8) & 0xFF);
;;;960    	val2 = (valTemp & 0xFF);
;;;961    	UART_PROTOCOLIOT_TxAddData(val1);
00027a  4620              MOV      r0,r4
00027c  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;962    	UART_PROTOCOLIOT_TxAddData(val2);
000280  4628              MOV      r0,r5
000282  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;963    	
;;;964    	// 上电以来平均速度
;;;965    	valTemp = 0;
;;;966    	val1 = ((valTemp >> 8) & 0xFF);
;;;967    	val2 = (valTemp & 0xFF);
;;;968    	UART_PROTOCOLIOT_TxAddData(val1);
000286  4620              MOV      r0,r4
000288  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;969    	UART_PROTOCOLIOT_TxAddData(val2);
00028c  4628              MOV      r0,r5
00028e  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;970    	
;;;971    	UART_PROTOCOLIOT_TxAddFrame();
000292  e8bd47f0          POP      {r4-r10,lr}
000296  f7ffbffe          B.W      UART_PROTOCOLIOT_TxAddFrame
;;;972    }
;;;973    
                          ENDP

00029a  0000              DCW      0x0000
                  |L16.668|
                          DCD      ||.bss||
                  |L16.672|
                          DCD      paramCB+0x33c
                  |L16.676|
                          DCD      0x3e322d0e
                  |L16.680|
                          DCD      0x3c5ed289

                          AREA ||i.UART_PROTOCOLIOT_SendCmdState2Data||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOLIOT_SendCmdState2Data PROC
;;;974    // 状态组2数据回复
;;;975    void UART_PROTOCOLIOT_SendCmdState2Data(void)
000000  b510              PUSH     {r4,lr}
;;;976    {
;;;977    	int i = 0;
000002  2400              MOVS     r4,#0
;;;978    	
;;;979    	uartProtocolCBIOT.cmdStyle &= (~0x02);
000004  4821              LDR      r0,|L17.140|
000006  f8b016ee          LDRH     r1,[r0,#0x6ee]  ; uartProtocolCBIOT
00000a  f0210102          BIC      r1,r1,#2
00000e  f8a016ee          STRH     r1,[r0,#0x6ee]
;;;980    	
;;;981    	UART_PROTOCOLIOT_TxAddData(UART_PROTOCOLIOT_CMD_HEAD); 		
000012  2055              MOVS     r0,#0x55
000014  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;982    	UART_PROTOCOLIOT_TxAddData((UART_PROTOCOLIOT_HMI_DDR << 4) | (UART_PROTOCOLIOT_IOT_ADD));
000018  2009              MOVS     r0,#9
00001a  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;983    	UART_PROTOCOLIOT_TxAddData(UART_PROTOCOLIOT_CMD_GET_CONDATA); 	
00001e  2003              MOVS     r0,#3
000020  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;984    	UART_PROTOCOLIOT_TxAddData(0x02);
000024  2002              MOVS     r0,#2
000026  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;985    	
;;;986    	// 状态组2编号
;;;987    	UART_PROTOCOLIOT_TxAddData(0x02);
00002a  2002              MOVS     r0,#2
00002c  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;988    	
;;;989    	// 剩余电量
;;;990    	UART_PROTOCOLIOT_TxAddData(0x02);
000030  2002              MOVS     r0,#2
000032  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;991    	
;;;992    	// 剩余续航
;;;993    	UART_PROTOCOLIOT_TxAddData(0x02);
000036  2002              MOVS     r0,#2
000038  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
                  |L17.60|
;;;994    	
;;;995    	// 电池序列号
;;;996    	for (i = 0;i < 32;i++)
;;;997    	{
;;;998    		UART_PROTOCOLIOT_TxAddData(0);
00003c  2000              MOVS     r0,#0
00003e  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
000042  1c64              ADDS     r4,r4,#1              ;996
000044  2c20              CMP      r4,#0x20              ;996
000046  dbf9              BLT      |L17.60|
;;;999    	}
;;;1000   	
;;;1001   	// 电池充放电次数
;;;1002   	UART_PROTOCOLIOT_TxAddData(0);
000048  2000              MOVS     r0,#0
00004a  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1003   	UART_PROTOCOLIOT_TxAddData(0);
00004e  2000              MOVS     r0,#0
000050  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1004   	
;;;1005   	// 电池损耗率
;;;1006   	UART_PROTOCOLIOT_TxAddData(0);
000054  2000              MOVS     r0,#0
000056  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1007   	UART_PROTOCOLIOT_TxAddData(0);
00005a  2000              MOVS     r0,#0
00005c  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1008   
;;;1009   	// 设计容量
;;;1010   	UART_PROTOCOLIOT_TxAddData(0);
000060  2000              MOVS     r0,#0
000062  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1011   	UART_PROTOCOLIOT_TxAddData(0);
000066  2000              MOVS     r0,#0
000068  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1012   
;;;1013   	// 满充容量
;;;1014   	UART_PROTOCOLIOT_TxAddData(0);
00006c  2000              MOVS     r0,#0
00006e  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1015   	UART_PROTOCOLIOT_TxAddData(0);
000072  2000              MOVS     r0,#0
000074  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1016   
;;;1017   	// 剩余容量
;;;1018   	UART_PROTOCOLIOT_TxAddData(0);
000078  2000              MOVS     r0,#0
00007a  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1019   	UART_PROTOCOLIOT_TxAddData(0);
00007e  2000              MOVS     r0,#0
000080  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1020   	
;;;1021   	UART_PROTOCOLIOT_TxAddFrame();
000084  e8bd4010          POP      {r4,lr}
000088  f7ffbffe          B.W      UART_PROTOCOLIOT_TxAddFrame
;;;1022   }
;;;1023   
                          ENDP

                  |L17.140|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOLIOT_SendCmdState3Data||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOLIOT_SendCmdState3Data PROC
;;;1024   // 状态组3数据回复
;;;1025   void UART_PROTOCOLIOT_SendCmdState3Data(void)
000000  b510              PUSH     {r4,lr}
;;;1026   {
;;;1027   	uint8 val1;
;;;1028   	
;;;1029   	uartProtocolCBIOT.cmdStyle &= (~0x04);
000002  4823              LDR      r0,|L18.144|
000004  f8b016ee          LDRH     r1,[r0,#0x6ee]  ; uartProtocolCBIOT
000008  f0210104          BIC      r1,r1,#4
00000c  f8a016ee          STRH     r1,[r0,#0x6ee]
;;;1030   	
;;;1031   	UART_PROTOCOLIOT_TxAddData(UART_PROTOCOLIOT_CMD_HEAD); 		
000010  2055              MOVS     r0,#0x55
000012  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1032   	UART_PROTOCOLIOT_TxAddData((UART_PROTOCOLIOT_HMI_DDR << 4) | (UART_PROTOCOLIOT_IOT_ADD));
000016  2009              MOVS     r0,#9
000018  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1033   	UART_PROTOCOLIOT_TxAddData(UART_PROTOCOLIOT_CMD_GET_CONDATA); 	
00001c  2003              MOVS     r0,#3
00001e  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1034   	UART_PROTOCOLIOT_TxAddData(0x02);
000022  2002              MOVS     r0,#2
000024  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1035   		
;;;1036   	// 状态组3编号
;;;1037   	UART_PROTOCOLIOT_TxAddData(0x03);
000028  2003              MOVS     r0,#3
00002a  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1038   	
;;;1039   	// 大灯状态
;;;1040   	val1 = (uint8)PARAM_GetLightSwitch();
00002e  4c19              LDR      r4,|L18.148|
000030  f8940202          LDRB     r0,[r4,#0x202]  ; paramCB
;;;1041   	UART_PROTOCOLIOT_TxAddData(val1);
000034  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1042   	
;;;1043   	// 自动关机时间
;;;1044   	val1 = PARAM_GetPowerOffTime();
000038  f8940321          LDRB     r0,[r4,#0x321]  ; paramCB
;;;1045   	UART_PROTOCOLIOT_TxAddData(val1);
00003c  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1046   	
;;;1047   	// 限速值
;;;1048   	val1 = paramCB.nvm.param.common.speed.limitVal/10;
000040  f8b40334          LDRH     r0,[r4,#0x334]  ; paramCB
000044  210a              MOVS     r1,#0xa
000046  fbb0f0f1          UDIV     r0,r0,r1
00004a  b2c0              UXTB     r0,r0
;;;1049   	UART_PROTOCOLIOT_TxAddData(val1);
00004c  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1050   	
;;;1051   	// 显示单位
;;;1052   	val1 = PARAM_GetUnit();
000050  f8940319          LDRB     r0,[r4,#0x319]  ; paramCB
;;;1053   	UART_PROTOCOLIOT_TxAddData(val1);
000054  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1054   	
;;;1055   	// 助力档位
;;;1056   	val1 = (uint8)PARAM_GetAssistLevel();
000058  f7fffffe          BL       PARAM_GetAssistLevel
;;;1057   	UART_PROTOCOLIOT_TxAddData(val1);
00005c  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1058   	
;;;1059   	// 锁车状态
;;;1060   	UART_PROTOCOLIOT_TxAddData(0x00);
000060  2000              MOVS     r0,#0
000062  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1061   	
;;;1062   	// 仪表背光亮度
;;;1063   	val1 = PARAM_GetBrightness();
000066  f8940320          LDRB     r0,[r4,#0x320]  ; paramCB
;;;1064   	UART_PROTOCOLIOT_TxAddData(val1);
00006a  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1065   	
;;;1066   	// 启动方式
;;;1067   	UART_PROTOCOLIOT_TxAddData(0x01);
00006e  2001              MOVS     r0,#1
000070  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1068   	
;;;1069   	// 巡航模式
;;;1070   	UART_PROTOCOLIOT_TxAddData(0x01);
000074  2001              MOVS     r0,#1
000076  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1071   	
;;;1072   	// 开关机状态
;;;1073   	UART_PROTOCOLIOT_TxAddData(0x01);
00007a  2001              MOVS     r0,#1
00007c  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1074   	
;;;1075   	// 车辆锁定状态
;;;1076   	UART_PROTOCOLIOT_TxAddData(0x01);
000080  2001              MOVS     r0,#1
000082  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1077   	
;;;1078   	UART_PROTOCOLIOT_TxAddFrame();
000086  e8bd4010          POP      {r4,lr}
00008a  f7ffbffe          B.W      UART_PROTOCOLIOT_TxAddFrame
;;;1079   }
;;;1080   
                          ENDP

00008e  0000              DCW      0x0000
                  |L18.144|
                          DCD      ||.bss||
                  |L18.148|
                          DCD      paramCB

                          AREA ||i.UART_PROTOCOLIOT_SendCmdState4Data||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOLIOT_SendCmdState4Data PROC
;;;1081   // 状态组4数据回复
;;;1082   void UART_PROTOCOLIOT_SendCmdState4Data(void)
000000  b530              PUSH     {r4,r5,lr}
;;;1083   {
;;;1084   	uint8 val1, val2;
;;;1085   	uint32 valTemp;
;;;1086   	
;;;1087   	uartProtocolCBIOT.cmdStyle &= (~0x08);
000002  4817              LDR      r0,|L19.96|
000004  f8b016ee          LDRH     r1,[r0,#0x6ee]  ; uartProtocolCBIOT
000008  f0210108          BIC      r1,r1,#8
00000c  f8a016ee          STRH     r1,[r0,#0x6ee]
;;;1088   	
;;;1089   	UART_PROTOCOLIOT_TxAddData(UART_PROTOCOLIOT_CMD_HEAD); 		
000010  2055              MOVS     r0,#0x55
000012  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1090   	UART_PROTOCOLIOT_TxAddData((UART_PROTOCOLIOT_HMI_DDR << 4) | (UART_PROTOCOLIOT_IOT_ADD));
000016  2009              MOVS     r0,#9
000018  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1091   	UART_PROTOCOLIOT_TxAddData(UART_PROTOCOLIOT_CMD_GET_CONDATA); 	
00001c  2003              MOVS     r0,#3
00001e  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1092   	UART_PROTOCOLIOT_TxAddData(0x02);
000022  2002              MOVS     r0,#2
000024  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1093   		
;;;1094   	// 状态组4编号
;;;1095   	UART_PROTOCOLIOT_TxAddData(0x04);
000028  2004              MOVS     r0,#4
00002a  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1096   	
;;;1097   	// 实时速度
;;;1098   	valTemp = paramCB.runtime.speed;
00002e  4d0d              LDR      r5,|L19.100|
000030  f8b50218          LDRH     r0,[r5,#0x218]  ; paramCB
;;;1099   	val1 = ((valTemp >> 8) & 0xFF);
000034  0a01              LSRS     r1,r0,#8
;;;1100   	val2 = (valTemp & 0xFF);
000036  b2c4              UXTB     r4,r0
;;;1101   	UART_PROTOCOLIOT_TxAddData(val1);
000038  4608              MOV      r0,r1
00003a  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1102   	UART_PROTOCOLIOT_TxAddData(val2);
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1103   	
;;;1104   	// 实时功率
;;;1105   	valTemp = paramCB.runtime.power;
000044  f8b5022e          LDRH     r0,[r5,#0x22e]  ; paramCB
;;;1106   	val1 = ((valTemp >> 8) & 0xFF);
000048  0a01              LSRS     r1,r0,#8
;;;1107   	val2 = (valTemp & 0xFF);
00004a  b2c4              UXTB     r4,r0
;;;1108   	UART_PROTOCOLIOT_TxAddData(val1);
00004c  4608              MOV      r0,r1
00004e  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1109   	UART_PROTOCOLIOT_TxAddData(val2);
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1110   	
;;;1111   	UART_PROTOCOLIOT_TxAddFrame();
000058  e8bd4030          POP      {r4,r5,lr}
00005c  f7ffbffe          B.W      UART_PROTOCOLIOT_TxAddFrame
;;;1112   }
;;;1113   
                          ENDP

                  |L19.96|
                          DCD      ||.bss||
                  |L19.100|
                          DCD      paramCB

                          AREA ||i.UART_PROTOCOLIOT_SendCmdStyle||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOLIOT_SendCmdStyle PROC
;;;735    // 获取发送CMD类型
;;;736    uint16 UART_PROTOCOLIOT_SendCmdStyle(void)
000000  4801              LDR      r0,|L20.8|
;;;737    {
;;;738    		return uartProtocolCBIOT.cmdStyle;
000002  f8b006ee          LDRH     r0,[r0,#0x6ee]  ; uartProtocolCBIOT
;;;739    }
000006  4770              BX       lr
;;;740    
                          ENDP

                  |L20.8|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOLIOT_SendCmdSystemData||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOLIOT_SendCmdSystemData PROC
;;;1114   // 整车系统数据回复
;;;1115   void UART_PROTOCOLIOT_SendCmdSystemData(void)
000000  b570              PUSH     {r4-r6,lr}
;;;1116   {
;;;1117   	uartProtocolCBIOT.cmdStyle &= (~0x10);
000002  484c              LDR      r0,|L21.308|
000004  f8b016ee          LDRH     r1,[r0,#0x6ee]  ; uartProtocolCBIOT
000008  f0210110          BIC      r1,r1,#0x10
00000c  f8a016ee          STRH     r1,[r0,#0x6ee]
;;;1118   	
;;;1119   	UART_PROTOCOLIOT_TxAddData(UART_PROTOCOLIOT_CMD_HEAD); 		
000010  2055              MOVS     r0,#0x55
000012  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1120   	UART_PROTOCOLIOT_TxAddData((UART_PROTOCOLIOT_HMI_DDR << 4) | (UART_PROTOCOLIOT_IOT_ADD));
000016  2009              MOVS     r0,#9
000018  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1121   	UART_PROTOCOLIOT_TxAddData(UART_PROTOCOLIOT_CMD_GET_BIKE_INFO); 	
00001c  2005              MOVS     r0,#5
00001e  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1122   	UART_PROTOCOLIOT_TxAddData(0x02);
000022  2002              MOVS     r0,#2
000024  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1123   	
;;;1124   	// 蓝牙MAC地址
;;;1125   	UART_PROTOCOLIOT_TxAddData((char_to_hex(bleUartCB.rx.macBuff[0]) << 4) | char_to_hex(bleUartCB.rx.macBuff[1]));
000028  4c43              LDR      r4,|L21.312|
00002a  7860              LDRB     r0,[r4,#1]  ; bleUartCB
00002c  f7fffffe          BL       char_to_hex
000030  4605              MOV      r5,r0
000032  7820              LDRB     r0,[r4,#0]  ; bleUartCB
000034  f7fffffe          BL       char_to_hex
000038  ea451000          ORR      r0,r5,r0,LSL #4
00003c  b2c0              UXTB     r0,r0
00003e  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1126   	UART_PROTOCOLIOT_TxAddData((char_to_hex(bleUartCB.rx.macBuff[3]) << 4) | char_to_hex(bleUartCB.rx.macBuff[4]));
000042  7920              LDRB     r0,[r4,#4]  ; bleUartCB
000044  f7fffffe          BL       char_to_hex
000048  4605              MOV      r5,r0
00004a  78e0              LDRB     r0,[r4,#3]  ; bleUartCB
00004c  f7fffffe          BL       char_to_hex
000050  ea451000          ORR      r0,r5,r0,LSL #4
000054  b2c0              UXTB     r0,r0
000056  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1127   	UART_PROTOCOLIOT_TxAddData((char_to_hex(bleUartCB.rx.macBuff[6]) << 4) | char_to_hex(bleUartCB.rx.macBuff[7]));
00005a  79e0              LDRB     r0,[r4,#7]  ; bleUartCB
00005c  f7fffffe          BL       char_to_hex
000060  4605              MOV      r5,r0
000062  79a0              LDRB     r0,[r4,#6]  ; bleUartCB
000064  f7fffffe          BL       char_to_hex
000068  ea451000          ORR      r0,r5,r0,LSL #4
00006c  b2c0              UXTB     r0,r0
00006e  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1128   	UART_PROTOCOLIOT_TxAddData((char_to_hex(bleUartCB.rx.macBuff[9]) << 4) | char_to_hex(bleUartCB.rx.macBuff[10]));
000072  7aa0              LDRB     r0,[r4,#0xa]  ; bleUartCB
000074  f7fffffe          BL       char_to_hex
000078  4605              MOV      r5,r0
00007a  7a60              LDRB     r0,[r4,#9]  ; bleUartCB
00007c  f7fffffe          BL       char_to_hex
000080  ea451000          ORR      r0,r5,r0,LSL #4
000084  b2c0              UXTB     r0,r0
000086  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1129   	UART_PROTOCOLIOT_TxAddData((char_to_hex(bleUartCB.rx.macBuff[12]) << 4) | char_to_hex(bleUartCB.rx.macBuff[13]));
00008a  7b60              LDRB     r0,[r4,#0xd]  ; bleUartCB
00008c  f7fffffe          BL       char_to_hex
000090  4605              MOV      r5,r0
000092  7b20              LDRB     r0,[r4,#0xc]  ; bleUartCB
000094  f7fffffe          BL       char_to_hex
000098  ea451000          ORR      r0,r5,r0,LSL #4
00009c  b2c0              UXTB     r0,r0
00009e  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1130   	UART_PROTOCOLIOT_TxAddData((char_to_hex(bleUartCB.rx.macBuff[15]) << 4) | char_to_hex(bleUartCB.rx.macBuff[16]));
0000a2  7c20              LDRB     r0,[r4,#0x10]  ; bleUartCB
0000a4  f7fffffe          BL       char_to_hex
0000a8  4605              MOV      r5,r0
0000aa  7be0              LDRB     r0,[r4,#0xf]  ; bleUartCB
0000ac  f7fffffe          BL       char_to_hex
0000b0  ea451000          ORR      r0,r5,r0,LSL #4
0000b4  b2c0              UXTB     r0,r0
0000b6  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1131   	
;;;1132   	// 车型编码
;;;1133   	UART_PROTOCOLIOT_TxAddData(paramCB.nvm.param.protocol.carModel[0]);
0000ba  4c20              LDR      r4,|L21.316|
0000bc  f89402c3          LDRB     r0,[r4,#0x2c3]  ; paramCB
0000c0  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1134   	UART_PROTOCOLIOT_TxAddData(paramCB.nvm.param.protocol.carModel[1]);
0000c4  f89402c4          LDRB     r0,[r4,#0x2c4]  ; paramCB
0000c8  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1135   	
;;;1136   	// 仪表型号
;;;1137   	UART_PROTOCOLIOT_TxAddData(DEV_VERSION[0]);
0000cc  2051              MOVS     r0,#0x51
0000ce  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1138   	UART_PROTOCOLIOT_TxAddData(DEV_VERSION[1]);
0000d2  2048              MOVS     r0,#0x48
0000d4  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1139   	UART_PROTOCOLIOT_TxAddData(DEV_VERSION[2]);
0000d8  2062              MOVS     r0,#0x62
0000da  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1140   	
;;;1141   	// 仪表版本
;;;1142   	UART_PROTOCOLIOT_TxAddData(DEV_VERSION_REMAIN);
0000de  2000              MOVS     r0,#0
0000e0  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1143   	UART_PROTOCOLIOT_TxAddData(DEV_RELEASE_VERSION);
0000e4  2004              MOVS     r0,#4
0000e6  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1144   	UART_PROTOCOLIOT_TxAddData(FW_UPDATE_VERSION);
0000ea  2000              MOVS     r0,#0
0000ec  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1145   	UART_PROTOCOLIOT_TxAddData(FW_DEBUG_RELEASE_VERSION);
0000f0  2013              MOVS     r0,#0x13
0000f2  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1146   	
;;;1147   	// 仪表版本编号
;;;1148   	UART_PROTOCOLIOT_TxAddData(FW_BINNUM);
0000f6  2001              MOVS     r0,#1
0000f8  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1149   	
;;;1150   	// 控制器版本
;;;1151   	UART_PROTOCOLIOT_TxAddData(0);
0000fc  2000              MOVS     r0,#0
0000fe  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1152   	UART_PROTOCOLIOT_TxAddData(0);
000102  2000              MOVS     r0,#0
000104  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1153   	UART_PROTOCOLIOT_TxAddData(0);
000108  2000              MOVS     r0,#0
00010a  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1154   	
;;;1155   	// 控制器版本编号
;;;1156   	UART_PROTOCOLIOT_TxAddData(0);
00010e  2000              MOVS     r0,#0
000110  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1157   	
;;;1158   	// 电池版本
;;;1159   	UART_PROTOCOLIOT_TxAddData(0);
000114  2000              MOVS     r0,#0
000116  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1160   	UART_PROTOCOLIOT_TxAddData(0);
00011a  2000              MOVS     r0,#0
00011c  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1161   	UART_PROTOCOLIOT_TxAddData(0);
000120  2000              MOVS     r0,#0
000122  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1162   	
;;;1163   	// 电池版本编号
;;;1164   	UART_PROTOCOLIOT_TxAddData(0);
000126  2000              MOVS     r0,#0
000128  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;1165   	
;;;1166   	UART_PROTOCOLIOT_TxAddFrame();
00012c  e8bd4070          POP      {r4-r6,lr}
000130  f7ffbffe          B.W      UART_PROTOCOLIOT_TxAddFrame
;;;1167   }
;;;1168   
                          ENDP

                  |L21.308|
                          DCD      ||.bss||
                  |L21.312|
                          DCD      bleUartCB+0x50f
                  |L21.316|
                          DCD      paramCB

                          AREA ||i.UART_PROTOCOLIOT_SendCmdWithResult||, CODE, READONLY, ALIGN=1

                  UART_PROTOCOLIOT_SendCmdWithResult PROC
;;;698    // 发送命令带结果
;;;699    void UART_PROTOCOLIOT_SendCmdWithResult(uint8 cmdWord, uint8 result)
000000  b530              PUSH     {r4,r5,lr}
;;;700    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;701    	// 添加命令头
;;;702    	UART_PROTOCOLIOT_TxAddData(UART_PROTOCOLIOT_CMD_HEAD);
000006  2055              MOVS     r0,#0x55
000008  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;703    
;;;704    	// 添加设备地址
;;;705    	UART_PROTOCOLIOT_TxAddData((UART_PROTOCOLIOT_HMI_DDR << 4) | (UART_PROTOCOLIOT_IOT_ADD));
00000c  2009              MOVS     r0,#9
00000e  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;706    
;;;707    	// 添加命令字
;;;708    	UART_PROTOCOLIOT_TxAddData(cmdWord);
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;709    
;;;710    	// 添加数据长度
;;;711    	UART_PROTOCOLIOT_TxAddData(1);
000018  2001              MOVS     r0,#1
00001a  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;712    	
;;;713    	UART_PROTOCOLIOT_TxAddData(result);
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       UART_PROTOCOLIOT_TxAddData
;;;714    	
;;;715    	UART_PROTOCOLIOT_TxAddFrame();
000024  e8bd4030          POP      {r4,r5,lr}
000028  f7ffbffe          B.W      UART_PROTOCOLIOT_TxAddFrame
;;;716    }
;;;717    
                          ENDP


                          AREA ||i.UART_PROTOCOLIOT_StartTimeoutCheckTask||, CODE, READONLY, ALIGN=1

                  UART_PROTOCOLIOT_StartTimeoutCheckTask PROC
;;;76     // 启动通讯超时判断任务
;;;77     void UART_PROTOCOLIOT_StartTimeoutCheckTask(void)
000000  4770              BX       lr
;;;78     {
;;;79     /*
;;;80     	// 清除通讯异常
;;;81     	if(ERROR_TYPE_COMMUNICATION_TIME_OUT == PARAM_GetErrorCode())
;;;82     	{
;;;83     		PARAM_SetErrorCode(ERROR_TYPE_NO_ERROR);
;;;84     	}
;;;85     
;;;86     	// 开启UART通讯超时定时器
;;;87     #if __SYSTEM_NO_TIME_OUT_ERROR__		// 研发调试时不启用
;;;88     #else
;;;89     	TIMER_AddTask(TIMER_ID_UART_TXRX_TIME_OUT,
;;;90     					PARAM_GetBusAliveTime(),
;;;91     					UART_PROTOCOLIOT_CALLBACK_UartBusError,
;;;92     					TRUE,
;;;93     					1,
;;;94     					ACTION_MODE_ADD_TO_QUEUE);
;;;95     #endif
;;;96     */
;;;97     }
;;;98     
                          ENDP


                          AREA ||i.UART_PROTOCOLIOT_TxAddData||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOLIOT_TxAddData PROC
;;;125    // 向发送命令帧队列中添加数据
;;;126    void UART_PROTOCOLIOT_TxAddData(uint8 data)
000000  b530              PUSH     {r4,r5,lr}
;;;127    {
;;;128    	uint16 head = uartProtocolCBIOT.tx.head;
000002  490f              LDR      r1,|L24.64|
000004  f8b146d6          LDRH     r4,[r1,#0x6d6]  ; uartProtocolCBIOT
;;;129    	uint16 end =  uartProtocolCBIOT.tx.end;
000008  f8b126d8          LDRH     r2,[r1,#0x6d8]  ; uartProtocolCBIOT
;;;130    	UART_PROTOCOLIOT_TX_CMD_FRAME* pCmdFrame = &uartProtocolCBIOT.tx.cmdQueue[uartProtocolCBIOT.tx.end];
00000c  234d              MOVS     r3,#0x4d
00000e  4353              MULS     r3,r2,r3
000010  eb010143          ADD      r1,r1,r3,LSL #1
000014  f5017175          ADD      r1,r1,#0x3d4
;;;131    
;;;132    	// 发送缓冲区已满，不予接收
;;;133    	if((end + 1) % UART_PROTOCOLIOT_TX_QUEUE_SIZE == head)
000018  1c52              ADDS     r2,r2,#1
00001a  2305              MOVS     r3,#5
00001c  fbb2f5f3          UDIV     r5,r2,r3
000020  fb032215          MLS      r2,r3,r5,r2
000024  42a2              CMP      r2,r4
000026  d009              BEQ      |L24.60|
;;;134    	{
;;;135    		return;
;;;136    	}
;;;137    	
;;;138    	// 队尾命令帧已满，退出
;;;139    	if(pCmdFrame->length >= UART_PROTOCOLIOT_TX_CMD_FRAME_LENGTH_MAX)
000028  f8b12098          LDRH     r2,[r1,#0x98]
00002c  2a96              CMP      r2,#0x96
00002e  d205              BCS      |L24.60|
;;;140    	{
;;;141    		return;
;;;142    	}
;;;143    
;;;144    	// 数据添加到帧末尾，并更新帧长度
;;;145    	pCmdFrame->buff[pCmdFrame->length] = data;
000030  1c8b              ADDS     r3,r1,#2
000032  54d0              STRB     r0,[r2,r3]
;;;146    	pCmdFrame->length ++;
000034  f8310f98          LDRH     r0,[r1,#0x98]!
000038  1c40              ADDS     r0,r0,#1
00003a  8008              STRH     r0,[r1,#0]
                  |L24.60|
;;;147    }
00003c  bd30              POP      {r4,r5,pc}
;;;148    
                          ENDP

00003e  0000              DCW      0x0000
                  |L24.64|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOLIOT_TxAddFrame||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOLIOT_TxAddFrame PROC
;;;149    // 确认添加命令帧，即承认之前填充的数据为命令帧，将其添加到发送队列中，由main进行调度发送，本函数内会自动校正命令长度，并添加校验码
;;;150    void UART_PROTOCOLIOT_TxAddFrame(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;151    {
;;;152    	uint8 checkSum = 0;
000002  2300              MOVS     r3,#0
;;;153    	uint16 i = 0;
000004  2100              MOVS     r1,#0
;;;154    	uint16 head = uartProtocolCBIOT.tx.head;
000006  4d1c              LDR      r5,|L25.120|
000008  f8b576d6          LDRH     r7,[r5,#0x6d6]  ; uartProtocolCBIOT
;;;155    	uint16 end  = uartProtocolCBIOT.tx.end;
00000c  f8b546d8          LDRH     r4,[r5,#0x6d8]  ; uartProtocolCBIOT
;;;156    	UART_PROTOCOLIOT_TX_CMD_FRAME* pCmdFrame = &uartProtocolCBIOT.tx.cmdQueue[uartProtocolCBIOT.tx.end];
000010  204d              MOVS     r0,#0x4d
000012  4360              MULS     r0,r4,r0
000014  eb050040          ADD      r0,r5,r0,LSL #1
000018  f5007075          ADD      r0,r0,#0x3d4
;;;157    	uint16 length = pCmdFrame->length;
00001c  f8b02098          LDRH     r2,[r0,#0x98]
;;;158    
;;;159    	// 发送缓冲区已满，不予接收
;;;160    	if((end + 1) % UART_PROTOCOLIOT_TX_QUEUE_SIZE == head)
000020  1c64              ADDS     r4,r4,#1
000022  2605              MOVS     r6,#5
000024  fbb4fcf6          UDIV     r12,r4,r6
000028  fb06441c          MLS      r4,r6,r12,r4
00002c  42bc              CMP      r4,r7
00002e  d003              BEQ      |L25.56|
;;;161    	{
;;;162    		return;
;;;163    	}
;;;164    	
;;;165    	// 命令帧长度不足，清除已填充的数据，退出
;;;166    	if(UART_PROTOCOLIOT_CMD_FRAME_LENGTH_MIN-1 > length)	// 减去"校验"1个字节
000030  2a04              CMP      r2,#4
000032  d202              BCS      |L25.58|
;;;167    	{
;;;168    		pCmdFrame->length = 0;
000034  f8a01098          STRH     r1,[r0,#0x98]
                  |L25.56|
;;;169    		
;;;170    		return;
;;;171    	}
;;;172    
;;;173    	// 队尾命令帧已满，退出
;;;174    	if(length >= UART_PROTOCOLIOT_TX_CMD_FRAME_LENGTH_MAX)
;;;175    	{
;;;176    		return;
;;;177    	}
;;;178    
;;;179    	// 重新设置数据长度，系统在准备数据时，填充的"数据长度"可以为任意值，并且不需要添加校验码，在这里重新设置为正确的值
;;;180    	pCmdFrame->buff[UART_PROTOCOLIOT_CMD_LENGTH_INDEX] = length - 4;	// 重设数据长度，减去"命令头、设备地址、命令字、数据长度"4个字节
;;;181    	
;;;182    	for(i=0; i<length; i++)
;;;183    	{
;;;184    		checkSum ^= pCmdFrame->buff[i];
;;;185    	}
;;;186    	pCmdFrame->buff[pCmdFrame->length++] = ~checkSum ;		
;;;187    
;;;188    	uartProtocolCBIOT.tx.end ++;
;;;189    	uartProtocolCBIOT.tx.end %= UART_PROTOCOLIOT_TX_QUEUE_SIZE;
;;;190    	//pCB->tx.cmdQueue[pCB->tx.end].length = 0;   //2015.12.2修改
;;;191    }
000038  bdf0              POP      {r4-r7,pc}
                  |L25.58|
00003a  2a96              CMP      r2,#0x96              ;174
00003c  d2fc              BCS      |L25.56|
00003e  1f14              SUBS     r4,r2,#4              ;180
000040  7144              STRB     r4,[r0,#5]            ;180
000042  e004              B        |L25.78|
                  |L25.68|
000044  1844              ADDS     r4,r0,r1              ;184
000046  78a4              LDRB     r4,[r4,#2]            ;184
000048  4063              EORS     r3,r3,r4              ;184
00004a  1c49              ADDS     r1,r1,#1              ;182
00004c  b289              UXTH     r1,r1                 ;182
                  |L25.78|
00004e  4291              CMP      r1,r2                 ;182
000050  d3f8              BCC      |L25.68|
000052  f8b01098          LDRH     r1,[r0,#0x98]         ;186
000056  43db              MVNS     r3,r3                 ;186
000058  1c4a              ADDS     r2,r1,#1              ;186
00005a  f8a02098          STRH     r2,[r0,#0x98]         ;186
00005e  4408              ADD      r0,r0,r1              ;186
000060  7083              STRB     r3,[r0,#2]            ;186
000062  f8b506d8          LDRH     r0,[r5,#0x6d8]        ;188  ; uartProtocolCBIOT
000066  1c40              ADDS     r0,r0,#1              ;188
000068  b280              UXTH     r0,r0                 ;188
00006a  fbb0f1f6          UDIV     r1,r0,r6              ;189
00006e  fb060011          MLS      r0,r6,r1,r0           ;189
000072  f8a506d8          STRH     r0,[r5,#0x6d8]        ;189
000076  bdf0              POP      {r4-r7,pc}
;;;192    
                          ENDP

                  |L25.120|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOLIOT_TxStateProcess||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOLIOT_TxStateProcess PROC
;;;284    // 协议层发送处理过程
;;;285    void UART_PROTOCOLIOT_TxStateProcess(void)
000000  b570              PUSH     {r4-r6,lr}
;;;286    {
;;;287    	uint16 head = uartProtocolCBIOT.tx.head;
000002  4c14              LDR      r4,|L26.84|
000004  f8b436d6          LDRH     r3,[r4,#0x6d6]  ; uartProtocolCBIOT
;;;288    	uint16 end =  uartProtocolCBIOT.tx.end;
000008  f8b466d8          LDRH     r6,[r4,#0x6d8]  ; uartProtocolCBIOT
;;;289    	uint16 length = uartProtocolCBIOT.tx.cmdQueue[head].length;
00000c  204d              MOVS     r0,#0x4d
00000e  4358              MULS     r0,r3,r0
000010  eb040040          ADD      r0,r4,r0,LSL #1
000014  4605              MOV      r5,r0
000016  f8b0246c          LDRH     r2,[r0,#0x46c]
;;;290    	uint8* pCmd = uartProtocolCBIOT.tx.cmdQueue[head].buff;
00001a  f20031d6          ADD      r1,r0,#0x3d6
;;;291    	uint16 localDeviceID = uartProtocolCBIOT.tx.cmdQueue[head].deviceID;
00001e  f8b003d4          LDRH     r0,[r0,#0x3d4]
;;;292    
;;;293    	// 发送缓冲区为空，说明无数据
;;;294    	if (head == end)
000022  42b3              CMP      r3,r6
000024  d014              BEQ      |L26.80|
;;;295    	{
;;;296    		return;
;;;297    	}
;;;298    
;;;299    	// 发送函数没有注册直接返回
;;;300    	if (NULL == uartProtocolCBIOT.sendDataThrowService)
000026  f8d436e0          LDR      r3,[r4,#0x6e0]  ; uartProtocolCBIOT
00002a  2b00              CMP      r3,#0
00002c  d010              BEQ      |L26.80|
;;;301    	{
;;;302    		return;
;;;303    	}
;;;304    
;;;305    	// 协议层有数据需要发送到驱动层		
;;;306    	if (!(*uartProtocolCBIOT.sendDataThrowService)(localDeviceID, pCmd, length))
00002e  4798              BLX      r3
000030  2800              CMP      r0,#0
000032  d00d              BEQ      |L26.80|
;;;307    	{
;;;308    		return;
;;;309    	}
;;;310    
;;;311    	// 发送环形队列更新位置
;;;312    	uartProtocolCBIOT.tx.cmdQueue[head].length = 0;
000034  2000              MOVS     r0,#0
000036  f8a5046c          STRH     r0,[r5,#0x46c]
;;;313    	uartProtocolCBIOT.tx.head ++;
00003a  f8b406d6          LDRH     r0,[r4,#0x6d6]  ; uartProtocolCBIOT
00003e  1c40              ADDS     r0,r0,#1
000040  b280              UXTH     r0,r0
;;;314    	uartProtocolCBIOT.tx.head %= UART_PROTOCOLIOT_TX_QUEUE_SIZE;
000042  2105              MOVS     r1,#5
000044  fbb0f2f1          UDIV     r2,r0,r1
000048  fb010012          MLS      r0,r1,r2,r0
00004c  f8a406d6          STRH     r0,[r4,#0x6d6]
                  |L26.80|
;;;315    }
000050  bd70              POP      {r4-r6,pc}
;;;316    
                          ENDP

000052  0000              DCW      0x0000
                  |L26.84|
                          DCD      ||.bss||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  uartProtocolCBIOT
                          %        1780

;*** Start embedded assembler ***

#line 1 "User\\UartProtocolIOT.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___17_UartProtocolIOT_c_37ceb534____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___17_UartProtocolIOT_c_37ceb534____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___17_UartProtocolIOT_c_37ceb534____REVSH|
#line 128
|__asm___17_UartProtocolIOT_c_37ceb534____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
