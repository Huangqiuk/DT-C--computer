; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\dutuartprotocol.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\dutuartprotocol.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -I.\User\qrencode -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.3\Device\Include -D__MICROLIB -D__UVISION_VERSION=539 -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\dutuartprotocol.crf User\DutUartProtocol.c]
                          THUMB

                          AREA ||i.DUT_PROTOCOL_CheckSUM||, CODE, READONLY, ALIGN=1

                  DUT_PROTOCOL_CheckSUM PROC
;;;450    // 对传入的命令帧进行校验，返回校验结果
;;;451    BOOL DUT_PROTOCOL_CheckSUM(DUT_PROTOCOL_RX_CMD_FRAME *pCmdFrame)
000000  b530              PUSH     {r4,r5,lr}
;;;452    {
;;;453        uint16 cc = 0;
000002  2200              MOVS     r2,#0
;;;454        uint16 i = 0;
000004  2100              MOVS     r1,#0
;;;455    
;;;456        if (NULL == pCmdFrame)
000006  2800              CMP      r0,#0
000008  d003              BEQ      |L1.18|
;;;457        {
;;;458            return FALSE;
;;;459        }
;;;460    
;;;461        // 从命令头开始，到校验码之前的一个字节，依次进行异或运算
;;;462        for (i = 0; i < pCmdFrame->length - 1; i++)
00000a  f8b05052          LDRH     r5,[r0,#0x52]
00000e  1e6b              SUBS     r3,r5,#1
000010  e006              B        |L1.32|
                  |L1.18|
000012  2000              MOVS     r0,#0                 ;458
;;;463        {
;;;464            cc ^= pCmdFrame->buff[i];
;;;465        }
;;;466    
;;;467        // 判断计算得到的校验码与命令帧中的校验码是否相同
;;;468        if (pCmdFrame->buff[pCmdFrame->length - 1] != cc)
;;;469        {
;;;470            return FALSE;
;;;471        }
;;;472        return TRUE;
;;;473    }
000014  bd30              POP      {r4,r5,pc}
                  |L1.22|
000016  1844              ADDS     r4,r0,r1              ;464
000018  78a4              LDRB     r4,[r4,#2]            ;464
00001a  4062              EORS     r2,r2,r4              ;464
00001c  1c49              ADDS     r1,r1,#1              ;462
00001e  b289              UXTH     r1,r1                 ;462
                  |L1.32|
000020  428b              CMP      r3,r1                 ;462
000022  dcf8              BGT      |L1.22|
000024  1c40              ADDS     r0,r0,#1              ;468
000026  5c28              LDRB     r0,[r5,r0]            ;468
000028  4290              CMP      r0,r2                 ;468
00002a  d001              BEQ      |L1.48|
00002c  2000              MOVS     r0,#0                 ;470
00002e  bd30              POP      {r4,r5,pc}
                  |L1.48|
000030  2001              MOVS     r0,#1                 ;472
000032  bd30              POP      {r4,r5,pc}
;;;474    
                          ENDP


                          AREA ||i.DUT_PROTOCOL_CmdFrameProcess||, CODE, READONLY, ALIGN=2

                  DUT_PROTOCOL_CmdFrameProcess PROC
;;;475    // UART命令帧缓冲区处理
;;;476    void DUT_PROTOCOL_CmdFrameProcess(DUT_PROTOCOL_CB *pCB)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;477    {
000004  b09b              SUB      sp,sp,#0x6c
000006  4607              MOV      r7,r0
;;;478        DUT_PROTOCOL_CMD cmd = DUT_PROTOCOL_CMD_NULL;
;;;479        DUT_PROTOCOL_RX_CMD_FRAME *pCmdFrame = NULL;
;;;480    
;;;481        uint8 switch_state = 0;
;;;482        uint8 Peripheral_type = 0;
;;;483        uint8 calibration_result = 0;
;;;484        uint8 turn_item = 0;
;;;485        uint8 turn_state = 0;
;;;486        uint8 buffFlag[4] = {0xFF};
000008  48fd              LDR      r0,|L2.1024|
00000a  6800              LDR      r0,[r0,#0]  ; <Data2>
00000c  901a              STR      r0,[sp,#0x68]
;;;487        uint8 i =  0;
00000e  2500              MOVS     r5,#0
;;;488        uint8_t verType = 0;
;;;489        uint8_t infoLen = 0;
;;;490        char  verBuff[100] = {0};
000010  2164              MOVS     r1,#0x64
000012  a801              ADD      r0,sp,#4
000014  f7fffffe          BL       __aeabi_memclr4
;;;491        BOOL testResult = 0;
000018  2100              MOVS     r1,#0
;;;492    
;;;493        // 参数合法性检验
;;;494        if (NULL == pCB)
00001a  2f00              CMP      r7,#0
00001c  d018              BEQ      |L2.80|
;;;495        {
;;;496            return;
;;;497        }
;;;498    
;;;499        // 命令帧缓冲区为空，退出
;;;500        if (pCB->rx.head == pCB->rx.end)
00001e  f8b70274          LDRH     r0,[r7,#0x274]
000022  f8b72276          LDRH     r2,[r7,#0x276]
000026  4290              CMP      r0,r2
000028  d012              BEQ      |L2.80|
;;;501        {
;;;502            return;
;;;503        }
;;;504    
;;;505        // 获取当前要处理的命令帧指针
;;;506        pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.head];
00002a  ebc002c0          RSB      r2,r0,r0,LSL #3
00002e  eb020242          ADD      r2,r2,r2,LSL #1
000032  eb070482          ADD      r4,r7,r2,LSL #2
000036  34d0              ADDS     r4,r4,#0xd0
;;;507    
;;;508        // 命令头非法，退出
;;;509        if (DUT_PROTOCOL_CMD_HEAD != pCmdFrame->buff[DUT_PROTOCOL_CMD_HEAD_INDEX])
000038  78a2              LDRB     r2,[r4,#2]
00003a  2a55              CMP      r2,#0x55
00003c  d00b              BEQ      |L2.86|
;;;510        {
;;;511            // 删除命令帧
;;;512            pCB->rx.head++;
00003e  1c40              ADDS     r0,r0,#1
000040  b280              UXTH     r0,r0
;;;513            pCB->rx.head %= DUT_PROTOCOL_RX_QUEUE_SIZE;
000042  2105              MOVS     r1,#5
000044  fbb0f2f1          UDIV     r2,r0,r1
000048  fb010012          MLS      r0,r1,r2,r0
00004c  f8a70274          STRH     r0,[r7,#0x274]
                  |L2.80|
;;;514            return;
;;;515        }
;;;516    
;;;517        // 命令头合法，则提取命令
;;;518        cmd = (DUT_PROTOCOL_CMD)pCmdFrame->buff[DUT_PROTOCOL_CMD_CMD_INDEX];
;;;519    
;;;520        // 执行命令帧
;;;521        switch (cmd)
;;;522        {
;;;523            // 空命令，不予执行
;;;524            case DUT_PROTOCOL_CMD_NULL:
;;;525                break;
;;;526    
;;;527            // 收到大灯应答
;;;528            case DUT_PROTOCOL_CMD_HEADLIGHT_CONTROL:
;;;529                switch_state = pCmdFrame->buff[DUT_PROTOCOL_CMD_DATA1_INDEX];   // 执行结果
;;;530                light_cnt++;
;;;531    
;;;532                // 执行失败
;;;533                if (0x00 == switch_state)
;;;534                {
;;;535                    STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_MULTIPLE_TEST, FALSE);
;;;536                    TIMER_KillTask(TIMER_ID_DUT_TIMEOUT);
;;;537                }
;;;538    
;;;539                // 执行成功
;;;540                if (0x01 == (switch_state & 0x01))
;;;541                {
;;;542                    if (light_cnt == 1)
;;;543                    {
;;;544                        STATE_SwitchStep(STEP_HEADLIGHT_UART_TEST_OPEN);
;;;545                    }
;;;546                    if (light_cnt == 2)
;;;547                    {
;;;548                        STATE_SwitchStep(STEP_HEADLIGHT_UART_TEST_COMPLETE);
;;;549                        light_cnt = 0;
;;;550                    }
;;;551                }
;;;552                break;
;;;553    
;;;554            case DUT_PROTOCOL_CMD_GET_THROTTLE_BRAKE_AD:                      // 获取油门/刹车的模拟数字值
;;;555                Peripheral_type = pCmdFrame->buff[DUT_PROTOCOL_CMD_DATA1_INDEX];   // 外设类型
;;;556    
;;;557                // 油门
;;;558                if (0x01 == (Peripheral_type & 0x01))
;;;559                {
;;;560                    // 获取油门AD值
;;;561                    throttle.value = pCmdFrame->buff[DUT_PROTOCOL_CMD_DATA2_INDEX] << 8;
;;;562                    throttle.value = throttle.value | pCmdFrame->buff[DUT_PROTOCOL_CMD_DATA3_INDEX];
;;;563                    dut_info.throttleAd = throttle.value;
;;;564                    cnt++;
;;;565                    
;;;566                    switch (cnt)
;;;567                    {
;;;568                        case 0:
;;;569                            break;
;;;570    
;;;571                        case 1:
;;;572                            STATE_SwitchStep(STEP_THROTTLE_UART_TEST_CHECK_DAC1_VALUE);
;;;573                            break;
;;;574    
;;;575                        case 2:
;;;576                            STATE_SwitchStep(STEP_THROTTLE_UART_TEST_CHECK_DAC3_VALUE);
;;;577                            break;
;;;578    
;;;579                        case 3:
;;;580                            STATE_SwitchStep(STEP_THROTTLE_UART_TEST_CHECK_DAC5_VALUE);
;;;581                            cnt = 0;
;;;582                            break;
;;;583    
;;;584                        default:
;;;585                            break;
;;;586                    }
;;;587                }
;;;588    
;;;589                // 刹把
;;;590                if (0x02 == (Peripheral_type & 0x02))
;;;591                {
;;;592                    // 获取刹把AD值
;;;593                    brake.value = pCmdFrame->buff[DUT_PROTOCOL_CMD_DATA2_INDEX] << 8;
;;;594                    brake.value = brake.value | pCmdFrame->buff[DUT_PROTOCOL_CMD_DATA3_INDEX];
;;;595                    dut_info.brakeAd = brake.value;
;;;596                    brake_cnt++;
;;;597                    
;;;598                    switch (brake_cnt)
;;;599                    {
;;;600                        case 0:
;;;601                            break;
;;;602    
;;;603                        case 1:
;;;604                            STATE_SwitchStep(STEP_BRAKE_UART_TEST_CHECK_DAC1_VALUE);
;;;605                            break;
;;;606    
;;;607                        case 2:
;;;608                            STATE_SwitchStep(STEP_BRAKE_UART_TEST_CHECK_DAC3_VALUE);
;;;609                            break;
;;;610    
;;;611                        case 3:
;;;612                            STATE_SwitchStep(STEP_BRAKE_UART_TEST_CHECK_DAC5_VALUE);
;;;613                            brake_cnt = 0;
;;;614                            break;
;;;615    
;;;616                        default:
;;;617                            break;
;;;618                    }
;;;619                }
;;;620    
;;;621                // 电子变速
;;;622                if (0x03 == (Peripheral_type & 0x03))
;;;623                {
;;;624                    // 获取刹把AD值
;;;625                    derailleur.value = pCmdFrame->buff[DUT_PROTOCOL_CMD_DATA2_INDEX] << 8;
;;;626                    derailleur.value = derailleur.value | pCmdFrame->buff[DUT_PROTOCOL_CMD_DATA3_INDEX];
;;;627                    dut_info.derailleurAd = derailleur.value;
;;;628                    derailleur_cnt++;
;;;629                    
;;;630                    switch (derailleur_cnt)
;;;631                    {
;;;632                        case 0:
;;;633                            break;
;;;634    
;;;635                        case 1:
;;;636                            STATE_SwitchStep(STEP_DERAILLEUR_UART_TEST_CHECK_DAC1_VALUE);
;;;637                            break;
;;;638    
;;;639                        case 2:
;;;640                            STATE_SwitchStep(STEP_DERAILLEUR_UART_TEST_CHECK_DAC3_VALUE);
;;;641                            break;
;;;642    
;;;643                        case 3:
;;;644                            STATE_SwitchStep(STEP_DERAILLEUR_UART_TEST_CHECK_DAC5_VALUE);
;;;645                            derailleur_cnt = 0;
;;;646                            break;
;;;647    
;;;648                        default:
;;;649                            break;
;;;650                    }
;;;651                }
;;;652                
;;;653                break;
;;;654    
;;;655            // 转向灯控制
;;;656            case DUT_PROTOCOL_CMD_TURN_SIGNAL_CONTROL:
;;;657                turn_item = pCmdFrame->buff[DUT_PROTOCOL_CMD_DATA1_INDEX];   // 转向灯类型
;;;658                turn_state = pCmdFrame->buff[DUT_PROTOCOL_CMD_DATA2_INDEX];  // 执行结果
;;;659                light_cnt++;
;;;660    
;;;661                // 近光灯
;;;662                if ((turn_state) && (dut_info.test == TEST_TYPE_LBEAM) && (LBEAM == turn_item))
;;;663                {
;;;664                    if (light_cnt == 1)
;;;665                    {
;;;666                        STATE_SwitchStep(STEP_LBEAM_UART_TEST_OPEN);
;;;667                    }
;;;668                    if (light_cnt == 2)
;;;669                    {
;;;670                        STATE_SwitchStep(STEP_LBEAM_UART_TEST_COMPLETE);
;;;671                        light_cnt = 0;
;;;672                    }
;;;673                }
;;;674    
;;;675                // 远光灯
;;;676                if ((turn_state) && (dut_info.test == TEST_TYPE_HBEAM) && (HBEAM == turn_item))
;;;677                {
;;;678                    if (light_cnt == 1)
;;;679                    {
;;;680                        STATE_SwitchStep(STEP_HBEAM_UART_TEST_OPEN);
;;;681                    }
;;;682                    if (light_cnt == 2)
;;;683                    {
;;;684                        STATE_SwitchStep(STEP_HBEAM_UART_TEST_COMPLETE);
;;;685                        light_cnt = 0;
;;;686                    }
;;;687                }
;;;688    
;;;689                // 左转向灯
;;;690                if ((turn_state) && (dut_info.test == TEST_TYPE_LEFT_TURN_SIGNAL) && (LEFT_TURN_SIGNAL == turn_item))
;;;691                {
;;;692                    if (light_cnt == 1)
;;;693                    {
;;;694                        STATE_SwitchStep(STEP_LEFT_TURN_SIGNAL_UART_TEST_OPEN);
;;;695                    }
;;;696                    if (light_cnt == 2)
;;;697                    {
;;;698                        STATE_SwitchStep(STEP_LEFT_TURN_SIGNAL_UART_TEST_COMPLETE);
;;;699                        light_cnt = 0;
;;;700                    }
;;;701                }
;;;702    
;;;703                // 右转向灯
;;;704                if ((turn_state) && (dut_info.test == TEST_TYPE_RIGHT_TURN_SIGNAL) && (RIGHT_TURN_SIGNAL == turn_item))
;;;705                {
;;;706                    if (light_cnt == 1)
;;;707                    {
;;;708                        STATE_SwitchStep(STEP_RIGHT_TURN_SIGNAL_UART_TEST_OPEN);
;;;709                    }
;;;710                    if (light_cnt == 2)
;;;711                    {
;;;712                        STATE_SwitchStep(STEP_RIGHT_TURN_SIGNAL_UART_TEST_COMPLETE);
;;;713                        light_cnt = 0;
;;;714                    }
;;;715                }
;;;716    
;;;717                // 执行失败
;;;718                if (!switch_state)
;;;719                {
;;;720        #if DEBUG_ENABLE
;;;721                    Clear_All_Lines();
;;;722                    Display_Centered(1, "Fail to turn on");
;;;723        #endif
;;;724                    left_light_cnt = 0;
;;;725                    right_light_cnt = 0;
;;;726                    STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_MULTIPLE_TEST, FALSE);
;;;727                    TIMER_KillTask(TIMER_ID_DUT_TIMEOUT);
;;;728                }
;;;729                break;
;;;730    
;;;731            // 收到仪表的校准结果
;;;732            case DUT_PROTOCOL_CMD_VOLTAGE_CALIBRATION:
;;;733                cali_cnt++;
;;;734                calibration_result = pCmdFrame->buff[DUT_PROTOCOL_CMD_DATA1_INDEX];
;;;735    
;;;736                // 一级校准
;;;737                if ((calibration_result) && (dut_info.cali_cnt == 1))
;;;738                {
;;;739                    STATE_SwitchStep(STEP_CALIBRATION_UART_TEST_RESTORE_VOLTAGE_CALIBRATION);
;;;740                    cali_cnt = 0;
;;;741                }
;;;742    
;;;743                // 二级校准
;;;744                if ((calibration_result) && (dut_info.cali_cnt == 2))
;;;745                {
;;;746                    if (cali_cnt == 1)
;;;747                    {
;;;748                        STATE_SwitchStep(STEP_CALIBRATION_UART_TEST_TWO_NOTIFY_POWER_BOARD);
;;;749                    }
;;;750                    if (cali_cnt == 2)
;;;751                    {
;;;752                        STATE_SwitchStep(STEP_CALIBRATION_UART_TEST_RESTORE_VOLTAGE_CALIBRATION);
;;;753                        cali_cnt = 0;
;;;754                    }
;;;755                }
;;;756    
;;;757                // 三级校准
;;;758                if ((calibration_result) && (dut_info.cali_cnt == 3))
;;;759                {
;;;760                    if (cali_cnt == 1)
;;;761                    {
;;;762                        STATE_SwitchStep(STEP_CALIBRATION_UART_TEST_TWO_NOTIFY_POWER_BOARD);
;;;763                    }
;;;764                    if (cali_cnt == 2)
;;;765                    {
;;;766                        STATE_SwitchStep(STEP_CALIBRATION_UART_TEST_THREE_NOTIFY_POWER_BOARD);
;;;767                    }
;;;768                    if (cali_cnt == 3)
;;;769                    {
;;;770                        STATE_SwitchStep(STEP_CALIBRATION_UART_TEST_RESTORE_VOLTAGE_CALIBRATION);
;;;771                    }
;;;772                }
;;;773    
;;;774                // 校准失败
;;;775                if (!calibration_result)
;;;776                {
;;;777                    cali_cnt = 0;
;;;778                    Clear_All_Lines();
;;;779                    Display_Centered(0, "Calibration");
;;;780                    Display_Centered(1, "Fail");
;;;781                    STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_VOLTAGE_CALIBRATION, FALSE);
;;;782                    TIMER_KillTask(TIMER_ID_DUT_TIMEOUT);
;;;783                }
;;;784                break;
;;;785    
;;;786            // 在线检测
;;;787            case DUT_PROTOCOL_CMD_ONLINE_DETECTION:
;;;788                online_detection_cnt++;            
;;;789                TIMER_ResetTimer(TIMER_ID_ONLINE_DETECT);
;;;790                
;;;791                if(1 == online_detection_cnt)
;;;792                {
;;;793                   // 上报仪表启动状态
;;;794                   STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_ONLINE_DETECTION,TRUE);
;;;795                }
;;;796                break;
;;;797    
;;;798            // 读取标志区数据
;;;799            case DUT_PROTOCOL_CMD_READ_FLAG_DATA:
;;;800                TIMER_KillTask(TIMER_ID_WRITE_FLAG_TIMEOUT);
;;;801    
;;;802                // 读取标志区数据
;;;803                for (i = 0; i < 4; i++)
;;;804                {
;;;805                    buffFlag[i] = pCmdFrame->buff[(stationNumber * 4) + 4 + i];
;;;806                }
;;;807    
;;;808                // 校验标志区数据
;;;809                if ((buffFlag[0] == 0x00) && (buffFlag[1] == 0x00) && (buffFlag[2] == 0x00) && (buffFlag[3] == 0x02))
;;;810                {
;;;811                    STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_CHECK_STATION_FLAG, TRUE);
;;;812                }
;;;813                else
;;;814                {
;;;815                    STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_CHECK_STATION_FLAG, FALSE);
;;;816                }
;;;817                break;
;;;818    
;;;819            // 写入标志区数据
;;;820            case DUT_PROTOCOL_CMD_WRITE_FLAG_DATA:
;;;821    
;;;822                // 关闭写入超时定时器
;;;823                TIMER_ResetTimer(TIMER_ID_WRITE_FLAG_TIMEOUT);
;;;824    
;;;825                // 收到写入成功再读取出来进行校验
;;;826                if (pCmdFrame->buff[DUT_PROTOCOL_CMD_DATA1_INDEX])
;;;827                {
;;;828                    DUT_PROTOCOL_SendCmdAck(DUT_PROTOCOL_CMD_READ_FLAG_DATA);
;;;829                }
;;;830                else
;;;831                {
;;;832                    STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_CHECK_STATION_FLAG, FALSE);
;;;833                }
;;;834                break;
;;;835    
;;;836            // 写入版本类型数据
;;;837            case DUT_PROTOCOL_CMD_WRITE_VERSION_TYPE_DATA:
;;;838    
;;;839                // 关闭定时器
;;;840                TIMER_ResetTimer(TIMER_ID_OPERATE_VER_TIMEOUT);
;;;841    
;;;842                // 获取类型
;;;843                verType =  pCmdFrame->buff[DUT_PROTOCOL_CMD_DATA1_INDEX];
;;;844    
;;;845                // 类型正确并且执行成功，上报STS
;;;846                if ((dutverType == verType) && (pCmdFrame->buff[DUT_PROTOCOL_CMD_DATA2_INDEX]))
;;;847                {
;;;848                    // 读取版本类型信息
;;;849                    DUT_PROTOCOL_SendCmdParamAck(DUT_PROTOCOL_CMD_READ_VERSION_TYPE_INFO, dutverType);
;;;850                }
;;;851                else
;;;852                {
;;;853                    STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_CHECK_VERSION_INFO, FALSE);
;;;854                }
;;;855                break;
;;;856    
;;;857            // 读取版本类型信息
;;;858            case DUT_PROTOCOL_CMD_READ_VERSION_TYPE_INFO:
;;;859                TIMER_KillTask(TIMER_ID_OPERATE_VER_TIMEOUT);
;;;860    
;;;861                // 获取类型
;;;862                verType =  pCmdFrame->buff[DUT_PROTOCOL_CMD_DATA1_INDEX];
;;;863    
;;;864                // 获取信息长度
;;;865                infoLen = pCmdFrame->buff[DUT_PROTOCOL_CMD_DATA2_INDEX];
;;;866    
;;;867                // 获取类型信息
;;;868                strcpy(verBuff, (const char *)&pCmdFrame->buff[DUT_PROTOCOL_CMD_DATA3_INDEX]);
;;;869                verBuff[infoLen] = 0;
;;;870    
;;;871                // 只读取
;;;872                if (verreadFlag)
;;;873                {
;;;874                    STS_PROTOCOL_TxAddData(STS_PROTOCOL_CMD_HEAD);
;;;875                    STS_PROTOCOL_TxAddData(STS_PROTOCOL_CMD_CHECK_VERSION_INFO);
;;;876                    STS_PROTOCOL_TxAddData(0x00);       // 数据长度
;;;877                    STS_PROTOCOL_TxAddData(1);          // 校验读取结果
;;;878                    STS_PROTOCOL_TxAddData(verType);    // 版本类型
;;;879                    STS_PROTOCOL_TxAddData(infoLen);    // 信息长度
;;;880    
;;;881                    // 类型信息
;;;882                    for (i = 0; i < infoLen; i++)
;;;883                    {
;;;884                        STS_PROTOCOL_TxAddData(pCmdFrame->buff[5 + i]);
;;;885                    }
;;;886                    STS_PROTOCOL_TxAddFrame();     // 版本类型
;;;887                    verreadFlag = FALSE;
;;;888                }
;;;889    
;;;890                // 写入对比
;;;891                if (verwriteFlag)
;;;892                {
;;;893                    // 版本对比
;;;894                    if ((dutverType == verType) && (strstr((const char *)dutverBuff, (char *)verBuff) != NULL))
;;;895                    {
;;;896                        STS_PROTOCOL_TxAddData(STS_PROTOCOL_CMD_HEAD);
;;;897                        STS_PROTOCOL_TxAddData(STS_PROTOCOL_CMD_CHECK_VERSION_INFO);
;;;898                        STS_PROTOCOL_TxAddData(0x00);       // 数据长度
;;;899                        STS_PROTOCOL_TxAddData(1);          // 校验读取结果
;;;900                        STS_PROTOCOL_TxAddData(verType);    // 版本类型
;;;901                        STS_PROTOCOL_TxAddData(infoLen);    // 信息长度
;;;902    
;;;903                        // 类型信息
;;;904                        for (i = 0; i < infoLen; i++)
;;;905                        {
;;;906                            STS_PROTOCOL_TxAddData(pCmdFrame->buff[5 + i]);
;;;907                        }
;;;908                        STS_PROTOCOL_TxAddFrame();     // 版本类型
;;;909                    }
;;;910                    else
;;;911                    {
;;;912                        STS_PROTOCOL_TxAddData(STS_PROTOCOL_CMD_HEAD);
;;;913                        STS_PROTOCOL_TxAddData(STS_PROTOCOL_CMD_CHECK_VERSION_INFO);
;;;914                        STS_PROTOCOL_TxAddData(0x00);       // 数据长度
;;;915                        STS_PROTOCOL_TxAddData(0);          // 校验读取结果
;;;916                        STS_PROTOCOL_TxAddData(verType);    // 版本类型
;;;917                        STS_PROTOCOL_TxAddData(infoLen);    // 信息长度
;;;918    
;;;919                        // 类型信息
;;;920                        for (i = 0; i < infoLen; i++)
;;;921                        {
;;;922                            STS_PROTOCOL_TxAddData(pCmdFrame->buff[5 + i]);
;;;923                        }
;;;924                        STS_PROTOCOL_TxAddFrame();     // 版本类型
;;;925                    }
;;;926                    verwriteFlag = FALSE;
;;;927                }
;;;928    
;;;929                break;
;;;930    
;;;931            // 蓝牙测试
;;;932            case DUT_PROTOCOL_CMD_BLUETOOTH_MAC_ADDRESS_READ:
;;;933                
;;;934                // 将蓝牙版本复制到缓冲区
;;;935                strcpy(dut_info.bleVerBuff, &pCmdFrame->buff[DUT_PROTOCOL_CMD_DATA14_INDEX]);
;;;936                
;;;937                // 将校验码赋为0
;;;938                dut_info.bleVerBuff[pCmdFrame->buff[DUT_PROTOCOL_CMD_LENGTH_INDEX] - 13] =  0;
;;;939    
;;;940                // 版本比对成功将MAC地址发给电源板连接
;;;941                if (pCmdFrame->buff[DUT_PROTOCOL_CMD_DATA1_INDEX])
;;;942                {
;;;943                    POWER_PROTOCOL_TxAddData(POWER_PROTOCOL_CMD_HEAD);
;;;944                    POWER_PROTOCOL_TxAddData(POWER_PROTOCOL_CMD_DEVICE_ADDR);
;;;945                    POWER_PROTOCOL_TxAddData(POWER_PROTOCOL_CMD_BLUETOOTH_CONNECT);
;;;946                    POWER_PROTOCOL_TxAddData(12);
;;;947                    POWER_PROTOCOL_TxAddData(pCmdFrame->buff[DUT_PROTOCOL_CMD_DATA2_INDEX]);
;;;948                    POWER_PROTOCOL_TxAddData(pCmdFrame->buff[DUT_PROTOCOL_CMD_DATA3_INDEX]);
;;;949                    POWER_PROTOCOL_TxAddData(pCmdFrame->buff[DUT_PROTOCOL_CMD_DATA4_INDEX]);
;;;950                    POWER_PROTOCOL_TxAddData(pCmdFrame->buff[DUT_PROTOCOL_CMD_DATA5_INDEX]);
;;;951                    POWER_PROTOCOL_TxAddData(pCmdFrame->buff[DUT_PROTOCOL_CMD_DATA6_INDEX]);
;;;952                    POWER_PROTOCOL_TxAddData(pCmdFrame->buff[DUT_PROTOCOL_CMD_DATA7_INDEX]);
;;;953                    POWER_PROTOCOL_TxAddData(pCmdFrame->buff[DUT_PROTOCOL_CMD_DATA8_INDEX]);
;;;954                    POWER_PROTOCOL_TxAddData(pCmdFrame->buff[DUT_PROTOCOL_CMD_DATA9_INDEX]);
;;;955                    POWER_PROTOCOL_TxAddData(pCmdFrame->buff[DUT_PROTOCOL_CMD_DATA10_INDEX]);
;;;956                    POWER_PROTOCOL_TxAddData(pCmdFrame->buff[DUT_PROTOCOL_CMD_DATA11_INDEX]);
;;;957                    POWER_PROTOCOL_TxAddData(pCmdFrame->buff[DUT_PROTOCOL_CMD_DATA12_INDEX]);
;;;958                    POWER_PROTOCOL_TxAddData(pCmdFrame->buff[DUT_PROTOCOL_CMD_DATA13_INDEX]);                
;;;959                    POWER_PROTOCOL_TxAddFrame();
;;;960                }
;;;961    
;;;962                // 版本比对失败上报STS
;;;963                if (0 == pCmdFrame->buff[DUT_PROTOCOL_CMD_DATA1_INDEX])
;;;964                {
;;;965                    STS_PROTOCOL_TxAddData(STS_PROTOCOL_CMD_HEAD);
;;;966                    STS_PROTOCOL_TxAddData(STS_PROTOCOL_CMD_BLE_TEST);
;;;967                    STS_PROTOCOL_TxAddData(7);
;;;968                    STS_PROTOCOL_TxAddData(1);
;;;969                    STS_PROTOCOL_TxAddData((HexToChar(pCmdFrame->buff[DUT_PROTOCOL_CMD_DATA2_INDEX]) << 4) | (HexToChar(pCmdFrame->buff[DUT_PROTOCOL_CMD_DATA3_INDEX]) & 0x0F)); 
;;;970                    STS_PROTOCOL_TxAddData((HexToChar(pCmdFrame->buff[DUT_PROTOCOL_CMD_DATA4_INDEX]) << 4) | (HexToChar(pCmdFrame->buff[DUT_PROTOCOL_CMD_DATA5_INDEX]) & 0x0F)); 
;;;971                    STS_PROTOCOL_TxAddData((HexToChar(pCmdFrame->buff[DUT_PROTOCOL_CMD_DATA6_INDEX]) << 4) | (HexToChar(pCmdFrame->buff[DUT_PROTOCOL_CMD_DATA7_INDEX]) & 0x0F)); 
;;;972                    STS_PROTOCOL_TxAddData((HexToChar(pCmdFrame->buff[DUT_PROTOCOL_CMD_DATA8_INDEX]) << 4) | (HexToChar(pCmdFrame->buff[DUT_PROTOCOL_CMD_DATA9_INDEX]) & 0x0F)); 
;;;973                    STS_PROTOCOL_TxAddData((HexToChar(pCmdFrame->buff[DUT_PROTOCOL_CMD_DATA10_INDEX]) << 4) | (HexToChar(pCmdFrame->buff[DUT_PROTOCOL_CMD_DATA11_INDEX]) & 0x0F)); 
;;;974                    STS_PROTOCOL_TxAddData((HexToChar(pCmdFrame->buff[DUT_PROTOCOL_CMD_DATA12_INDEX]) << 4) | (HexToChar(pCmdFrame->buff[DUT_PROTOCOL_CMD_DATA13_INDEX]) & 0x0F)); 
;;;975                    
;;;976                    for(i = 0; i < 20 ;i++)
;;;977                    {
;;;978                      STS_PROTOCOL_TxAddData(dut_info.bleVerBuff[i]);
;;;979                    }
;;;980                                  
;;;981                    STS_PROTOCOL_TxAddFrame();
;;;982                }
;;;983                break;
;;;984    
;;;985            // LCD 颜色测试（命令字=0x03）
;;;986            case DUT_PROTOCOL_CMD_TEST_LCD:
;;;987                STS_PROTOCOL_SendCmdParamAck(DUT_PROTOCOL_CMD_TEST_LCD, TRUE);
;;;988                break;
;;;989    
;;;990            // Flash 校验测试
;;;991            case DUT_PROTOCOL_CMD_FLASH_CHECK_TEST:
;;;992                TIMER_ChangeTime(TIMER_ID_ONLINE_DETECT, 3000);
;;;993                STS_UART_AddTxArray(0, pCmdFrame->buff, pCmdFrame->length);
;;;994                break;
;;;995    
;;;996            // 按键测试
;;;997            case DUT_PROTOCOL_CMD_KEY_TEST:
;;;998            
;;;999                // 按键模拟测试
;;;1000               if(dut_info.buttonSimulationFlag)
;;;1001               {
;;;1002                   if(keyValue == pCmdFrame->buff[DUT_PROTOCOL_CMD_DATA1_INDEX])
;;;1003                   {
;;;1004                        testResult = TRUE;
;;;1005                   }
;;;1006                   else
;;;1007                   {
;;;1008                        testResult = FALSE;
;;;1009                   }
;;;1010                   STS_PROTOCOL_SendCmdParamTwoAck(STS_PROTOCOL_CMD_SIMULATION_KEY_TEST, testResult, pCmdFrame->buff[DUT_PROTOCOL_CMD_DATA12_INDEX]);                
;;;1011               }
;;;1012               // 按键正常测试
;;;1013               else
;;;1014               {
;;;1015                   STS_UART_AddTxArray(0, pCmdFrame->buff, pCmdFrame->length);         
;;;1016   
;;;1017                   // LCD显示
;;;1018                   Vertical_Scrolling_Display(ptUpMsgBuff, 4, 0);                
;;;1019               }
;;;1020               break;
;;;1021               
;;;1022           default:
;;;1023               STS_UART_AddTxArray(0, pCmdFrame->buff, pCmdFrame->length);
;;;1024   
;;;1025               // LCD显示
;;;1026               Vertical_Scrolling_Display(ptUpMsgBuff, 4, 0);     
;;;1027               break;
;;;1028       }
;;;1029   
;;;1030       // 删除命令帧
;;;1031       pCB->rx.head++;
;;;1032       pCB->rx.head %= DUT_PROTOCOL_RX_QUEUE_SIZE;
;;;1033   }
000050  b01b              ADD      sp,sp,#0x6c
000052  e8bd8ff0          POP      {r4-r11,pc}
                  |L2.86|
000056  78e0              LDRB     r0,[r4,#3]            ;518
000058  f8dfa3a8          LDR      r10,|L2.1028|
00005c  4eea              LDR      r6,|L2.1032|
00005e  f04f0800          MOV      r8,#0                 ;530
000062  28a7              CMP      r0,#0xa7              ;521
000064  d074              BEQ      |L2.336|
000066  dc0f              BGT      |L2.136|
000068  2809              CMP      r0,#9                 ;521
00006a  d072              BEQ      |L2.338|
00006c  dc05              BGT      |L2.122|
00006e  b350              CBZ      r0,|L2.198|
000070  2803              CMP      r0,#3                 ;521
000072  d06f              BEQ      |L2.340|
000074  2805              CMP      r0,#5                 ;521
000076  d11b              BNE      |L2.176|
000078  e338              B        |L2.1772|
                  |L2.122|
00007a  280c              CMP      r0,#0xc               ;521
00007c  d06b              BEQ      |L2.342|
00007e  2891              CMP      r0,#0x91              ;521
000080  d06a              BEQ      |L2.344|
000082  28a6              CMP      r0,#0xa6              ;521
000084  d114              BNE      |L2.176|
000086  e199              B        |L2.956|
                  |L2.136|
000088  49de              LDR      r1,|L2.1028|
00008a  7809              LDRB     r1,[r1,#0]            ;530
00008c  1c49              ADDS     r1,r1,#1              ;530
00008e  b2c9              UXTB     r1,r1                 ;530
000090  28eb              CMP      r0,#0xeb              ;521
000092  d042              BEQ      |L2.282|
000094  dc08              BGT      |L2.168|
000096  f8df9374          LDR      r9,|L2.1036|
00009a  28a8              CMP      r0,#0xa8              ;521
00009c  d07e              BEQ      |L2.412|
00009e  28a9              CMP      r0,#0xa9              ;521
0000a0  d07d              BEQ      |L2.414|
0000a2  28ea              CMP      r0,#0xea              ;521
0000a4  d104              BNE      |L2.176|
0000a6  e01a              B        |L2.222|
                  |L2.168|
0000a8  28ec              CMP      r0,#0xec              ;521
0000aa  d079              BEQ      |L2.416|
0000ac  28ed              CMP      r0,#0xed              ;521
0000ae  d078              BEQ      |L2.418|
                  |L2.176|
0000b0  f8b42052          LDRH     r2,[r4,#0x52]         ;1023
0000b4  1ca1              ADDS     r1,r4,#2              ;1023
0000b6  2000              MOVS     r0,#0                 ;1023
0000b8  f7fffffe          BL       STS_UART_AddTxArray
0000bc  2200              MOVS     r2,#0                 ;1026
0000be  2104              MOVS     r1,#4                 ;1026
0000c0  48d3              LDR      r0,|L2.1040|
0000c2  f7fffffe          BL       Vertical_Scrolling_Display
                  |L2.198|
0000c6  f8b70274          LDRH     r0,[r7,#0x274]        ;1031
0000ca  1c40              ADDS     r0,r0,#1              ;1031
0000cc  b280              UXTH     r0,r0                 ;1031
0000ce  2105              MOVS     r1,#5                 ;1032
0000d0  fbb0f2f1          UDIV     r2,r0,r1              ;1032
0000d4  fb010012          MLS      r0,r1,r2,r0           ;1032
0000d8  f8a70274          STRH     r0,[r7,#0x274]        ;1032
0000dc  e7b8              B        |L2.80|
                  |L2.222|
0000de  7964              LDRB     r4,[r4,#5]            ;529
0000e0  f88a1000          STRB     r1,[r10,#0]           ;530
0000e4  b934              CBNZ     r4,|L2.244|
0000e6  2100              MOVS     r1,#0                 ;535
0000e8  200b              MOVS     r0,#0xb               ;535
0000ea  f7fffffe          BL       STS_PROTOCOL_SendCmdParamAck
0000ee  2008              MOVS     r0,#8                 ;536
0000f0  f7fffffe          BL       TIMER_KillTask
                  |L2.244|
0000f4  07e0              LSLS     r0,r4,#31             ;540
0000f6  d0e6              BEQ      |L2.198|
0000f8  f89a0000          LDRB     r0,[r10,#0]           ;542  ; light_cnt
0000fc  2801              CMP      r0,#1                 ;542
0000fe  d102              BNE      |L2.262|
000100  2013              MOVS     r0,#0x13              ;544
000102  f7fffffe          BL       STATE_SwitchStep
                  |L2.262|
000106  f89a0000          LDRB     r0,[r10,#0]           ;546  ; light_cnt
00010a  2802              CMP      r0,#2                 ;546
00010c  d1db              BNE      |L2.198|
00010e  2016              MOVS     r0,#0x16              ;548
000110  f7fffffe          BL       STATE_SwitchStep
000114  f88a8000          STRB     r8,[r10,#0]           ;549
                  |L2.280|
000118  e7d5              B        |L2.198|
                  |L2.282|
00011a  7965              LDRB     r5,[r4,#5]            ;555
00011c  07e8              LSLS     r0,r5,#31             ;558
00011e  d029              BEQ      |L2.372|
000120  79a0              LDRB     r0,[r4,#6]            ;561
000122  49b8              LDR      r1,|L2.1028|
000124  0200              LSLS     r0,r0,#8              ;561
000126  310c              ADDS     r1,r1,#0xc            ;561
000128  8008              STRH     r0,[r1,#0]            ;561
00012a  79e2              LDRB     r2,[r4,#7]            ;562
00012c  4310              ORRS     r0,r0,r2              ;562
00012e  8008              STRH     r0,[r1,#0]            ;562
000130  f8a60040          STRH     r0,[r6,#0x40]         ;563
000134  f89a0001          LDRB     r0,[r10,#1]           ;564  ; cnt
000138  1c40              ADDS     r0,r0,#1              ;564
00013a  b2c0              UXTB     r0,r0                 ;564
00013c  f88a0001          STRB     r0,[r10,#1]           ;564
000140  b1c0              CBZ      r0,|L2.372|
000142  2801              CMP      r0,#1                 ;566
000144  d009              BEQ      |L2.346|
000146  2802              CMP      r0,#2                 ;566
000148  d00b              BEQ      |L2.354|
00014a  2803              CMP      r0,#3                 ;566
00014c  d112              BNE      |L2.372|
00014e  e00c              B        |L2.362|
                  |L2.336|
000150  e179              B        |L2.1094|
                  |L2.338|
000152  e2bf              B        |L2.1748|
                  |L2.340|
000154  e2b9              B        |L2.1738|
                  |L2.342|
000156  e217              B        |L2.1416|
                  |L2.344|
000158  e0ca              B        |L2.752|
                  |L2.346|
00015a  203f              MOVS     r0,#0x3f              ;572
00015c  f7fffffe          BL       STATE_SwitchStep
000160  e008              B        |L2.372|
                  |L2.354|
000162  2040              MOVS     r0,#0x40              ;576
000164  f7fffffe          BL       STATE_SwitchStep
000168  e004              B        |L2.372|
                  |L2.362|
00016a  2041              MOVS     r0,#0x41              ;580
00016c  f7fffffe          BL       STATE_SwitchStep
000170  f88a8001          STRB     r8,[r10,#1]           ;581
                  |L2.372|
000174  07a8              LSLS     r0,r5,#30             ;590
000176  d528              BPL      |L2.458|
000178  79a0              LDRB     r0,[r4,#6]            ;593
00017a  49a2              LDR      r1,|L2.1028|
00017c  0200              LSLS     r0,r0,#8              ;593
00017e  3110              ADDS     r1,r1,#0x10           ;593
000180  79e2              LDRB     r2,[r4,#7]            ;594
000182  4310              ORRS     r0,r0,r2              ;594
000184  8008              STRH     r0,[r1,#0]            ;594
000186  f8a60042          STRH     r0,[r6,#0x42]         ;595
00018a  f89a0003          LDRB     r0,[r10,#3]           ;596  ; brake_cnt
00018e  1c40              ADDS     r0,r0,#1              ;596
000190  b2c0              UXTB     r0,r0                 ;596
000192  f88a0003          STRB     r0,[r10,#3]           ;596
000196  b1c0              CBZ      r0,|L2.458|
000198  2801              CMP      r0,#1                 ;598
00019a  e003              B        |L2.420|
                  |L2.412|
00019c  e161              B        |L2.1122|
                  |L2.414|
00019e  e173              B        |L2.1160|
                  |L2.416|
0001a0  e03b              B        |L2.538|
                  |L2.418|
0001a2  e0fa              B        |L2.922|
                  |L2.420|
0001a4  d004              BEQ      |L2.432|
0001a6  2802              CMP      r0,#2                 ;598
0001a8  d006              BEQ      |L2.440|
0001aa  2803              CMP      r0,#3                 ;598
0001ac  d10d              BNE      |L2.458|
0001ae  e007              B        |L2.448|
                  |L2.432|
0001b0  2048              MOVS     r0,#0x48              ;604
0001b2  f7fffffe          BL       STATE_SwitchStep
0001b6  e008              B        |L2.458|
                  |L2.440|
0001b8  2049              MOVS     r0,#0x49              ;608
0001ba  f7fffffe          BL       STATE_SwitchStep
0001be  e004              B        |L2.458|
                  |L2.448|
0001c0  204a              MOVS     r0,#0x4a              ;612
0001c2  f7fffffe          BL       STATE_SwitchStep
0001c6  f88a8003          STRB     r8,[r10,#3]           ;613
                  |L2.458|
0001ca  43e8              MVNS     r0,r5                 ;622
0001cc  0780              LSLS     r0,r0,#30             ;622
0001ce  d1a3              BNE      |L2.280|
0001d0  79a0              LDRB     r0,[r4,#6]            ;625
0001d2  498c              LDR      r1,|L2.1028|
0001d4  0200              LSLS     r0,r0,#8              ;625
0001d6  3114              ADDS     r1,r1,#0x14           ;625
0001d8  79e2              LDRB     r2,[r4,#7]            ;626
0001da  4310              ORRS     r0,r0,r2              ;626
0001dc  8008              STRH     r0,[r1,#0]            ;626
0001de  f8a60044          STRH     r0,[r6,#0x44]         ;627
0001e2  f89a0004          LDRB     r0,[r10,#4]           ;628  ; derailleur_cnt
0001e6  1c40              ADDS     r0,r0,#1              ;628
0001e8  b2c0              UXTB     r0,r0                 ;628
0001ea  f88a0004          STRB     r0,[r10,#4]           ;628
0001ee  2800              CMP      r0,#0                 ;630
0001f0  d092              BEQ      |L2.280|
0001f2  2801              CMP      r0,#1                 ;630
0001f4  d009              BEQ      |L2.522|
0001f6  2802              CMP      r0,#2                 ;630
0001f8  d00b              BEQ      |L2.530|
0001fa  2803              CMP      r0,#3                 ;630
0001fc  d18c              BNE      |L2.280|
0001fe  2053              MOVS     r0,#0x53              ;644
000200  f7fffffe          BL       STATE_SwitchStep
000204  f88a8004          STRB     r8,[r10,#4]           ;645
000208  e75d              B        |L2.198|
                  |L2.522|
00020a  2051              MOVS     r0,#0x51              ;636
00020c  f7fffffe          BL       STATE_SwitchStep
000210  e759              B        |L2.198|
                  |L2.530|
000212  2052              MOVS     r0,#0x52              ;640
000214  f7fffffe          BL       STATE_SwitchStep
000218  e755              B        |L2.198|
                  |L2.538|
00021a  7965              LDRB     r5,[r4,#5]            ;657
00021c  79a4              LDRB     r4,[r4,#6]            ;658
00021e  f88a1000          STRB     r1,[r10,#0]           ;659
000222  b194              CBZ      r4,|L2.586|
000224  7df0              LDRB     r0,[r6,#0x17]         ;662  ; dut_info
000226  2804              CMP      r0,#4                 ;662
000228  d10f              BNE      |L2.586|
00022a  2d02              CMP      r5,#2                 ;662
00022c  d10d              BNE      |L2.586|
00022e  2901              CMP      r1,#1                 ;664
000230  d102              BNE      |L2.568|
000232  201b              MOVS     r0,#0x1b              ;666
000234  f7fffffe          BL       STATE_SwitchStep
                  |L2.568|
000238  f89a0000          LDRB     r0,[r10,#0]           ;668  ; light_cnt
00023c  2802              CMP      r0,#2                 ;668
00023e  d104              BNE      |L2.586|
000240  201e              MOVS     r0,#0x1e              ;670
000242  f7fffffe          BL       STATE_SwitchStep
000246  f88a8000          STRB     r8,[r10,#0]           ;671
                  |L2.586|
00024a  b1a4              CBZ      r4,|L2.630|
00024c  7df0              LDRB     r0,[r6,#0x17]         ;676  ; dut_info
00024e  2805              CMP      r0,#5                 ;676
000250  d111              BNE      |L2.630|
000252  2d03              CMP      r5,#3                 ;676
000254  d10f              BNE      |L2.630|
000256  f89a0000          LDRB     r0,[r10,#0]           ;678  ; light_cnt
00025a  2801              CMP      r0,#1                 ;678
00025c  d102              BNE      |L2.612|
00025e  2023              MOVS     r0,#0x23              ;680
000260  f7fffffe          BL       STATE_SwitchStep
                  |L2.612|
000264  f89a0000          LDRB     r0,[r10,#0]           ;682  ; light_cnt
000268  2802              CMP      r0,#2                 ;682
00026a  d104              BNE      |L2.630|
00026c  2026              MOVS     r0,#0x26              ;684
00026e  f7fffffe          BL       STATE_SwitchStep
000272  f88a8000          STRB     r8,[r10,#0]           ;685
                  |L2.630|
000276  b19c              CBZ      r4,|L2.672|
000278  7df0              LDRB     r0,[r6,#0x17]         ;690  ; dut_info
00027a  2806              CMP      r0,#6                 ;690
00027c  d110              BNE      |L2.672|
00027e  b97d              CBNZ     r5,|L2.672|
000280  f89a0000          LDRB     r0,[r10,#0]           ;692  ; light_cnt
000284  2801              CMP      r0,#1                 ;692
000286  d102              BNE      |L2.654|
000288  202b              MOVS     r0,#0x2b              ;694
00028a  f7fffffe          BL       STATE_SwitchStep
                  |L2.654|
00028e  f89a0000          LDRB     r0,[r10,#0]           ;696  ; light_cnt
000292  2802              CMP      r0,#2                 ;696
000294  d104              BNE      |L2.672|
000296  202f              MOVS     r0,#0x2f              ;698
000298  f7fffffe          BL       STATE_SwitchStep
00029c  f88a8000          STRB     r8,[r10,#0]           ;699
                  |L2.672|
0002a0  b1a4              CBZ      r4,|L2.716|
0002a2  7df0              LDRB     r0,[r6,#0x17]         ;704  ; dut_info
0002a4  2807              CMP      r0,#7                 ;704
0002a6  d111              BNE      |L2.716|
0002a8  2d01              CMP      r5,#1                 ;704
0002aa  d10f              BNE      |L2.716|
0002ac  f89a0000          LDRB     r0,[r10,#0]           ;706  ; light_cnt
0002b0  2801              CMP      r0,#1                 ;706
0002b2  d102              BNE      |L2.698|
0002b4  2034              MOVS     r0,#0x34              ;708
0002b6  f7fffffe          BL       STATE_SwitchStep
                  |L2.698|
0002ba  f89a0000          LDRB     r0,[r10,#0]           ;710  ; light_cnt
0002be  2802              CMP      r0,#2                 ;710
0002c0  d104              BNE      |L2.716|
0002c2  2039              MOVS     r0,#0x39              ;712
0002c4  f7fffffe          BL       STATE_SwitchStep
0002c8  f88a8000          STRB     r8,[r10,#0]           ;713
                  |L2.716|
0002cc  f7fffffe          BL       Clear_All_Lines
0002d0  a150              ADR      r1,|L2.1044|
0002d2  2001              MOVS     r0,#1                 ;722
0002d4  f7fffffe          BL       Display_Centered
0002d8  f88a8005          STRB     r8,[r10,#5]           ;724
0002dc  f88a8006          STRB     r8,[r10,#6]           ;725
0002e0  2100              MOVS     r1,#0                 ;726
0002e2  200b              MOVS     r0,#0xb               ;726
0002e4  f7fffffe          BL       STS_PROTOCOL_SendCmdParamAck
0002e8  2008              MOVS     r0,#8                 ;727
0002ea  f7fffffe          BL       TIMER_KillTask
                  |L2.750|
0002ee  e6ea              B        |L2.198|
                  |L2.752|
0002f0  f89a0002          LDRB     r0,[r10,#2]           ;733  ; cali_cnt
0002f4  1c40              ADDS     r0,r0,#1              ;733
0002f6  f88a0002          STRB     r0,[r10,#2]           ;733
0002fa  7964              LDRB     r4,[r4,#5]            ;734
0002fc  b144              CBZ      r4,|L2.784|
0002fe  f8960030          LDRB     r0,[r6,#0x30]         ;737  ; dut_info
000302  2801              CMP      r0,#1                 ;737
000304  d104              BNE      |L2.784|
000306  2066              MOVS     r0,#0x66              ;739
000308  f7fffffe          BL       STATE_SwitchStep
00030c  f88a8002          STRB     r8,[r10,#2]           ;740
                  |L2.784|
000310  b19c              CBZ      r4,|L2.826|
000312  f8960030          LDRB     r0,[r6,#0x30]         ;744  ; dut_info
000316  2802              CMP      r0,#2                 ;744
000318  d10f              BNE      |L2.826|
00031a  f89a0002          LDRB     r0,[r10,#2]           ;746  ; cali_cnt
00031e  2801              CMP      r0,#1                 ;746
000320  d102              BNE      |L2.808|
000322  2062              MOVS     r0,#0x62              ;748
000324  f7fffffe          BL       STATE_SwitchStep
                  |L2.808|
000328  f89a0002          LDRB     r0,[r10,#2]           ;750  ; cali_cnt
00032c  2802              CMP      r0,#2                 ;750
00032e  d104              BNE      |L2.826|
000330  2066              MOVS     r0,#0x66              ;752
000332  f7fffffe          BL       STATE_SwitchStep
000336  f88a8002          STRB     r8,[r10,#2]           ;753
                  |L2.826|
00033a  b1c4              CBZ      r4,|L2.878|
00033c  f8960030          LDRB     r0,[r6,#0x30]         ;758  ; dut_info
000340  2803              CMP      r0,#3                 ;758
000342  d114              BNE      |L2.878|
000344  f89a0002          LDRB     r0,[r10,#2]           ;760  ; cali_cnt
000348  2801              CMP      r0,#1                 ;760
00034a  d102              BNE      |L2.850|
00034c  2062              MOVS     r0,#0x62              ;762
00034e  f7fffffe          BL       STATE_SwitchStep
                  |L2.850|
000352  f89a0002          LDRB     r0,[r10,#2]           ;764  ; cali_cnt
000356  2802              CMP      r0,#2                 ;764
000358  d102              BNE      |L2.864|
00035a  2064              MOVS     r0,#0x64              ;766
00035c  f7fffffe          BL       STATE_SwitchStep
                  |L2.864|
000360  f89a0002          LDRB     r0,[r10,#2]           ;768  ; cali_cnt
000364  2803              CMP      r0,#3                 ;768
000366  d102              BNE      |L2.878|
000368  2066              MOVS     r0,#0x66              ;770
00036a  f7fffffe          BL       STATE_SwitchStep
                  |L2.878|
00036e  2c00              CMP      r4,#0                 ;775
000370  d1bd              BNE      |L2.750|
000372  f88a8002          STRB     r8,[r10,#2]           ;777
000376  f7fffffe          BL       Clear_All_Lines
00037a  a12a              ADR      r1,|L2.1060|
00037c  2000              MOVS     r0,#0                 ;779
00037e  f7fffffe          BL       Display_Centered
000382  a12b              ADR      r1,|L2.1072|
000384  2001              MOVS     r0,#1                 ;780
000386  f7fffffe          BL       Display_Centered
00038a  2100              MOVS     r1,#0                 ;781
00038c  2015              MOVS     r0,#0x15              ;781
00038e  f7fffffe          BL       STS_PROTOCOL_SendCmdParamAck
000392  2008              MOVS     r0,#8                 ;782
000394  f7fffffe          BL       TIMER_KillTask
000398  e695              B        |L2.198|
                  |L2.922|
00039a  f8da0008          LDR      r0,[r10,#8]           ;788  ; online_detection_cnt
00039e  1c40              ADDS     r0,r0,#1              ;788
0003a0  f8ca0008          STR      r0,[r10,#8]           ;788  ; online_detection_cnt
0003a4  2011              MOVS     r0,#0x11              ;789
0003a6  f7fffffe          BL       TIMER_ResetTimer
0003aa  f8da0008          LDR      r0,[r10,#8]           ;791  ; online_detection_cnt
0003ae  2801              CMP      r0,#1                 ;791
0003b0  d19d              BNE      |L2.750|
0003b2  2101              MOVS     r1,#1                 ;794
0003b4  2018              MOVS     r0,#0x18              ;794
0003b6  f7fffffe          BL       STS_PROTOCOL_SendCmdParamAck
0003ba  e684              B        |L2.198|
                  |L2.956|
0003bc  2012              MOVS     r0,#0x12              ;800
0003be  f7fffffe          BL       TIMER_KillTask
0003c2  481d              LDR      r0,|L2.1080|
0003c4  a91a              ADD      r1,sp,#0x68           ;486
0003c6  7800              LDRB     r0,[r0,#0]            ;805
                  |L2.968|
0003c8  eb050280          ADD      r2,r5,r0,LSL #2       ;805
0003cc  4422              ADD      r2,r2,r4              ;805
0003ce  7992              LDRB     r2,[r2,#6]            ;805
0003d0  554a              STRB     r2,[r1,r5]            ;805
0003d2  1c6d              ADDS     r5,r5,#1              ;803
0003d4  b2ed              UXTB     r5,r5                 ;803
0003d6  2d04              CMP      r5,#4                 ;803
0003d8  d3f6              BCC      |L2.968|
0003da  f89d0068          LDRB     r0,[sp,#0x68]         ;809
0003de  b948              CBNZ     r0,|L2.1012|
0003e0  f89d0069          LDRB     r0,[sp,#0x69]         ;809
0003e4  b930              CBNZ     r0,|L2.1012|
0003e6  f89d006a          LDRB     r0,[sp,#0x6a]         ;809
0003ea  b918              CBNZ     r0,|L2.1012|
0003ec  f89d006b          LDRB     r0,[sp,#0x6b]         ;809
0003f0  2802              CMP      r0,#2                 ;809
0003f2  d023              BEQ      |L2.1084|
                  |L2.1012|
0003f4  2100              MOVS     r1,#0                 ;815
0003f6  2001              MOVS     r0,#1                 ;815
0003f8  f7fffffe          BL       STS_PROTOCOL_SendCmdParamAck
0003fc  e663              B        |L2.198|
0003fe  0000              DCW      0x0000
                  |L2.1024|
                          DCD      ||.constdata||
                  |L2.1028|
                          DCD      ||.data||
                  |L2.1032|
                          DCD      dut_info
                  |L2.1036|
                          DCD      dutverType
                  |L2.1040|
                          DCD      ptUpMsgBuff
                  |L2.1044|
000414  4661696c          DCB      "Fail to turn on",0
000418  20746f20
00041c  7475726e
000420  206f6e00
                  |L2.1060|
000424  43616c69          DCB      "Calibration",0
000428  62726174
00042c  696f6e00
                  |L2.1072|
000430  4661696c          DCB      "Fail",0
000434  00      
000435  00                DCB      0
000436  00                DCB      0
000437  00                DCB      0
                  |L2.1080|
                          DCD      stationNumber
                  |L2.1084|
00043c  2101              MOVS     r1,#1                 ;811
00043e  4608              MOV      r0,r1                 ;811
000440  f7fffffe          BL       STS_PROTOCOL_SendCmdParamAck
                  |L2.1092|
000444  e63f              B        |L2.198|
                  |L2.1094|
000446  2012              MOVS     r0,#0x12              ;823
000448  f7fffffe          BL       TIMER_ResetTimer
00044c  7960              LDRB     r0,[r4,#5]            ;826
00044e  b118              CBZ      r0,|L2.1112|
000450  20a6              MOVS     r0,#0xa6              ;828
000452  f7fffffe          BL       DUT_PROTOCOL_SendCmdAck
000456  e636              B        |L2.198|
                  |L2.1112|
000458  2100              MOVS     r1,#0                 ;832
00045a  2001              MOVS     r0,#1                 ;832
00045c  f7fffffe          BL       STS_PROTOCOL_SendCmdParamAck
000460  e631              B        |L2.198|
                  |L2.1122|
000462  2013              MOVS     r0,#0x13              ;840
000464  f7fffffe          BL       TIMER_ResetTimer
000468  7960              LDRB     r0,[r4,#5]            ;843
00046a  f8991000          LDRB     r1,[r9,#0]            ;846  ; dutverType
00046e  4281              CMP      r1,r0                 ;846
000470  d105              BNE      |L2.1150|
000472  79a0              LDRB     r0,[r4,#6]            ;846
000474  b118              CBZ      r0,|L2.1150|
000476  20a9              MOVS     r0,#0xa9              ;849
000478  f7fffffe          BL       DUT_PROTOCOL_SendCmdParamAck
00047c  e623              B        |L2.198|
                  |L2.1150|
00047e  2100              MOVS     r1,#0                 ;853
000480  2002              MOVS     r0,#2                 ;853
000482  f7fffffe          BL       STS_PROTOCOL_SendCmdParamAck
000486  e61e              B        |L2.198|
                  |L2.1160|
000488  2013              MOVS     r0,#0x13              ;859
00048a  f7fffffe          BL       TIMER_KillTask
00048e  f894b005          LDRB     r11,[r4,#5]           ;862
000492  79a6              LDRB     r6,[r4,#6]            ;865
000494  1de1              ADDS     r1,r4,#7              ;868
000496  a801              ADD      r0,sp,#4              ;868
000498  f7fffffe          BL       strcpy
00049c  a801              ADD      r0,sp,#4              ;869
00049e  f8008006          STRB     r8,[r0,r6]            ;869
0004a2  f8dfa27c          LDR      r10,|L2.1824|
0004a6  f89a0000          LDRB     r0,[r10,#0]           ;872  ; verreadFlag
0004aa  b1f0              CBZ      r0,|L2.1258|
0004ac  2055              MOVS     r0,#0x55              ;874
0004ae  f7fffffe          BL       STS_PROTOCOL_TxAddData
0004b2  2002              MOVS     r0,#2                 ;875
0004b4  f7fffffe          BL       STS_PROTOCOL_TxAddData
0004b8  2000              MOVS     r0,#0                 ;876
0004ba  f7fffffe          BL       STS_PROTOCOL_TxAddData
0004be  2001              MOVS     r0,#1                 ;877
0004c0  f7fffffe          BL       STS_PROTOCOL_TxAddData
0004c4  4658              MOV      r0,r11                ;878
0004c6  f7fffffe          BL       STS_PROTOCOL_TxAddData
0004ca  4630              MOV      r0,r6                 ;879
0004cc  f7fffffe          BL       STS_PROTOCOL_TxAddData
0004d0  e005              B        |L2.1246|
                  |L2.1234|
0004d2  1960              ADDS     r0,r4,r5              ;884
0004d4  79c0              LDRB     r0,[r0,#7]            ;884
0004d6  f7fffffe          BL       STS_PROTOCOL_TxAddData
0004da  1c6d              ADDS     r5,r5,#1              ;882
0004dc  b2ed              UXTB     r5,r5                 ;882
                  |L2.1246|
0004de  42b5              CMP      r5,r6                 ;882
0004e0  d3f7              BCC      |L2.1234|
0004e2  f7fffffe          BL       STS_PROTOCOL_TxAddFrame
0004e6  f88a8000          STRB     r8,[r10,#0]           ;887
                  |L2.1258|
0004ea  f8dfa238          LDR      r10,|L2.1828|
0004ee  f89a0000          LDRB     r0,[r10,#0]           ;891  ; verwriteFlag
0004f2  2800              CMP      r0,#0                 ;891
0004f4  d0a6              BEQ      |L2.1092|
0004f6  f8990000          LDRB     r0,[r9,#0]            ;894  ; dutverType
0004fa  4558              CMP      r0,r11                ;894
0004fc  d123              BNE      |L2.1350|
0004fe  a901              ADD      r1,sp,#4              ;894
000500  4889              LDR      r0,|L2.1832|
000502  f7fffffe          BL       strstr
000506  b1f0              CBZ      r0,|L2.1350|
000508  2055              MOVS     r0,#0x55              ;896
00050a  f7fffffe          BL       STS_PROTOCOL_TxAddData
00050e  2002              MOVS     r0,#2                 ;897
000510  f7fffffe          BL       STS_PROTOCOL_TxAddData
000514  2000              MOVS     r0,#0                 ;898
000516  f7fffffe          BL       STS_PROTOCOL_TxAddData
00051a  2001              MOVS     r0,#1                 ;899
00051c  f7fffffe          BL       STS_PROTOCOL_TxAddData
000520  4658              MOV      r0,r11                ;900
000522  f7fffffe          BL       STS_PROTOCOL_TxAddData
000526  4630              MOV      r0,r6                 ;901
000528  f7fffffe          BL       STS_PROTOCOL_TxAddData
00052c  2500              MOVS     r5,#0                 ;904
00052e  e005              B        |L2.1340|
                  |L2.1328|
000530  1960              ADDS     r0,r4,r5              ;906
000532  79c0              LDRB     r0,[r0,#7]            ;906
000534  f7fffffe          BL       STS_PROTOCOL_TxAddData
000538  1c6d              ADDS     r5,r5,#1              ;904
00053a  b2ed              UXTB     r5,r5                 ;904
                  |L2.1340|
00053c  42b5              CMP      r5,r6                 ;904
00053e  d3f7              BCC      |L2.1328|
000540  f7fffffe          BL       STS_PROTOCOL_TxAddFrame
000544  e01d              B        |L2.1410|
                  |L2.1350|
000546  2055              MOVS     r0,#0x55              ;912
000548  f7fffffe          BL       STS_PROTOCOL_TxAddData
00054c  2002              MOVS     r0,#2                 ;913
00054e  f7fffffe          BL       STS_PROTOCOL_TxAddData
000552  2000              MOVS     r0,#0                 ;914
000554  f7fffffe          BL       STS_PROTOCOL_TxAddData
000558  2000              MOVS     r0,#0                 ;915
00055a  f7fffffe          BL       STS_PROTOCOL_TxAddData
00055e  4658              MOV      r0,r11                ;916
000560  f7fffffe          BL       STS_PROTOCOL_TxAddData
000564  4630              MOV      r0,r6                 ;917
000566  f7fffffe          BL       STS_PROTOCOL_TxAddData
00056a  2500              MOVS     r5,#0                 ;920
00056c  e005              B        |L2.1402|
                  |L2.1390|
00056e  1960              ADDS     r0,r4,r5              ;922
000570  79c0              LDRB     r0,[r0,#7]            ;922
000572  f7fffffe          BL       STS_PROTOCOL_TxAddData
000576  1c6d              ADDS     r5,r5,#1              ;920
000578  b2ed              UXTB     r5,r5                 ;920
                  |L2.1402|
00057a  42b5              CMP      r5,r6                 ;920
00057c  d3f7              BCC      |L2.1390|
00057e  f7fffffe          BL       STS_PROTOCOL_TxAddFrame
                  |L2.1410|
000582  f88a8000          STRB     r8,[r10,#0]           ;926
                  |L2.1414|
000586  e59e              B        |L2.198|
                  |L2.1416|
000588  f1040112          ADD      r1,r4,#0x12           ;935
00058c  4867              LDR      r0,|L2.1836|
00058e  f7fffffe          BL       strcpy
000592  4866              LDR      r0,|L2.1836|
000594  7921              LDRB     r1,[r4,#4]            ;938
000596  380d              SUBS     r0,r0,#0xd            ;938
000598  f8018000          STRB     r8,[r1,r0]            ;938
00059c  7960              LDRB     r0,[r4,#5]            ;941
00059e  b388              CBZ      r0,|L2.1540|
0005a0  203a              MOVS     r0,#0x3a              ;943
0005a2  f7fffffe          BL       POWER_PROTOCOL_TxAddData
0005a6  201a              MOVS     r0,#0x1a              ;944
0005a8  f7fffffe          BL       POWER_PROTOCOL_TxAddData
0005ac  2006              MOVS     r0,#6                 ;945
0005ae  f7fffffe          BL       POWER_PROTOCOL_TxAddData
0005b2  200c              MOVS     r0,#0xc               ;946
0005b4  f7fffffe          BL       POWER_PROTOCOL_TxAddData
0005b8  79a0              LDRB     r0,[r4,#6]            ;947
0005ba  f7fffffe          BL       POWER_PROTOCOL_TxAddData
0005be  79e0              LDRB     r0,[r4,#7]            ;948
0005c0  f7fffffe          BL       POWER_PROTOCOL_TxAddData
0005c4  7a20              LDRB     r0,[r4,#8]            ;949
0005c6  f7fffffe          BL       POWER_PROTOCOL_TxAddData
0005ca  7a60              LDRB     r0,[r4,#9]            ;950
0005cc  f7fffffe          BL       POWER_PROTOCOL_TxAddData
0005d0  7aa0              LDRB     r0,[r4,#0xa]          ;951
0005d2  f7fffffe          BL       POWER_PROTOCOL_TxAddData
0005d6  7ae0              LDRB     r0,[r4,#0xb]          ;952
0005d8  f7fffffe          BL       POWER_PROTOCOL_TxAddData
0005dc  7b20              LDRB     r0,[r4,#0xc]          ;953
0005de  f7fffffe          BL       POWER_PROTOCOL_TxAddData
0005e2  7b60              LDRB     r0,[r4,#0xd]          ;954
0005e4  f7fffffe          BL       POWER_PROTOCOL_TxAddData
0005e8  7ba0              LDRB     r0,[r4,#0xe]          ;955
0005ea  f7fffffe          BL       POWER_PROTOCOL_TxAddData
0005ee  7be0              LDRB     r0,[r4,#0xf]          ;956
0005f0  f7fffffe          BL       POWER_PROTOCOL_TxAddData
0005f4  7c20              LDRB     r0,[r4,#0x10]         ;957
0005f6  f7fffffe          BL       POWER_PROTOCOL_TxAddData
0005fa  7c60              LDRB     r0,[r4,#0x11]         ;958
0005fc  f7fffffe          BL       POWER_PROTOCOL_TxAddData
000600  f7fffffe          BL       POWER_PROTOCOL_TxAddFrame
                  |L2.1540|
000604  7960              LDRB     r0,[r4,#5]            ;963
000606  2800              CMP      r0,#0                 ;963
000608  d1bd              BNE      |L2.1414|
00060a  2055              MOVS     r0,#0x55              ;965
00060c  f7fffffe          BL       STS_PROTOCOL_TxAddData
000610  200c              MOVS     r0,#0xc               ;966
000612  f7fffffe          BL       STS_PROTOCOL_TxAddData
000616  2007              MOVS     r0,#7                 ;967
000618  f7fffffe          BL       STS_PROTOCOL_TxAddData
00061c  2001              MOVS     r0,#1                 ;968
00061e  f7fffffe          BL       STS_PROTOCOL_TxAddData
000622  79a0              LDRB     r0,[r4,#6]            ;969
000624  f7fffffe          BL       HexToChar
000628  4680              MOV      r8,r0                 ;969
00062a  79e0              LDRB     r0,[r4,#7]            ;969
00062c  f7fffffe          BL       HexToChar
000630  f368101f          BFI      r0,r8,#4,#28          ;969
000634  b2c0              UXTB     r0,r0                 ;969
000636  f7fffffe          BL       STS_PROTOCOL_TxAddData
00063a  7a20              LDRB     r0,[r4,#8]            ;970
00063c  f7fffffe          BL       HexToChar
000640  4680              MOV      r8,r0                 ;970
000642  7a60              LDRB     r0,[r4,#9]            ;970
000644  f7fffffe          BL       HexToChar
000648  f368101f          BFI      r0,r8,#4,#28          ;970
00064c  b2c0              UXTB     r0,r0                 ;970
00064e  f7fffffe          BL       STS_PROTOCOL_TxAddData
000652  7aa0              LDRB     r0,[r4,#0xa]          ;971
000654  f7fffffe          BL       HexToChar
000658  4680              MOV      r8,r0                 ;971
00065a  7ae0              LDRB     r0,[r4,#0xb]          ;971
00065c  f7fffffe          BL       HexToChar
000660  f368101f          BFI      r0,r8,#4,#28          ;971
000664  b2c0              UXTB     r0,r0                 ;971
000666  f7fffffe          BL       STS_PROTOCOL_TxAddData
00066a  7b20              LDRB     r0,[r4,#0xc]          ;972
00066c  f7fffffe          BL       HexToChar
000670  4680              MOV      r8,r0                 ;972
000672  7b60              LDRB     r0,[r4,#0xd]          ;972
000674  f7fffffe          BL       HexToChar
000678  f368101f          BFI      r0,r8,#4,#28          ;972
00067c  b2c0              UXTB     r0,r0                 ;972
00067e  f7fffffe          BL       STS_PROTOCOL_TxAddData
000682  7ba0              LDRB     r0,[r4,#0xe]          ;973
000684  f7fffffe          BL       HexToChar
000688  4680              MOV      r8,r0                 ;973
00068a  7be0              LDRB     r0,[r4,#0xf]          ;973
00068c  f7fffffe          BL       HexToChar
000690  f368101f          BFI      r0,r8,#4,#28          ;973
000694  b2c0              UXTB     r0,r0                 ;973
000696  f7fffffe          BL       STS_PROTOCOL_TxAddData
00069a  7c20              LDRB     r0,[r4,#0x10]         ;974
00069c  f7fffffe          BL       HexToChar
0006a0  4680              MOV      r8,r0                 ;974
0006a2  7c60              LDRB     r0,[r4,#0x11]         ;974
0006a4  f7fffffe          BL       HexToChar
0006a8  f368101f          BFI      r0,r8,#4,#28          ;974
0006ac  b2c0              UXTB     r0,r0                 ;974
0006ae  f7fffffe          BL       STS_PROTOCOL_TxAddData
                  |L2.1714|
0006b2  1970              ADDS     r0,r6,r5              ;978
0006b4  f890010c          LDRB     r0,[r0,#0x10c]        ;978
0006b8  f7fffffe          BL       STS_PROTOCOL_TxAddData
0006bc  1c6d              ADDS     r5,r5,#1              ;976
0006be  b2ed              UXTB     r5,r5                 ;976
0006c0  2d14              CMP      r5,#0x14              ;976
0006c2  d3f6              BCC      |L2.1714|
0006c4  f7fffffe          BL       STS_PROTOCOL_TxAddFrame
0006c8  e4fd              B        |L2.198|
                  |L2.1738|
0006ca  2101              MOVS     r1,#1                 ;987
0006cc  2003              MOVS     r0,#3                 ;987
0006ce  f7fffffe          BL       STS_PROTOCOL_SendCmdParamAck
0006d2  e4f8              B        |L2.198|
                  |L2.1748|
0006d4  f64031b8          MOV      r1,#0xbb8             ;992
0006d8  2011              MOVS     r0,#0x11              ;992
0006da  f7fffffe          BL       TIMER_ChangeTime
0006de  f8b42052          LDRH     r2,[r4,#0x52]         ;993
0006e2  1ca1              ADDS     r1,r4,#2              ;993
0006e4  2000              MOVS     r0,#0                 ;993
0006e6  f7fffffe          BL       STS_UART_AddTxArray
0006ea  e4ec              B        |L2.198|
                  |L2.1772|
0006ec  f896010a          LDRB     r0,[r6,#0x10a]        ;1000  ; dut_info
0006f0  b150              CBZ      r0,|L2.1800|
0006f2  4a0f              LDR      r2,|L2.1840|
0006f4  7960              LDRB     r0,[r4,#5]            ;1002
0006f6  7812              LDRB     r2,[r2,#0]            ;1002  ; keyValue
0006f8  4290              CMP      r0,r2                 ;1002
0006fa  d100              BNE      |L2.1790|
0006fc  2101              MOVS     r1,#1                 ;1004
                  |L2.1790|
0006fe  7c22              LDRB     r2,[r4,#0x10]         ;1010
000700  201e              MOVS     r0,#0x1e              ;1010
000702  f7fffffe          BL       STS_PROTOCOL_SendCmdParamTwoAck
000706  e4de              B        |L2.198|
                  |L2.1800|
000708  f8b42052          LDRH     r2,[r4,#0x52]         ;1015
00070c  1ca1              ADDS     r1,r4,#2              ;1015
00070e  2000              MOVS     r0,#0                 ;1015
000710  f7fffffe          BL       STS_UART_AddTxArray
000714  2200              MOVS     r2,#0                 ;1018
000716  2104              MOVS     r1,#4                 ;1018
000718  4806              LDR      r0,|L2.1844|
00071a  f7fffffe          BL       Vertical_Scrolling_Display
00071e  e4d2              B        |L2.198|
;;;1034   
                          ENDP

                  |L2.1824|
                          DCD      verreadFlag
                  |L2.1828|
                          DCD      verwriteFlag
                  |L2.1832|
                          DCD      dutverBuff
                  |L2.1836|
                          DCD      dut_info+0x10c
                  |L2.1840|
                          DCD      keyValue
                  |L2.1844|
                          DCD      ptUpMsgBuff

                          AREA ||i.DUT_PROTOCOL_ConfirmTempCmdFrameBuff||, CODE, READONLY, ALIGN=1

                  DUT_PROTOCOL_ConfirmTempCmdFrameBuff PROC
;;;230    // 将临时缓冲区添加到命令帧缓冲区中，其本质操作是承认临时缓冲区数据有效
;;;231    BOOL DUT_PROTOCOL_ConfirmTempCmdFrameBuff(DUT_PROTOCOL_CB *pCB)
000000  2800              CMP      r0,#0
;;;232    {
000002  d01e              BEQ      |L3.66|
;;;233        DUT_PROTOCOL_RX_CMD_FRAME *pCmdFrame = NULL;
;;;234    
;;;235        // 参数合法性检验
;;;236        if (NULL == pCB)
;;;237        {
;;;238            return FALSE;
;;;239        }
;;;240    
;;;241        // 临时缓冲区为空，不予添加
;;;242        pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.end];
000004  f8b01276          LDRH     r1,[r0,#0x276]
000008  ebc102c1          RSB      r2,r1,r1,LSL #3
00000c  eb020242          ADD      r2,r2,r2,LSL #1
000010  eb000282          ADD      r2,r0,r2,LSL #2
;;;243        if (0 == pCmdFrame->length)
000014  f8b22122          LDRH     r2,[r2,#0x122]
000018  b1aa              CBZ      r2,|L3.70|
;;;244        {
;;;245            return FALSE;
;;;246        }
;;;247    
;;;248        // 添加
;;;249        pCB->rx.end++;
00001a  1c49              ADDS     r1,r1,#1
00001c  b289              UXTH     r1,r1
;;;250        pCB->rx.end %= DUT_PROTOCOL_RX_QUEUE_SIZE;
00001e  2205              MOVS     r2,#5
000020  fbb1f3f2          UDIV     r3,r1,r2
000024  fb021113          MLS      r1,r2,r3,r1
000028  f8a01276          STRH     r1,[r0,#0x276]
;;;251        pCB->rx.cmdQueue[pCB->rx.end].length = 0; // 该行的作用是将新的添加位置有效数据个数清零，以便将这个位置当做临时帧缓冲区
00002c  ebc101c1          RSB      r1,r1,r1,LSL #3
000030  eb010141          ADD      r1,r1,r1,LSL #1
000034  eb000081          ADD      r0,r0,r1,LSL #2
000038  2200              MOVS     r2,#0
00003a  f8a02122          STRH     r2,[r0,#0x122]
;;;252    
;;;253        return TRUE;
00003e  2001              MOVS     r0,#1
;;;254    }
000040  4770              BX       lr
                  |L3.66|
000042  2000              MOVS     r0,#0                 ;238
000044  4770              BX       lr
                  |L3.70|
000046  2000              MOVS     r0,#0                 ;245
000048  4770              BX       lr
;;;255    
                          ENDP


                          AREA ||i.DUT_PROTOCOL_DataStructInit||, CODE, READONLY, ALIGN=1

                  DUT_PROTOCOL_DataStructInit PROC
;;;162    // 数据结构初始化
;;;163    void DUT_PROTOCOL_DataStructInit(DUT_PROTOCOL_CB *pCB)
000000  2800              CMP      r0,#0
;;;164    {
000002  d029              BEQ      |L4.88|
;;;165        uint16 i;
;;;166    
;;;167        // 参数合法性检验
;;;168        if (NULL == pCB)
;;;169        {
;;;170            return;
;;;171        }
;;;172    
;;;173        pCB->tx.txBusy = FALSE;
000004  2300              MOVS     r3,#0
000006  f8803580          STRB     r3,[r0,#0x580]
;;;174        pCB->tx.index = 0;
00000a  f8a0357e          STRH     r3,[r0,#0x57e]
;;;175        pCB->tx.head = 0;
00000e  f8a0357a          STRH     r3,[r0,#0x57a]
;;;176        pCB->tx.end = 0;
000012  f8a0357c          STRH     r3,[r0,#0x57c]
;;;177        for (i = 0; i < DUT_PROTOCOL_TX_QUEUE_SIZE; i++)
000016  2100              MOVS     r1,#0
                  |L4.24|
;;;178        {
;;;179            pCB->tx.cmdQueue[i].length = 0;
000018  224d              MOVS     r2,#0x4d
00001a  434a              MULS     r2,r1,r2
00001c  eb000242          ADD      r2,r0,r2,LSL #1
000020  f8a23310          STRH     r3,[r2,#0x310]
000024  1c49              ADDS     r1,r1,#1              ;177
000026  b289              UXTH     r1,r1                 ;177
000028  2905              CMP      r1,#5                 ;177
00002a  d3f5              BCC      |L4.24|
;;;180        }
;;;181    
;;;182        pCB->rxFIFO.head = 0;
00002c  f8203fc8          STRH     r3,[r0,#0xc8]!
;;;183        pCB->rxFIFO.end = 0;
000030  8043              STRH     r3,[r0,#2]
;;;184        pCB->rxFIFO.currentProcessIndex = 0;
000032  8083              STRH     r3,[r0,#4]
;;;185    
;;;186        pCB->rx.head = 0;
000034  f8a031ac          STRH     r3,[r0,#0x1ac]
;;;187        pCB->rx.end = 0;
000038  f8a031ae          STRH     r3,[r0,#0x1ae]
00003c  38c8              SUBS     r0,r0,#0xc8
;;;188        for (i = 0; i < DUT_PROTOCOL_RX_QUEUE_SIZE; i++)
00003e  2100              MOVS     r1,#0
                  |L4.64|
;;;189        {
;;;190            pCB->rx.cmdQueue[i].length = 0;
000040  ebc102c1          RSB      r2,r1,r1,LSL #3
000044  eb020242          ADD      r2,r2,r2,LSL #1
000048  eb000282          ADD      r2,r0,r2,LSL #2
00004c  f8a23122          STRH     r3,[r2,#0x122]
000050  1c49              ADDS     r1,r1,#1              ;188
000052  b289              UXTH     r1,r1                 ;188
000054  2905              CMP      r1,#5                 ;188
000056  d3f3              BCC      |L4.64|
                  |L4.88|
;;;191        }
;;;192    }
000058  4770              BX       lr
;;;193    
                          ENDP


                          AREA ||i.DUT_PROTOCOL_Init||, CODE, READONLY, ALIGN=2

                  DUT_PROTOCOL_Init PROC
;;;66     // 协议初始化
;;;67     void DUT_PROTOCOL_Init(void)
000000  b510              PUSH     {r4,lr}
;;;68     {
;;;69         // 协议层数据结构初始化
;;;70         DUT_PROTOCOL_DataStructInit(&uartProtocolCB3);
000002  4805              LDR      r0,|L5.24|
000004  f7fffffe          BL       DUT_PROTOCOL_DataStructInit
;;;71     
;;;72         // 向驱动层注册数据接收接口
;;;73         UART_DRIVE_RegisterDataSendService(DUT_PROTOCOL_MacProcess);
000008  4804              LDR      r0,|L5.28|
00000a  f7fffffe          BL       UART_DRIVE_RegisterDataSendService
;;;74     
;;;75         // 向驱动层注册数据发送接口
;;;76         DUT_PROTOCOL_RegisterDataSendService(UART_DRIVE_AddTxArray);
00000e  e8bd4010          POP      {r4,lr}
000012  4803              LDR      r0,|L5.32|
000014  f7ffbffe          B.W      DUT_PROTOCOL_RegisterDataSendService
;;;77     }
;;;78     
                          ENDP

                  |L5.24|
                          DCD      ||.bss||
                  |L5.28|
                          DCD      DUT_PROTOCOL_MacProcess
                  |L5.32|
                          DCD      UART_DRIVE_AddTxArray

                          AREA ||i.DUT_PROTOCOL_MacProcess||, CODE, READONLY, ALIGN=2

                  DUT_PROTOCOL_MacProcess PROC
;;;194    // UART报文接收处理函数(注意根据具体模块修改)
;;;195    void DUT_PROTOCOL_MacProcess(uint16 standarID, uint8 *pData, uint16 length)
000000  b570              PUSH     {r4-r6,lr}
;;;196    {
;;;197        uint16 end = uartProtocolCB3.rxFIFO.end;
000002  480d              LDR      r0,|L6.56|
000004  f8b020ca          LDRH     r2,[r0,#0xca]  ; uartProtocolCB3
;;;198        uint16 head = uartProtocolCB3.rxFIFO.head;
000008  f8b040c8          LDRH     r4,[r0,#0xc8]  ; uartProtocolCB3
;;;199        uint8 rxdata = 0x00;
;;;200    
;;;201        // 接收数据
;;;202        rxdata = *pData;
00000c  780d              LDRB     r5,[r1,#0]
;;;203    
;;;204    //    UART_PROTOCOL4_MacProcess(standarID, pData, length);
;;;205        
;;;206        // 一级缓冲区已满，不予接收
;;;207        if ((end + 1) % DUT_PROTOCOL_RX_FIFO_SIZE == head)
00000e  1c53              ADDS     r3,r2,#1
000010  21c8              MOVS     r1,#0xc8
000012  fbb3f6f1          UDIV     r6,r3,r1
000016  fb013316          MLS      r3,r1,r6,r3
00001a  42a3              CMP      r3,r4
00001c  d00a              BEQ      |L6.52|
;;;208        {
;;;209            return;
;;;210        }
;;;211        // 一级缓冲区未满，接收
;;;212        else
;;;213        {
;;;214            // 将接收到的数据放到临时缓冲区中
;;;215            uartProtocolCB3.rxFIFO.buff[end] = rxdata;
00001e  5485              STRB     r5,[r0,r2]
;;;216            uartProtocolCB3.rxFIFO.end++;
000020  f8302fca          LDRH     r2,[r0,#0xca]!  ; uartProtocolCB3
000024  1c52              ADDS     r2,r2,#1
000026  8002              STRH     r2,[r0,#0]
;;;217            uartProtocolCB3.rxFIFO.end %= DUT_PROTOCOL_RX_FIFO_SIZE;
000028  8802              LDRH     r2,[r0,#0]  ; uartProtocolCB3
00002a  fbb2f3f1          UDIV     r3,r2,r1
00002e  fb012113          MLS      r1,r1,r3,r2
000032  8001              STRH     r1,[r0,#0]
                  |L6.52|
;;;218        }
;;;219    
;;;220        // 借用KM5S协议解析
;;;221        // DUT_PROTOCOL_MacProcess(standarID, pData, length);
;;;222    }
000034  bd70              POP      {r4-r6,pc}
;;;223    
                          ENDP

000036  0000              DCW      0x0000
                  |L6.56|
                          DCD      ||.bss||

                          AREA ||i.DUT_PROTOCOL_RegisterDataSendService||, CODE, READONLY, ALIGN=2

                  DUT_PROTOCOL_RegisterDataSendService PROC
;;;224    // UART协议层向驱动层注册数据发送接口
;;;225    void DUT_PROTOCOL_RegisterDataSendService(BOOL (*service)(uint16 id, uint8 *pData, uint16 length))
000000  4901              LDR      r1,|L7.8|
;;;226    {
;;;227        uartProtocolCB3.sendDataThrowService = service;
000002  f8c10584          STR      r0,[r1,#0x584]  ; uartProtocolCB3
;;;228    }
000006  4770              BX       lr
;;;229    
                          ENDP

                  |L7.8|
                          DCD      ||.bss||

                          AREA ||i.DUT_PROTOCOL_RxFIFOProcess||, CODE, READONLY, ALIGN=1

                  DUT_PROTOCOL_RxFIFOProcess PROC
;;;289    // 一级接收缓冲区处理，从一级接收缓冲区中取出一个字节添加到命令帧缓冲区中
;;;290    void DUT_PROTOCOL_RxFIFOProcess(DUT_PROTOCOL_CB *pCB)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;291    {
000004  4604              MOV      r4,r0
;;;292        uint16 end = pCB->rxFIFO.end;
000006  f8b410ca          LDRH     r1,[r4,#0xca]
;;;293        uint16 head = pCB->rxFIFO.head;
00000a  f8b400c8          LDRH     r0,[r4,#0xc8]
;;;294        DUT_PROTOCOL_RX_CMD_FRAME *pCmdFrame = NULL;
;;;295        uint16 length = 0;
;;;296        uint8 currentData = 0;
;;;297    
;;;298        // 参数合法性检验
;;;299        if (NULL == pCB)
00000e  2c00              CMP      r4,#0
000010  d023              BEQ      |L8.90|
;;;300        {
;;;301            return;
;;;302        }
;;;303    
;;;304        // 一级缓冲区为空，退出
;;;305        if (head == end)
000012  4288              CMP      r0,r1
000014  d021              BEQ      |L8.90|
;;;306        {
;;;307            return;
;;;308        }
;;;309    
;;;310        // 获取临时缓冲区指针
;;;311        pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.end];
000016  f8b40276          LDRH     r0,[r4,#0x276]
00001a  ebc002c0          RSB      r2,r0,r0,LSL #3
00001e  eb020242          ADD      r2,r2,r2,LSL #1
000022  eb040582          ADD      r5,r4,r2,LSL #2
000026  35d0              ADDS     r5,r5,#0xd0
;;;312    
;;;313        // 取出当前要处理的字节
;;;314        currentData = pCB->rxFIFO.buff[pCB->rxFIFO.currentProcessIndex];
000028  f8b420cc          LDRH     r2,[r4,#0xcc]
00002c  5ca2              LDRB     r2,[r4,r2]
;;;315    
;;;316        // 临时缓冲区长度为0时，搜索首字节
;;;317        if (0 == pCmdFrame->length)
00002e  f8b53052          LDRH     r3,[r5,#0x52]
;;;318        {
;;;319            // 命令头错误，删除当前字节并退出
;;;320            if (DUT_PROTOCOL_CMD_HEAD != currentData)
;;;321            {
;;;322                pCB->rxFIFO.head++;
;;;323                pCB->rxFIFO.head %= DUT_PROTOCOL_RX_FIFO_SIZE;
000032  26c8              MOVS     r6,#0xc8
000034  b19b              CBZ      r3,|L8.94|
;;;324                pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;325    
;;;326                return;
;;;327            }
;;;328    
;;;329            // 命令头正确，但无临时缓冲区可用，退出
;;;330            if ((pCB->rx.end + 1) % DUT_PROTOCOL_RX_QUEUE_SIZE == pCB->rx.head)
;;;331            {
;;;332                return;
;;;333            }
;;;334    
;;;335            // 添加UART通讯超时时间设置-2016.1.5增加
;;;336    #if UART_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;337            TIMER_AddTask(TIMER_ID_UART_RX_TIME_OUT_CONTROL,
;;;338                          UART_PROTOCOL_BUS_UNIDIRECTIONAL_TIME_OUT,
;;;339                          UART_PROTOCOL_CALLBACK_RxTimeOut,
;;;340                          0,
;;;341                          1,
;;;342                          ACTION_MODE_ADD_TO_QUEUE);
;;;343    #endif
;;;344    
;;;345            // 命令头正确，有临时缓冲区可用，则将其添加到命令帧临时缓冲区中
;;;346            pCmdFrame->buff[pCmdFrame->length++] = currentData;
;;;347            pCB->rxFIFO.currentProcessIndex++;
;;;348            pCB->rxFIFO.currentProcessIndex %= DUT_PROTOCOL_RX_FIFO_SIZE;
;;;349        }
;;;350        // 非首字节，将数据添加到命令帧临时缓冲区中，但暂不删除当前数据
;;;351        else
;;;352        {
;;;353            // 临时缓冲区溢出，说明当前正在接收的命令帧是错误的，正确的命令帧不会出现长度溢出的情况
;;;354            if (pCmdFrame->length >= DUT_PROTOCOL_RX_CMD_FRAME_LENGTH_MAX)
000036  f04f0800          MOV      r8,#0
00003a  2b96              CMP      r3,#0x96
00003c  d37e              BCC      |L8.316|
;;;355            {
;;;356    #if UART_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;357                // 停止RX通讯超时检测
;;;358                UART_PROTOCOL_StopRxTimeOutCheck();
;;;359    #endif
;;;360    
;;;361                // 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;362                pCmdFrame->length = 0; // 2016.1.5增加
00003e  f8a58052          STRH     r8,[r5,#0x52]
;;;363                // 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;364                pCB->rxFIFO.head++;
000042  f8340fc8          LDRH     r0,[r4,#0xc8]!
000046  1c40              ADDS     r0,r0,#1
000048  8020              STRH     r0,[r4,#0]
;;;365                pCB->rxFIFO.head %= DUT_PROTOCOL_RX_FIFO_SIZE;
00004a  8820              LDRH     r0,[r4,#0]
00004c  fbb0f1f6          UDIV     r1,r0,r6
000050  fb060011          MLS      r0,r6,r1,r0
000054  8020              STRH     r0,[r4,#0]
;;;366                pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
000056  8820              LDRH     r0,[r4,#0]
000058  80a0              STRH     r0,[r4,#4]
                  |L8.90|
;;;367    
;;;368                return;
;;;369            }
;;;370    
;;;371            // 一直取到末尾
;;;372            while (end != pCB->rxFIFO.currentProcessIndex)
;;;373            {
;;;374                // 取出当前要处理的字节
;;;375                currentData = pCB->rxFIFO.buff[pCB->rxFIFO.currentProcessIndex];
;;;376                // 缓冲区未溢出，正常接收，将数据添加到临时缓冲区中
;;;377                pCmdFrame->buff[pCmdFrame->length++] = currentData;
;;;378                pCB->rxFIFO.currentProcessIndex++;
;;;379                pCB->rxFIFO.currentProcessIndex %= DUT_PROTOCOL_RX_FIFO_SIZE;
;;;380    
;;;381                // ■■接下来，需要检查命令帧是否完整，如果完整，则将命令帧临时缓冲区扶正■■
;;;382    
;;;383                // 首先判断命令帧最小长度，一个完整的命令字至少包括8个字节: 命令头、设备地址、命令字、数据长度、校验和L、校验和H、结束标识0xD、结束标识OxA，因此不足8个字节的必定不完整
;;;384                if (pCmdFrame->length < DUT_PROTOCOL_CMD_FRAME_LENGTH_MIN)
;;;385                {
;;;386                    // 继续接收
;;;387                    continue;
;;;388                }
;;;389    
;;;390                // 命令帧长度数值越界，说明当前命令帧错误，停止接收
;;;391                if (pCmdFrame->buff[DUT_PROTOCOL_CMD_LENGTH_INDEX] > DUT_PROTOCOL_RX_CMD_FRAME_LENGTH_MAX - DUT_PROTOCOL_CMD_FRAME_LENGTH_MIN)
;;;392                {
;;;393    #if UART_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;394                    // 停止RX通讯超时检测
;;;395                    UART_PROTOCOL_StopRxTimeOutCheck();
;;;396    #endif
;;;397    
;;;398                    // 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;399                    pCmdFrame->length = 0;
;;;400                    // 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;401                    pCB->rxFIFO.head++;
;;;402                    pCB->rxFIFO.head %= DUT_PROTOCOL_RX_FIFO_SIZE;
;;;403                    pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;404    
;;;405                    return;
;;;406                }
;;;407    
;;;408                // 命令帧长度校验，在命令长度描述字的数值上，增加命令头、设备地址、命令字、数据长度、校验和L、校验和H、结束标识0xD、结束标识OxA，即为命令帧实际长度
;;;409                length = pCmdFrame->length;
;;;410                if (length < pCmdFrame->buff[DUT_PROTOCOL_CMD_LENGTH_INDEX] + DUT_PROTOCOL_CMD_FRAME_LENGTH_MIN)
;;;411                {
;;;412                    // 长度要求不一致，说明未接收完毕，退出继续
;;;413                    continue;
;;;414                }
;;;415    
;;;416                // 命令帧长度OK，则进行校验，失败时删除命令头
;;;417                if (!DUT_PROTOCOL_CheckSUM(pCmdFrame))
;;;418                {
;;;419    #if UART_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;420                    // 停止RX通讯超时检测
;;;421                    UART_PROTOCOL_StopRxTimeOutCheck();
;;;422    #endif
;;;423    
;;;424                    // 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;425                    pCmdFrame->length = 0;
;;;426                    // 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;427                    pCB->rxFIFO.head++;
;;;428                    pCB->rxFIFO.head %= DUT_PROTOCOL_RX_FIFO_SIZE;
;;;429                    pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;430    
;;;431                    return;
;;;432                }
;;;433    
;;;434    #if UART_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;435                // 停止RX通讯超时检测
;;;436                UART_PROTOCOL_StopRxTimeOutCheck();
;;;437    #endif
;;;438    
;;;439                // 执行到这里，即说明接收到了一个完整并且正确的命令帧，此时需将处理过的数据从一级缓冲区中删除，并将该命令帧扶正
;;;440                pCB->rxFIFO.head += length;
;;;441                pCB->rxFIFO.head %= DUT_PROTOCOL_RX_FIFO_SIZE;
;;;442                pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;443                DUT_PROTOCOL_ConfirmTempCmdFrameBuff(pCB);
;;;444    
;;;445                return;
;;;446            }
;;;447        }
;;;448    }
00005a  e8bd81f0          POP      {r4-r8,pc}
                  |L8.94|
00005e  2a55              CMP      r2,#0x55              ;320
000060  d00c              BEQ      |L8.124|
000062  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;322
000066  1c40              ADDS     r0,r0,#1              ;322
000068  8020              STRH     r0,[r4,#0]            ;322
00006a  8820              LDRH     r0,[r4,#0]            ;323
00006c  fbb0f1f6          UDIV     r1,r0,r6              ;323
000070  fb060011          MLS      r0,r6,r1,r0           ;323
000074  8020              STRH     r0,[r4,#0]            ;323
000076  8820              LDRH     r0,[r4,#0]            ;324
000078  80a0              STRH     r0,[r4,#4]            ;324
00007a  e7ee              B        |L8.90|
                  |L8.124|
00007c  1c40              ADDS     r0,r0,#1              ;330
00007e  2105              MOVS     r1,#5                 ;330
000080  fbb0f3f1          UDIV     r3,r0,r1              ;330
000084  fb010013          MLS      r0,r1,r3,r0           ;330
000088  f8b41274          LDRH     r1,[r4,#0x274]        ;330
00008c  4288              CMP      r0,r1                 ;330
00008e  d0e4              BEQ      |L8.90|
000090  2001              MOVS     r0,#1                 ;346
000092  f8a50052          STRH     r0,[r5,#0x52]         ;346
000096  70aa              STRB     r2,[r5,#2]            ;346
000098  f8340fcc          LDRH     r0,[r4,#0xcc]!        ;347
00009c  1c40              ADDS     r0,r0,#1              ;347
00009e  b280              UXTH     r0,r0                 ;347
0000a0  fbb0f1f6          UDIV     r1,r0,r6              ;348
0000a4  fb060011          MLS      r0,r6,r1,r0           ;348
0000a8  8020              STRH     r0,[r4,#0]            ;348
0000aa  e7d6              B        |L8.90|
                  |L8.172|
0000ac  5c22              LDRB     r2,[r4,r0]            ;375
0000ae  f8b50052          LDRH     r0,[r5,#0x52]         ;377
0000b2  1c43              ADDS     r3,r0,#1              ;377
0000b4  4428              ADD      r0,r0,r5              ;377
0000b6  f8a53052          STRH     r3,[r5,#0x52]         ;377
0000ba  7082              STRB     r2,[r0,#2]            ;377
0000bc  f8b400cc          LDRH     r0,[r4,#0xcc]         ;378
0000c0  1c40              ADDS     r0,r0,#1              ;378
0000c2  b280              UXTH     r0,r0                 ;378
0000c4  fbb0f2f6          UDIV     r2,r0,r6              ;379
0000c8  fb060012          MLS      r0,r6,r2,r0           ;379
0000cc  f8a400cc          STRH     r0,[r4,#0xcc]         ;379
0000d0  f8b57052          LDRH     r7,[r5,#0x52]         ;384
0000d4  2f04              CMP      r7,#4                 ;384
0000d6  d33b              BCC      |L8.336|
0000d8  7928              LDRB     r0,[r5,#4]            ;391
0000da  2892              CMP      r0,#0x92              ;391
0000dc  d90e              BLS      |L8.252|
0000de  f8a58052          STRH     r8,[r5,#0x52]         ;399
0000e2  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;401
0000e6  1c40              ADDS     r0,r0,#1              ;401
0000e8  8020              STRH     r0,[r4,#0]            ;401
0000ea  8820              LDRH     r0,[r4,#0]            ;402
0000ec  fbb0f1f6          UDIV     r1,r0,r6              ;402
0000f0  fb060011          MLS      r0,r6,r1,r0           ;402
0000f4  8020              STRH     r0,[r4,#0]            ;402
0000f6  8820              LDRH     r0,[r4,#0]            ;403
0000f8  80a0              STRH     r0,[r4,#4]            ;403
0000fa  e7ae              B        |L8.90|
                  |L8.252|
0000fc  1d00              ADDS     r0,r0,#4              ;410
0000fe  42b8              CMP      r0,r7                 ;410
000100  d826              BHI      |L8.336|
000102  4628              MOV      r0,r5                 ;417
000104  f7fffffe          BL       DUT_PROTOCOL_CheckSUM
000108  b188              CBZ      r0,|L8.302|
00010a  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;440
00010e  4438              ADD      r0,r0,r7              ;440
000110  8020              STRH     r0,[r4,#0]            ;440
000112  8820              LDRH     r0,[r4,#0]            ;441
000114  fbb0f1f6          UDIV     r1,r0,r6              ;441
000118  fb060011          MLS      r0,r6,r1,r0           ;441
00011c  8020              STRH     r0,[r4,#0]            ;441
00011e  8820              LDRH     r0,[r4,#0]            ;442
000120  80a0              STRH     r0,[r4,#4]            ;442
000122  3cc8              SUBS     r4,r4,#0xc8           ;442
000124  4620              MOV      r0,r4                 ;443
000126  e8bd41f0          POP      {r4-r8,lr}            ;443
00012a  f7ffbffe          B.W      DUT_PROTOCOL_ConfirmTempCmdFrameBuff
                  |L8.302|
00012e  f8a58052          STRH     r8,[r5,#0x52]         ;425
000132  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;427
000136  1c40              ADDS     r0,r0,#1              ;427
000138  8020              STRH     r0,[r4,#0]            ;427
00013a  e000              B        |L8.318|
                  |L8.316|
00013c  e008              B        |L8.336|
                  |L8.318|
00013e  8820              LDRH     r0,[r4,#0]            ;428
000140  fbb0f1f6          UDIV     r1,r0,r6              ;428
000144  fb060011          MLS      r0,r6,r1,r0           ;428
000148  8020              STRH     r0,[r4,#0]            ;428
00014a  8820              LDRH     r0,[r4,#0]            ;429
00014c  80a0              STRH     r0,[r4,#4]            ;429
00014e  e784              B        |L8.90|
                  |L8.336|
000150  f8b400cc          LDRH     r0,[r4,#0xcc]         ;372
000154  4288              CMP      r0,r1                 ;372
000156  d1a9              BNE      |L8.172|
000158  e77f              B        |L8.90|
;;;449    
                          ENDP


                          AREA ||i.DUT_PROTOCOL_SendCmdAck||, CODE, READONLY, ALIGN=1

                  DUT_PROTOCOL_SendCmdAck PROC
;;;1035   // 发送命令回复
;;;1036   void DUT_PROTOCOL_SendCmdAck(uint8 ackCmd)
000000  b510              PUSH     {r4,lr}
;;;1037   {
000002  4604              MOV      r4,r0
;;;1038       DUT_PROTOCOL_TxAddData(DUT_PROTOCOL_CMD_HEAD);
000004  2055              MOVS     r0,#0x55
000006  f7fffffe          BL       DUT_PROTOCOL_TxAddData
;;;1039       DUT_PROTOCOL_TxAddData(ackCmd);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       DUT_PROTOCOL_TxAddData
;;;1040       DUT_PROTOCOL_TxAddData(0x00);         // 数据长度
000010  2000              MOVS     r0,#0
000012  f7fffffe          BL       DUT_PROTOCOL_TxAddData
;;;1041       DUT_PROTOCOL_TxAddFrame();
000016  e8bd4010          POP      {r4,lr}
00001a  f7ffbffe          B.W      DUT_PROTOCOL_TxAddFrame
;;;1042   }
;;;1043   
                          ENDP


                          AREA ||i.DUT_PROTOCOL_SendCmdParamAck||, CODE, READONLY, ALIGN=1

                  DUT_PROTOCOL_SendCmdParamAck PROC
;;;1044   // 发送命令回复，带一个参数
;;;1045   void DUT_PROTOCOL_SendCmdParamAck(uint8 ackCmd, uint8 ackParam)
000000  b530              PUSH     {r4,r5,lr}
;;;1046   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1047   
;;;1048       DUT_PROTOCOL_TxAddData(DUT_PROTOCOL_CMD_HEAD);
000006  2055              MOVS     r0,#0x55
000008  f7fffffe          BL       DUT_PROTOCOL_TxAddData
;;;1049       DUT_PROTOCOL_TxAddData(ackCmd);
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       DUT_PROTOCOL_TxAddData
;;;1050       DUT_PROTOCOL_TxAddData(0x01);
000012  2001              MOVS     r0,#1
000014  f7fffffe          BL       DUT_PROTOCOL_TxAddData
;;;1051   
;;;1052       DUT_PROTOCOL_TxAddData(ackParam);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       DUT_PROTOCOL_TxAddData
;;;1053       DUT_PROTOCOL_TxAddFrame();
00001e  e8bd4030          POP      {r4,r5,lr}
000022  f7ffbffe          B.W      DUT_PROTOCOL_TxAddFrame
;;;1054   }
;;;1055   
                          ENDP


                          AREA ||i.DUT_PROTOCOL_SendCmdTwoParamAck||, CODE, READONLY, ALIGN=1

                  DUT_PROTOCOL_SendCmdTwoParamAck PROC
;;;1056   // 发送命令回复，带两个个参数
;;;1057   void DUT_PROTOCOL_SendCmdTwoParamAck(uint8 ackCmd, uint8 ackParam, uint8 two_ackParam)
000000  b570              PUSH     {r4-r6,lr}
;;;1058   {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;1059       DUT_PROTOCOL_TxAddData(DUT_PROTOCOL_CMD_HEAD);
000008  2055              MOVS     r0,#0x55
00000a  f7fffffe          BL       DUT_PROTOCOL_TxAddData
;;;1060       DUT_PROTOCOL_TxAddData(ackCmd);
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       DUT_PROTOCOL_TxAddData
;;;1061       DUT_PROTOCOL_TxAddData(0x02);
000014  2002              MOVS     r0,#2
000016  f7fffffe          BL       DUT_PROTOCOL_TxAddData
;;;1062   
;;;1063       DUT_PROTOCOL_TxAddData(ackParam);
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       DUT_PROTOCOL_TxAddData
;;;1064       DUT_PROTOCOL_TxAddData(two_ackParam);
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       DUT_PROTOCOL_TxAddData
;;;1065       DUT_PROTOCOL_TxAddFrame();
000026  e8bd4070          POP      {r4-r6,lr}
00002a  f7ffbffe          B.W      DUT_PROTOCOL_TxAddFrame
;;;1066   }
;;;1067   
                          ENDP


                          AREA ||i.DUT_PROTOCOL_TxAddData||, CODE, READONLY, ALIGN=2

                  DUT_PROTOCOL_TxAddData PROC
;;;92     // 向发送命令帧队列中添加数据
;;;93     void DUT_PROTOCOL_TxAddData(uint8 data)
000000  b530              PUSH     {r4,r5,lr}
;;;94     {
;;;95         uint16 head = uartProtocolCB3.tx.head;
000002  490f              LDR      r1,|L12.64|
000004  f8b1457a          LDRH     r4,[r1,#0x57a]  ; uartProtocolCB3
;;;96         uint16 end = uartProtocolCB3.tx.end;
000008  f8b1257c          LDRH     r2,[r1,#0x57c]  ; uartProtocolCB3
;;;97         DUT_PROTOCOL_TX_CMD_FRAME *pCmdFrame = &uartProtocolCB3.tx.cmdQueue[uartProtocolCB3.tx.end];
00000c  234d              MOVS     r3,#0x4d
00000e  4353              MULS     r3,r2,r3
000010  eb010143          ADD      r1,r1,r3,LSL #1
000014  f501711e          ADD      r1,r1,#0x278
;;;98     
;;;99         // 发送缓冲区已满，不予接收
;;;100        if ((end + 1) % DUT_PROTOCOL_TX_QUEUE_SIZE == head)
000018  1c52              ADDS     r2,r2,#1
00001a  2305              MOVS     r3,#5
00001c  fbb2f5f3          UDIV     r5,r2,r3
000020  fb032215          MLS      r2,r3,r5,r2
000024  42a2              CMP      r2,r4
000026  d009              BEQ      |L12.60|
;;;101        {
;;;102            return;
;;;103        }
;;;104    
;;;105        // 队尾命令帧已满，退出
;;;106        if (pCmdFrame->length >= DUT_PROTOCOL_TX_CMD_FRAME_LENGTH_MAX)
000028  f8b12098          LDRH     r2,[r1,#0x98]
00002c  2a96              CMP      r2,#0x96
00002e  d205              BCS      |L12.60|
;;;107        {
;;;108            return;
;;;109        }
;;;110    
;;;111        // 数据添加到帧末尾，并更新帧长度
;;;112        pCmdFrame->buff[pCmdFrame->length] = data;
000030  1c8b              ADDS     r3,r1,#2
000032  54d0              STRB     r0,[r2,r3]
;;;113        pCmdFrame->length++;
000034  f8310f98          LDRH     r0,[r1,#0x98]!
000038  1c40              ADDS     r0,r0,#1
00003a  8008              STRH     r0,[r1,#0]
                  |L12.60|
;;;114    }
00003c  bd30              POP      {r4,r5,pc}
;;;115    
                          ENDP

00003e  0000              DCW      0x0000
                  |L12.64|
                          DCD      ||.bss||

                          AREA ||i.DUT_PROTOCOL_TxAddFrame||, CODE, READONLY, ALIGN=2

                  DUT_PROTOCOL_TxAddFrame PROC
;;;116    // 确认添加命令帧，即承认之前填充的数据为命令帧，将其添加到发送队列中，由main进行调度发送，本函数内会自动校正命令长度，并添加校验码
;;;117    void DUT_PROTOCOL_TxAddFrame(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;118    {
;;;119        uint16 cc = 0;
000002  2300              MOVS     r3,#0
;;;120        uint16 i = 0;
000004  2100              MOVS     r1,#0
;;;121        uint16 head = uartProtocolCB3.tx.head;
000006  4d20              LDR      r5,|L13.136|
000008  f8b5757a          LDRH     r7,[r5,#0x57a]  ; uartProtocolCB3
;;;122        uint16 end = uartProtocolCB3.tx.end;
00000c  f8b5457c          LDRH     r4,[r5,#0x57c]  ; uartProtocolCB3
;;;123        DUT_PROTOCOL_TX_CMD_FRAME *pCmdFrame = &uartProtocolCB3.tx.cmdQueue[uartProtocolCB3.tx.end];
000010  204d              MOVS     r0,#0x4d
000012  4360              MULS     r0,r4,r0
000014  eb050040          ADD      r0,r5,r0,LSL #1
000018  f500701e          ADD      r0,r0,#0x278
;;;124        uint16 length = pCmdFrame->length;
00001c  f8b02098          LDRH     r2,[r0,#0x98]
;;;125    
;;;126        // 发送缓冲区已满，不予接收
;;;127        if ((end + 1) % DUT_PROTOCOL_TX_QUEUE_SIZE == head)
000020  1c64              ADDS     r4,r4,#1
000022  2605              MOVS     r6,#5
000024  fbb4fcf6          UDIV     r12,r4,r6
000028  fb06441c          MLS      r4,r6,r12,r4
00002c  42bc              CMP      r4,r7
00002e  d00d              BEQ      |L13.76|
;;;128        {
;;;129            return;
;;;130        }
;;;131    
;;;132        // 队尾命令帧已满，退出
;;;133        if ((length >= DUT_PROTOCOL_TX_CMD_FRAME_LENGTH_MAX) || (length + 1 >= DUT_PROTOCOL_TX_CMD_FRAME_LENGTH_MAX)
000030  2a96              CMP      r2,#0x96
000032  d208              BCS      |L13.70|
000034  1c54              ADDS     r4,r2,#1
000036  2c96              CMP      r4,#0x96
000038  d205              BCS      |L13.70|
;;;134                || (length + 2 >= DUT_PROTOCOL_TX_CMD_FRAME_LENGTH_MAX) || (length + 3 >= DUT_PROTOCOL_TX_CMD_FRAME_LENGTH_MAX))
00003a  1c94              ADDS     r4,r2,#2
00003c  2c96              CMP      r4,#0x96
00003e  d202              BCS      |L13.70|
000040  1cd4              ADDS     r4,r2,#3
000042  2c96              CMP      r4,#0x96
000044  d303              BCC      |L13.78|
                  |L13.70|
;;;135        {
;;;136            pCmdFrame->length = 0;
000046  2100              MOVS     r1,#0
000048  f8a01098          STRH     r1,[r0,#0x98]
                  |L13.76|
;;;137    
;;;138            return;
;;;139        }
;;;140    
;;;141        // 队尾命令帧已满，退出
;;;142        if (length >= DUT_PROTOCOL_TX_CMD_FRAME_LENGTH_MAX)
;;;143        {
;;;144            return;
;;;145        }
;;;146    
;;;147    
;;;148        // 重新设置数据长度，系统在准备数据时，填充的"数据长度"可以为任意值，并且不需要添加校验码，在这里重新设置为正确的值
;;;149        pCmdFrame->buff[DUT_PROTOCOL_CMD_LENGTH_INDEX] = length - 3; // 重设数据长度，减去"命令头、设备地址、命令字、数据长度"4个字节
;;;150    
;;;151        for (i = 0; i < length; i++)
;;;152        {
;;;153            cc ^= pCmdFrame->buff[i];
;;;154        }
;;;155        pCmdFrame->buff[pCmdFrame->length++] = cc ;
;;;156    
;;;157    
;;;158        uartProtocolCB3.tx.end++;
;;;159        uartProtocolCB3.tx.end %= DUT_PROTOCOL_TX_QUEUE_SIZE;
;;;160    }
00004c  bdf0              POP      {r4-r7,pc}
                  |L13.78|
00004e  1ed4              SUBS     r4,r2,#3              ;149
000050  7104              STRB     r4,[r0,#4]            ;149
000052  e004              B        |L13.94|
                  |L13.84|
000054  1844              ADDS     r4,r0,r1              ;153
000056  78a4              LDRB     r4,[r4,#2]            ;153
000058  4063              EORS     r3,r3,r4              ;153
00005a  1c49              ADDS     r1,r1,#1              ;151
00005c  b289              UXTH     r1,r1                 ;151
                  |L13.94|
00005e  4291              CMP      r1,r2                 ;151
000060  d3f8              BCC      |L13.84|
000062  f8b01098          LDRH     r1,[r0,#0x98]         ;155
000066  1c4a              ADDS     r2,r1,#1              ;155
000068  f8a02098          STRH     r2,[r0,#0x98]         ;155
00006c  4408              ADD      r0,r0,r1              ;155
00006e  7083              STRB     r3,[r0,#2]            ;155
000070  f8b5057c          LDRH     r0,[r5,#0x57c]        ;158  ; uartProtocolCB3
000074  1c40              ADDS     r0,r0,#1              ;158
000076  b280              UXTH     r0,r0                 ;158
000078  fbb0f1f6          UDIV     r1,r0,r6              ;159
00007c  fb060011          MLS      r0,r6,r1,r0           ;159
000080  f8a5057c          STRH     r0,[r5,#0x57c]        ;159
000084  bdf0              POP      {r4-r7,pc}
;;;161    
                          ENDP

000086  0000              DCW      0x0000
                  |L13.136|
                          DCD      ||.bss||

                          AREA ||i.DUT_PROTOCOL_TxStateProcess||, CODE, READONLY, ALIGN=2

                  DUT_PROTOCOL_TxStateProcess PROC
;;;256    // 协议层发送处理过程
;;;257    void DUT_PROTOCOL_TxStateProcess(void)
000000  b570              PUSH     {r4-r6,lr}
;;;258    {
;;;259        uint16 head = uartProtocolCB3.tx.head;
000002  4c14              LDR      r4,|L14.84|
000004  f8b4357a          LDRH     r3,[r4,#0x57a]  ; uartProtocolCB3
;;;260        uint16 end = uartProtocolCB3.tx.end;
000008  f8b4657c          LDRH     r6,[r4,#0x57c]  ; uartProtocolCB3
;;;261        uint16 length = uartProtocolCB3.tx.cmdQueue[head].length;
00000c  204d              MOVS     r0,#0x4d
00000e  4358              MULS     r0,r3,r0
000010  eb040040          ADD      r0,r4,r0,LSL #1
000014  4605              MOV      r5,r0
000016  f8b02310          LDRH     r2,[r0,#0x310]
;;;262        uint8 *pCmd = uartProtocolCB3.tx.cmdQueue[head].buff;
00001a  f200217a          ADD      r1,r0,#0x27a
;;;263        uint16 localDeviceID = uartProtocolCB3.tx.cmdQueue[head].deviceID;
00001e  f8b00278          LDRH     r0,[r0,#0x278]
;;;264    
;;;265        // 发送缓冲区为空，说明无数据
;;;266        if (head == end)
000022  42b3              CMP      r3,r6
000024  d014              BEQ      |L14.80|
;;;267        {
;;;268            return;
;;;269        }
;;;270    
;;;271        // 发送函数没有注册直接返回
;;;272        if (NULL == uartProtocolCB3.sendDataThrowService)
000026  f8d43584          LDR      r3,[r4,#0x584]  ; uartProtocolCB3
00002a  2b00              CMP      r3,#0
00002c  d010              BEQ      |L14.80|
;;;273        {
;;;274            return;
;;;275        }
;;;276    
;;;277        // 协议层有数据需要发送到驱动层
;;;278        if (!(*uartProtocolCB3.sendDataThrowService)(localDeviceID, pCmd, length))
00002e  4798              BLX      r3
000030  2800              CMP      r0,#0
000032  d00d              BEQ      |L14.80|
;;;279        {
;;;280            return;
;;;281        }
;;;282    
;;;283        // 发送环形队列更新位置
;;;284        uartProtocolCB3.tx.cmdQueue[head].length = 0;
000034  2000              MOVS     r0,#0
000036  f8a50310          STRH     r0,[r5,#0x310]
;;;285        uartProtocolCB3.tx.head++;
00003a  f8b4057a          LDRH     r0,[r4,#0x57a]  ; uartProtocolCB3
00003e  1c40              ADDS     r0,r0,#1
000040  b280              UXTH     r0,r0
;;;286        uartProtocolCB3.tx.head %= DUT_PROTOCOL_TX_QUEUE_SIZE;
000042  2105              MOVS     r1,#5
000044  fbb0f2f1          UDIV     r2,r0,r1
000048  fb010012          MLS      r0,r1,r2,r0
00004c  f8a4057a          STRH     r0,[r4,#0x57a]
                  |L14.80|
;;;287    }
000050  bd70              POP      {r4-r6,pc}
;;;288    
                          ENDP

000052  0000              DCW      0x0000
                  |L14.84|
                          DCD      ||.bss||

                          AREA ||i.DUT_PROTOCOL_WriteFlag||, CODE, READONLY, ALIGN=1

                  DUT_PROTOCOL_WriteFlag PROC
;;;1074   // 写入标志区数据
;;;1075   void DUT_PROTOCOL_WriteFlag(uint8 placeParam, uint8 shutdownFlagParam)
000000  b530              PUSH     {r4,r5,lr}
;;;1076   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1077   
;;;1078       DUT_PROTOCOL_TxAddData(DUT_PROTOCOL_CMD_HEAD);
000006  2055              MOVS     r0,#0x55
000008  f7fffffe          BL       DUT_PROTOCOL_TxAddData
;;;1079       DUT_PROTOCOL_TxAddData(DUT_PROTOCOL_CMD_WRITE_FLAG_DATA);
00000c  20a7              MOVS     r0,#0xa7
00000e  f7fffffe          BL       DUT_PROTOCOL_TxAddData
;;;1080       DUT_PROTOCOL_TxAddData(0x06);
000012  2006              MOVS     r0,#6
000014  f7fffffe          BL       DUT_PROTOCOL_TxAddData
;;;1081   
;;;1082       DUT_PROTOCOL_TxAddData(placeParam);
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       DUT_PROTOCOL_TxAddData
;;;1083       DUT_PROTOCOL_TxAddData(0x00);
00001e  2000              MOVS     r0,#0
000020  f7fffffe          BL       DUT_PROTOCOL_TxAddData
;;;1084       DUT_PROTOCOL_TxAddData(0x00);
000024  2000              MOVS     r0,#0
000026  f7fffffe          BL       DUT_PROTOCOL_TxAddData
;;;1085       DUT_PROTOCOL_TxAddData(0x00);
00002a  2000              MOVS     r0,#0
00002c  f7fffffe          BL       DUT_PROTOCOL_TxAddData
;;;1086       DUT_PROTOCOL_TxAddData(0x02);
000030  2002              MOVS     r0,#2
000032  f7fffffe          BL       DUT_PROTOCOL_TxAddData
;;;1087       DUT_PROTOCOL_TxAddData(shutdownFlagParam);
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       DUT_PROTOCOL_TxAddData
;;;1088       DUT_PROTOCOL_TxAddFrame();
00003c  e8bd4030          POP      {r4,r5,lr}
000040  f7ffbffe          B.W      DUT_PROTOCOL_TxAddFrame
;;;1089   }
;;;1090   
                          ENDP


                          AREA ||i.DUT_UART_PROTOCOL_Process||, CODE, READONLY, ALIGN=2

                  DUT_UART_PROTOCOL_Process PROC
;;;79     // UART协议层过程处理
;;;80     void DUT_UART_PROTOCOL_Process(void)
000000  b510              PUSH     {r4,lr}
;;;81     {
;;;82         // UART接收FIFO缓冲区处理
;;;83         DUT_PROTOCOL_RxFIFOProcess(&uartProtocolCB3);
000002  4805              LDR      r0,|L16.24|
000004  f7fffffe          BL       DUT_PROTOCOL_RxFIFOProcess
;;;84     
;;;85         // UART接收命令缓冲区处理
;;;86         DUT_PROTOCOL_CmdFrameProcess(&uartProtocolCB3);
000008  4803              LDR      r0,|L16.24|
00000a  f7fffffe          BL       DUT_PROTOCOL_CmdFrameProcess
;;;87     
;;;88         // UART协议层发送处理过程
;;;89         DUT_PROTOCOL_TxStateProcess();
00000e  e8bd4010          POP      {r4,lr}
000012  f7ffbffe          B.W      DUT_PROTOCOL_TxStateProcess
;;;90     }
;;;91     
                          ENDP

000016  0000              DCW      0x0000
                  |L16.24|
                          DCD      ||.bss||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  uartProtocolCB3
                          %        1428

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

000000  ff000000          DCB      0xff,0x00,0x00,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  light_cnt
000000  00                DCB      0x00
                  ||cnt||
000001  00                DCB      0x00
                  cali_cnt
000002  00                DCB      0x00
                  brake_cnt
000003  00                DCB      0x00
                  derailleur_cnt
000004  00                DCB      0x00
                  left_light_cnt
000005  00                DCB      0x00
                  right_light_cnt
000006  0000              DCB      0x00,0x00
                  online_detection_cnt
                          DCD      0x00000000
                  throttle
                          DCD      0x00000000
                  brake
                          DCD      0x00000000
                  derailleur
                          DCD      0x00000000

                          AREA ||area_number.22||, DATA, ALIGN=0

                          EXPORTAS ||area_number.22||, ||.data||
                  write_success_Flag
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "User\\DutUartProtocol.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___17_DutUartProtocol_c_40f7fd5c____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___17_DutUartProtocol_c_40f7fd5c____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___17_DutUartProtocol_c_40f7fd5c____REVSH|
#line 128
|__asm___17_DutUartProtocol_c_40f7fd5c____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
