; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\canprotocolupdt.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\canprotocolupdt.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -I.\User\qrencode -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.3\Device\Include -D__MICROLIB -D__UVISION_VERSION=539 -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\canprotocolupdt.crf User\CanProtocolUpDT.c]
                          THUMB

                          AREA ||i.CAN_AddSum||, CODE, READONLY, ALIGN=1

                  CAN_AddSum PROC
;;;1121   // 对传入的命令帧进行校验，返回校验结果
;;;1122   BOOL CAN_AddSum(uint8 *buff, uint32 len)
000000  b510              PUSH     {r4,lr}
;;;1123   {
;;;1124       uint8 cc = 0;
000002  2300              MOVS     r3,#0
;;;1125       uint16 i = 0;
000004  2200              MOVS     r2,#0
;;;1126   
;;;1127       if (NULL == buff)
000006  2800              CMP      r0,#0
000008  d104              BNE      |L1.20|
;;;1128       {
;;;1129           return FALSE;
;;;1130       }
;;;1131   
;;;1132       // 从命令头开始，到校验码之前的一个字节，依次进行异或运算
;;;1133       for (i = 0; i < len; i++)
;;;1134       {
;;;1135           cc ^= buff[i];
;;;1136       }
;;;1137   
;;;1138       cc = ~cc;
;;;1139   
;;;1140       // 添加校验码
;;;1141       buff[len] = cc;
;;;1142   
;;;1143       return TRUE;
;;;1144   }
00000a  bd10              POP      {r4,pc}
                  |L1.12|
00000c  5c84              LDRB     r4,[r0,r2]            ;1135
00000e  4063              EORS     r3,r3,r4              ;1135
000010  1c52              ADDS     r2,r2,#1              ;1133
000012  b292              UXTH     r2,r2                 ;1133
                  |L1.20|
000014  428a              CMP      r2,r1                 ;1133
000016  d3f9              BCC      |L1.12|
000018  43da              MVNS     r2,r3                 ;1138
00001a  5442              STRB     r2,[r0,r1]            ;1141
00001c  2001              MOVS     r0,#1                 ;1143
00001e  bd10              POP      {r4,pc}
;;;1145   
                          ENDP


                          AREA ||i.CAN_CheckSum||, CODE, READONLY, ALIGN=1

                  CAN_CheckSum PROC
;;;1093   // 对传入的命令帧进行校验，返回校验结果
;;;1094   BOOL CAN_CheckSum(uint8 *buff, uint32 len)
000000  b530              PUSH     {r4,r5,lr}
;;;1095   {
;;;1096       uint8 cc = 0;
000002  2300              MOVS     r3,#0
;;;1097       uint16 i = 0;
000004  2200              MOVS     r2,#0
;;;1098   
;;;1099       if (NULL == buff)
000006  2800              CMP      r0,#0
000008  d001              BEQ      |L2.14|
;;;1100       {
;;;1101           return FALSE;
;;;1102       }
;;;1103   
;;;1104       // 从命令头开始，到校验码之前的一个字节，依次进行异或运算
;;;1105       for (i = 0; i < (len - CAN_CHECK_BYTE_SIZE); i++)
00000a  1e4c              SUBS     r4,r1,#1
00000c  e005              B        |L2.26|
                  |L2.14|
00000e  2000              MOVS     r0,#0                 ;1101
;;;1106       {
;;;1107           cc ^= buff[i];
;;;1108       }
;;;1109   
;;;1110       cc = ~cc;
;;;1111   
;;;1112       // 判断计算得到的校验码与命令帧中的校验码是否相同
;;;1113       if (buff[len - 1] != cc)
;;;1114       {
;;;1115           return FALSE;
;;;1116       }
;;;1117   
;;;1118       return TRUE;
;;;1119   }
000010  bd30              POP      {r4,r5,pc}
                  |L2.18|
000012  5c85              LDRB     r5,[r0,r2]            ;1107
000014  406b              EORS     r3,r3,r5              ;1107
000016  1c52              ADDS     r2,r2,#1              ;1105
000018  b292              UXTH     r2,r2                 ;1105
                  |L2.26|
00001a  42a2              CMP      r2,r4                 ;1105
00001c  d3f9              BCC      |L2.18|
00001e  43da              MVNS     r2,r3                 ;1110
000020  b2d2              UXTB     r2,r2                 ;1110
000022  4408              ADD      r0,r0,r1              ;1113
000024  f8100c01          LDRB     r0,[r0,#-1]           ;1113
000028  4290              CMP      r0,r2                 ;1113
00002a  d001              BEQ      |L2.48|
00002c  2000              MOVS     r0,#0                 ;1115
00002e  bd30              POP      {r4,r5,pc}
                  |L2.48|
000030  2001              MOVS     r0,#1                 ;1118
000032  bd30              POP      {r4,r5,pc}
;;;1120   
                          ENDP


                          AREA ||i.CAN_CmdFrameProcess||, CODE, READONLY, ALIGN=2

                  CAN_CmdFrameProcess PROC
;;;589    // CAN命令帧缓冲区处理
;;;590    void CAN_CmdFrameProcess(CAN_CB *pCB)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;591    {
000004  4682              MOV      r10,r0
;;;592        CAN_CMD cmd = IAP_CTRL_CAN_CMD_EMPTY;
;;;593        CAN_CMD_FRAME *pCmdFrame = NULL;
;;;594        uint8 sourceBuffSelect = CAN_DEVICE_SOURCE_ID_MAX;
;;;595        volatile uint32 temp = 0;
000006  f04f0800          MOV      r8,#0
00000a  f8cd8008          STR      r8,[sp,#8]
;;;596        volatile uint16 length;
;;;597        volatile uint8 errStatus;
;;;598        volatile uint16 i;
;;;599    
;;;600        // 参数合法性检验
;;;601        if (NULL == pCB)
00000e  f1ba0f00          CMP      r10,#0
000012  d071              BEQ      |L3.248|
;;;602        {
;;;603            return;
;;;604        }
;;;605    
;;;606        // 循环判断是否有数据需要处理
;;;607        for (sourceBuffSelect = 0; sourceBuffSelect < CAN_DEVICE_SOURCE_ID_MAX; sourceBuffSelect++)
000014  46c1              MOV      r9,r8
;;;608        {
;;;609            // 命令帧缓冲区为空，退出
;;;610            if (pCB->rx.rxEachNode[sourceBuffSelect].head == pCB->rx.rxEachNode[sourceBuffSelect].end)
;;;611            {
;;;612                continue;
;;;613            }
;;;614    
;;;615            // 获取当前要处理的命令帧指针
;;;616            pCmdFrame = &pCB->rx.rxEachNode[sourceBuffSelect].cmdQueue[pCB->rx.rxEachNode[sourceBuffSelect].head];
;;;617    
;;;618            // 命令头非法，退出
;;;619            if (CAN_CMD_HEAD != pCmdFrame->buff[CAN_CMD_HEAD_INDEX])
;;;620            {
;;;621                // 删除命令帧
;;;622                pCB->rx.rxEachNode[sourceBuffSelect].head++;
;;;623                pCB->rx.rxEachNode[sourceBuffSelect].head %= CAN_RX_QUEUE_SIZE;
;;;624                continue;
;;;625            }
;;;626    
;;;627            // 命令头合法，则提取命令
;;;628            cmd = (CAN_CMD)(pCmdFrame->buff[CAN_CMD_CMD_INDEX]);
;;;629    
;;;630            switch (dut_info.ID)
000016  4dfe              LDR      r5,|L3.1040|
;;;631            {
;;;632            case DUT_TYPE_NULL:
;;;633                break;
;;;634    
;;;635            case DUT_TYPE_CM: // 通用仪表升级
;;;636                switch (cmd)
;;;637                {
;;;638                case IAP_CTRL_CAN_CMD_EMPTY: // 0x00 空命令
;;;639                    break;
;;;640    
;;;641                case IAP_CTRL_CAN_CMD_UP_PROJECT_APPLY:
;;;642                    if (!dut_info.dutPowerOnAllow) // 只接收一次eco请求
;;;643                    {
;;;644                        STATE_SwitchStep(STEP_CM_CAN_UPGRADE_RECEIVE_DUT_ECO_REQUEST);
;;;645                        dut_info.dutPowerOnAllow = TRUE; // 不再接收eco请求
;;;646                    }
;;;647                    break;
;;;648    
;;;649                case IAP_CTRL_CAN_CMD_UP_PROJECT_READY: // 0x03：DUT工程模式准备就绪
;;;650                    if (dut_info.reconnectionFlag)
;;;651                    {
;;;652                        if (dut_info.reconnectionRepeatOne)
;;;653                        {
;;;654                            if (dut_info.appUpFlag)
;;;655                            {
;;;656                                STATE_SwitchStep(STEP_CM_CAN_UPGRADE_SEND_APP_WRITE);
;;;657                            }
;;;658                            else if (dut_info.uiUpFlag)
;;;659                            {
;;;660                                STATE_SwitchStep(STEP_CM_CAN_UPGRADE_SEND_UI_WRITE);
;;;661                            }
;;;662                        }
;;;663                        break;
;;;664                    }
;;;665                    // 选择升级
;;;666                    if (dut_info.appUpFlag)
;;;667                    {
;;;668                        STATE_SwitchStep(STEP_CM_CAN_UPGRADE_SEND_APP_EAR);
;;;669                    }
;;;670                    else if (dut_info.uiUpFlag)
;;;671                    {
;;;672                        STATE_SwitchStep(STEP_CM_CAN_UPGRADE_SEND_UI_EAR);
;;;673                    }
;;;674                    else if (dut_info.configUpFlag)
;;;675                    {
;;;676                        STATE_SwitchStep(STEP_CAN_SET_CONFIG_ENTRY);
;;;677                    }
;;;678                    break;
;;;679    
;;;680                case IAP_CTRL_CAN_CMD_UP_UI_DATA_ERASE_ACK: // 0x13,DUT_UI擦写成功
;;;681                    // 提取DUT_UI擦除结果
;;;682                    temp = pCmdFrame->buff[CAN_CMD_DATA1_INDEX];
;;;683                    // 擦除失败
;;;684                    if (0 == temp)
;;;685                    {
;;;686                        // 擦除失败再擦除一次
;;;687                        STATE_SwitchStep(STEP_CM_CAN_UPGRADE_SEND_UI_EAR);
;;;688                        break;
;;;689                    }
;;;690                    // 擦除成功
;;;691                    STATE_SwitchStep(STEP_CM_CAN_UPGRADE_UI_EAR_RESUALT);
;;;692                    break;
;;;693    
;;;694                case IAP_CTRL_CAN_CMD_UP_UI_DATA_WRITE_RESULT: // 0x15  //DUT_UI写入结果
;;;695                    temp = pCmdFrame->buff[CAN_CMD_DATA1_INDEX];
;;;696    
;;;697                    if (0 == temp)
;;;698                    {
;;;699                        dut_info.currentUiSize--; // 应答失败重发上一包数据
;;;700                    }
;;;701                    if (dut_info.currentUiSize < dut_info.uiSize)
;;;702                    {
;;;703                        STATE_SwitchStep(STEP_CM_CAN_UPGRADE_SEND_UI_WRITE);
;;;704                    }
;;;705                    else
;;;706                    {
;;;707                        STATE_SwitchStep(STEP_CM_CAN_UPGRADE_UI_UP_SUCCESS);
;;;708                    }
;;;709                    break;
;;;710    
;;;711                case IAP_CTRL_CAN_CMD_DOWN_IAP_ERASE_FLASH: // 0x24：DUT_APP擦写
;;;712                    break;
;;;713    
;;;714                case IAP_CTRL_CAN_CMD_UP_IAP_ERASE_FLASH_RESULT: // 0x25：DUT_APP擦写结果查询
;;;715                    temp = pCmdFrame->buff[CAN_CMD_DATA1_INDEX];
;;;716                    // 擦除失败
;;;717                    if (0 == temp)
;;;718                    {
;;;719                        // 擦除失败再擦除一次
;;;720                        STATE_SwitchStep(STEP_CM_CAN_UPGRADE_SEND_APP_EAR);
;;;721                        TIMER_ResetTimer(TIMER_ID_DUT_TIMEOUT);
;;;722                        // TIMER_KillTask(TIMER_ID_DUT_TIMEOUT);
;;;723                        break;
;;;724                    }
;;;725                    STATE_SwitchStep(STEP_CM_CAN_UPGRADE_APP_EAR_RESUALT);
;;;726                    break;
;;;727    
;;;728                case IAP_CTRL_CAN_CMD_UP_IAP_WRITE_FLASH_RESULT: // 0x27：DUT_APP写入结果
;;;729                    temp = pCmdFrame->buff[CAN_CMD_DATA1_INDEX];
;;;730    
;;;731                    if (0 == temp)
;;;732                    {
;;;733                        if (0 < dut_info.currentAppSize)
;;;734                        {
;;;735                            dut_info.currentAppSize--;
;;;736                        }
;;;737                        break;
;;;738                    }
;;;739                    if (dut_info.currentAppSize < dut_info.appSize)
;;;740                    {
;;;741                        STATE_SwitchStep(STEP_CM_CAN_UPGRADE_SEND_APP_WRITE);
;;;742                    }
;;;743                    else
;;;744                    {
;;;745                        STATE_SwitchStep(STEP_CM_CAN_UPGRADE_APP_UP_SUCCESS);
;;;746                    }
;;;747                    break;
;;;748    
;;;749                case IAP_CTRL_CAN_CMD_UP_UPDATA_FINISH_RESULT: // 0x2B：DUT写入结果确定
;;;750    //                    STATE_SwitchStep(STEP_CM_CAN_UPGRADE_ITEM_FINISH);
;;;751                    STATE_SwitchStep(STEP_CM_CAN_UPGRADE_APP_UP_SUCCESS_RESET);
;;;752                    break;
;;;753    
;;;754                default:
;;;755                    break;
;;;756                }
;;;757                break;
;;;758    
;;;759            // 华芯微特升级
;;;760            case DUT_TYPE_HUAXIN:
;;;761                switch (cmd)
;;;762                {
;;;763                case IAP_CTRL_CAN_CMD_EMPTY: // 0x00 空命令
;;;764                    break;
;;;765    
;;;766                // 收到仪表eco请求
;;;767                case IAP_CTRL_CAN_CMD_DOWN_PROJECT_APPLY_ACK: // 0x02
;;;768                    if (dut_info.appUpFlag || dut_info.uiUpFlag)
;;;769                    {
;;;770                        if (!dut_info.dutPowerOnAllow) // 只接收一次eco请求
;;;771                        {
;;;772                            STATE_SwitchStep(STEP_HUAXIN_CAN_UPGRADE_RECEIVE_DUT_ECO_REQUEST);
;;;773                            dut_info.dutPowerOnAllow = TRUE; // 不再接收eco请求
;;;774                        }
;;;775                    }
;;;776                    else if (dut_info.configUpFlag)
;;;777                    {
;;;778                        STATE_SwitchStep(STEP_CAN_SET_CONFIG_ENTRY);
;;;779                    }
;;;780    
;;;781                    break;
;;;782    
;;;783                case IAP_CTRL_CAN_CMD_UP_PROJECT_READY: // 0x03：DUT工程模式准备就绪
;;;784                    // 选择升级
;;;785                    if (dut_info.appUpFlag)
;;;786                    {
;;;787                        STATE_SwitchStep(STEP_HUAXIN_CAN_UPGRADE_SEND_APP_EAR);
;;;788                    }
;;;789                    else if (dut_info.uiUpFlag)
;;;790                    {
;;;791                        STATE_SwitchStep(STEP_HUAXIN_CAN_UPGRADE_SEND_UI_EAR);
;;;792                    }
;;;793                    else if (dut_info.configUpFlag)
;;;794                    {
;;;795                        STATE_SwitchStep(STEP_CAN_SET_CONFIG_ENTRY);
;;;796                    }
;;;797                    break;
;;;798    
;;;799                case IAP_CTRL_CAN_HUAXIN_CMD_APP_EAR: // 0x05：DUT_APP擦写结果查询
;;;800                    temp = pCmdFrame->buff[CAN_CMD_DATA1_INDEX];
;;;801                    // 擦除失败
;;;802                    if (0 == temp)
;;;803                    {
;;;804                        // 擦除失败再擦除一次
;;;805                        STATE_SwitchStep(STEP_HUAXIN_CAN_UPGRADE_SEND_APP_EAR);
;;;806                        break;
;;;807                    }
;;;808                    dut_info.currentAppSize = 0;
;;;809                    STATE_SwitchStep(STEP_HUAXIN_CAN_UPGRADE_SEND_APP_WRITE);
;;;810                    break;
;;;811    
;;;812                case IAP_CTRL_CAN_HUAXIN_CMD_WRITE_APP: // 0x06：DUT_APP写入结果
;;;813                    temp = pCmdFrame->buff[CAN_CMD_DATA1_INDEX];
;;;814    
;;;815                    if (0 == temp)
;;;816                    {
;;;817                        if (0 < dut_info.currentAppSize)
;;;818                        {
;;;819                            dut_info.currentAppSize--;
;;;820                        }
;;;821                    }
;;;822                    if (dut_info.currentAppSize < dut_info.appSize)
;;;823                    {
;;;824                        STATE_SwitchStep(STEP_HUAXIN_CAN_UPGRADE_SEND_APP_WRITE);
;;;825                    }
;;;826                    else
;;;827                    {
;;;828                        STATE_SwitchStep(STEP_HUAXIN_CAN_UPGRADE_APP_UP_SUCCESS);
;;;829                    }
;;;830                    break;
;;;831    
;;;832                case IAP_CTRL_CAN_HUAXIN_CMD_WRITE_APP_COMPLETE: // 0x07：DUT写入结果确定
;;;833                    STATE_SwitchStep(STEP_HUAXIN_CAN_UPGRADE_ITEM_FINISH);
;;;834                    break;
;;;835    
;;;836                case IAP_CTRL_CAN_CMD_UP_UI_DATA_ERASE_ACK: // 0x13：DUT_UI擦写成功
;;;837                    // 提取DUT_UI擦除结果
;;;838                    temp = pCmdFrame->buff[CAN_CMD_DATA1_INDEX];
;;;839                    // 擦除失败
;;;840                    if (0 == temp)
;;;841                    {
;;;842                        // 擦除失败再擦除一次
;;;843                        STATE_SwitchStep(STEP_HUAXIN_CAN_UPGRADE_SEND_UI_EAR);
;;;844                        break;
;;;845                    }
;;;846                    // 擦除成功
;;;847                    dut_info.currentUiSize = 0;
;;;848                    STATE_SwitchStep(STEP_HUAXIN_CAN_UPGRADE_SEND_UI_WRITE);
;;;849                    break;
;;;850    
;;;851                case IAP_CTRL_CAN_CMD_UP_UI_DATA_WRITE_RESULT: // 0x15：DUT_UI写入结果
;;;852                    temp = pCmdFrame->buff[CAN_CMD_DATA1_INDEX];
;;;853    
;;;854                    if (0 == temp)
;;;855                    {
;;;856                        dut_info.currentUiSize--; // 应答失败重发上一包数据
;;;857                    }
;;;858                    if (dut_info.currentUiSize < dut_info.uiSize)
;;;859                    {
;;;860                        STATE_SwitchStep(STEP_HUAXIN_CAN_UPGRADE_SEND_UI_WRITE);
;;;861                    }
;;;862                    else
;;;863                    {
;;;864                        STATE_SwitchStep(STEP_HUAXIN_CAN_UPGRADE_UI_UP_SUCCESS);
;;;865                    }
;;;866                    break;
;;;867    
;;;868                case IAP_CTRL_CAN_CMD_UP_UPDATA_FINISH_RESULT:
;;;869                    STATE_SwitchStep(STEP_HUAXIN_CAN_UPGRADE_ITEM_FINISH);
;;;870                    break;
;;;871    
;;;872                default:
;;;873                    break;
;;;874                }
;;;875                break;
;;;876    
;;;877            case DUT_TYPE_SPARROW:
;;;878            case DUT_TYPE_SEG: // 段码屏
;;;879                // 执行命令帧
;;;880                switch (cmd)
;;;881                {
;;;882                // 收到仪表发送的ECO请求
;;;883                case IAP_CTRL_CAN_CMD_DOWN_PROJECT_APPLY_ACK: // 02
;;;884                    if (!dut_info.dutPowerOnAllow)
;;;885                    {
;;;886                        // 延时50ms允许进入工程模式
;;;887                        STATE_SwitchStep(STEP_SEG_CAN_UPGRADE_RECEIVE_DUT_ECO_REQUEST);
;;;888                        dut_info.dutPowerOnAllow = TRUE; // 不在接收eco请求
;;;889                    }
;;;890                    break;
;;;891    
;;;892                // 仪表回应准备就绪
;;;893                case IAP_CTRL_CAN_CMD_UP_PROJECT_READY: // 03
;;;894                    if (dut_info.appUpFlag)
;;;895                    {
;;;896                        STATE_SwitchStep(STEP_SEG_CAN_UPGRADE_SEND_APP_EAR); // 擦除app
;;;897                    }
;;;898                    break;
;;;899    
;;;900                case IAP_CTRL_CAN_CMD_SEG_RUN_APP_ACK: // 04
;;;901                    if (dut_info.configUpFlag)
;;;902                    {
;;;903                        STATE_SwitchStep(STEP_CAN_SET_CONFIG_ENTRY);
;;;904                    }
;;;905                    else
;;;906                    {
;;;907                    }
;;;908                    break;
;;;909                case IAP_CTRL_CAN_HUAXIN_CMD_APP_EAR: // 05
;;;910                    STATE_SwitchStep(STEP_SEG_CAN_UPGRADE_APP_EAR_RESUALT);
;;;911                    // 提取DUT_UI擦除结果
;;;912                    temp = pCmdFrame->buff[CAN_CMD_DATA1_INDEX];
;;;913    
;;;914                    // 擦除失败
;;;915                    if (0 == temp)
;;;916                    {
;;;917                        // 擦除失败再擦除一次
;;;918                        STATE_SwitchStep(STEP_SEG_CAN_UPGRADE_SEND_APP_EAR); // 擦除app
;;;919                        break;
;;;920                    }
;;;921                    // 擦除成功
;;;922                    dut_info.currentAppSize = 0;
;;;923                    STATE_SwitchStep(STEP_SEG_CAN_UPGRADE_SEND_APP_WRITE);
;;;924    
;;;925                    break;
;;;926                case IAP_CTRL_CAN_HUAXIN_CMD_WRITE_APP: // 06,app写入
;;;927                    temp = pCmdFrame->buff[CAN_CMD_DATA1_INDEX];
;;;928                    if (0 == temp) // 如果仪表写入失败
;;;929                    {
;;;930                        dut_info.currentAppSize--;
;;;931                    }
;;;932    
;;;933                    if (dut_info.currentAppSize < dut_info.appSize)
;;;934                    {
;;;935                        STATE_SwitchStep(STEP_SEG_CAN_UPGRADE_SEND_APP_WRITE);
;;;936                    }
;;;937                    else
;;;938                    {
;;;939                        STATE_SwitchStep(STEP_SEG_CAN_UPGRADE_APP_UP_SUCCESS);
;;;940                    }
;;;941                    break;
;;;942    
;;;943                case IAP_CTRL_CAN_HUAXIN_CMD_WRITE_APP_COMPLETE: // 07，升级项结束，开始升级下一项
;;;944                    STATE_SwitchStep(STEP_SEG_CAN_UPGRADE_ITEM_FINISH);
;;;945                    break;
;;;946    
;;;947                default:
;;;948                    break;
;;;949                }
;;;950                break;
;;;951    
;;;952            // 开阳升级流程
;;;953            case DUT_TYPE_KAIYANG:
;;;954                // 执行命令帧
;;;955                switch (cmd)
;;;956                {
;;;957                // 收到仪表发送的ECO请求
;;;958                case IAP_CTRL_CAN_CMD_UP_PROJECT_APPLY: // 01
;;;959    
;;;960                    if (!dut_info.dutPowerOnAllow)
;;;961                    {
;;;962                        if (dut_info.uiUpFlag || dut_info.appUpFlag)
;;;963                        {
;;;964                            STATE_SwitchStep(STEP_KAIYANG_CAN_UPGRADE_UP_ALLOW);
;;;965                        }
;;;966                        else if (dut_info.configUpFlag)
;;;967                        {
;;;968                            STATE_SwitchStep(STEP_CAN_SET_CONFIG_ENTRY);
;;;969                        }
;;;970                        dut_info.dutPowerOnAllow = TRUE; // 不在接收eco请求
;;;971                    }
;;;972                    break;
;;;973    
;;;974                // 仪表回应准备就绪
;;;975                case IAP_CTRL_CAN_CMD_DOWN_PROJECT_APPLY_ACK: // 02
;;;976                    if (dut_info.appUpFlag)
;;;977                    {
;;;978                        dut_info.currentAppSize = 0;
;;;979                        STATE_SwitchStep(STEP_KAIYANG_CAN_UPGRADE_SEND_APP_WRITE);
;;;980                        TIMER_AddTask(TIMER_ID_RECONNECTION,
000018  f04f3bff          MOV      r11,#0xffffffff
00001c  2701              MOVS     r7,#1                 ;594
                  |L3.30|
00001e  f24020e5          MOV      r0,#0x2e5             ;610
000022  fb09f000          MUL      r0,r9,r0              ;610
000026  eb0a0680          ADD      r6,r10,r0,LSL #2      ;610
00002a  f8b60c24          LDRH     r0,[r6,#0xc24]        ;610
00002e  f8b61c26          LDRH     r1,[r6,#0xc26]        ;610
000032  4288              CMP      r0,r1                 ;610
000034  d012              BEQ      |L3.92|
000036  eb000180          ADD      r1,r0,r0,LSL #2       ;616
00003a  eb011140          ADD      r1,r1,r0,LSL #5       ;616
00003e  eb060481          ADD      r4,r6,r1,LSL #2       ;616
000042  3494              ADDS     r4,r4,#0x94           ;616
000044  7921              LDRB     r1,[r4,#4]            ;619
000046  2955              CMP      r1,#0x55              ;619
000048  d009              BEQ      |L3.94|
00004a  1c40              ADDS     r0,r0,#1              ;622
00004c  b281              UXTH     r1,r0                 ;622
00004e  2014              MOVS     r0,#0x14              ;623
000050  fbb1f2f0          UDIV     r2,r1,r0              ;623
000054  fb001012          MLS      r0,r0,r2,r1           ;623
000058  f8a60c24          STRH     r0,[r6,#0xc24]        ;623
                  |L3.92|
00005c  e22a              B        |L3.1204|
                  |L3.94|
00005e  7960              LDRB     r0,[r4,#5]            ;628
000060  7da9              LDRB     r1,[r5,#0x16]         ;630  ; dut_info
000062  2908              CMP      r1,#8                 ;630
000064  d223              BCS      |L3.174|
000066  e8dff001          TBB      [pc,r1]               ;630
00006a  2222              DCB      0x22,0x22
00006c  0499fdfc          DCB      0x04,0x99,0xfd,0xfc
000070  22fd              DCB      0x22,0xfd
000072  2815              CMP      r0,#0x15              ;636
000074  d056              BEQ      |L3.292|
000076  dc08              BGT      |L3.138|
000078  2800              CMP      r0,#0                 ;636
                  |L3.122|
00007a  d018              BEQ      |L3.174|
00007c  2801              CMP      r0,#1                 ;636
00007e  d00d              BEQ      |L3.156|
000080  2803              CMP      r0,#3                 ;636
000082  d015              BEQ      |L3.176|
000084  2813              CMP      r0,#0x13              ;636
                  |L3.134|
000086  d112              BNE      |L3.174|
000088  e040              B        |L3.268|
                  |L3.138|
00008a  2824              CMP      r0,#0x24              ;636
00008c  d0f5              BEQ      |L3.122|
00008e  2825              CMP      r0,#0x25              ;636
000090  d05b              BEQ      |L3.330|
000092  2827              CMP      r0,#0x27              ;636
000094  d068              BEQ      |L3.360|
000096  282b              CMP      r0,#0x2b              ;636
000098  d1f5              BNE      |L3.134|
00009a  e07b              B        |L3.404|
                  |L3.156|
00009c  f8950064          LDRB     r0,[r5,#0x64]         ;642  ; dut_info
0000a0  2800              CMP      r0,#0                 ;642
0000a2  d1f0              BNE      |L3.134|
0000a4  20da              MOVS     r0,#0xda              ;644
0000a6  f7fffffe          BL       STATE_SwitchStep
0000aa  f8857064          STRB     r7,[r5,#0x64]         ;645
                  |L3.174|
0000ae  e1f6              B        |L3.1182|
                  |L3.176|
0000b0  f8950071          LDRB     r0,[r5,#0x71]         ;650  ; dut_info
0000b4  b190              CBZ      r0,|L3.220|
0000b6  f8950072          LDRB     r0,[r5,#0x72]         ;652  ; dut_info
0000ba  2800              CMP      r0,#0                 ;652
0000bc  d0f7              BEQ      |L3.174|
0000be  f8950025          LDRB     r0,[r5,#0x25]         ;654  ; dut_info
0000c2  b118              CBZ      r0,|L3.204|
0000c4  20e4              MOVS     r0,#0xe4              ;656
0000c6  f7fffffe          BL       STATE_SwitchStep
                  |L3.202|
0000ca  e1e8              B        |L3.1182|
                  |L3.204|
0000cc  f8950027          LDRB     r0,[r5,#0x27]         ;658  ; dut_info
0000d0  2800              CMP      r0,#0                 ;658
0000d2  d0ec              BEQ      |L3.174|
0000d4  20de              MOVS     r0,#0xde              ;660
0000d6  f7fffffe          BL       STATE_SwitchStep
                  |L3.218|
0000da  e1e0              B        |L3.1182|
                  |L3.220|
0000dc  f8950025          LDRB     r0,[r5,#0x25]         ;666  ; dut_info
0000e0  b118              CBZ      r0,|L3.234|
0000e2  20e2              MOVS     r0,#0xe2              ;668
0000e4  f7fffffe          BL       STATE_SwitchStep
                  |L3.232|
0000e8  e1d9              B        |L3.1182|
                  |L3.234|
0000ea  f8950027          LDRB     r0,[r5,#0x27]         ;670  ; dut_info
0000ee  b120              CBZ      r0,|L3.250|
0000f0  20dc              MOVS     r0,#0xdc              ;672
0000f2  f7fffffe          BL       STATE_SwitchStep
0000f6  e1d2              B        |L3.1182|
                  |L3.248|
0000f8  e1e4              B        |L3.1220|
                  |L3.250|
0000fa  f8950026          LDRB     r0,[r5,#0x26]         ;674  ; dut_info
0000fe  2800              CMP      r0,#0                 ;674
000100  d0d5              BEQ      |L3.174|
000102  f240100d          MOV      r0,#0x10d             ;676
000106  f7fffffe          BL       STATE_SwitchStep
                  |L3.266|
00010a  e1c8              B        |L3.1182|
                  |L3.268|
00010c  79e0              LDRB     r0,[r4,#7]            ;682
00010e  9002              STR      r0,[sp,#8]            ;682
000110  9802              LDR      r0,[sp,#8]            ;684
000112  b118              CBZ      r0,|L3.284|
000114  20dd              MOVS     r0,#0xdd              ;691
000116  f7fffffe          BL       STATE_SwitchStep
00011a  e1c0              B        |L3.1182|
                  |L3.284|
00011c  20dc              MOVS     r0,#0xdc              ;687
00011e  f7fffffe          BL       STATE_SwitchStep
000122  e1bc              B        |L3.1182|
                  |L3.292|
000124  79e0              LDRB     r0,[r4,#7]            ;695
000126  9002              STR      r0,[sp,#8]            ;695
000128  9802              LDR      r0,[sp,#8]            ;697
00012a  b910              CBNZ     r0,|L3.306|
00012c  6de8              LDR      r0,[r5,#0x5c]         ;699  ; dut_info
00012e  1e40              SUBS     r0,r0,#1              ;699
000130  65e8              STR      r0,[r5,#0x5c]         ;699  ; dut_info
                  |L3.306|
000132  6d29              LDR      r1,[r5,#0x50]         ;701  ; dut_info
000134  6de8              LDR      r0,[r5,#0x5c]         ;701  ; dut_info
000136  4288              CMP      r0,r1                 ;701
000138  d203              BCS      |L3.322|
00013a  20de              MOVS     r0,#0xde              ;703
00013c  f7fffffe          BL       STATE_SwitchStep
                  |L3.320|
000140  e1ad              B        |L3.1182|
                  |L3.322|
000142  20df              MOVS     r0,#0xdf              ;707
000144  f7fffffe          BL       STATE_SwitchStep
000148  e1a9              B        |L3.1182|
                  |L3.330|
00014a  79e0              LDRB     r0,[r4,#7]            ;715
00014c  9002              STR      r0,[sp,#8]            ;715
00014e  9802              LDR      r0,[sp,#8]            ;717
000150  b118              CBZ      r0,|L3.346|
000152  20e3              MOVS     r0,#0xe3              ;725
000154  f7fffffe          BL       STATE_SwitchStep
000158  e1a1              B        |L3.1182|
                  |L3.346|
00015a  20e2              MOVS     r0,#0xe2              ;720
00015c  f7fffffe          BL       STATE_SwitchStep
000160  2008              MOVS     r0,#8                 ;721
000162  f7fffffe          BL       TIMER_ResetTimer
000166  e19a              B        |L3.1182|
                  |L3.360|
000168  79e0              LDRB     r0,[r4,#7]            ;729
00016a  9002              STR      r0,[sp,#8]            ;729
00016c  9802              LDR      r0,[sp,#8]            ;731
00016e  b138              CBZ      r0,|L3.384|
000170  6ce9              LDR      r1,[r5,#0x4c]         ;739  ; dut_info
000172  6da8              LDR      r0,[r5,#0x58]         ;739  ; dut_info
000174  4288              CMP      r0,r1                 ;739
000176  d209              BCS      |L3.396|
000178  20e4              MOVS     r0,#0xe4              ;741
00017a  f7fffffe          BL       STATE_SwitchStep
00017e  e18e              B        |L3.1182|
                  |L3.384|
000180  6da8              LDR      r0,[r5,#0x58]         ;733  ; dut_info
000182  2800              CMP      r0,#0                 ;733
000184  d093              BEQ      |L3.174|
000186  1e40              SUBS     r0,r0,#1              ;735
000188  65a8              STR      r0,[r5,#0x58]         ;735  ; dut_info
00018a  e188              B        |L3.1182|
                  |L3.396|
00018c  20e5              MOVS     r0,#0xe5              ;745
00018e  f7fffffe          BL       STATE_SwitchStep
000192  e184              B        |L3.1182|
                  |L3.404|
000194  20e0              MOVS     r0,#0xe0              ;751
000196  f7fffffe          BL       STATE_SwitchStep
00019a  e180              B        |L3.1182|
00019c  2806              CMP      r0,#6                 ;761
00019e  d050              BEQ      |L3.578|
0001a0  dc08              BGT      |L3.436|
0001a2  2800              CMP      r0,#0                 ;761
0001a4  d091              BEQ      |L3.202|
0001a6  2802              CMP      r0,#2                 ;761
0001a8  d00d              BEQ      |L3.454|
0001aa  2803              CMP      r0,#3                 ;761
0001ac  d024              BEQ      |L3.504|
0001ae  2805              CMP      r0,#5                 ;761
0001b0  d18b              BNE      |L3.202|
0001b2  e038              B        |L3.550|
                  |L3.436|
0001b4  2807              CMP      r0,#7                 ;761
0001b6  d05a              BEQ      |L3.622|
0001b8  2813              CMP      r0,#0x13              ;761
0001ba  d05c              BEQ      |L3.630|
0001bc  2815              CMP      r0,#0x15              ;761
0001be  d068              BEQ      |L3.658|
0001c0  282b              CMP      r0,#0x2b              ;761
0001c2  d18a              BNE      |L3.218|
0001c4  e078              B        |L3.696|
                  |L3.454|
0001c6  f8950025          LDRB     r0,[r5,#0x25]         ;768  ; dut_info
0001ca  b910              CBNZ     r0,|L3.466|
0001cc  f8950027          LDRB     r0,[r5,#0x27]         ;768  ; dut_info
0001d0  b148              CBZ      r0,|L3.486|
                  |L3.466|
0001d2  f8950064          LDRB     r0,[r5,#0x64]         ;770  ; dut_info
0001d6  2800              CMP      r0,#0                 ;770
0001d8  d186              BNE      |L3.232|
0001da  20ec              MOVS     r0,#0xec              ;772
0001dc  f7fffffe          BL       STATE_SwitchStep
0001e0  f8857064          STRB     r7,[r5,#0x64]         ;773
0001e4  e15b              B        |L3.1182|
                  |L3.486|
0001e6  f8950026          LDRB     r0,[r5,#0x26]         ;776  ; dut_info
0001ea  2800              CMP      r0,#0                 ;776
0001ec  d08d              BEQ      |L3.266|
0001ee  f240100d          MOV      r0,#0x10d             ;778
0001f2  f7fffffe          BL       STATE_SwitchStep
0001f6  e152              B        |L3.1182|
                  |L3.504|
0001f8  f8950025          LDRB     r0,[r5,#0x25]         ;785  ; dut_info
0001fc  b118              CBZ      r0,|L3.518|
0001fe  20ee              MOVS     r0,#0xee              ;787
000200  f7fffffe          BL       STATE_SwitchStep
000204  e14b              B        |L3.1182|
                  |L3.518|
000206  f8950027          LDRB     r0,[r5,#0x27]         ;789  ; dut_info
00020a  b118              CBZ      r0,|L3.532|
00020c  20f2              MOVS     r0,#0xf2              ;791
00020e  f7fffffe          BL       STATE_SwitchStep
000212  e144              B        |L3.1182|
                  |L3.532|
000214  f8950026          LDRB     r0,[r5,#0x26]         ;793  ; dut_info
000218  2800              CMP      r0,#0                 ;793
00021a  d091              BEQ      |L3.320|
00021c  f240100d          MOV      r0,#0x10d             ;795
000220  f7fffffe          BL       STATE_SwitchStep
000224  e13b              B        |L3.1182|
                  |L3.550|
000226  79e0              LDRB     r0,[r4,#7]            ;800
000228  9002              STR      r0,[sp,#8]            ;800
00022a  9802              LDR      r0,[sp,#8]            ;802
00022c  b128              CBZ      r0,|L3.570|
00022e  f8c58058          STR      r8,[r5,#0x58]         ;808  ; dut_info
000232  20f0              MOVS     r0,#0xf0              ;809
000234  f7fffffe          BL       STATE_SwitchStep
000238  e131              B        |L3.1182|
                  |L3.570|
00023a  20ee              MOVS     r0,#0xee              ;805
00023c  f7fffffe          BL       STATE_SwitchStep
000240  e12d              B        |L3.1182|
                  |L3.578|
000242  79e0              LDRB     r0,[r4,#7]            ;813
000244  9002              STR      r0,[sp,#8]            ;813
000246  9802              LDR      r0,[sp,#8]            ;815
000248  b918              CBNZ     r0,|L3.594|
00024a  6da8              LDR      r0,[r5,#0x58]         ;817  ; dut_info
00024c  b108              CBZ      r0,|L3.594|
00024e  1e40              SUBS     r0,r0,#1              ;819
000250  65a8              STR      r0,[r5,#0x58]         ;819  ; dut_info
                  |L3.594|
000252  6ce9              LDR      r1,[r5,#0x4c]         ;822  ; dut_info
000254  6da8              LDR      r0,[r5,#0x58]         ;822  ; dut_info
000256  4288              CMP      r0,r1                 ;822
000258  d205              BCS      |L3.614|
00025a  20f0              MOVS     r0,#0xf0              ;824
00025c  f7fffffe          BL       STATE_SwitchStep
000260  e11d              B        |L3.1182|
000262  e077              B        |L3.852|
000264  e02c              B        |L3.704|
                  |L3.614|
000266  20f1              MOVS     r0,#0xf1              ;828
000268  f7fffffe          BL       STATE_SwitchStep
00026c  e117              B        |L3.1182|
                  |L3.622|
00026e  20f6              MOVS     r0,#0xf6              ;833
000270  f7fffffe          BL       STATE_SwitchStep
000274  e113              B        |L3.1182|
                  |L3.630|
000276  79e0              LDRB     r0,[r4,#7]            ;838
000278  9002              STR      r0,[sp,#8]            ;838
00027a  9802              LDR      r0,[sp,#8]            ;840
00027c  b128              CBZ      r0,|L3.650|
00027e  f8c5805c          STR      r8,[r5,#0x5c]         ;847  ; dut_info
000282  20f4              MOVS     r0,#0xf4              ;848
000284  f7fffffe          BL       STATE_SwitchStep
000288  e109              B        |L3.1182|
                  |L3.650|
00028a  20f2              MOVS     r0,#0xf2              ;843
00028c  f7fffffe          BL       STATE_SwitchStep
000290  e105              B        |L3.1182|
                  |L3.658|
000292  79e0              LDRB     r0,[r4,#7]            ;852
000294  9002              STR      r0,[sp,#8]            ;852
000296  9802              LDR      r0,[sp,#8]            ;854
000298  b910              CBNZ     r0,|L3.672|
00029a  6de8              LDR      r0,[r5,#0x5c]         ;856  ; dut_info
00029c  1e40              SUBS     r0,r0,#1              ;856
00029e  65e8              STR      r0,[r5,#0x5c]         ;856  ; dut_info
                  |L3.672|
0002a0  6d29              LDR      r1,[r5,#0x50]         ;858  ; dut_info
0002a2  6de8              LDR      r0,[r5,#0x5c]         ;858  ; dut_info
0002a4  4288              CMP      r0,r1                 ;858
0002a6  d203              BCS      |L3.688|
0002a8  20f4              MOVS     r0,#0xf4              ;860
0002aa  f7fffffe          BL       STATE_SwitchStep
0002ae  e0f6              B        |L3.1182|
                  |L3.688|
0002b0  20f5              MOVS     r0,#0xf5              ;864
0002b2  f7fffffe          BL       STATE_SwitchStep
0002b6  e0f2              B        |L3.1182|
                  |L3.696|
0002b8  20f6              MOVS     r0,#0xf6              ;869
0002ba  f7fffffe          BL       STATE_SwitchStep
0002be  e0ee              B        |L3.1182|
                  |L3.704|
0002c0  1e80              SUBS     r0,r0,#2              ;880
0002c2  2806              CMP      r0,#6                 ;880
0002c4  d20d              BCS      |L3.738|
0002c6  e8dff000          TBB      [pc,r0]               ;880
0002ca  030d              DCB      0x03,0x0d
0002cc  141c2d40          DCB      0x14,0x1c,0x2d,0x40
0002d0  f8950064          LDRB     r0,[r5,#0x64]         ;884  ; dut_info
0002d4  2800              CMP      r0,#0                 ;884
0002d6  d104              BNE      |L3.738|
0002d8  20fa              MOVS     r0,#0xfa              ;887
0002da  f7fffffe          BL       STATE_SwitchStep
0002de  f8857064          STRB     r7,[r5,#0x64]         ;888
                  |L3.738|
0002e2  e0dc              B        |L3.1182|
0002e4  f8950025          LDRB     r0,[r5,#0x25]         ;894  ; dut_info
0002e8  b350              CBZ      r0,|L3.832|
0002ea  20fc              MOVS     r0,#0xfc              ;896
0002ec  f7fffffe          BL       STATE_SwitchStep
0002f0  e0d5              B        |L3.1182|
0002f2  f8950026          LDRB     r0,[r5,#0x26]         ;901  ; dut_info
0002f6  b318              CBZ      r0,|L3.832|
0002f8  f240100d          MOV      r0,#0x10d             ;903
0002fc  f7fffffe          BL       STATE_SwitchStep
000300  e0cd              B        |L3.1182|
000302  20fd              MOVS     r0,#0xfd              ;910
000304  f7fffffe          BL       STATE_SwitchStep
000308  79e0              LDRB     r0,[r4,#7]            ;912
00030a  9002              STR      r0,[sp,#8]            ;912
00030c  9802              LDR      r0,[sp,#8]            ;915
00030e  b128              CBZ      r0,|L3.796|
000310  f8c58058          STR      r8,[r5,#0x58]         ;922  ; dut_info
000314  20fe              MOVS     r0,#0xfe              ;923
000316  f7fffffe          BL       STATE_SwitchStep
00031a  e0c0              B        |L3.1182|
                  |L3.796|
00031c  20fc              MOVS     r0,#0xfc              ;918
00031e  f7fffffe          BL       STATE_SwitchStep
000322  e0bc              B        |L3.1182|
000324  79e0              LDRB     r0,[r4,#7]            ;927
000326  9002              STR      r0,[sp,#8]            ;927
000328  9802              LDR      r0,[sp,#8]            ;928
00032a  b910              CBNZ     r0,|L3.818|
00032c  6da8              LDR      r0,[r5,#0x58]         ;930  ; dut_info
00032e  1e40              SUBS     r0,r0,#1              ;930
000330  65a8              STR      r0,[r5,#0x58]         ;930  ; dut_info
                  |L3.818|
000332  6ce9              LDR      r1,[r5,#0x4c]         ;933  ; dut_info
000334  6da8              LDR      r0,[r5,#0x58]         ;933  ; dut_info
000336  4288              CMP      r0,r1                 ;933
000338  d203              BCS      |L3.834|
00033a  20fe              MOVS     r0,#0xfe              ;935
00033c  f7fffffe          BL       STATE_SwitchStep
                  |L3.832|
000340  e0ad              B        |L3.1182|
                  |L3.834|
000342  20ff              MOVS     r0,#0xff              ;939
000344  f7fffffe          BL       STATE_SwitchStep
000348  e0a9              B        |L3.1182|
00034a  f44f7080          MOV      r0,#0x100             ;944
00034e  f7fffffe          BL       STATE_SwitchStep
000352  e0a4              B        |L3.1182|
                  |L3.852|
000354  2801              CMP      r0,#1                 ;955
000356  d006              BEQ      |L3.870|
000358  2802              CMP      r0,#2                 ;955
00035a  d01c              BEQ      |L3.918|
00035c  2803              CMP      r0,#3                 ;955
00035e  d042              BEQ      |L3.998|
000360  2804              CMP      r0,#4                 ;955
000362  d12b              BNE      |L3.956|
000364  e073              B        |L3.1102|
                  |L3.870|
000366  f8950064          LDRB     r0,[r5,#0x64]         ;960  ; dut_info
00036a  bb38              CBNZ     r0,|L3.956|
00036c  f8950027          LDRB     r0,[r5,#0x27]         ;962  ; dut_info
000370  b910              CBNZ     r0,|L3.888|
000372  f8950025          LDRB     r0,[r5,#0x25]         ;962  ; dut_info
000376  b120              CBZ      r0,|L3.898|
                  |L3.888|
000378  f2401005          MOV      r0,#0x105             ;964
00037c  f7fffffe          BL       STATE_SwitchStep
000380  e006              B        |L3.912|
                  |L3.898|
000382  f8950026          LDRB     r0,[r5,#0x26]         ;966  ; dut_info
000386  b118              CBZ      r0,|L3.912|
000388  f240100d          MOV      r0,#0x10d             ;968
00038c  f7fffffe          BL       STATE_SwitchStep
                  |L3.912|
000390  f8857064          STRB     r7,[r5,#0x64]         ;970
000394  e083              B        |L3.1182|
                  |L3.918|
000396  f8950025          LDRB     r0,[r5,#0x25]         ;976  ; dut_info
00039a  b180              CBZ      r0,|L3.958|
00039c  f8c58058          STR      r8,[r5,#0x58]         ;978  ; dut_info
0003a0  f44f7083          MOV      r0,#0x106             ;979
0003a4  f7fffffe          BL       STATE_SwitchStep
0003a8  e9cdb700          STRD     r11,r7,[sp,#0]
0003ac  f2401307          MOV      r3,#0x107
0003b0  4a18              LDR      r2,|L3.1044|
0003b2  f44f717a          MOV      r1,#0x3e8
0003b6  2009              MOVS     r0,#9
0003b8  f7fffffe          BL       TIMER_AddTask
                  |L3.956|
0003bc  e06f              B        |L3.1182|
                  |L3.958|
;;;981                                      1000,
;;;982                                      STATE_SwitchStep,
;;;983                                      STEP_KAIYANG_CAN_UPGRADE_SEND_APP_AGAIN,
;;;984                                      TIMER_LOOP_FOREVER,
;;;985                                      ACTION_MODE_ADD_TO_QUEUE);
;;;986                    }
;;;987                    else if (dut_info.uiUpFlag)
0003be  f8950027          LDRB     r0,[r5,#0x27]  ; dut_info
0003c2  b318              CBZ      r0,|L3.1036|
;;;988                    {
;;;989                        dut_info.currentUiSize = 0;
0003c4  f8c5805c          STR      r8,[r5,#0x5c]  ; dut_info
;;;990                        STATE_SwitchStep(STEP_KAIYANG_CAN_UPGRADE_SEND_UI_WRITE);
0003c8  f2401009          MOV      r0,#0x109
0003cc  f7fffffe          BL       STATE_SwitchStep
;;;991                        TIMER_AddTask(TIMER_ID_RECONNECTION,
0003d0  e9cdb700          STRD     r11,r7,[sp,#0]
0003d4  f44f7385          MOV      r3,#0x10a
0003d8  4a0e              LDR      r2,|L3.1044|
0003da  f44f717a          MOV      r1,#0x3e8
0003de  2009              MOVS     r0,#9
0003e0  f7fffffe          BL       TIMER_AddTask
0003e4  e05b              B        |L3.1182|
                  |L3.998|
;;;992                                      1000,
;;;993                                      STATE_SwitchStep,
;;;994                                      STEP_KAIYANG_CAN_UPGRADE_SEND_UI_AGAIN,
;;;995                                      TIMER_LOOP_FOREVER,
;;;996                                      ACTION_MODE_ADD_TO_QUEUE);
;;;997                    }
;;;998                    break;
;;;999    
;;;1000               case IAP_CTRL_CAN_CMD_UP_PROJECT_READY: // 03
;;;1001                   TIMER_ResetTimer(TIMER_ID_DUT_TIMEOUT); // 喂狗
0003e6  2008              MOVS     r0,#8
0003e8  f7fffffe          BL       TIMER_ResetTimer
;;;1002                   if (dut_info.appUpFlag)
0003ec  f8950025          LDRB     r0,[r5,#0x25]  ; dut_info
0003f0  b1b8              CBZ      r0,|L3.1058|
;;;1003                   {
;;;1004                       if (dut_info.currentAppSize < dut_info.appSize - 1)
0003f2  6ce9              LDR      r1,[r5,#0x4c]  ; dut_info
0003f4  6da8              LDR      r0,[r5,#0x58]  ; dut_info
0003f6  1e49              SUBS     r1,r1,#1
0003f8  4288              CMP      r0,r1
0003fa  d20d              BCS      |L3.1048|
;;;1005                       {
;;;1006                           if (pCmdFrame->buff[CAN_CMD_DATA1_INDEX])
0003fc  79e1              LDRB     r1,[r4,#7]
0003fe  b109              CBZ      r1,|L3.1028|
;;;1007                           {
;;;1008                               dut_info.currentAppSize++;
000400  1c40              ADDS     r0,r0,#1
000402  65a8              STR      r0,[r5,#0x58]  ; dut_info
                  |L3.1028|
;;;1009                           }
;;;1010                           STATE_SwitchStep(STEP_KAIYANG_CAN_UPGRADE_SEND_APP_WRITE);
000404  f44f7083          MOV      r0,#0x106
000408  f7fffffe          BL       STATE_SwitchStep
                  |L3.1036|
00040c  e047              B        |L3.1182|
00040e  0000              DCW      0x0000
                  |L3.1040|
                          DCD      dut_info
                  |L3.1044|
                          DCD      STATE_SwitchStep
                  |L3.1048|
;;;1011                       }
;;;1012                       else
;;;1013                       {
;;;1014                           STATE_SwitchStep(STEP_KAIYANG_CAN_UPGRADE_APP_UP_SUCCESS);
000418  f44f7084          MOV      r0,#0x108
00041c  f7fffffe          BL       STATE_SwitchStep
000420  e03d              B        |L3.1182|
                  |L3.1058|
;;;1015                       }
;;;1016                   }
;;;1017                   else if (dut_info.uiUpFlag)
000422  f8950027          LDRB     r0,[r5,#0x27]  ; dut_info
000426  b3d0              CBZ      r0,|L3.1182|
;;;1018                   {
;;;1019                       if (dut_info.currentUiSize < dut_info.uiSize - 1)
000428  6d29              LDR      r1,[r5,#0x50]  ; dut_info
00042a  6de8              LDR      r0,[r5,#0x5c]  ; dut_info
00042c  1e49              SUBS     r1,r1,#1
00042e  4288              CMP      r0,r1
000430  d208              BCS      |L3.1092|
;;;1020                       {
;;;1021                           if (pCmdFrame->buff[CAN_CMD_DATA1_INDEX])
000432  79e1              LDRB     r1,[r4,#7]
000434  b109              CBZ      r1,|L3.1082|
;;;1022                           {
;;;1023                               dut_info.currentUiSize++;
000436  1c40              ADDS     r0,r0,#1
000438  65e8              STR      r0,[r5,#0x5c]  ; dut_info
                  |L3.1082|
;;;1024                           }
;;;1025                           STATE_SwitchStep(STEP_KAIYANG_CAN_UPGRADE_SEND_UI_WRITE);
00043a  f2401009          MOV      r0,#0x109
00043e  f7fffffe          BL       STATE_SwitchStep
000442  e02c              B        |L3.1182|
                  |L3.1092|
;;;1026                       }
;;;1027                       else
;;;1028                       {
;;;1029                           STATE_SwitchStep(STEP_KAIYANG_CAN_UPGRADE_APP_UP_SUCCESS);
000444  f44f7084          MOV      r0,#0x108
000448  f7fffffe          BL       STATE_SwitchStep
00044c  e027              B        |L3.1182|
                  |L3.1102|
;;;1030                       }
;;;1031                   }
;;;1032   
;;;1033                   break;
;;;1034               case IAP_CTRL_CAN_CMD_SEG_RUN_APP_ACK: // 04
;;;1035                   if (pCmdFrame->buff[CAN_CMD_DATA1_INDEX])
00044e  79e0              LDRB     r0,[r4,#7]
000450  b178              CBZ      r0,|L3.1138|
;;;1036                   {
;;;1037                       // 升级成功
;;;1038                       if (dut_info.appUpFlag)
000452  f8950025          LDRB     r0,[r5,#0x25]  ; dut_info
000456  b120              CBZ      r0,|L3.1122|
;;;1039                       {
;;;1040                           dut_info.appUpSuccesss = TRUE;
000458  f8857067          STRB     r7,[r5,#0x67]
;;;1041                           dut_info.appUpFlag = FALSE;
00045c  f8858025          STRB     r8,[r5,#0x25]
000460  e016              B        |L3.1168|
                  |L3.1122|
;;;1042                       }
;;;1043                       else if (dut_info.uiUpFlag)
000462  f8950027          LDRB     r0,[r5,#0x27]  ; dut_info
000466  b198              CBZ      r0,|L3.1168|
;;;1044                       {
;;;1045                           dut_info.uiUpSuccesss = TRUE;
000468  f8857066          STRB     r7,[r5,#0x66]
;;;1046                           dut_info.uiUpFlag = FALSE;
00046c  f8858027          STRB     r8,[r5,#0x27]
000470  e00e              B        |L3.1168|
                  |L3.1138|
;;;1047                       }
;;;1048                   }
;;;1049                   else // 升级失败
;;;1050                   {
;;;1051                       if (dut_info.appUpFlag)
000472  f8950025          LDRB     r0,[r5,#0x25]  ; dut_info
000476  b120              CBZ      r0,|L3.1154|
;;;1052                       {
;;;1053                           dut_info.appUpFaile = TRUE;
000478  f8857061          STRB     r7,[r5,#0x61]
;;;1054                           dut_info.appUpFlag = FALSE;
00047c  f8858025          STRB     r8,[r5,#0x25]
000480  e006              B        |L3.1168|
                  |L3.1154|
;;;1055                       }
;;;1056                       else if (dut_info.uiUpFlag)
000482  f8950027          LDRB     r0,[r5,#0x27]  ; dut_info
000486  b118              CBZ      r0,|L3.1168|
;;;1057                       {
;;;1058                           dut_info.appUpFaile = TRUE;
000488  f8857061          STRB     r7,[r5,#0x61]
;;;1059                           dut_info.uiUpFlag = FALSE;
00048c  f8858027          STRB     r8,[r5,#0x27]
                  |L3.1168|
;;;1060                       }
;;;1061                   }
;;;1062                   TIMER_KillTask(TIMER_ID_DUT_TIMEOUT);
000490  2008              MOVS     r0,#8
000492  f7fffffe          BL       TIMER_KillTask
;;;1063                   STATE_SwitchStep(STEP_KAIYANG_CAN_UPGRADE_ITEM_FINISH);
000496  f44f7086          MOV      r0,#0x10c
00049a  f7fffffe          BL       STATE_SwitchStep
                  |L3.1182|
;;;1064                   break;
;;;1065   
;;;1066               default:
;;;1067                   break;
;;;1068               }
;;;1069               break;
;;;1070   
;;;1071           default:
;;;1072               break;
;;;1073           }
;;;1074           // 删除命令帧
;;;1075           pCB->rx.rxEachNode[sourceBuffSelect].head++;
00049e  f8b60c24          LDRH     r0,[r6,#0xc24]
0004a2  1c40              ADDS     r0,r0,#1
0004a4  b280              UXTH     r0,r0
;;;1076           pCB->rx.rxEachNode[sourceBuffSelect].head %= CAN_RX_QUEUE_SIZE;
0004a6  2114              MOVS     r1,#0x14
0004a8  fbb0f2f1          UDIV     r2,r0,r1
0004ac  fb010012          MLS      r0,r1,r2,r0
0004b0  f8a60c24          STRH     r0,[r6,#0xc24]
                  |L3.1204|
0004b4  f1090901          ADD      r9,r9,#1              ;607
0004b8  f00909ff          AND      r9,r9,#0xff           ;607
0004bc  f1b90f00          CMP      r9,#0                 ;607
0004c0  f43fadad          BEQ      |L3.30|
                  |L3.1220|
;;;1077       }
;;;1078   }
0004c4  e8bd8ffe          POP      {r1-r11,pc}
;;;1079   
                          ENDP


                          AREA ||i.CAN_ConfirmTempCmdFrameBuff||, CODE, READONLY, ALIGN=1

                  CAN_ConfirmTempCmdFrameBuff PROC
;;;1146   // 将临时缓冲区添加到命令帧缓冲区中，其本质操作是承认临时缓冲区数据有效
;;;1147   BOOL CAN_ConfirmTempCmdFrameBuff(CAN_CB *pCB, uint8 sourceSelect)
000000  2800              CMP      r0,#0
;;;1148   {
000002  d023              BEQ      |L4.76|
;;;1149       CAN_CMD_FRAME *pCmdFrame = NULL;
;;;1150   
;;;1151       // 参数合法性检验
;;;1152       if (NULL == pCB)
;;;1153       {
;;;1154           return FALSE;
;;;1155       }
;;;1156   
;;;1157       // 临时缓冲区为空，不予添加
;;;1158       pCmdFrame = &pCB->rx.rxEachNode[sourceSelect].cmdQueue[pCB->rx.rxEachNode[sourceSelect].end];
000004  f24022e5          MOV      r2,#0x2e5
000008  4351              MULS     r1,r2,r1
00000a  eb000181          ADD      r1,r0,r1,LSL #2
00000e  f8b10c26          LDRH     r0,[r1,#0xc26]
000012  eb000280          ADD      r2,r0,r0,LSL #2
000016  eb021240          ADD      r2,r2,r0,LSL #5
00001a  eb010282          ADD      r2,r1,r2,LSL #2
;;;1159   
;;;1160       if (0 == pCmdFrame->length)
00001e  f8b22124          LDRH     r2,[r2,#0x124]
000022  b1aa              CBZ      r2,|L4.80|
;;;1161       {
;;;1162           return FALSE;
;;;1163       }
;;;1164   
;;;1165       // 添加
;;;1166       pCB->rx.rxEachNode[sourceSelect].end++;
000024  1c40              ADDS     r0,r0,#1
000026  b280              UXTH     r0,r0
;;;1167       pCB->rx.rxEachNode[sourceSelect].end %= CAN_RX_QUEUE_SIZE;
000028  2214              MOVS     r2,#0x14
00002a  fbb0f3f2          UDIV     r3,r0,r2
00002e  fb020013          MLS      r0,r2,r3,r0
000032  f8a10c26          STRH     r0,[r1,#0xc26]
;;;1168       // 该行的作用是将新的添加位置有效数据个数清零，以便将这个位置当做临时帧缓冲区
;;;1169       pCB->rx.rxEachNode[sourceSelect].cmdQueue[pCB->rx.rxEachNode[sourceSelect].end].length = 0;
000036  eb000380          ADD      r3,r0,r0,LSL #2
00003a  eb031040          ADD      r0,r3,r0,LSL #5
00003e  eb010080          ADD      r0,r1,r0,LSL #2
000042  2200              MOVS     r2,#0
000044  f8a02124          STRH     r2,[r0,#0x124]
;;;1170   
;;;1171       return TRUE;
000048  2001              MOVS     r0,#1
;;;1172   }
00004a  4770              BX       lr
                  |L4.76|
00004c  2000              MOVS     r0,#0                 ;1154
00004e  4770              BX       lr
                  |L4.80|
000050  2000              MOVS     r0,#0                 ;1162
000052  4770              BX       lr
;;;1173   
                          ENDP


                          AREA ||i.CAN_DRIVE_AddTxArray||, CODE, READONLY, ALIGN=2

                  CAN_DRIVE_AddTxArray PROC
;;;1216   // 向发送缓冲区中添加一条待发送序列
;;;1217   BOOL CAN_DRIVE_AddTxArray(uint32 id, uint8 *pArray, uint8 length)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1218   {
;;;1219       uint16 i;
;;;1220       uint16 head = sysCanCB.tx.head;
000002  4b21              LDR      r3,|L5.136|
000004  f8b374d4          LDRH     r7,[r3,#0x4d4]  ; sysCanCB
;;;1221       uint16 end = sysCanCB.tx.end;
000008  f8b344d6          LDRH     r4,[r3,#0x4d6]  ; sysCanCB
;;;1222   
;;;1223       // 参数检验
;;;1224       if ((NULL == pArray) || (0 == length))
00000c  2900              CMP      r1,#0
00000e  d00a              BEQ      |L5.38|
000010  b14a              CBZ      r2,|L5.38|
;;;1225       {
;;;1226           return FALSE;
;;;1227       }
;;;1228   
;;;1229       // 发送缓冲区已满，不予接收
;;;1230       if ((end + 1) % CAN_TX_QUEUE_SIZE == head)
000012  1c66              ADDS     r6,r4,#1
000014  250f              MOVS     r5,#0xf
000016  fbb6fcf5          UDIV     r12,r6,r5
00001a  fb05661c          MLS      r6,r5,r12,r6
00001e  42be              CMP      r6,r7
000020  d103              BNE      |L5.42|
;;;1231       {
;;;1232           return FALSE;
000022  2000              MOVS     r0,#0
;;;1233       }
;;;1234   
;;;1235       sysCanCB.tx.cmdQueue[end].deviceID = id;
;;;1236   
;;;1237       for (i = 0; i < length; i++)
;;;1238       {
;;;1239           sysCanCB.tx.cmdQueue[end].buff[i] = *pArray++;
;;;1240       }
;;;1241       sysCanCB.tx.cmdQueue[end].length = length;
;;;1242   
;;;1243       // 发送环形队列更新位置
;;;1244       sysCanCB.tx.end++;
;;;1245       sysCanCB.tx.end %= CAN_TX_QUEUE_SIZE;
;;;1246       sysCanCB.tx.cmdQueue[sysCanCB.tx.end].length = 0;
;;;1247   
;;;1248       return TRUE;
;;;1249   }
000024  bdf0              POP      {r4-r7,pc}
                  |L5.38|
000026  2000              MOVS     r0,#0                 ;1226
000028  bdf0              POP      {r4-r7,pc}
                  |L5.42|
00002a  eb040684          ADD      r6,r4,r4,LSL #2       ;1235
00002e  eb061444          ADD      r4,r6,r4,LSL #5       ;1235
000032  4e16              LDR      r6,|L5.140|
000034  eb060484          ADD      r4,r6,r4,LSL #2       ;1235
000038  f8c40c28          STR      r0,[r4,#0xc28]        ;1235
00003c  2000              MOVS     r0,#0                 ;1237
00003e  e007              B        |L5.80|
                  |L5.64|
000040  eb040c00          ADD      r12,r4,r0             ;1239
000044  f8117b01          LDRB     r7,[r1],#1            ;1239
000048  f88c7c2c          STRB     r7,[r12,#0xc2c]       ;1239
00004c  1c40              ADDS     r0,r0,#1              ;1237
00004e  b280              UXTH     r0,r0                 ;1237
                  |L5.80|
000050  4290              CMP      r0,r2                 ;1237
000052  d3f5              BCC      |L5.64|
000054  f8a42cb8          STRH     r2,[r4,#0xcb8]        ;1241
000058  f20343d6          ADD      r3,r3,#0x4d6          ;1244
00005c  8818              LDRH     r0,[r3,#0]            ;1244  ; sysCanCB
00005e  1c40              ADDS     r0,r0,#1              ;1244
000060  8018              STRH     r0,[r3,#0]            ;1244
000062  8818              LDRH     r0,[r3,#0]            ;1245  ; sysCanCB
000064  fbb0f1f5          UDIV     r1,r0,r5              ;1245
000068  fb050011          MLS      r0,r5,r1,r0           ;1245
00006c  8018              STRH     r0,[r3,#0]            ;1245
00006e  8818              LDRH     r0,[r3,#0]            ;1246  ; sysCanCB
000070  2100              MOVS     r1,#0                 ;1246
000072  eb000280          ADD      r2,r0,r0,LSL #2       ;1246
000076  eb021040          ADD      r0,r2,r0,LSL #5       ;1246
00007a  eb060080          ADD      r0,r6,r0,LSL #2       ;1246
00007e  f8a01cb8          STRH     r1,[r0,#0xcb8]        ;1246
000082  2001              MOVS     r0,#1                 ;1248
000084  bdf0              POP      {r4-r7,pc}
;;;1250   
                          ENDP

000086  0000              DCW      0x0000
                  |L5.136|
                          DCD      ||.bss||+0x1000
                  |L5.140|
                          DCD      ||.bss||

                          AREA ||i.CAN_DataStructureInit||, CODE, READONLY, ALIGN=1

                  CAN_DataStructureInit PROC
;;;121    // 数据结构初始化
;;;122    void CAN_DataStructureInit(CAN_CB *pCB)
000000  b530              PUSH     {r4,r5,lr}
;;;123    {
;;;124        uint8 i;
;;;125        uint8 j;
;;;126    
;;;127        // 参数合法性检验
;;;128        if (NULL == pCB)
000002  2800              CMP      r0,#0
000004  d03f              BEQ      |L6.134|
;;;129        {
;;;130            return;
;;;131        }
;;;132    
;;;133        pCB->tx.txBusy = FALSE;
000006  f5005180          ADD      r1,r0,#0x1000
00000a  f20141d4          ADD      r1,r1,#0x4d4
00000e  2400              MOVS     r4,#0
000010  718c              STRB     r4,[r1,#6]
;;;134        pCB->tx.index = 0;
000012  808c              STRH     r4,[r1,#4]
;;;135        pCB->tx.head = 0;
000014  800c              STRH     r4,[r1,#0]
;;;136        pCB->tx.end = 0;
000016  804c              STRH     r4,[r1,#2]
;;;137        for (i = 0; i < CAN_TX_QUEUE_SIZE; i++)
000018  2100              MOVS     r1,#0
                  |L6.26|
;;;138        {
;;;139            pCB->tx.cmdQueue[i].length = 0;
00001a  eb010281          ADD      r2,r1,r1,LSL #2
00001e  eb021241          ADD      r2,r2,r1,LSL #5
000022  eb000282          ADD      r2,r0,r2,LSL #2
000026  f8a24cb8          STRH     r4,[r2,#0xcb8]
00002a  1c49              ADDS     r1,r1,#1              ;137
00002c  b2c9              UXTB     r1,r1                 ;137
00002e  290f              CMP      r1,#0xf               ;137
000030  d3f3              BCC      |L6.26|
;;;140        }
;;;141    
;;;142        for (i = 0; i < CAN_DEVICE_SOURCE_ID_MAX; i++)
000032  2100              MOVS     r1,#0
                  |L6.52|
;;;143        {
;;;144            pCB->rxFIFO.rxFIFOEachNode[i].head = 0;
000034  eb0102c1          ADD      r2,r1,r1,LSL #3
000038  eb021281          ADD      r2,r2,r1,LSL #6
00003c  eb000242          ADD      r2,r0,r2,LSL #1
000040  f8224f8c          STRH     r4,[r2,#0x8c]!
;;;145            pCB->rxFIFO.rxFIFOEachNode[i].end = 0;
000044  8054              STRH     r4,[r2,#2]
;;;146            pCB->rxFIFO.rxFIFOEachNode[i].currentProcessIndex = 0;
000046  8094              STRH     r4,[r2,#4]
000048  1c49              ADDS     r1,r1,#1              ;142
00004a  b2c9              UXTB     r1,r1                 ;142
00004c  2900              CMP      r1,#0                 ;142
00004e  d0f1              BEQ      |L6.52|
;;;147        }
;;;148    
;;;149        for (i = 0; i < CAN_DEVICE_SOURCE_ID_MAX; i++)
000050  2200              MOVS     r2,#0
                  |L6.82|
;;;150        {
;;;151            for (j = 0; j < CAN_RX_QUEUE_SIZE; j++)
000052  2100              MOVS     r1,#0
;;;152            {
;;;153                pCB->rx.rxEachNode[i].cmdQueue[j].length = 0;
000054  f24023e5          MOV      r3,#0x2e5
000058  4353              MULS     r3,r2,r3
00005a  eb000383          ADD      r3,r0,r3,LSL #2
                  |L6.94|
00005e  eb010581          ADD      r5,r1,r1,LSL #2
000062  eb051541          ADD      r5,r5,r1,LSL #5
000066  eb030585          ADD      r5,r3,r5,LSL #2
00006a  f8a54124          STRH     r4,[r5,#0x124]
00006e  1c49              ADDS     r1,r1,#1              ;151
000070  b2c9              UXTB     r1,r1                 ;151
000072  2914              CMP      r1,#0x14              ;151
000074  d3f3              BCC      |L6.94|
;;;154            }
;;;155            pCB->rx.rxEachNode[i].head = 0;
000076  f8a34c24          STRH     r4,[r3,#0xc24]
;;;156            pCB->rx.rxEachNode[i].end = 0;
00007a  f8a34c26          STRH     r4,[r3,#0xc26]
00007e  1c52              ADDS     r2,r2,#1              ;149
000080  b2d2              UXTB     r2,r2                 ;149
000082  2a00              CMP      r2,#0                 ;149
000084  d0e5              BEQ      |L6.82|
                  |L6.134|
;;;157        }
;;;158    }
000086  bd30              POP      {r4,r5,pc}
;;;159    
                          ENDP


                          AREA ||i.CAN_HW_Init||, CODE, READONLY, ALIGN=2

                  CAN_HW_Init PROC
;;;1303   // 功能函数：CAN初始化
;;;1304   void CAN_HW_Init(uint16 bund)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1305   {
000002  b089              SUB      sp,sp,#0x24
000004  4605              MOV      r5,r0
;;;1306       can_parameter_struct can_parameter;
;;;1307       can_filter_parameter_struct can_filter;
;;;1308   
;;;1309       // 时钟分配与使能
;;;1310       rcu_periph_clock_enable(RCU_CAN0);
000006  f2407019          MOV      r0,#0x719
00000a  f7fffffe          BL       rcu_periph_clock_enable
;;;1311       rcu_periph_clock_enable(RCU_GPIOB);
00000e  f2406003          MOV      r0,#0x603
000012  f7fffffe          BL       rcu_periph_clock_enable
;;;1312       rcu_periph_clock_enable(RCU_AF);
000016  f44f60c0          MOV      r0,#0x600
00001a  f7fffffe          BL       rcu_periph_clock_enable
;;;1313   
;;;1314       // 配置CAN的接收中断
;;;1315       nvic_irq_enable(USBD_LP_CAN0_RX0_IRQn, 1, 0);
00001e  2200              MOVS     r2,#0
000020  2101              MOVS     r1,#1
000022  2014              MOVS     r0,#0x14
000024  f7fffffe          BL       nvic_irq_enable
;;;1316   
;;;1317       // 配置CAN邮箱空中断
;;;1318       nvic_irq_enable(USBD_HP_CAN0_TX_IRQn, 2, 0);
000028  2200              MOVS     r2,#0
00002a  2102              MOVS     r1,#2
00002c  2013              MOVS     r0,#0x13
00002e  f7fffffe          BL       nvic_irq_enable
;;;1319   
;;;1320       // CAN管脚重映射到PB8-9
;;;1321       gpio_pin_remap_config(GPIO_CAN_PARTIAL_REMAP, ENABLE);
000032  2101              MOVS     r1,#1
000034  f44f10ea          MOV      r0,#0x1d4000
000038  f7fffffe          BL       gpio_pin_remap_config
;;;1322   
;;;1323       /* configure CAN0 GPIO */
;;;1324       gpio_init(GPIOB, GPIO_MODE_IPU, GPIO_OSPEED_50MHZ, GPIO_PIN_8);
00003c  4c32              LDR      r4,|L7.264|
00003e  f44f7380          MOV      r3,#0x100
000042  2203              MOVS     r2,#3
000044  2148              MOVS     r1,#0x48
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       gpio_init
;;;1325       gpio_init(GPIOB, GPIO_MODE_AF_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_9);
00004c  1563              ASRS     r3,r4,#21
00004e  2203              MOVS     r2,#3
000050  2118              MOVS     r1,#0x18
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       gpio_init
;;;1326   
;;;1327       can_struct_para_init(CAN_INIT_STRUCT, &can_parameter);
000058  a906              ADD      r1,sp,#0x18
00005a  2000              MOVS     r0,#0
00005c  f7fffffe          BL       can_struct_para_init
;;;1328       can_struct_para_init(CAN_INIT_STRUCT, &can_filter);
000060  a901              ADD      r1,sp,#4
000062  2000              MOVS     r0,#0
000064  f7fffffe          BL       can_struct_para_init
;;;1329   
;;;1330       /* initialize CAN register */
;;;1331       can_deinit(CAN0);
000068  4f28              LDR      r7,|L7.268|
00006a  4638              MOV      r0,r7
00006c  f7fffffe          BL       can_deinit
;;;1332   
;;;1333       /* initialize CAN parameters */
;;;1334       can_parameter.time_triggered = DISABLE;
000070  2400              MOVS     r4,#0
000072  f88d401c          STRB     r4,[sp,#0x1c]
;;;1335       can_parameter.auto_bus_off_recovery = ENABLE;
000076  2601              MOVS     r6,#1
000078  f88d601d          STRB     r6,[sp,#0x1d]
;;;1336       can_parameter.auto_wake_up = DISABLE;
00007c  f88d401e          STRB     r4,[sp,#0x1e]
;;;1337       can_parameter.no_auto_retrans = DISABLE;
000080  f88d401f          STRB     r4,[sp,#0x1f]
;;;1338       can_parameter.rec_fifo_overwrite = DISABLE;
000084  f88d4020          STRB     r4,[sp,#0x20]
;;;1339       can_parameter.trans_fifo_order = DISABLE;
000088  f88d4021          STRB     r4,[sp,#0x21]
;;;1340       can_parameter.working_mode = CAN_NORMAL_MODE;
00008c  f88d4018          STRB     r4,[sp,#0x18]
;;;1341   
;;;1342       // 波特率计算：36MHz / (1+6+1) / 36 = 125K bit
;;;1343       can_parameter.resync_jump_width = CAN_BT_SJW_1TQ;
000090  f88d4019          STRB     r4,[sp,#0x19]
;;;1344       can_parameter.time_segment_1 = CAN_BT_BS1_6TQ;// 6
000094  2005              MOVS     r0,#5
000096  f88d001a          STRB     r0,[sp,#0x1a]
;;;1345       can_parameter.time_segment_2 = CAN_BT_BS2_1TQ;// 1
00009a  f88d401b          STRB     r4,[sp,#0x1b]
;;;1346       if (CAN_BAUD_RATE_125K == bund)
;;;1347       {
;;;1348           can_parameter.prescaler = 36;
00009e  2024              MOVS     r0,#0x24
0000a0  2d7d              CMP      r5,#0x7d              ;1346
0000a2  d025              BEQ      |L7.240|
;;;1349       }
;;;1350       else if (CAN_BAUD_RATE_250K == bund)
0000a4  2dfa              CMP      r5,#0xfa
0000a6  d026              BEQ      |L7.246|
;;;1351       {
;;;1352           can_parameter.prescaler = 18;
;;;1353       }
;;;1354       else if (CAN_BAUD_RATE_500K == bund)
0000a8  f5b57ffa          CMP      r5,#0x1f4
0000ac  d027              BEQ      |L7.254|
;;;1355       {
;;;1356           can_parameter.prescaler = 9;
;;;1357       }
;;;1358       else
;;;1359       {
;;;1360           can_parameter.prescaler = 36;
0000ae  f8ad0022          STRH     r0,[sp,#0x22]
                  |L7.178|
;;;1361       }
;;;1362   
;;;1363       /* initialize CAN */
;;;1364       can_init(CAN0, &can_parameter);
0000b2  a906              ADD      r1,sp,#0x18
0000b4  4638              MOV      r0,r7
0000b6  f7fffffe          BL       can_init
;;;1365   
;;;1366       /* initialize filter */
;;;1367       can_filter.filter_number = 1;
0000ba  f8ad600e          STRH     r6,[sp,#0xe]
;;;1368       can_filter.filter_mode = CAN_FILTERMODE_MASK;
0000be  f8ad4010          STRH     r4,[sp,#0x10]
;;;1369       can_filter.filter_bits = CAN_FILTERBITS_32BIT;
0000c2  f8ad6012          STRH     r6,[sp,#0x12]
;;;1370       can_filter.filter_list_high = 0x0000;
0000c6  f8ad4004          STRH     r4,[sp,#4]
;;;1371       can_filter.filter_list_low = 0x0000;
0000ca  f8ad4006          STRH     r4,[sp,#6]
;;;1372       can_filter.filter_mask_high = 0x0000;
0000ce  f8ad4008          STRH     r4,[sp,#8]
;;;1373       can_filter.filter_mask_low = 0x0000;
0000d2  f8ad400a          STRH     r4,[sp,#0xa]
;;;1374       can_filter.filter_fifo_number = CAN_FIFO0;
0000d6  f8ad400c          STRH     r4,[sp,#0xc]
;;;1375       can_filter.filter_enable = ENABLE;
0000da  f88d6014          STRB     r6,[sp,#0x14]
;;;1376   
;;;1377       can_filter_init(&can_filter);
0000de  a801              ADD      r0,sp,#4
0000e0  f7fffffe          BL       can_filter_init
;;;1378   
;;;1379       /* enable can receive FIFO0 not empty interrupt */
;;;1380       can_interrupt_enable(CAN0, CAN_INT_RFNE0);
0000e4  2102              MOVS     r1,#2
0000e6  4638              MOV      r0,r7
0000e8  f7fffffe          BL       can_interrupt_enable
;;;1381   }
0000ec  b009              ADD      sp,sp,#0x24
0000ee  bdf0              POP      {r4-r7,pc}
                  |L7.240|
0000f0  f8ad0022          STRH     r0,[sp,#0x22]         ;1348
0000f4  e7dd              B        |L7.178|
                  |L7.246|
0000f6  2012              MOVS     r0,#0x12              ;1352
0000f8  f8ad0022          STRH     r0,[sp,#0x22]         ;1352
0000fc  e7d9              B        |L7.178|
                  |L7.254|
0000fe  2009              MOVS     r0,#9                 ;1356
000100  f8ad0022          STRH     r0,[sp,#0x22]         ;1356
000104  e7d5              B        |L7.178|
;;;1382   
                          ENDP

000106  0000              DCW      0x0000
                  |L7.264|
                          DCD      0x40010c00
                  |L7.268|
                          DCD      0x40006400

                          AREA ||i.CAN_MacProcess||, CODE, READONLY, ALIGN=2

                  CAN_MacProcess PROC
;;;375    // CAN 报文接收处理函数(注意根据具体模块修改)
;;;376    void CAN_MacProcess(uint16 standarID, uint8 *data, uint8 length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;377    {
;;;378        uint16 end;
;;;379        uint16 head;
;;;380        uint8 i;
;;;381        int8 sourceBuffSelect = CAN_DEVICE_SOURCE_ID_MAX; // 节点缓存区编号选择
;;;382    
;;;383        // 参数合法性判断
;;;384        if (NULL == data)
000004  2900              CMP      r1,#0
000006  d037              BEQ      |L8.120|
;;;385        {
;;;386            return;
;;;387        }
;;;388    
;;;389        // 标准帧判断
;;;390        if (standarID > 0x7FF)
000008  f5b06f00          CMP      r0,#0x800
00000c  d234              BCS      |L8.120|
;;;391        {
;;;392            return;
;;;393        }
;;;394    
;;;395        // 取出目标节点
;;;396        //  destinationID = standarID & 0x07FF;
;;;397    
;;;398        // 不是发给自身ID的数据直接丢掉
;;;399        //  if (CAN_DEVICE_ID_HMI != destinationID)
;;;400        //  {
;;;401        //      return;
;;;402        //  }
;;;403    
;;;404        // 已经使能
;;;405        if (CAN_RX_DEVICE_PUC)
;;;406        {
;;;407            sourceBuffSelect = CAN_RX_DEVICE_PUC - 1;
00000e  2300              MOVS     r3,#0
;;;408        }
;;;409    
;;;410        // 没有合适的源节点
;;;411        if ((sourceBuffSelect >= CAN_DEVICE_SOURCE_ID_MAX) || (sourceBuffSelect < 0))
;;;412        {
;;;413            return;
;;;414        }
;;;415    
;;;416        // 取相应缓存区结构体数据
;;;417        end = sysCanCB.rxFIFO.rxFIFOEachNode[sourceBuffSelect].end;
000010  f8dfc068          LDR      r12,|L8.124|
000014  f8bc008e          LDRH     r0,[r12,#0x8e]
;;;418        head = sysCanCB.rxFIFO.rxFIFOEachNode[sourceBuffSelect].head;
000018  f8bc708c          LDRH     r7,[r12,#0x8c]
;;;419    
;;;420        // ■■环形列队，入队■■
;;;421        //  一级缓冲区已满，不予接收
;;;422        if ((end + 1) % CAN_RX_FIFO_SIZE == head)
00001c  1c40              ADDS     r0,r0,#1
00001e  258c              MOVS     r5,#0x8c
000020  fbb0f4f5          UDIV     r4,r0,r5
000024  fb050014          MLS      r0,r5,r4,r0
000028  42b8              CMP      r0,r7
00002a  d025              BEQ      |L8.120|
;;;423        {
;;;424            return;
;;;425        }
;;;426    
;;;427        for (i = 0; i < length; i++)
00002c  2400              MOVS     r4,#0
00002e  e021              B        |L8.116|
                  |L8.48|
;;;428        {
;;;429            // 单个字节读取，并放入FIFO中
;;;430            sysCanCB.rxFIFO.rxFIFOEachNode[sourceBuffSelect].buff[sysCanCB.rxFIFO.rxFIFOEachNode[sourceBuffSelect].end] = *data++;
000030  eb0300c3          ADD      r0,r3,r3,LSL #3
000034  eb001083          ADD      r0,r0,r3,LSL #6
000038  eb0c0040          ADD      r0,r12,r0,LSL #1
00003c  f8116b01          LDRB     r6,[r1],#1
000040  f8b0808e          LDRH     r8,[r0,#0x8e]
000044  f8086000          STRB     r6,[r8,r0]
;;;431    
;;;432            sysCanCB.rxFIFO.rxFIFOEachNode[sourceBuffSelect].end++;
000048  f8306f8e          LDRH     r6,[r0,#0x8e]!
00004c  1c76              ADDS     r6,r6,#1
00004e  8006              STRH     r6,[r0,#0]
;;;433    
;;;434            // 一级缓冲区已满，不予接收
;;;435            if ((sysCanCB.rxFIFO.rxFIFOEachNode[sourceBuffSelect].end + 1) % CAN_RX_FIFO_SIZE == head)
000050  f830698e          LDRH     r6,[r0],#-0x8e
000054  1c76              ADDS     r6,r6,#1
000056  fbb6f8f5          UDIV     r8,r6,r5
00005a  fb056618          MLS      r6,r5,r8,r6
00005e  42be              CMP      r6,r7
000060  d00a              BEQ      |L8.120|
;;;436            {
;;;437                break;
;;;438            }
;;;439    
;;;440            sysCanCB.rxFIFO.rxFIFOEachNode[sourceBuffSelect].end %= CAN_RX_FIFO_SIZE;
000062  f8306f8e          LDRH     r6,[r0,#0x8e]!
000066  fbb6f8f5          UDIV     r8,r6,r5
00006a  fb056618          MLS      r6,r5,r8,r6
00006e  8006              STRH     r6,[r0,#0]
000070  1c64              ADDS     r4,r4,#1              ;427
000072  b2e4              UXTB     r4,r4                 ;427
                  |L8.116|
000074  4294              CMP      r4,r2                 ;427
000076  d3db              BCC      |L8.48|
                  |L8.120|
;;;441        }
;;;442    }
000078  e8bd81f0          POP      {r4-r8,pc}
;;;443    
                          ENDP

                  |L8.124|
                          DCD      ||.bss||

                          AREA ||i.CAN_PROTOCOL_Process_DT||, CODE, READONLY, ALIGN=2

                  CAN_PROTOCOL_Process_DT PROC
;;;1080   // CAN处理测试过程函数
;;;1081   void CAN_PROTOCOL_Process_DT(void)
000000  b510              PUSH     {r4,lr}
;;;1082   {
;;;1083       // CAN接收FIFO缓冲区处理
;;;1084       CAN_RxFIFOProcess(&sysCanCB);
000002  4805              LDR      r0,|L9.24|
000004  f7fffffe          BL       CAN_RxFIFOProcess
;;;1085   
;;;1086       // CAN接收命令缓冲区处理
;;;1087       CAN_CmdFrameProcess(&sysCanCB);
000008  4803              LDR      r0,|L9.24|
00000a  f7fffffe          BL       CAN_CmdFrameProcess
;;;1088   
;;;1089       // CAN发送状态机处理过程
;;;1090       CAN_TxStateProcess();
00000e  e8bd4010          POP      {r4,lr}
000012  f7ffbffe          B.W      CAN_TxStateProcess
;;;1091   }
;;;1092   
                          ENDP

000016  0000              DCW      0x0000
                  |L9.24|
                          DCD      ||.bss||

                          AREA ||i.CAN_RxFIFOProcess||, CODE, READONLY, ALIGN=1

                  CAN_RxFIFOProcess PROC
;;;444    // 一级报文接收缓冲区处理，从一级接收缓冲区中取出一个字节添加到命令帧缓冲区中
;;;445    void CAN_RxFIFOProcess(CAN_CB *pCB)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;446    {
000004  4680              MOV      r8,r0
;;;447        uint16 end;
;;;448        uint16 head;
;;;449        CAN_CMD_FRAME *pCmdFrame = NULL;
;;;450        CAN_RX_FIFO *pRxFIFO = NULL;
;;;451        uint16 length = 0;
;;;452        uint8 currentData = 0;
;;;453        uint8 sourceBuffSelect;
;;;454    
;;;455        // 参数合法性检验
;;;456        if (NULL == pCB)
000006  f1b80f00          CMP      r8,#0
00000a  d07d              BEQ      |L10.264|
;;;457        {
;;;458            return;
;;;459        }
;;;460    
;;;461        // 循环判断是否有数据需要处理
;;;462        for (sourceBuffSelect = 0; sourceBuffSelect < CAN_DEVICE_SOURCE_ID_MAX; sourceBuffSelect++)
00000c  2600              MOVS     r6,#0
00000e  46b1              MOV      r9,r6
;;;463        {
;;;464            // 获取接收一级缓冲区节点临时缓冲区指针
;;;465            pRxFIFO = &pCB->rxFIFO.rxFIFOEachNode[sourceBuffSelect];
;;;466    
;;;467            end = pRxFIFO->end;
;;;468            head = pRxFIFO->head;
;;;469    
;;;470            // 一级缓冲区为空，继续
;;;471            if (head == end)
;;;472            {
;;;473                continue;
;;;474            }
;;;475    
;;;476            // 获取接收命令临时缓冲区指针
;;;477            pCmdFrame = &pCB->rx.rxEachNode[sourceBuffSelect].cmdQueue[pCB->rx.rxEachNode[sourceBuffSelect].end];
;;;478    
;;;479            // 取出当前要处理的字节
;;;480            currentData = pRxFIFO->buff[pRxFIFO->currentProcessIndex];
;;;481    
;;;482            // 临时缓冲区长度为0时，搜索首字节
;;;483            if (0 == pCmdFrame->length)
;;;484            {
;;;485                // 命令头错误，删除当前字节并退出
;;;486                if (CAN_CMD_HEAD != currentData)
;;;487                {
;;;488                    pRxFIFO->head++;
;;;489                    pRxFIFO->head %= CAN_RX_FIFO_SIZE;
000010  278c              MOVS     r7,#0x8c
                  |L10.18|
000012  eb0600c6          ADD      r0,r6,r6,LSL #3       ;465
000016  eb001086          ADD      r0,r0,r6,LSL #6       ;465
00001a  eb080440          ADD      r4,r8,r0,LSL #1       ;465
00001e  f8b4108e          LDRH     r1,[r4,#0x8e]         ;467
000022  f8b4008c          LDRH     r0,[r4,#0x8c]         ;468
000026  4288              CMP      r0,r1                 ;471
000028  d024              BEQ      |L10.116|
00002a  f24020e5          MOV      r0,#0x2e5             ;477
00002e  4370              MULS     r0,r6,r0              ;477
000030  eb080280          ADD      r2,r8,r0,LSL #2       ;477
000034  f8b20c26          LDRH     r0,[r2,#0xc26]        ;477
000038  eb000380          ADD      r3,r0,r0,LSL #2       ;477
00003c  eb031340          ADD      r3,r3,r0,LSL #5       ;477
000040  eb020583          ADD      r5,r2,r3,LSL #2       ;477
000044  3594              ADDS     r5,r5,#0x94           ;477
000046  f8b43090          LDRH     r3,[r4,#0x90]         ;480
00004a  5ce3              LDRB     r3,[r4,r3]            ;480
00004c  f8b5c090          LDRH     r12,[r5,#0x90]        ;483
000050  f1bc0f00          CMP      r12,#0                ;483
000054  d00f              BEQ      |L10.118|
;;;490                    pRxFIFO->currentProcessIndex = pRxFIFO->head;
;;;491    
;;;492                    continue;
;;;493                }
;;;494    
;;;495                // 命令头正确，但无命令临时缓冲区可用，退出
;;;496                if ((pCB->rx.rxEachNode[sourceBuffSelect].end + 1) % CAN_RX_QUEUE_SIZE == pCB->rx.rxEachNode[sourceBuffSelect].head)
;;;497                {
;;;498                    continue;
;;;499                }
;;;500    
;;;501                // 命令头正确，有临时缓冲区可用，则将其添加到命令帧临时缓冲区中
;;;502                pCmdFrame->buff[pCmdFrame->length++] = currentData;
;;;503                pRxFIFO->currentProcessIndex++;
;;;504                pRxFIFO->currentProcessIndex %= CAN_RX_FIFO_SIZE;
;;;505            }
;;;506            // 非首字节，将数据添加到命令帧临时缓冲区中，但暂不删除当前数据
;;;507            else
;;;508            {
;;;509                // 临时缓冲区溢出，说明当前正在接收的命令帧是错误的，正确的命令帧不会出现长度溢出的情况
;;;510                if (pCmdFrame->length >= CAN_CMD_FRAME_LENGTH_MAX)
000056  f1bc0f8c          CMP      r12,#0x8c
00005a  d377              BCC      |L10.332|
;;;511                {
;;;512                    // 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;513                    pRxFIFO->head++;
00005c  f8340f8c          LDRH     r0,[r4,#0x8c]!
000060  1c40              ADDS     r0,r0,#1
000062  8020              STRH     r0,[r4,#0]
;;;514                    pRxFIFO->head %= CAN_RX_FIFO_SIZE;
000064  8820              LDRH     r0,[r4,#0]
000066  fbb0f1f7          UDIV     r1,r0,r7
00006a  fb070011          MLS      r0,r7,r1,r0
00006e  8020              STRH     r0,[r4,#0]
;;;515                    pRxFIFO->currentProcessIndex = pRxFIFO->head;
000070  8820              LDRH     r0,[r4,#0]
000072  80a0              STRH     r0,[r4,#4]
                  |L10.116|
;;;516    
;;;517                    continue;
000074  e07e              B        |L10.372|
                  |L10.118|
000076  2b55              CMP      r3,#0x55              ;486
000078  d00c              BEQ      |L10.148|
00007a  f8340f8c          LDRH     r0,[r4,#0x8c]!        ;488
00007e  1c40              ADDS     r0,r0,#1              ;488
000080  8020              STRH     r0,[r4,#0]            ;488
000082  8820              LDRH     r0,[r4,#0]            ;489
000084  fbb0f1f7          UDIV     r1,r0,r7              ;489
000088  fb070011          MLS      r0,r7,r1,r0           ;489
00008c  8020              STRH     r0,[r4,#0]            ;489
00008e  8820              LDRH     r0,[r4,#0]            ;490
000090  80a0              STRH     r0,[r4,#4]            ;490
000092  e06f              B        |L10.372|
                  |L10.148|
000094  1c40              ADDS     r0,r0,#1              ;496
000096  2114              MOVS     r1,#0x14              ;496
000098  fbb0fcf1          UDIV     r12,r0,r1             ;496
00009c  fb01001c          MLS      r0,r1,r12,r0          ;496
0000a0  f8b21c24          LDRH     r1,[r2,#0xc24]        ;496
0000a4  4288              CMP      r0,r1                 ;496
0000a6  d065              BEQ      |L10.372|
0000a8  2001              MOVS     r0,#1                 ;502
0000aa  f8a50090          STRH     r0,[r5,#0x90]         ;502
0000ae  712b              STRB     r3,[r5,#4]            ;502
0000b0  f8340f90          LDRH     r0,[r4,#0x90]!        ;503
0000b4  1c40              ADDS     r0,r0,#1              ;503
0000b6  b280              UXTH     r0,r0                 ;503
0000b8  fbb0f1f7          UDIV     r1,r0,r7              ;504
0000bc  fb070011          MLS      r0,r7,r1,r0           ;504
0000c0  8020              STRH     r0,[r4,#0]            ;504
0000c2  e057              B        |L10.372|
                  |L10.196|
;;;518                }
;;;519    
;;;520                // 一直取到末尾
;;;521                while (end != pRxFIFO->currentProcessIndex)
;;;522                {
;;;523                    // 取出当前要处理的字节
;;;524                    currentData = pRxFIFO->buff[pRxFIFO->currentProcessIndex];
0000c4  5c22              LDRB     r2,[r4,r0]
;;;525                    // 缓冲区未溢出，正常接收，将数据添加到临时缓冲区中
;;;526                    pCmdFrame->buff[pCmdFrame->length++] = currentData;
0000c6  f8b50090          LDRH     r0,[r5,#0x90]
0000ca  1c43              ADDS     r3,r0,#1
0000cc  4428              ADD      r0,r0,r5
0000ce  f8a53090          STRH     r3,[r5,#0x90]
0000d2  7102              STRB     r2,[r0,#4]
;;;527                    pRxFIFO->currentProcessIndex++;
0000d4  f8b40090          LDRH     r0,[r4,#0x90]
0000d8  1c40              ADDS     r0,r0,#1
0000da  b280              UXTH     r0,r0
;;;528                    pRxFIFO->currentProcessIndex %= CAN_RX_FIFO_SIZE;
0000dc  fbb0f2f7          UDIV     r2,r0,r7
0000e0  fb070012          MLS      r0,r7,r2,r0
0000e4  f8a40090          STRH     r0,[r4,#0x90]
;;;529    
;;;530                    // ■■接下来，需要检查命令帧是否完整，如果完整，则将命令帧临时缓冲区扶正■■
;;;531    
;;;532                    // 首先判断命令帧最小长度，一个完整的命令字至少包括4个字节: 命令头(1Byte)+命令字(1Byte)+数据长度(1Byte)+校验码(1Byte) ，因此不足4个字节的必定不完整
;;;533                    if (pCmdFrame->length < CAN_CMD_FRAME_LENGTH_MIN)
0000e8  f8b5a090          LDRH     r10,[r5,#0x90]
0000ec  f1ba0f04          CMP      r10,#4
0000f0  d33c              BCC      |L10.364|
;;;534                    {
;;;535                        // 继续接收
;;;536                        continue;
;;;537                    }
;;;538    
;;;539                    // 命令帧长度数值越界，说明当前命令帧错误，停止接收
;;;540                    if (pCmdFrame->buff[CAN_CMD_LENGTH_INDEX] > (CAN_CMD_FRAME_LENGTH_MAX - CAN_CMD_FRAME_LENGTH_MIN))
0000f2  79a8              LDRB     r0,[r5,#6]
0000f4  2888              CMP      r0,#0x88
0000f6  d910              BLS      |L10.282|
;;;541                    {
;;;542                        // 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;543                        pCmdFrame->length = 0;
0000f8  f8a59090          STRH     r9,[r5,#0x90]
;;;544                        // 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;545                        pRxFIFO->head++;
0000fc  f8340f8c          LDRH     r0,[r4,#0x8c]!
000100  1c40              ADDS     r0,r0,#1
000102  8020              STRH     r0,[r4,#0]
;;;546                        pRxFIFO->head %= CAN_RX_FIFO_SIZE;
000104  8820              LDRH     r0,[r4,#0]
000106  e000              B        |L10.266|
                  |L10.264|
000108  e039              B        |L10.382|
                  |L10.266|
00010a  fbb0f1f7          UDIV     r1,r0,r7
00010e  fb070011          MLS      r0,r7,r1,r0
000112  8020              STRH     r0,[r4,#0]
;;;547                        pRxFIFO->currentProcessIndex = pRxFIFO->head;
000114  8820              LDRH     r0,[r4,#0]
000116  80a0              STRH     r0,[r4,#4]
;;;548    
;;;549                        break;
000118  e02c              B        |L10.372|
                  |L10.282|
;;;550                    }
;;;551    
;;;552                    // 命令帧长度校验，在命令长度描述字的数值上，增加命令头、命令字、...、数据长度、校验码，即为命令帧实际长度
;;;553                    length = pCmdFrame->length;
;;;554                    if (length < (pCmdFrame->buff[CAN_CMD_LENGTH_INDEX] + CAN_CMD_FRAME_LENGTH_MIN))
00011a  1d00              ADDS     r0,r0,#4
00011c  4550              CMP      r0,r10
00011e  d825              BHI      |L10.364|
;;;555                    {
;;;556                        // 长度要求不一致，说明未接收完毕，继续
;;;557                        continue;
;;;558                    }
;;;559    
;;;560                    // 命令帧长度OK，则进行校验，失败时删除命令头
;;;561                    if (!CAN_CheckSum(pCmdFrame->buff, pCmdFrame->length))
000120  4651              MOV      r1,r10
000122  1d28              ADDS     r0,r5,#4
000124  f7fffffe          BL       CAN_CheckSum
000128  b188              CBZ      r0,|L10.334|
;;;562                    {
;;;563                        // 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;564                        pCmdFrame->length = 0;
;;;565                        // 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;566                        pRxFIFO->head++;
;;;567                        pRxFIFO->head %= CAN_RX_FIFO_SIZE;
;;;568                        pRxFIFO->currentProcessIndex = pRxFIFO->head;
;;;569    
;;;570                        break;
;;;571                    }
;;;572    
;;;573                    // 执行到这里，即说明接收到了一个完整并且正确的命令帧，此时需将处理过的数据从一级缓冲区中删除，并将该命令帧扶正
;;;574                    pRxFIFO->head += length;
00012a  f8340f8c          LDRH     r0,[r4,#0x8c]!
00012e  4450              ADD      r0,r0,r10
000130  8020              STRH     r0,[r4,#0]
;;;575                    pRxFIFO->head %= CAN_RX_FIFO_SIZE;
000132  8820              LDRH     r0,[r4,#0]
000134  fbb0f1f7          UDIV     r1,r0,r7
000138  fb070011          MLS      r0,r7,r1,r0
00013c  8020              STRH     r0,[r4,#0]
;;;576                    pRxFIFO->currentProcessIndex = pRxFIFO->head;
00013e  8820              LDRH     r0,[r4,#0]
000140  80a0              STRH     r0,[r4,#4]
;;;577    
;;;578                    CAN_ConfirmTempCmdFrameBuff(pCB, sourceBuffSelect);
000142  4631              MOV      r1,r6
000144  4640              MOV      r0,r8
000146  f7fffffe          BL       CAN_ConfirmTempCmdFrameBuff
;;;579    
;;;580                    break;
00014a  e013              B        |L10.372|
                  |L10.332|
00014c  e00e              B        |L10.364|
                  |L10.334|
00014e  f8a59090          STRH     r9,[r5,#0x90]         ;564
000152  f8340f8c          LDRH     r0,[r4,#0x8c]!        ;566
000156  1c40              ADDS     r0,r0,#1              ;566
000158  8020              STRH     r0,[r4,#0]            ;566
00015a  8820              LDRH     r0,[r4,#0]            ;567
00015c  fbb0f1f7          UDIV     r1,r0,r7              ;567
000160  fb070011          MLS      r0,r7,r1,r0           ;567
000164  8020              STRH     r0,[r4,#0]            ;567
000166  8820              LDRH     r0,[r4,#0]            ;568
000168  80a0              STRH     r0,[r4,#4]            ;568
00016a  e003              B        |L10.372|
                  |L10.364|
00016c  f8b40090          LDRH     r0,[r4,#0x90]         ;521
000170  4288              CMP      r0,r1                 ;521
000172  d1a7              BNE      |L10.196|
                  |L10.372|
000174  1c76              ADDS     r6,r6,#1              ;462
000176  b2f6              UXTB     r6,r6                 ;462
000178  2e00              CMP      r6,#0                 ;462
00017a  f43faf4a          BEQ      |L10.18|
                  |L10.382|
;;;581                }
;;;582            }
;;;583        }
;;;584    
;;;585        return;
;;;586    }
00017e  e8bd87f0          POP      {r4-r10,pc}
;;;587    
                          ENDP


                          AREA ||i.CAN_TEST||, CODE, READONLY, ALIGN=1

                  CAN_TEST PROC
;;;88     
;;;89     void CAN_TEST(uint32 temp)
000000  b500              PUSH     {lr}
;;;90     {
;;;91         IAP_CTRL_CAN_TxAddData(CAN_CMD_HEAD);
000002  2055              MOVS     r0,#0x55
000004  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;92         IAP_CTRL_CAN_TxAddData(IAP_CTRL_CAN_CMD_DOWN_PROJECT_APPLY_ACK);
000008  2002              MOVS     r0,#2
00000a  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;93         IAP_CTRL_CAN_TxAddData(2); // 数据长度
00000e  2002              MOVS     r0,#2
000010  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;94         IAP_CTRL_CAN_TxAddData(55);
000014  2037              MOVS     r0,#0x37
000016  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;95         IAP_CTRL_CAN_TxAddData(55);
00001a  2037              MOVS     r0,#0x37
00001c  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;96         IAP_CTRL_CAN_TxAddFrame();
000020  f85deb04          POP      {lr}
000024  f7ffbffe          B.W      IAP_CTRL_CAN_TxAddFrame
;;;97     }
;;;98     /*********************************************************
                          ENDP


                          AREA ||i.CAN_TxEnterState||, CODE, READONLY, ALIGN=2

                  CAN_TxEnterState PROC
;;;1180   // CANTX状态迁移函数
;;;1181   void CAN_TxEnterState(uint32 state)
000000  4902              LDR      r1,|L12.12|
;;;1182   {
;;;1183       // 让当前的状态成为历史
;;;1184       canTxStateCB.preState = canTxStateCB.state;
000002  780a              LDRB     r2,[r1,#0]  ; canTxStateCB
000004  704a              STRB     r2,[r1,#1]
;;;1185   
;;;1186       // 设置新的状态
;;;1187       canTxStateCB.state = (CAN_TX_STATE_E)state;
000006  7008              STRB     r0,[r1,#0]
;;;1188   
;;;1189       switch (state)
;;;1190       {
;;;1191       // ■■状态的入口处理■■
;;;1192       case CAN_TX_STATE_NULL:
;;;1193   
;;;1194           break;
;;;1195   
;;;1196       // ■■入口状态的入口处理■■
;;;1197       case CAN_TX_STATE_ENTRY:
;;;1198   
;;;1199           break;
;;;1200   
;;;1201       // ■■待机状态状态的入口处理■■
;;;1202       case CAN_TX_STATE_STANDBY:
;;;1203   
;;;1204           break;
;;;1205   
;;;1206       // ■■CAN消息发送中■■
;;;1207       case CAN_TX_STATE_SENDING:
;;;1208   
;;;1209           break;
;;;1210   
;;;1211       default:
;;;1212           break;
;;;1213       }
;;;1214   }
000008  4770              BX       lr
;;;1215   
                          ENDP

00000a  0000              DCW      0x0000
                  |L12.12|
                          DCD      ||.data||

                          AREA ||i.CAN_TxStateInit||, CODE, READONLY, ALIGN=1

                  CAN_TxStateInit PROC
;;;1174   // CANTX状态机初始化
;;;1175   void CAN_TxStateInit(void)
000000  2002              MOVS     r0,#2
;;;1176   {
;;;1177       CAN_TxEnterState(CAN_TX_STATE_STANDBY);
000002  f7ffbffe          B.W      CAN_TxEnterState
;;;1178   }
;;;1179   
                          ENDP


                          AREA ||i.CAN_TxStateProcess||, CODE, READONLY, ALIGN=2

                  CAN_TxStateProcess PROC
;;;1251   // CANTX过程处理函数
;;;1252   void CAN_TxStateProcess(void)
000000  b510              PUSH     {r4,lr}
;;;1253   {
;;;1254       uint16 head = sysCanCB.tx.head;
000002  480f              LDR      r0,|L14.64|
000004  f8b014d4          LDRH     r1,[r0,#0x4d4]  ; sysCanCB
;;;1255       uint16 end = sysCanCB.tx.end;
000008  f8b024d6          LDRH     r2,[r0,#0x4d6]  ; sysCanCB
;;;1256   
;;;1257       switch (canTxStateCB.state)
00000c  480d              LDR      r0,|L14.68|
00000e  7800              LDRB     r0,[r0,#0]  ; canTxStateCB
000010  2800              CMP      r0,#0
000012  d013              BEQ      |L14.60|
000014  2801              CMP      r0,#1
000016  d011              BEQ      |L14.60|
000018  2802              CMP      r0,#2
00001a  d10f              BNE      |L14.60|
;;;1258       {
;;;1259       // ■■状态的入口处理■■
;;;1260       case CAN_TX_STATE_NULL:
;;;1261   
;;;1262           break;
;;;1263   
;;;1264       // ■■入口状态的入口处理■■
;;;1265       case CAN_TX_STATE_ENTRY:
;;;1266   
;;;1267           break;
;;;1268   
;;;1269       // ■■待机状态状态的入口处理■■
;;;1270       case CAN_TX_STATE_STANDBY:
;;;1271           // 检测是否有Tx请求
;;;1272           if (head != end)
00001c  4291              CMP      r1,r2
00001e  d00d              BEQ      |L14.60|
;;;1273           {
;;;1274               // 调用此函数填充与启动发送can消息
;;;1275               if (CAN_Tx_FillAndSend(&sysCanCB))
000020  4809              LDR      r0,|L14.72|
000022  f7fffffe          BL       CAN_Tx_FillAndSend
000026  b120              CBZ      r0,|L14.50|
;;;1276               {
;;;1277                   // 进入CAN消息发送中状态
;;;1278                   CAN_TxEnterState(CAN_TX_STATE_SENDING);
000028  e8bd4010          POP      {r4,lr}
00002c  2004              MOVS     r0,#4
00002e  f7ffbffe          B.W      CAN_TxEnterState
                  |L14.50|
;;;1279               }
;;;1280               else
;;;1281               {
;;;1282                   // 进入CAN消息发送待机状态
;;;1283                   CAN_TxEnterState(CAN_TX_STATE_STANDBY);
000032  e8bd4010          POP      {r4,lr}
000036  2002              MOVS     r0,#2
000038  f7ffbffe          B.W      CAN_TxEnterState
                  |L14.60|
;;;1284               }
;;;1285           }
;;;1286           else
;;;1287           {
;;;1288               // 否则什么也不处理
;;;1289           }
;;;1290   
;;;1291           break;
;;;1292   
;;;1293       // ■■CAN消息发送中■■
;;;1294       case CAN_TX_STATE_SENDING:
;;;1295   
;;;1296           break;
;;;1297   
;;;1298       default:
;;;1299           break;
;;;1300       }
;;;1301   }
00003c  bd10              POP      {r4,pc}
;;;1302   
                          ENDP

00003e  0000              DCW      0x0000
                  |L14.64|
                          DCD      ||.bss||+0x1000
                  |L14.68|
                          DCD      ||.data||
                  |L14.72|
                          DCD      ||.bss||

                          AREA ||i.CAN_Tx_FillAndSend||, CODE, READONLY, ALIGN=2

                  CAN_Tx_FillAndSend PROC
;;;232    // 填充与发送处理:TRUE,填充与发送；FALSE，环形队列向前滑移.
;;;233    BOOL CAN_Tx_FillAndSend(CAN_CB *pCB)
000000  b5f0              PUSH     {r4-r7,lr}
;;;234    {
000002  b085              SUB      sp,sp,#0x14
;;;235        uint16 index = pCB->tx.index;                          // 当前发送数据的索引号
000004  f5005180          ADD      r1,r0,#0x1000
000008  f20141d4          ADD      r1,r1,#0x4d4
00000c  888b              LDRH     r3,[r1,#4]
;;;236        uint16 length = pCB->tx.cmdQueue[pCB->tx.head].length; // 当前发送的命令帧的长度
00000e  880a              LDRH     r2,[r1,#0]
000010  eb020482          ADD      r4,r2,r2,LSL #2
000014  eb041242          ADD      r2,r4,r2,LSL #5
000018  eb000282          ADD      r2,r0,r2,LSL #2
00001c  f8b25cb8          LDRH     r5,[r2,#0xcb8]
;;;237        uint16 head = pCB->tx.head;                            // 发送命令帧队列头索引号
000020  880c              LDRH     r4,[r1,#0]
;;;238        uint16 end = pCB->tx.end;                              // 发送命令帧队列尾索引号
000022  884e              LDRH     r6,[r1,#2]
;;;239        CAN_CMD_FRAME *pCmd = &pCB->tx.cmdQueue[pCB->tx.head]; // 取当前发送缓冲区地址
000024  880a              LDRH     r2,[r1,#0]
000026  f2a141d4          SUB      r1,r1,#0x4d4
00002a  eb020782          ADD      r7,r2,r2,LSL #2
00002e  eb071242          ADD      r2,r7,r2,LSL #5
000032  eb000282          ADD      r2,r0,r2,LSL #2
000036  f6024228          ADD      r2,r2,#0xc28
;;;240        can_trasnmit_message_struct canTxMsgCB;
;;;241        uint16 standardID = 0x000;
;;;242        uint8 i; // 内部赋值用
;;;243        uint32 extendedID;
;;;244    
;;;245        // 参数合法性检验
;;;246        if (NULL == pCB)
00003a  2800              CMP      r0,#0
00003c  d004              BEQ      |L15.72|
;;;247        {
;;;248            return FALSE;
;;;249        }
;;;250    
;;;251        // 队列为空，不处理
;;;252        if (head == end)
00003e  42b4              CMP      r4,r6
000040  d104              BNE      |L15.76|
;;;253        {
;;;254            return FALSE;
000042  2000              MOVS     r0,#0
                  |L15.68|
;;;255        }
;;;256    
;;;257        // ■■执行到这里，说明队列非空■■
;;;258    
;;;259        // 当前命令帧未发送完时，根据长度的变化取出命令帧中的数据放到发送寄存器中
;;;260        if (index < length)
;;;261        {
;;;262            // 配置为标准帧
;;;263            // 配置为数据帧
;;;264            canTxMsgCB.tx_ft = CAN_FT_DATA;
;;;265    
;;;266            switch (dut_info.ID)
;;;267            {
;;;268                case DUT_TYPE_GB:
;;;269                case DUT_TYPE_KAIYANG:
;;;270                    // 扩展帧
;;;271                    canTxMsgCB.tx_ff = CAN_FF_EXTENDED;
;;;272                    extendedID = pCmd->deviceID;
;;;273                    canTxMsgCB.tx_efid = extendedID;
;;;274                    break;
;;;275                    
;;;276                default:
;;;277                    if (dut_info.can == CAN_EXTENDED)
;;;278                    {
;;;279                        // 扩展帧
;;;280                        canTxMsgCB.tx_ff = CAN_FF_EXTENDED;
;;;281                        extendedID = pCmd->deviceID;
;;;282                        canTxMsgCB.tx_efid = extendedID;
;;;283        //                dut_info.can = CAN_FF_STANDARD;
;;;284                    }
;;;285                    else
;;;286                    {
;;;287                        // 标准帧
;;;288                        canTxMsgCB.tx_ff = CAN_FF_STANDARD;
;;;289                        standardID = (uint16)CAN_DEVICE_ID_HMI; // id：001
;;;290                        canTxMsgCB.tx_sfid = standardID;
;;;291                    }
;;;292                    break;
;;;293            }
;;;294            // ■■标准数据帧CAN消息格式■■
;;;295    
;;;296            // 填充 DLC，最大8字节.当前长度>8字节，先发8字节。
;;;297            if ((length - index) >= CAN_ONCEMESSAGE_MAX_SIZE)
;;;298            {
;;;299                canTxMsgCB.tx_dlen = CAN_ONCEMESSAGE_MAX_SIZE;
;;;300            }
;;;301            else
;;;302            {
;;;303                canTxMsgCB.tx_dlen = length - index;
;;;304            }
;;;305    
;;;306            // 填充数据
;;;307            for (i = 0; i < canTxMsgCB.tx_dlen; i++)
;;;308            {
;;;309                canTxMsgCB.tx_data[i] = pCmd->buff[index + i];
;;;310            }
;;;311    
;;;312            // 发送数据
;;;313            if (can_message_transmit(CAN0, &canTxMsgCB) == CAN_TRANSMIT_NOMAILBOX)
;;;314            {
;;;315                return FALSE;
;;;316            }
;;;317    
;;;318            // 开启邮箱空中断
;;;319            can_interrupt_enable(CAN0, CAN_INT_TME);
;;;320    
;;;321            return TRUE;
;;;322        }
;;;323        // 当前命令帧发送完时，删除之
;;;324        else
;;;325        {
;;;326            pCB->tx.cmdQueue[head].length = 0;
;;;327            pCB->tx.head++;
;;;328            pCB->tx.head %= CAN_TX_QUEUE_SIZE;
;;;329            pCB->tx.index = 0;
;;;330    
;;;331            // 进入CAN消息发送待机状态
;;;332            CAN_TxEnterState(CAN_TX_STATE_STANDBY);
;;;333    
;;;334            return FALSE;
;;;335        }
;;;336    }
000044  b005              ADD      sp,sp,#0x14
000046  bdf0              POP      {r4-r7,pc}
                  |L15.72|
000048  2000              MOVS     r0,#0                 ;248
00004a  e7fb              B        |L15.68|
                  |L15.76|
00004c  2600              MOVS     r6,#0                 ;260
00004e  42ab              CMP      r3,r5                 ;260
000050  d23f              BCS      |L15.210|
000052  f88d6009          STRB     r6,[sp,#9]            ;264
000056  4c2c              LDR      r4,|L15.264|
000058  2104              MOVS     r1,#4                 ;271
00005a  7da0              LDRB     r0,[r4,#0x16]         ;266  ; dut_info
00005c  2801              CMP      r0,#1                 ;266
00005e  d00f              BEQ      |L15.128|
000060  2805              CMP      r0,#5                 ;266
000062  d00d              BEQ      |L15.128|
000064  7e60              LDRB     r0,[r4,#0x19]         ;277  ; dut_info
000066  2801              CMP      r0,#1                 ;277
000068  d00f              BEQ      |L15.138|
00006a  f88d6008          STRB     r6,[sp,#8]            ;288
00006e  2001              MOVS     r0,#1                 ;289
000070  9000              STR      r0,[sp,#0]            ;290
                  |L15.114|
000072  1ae8              SUBS     r0,r5,r3              ;297
000074  2808              CMP      r0,#8                 ;297
000076  db0d              BLT      |L15.148|
000078  2008              MOVS     r0,#8                 ;299
00007a  f88d000a          STRB     r0,[sp,#0xa]          ;299
00007e  e00b              B        |L15.152|
                  |L15.128|
000080  f88d1008          STRB     r1,[sp,#8]            ;271
000084  6810              LDR      r0,[r2,#0]            ;272
000086  9001              STR      r0,[sp,#4]            ;273
000088  e7f3              B        |L15.114|
                  |L15.138|
00008a  f88d1008          STRB     r1,[sp,#8]            ;280
00008e  6810              LDR      r0,[r2,#0]            ;281
000090  9001              STR      r0,[sp,#4]            ;282
000092  e7ee              B        |L15.114|
                  |L15.148|
000094  f88d000a          STRB     r0,[sp,#0xa]          ;303
                  |L15.152|
000098  2000              MOVS     r0,#0                 ;307
00009a  4669              MOV      r1,sp                 ;240
00009c  e006              B        |L15.172|
                  |L15.158|
00009e  181c              ADDS     r4,r3,r0              ;309
0000a0  4414              ADD      r4,r4,r2              ;309
0000a2  180d              ADDS     r5,r1,r0              ;309
0000a4  7924              LDRB     r4,[r4,#4]            ;309
0000a6  72ec              STRB     r4,[r5,#0xb]          ;309
0000a8  1c40              ADDS     r0,r0,#1              ;307
0000aa  b2c0              UXTB     r0,r0                 ;307
                  |L15.172|
0000ac  f89d400a          LDRB     r4,[sp,#0xa]          ;307
0000b0  4284              CMP      r4,r0                 ;307
0000b2  d8f4              BHI      |L15.158|
0000b4  4c15              LDR      r4,|L15.268|
0000b6  4669              MOV      r1,sp                 ;313
0000b8  4620              MOV      r0,r4                 ;313
0000ba  f7fffffe          BL       can_message_transmit
0000be  2804              CMP      r0,#4                 ;313
0000c0  d005              BEQ      |L15.206|
0000c2  2101              MOVS     r1,#1                 ;319
0000c4  4620              MOV      r0,r4                 ;319
0000c6  f7fffffe          BL       can_interrupt_enable
0000ca  2001              MOVS     r0,#1                 ;321
0000cc  e7ba              B        |L15.68|
                  |L15.206|
0000ce  2000              MOVS     r0,#0                 ;315
0000d0  e7b8              B        |L15.68|
                  |L15.210|
0000d2  eb040284          ADD      r2,r4,r4,LSL #2       ;326
0000d6  eb021244          ADD      r2,r2,r4,LSL #5       ;326
0000da  eb000082          ADD      r0,r0,r2,LSL #2       ;326
0000de  f8a06cb8          STRH     r6,[r0,#0xcb8]        ;326
0000e2  f20141d4          ADD      r1,r1,#0x4d4          ;327
0000e6  8808              LDRH     r0,[r1,#0]            ;327
0000e8  1c40              ADDS     r0,r0,#1              ;327
0000ea  8008              STRH     r0,[r1,#0]            ;327
0000ec  8808              LDRH     r0,[r1,#0]            ;328
0000ee  220f              MOVS     r2,#0xf               ;328
0000f0  fbb0f3f2          UDIV     r3,r0,r2              ;328
0000f4  fb020013          MLS      r0,r2,r3,r0           ;328
0000f8  8008              STRH     r0,[r1,#0]            ;328
0000fa  808e              STRH     r6,[r1,#4]            ;329
0000fc  2002              MOVS     r0,#2                 ;332
0000fe  f7fffffe          BL       CAN_TxEnterState
000102  2000              MOVS     r0,#0                 ;334
000104  e79e              B        |L15.68|
;;;337    
                          ENDP

000106  0000              DCW      0x0000
                  |L15.264|
                          DCD      dut_info
                  |L15.268|
                          DCD      0x40006400

                          AREA ||i.CAN_Tx_NextFram||, CODE, READONLY, ALIGN=1

                  CAN_Tx_NextFram PROC
;;;338    // 发送成功启动下一帧:TRUE,启动下一帧；FALSE，发送完成.
;;;339    BOOL CAN_Tx_NextFram(CAN_CB *pCB)
000000  b510              PUSH     {r4,lr}
;;;340    {
;;;341        uint16 index = pCB->tx.index;                          // 当前发送数据的索引号
000002  f5005180          ADD      r1,r0,#0x1000
000006  f8b134d8          LDRH     r3,[r1,#0x4d8]
;;;342        uint16 length = pCB->tx.cmdQueue[pCB->tx.head].length; // 当前发送的命令帧的长度
00000a  f8b124d4          LDRH     r2,[r1,#0x4d4]
00000e  eb020482          ADD      r4,r2,r2,LSL #2
000012  eb041242          ADD      r2,r4,r2,LSL #5
000016  eb000282          ADD      r2,r0,r2,LSL #2
00001a  f8b22cb8          LDRH     r2,[r2,#0xcb8]
;;;343        uint8 txBnDLC = 0;
;;;344    
;;;345        // 参数合法性检验
;;;346        if (NULL == pCB)
00001e  2800              CMP      r0,#0
000020  d004              BEQ      |L16.44|
;;;347        {
;;;348            return FALSE;
;;;349        }
;;;350    
;;;351        // 判断上一次成功发送的字节数.
;;;352        if (length - index >= CAN_ONCEMESSAGE_MAX_SIZE)
000022  1ad0              SUBS     r0,r2,r3
000024  2808              CMP      r0,#8
000026  db03              BLT      |L16.48|
;;;353        {
;;;354            txBnDLC = CAN_ONCEMESSAGE_MAX_SIZE;
000028  2008              MOVS     r0,#8
00002a  e002              B        |L16.50|
                  |L16.44|
00002c  2000              MOVS     r0,#0                 ;348
;;;355        }
;;;356        else
;;;357        {
;;;358            txBnDLC = length - index;
;;;359        }
;;;360        pCB->tx.index += txBnDLC;
;;;361    
;;;362        // 启动下一帧
;;;363        if (pCB->tx.index < length)
;;;364        {
;;;365            // 进入CAN消息下一帧发送状态
;;;366            return TRUE;
;;;367        }
;;;368        else
;;;369        {
;;;370            // 发送完成
;;;371            return FALSE;
;;;372        }
;;;373    }
00002e  bd10              POP      {r4,pc}
                  |L16.48|
000030  b2c0              UXTB     r0,r0                 ;358
                  |L16.50|
000032  f501619b          ADD      r1,r1,#0x4d8          ;360
000036  880b              LDRH     r3,[r1,#0]            ;360
000038  4418              ADD      r0,r0,r3              ;360
00003a  8008              STRH     r0,[r1,#0]            ;360
00003c  8808              LDRH     r0,[r1,#0]            ;363
00003e  4290              CMP      r0,r2                 ;363
000040  d201              BCS      |L16.70|
000042  2001              MOVS     r0,#1                 ;366
000044  bd10              POP      {r4,pc}
                  |L16.70|
000046  2000              MOVS     r0,#0                 ;371
000048  bd10              POP      {r4,pc}
;;;374    
                          ENDP


                          AREA ||i.IAP_CTRL_CAN_Init||, CODE, READONLY, ALIGN=2

                  IAP_CTRL_CAN_Init PROC
;;;101    // CAN 初始化
;;;102    void IAP_CTRL_CAN_Init(uint16 bund)
000000  b510              PUSH     {r4,lr}
;;;103    {
;;;104        // 初始化硬件配置
;;;105        CAN_HW_Init(bund);
000002  f7fffffe          BL       CAN_HW_Init
;;;106    
;;;107        // 初始化结构体
;;;108        CAN_DataStructureInit(&sysCanCB);
000006  4803              LDR      r0,|L17.20|
000008  f7fffffe          BL       CAN_DataStructureInit
;;;109    
;;;110        // CAN发送状态机初始化
;;;111        CAN_TxStateInit();
00000c  e8bd4010          POP      {r4,lr}
000010  f7ffbffe          B.W      CAN_TxStateInit
;;;112    
;;;113        //  TIMER_AddTask(TIMER_ID_CAN_TEST,//测试
;;;114        //                          500,
;;;115        //                          CAN_TEST,
;;;116        //                          TRUE,
;;;117        //                          -1,
;;;118        //                          ACTION_MODE_ADD_TO_QUEUE);
;;;119    }
;;;120    
                          ENDP

                  |L17.20|
                          DCD      ||.bss||

                          AREA ||i.IAP_CTRL_CAN_SendCmdCheckFlashBlankResult||, CODE, READONLY, ALIGN=1

                  IAP_CTRL_CAN_SendCmdCheckFlashBlankResult PROC
;;;1533   // 查空结果上报
;;;1534   void IAP_CTRL_CAN_SendCmdCheckFlashBlankResult(uint8 param)
000000  b510              PUSH     {r4,lr}
;;;1535   {
000002  4604              MOV      r4,r0
;;;1536       IAP_CTRL_CAN_TxAddData(CAN_CMD_HEAD);
000004  2055              MOVS     r0,#0x55
000006  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1537       IAP_CTRL_CAN_TxAddData(IAP_CTRL_CAN_CMD_UP_CHECK_FLASH_BLANK_RESULT);
00000a  2029              MOVS     r0,#0x29
00000c  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1538       IAP_CTRL_CAN_TxAddData(1); // 数据长度
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1539       IAP_CTRL_CAN_TxAddData(param);
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1540       IAP_CTRL_CAN_TxAddFrame();
00001c  e8bd4010          POP      {r4,lr}
000020  f7ffbffe          B.W      IAP_CTRL_CAN_TxAddFrame
;;;1541   }
;;;1542   
                          ENDP


                          AREA ||i.IAP_CTRL_CAN_SendCmdEraseFlashResult||, CODE, READONLY, ALIGN=1

                  IAP_CTRL_CAN_SendCmdEraseFlashResult PROC
;;;1513   // 擦除FLASH结果上报
;;;1514   void IAP_CTRL_CAN_SendCmdEraseFlashResult(uint8 param)
000000  b510              PUSH     {r4,lr}
;;;1515   {
000002  4604              MOV      r4,r0
;;;1516       IAP_CTRL_CAN_TxAddData(CAN_CMD_HEAD);
000004  2055              MOVS     r0,#0x55
000006  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1517       IAP_CTRL_CAN_TxAddData(IAP_CTRL_CAN_CMD_UP_IAP_ERASE_FLASH_RESULT);
00000a  2025              MOVS     r0,#0x25
00000c  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1518       IAP_CTRL_CAN_TxAddData(1); // 数据长度
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1519       IAP_CTRL_CAN_TxAddData(param);
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1520       IAP_CTRL_CAN_TxAddFrame();
00001c  e8bd4010          POP      {r4,lr}
000020  f7ffbffe          B.W      IAP_CTRL_CAN_TxAddFrame
;;;1521   }
;;;1522   
                          ENDP


                          AREA ||i.IAP_CTRL_CAN_SendCmdNoAck||, CODE, READONLY, ALIGN=1

                  IAP_CTRL_CAN_SendCmdNoAck PROC
;;;1433   // 发送命令不带应答
;;;1434   void IAP_CTRL_CAN_SendCmdNoAck(uint8 param)
000000  b510              PUSH     {r4,lr}
;;;1435   {
000002  4604              MOV      r4,r0
;;;1436       IAP_CTRL_CAN_TxAddData(CAN_CMD_HEAD);
000004  2055              MOVS     r0,#0x55
000006  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1437       IAP_CTRL_CAN_TxAddData(param);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1438       IAP_CTRL_CAN_TxAddData(0);
000010  2000              MOVS     r0,#0
000012  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1439       IAP_CTRL_CAN_TxAddData(1); // 段码屏工程允许
000016  2001              MOVS     r0,#1
000018  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1440       IAP_CTRL_CAN_TxAddFrame();
00001c  e8bd4010          POP      {r4,lr}
000020  f7ffbffe          B.W      IAP_CTRL_CAN_TxAddFrame
;;;1441   }
;;;1442   
                          ENDP


                          AREA ||i.IAP_CTRL_CAN_SendCmdProjectApply||, CODE, READONLY, ALIGN=1

                  IAP_CTRL_CAN_SendCmdProjectApply PROC
;;;1485   // 工程模式启用
;;;1486   void IAP_CTRL_CAN_SendCmdProjectApply(uint8 *param)
000000  b570              PUSH     {r4-r6,lr}
;;;1487   {
000002  4605              MOV      r5,r0
;;;1488       uint8 len = strlen((char *)param);
000004  4628              MOV      r0,r5
000006  f7fffffe          BL       strlen
00000a  b2c6              UXTB     r6,r0
;;;1489       uint8 i;
;;;1490   
;;;1491       IAP_CTRL_CAN_TxAddData(CAN_CMD_HEAD);
00000c  2055              MOVS     r0,#0x55
00000e  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1492       IAP_CTRL_CAN_TxAddData(IAP_CTRL_CAN_CMD_UP_PROJECT_APPLY);
000012  2001              MOVS     r0,#1
000014  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1493       IAP_CTRL_CAN_TxAddData(len); // 数据长度
000018  4630              MOV      r0,r6
00001a  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1494   
;;;1495       for (i = 0; i < len; i++)
00001e  2400              MOVS     r4,#0
000020  e004              B        |L21.44|
                  |L21.34|
;;;1496       {
;;;1497           IAP_CTRL_CAN_TxAddData(param[i]);
000022  5d28              LDRB     r0,[r5,r4]
000024  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
000028  1c64              ADDS     r4,r4,#1              ;1495
00002a  b2e4              UXTB     r4,r4                 ;1495
                  |L21.44|
00002c  42b4              CMP      r4,r6                 ;1495
00002e  d3f8              BCC      |L21.34|
;;;1498       }
;;;1499   
;;;1500       IAP_CTRL_CAN_TxAddFrame();
000030  e8bd4070          POP      {r4-r6,lr}
000034  f7ffbffe          B.W      IAP_CTRL_CAN_TxAddFrame
;;;1501   }
;;;1502   
                          ENDP


                          AREA ||i.IAP_CTRL_CAN_SendCmdProjectReady||, CODE, READONLY, ALIGN=1

                  IAP_CTRL_CAN_SendCmdProjectReady PROC
;;;1503   // 工程模式准备就绪报告
;;;1504   void IAP_CTRL_CAN_SendCmdProjectReady(uint8 param)
000000  b510              PUSH     {r4,lr}
;;;1505   {
000002  4604              MOV      r4,r0
;;;1506       IAP_CTRL_CAN_TxAddData(CAN_CMD_HEAD);
000004  2055              MOVS     r0,#0x55
000006  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1507       IAP_CTRL_CAN_TxAddData(IAP_CTRL_CAN_CMD_UP_PROJECT_READY);
00000a  2003              MOVS     r0,#3
00000c  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1508       IAP_CTRL_CAN_TxAddData(1); // 数据长度
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1509       IAP_CTRL_CAN_TxAddData(param);
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1510       IAP_CTRL_CAN_TxAddFrame();
00001c  e8bd4010          POP      {r4,lr}
000020  f7ffbffe          B.W      IAP_CTRL_CAN_TxAddFrame
;;;1511   }
;;;1512   
                          ENDP


                          AREA ||i.IAP_CTRL_CAN_SendCmdTest||, CODE, READONLY, ALIGN=1

                  IAP_CTRL_CAN_SendCmdTest PROC
;;;1572   // 发送命令测试
;;;1573   void IAP_CTRL_CAN_SendCmdTest(uint32 param)
000000  b500              PUSH     {lr}
;;;1574   {
;;;1575       IAP_CTRL_CAN_TxAddData(CAN_CMD_HEAD);
000002  2055              MOVS     r0,#0x55
000004  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1576       IAP_CTRL_CAN_TxAddData(1);
000008  2001              MOVS     r0,#1
00000a  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1577       IAP_CTRL_CAN_TxAddData(0);
00000e  2000              MOVS     r0,#0
000010  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1578       IAP_CTRL_CAN_TxAddData(1); // 段码屏工程允许
000014  2001              MOVS     r0,#1
000016  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1579       IAP_CTRL_CAN_TxAddFrame();
00001a  f85deb04          POP      {lr}
00001e  f7ffbffe          B.W      IAP_CTRL_CAN_TxAddFrame
;;;1580   }
                          ENDP


                          AREA ||i.IAP_CTRL_CAN_SendCmdUIEraseResultReport||, CODE, READONLY, ALIGN=1

                  IAP_CTRL_CAN_SendCmdUIEraseResultReport PROC
;;;1552   // 发送UI数据擦除结果
;;;1553   void IAP_CTRL_CAN_SendCmdUIEraseResultReport(uint8 param)
000000  b510              PUSH     {r4,lr}
;;;1554   {
000002  4604              MOV      r4,r0
;;;1555       IAP_CTRL_CAN_TxAddData(CAN_CMD_HEAD);
000004  2055              MOVS     r0,#0x55
000006  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1556       IAP_CTRL_CAN_TxAddData(IAP_CTRL_CAN_CMD_UP_UI_DATA_ERASE_ACK);
00000a  2013              MOVS     r0,#0x13
00000c  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1557       IAP_CTRL_CAN_TxAddData(1); // 数据长度
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1558       IAP_CTRL_CAN_TxAddData(param);
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1559       IAP_CTRL_CAN_TxAddFrame();
00001c  e8bd4010          POP      {r4,lr}
000020  f7ffbffe          B.W      IAP_CTRL_CAN_TxAddFrame
;;;1560   }
;;;1561   
                          ENDP


                          AREA ||i.IAP_CTRL_CAN_SendCmdUIWriteDataResultReport||, CODE, READONLY, ALIGN=1

                  IAP_CTRL_CAN_SendCmdUIWriteDataResultReport PROC
;;;1562   // 发送UI数据写入结果
;;;1563   void IAP_CTRL_CAN_SendCmdUIWriteDataResultReport(uint8 param)
000000  b510              PUSH     {r4,lr}
;;;1564   {
000002  4604              MOV      r4,r0
;;;1565       IAP_CTRL_CAN_TxAddData(CAN_CMD_HEAD);
000004  2055              MOVS     r0,#0x55
000006  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1566       IAP_CTRL_CAN_TxAddData(IAP_CTRL_CAN_CMD_UP_UI_DATA_WRITE_RESULT);
00000a  2015              MOVS     r0,#0x15
00000c  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1567       IAP_CTRL_CAN_TxAddData(1); // 数据长度
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1568       IAP_CTRL_CAN_TxAddData(param);
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1569       IAP_CTRL_CAN_TxAddFrame();
00001c  e8bd4010          POP      {r4,lr}
000020  f7ffbffe          B.W      IAP_CTRL_CAN_TxAddFrame
;;;1570   }
;;;1571   
                          ENDP


                          AREA ||i.IAP_CTRL_CAN_SendCmdUpdataFinishResult||, CODE, READONLY, ALIGN=1

                  IAP_CTRL_CAN_SendCmdUpdataFinishResult PROC
;;;1543   // 系统升级结束确认
;;;1544   void IAP_CTRL_CAN_SendCmdUpdataFinishResult(uint8 param)
000000  b500              PUSH     {lr}
;;;1545   {
;;;1546       IAP_CTRL_CAN_TxAddData(CAN_CMD_HEAD);
000002  2055              MOVS     r0,#0x55
000004  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1547       IAP_CTRL_CAN_TxAddData(IAP_CTRL_CAN_CMD_UP_UPDATA_FINISH_RESULT);
000008  202b              MOVS     r0,#0x2b
00000a  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1548       IAP_CTRL_CAN_TxAddData(0); // 数据长度
00000e  2000              MOVS     r0,#0
000010  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1549       IAP_CTRL_CAN_TxAddFrame();
000014  f85deb04          POP      {lr}
000018  f7ffbffe          B.W      IAP_CTRL_CAN_TxAddFrame
;;;1550   }
;;;1551   
                          ENDP


                          AREA ||i.IAP_CTRL_CAN_SendCmdWriteFlashResult||, CODE, READONLY, ALIGN=1

                  IAP_CTRL_CAN_SendCmdWriteFlashResult PROC
;;;1523   // IAP数据写入结果上报
;;;1524   void IAP_CTRL_CAN_SendCmdWriteFlashResult(uint8 param)
000000  b510              PUSH     {r4,lr}
;;;1525   {
000002  4604              MOV      r4,r0
;;;1526       IAP_CTRL_CAN_TxAddData(CAN_CMD_HEAD);
000004  2055              MOVS     r0,#0x55
000006  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1527       IAP_CTRL_CAN_TxAddData(IAP_CTRL_CAN_CMD_UP_IAP_WRITE_FLASH_RESULT);
00000a  2027              MOVS     r0,#0x27
00000c  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1528       IAP_CTRL_CAN_TxAddData(1); // 数据长度
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1529       IAP_CTRL_CAN_TxAddData(param);
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
;;;1530       IAP_CTRL_CAN_TxAddFrame();
00001c  e8bd4010          POP      {r4,lr}
000020  f7ffbffe          B.W      IAP_CTRL_CAN_TxAddFrame
;;;1531   }
;;;1532   
                          ENDP


                          AREA ||i.IAP_CTRL_CAN_SendUpDataPacket||, CODE, READONLY, ALIGN=2

                  IAP_CTRL_CAN_SendUpDataPacket PROC
;;;1443   // 发送升级数据
;;;1444   void IAP_CTRL_CAN_SendUpDataPacket(DUT_FILE_TYPE upDataType, CAN_CMD cmd, uint32 flashAddr, uint32 addr)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1445   {
000004  460f              MOV      r7,r1
;;;1446       uint8 i = 0;
000006  2400              MOVS     r4,#0
;;;1447       switch (upDataType)
000008  2600              MOVS     r6,#0
;;;1448       {
;;;1449       case DUT_FILE_TYPE_HEX:                          // hex
;;;1450           dut_info.reconnectionRepeatContent[0] = 121; // 总长度
;;;1451           dut_info.reconnectionRepeatContent[1] = CAN_CMD_HEAD;
;;;1452           dut_info.reconnectionRepeatContent[2] = cmd;
;;;1453           dut_info.reconnectionRepeatContent[3] = 0;                                            // 数据长度
;;;1454           dut_info.reconnectionRepeatContent[4] = 0;                                            // 添加是否加密
;;;1455           dut_info.reconnectionRepeatContent[5] = 0;                                            // 添加密钥
;;;1456           SPI_FLASH_ReadArray(&dut_info.reconnectionRepeatContent[6], flashAddr + (addr), 116); // 工具读取 4+112 个字节
00000a  18d1              ADDS     r1,r2,r3
00000c  4d20              LDR      r5,|L28.144|
00000e  f04f0c55          MOV      r12,#0x55             ;1451
000012  2801              CMP      r0,#1                 ;1447
000014  d01a              BEQ      |L28.76|
000016  2804              CMP      r0,#4                 ;1447
000018  d135              BNE      |L28.134|
00001a  2079              MOVS     r0,#0x79              ;1450
00001c  f8050f73          STRB     r0,[r5,#0x73]!        ;1450
000020  f885c001          STRB     r12,[r5,#1]           ;1451
000024  70af              STRB     r7,[r5,#2]            ;1452
000026  70ee              STRB     r6,[r5,#3]            ;1453
000028  712e              STRB     r6,[r5,#4]            ;1454
00002a  716e              STRB     r6,[r5,#5]            ;1455
00002c  3d73              SUBS     r5,r5,#0x73           ;1455
00002e  4818              LDR      r0,|L28.144|
000030  2274              MOVS     r2,#0x74
000032  3079              ADDS     r0,r0,#0x79
000034  f7fffffe          BL       SPI_FLASH_ReadArray
                  |L28.56|
;;;1457           for (i = 0; i < 121; i++)                                                             // 添加数据
;;;1458           {
;;;1459               IAP_CTRL_CAN_TxAddData(dut_info.reconnectionRepeatContent[i + 1]);
000038  1928              ADDS     r0,r5,r4
00003a  f8900074          LDRB     r0,[r0,#0x74]
00003e  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
000042  1c64              ADDS     r4,r4,#1              ;1457
000044  b2e4              UXTB     r4,r4                 ;1457
000046  2c79              CMP      r4,#0x79              ;1457
000048  d3f6              BCC      |L28.56|
00004a  e01c              B        |L28.134|
                  |L28.76|
;;;1460           }
;;;1461           break;
;;;1462   
;;;1463       case DUT_FILE_TYPE_BIN:                          // bin
;;;1464           dut_info.reconnectionRepeatContent[0] = 135; // 总长度
00004c  2087              MOVS     r0,#0x87
00004e  f8050f73          STRB     r0,[r5,#0x73]!
;;;1465           dut_info.reconnectionRepeatContent[1] = CAN_CMD_HEAD;
000052  f885c001          STRB     r12,[r5,#1]
;;;1466           dut_info.reconnectionRepeatContent[2] = cmd;
000056  70af              STRB     r7,[r5,#2]
;;;1467           dut_info.reconnectionRepeatContent[3] = 0;                                            // 数据长度
000058  70ee              STRB     r6,[r5,#3]
;;;1468           dut_info.reconnectionRepeatContent[4] = ((addr) & 0xFF000000) >> 24;                  // 数据长度
00005a  0e18              LSRS     r0,r3,#24
00005c  7128              STRB     r0,[r5,#4]
;;;1469           dut_info.reconnectionRepeatContent[5] = ((addr) & 0x00FF0000) >> 16;                  // 数据长度
00005e  0c18              LSRS     r0,r3,#16
000060  7168              STRB     r0,[r5,#5]
;;;1470           dut_info.reconnectionRepeatContent[6] = ((addr) & 0x0000FF00) >> 8;                   // 数据长度
000062  0a18              LSRS     r0,r3,#8
000064  71a8              STRB     r0,[r5,#6]
;;;1471           dut_info.reconnectionRepeatContent[7] = ((addr) & 0x000000FF);                        // 数据长度
000066  71eb              STRB     r3,[r5,#7]
000068  3d73              SUBS     r5,r5,#0x73
;;;1472           SPI_FLASH_ReadArray(&dut_info.reconnectionRepeatContent[8], flashAddr + (addr), 128); // 工具读取128字节
00006a  4809              LDR      r0,|L28.144|
00006c  2280              MOVS     r2,#0x80
00006e  307b              ADDS     r0,r0,#0x7b
000070  f7fffffe          BL       SPI_FLASH_ReadArray
                  |L28.116|
;;;1473           for (i = 0; i < 135; i++)                                                             // 添加数据
;;;1474           {
;;;1475               IAP_CTRL_CAN_TxAddData(dut_info.reconnectionRepeatContent[i + 1]);
000074  1928              ADDS     r0,r5,r4
000076  f8900074          LDRB     r0,[r0,#0x74]
00007a  f7fffffe          BL       IAP_CTRL_CAN_TxAddData
00007e  1c64              ADDS     r4,r4,#1              ;1473
000080  b2e4              UXTB     r4,r4                 ;1473
000082  2c87              CMP      r4,#0x87              ;1473
000084  d3f6              BCC      |L28.116|
                  |L28.134|
;;;1476           }
;;;1477           break;
;;;1478       default:
;;;1479           break;
;;;1480       }
;;;1481   
;;;1482       IAP_CTRL_CAN_TxAddFrame(); // 调整帧格式,修改长度和添加校验
000086  e8bd41f0          POP      {r4-r8,lr}
00008a  f7ffbffe          B.W      IAP_CTRL_CAN_TxAddFrame
;;;1483   }
;;;1484   
                          ENDP

00008e  0000              DCW      0x0000
                  |L28.144|
                          DCD      dut_info

                          AREA ||i.IAP_CTRL_CAN_TxAddData||, CODE, READONLY, ALIGN=2

                  IAP_CTRL_CAN_TxAddData PROC
;;;160    // 向发送命令帧队列中添加数据
;;;161    void IAP_CTRL_CAN_TxAddData(uint8 data)
000000  b530              PUSH     {r4,r5,lr}
;;;162    {
;;;163        uint16 head = sysCanCB.tx.head;
000002  4910              LDR      r1,|L29.68|
000004  880c              LDRH     r4,[r1,#0]  ; sysCanCB
;;;164        uint16 end = sysCanCB.tx.end;
000006  884a              LDRH     r2,[r1,#2]  ; sysCanCB
;;;165        CAN_CMD_FRAME *pCmdFrame = &sysCanCB.tx.cmdQueue[sysCanCB.tx.end];
000008  8849              LDRH     r1,[r1,#2]  ; sysCanCB
00000a  eb010381          ADD      r3,r1,r1,LSL #2
00000e  eb031141          ADD      r1,r3,r1,LSL #5
000012  4b0d              LDR      r3,|L29.72|
000014  eb030181          ADD      r1,r3,r1,LSL #2
000018  f6014128          ADD      r1,r1,#0xc28
;;;166    
;;;167        // 发送缓冲区已满，不予接收
;;;168        if ((end + 1) % CAN_TX_QUEUE_SIZE == head)
00001c  1c52              ADDS     r2,r2,#1
00001e  230f              MOVS     r3,#0xf
000020  fbb2f5f3          UDIV     r5,r2,r3
000024  fb032215          MLS      r2,r3,r5,r2
000028  42a2              CMP      r2,r4
00002a  d009              BEQ      |L29.64|
;;;169        {
;;;170            return;
;;;171        }
;;;172    
;;;173        // 队尾命令帧已满，退出
;;;174        if (pCmdFrame->length >= CAN_CMD_FRAME_LENGTH_MAX)
00002c  f8b12090          LDRH     r2,[r1,#0x90]
000030  2a8c              CMP      r2,#0x8c
000032  d205              BCS      |L29.64|
;;;175        {
;;;176            return;
;;;177        }
;;;178    
;;;179        // 数据添加到帧末尾，并更新帧长度
;;;180        pCmdFrame->buff[pCmdFrame->length] = data;
000034  1d0b              ADDS     r3,r1,#4
000036  54d0              STRB     r0,[r2,r3]
;;;181        pCmdFrame->length++;
000038  f8310f90          LDRH     r0,[r1,#0x90]!
00003c  1c40              ADDS     r0,r0,#1
00003e  8008              STRH     r0,[r1,#0]
                  |L29.64|
;;;182    }
000040  bd30              POP      {r4,r5,pc}
;;;183    
                          ENDP

000042  0000              DCW      0x0000
                  |L29.68|
                          DCD      ||.bss||+0x14d4
                  |L29.72|
                          DCD      ||.bss||

                          AREA ||i.IAP_CTRL_CAN_TxAddFrame||, CODE, READONLY, ALIGN=2

                  IAP_CTRL_CAN_TxAddFrame PROC
;;;184    // 发送命令帧处理,自动扶正帧长度以及检验码
;;;185    void IAP_CTRL_CAN_TxAddFrame(void)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;186    {
;;;187        uint16 head = sysCanCB.tx.head;
000004  4c23              LDR      r4,|L30.148|
000006  f8b414d4          LDRH     r1,[r4,#0x4d4]  ; sysCanCB
;;;188        uint16 end = sysCanCB.tx.end;
00000a  f8b424d6          LDRH     r2,[r4,#0x4d6]  ; sysCanCB
;;;189        uint8 *buff = sysCanCB.tx.cmdQueue[end].buff;
00000e  f5a45780          SUB      r7,r4,#0x1000
000012  eb020082          ADD      r0,r2,r2,LSL #2
000016  eb001042          ADD      r0,r0,r2,LSL #5
00001a  eb070580          ADD      r5,r7,r0,LSL #2
00001e  f605402c          ADD      r0,r5,#0xc2c
;;;190        uint16 length = sysCanCB.tx.cmdQueue[end].length;
000022  f8b56cb8          LDRH     r6,[r5,#0xcb8]
;;;191        uint8 cmdHead = buff[CAN_CMD_HEAD_INDEX]; // 帧头
000026  7803              LDRB     r3,[r0,#0]
;;;192    
;;;193        // 发送缓冲区已满，不予接收
;;;194        if ((end + 1) % CAN_TX_QUEUE_SIZE == head)
000028  1c52              ADDS     r2,r2,#1
00002a  f04f080f          MOV      r8,#0xf
00002e  fbb2fcf8          UDIV     r12,r2,r8
000032  fb08221c          MLS      r2,r8,r12,r2
000036  428a              CMP      r2,r1
000038  d005              BEQ      |L30.70|
;;;195        {
;;;196            return;
;;;197        }
;;;198    
;;;199        // 命令头错误
;;;200        if (CAN_CMD_HEAD != cmdHead)
00003a  f04f0900          MOV      r9,#0
00003e  2b55              CMP      r3,#0x55
000040  d003              BEQ      |L30.74|
;;;201        {
;;;202            // 把帧数据索引放在最开始位置
;;;203            sysCanCB.tx.cmdQueue[end].length = 0;
000042  f8a59cb8          STRH     r9,[r5,#0xcb8]
                  |L30.70|
;;;204            return;
;;;205        }
;;;206    
;;;207        // 命令头正确，但数据长度不对(数据长度减去CRC的长度)
;;;208        if ((CAN_CMD_FRAME_LENGTH_MAX - CAN_CHECK_BYTE_SIZE < length) || (CAN_CMD_FRAME_LENGTH_MIN - CAN_CHECK_BYTE_SIZE > length))
;;;209        {
;;;210            // 把帧数据索引放在最开始位置
;;;211            sysCanCB.tx.cmdQueue[end].length = 0;
;;;212            buff[CAN_CMD_HEAD_INDEX] = CAN_CMD_NONHEAD; // 避免数据没更新时，再次进入
;;;213            return;
;;;214        }
;;;215    
;;;216        // 执行到此，命令头正确，数据长度正确,发送缓冲区未满
;;;217        // 长度扶正
;;;218        buff[CAN_CMD_LENGTH_INDEX] = length - CAN_CMD_FRAME_LENGTH_MIN + CAN_CHECK_BYTE_SIZE;
;;;219    
;;;220        // 填充CRC校验码
;;;221        CAN_AddSum(buff, length);
;;;222    
;;;223        // 将数据长度填到待发送缓冲器
;;;224        sysCanCB.tx.cmdQueue[end].length = length + CAN_CHECK_BYTE_SIZE;
;;;225    
;;;226        // 发送环形队列更新位置
;;;227        sysCanCB.tx.end++;
;;;228        sysCanCB.tx.end %= CAN_TX_QUEUE_SIZE;
;;;229        sysCanCB.tx.cmdQueue[sysCanCB.tx.end].length = 0; // 2015.12.2修改
;;;230    }
000046  e8bd83f0          POP      {r4-r9,pc}
                  |L30.74|
00004a  1ef1              SUBS     r1,r6,#3              ;208
00004c  2989              CMP      r1,#0x89              ;208
00004e  d304              BCC      |L30.90|
000050  f8a59cb8          STRH     r9,[r5,#0xcb8]        ;211
000054  21ff              MOVS     r1,#0xff              ;212
000056  7001              STRB     r1,[r0,#0]            ;212
000058  e7f5              B        |L30.70|
                  |L30.90|
00005a  7081              STRB     r1,[r0,#2]            ;218
00005c  4631              MOV      r1,r6                 ;221
00005e  f7fffffe          BL       CAN_AddSum
000062  1c76              ADDS     r6,r6,#1              ;224
000064  f8a56cb8          STRH     r6,[r5,#0xcb8]        ;224
000068  f20444d6          ADD      r4,r4,#0x4d6          ;227
00006c  8820              LDRH     r0,[r4,#0]            ;227  ; sysCanCB
00006e  1c40              ADDS     r0,r0,#1              ;227
000070  8020              STRH     r0,[r4,#0]            ;227
000072  8820              LDRH     r0,[r4,#0]            ;228  ; sysCanCB
000074  fbb0f1f8          UDIV     r1,r0,r8              ;228
000078  fb080011          MLS      r0,r8,r1,r0           ;228
00007c  8020              STRH     r0,[r4,#0]            ;228
00007e  8820              LDRH     r0,[r4,#0]            ;229  ; sysCanCB
000080  eb000180          ADD      r1,r0,r0,LSL #2       ;229
000084  eb011040          ADD      r0,r1,r0,LSL #5       ;229
000088  eb070080          ADD      r0,r7,r0,LSL #2       ;229
00008c  f8a09cb8          STRH     r9,[r0,#0xcb8]        ;229
000090  e7d9              B        |L30.70|
;;;231    
                          ENDP

000092  0000              DCW      0x0000
                  |L30.148|
                          DCD      ||.bss||+0x1000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  sysCanCB
                          %        5340

                          AREA ||.data||, DATA, ALIGN=0

                  canTxStateCB
                          DCDU     0x00000000
000004  000000            DCB      0x00,0x00,0x00

;*** Start embedded assembler ***

#line 1 "User\\CanProtocolUpDT.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___17_CanProtocolUpDT_c_CAN_TEST____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___17_CanProtocolUpDT_c_CAN_TEST____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___17_CanProtocolUpDT_c_CAN_TEST____REVSH|
#line 128
|__asm___17_CanProtocolUpDT_c_CAN_TEST____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
