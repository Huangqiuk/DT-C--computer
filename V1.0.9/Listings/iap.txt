; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\iap.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\iap.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -I.\User\qrencode -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.3\Device\Include -D__MICROLIB -D__UVISION_VERSION=539 -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\iap.crf User\iap.c]
                          THUMB

                          AREA ||i.IAP_BleWriteAppBin||, CODE, READONLY, ALIGN=2

                  IAP_BleWriteAppBin PROC
;;;174    *******************************************************************************/
;;;175    BOOL IAP_BleWriteAppBin(uint32 appAddr, uint8 *appBuf, uint32 appSize)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;176    {
000004  460c              MOV      r4,r1
000006  4690              MOV      r8,r2
;;;177    	uint16 i = 0;
000008  2500              MOVS     r5,#0
;;;178    	uint16 j = 0;
00000a  2600              MOVS     r6,#0
;;;179    	uint32 curAppAddr = appAddr; 	// 当前写入的地址
00000c  4681              MOV      r9,r0
;;;180    	uint32 *iapBuf = NULL;
;;;181    	BOOL writeStatus;
;;;182    	
;;;183    	// 参数判断
;;;184    	if (NULL == appBuf)
00000e  2c00              CMP      r4,#0
000010  d009              BEQ      |L1.38|
;;;185    	{
;;;186    		return FALSE;
;;;187    	}
;;;188    
;;;189    	// 参数检验是否非法，地址不能是IAP本身代码地址，绝对不能自己把自己擦掉
;;;190    	if ((appAddr < IAP_FLASH_APP1_ADDR) || ((appAddr + appSize) > (IAP_GD32_FLASH_BASE+IAP_GD32_FLASH_SIZE)))
000012  491a              LDR      r1,|L1.124|
000014  4288              CMP      r0,r1
000016  d303              BCC      |L1.32|
000018  4919              LDR      r1,|L1.128|
00001a  4440              ADD      r0,r0,r8
00001c  4288              CMP      r0,r1
00001e  d904              BLS      |L1.42|
                  |L1.32|
;;;191    	{
;;;192    		return FALSE;		// 非法地址
000020  2000              MOVS     r0,#0
                  |L1.34|
;;;193    	}
;;;194    
;;;195    	// 开辟临时内存
;;;196    	iapBuf = (uint32 *)malloc(1024);
;;;197    	if (NULL == iapBuf)
;;;198    	{
;;;199    		return FALSE;
;;;200    	}
;;;201    	
;;;202    	// 循环写入
;;;203    	for (i = 0, j = 0; j < appSize; j += 4)
;;;204    	{
;;;205    		// 字节整合
;;;206    		iapBuf[i++] = (uint32)(*appBuf) + ((uint32)(*(appBuf+1)) << 8) + ((uint32)(*(appBuf+2)) << 16) + ((uint32)(*(appBuf+3)) << 24);
;;;207    		// 偏移4个字节
;;;208    		appBuf += 4;
;;;209    	}      
;;;210    	
;;;211    	// 直接写入FLASH
;;;212    	writeStatus = IAP_FlashWriteWordArray(curAppAddr, iapBuf, appSize/4);	
;;;213    	
;;;214    	// 释放内存
;;;215    	free(iapBuf);
;;;216    	
;;;217    	return writeStatus;
;;;218    }
000022  e8bd87f0          POP      {r4-r10,pc}
                  |L1.38|
000026  2000              MOVS     r0,#0                 ;186
000028  e7fb              B        |L1.34|
                  |L1.42|
00002a  f44f6080          MOV      r0,#0x400             ;196
00002e  f7fffffe          BL       malloc
000032  4607              MOV      r7,r0                 ;196
000034  0038              MOVS     r0,r7                 ;197
000036  d112              BNE      |L1.94|
000038  e7f3              B        |L1.34|
                  |L1.58|
00003a  7820              LDRB     r0,[r4,#0]            ;206
00003c  7861              LDRB     r1,[r4,#1]            ;206
00003e  78e2              LDRB     r2,[r4,#3]            ;206
000040  eb002001          ADD      r0,r0,r1,LSL #8       ;206
000044  78a1              LDRB     r1,[r4,#2]            ;206
000046  0409              LSLS     r1,r1,#16             ;206
000048  eb016102          ADD      r1,r1,r2,LSL #24      ;206
00004c  4401              ADD      r1,r1,r0              ;206
00004e  4628              MOV      r0,r5                 ;206
000050  1c6d              ADDS     r5,r5,#1              ;206
000052  b2ad              UXTH     r5,r5                 ;206
000054  f8471020          STR      r1,[r7,r0,LSL #2]     ;206
000058  1d24              ADDS     r4,r4,#4              ;208
00005a  1d36              ADDS     r6,r6,#4              ;203
00005c  b2b6              UXTH     r6,r6                 ;203
                  |L1.94|
00005e  4546              CMP      r6,r8                 ;203
000060  d3eb              BCC      |L1.58|
000062  f3c8028f          UBFX     r2,r8,#2,#16          ;212
000066  4639              MOV      r1,r7                 ;212
000068  4648              MOV      r0,r9                 ;212
00006a  f7fffffe          BL       IAP_FlashWriteWordArray
00006e  4604              MOV      r4,r0                 ;212
000070  4638              MOV      r0,r7                 ;215
000072  f7fffffe          BL       free
000076  4620              MOV      r0,r4                 ;217
000078  e7d3              B        |L1.34|
;;;219    
                          ENDP

00007a  0000              DCW      0x0000
                  |L1.124|
                          DCD      0x08008000
                  |L1.128|
                          DCD      0x08040000

                          AREA ||i.IAP_CheckApp1FlashIsBlank||, CODE, READONLY, ALIGN=1

                  IAP_CheckApp1FlashIsBlank PROC
;;;254    // 查询Flash是否为空
;;;255    BOOL IAP_CheckApp1FlashIsBlank(void)
000000  b570              PUSH     {r4-r6,lr}
;;;256    {
;;;257    	uint16 i;
;;;258    	uint16 j;
;;;259    	uint16 readHalfWord;
;;;260    	uint32 readAddr;
;;;261    	
;;;262    	for (i = (IAP_FLASH_ADRESS_APP1_OFFSET/IAP_STM32_PAGE_SIZE); i < ((IAP_FLASH_ADRESS_APP1_OFFSET + IAP_GD32_APP1_SIZE)/IAP_STM32_PAGE_SIZE); i++)
000002  2210              MOVS     r2,#0x10
;;;263    	{
;;;264    		// 页地址
;;;265    		readAddr = i*IAP_STM32_PAGE_SIZE + IAP_GD32_FLASH_BASE;
000004  05d6              LSLS     r6,r2,#23
;;;266    
;;;267    		for (j = 0; j < IAP_STM32_PAGE_SIZE; j += 2)
;;;268    		{
;;;269    			readHalfWord = IAP_FlashReadHalfWord(readAddr);	// 读
;;;270    		  	readAddr += 2;
;;;271    
;;;272    			// 全为0xFFFF说明为空
;;;273    			if (readHalfWord == 0xFFFF)
000006  f64f74ff          MOV      r4,#0xffff
00000a  01d5              LSLS     r5,r2,#7              ;267
                  |L2.12|
00000c  eb0623c2          ADD      r3,r6,r2,LSL #11      ;265
000010  2100              MOVS     r1,#0                 ;267
                  |L2.18|
000012  4618              MOV      r0,r3                 ;269
000014  f7fffffe          BL       IAP_FlashReadHalfWord
000018  1c9b              ADDS     r3,r3,#2              ;270
00001a  42a0              CMP      r0,r4
00001c  d109              BNE      |L2.50|
00001e  1c89              ADDS     r1,r1,#2              ;267
000020  b289              UXTH     r1,r1                 ;267
000022  42a9              CMP      r1,r5                 ;267
;;;274    			{
;;;275    				continue;
000024  d3f5              BCC      |L2.18|
000026  1c52              ADDS     r2,r2,#1              ;262
000028  b292              UXTH     r2,r2                 ;262
00002a  2a80              CMP      r2,#0x80              ;262
00002c  d3ee              BCC      |L2.12|
;;;276    			}
;;;277    			else
;;;278    			{
;;;279    				return FALSE;
;;;280    			}
;;;281    		}  
;;;282    		
;;;283    	}
;;;284    
;;;285    	return TRUE;
00002e  2001              MOVS     r0,#1
;;;286    }
000030  bd70              POP      {r4-r6,pc}
                  |L2.50|
000032  2000              MOVS     r0,#0                 ;279
000034  bd70              POP      {r4-r6,pc}
;;;287    
                          ENDP


                          AREA ||i.IAP_CheckApp2FlashIsBlank||, CODE, READONLY, ALIGN=1

                  IAP_CheckApp2FlashIsBlank PROC
;;;288    // 查询Flash是否为空
;;;289    BOOL IAP_CheckApp2FlashIsBlank(void)
000000  b570              PUSH     {r4-r6,lr}
;;;290    {
;;;291    	uint16 i;
;;;292    	uint16 j;
;;;293    	uint16 readHalfWord;
;;;294    	uint32 readAddr;
;;;295    	
;;;296    	for (i = (IAP_FLASH_ADRESS_APP2_OFFSET/IAP_STM32_PAGE_SIZE); i < ((IAP_FLASH_ADRESS_APP2_OFFSET + IAP_GD32_APP2_SIZE)/IAP_STM32_PAGE_SIZE); i++)
000002  2220              MOVS     r2,#0x20
;;;297    	{
;;;298    		// 页地址
;;;299    		readAddr = i*IAP_STM32_PAGE_SIZE + IAP_GD32_FLASH_BASE;
000004  0596              LSLS     r6,r2,#22
;;;300    
;;;301    		for (j = 0; j < IAP_STM32_PAGE_SIZE; j += 2)
;;;302    		{
;;;303    			readHalfWord = IAP_FlashReadHalfWord(readAddr);	// 读
;;;304    		  	readAddr += 2;
;;;305    
;;;306    			// 全为0xFFFF说明为空
;;;307    			if (readHalfWord == 0xFFFF)
000006  f64f74ff          MOV      r4,#0xffff
00000a  0195              LSLS     r5,r2,#6              ;301
                  |L3.12|
00000c  eb0623c2          ADD      r3,r6,r2,LSL #11      ;299
000010  2100              MOVS     r1,#0                 ;301
                  |L3.18|
000012  4618              MOV      r0,r3                 ;303
000014  f7fffffe          BL       IAP_FlashReadHalfWord
000018  1c9b              ADDS     r3,r3,#2              ;304
00001a  42a0              CMP      r0,r4
00001c  d109              BNE      |L3.50|
00001e  1c89              ADDS     r1,r1,#2              ;301
000020  b289              UXTH     r1,r1                 ;301
000022  42a9              CMP      r1,r5                 ;301
;;;308    			{
;;;309    				continue;
000024  d3f5              BCC      |L3.18|
000026  1c52              ADDS     r2,r2,#1              ;296
000028  b292              UXTH     r2,r2                 ;296
00002a  2a80              CMP      r2,#0x80              ;296
00002c  d3ee              BCC      |L3.12|
;;;310    			}
;;;311    			else
;;;312    			{
;;;313    				return FALSE;
;;;314    			}
;;;315    		}
;;;316    		
;;;317    	}
;;;318    
;;;319    	return TRUE;
00002e  2001              MOVS     r0,#1
;;;320    }
000030  bd70              POP      {r4-r6,pc}
                  |L3.50|
000032  2000              MOVS     r0,#0                 ;313
000034  bd70              POP      {r4-r6,pc}
;;;321    
                          ENDP


                          AREA ||i.IAP_CheckAppRightful||, CODE, READONLY, ALIGN=2

                  IAP_CheckAppRightful PROC
;;;110    // 判断指定地址APP是否合法
;;;111    uint8 IAP_CheckAppRightful(uint32 addr)
000000  4a08              LDR      r2,|L4.36|
;;;112    {
;;;113    	// 检查栈顶地址是否合法.
;;;114    	if(((*(uint32*)addr) & 0x2FFE0000) != 0x20000000)	
000002  6801              LDR      r1,[r0,#0]
000004  4011              ANDS     r1,r1,r2
000006  f1b15f00          CMP      r1,#0x20000000
00000a  d001              BEQ      |L4.16|
;;;115    	{
;;;116    		return 0;
00000c  2000              MOVS     r0,#0
;;;117    	}
;;;118    
;;;119    	// APP无效
;;;120    	if (((*(uint32*)(addr+4)) & 0xFFF80000) != 0x08000000)
;;;121    	{
;;;122    		return 0;
;;;123    	}
;;;124    
;;;125    	return 1;
;;;126    }
00000e  4770              BX       lr
                  |L4.16|
000010  6840              LDR      r0,[r0,#4]            ;120
000012  f44f7180          MOV      r1,#0x100             ;120
000016  ebb14fd0          CMP      r1,r0,LSR #19         ;120
00001a  d001              BEQ      |L4.32|
00001c  2000              MOVS     r0,#0                 ;122
00001e  4770              BX       lr
                  |L4.32|
000020  2001              MOVS     r0,#1                 ;125
000022  4770              BX       lr
;;;127    
                          ENDP

                  |L4.36|
                          DCD      0x2ffe0000

                          AREA ||i.IAP_CheckFlashIsBlank||, CODE, READONLY, ALIGN=1

                  IAP_CheckFlashIsBlank PROC
;;;221    // 查询Flash是否为空
;;;222    BOOL IAP_CheckFlashIsBlank(void)
000000  b570              PUSH     {r4-r6,lr}
;;;223    {
;;;224    	uint16 i;
;;;225    	uint16 j;
;;;226    	uint16 readHalfWord;
;;;227    	uint32 readAddr;
;;;228    	
;;;229    	for (i = (IAP_FLASH_ADRESS_APP1_OFFSET/IAP_STM32_PAGE_SIZE); i < (IAP_GD32_FLASH_SIZE/IAP_STM32_PAGE_SIZE); i++)
000002  2210              MOVS     r2,#0x10
;;;230    	{
;;;231    		// 页地址
;;;232    		readAddr = i*IAP_STM32_PAGE_SIZE + IAP_GD32_FLASH_BASE;
000004  05d6              LSLS     r6,r2,#23
;;;233    
;;;234    		for (j = 0; j < IAP_STM32_PAGE_SIZE; j += 2)
;;;235    		{
;;;236    			readHalfWord = IAP_FlashReadHalfWord(readAddr);	// 读
;;;237    		  	readAddr += 2;
;;;238    
;;;239    			// 全为0xFFFF说明为空
;;;240    			if (readHalfWord == 0xFFFF)
000006  f64f74ff          MOV      r4,#0xffff
00000a  01d5              LSLS     r5,r2,#7              ;234
                  |L5.12|
00000c  eb0623c2          ADD      r3,r6,r2,LSL #11      ;232
000010  2100              MOVS     r1,#0                 ;234
                  |L5.18|
000012  4618              MOV      r0,r3                 ;236
000014  f7fffffe          BL       IAP_FlashReadHalfWord
000018  1c9b              ADDS     r3,r3,#2              ;237
00001a  42a0              CMP      r0,r4
00001c  d109              BNE      |L5.50|
00001e  1c89              ADDS     r1,r1,#2              ;234
000020  b289              UXTH     r1,r1                 ;234
000022  42a9              CMP      r1,r5                 ;234
;;;241    			{
;;;242    				continue;
000024  d3f5              BCC      |L5.18|
000026  1c52              ADDS     r2,r2,#1              ;229
000028  b292              UXTH     r2,r2                 ;229
00002a  2a80              CMP      r2,#0x80              ;229
00002c  d3ee              BCC      |L5.12|
;;;243    			}
;;;244    			else
;;;245    			{
;;;246    				return FALSE;
;;;247    			}
;;;248    		}  
;;;249    		
;;;250    	}
;;;251    	return TRUE;
00002e  2001              MOVS     r0,#1
;;;252    }
000030  bd70              POP      {r4-r6,pc}
                  |L5.50|
000032  2000              MOVS     r0,#0                 ;246
000034  bd70              POP      {r4-r6,pc}
;;;253    
                          ENDP


                          AREA ||i.IAP_EraseAPP1Area||, CODE, READONLY, ALIGN=1

                  IAP_EraseAPP1Area PROC
;;;361    // 擦除APP1所有页
;;;362    BOOL IAP_EraseAPP1Area(void)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;363    {
;;;364    	uint16 i;
;;;365    	fmc_state_enum status = FMC_READY;
;;;366    	BOOL eraseStatus = TRUE;
000004  2501              MOVS     r5,#1
;;;367    
;;;368    	DI();				// 关闭总中断
000006  b672              CPSID    i
;;;369    	fmc_unlock();		// 解锁
000008  f7fffffe          BL       fmc_unlock
;;;370    
;;;371    	// 清除所有挂起标志位
;;;372        fmc_flag_clear(FMC_FLAG_BANK0_END);
00000c  f2403705          MOV      r7,#0x305
000010  4638              MOV      r0,r7
000012  f7fffffe          BL       fmc_flag_clear
;;;373        fmc_flag_clear(FMC_FLAG_BANK0_WPERR);
000016  f44f7841          MOV      r8,#0x304
00001a  4640              MOV      r0,r8
00001c  f7fffffe          BL       fmc_flag_clear
;;;374        fmc_flag_clear(FMC_FLAG_BANK0_PGERR);
000020  f2403902          MOV      r9,#0x302
000024  4648              MOV      r0,r9
000026  f7fffffe          BL       fmc_flag_clear
;;;375    	
;;;376    	// 擦除APP所有页
;;;377    	for (i = (IAP_FLASH_ADRESS_APP1_OFFSET/IAP_STM32_PAGE_SIZE); i < ((IAP_FLASH_ADRESS_APP1_OFFSET + IAP_GD32_APP1_SIZE)/IAP_STM32_PAGE_SIZE); i++)
00002a  2410              MOVS     r4,#0x10
;;;378    	{
;;;379    		status = fmc_page_erase(i*IAP_STM32_PAGE_SIZE + IAP_GD32_FLASH_BASE);
00002c  05e6              LSLS     r6,r4,#23
                  |L6.46|
00002e  eb0620c4          ADD      r0,r6,r4,LSL #11
000032  f7fffffe          BL       fmc_page_erase
000036  4682              MOV      r10,r0
;;;380    
;;;381    		fmc_flag_clear(FMC_FLAG_BANK0_END);
000038  4638              MOV      r0,r7
00003a  f7fffffe          BL       fmc_flag_clear
;;;382            fmc_flag_clear(FMC_FLAG_BANK0_WPERR);
00003e  4640              MOV      r0,r8
000040  f7fffffe          BL       fmc_flag_clear
;;;383            fmc_flag_clear(FMC_FLAG_BANK0_PGERR);
000044  4648              MOV      r0,r9
000046  f7fffffe          BL       fmc_flag_clear
;;;384    		
;;;385    		if (FMC_READY != status)
00004a  f1ba0f00          CMP      r10,#0
00004e  d001              BEQ      |L6.84|
;;;386    		{
;;;387    			eraseStatus = FALSE;
000050  2500              MOVS     r5,#0
;;;388    
;;;389    			break;
000052  e003              B        |L6.92|
                  |L6.84|
000054  1c64              ADDS     r4,r4,#1              ;377
000056  b2a4              UXTH     r4,r4                 ;377
000058  2c80              CMP      r4,#0x80              ;377
00005a  d3e8              BCC      |L6.46|
                  |L6.92|
;;;390    		}
;;;391    	}
;;;392    
;;;393    	fmc_lock();			// 上锁
00005c  f7fffffe          BL       fmc_lock
;;;394    	EI(); 				// 开启总中断
000060  b662              CPSIE    i
;;;395    
;;;396    	return eraseStatus;
000062  4628              MOV      r0,r5
;;;397    }
000064  e8bd87f0          POP      {r4-r10,pc}
;;;398    
                          ENDP


                          AREA ||i.IAP_EraseAPP2Area||, CODE, READONLY, ALIGN=1

                  IAP_EraseAPP2Area PROC
;;;399    // 擦除APP2所有页
;;;400    BOOL IAP_EraseAPP2Area(void)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;401    {
;;;402    	uint16 i;
;;;403    	fmc_state_enum status = FMC_READY;
;;;404    	BOOL eraseStatus = TRUE;
000004  2501              MOVS     r5,#1
;;;405    
;;;406    	DI();				// 关闭总中断
000006  b672              CPSID    i
;;;407    	fmc_unlock();		// 解锁
000008  f7fffffe          BL       fmc_unlock
;;;408    
;;;409    	// 清除所有挂起标志位
;;;410        fmc_flag_clear(FMC_FLAG_BANK0_END);
00000c  f2403705          MOV      r7,#0x305
000010  4638              MOV      r0,r7
000012  f7fffffe          BL       fmc_flag_clear
;;;411        fmc_flag_clear(FMC_FLAG_BANK0_WPERR);
000016  f44f7841          MOV      r8,#0x304
00001a  4640              MOV      r0,r8
00001c  f7fffffe          BL       fmc_flag_clear
;;;412        fmc_flag_clear(FMC_FLAG_BANK0_PGERR);
000020  f2403902          MOV      r9,#0x302
000024  4648              MOV      r0,r9
000026  f7fffffe          BL       fmc_flag_clear
;;;413    	
;;;414    	// 擦除APP所有页
;;;415    	for (i = (IAP_FLASH_ADRESS_APP2_OFFSET/IAP_STM32_PAGE_SIZE); i < ((IAP_FLASH_ADRESS_APP2_OFFSET + IAP_GD32_APP2_SIZE)/IAP_STM32_PAGE_SIZE); i++)
00002a  2420              MOVS     r4,#0x20
;;;416    	{
;;;417    		status = fmc_page_erase(i*IAP_STM32_PAGE_SIZE + IAP_GD32_FLASH_BASE);
00002c  05a6              LSLS     r6,r4,#22
                  |L7.46|
00002e  eb0620c4          ADD      r0,r6,r4,LSL #11
000032  f7fffffe          BL       fmc_page_erase
000036  4682              MOV      r10,r0
;;;418    
;;;419    		fmc_flag_clear(FMC_FLAG_BANK0_END);
000038  4638              MOV      r0,r7
00003a  f7fffffe          BL       fmc_flag_clear
;;;420            fmc_flag_clear(FMC_FLAG_BANK0_WPERR);
00003e  4640              MOV      r0,r8
000040  f7fffffe          BL       fmc_flag_clear
;;;421            fmc_flag_clear(FMC_FLAG_BANK0_PGERR);
000044  4648              MOV      r0,r9
000046  f7fffffe          BL       fmc_flag_clear
;;;422    
;;;423    		if (FMC_READY != status)
00004a  f1ba0f00          CMP      r10,#0
00004e  d001              BEQ      |L7.84|
;;;424    		{
;;;425    			eraseStatus = FALSE;
000050  2500              MOVS     r5,#0
;;;426    
;;;427    			break;
000052  e003              B        |L7.92|
                  |L7.84|
000054  1c64              ADDS     r4,r4,#1              ;415
000056  b2a4              UXTH     r4,r4                 ;415
000058  2c80              CMP      r4,#0x80              ;415
00005a  d3e8              BCC      |L7.46|
                  |L7.92|
;;;428    		}
;;;429    	}
;;;430    
;;;431    	fmc_lock();			// 上锁
00005c  f7fffffe          BL       fmc_lock
;;;432    	EI(); 				// 开启总中断
000060  b662              CPSIE    i
;;;433    
;;;434    	return eraseStatus;
000062  4628              MOV      r0,r5
;;;435    }
000064  e8bd87f0          POP      {r4-r10,pc}
;;;436    
                          ENDP


                          AREA ||i.IAP_EraseAPPArea||, CODE, READONLY, ALIGN=1

                  IAP_EraseAPPArea PROC
;;;323    // 擦除APP所有页
;;;324    BOOL IAP_EraseAPPArea(void)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;325    {
;;;326    	uint16 i;
;;;327    	fmc_state_enum status = FMC_READY;
;;;328    	BOOL eraseStatus = TRUE;
000004  2501              MOVS     r5,#1
;;;329    
;;;330    	DI();				// 关闭总中断
000006  b672              CPSID    i
;;;331    	fmc_unlock();		// 解锁
000008  f7fffffe          BL       fmc_unlock
;;;332    
;;;333    	// 清除所有挂起标志位
;;;334        fmc_flag_clear(FMC_FLAG_BANK0_END);
00000c  f2403705          MOV      r7,#0x305
000010  4638              MOV      r0,r7
000012  f7fffffe          BL       fmc_flag_clear
;;;335        fmc_flag_clear(FMC_FLAG_BANK0_WPERR);
000016  f44f7841          MOV      r8,#0x304
00001a  4640              MOV      r0,r8
00001c  f7fffffe          BL       fmc_flag_clear
;;;336        fmc_flag_clear(FMC_FLAG_BANK0_PGERR);
000020  f2403902          MOV      r9,#0x302
000024  4648              MOV      r0,r9
000026  f7fffffe          BL       fmc_flag_clear
;;;337    	
;;;338    	// 擦除APP所有页
;;;339    	for (i = (IAP_FLASH_ADRESS_APP1_OFFSET/IAP_STM32_PAGE_SIZE); i < (IAP_GD32_FLASH_SIZE/IAP_STM32_PAGE_SIZE); i++)
00002a  2410              MOVS     r4,#0x10
;;;340    	{
;;;341    		status = fmc_page_erase(i*IAP_STM32_PAGE_SIZE + IAP_GD32_FLASH_BASE);
00002c  05e6              LSLS     r6,r4,#23
                  |L8.46|
00002e  eb0620c4          ADD      r0,r6,r4,LSL #11
000032  f7fffffe          BL       fmc_page_erase
000036  4682              MOV      r10,r0
;;;342    
;;;343    		fmc_flag_clear(FMC_FLAG_BANK0_END);
000038  4638              MOV      r0,r7
00003a  f7fffffe          BL       fmc_flag_clear
;;;344            fmc_flag_clear(FMC_FLAG_BANK0_WPERR);
00003e  4640              MOV      r0,r8
000040  f7fffffe          BL       fmc_flag_clear
;;;345            fmc_flag_clear(FMC_FLAG_BANK0_PGERR);
000044  4648              MOV      r0,r9
000046  f7fffffe          BL       fmc_flag_clear
;;;346    		
;;;347    		if (FMC_READY != status)
00004a  f1ba0f00          CMP      r10,#0
00004e  d001              BEQ      |L8.84|
;;;348    		{
;;;349    			eraseStatus = FALSE;
000050  2500              MOVS     r5,#0
;;;350    
;;;351    			break;
000052  e003              B        |L8.92|
                  |L8.84|
000054  1c64              ADDS     r4,r4,#1              ;339
000056  b2a4              UXTH     r4,r4                 ;339
000058  2c80              CMP      r4,#0x80              ;339
00005a  d3e8              BCC      |L8.46|
                  |L8.92|
;;;352    		}
;;;353    	}
;;;354    
;;;355    	fmc_lock();		// 上锁
00005c  f7fffffe          BL       fmc_lock
;;;356    	EI(); 				// 开启总中断
000060  b662              CPSIE    i
;;;357    
;;;358    	return eraseStatus;
000062  4628              MOV      r0,r5
;;;359    }
000064  e8bd87f0          POP      {r4-r10,pc}
;;;360    
                          ENDP


                          AREA ||i.IAP_FlashReadForCrc8||, CODE, READONLY, ALIGN=2

                  IAP_FlashReadForCrc8 PROC
;;;960    *******************************************************************************/
;;;961    uint8 IAP_FlashReadForCrc8(uint32 datalen)
000000  b5f8              PUSH     {r3-r7,lr}
;;;962    {
000002  4601              MOV      r1,r0
;;;963    	uint8 crc = 0;
000004  2000              MOVS     r0,#0
;;;964    	uint8 i,j;
;;;965    	uint8 buf[4] = {0};
000006  2200              MOVS     r2,#0
000008  9200              STR      r2,[sp,#0]
;;;966    	uint32 addrIndex = 0;
00000a  2300              MOVS     r3,#0
;;;967    	uint32 dataTemp;
;;;968    	uint32 len = datalen/4;
00000c  088c              LSRS     r4,r1,#2
00000e  e021              B        |L9.84|
                  |L9.16|
;;;969    
;;;970    	while (len--)
;;;971    	{
;;;972    		dataTemp = *(volatile uint32*)(addrIndex + IAP_FLASH_APP2_ADDR);
000010  4912              LDR      r1,|L9.92|
000012  5859              LDR      r1,[r3,r1]
;;;973    		addrIndex += 4;
000014  1d1b              ADDS     r3,r3,#4
;;;974    		// 小端模式
;;;975    		buf[3] = (uint8)(dataTemp >> 24);
000016  0e0a              LSRS     r2,r1,#24
000018  f88d2003          STRB     r2,[sp,#3]
;;;976    		buf[2] = (uint8)(dataTemp >> 16);
00001c  0c0a              LSRS     r2,r1,#16
00001e  f88d2002          STRB     r2,[sp,#2]
;;;977    		buf[1] = (uint8)(dataTemp >> 8);
000022  0a0a              LSRS     r2,r1,#8
000024  f88d2001          STRB     r2,[sp,#1]
;;;978    		buf[0] = (uint8)dataTemp;
000028  f88d1000          STRB     r1,[sp,#0]
;;;979    		
;;;980    		for(j = 0; j < 4; j++)
00002c  2200              MOVS     r2,#0
00002e  466e              MOV      r6,sp                 ;965
;;;981    		{
;;;982    			crc ^= buf[j];
;;;983    			
;;;984    			for (i = 0; i < 8; i++)
;;;985    			{
;;;986    				if (crc & 0x01)
;;;987    				{
;;;988    					crc = (crc >> 1) ^ 0x8C;
000030  258c              MOVS     r5,#0x8c
                  |L9.50|
000032  5cb1              LDRB     r1,[r6,r2]            ;982
000034  4048              EORS     r0,r0,r1              ;982
000036  2100              MOVS     r1,#0                 ;984
                  |L9.56|
000038  07c7              LSLS     r7,r0,#31             ;986
00003a  d002              BEQ      |L9.66|
00003c  ea850050          EOR      r0,r5,r0,LSR #1
000040  e000              B        |L9.68|
                  |L9.66|
;;;989    				}
;;;990    				else
;;;991    				{
;;;992    					crc >>= 1;
000042  0840              LSRS     r0,r0,#1
                  |L9.68|
000044  1c49              ADDS     r1,r1,#1              ;984
000046  b2c9              UXTB     r1,r1                 ;984
000048  2908              CMP      r1,#8                 ;984
00004a  d3f5              BCC      |L9.56|
00004c  1c52              ADDS     r2,r2,#1              ;980
00004e  b2d2              UXTB     r2,r2                 ;980
000050  2a04              CMP      r2,#4                 ;980
000052  d3ee              BCC      |L9.50|
                  |L9.84|
000054  1e64              SUBS     r4,r4,#1              ;970
000056  1c61              ADDS     r1,r4,#1              ;970
000058  d1da              BNE      |L9.16|
;;;993    				}
;;;994    			}
;;;995    		}
;;;996    	}
;;;997    	return crc;
;;;998    }
00005a  bdf8              POP      {r3-r7,pc}
;;;999    
                          ENDP

                  |L9.92|
                          DCD      0x08010000

                          AREA ||i.IAP_FlashReadHalfWord||, CODE, READONLY, ALIGN=1

                  IAP_FlashReadHalfWord PROC
;;;442    *******************************************************************************/
;;;443    uint16 IAP_FlashReadHalfWord(uint32 flashAddr)
000000  8800              LDRH     r0,[r0,#0]
;;;444    {
;;;445    	return *(volatile uint16*)flashAddr; 
;;;446    }
000002  4770              BX       lr
;;;447    
                          ENDP


                          AREA ||i.IAP_FlashReadHalfWordArray||, CODE, READONLY, ALIGN=1

                  IAP_FlashReadHalfWordArray PROC
;;;660    *******************************************************************************/
;;;661    void IAP_FlashReadHalfWordArray(uint32 readAddr, uint16 *pBuffer, uint16 numToRead)   	
000000  b510              PUSH     {r4,lr}
;;;662    {
000002  4604              MOV      r4,r0
;;;663    	uint16 i;
;;;664    
;;;665    	// 参数判断
;;;666    	if (NULL == pBuffer)
000004  2900              CMP      r1,#0
000006  d010              BEQ      |L11.42|
;;;667    	{
;;;668    		return;
;;;669    	}
;;;670    
;;;671    	// 参数检验是否非法
;;;672    	if ((readAddr < IAP_GD32_FLASH_BASE) || (readAddr >= (IAP_GD32_FLASH_BASE+IAP_GD32_FLASH_SIZE)))
000008  f1a46000          SUB      r0,r4,#0x8000000
00000c  f5b02f80          CMP      r0,#0x40000
000010  d20b              BCS      |L11.42|
;;;673    	{
;;;674    		return;	// 非法地址
;;;675    	}
;;;676    	
;;;677    	for (i = 0; i < numToRead; i++)
000012  2300              MOVS     r3,#0
000014  e007              B        |L11.38|
                  |L11.22|
;;;678    	{
;;;679    		pBuffer[i] = IAP_FlashReadHalfWord(readAddr);	// 读取2个字节.
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       IAP_FlashReadHalfWord
00001c  f8210013          STRH     r0,[r1,r3,LSL #1]
;;;680    		readAddr += 2; 									// 偏移2个字节.	
000020  1ca4              ADDS     r4,r4,#2
000022  1c5b              ADDS     r3,r3,#1              ;677
000024  b29b              UXTH     r3,r3                 ;677
                  |L11.38|
000026  4293              CMP      r3,r2                 ;677
000028  d3f5              BCC      |L11.22|
                  |L11.42|
;;;681    	}
;;;682    }
00002a  bd10              POP      {r4,pc}
;;;683    
                          ENDP


                          AREA ||i.IAP_FlashReadWord||, CODE, READONLY, ALIGN=1

                  IAP_FlashReadWord PROC
;;;809    *******************************************************************************/
;;;810    uint32 IAP_FlashReadWord(uint32 flashAddr)
000000  6800              LDR      r0,[r0,#0]
;;;811    {
;;;812    	return *(volatile uint32*)flashAddr; 
;;;813    }
000002  4770              BX       lr
;;;814    
                          ENDP


                          AREA ||i.IAP_FlashReadWordArray||, CODE, READONLY, ALIGN=2

                  IAP_FlashReadWordArray PROC
;;;780    *******************************************************************************/
;;;781    void IAP_FlashReadWordArray(uint32 readAddr, uint32 *pBuffer, uint16 numToRead)   	
000000  b510              PUSH     {r4,lr}
;;;782    {
000002  4604              MOV      r4,r0
;;;783    	uint16 i;
;;;784    
;;;785    	// 参数判断
;;;786    	if (NULL == pBuffer)
000004  2900              CMP      r1,#0
000006  d012              BEQ      |L13.46|
;;;787    	{
;;;788    		return;
;;;789    	}
;;;790    
;;;791    	// 参数检验是否非法
;;;792    	if ((readAddr < IAP_GD32_FLASH_BASE) || ((readAddr + numToRead) > (IAP_GD32_FLASH_BASE+IAP_GD32_FLASH_SIZE+1024UL)))
000008  f1b46f00          CMP      r4,#0x8000000
00000c  d30f              BCC      |L13.46|
00000e  4b08              LDR      r3,|L13.48|
000010  18a0              ADDS     r0,r4,r2
000012  4298              CMP      r0,r3
000014  d80b              BHI      |L13.46|
;;;793    	{
;;;794    		return;	// 非法地址
;;;795    	}
;;;796    	
;;;797    	for (i = 0; i < numToRead; i++)
000016  2300              MOVS     r3,#0
000018  e007              B        |L13.42|
                  |L13.26|
;;;798    	{
;;;799    		pBuffer[i] = IAP_FlashReadWord(readAddr);	// 读取4个字节.
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       IAP_FlashReadWord
000020  f8410023          STR      r0,[r1,r3,LSL #2]
;;;800    		readAddr += 4;								// 偏移4个字节.	
000024  1d24              ADDS     r4,r4,#4
000026  1c5b              ADDS     r3,r3,#1              ;797
000028  b29b              UXTH     r3,r3                 ;797
                  |L13.42|
00002a  4293              CMP      r3,r2                 ;797
00002c  d3f5              BCC      |L13.26|
                  |L13.46|
;;;801    	}
;;;802    }
00002e  bd10              POP      {r4,pc}
;;;803    
                          ENDP

                  |L13.48|
                          DCD      0x08040400

                          AREA ||i.IAP_FlashWriteHalfWordArray||, CODE, READONLY, ALIGN=1

                  IAP_FlashWriteHalfWordArray PROC
;;;500    *******************************************************************************/
;;;501    BOOL IAP_FlashWriteHalfWordArray(uint32 writeAddr, uint16 *pBuffer, uint16 numToWrite)	
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;502    {
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
;;;503    #if 0
;;;504    
;;;505    	uint32 secpos;	    // 扇区地址
;;;506    	uint16 secoff;	    // 扇区内偏移地址(16位字计算)
;;;507    	uint16 secremain;  	// 扇区内剩余地址(16位字计算)	   
;;;508     	uint16 i;    
;;;509    	uint32 offaddr;    	// 去掉0X08000000后的地址
;;;510    	BOOL writeStatus = FALSE;
;;;511    	FLASH_Status status = FLASH_COMPLETE;
;;;512    	static uint16 iapFlashBuf[IAP_STM32_PAGE_SIZE/2];	// 最多是2K字节
;;;513    
;;;514    	// 参数检验是否非法
;;;515    	if ((writeAddr < IAP_GD32_FLASH_BASE) || (writeAddr >= (IAP_GD32_FLASH_BASE+IAP_GD32_FLASH_SIZE)))
;;;516    	{
;;;517    		return FALSE;	// 非法地址
;;;518    	}
;;;519    	
;;;520    	DI();			// 关闭总中断
;;;521    	FLASH_Unlock();	// 解锁
;;;522    
;;;523    	// 清除所有挂起标志位
;;;524    	FLASH_ClearFlag(FLASH_FLAG_EOP | FLASH_FLAG_PGERR | FLASH_FLAG_WRPRTERR);
;;;525    	
;;;526    	offaddr = writeAddr-IAP_GD32_FLASH_BASE;			// 实际偏移地址.
;;;527    	secpos = offaddr/IAP_STM32_PAGE_SIZE;				// 扇区地址  0~127 for STM32F103RBT6
;;;528    	secoff = (offaddr%IAP_STM32_PAGE_SIZE)/2;			// 在扇区内的偏移(2个字节为基本单位.)
;;;529    	secremain = IAP_STM32_PAGE_SIZE/2 - secoff;			// 扇区剩余空间大小 
;;;530    
;;;531    	// 不大于该扇区范围
;;;532    	if (numToWrite <= secremain) 
;;;533    	{
;;;534    		secremain = numToWrite;
;;;535    	}
;;;536    	
;;;537    	while (1)
;;;538    	{
;;;539    		// 读出整个扇区的内容
;;;540    		IAP_FlashReadHalfWordArray((secpos*IAP_STM32_PAGE_SIZE+IAP_GD32_FLASH_BASE),
;;;541    									iapFlashBuf,
;;;542    									IAP_STM32_PAGE_SIZE/2);
;;;543    
;;;544    		// 校验数据
;;;545    		for (i = 0; i < secremain; i++)
;;;546    		{
;;;547    			if (iapFlashBuf[secoff + i] != 0xFFFF)
;;;548    			{
;;;549    				// 里面的数据不全是0xFFFF，说明需要擦除
;;;550    				break;
;;;551    			}
;;;552    		}
;;;553    
;;;554    		// 需要擦除
;;;555    		if (i < secremain)
;;;556    		{
;;;557    			// 擦除这个扇区
;;;558    			status = FLASH_ErasePage(secpos*IAP_STM32_PAGE_SIZE+IAP_STM32_FLASH_BASE);
;;;559    
;;;560    			if (FLASH_COMPLETE != status)
;;;561    			{
;;;562    				return FALSE;
;;;563    			}
;;;564    			
;;;565    			for (i = 0; i < secremain; i++) // 复制
;;;566    			{
;;;567    				iapFlashBuf[i + secoff] = pBuffer[i];	  
;;;568    			}
;;;569    
;;;570    			// 写入整个扇区
;;;571    			writeStatus = IAP_FlashWriteHalfWordArrayAndCheck((secpos*IAP_STM32_PAGE_SIZE+IAP_GD32_FLASH_BASE), 
;;;572    																iapFlashBuf, 
;;;573    																IAP_STM32_PAGE_SIZE/2);
;;;574    		}
;;;575    		// 不需要擦除
;;;576    		else
;;;577    		{
;;;578    			writeStatus = IAP_FlashWriteHalfWordArrayAndCheck(writeAddr,pBuffer,secremain); //写已经擦除了的,直接写入扇区剩余区间. 
;;;579    		}
;;;580    		
;;;581    		if (!writeStatus)
;;;582    		{
;;;583    			break;
;;;584    		}
;;;585    		
;;;586    		// 写入结束了
;;;587    		if (numToWrite == secremain)
;;;588    		{
;;;589    			break;
;;;590    		}
;;;591    		// 写入未结束
;;;592    		else 
;;;593    		{
;;;594    			secpos++;							// 扇区地址增1
;;;595    			secoff = 0;							// 偏移位置为0 	 
;;;596    		 	pBuffer += secremain;  	     		// 指针偏移
;;;597    			writeAddr += secremain;				// 写地址偏移	   
;;;598    		  	numToWrite -= secremain;			// 字节(16位)数递减
;;;599    
;;;600    		  	// 下一个扇区还是写不完
;;;601    			if (numToWrite > (IAP_STM32_PAGE_SIZE/2))
;;;602    			{
;;;603    				secremain = IAP_STM32_PAGE_SIZE/2;	
;;;604    			}
;;;605    			// 下一个扇区可以写完了
;;;606    			else 
;;;607    			{
;;;608    				secremain = numToWrite;
;;;609    			}
;;;610    		}	 
;;;611    	}
;;;612    	
;;;613    	FLASH_Lock();		// 上锁
;;;614    	EI(); 				// 开启总中断
;;;615    	
;;;616    	return writeStatus;
;;;617    
;;;618    #else
;;;619    	BOOL writeStatus = TRUE;
00000a  2401              MOVS     r4,#1
;;;620    	
;;;621    	// 参数判断
;;;622    	if (NULL == pBuffer)
00000c  2d00              CMP      r5,#0
00000e  d007              BEQ      |L14.32|
;;;623    	{
;;;624    		return FALSE;
;;;625    	}
;;;626    
;;;627    	// 参数检验是否非法
;;;628    	if ((writeAddr < IAP_GD32_FLASH_BASE) || (writeAddr >= (IAP_GD32_FLASH_BASE+IAP_GD32_FLASH_SIZE)))
000010  f1a66000          SUB      r0,r6,#0x8000000
000014  f5b02f80          CMP      r0,#0x40000
000018  d304              BCC      |L14.36|
;;;629    	{
;;;630    		return FALSE;	// 非法地址
00001a  2000              MOVS     r0,#0
                  |L14.28|
;;;631    	}
;;;632    	
;;;633    	DI();				// 关闭总中断
;;;634    	fmc_unlock();		// 解锁
;;;635    
;;;636    	// 清除所有挂起标志位
;;;637    	fmc_flag_clear(FMC_FLAG_BANK0_END);
;;;638        fmc_flag_clear(FMC_FLAG_BANK0_WPERR);
;;;639        fmc_flag_clear(FMC_FLAG_BANK0_PGERR);
;;;640    	
;;;641    	// 写入页
;;;642    	if (!IAP_FlashWriteHalfWordArrayAndCheck(writeAddr, pBuffer, numToWrite))	
;;;643    	{
;;;644    		writeStatus = FALSE;
;;;645    	}
;;;646    
;;;647    	fmc_lock();		// 上锁
;;;648    	EI(); 			// 开启总中断
;;;649    	
;;;650    	return writeStatus;
;;;651    
;;;652    #endif
;;;653    }
00001c  e8bd81f0          POP      {r4-r8,pc}
                  |L14.32|
000020  2000              MOVS     r0,#0                 ;624
000022  e7fb              B        |L14.28|
                  |L14.36|
000024  b672              CPSID    i                     ;633
000026  f7fffffe          BL       fmc_unlock
00002a  f2403005          MOV      r0,#0x305             ;637
00002e  f7fffffe          BL       fmc_flag_clear
000032  f44f7041          MOV      r0,#0x304             ;638
000036  f7fffffe          BL       fmc_flag_clear
00003a  f2403002          MOV      r0,#0x302             ;639
00003e  f7fffffe          BL       fmc_flag_clear
000042  463a              MOV      r2,r7                 ;642
000044  4629              MOV      r1,r5                 ;642
000046  4630              MOV      r0,r6                 ;642
000048  f7fffffe          BL       IAP_FlashWriteHalfWordArrayAndCheck
00004c  b900              CBNZ     r0,|L14.80|
00004e  2400              MOVS     r4,#0                 ;644
                  |L14.80|
000050  f7fffffe          BL       fmc_lock
000054  b662              CPSIE    i                     ;648
000056  4620              MOV      r0,r4                 ;650
000058  e7e0              B        |L14.28|
;;;654    
                          ENDP


                          AREA ||i.IAP_FlashWriteHalfWordArrayAndCheck||, CODE, READONLY, ALIGN=1

                  IAP_FlashWriteHalfWordArrayAndCheck PROC
;;;454    *******************************************************************************/
;;;455    BOOL IAP_FlashWriteHalfWordArrayAndCheck(uint32 writeAddr, uint16 *pBuffer, uint16 numToWrite)   
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;456    { 			 		 
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;457    	uint16 i;
;;;458    	uint16 readHalfWord;
;;;459    
;;;460    	// 参数判断
;;;461    	if (NULL == pBuffer)
00000a  2e00              CMP      r6,#0
00000c  d007              BEQ      |L15.30|
;;;462    	{
;;;463    		return FALSE;
;;;464    	}
;;;465    
;;;466    	// 参数检验是否非法
;;;467    	if ((writeAddr < IAP_GD32_FLASH_BASE) || (writeAddr >= (IAP_GD32_FLASH_BASE+IAP_GD32_FLASH_SIZE)))
00000e  f1a56000          SUB      r0,r5,#0x8000000
000012  f5b02f80          CMP      r0,#0x40000
000016  d304              BCC      |L15.34|
;;;468    	{
;;;469    		return FALSE;	// 非法地址
000018  2000              MOVS     r0,#0
                  |L15.26|
;;;470    	}
;;;471    	
;;;472    	for (i = 0; i < numToWrite; i++)
;;;473    	{
;;;474    		fmc_halfword_program(writeAddr, pBuffer[i]);		// 写
;;;475    		readHalfWord = IAP_FlashReadHalfWord(writeAddr);	// 读
;;;476    	  	writeAddr += 2;
;;;477    
;;;478    		fmc_flag_clear(FMC_FLAG_BANK0_END);
;;;479            fmc_flag_clear(FMC_FLAG_BANK0_WPERR);
;;;480            fmc_flag_clear(FMC_FLAG_BANK0_PGERR); 
;;;481    		
;;;482    	  	// 写入FLASH中的缓冲区数据与读取的数据是否匹配
;;;483    		if (readHalfWord == pBuffer[i])
;;;484    		{
;;;485    			continue;
;;;486    		}
;;;487    		else
;;;488    		{
;;;489    			return FALSE;
;;;490    		}
;;;491    	}  
;;;492    	return TRUE;
;;;493    } 
00001a  e8bd9ff0          POP      {r4-r12,pc}
                  |L15.30|
00001e  2000              MOVS     r0,#0                 ;463
000020  e7fb              B        |L15.26|
                  |L15.34|
000022  2400              MOVS     r4,#0                 ;472
000024  f2403805          MOV      r8,#0x305             ;478
000028  f44f7941          MOV      r9,#0x304             ;479
00002c  f2403a02          MOV      r10,#0x302            ;480
000030  e018              B        |L15.100|
                  |L15.50|
000032  f8361014          LDRH     r1,[r6,r4,LSL #1]     ;474
000036  4628              MOV      r0,r5                 ;474
000038  f7fffffe          BL       fmc_halfword_program
00003c  4628              MOV      r0,r5                 ;475
00003e  f7fffffe          BL       IAP_FlashReadHalfWord
000042  4683              MOV      r11,r0                ;475
000044  1cad              ADDS     r5,r5,#2              ;476
000046  4640              MOV      r0,r8                 ;478
000048  f7fffffe          BL       fmc_flag_clear
00004c  4648              MOV      r0,r9                 ;479
00004e  f7fffffe          BL       fmc_flag_clear
000052  4650              MOV      r0,r10                ;480
000054  f7fffffe          BL       fmc_flag_clear
000058  f8360014          LDRH     r0,[r6,r4,LSL #1]     ;483
00005c  4558              CMP      r0,r11                ;483
00005e  d105              BNE      |L15.108|
000060  1c64              ADDS     r4,r4,#1              ;472
000062  b2a4              UXTH     r4,r4                 ;472
                  |L15.100|
000064  42bc              CMP      r4,r7                 ;472
000066  d3e4              BCC      |L15.50|
000068  2001              MOVS     r0,#1                 ;492
00006a  e7d6              B        |L15.26|
                  |L15.108|
00006c  2000              MOVS     r0,#0                 ;489
00006e  e7d4              B        |L15.26|
;;;494    
                          ENDP


                          AREA ||i.IAP_FlashWriteWordArray||, CODE, READONLY, ALIGN=2

                  IAP_FlashWriteWordArray PROC
;;;690    *******************************************************************************/
;;;691    BOOL IAP_FlashWriteWordArray(uint32 writeAddr, uint32 *pBuffer, uint16 numToWrite)	
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;692    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;693    	BOOL writeStatus = TRUE;
00000a  2501              MOVS     r5,#1
;;;694    	
;;;695    	// 参数判断
;;;696    	if (NULL == pBuffer)
00000c  2e00              CMP      r6,#0
00000e  d009              BEQ      |L16.36|
;;;697    	{
;;;698    		return FALSE;
;;;699    	}
;;;700    
;;;701    	// 参数检验是否非法
;;;702    	if ((writeAddr < IAP_GD32_FLASH_BASE) || ((writeAddr + numToWrite) > (IAP_GD32_FLASH_BASE+IAP_GD32_FLASH_SIZE)))
000010  f1b46f00          CMP      r4,#0x8000000
000014  d303              BCC      |L16.30|
000016  4912              LDR      r1,|L16.96|
000018  19e0              ADDS     r0,r4,r7
00001a  4288              CMP      r0,r1
00001c  d904              BLS      |L16.40|
                  |L16.30|
;;;703    	{
;;;704    		return FALSE;	// 非法地址
00001e  2000              MOVS     r0,#0
                  |L16.32|
;;;705    	}
;;;706    	
;;;707    	DI();				// 关闭总中断
;;;708    	fmc_unlock();		// 解锁
;;;709    
;;;710    	// 清除所有挂起标志位
;;;711    	fmc_flag_clear(FMC_FLAG_BANK0_END);
;;;712        fmc_flag_clear(FMC_FLAG_BANK0_WPERR);
;;;713        fmc_flag_clear(FMC_FLAG_BANK0_PGERR);
;;;714    
;;;715    
;;;716    	// 写入页
;;;717    	if (!IAP_FlashWriteWordArrayAndCheck(writeAddr, pBuffer, numToWrite))	
;;;718    	{
;;;719    		writeStatus = FALSE;
;;;720    	}
;;;721    
;;;722    	fmc_lock();			// 上锁
;;;723    	EI(); 				// 开启总中断
;;;724    	
;;;725    	return writeStatus;
;;;726    }
000020  e8bd81f0          POP      {r4-r8,pc}
                  |L16.36|
000024  2000              MOVS     r0,#0                 ;698
000026  e7fb              B        |L16.32|
                  |L16.40|
000028  b672              CPSID    i                     ;707
00002a  f7fffffe          BL       fmc_unlock
00002e  f2403005          MOV      r0,#0x305             ;711
000032  f7fffffe          BL       fmc_flag_clear
000036  f44f7041          MOV      r0,#0x304             ;712
00003a  f7fffffe          BL       fmc_flag_clear
00003e  f2403002          MOV      r0,#0x302             ;713
000042  f7fffffe          BL       fmc_flag_clear
000046  463a              MOV      r2,r7                 ;717
000048  4631              MOV      r1,r6                 ;717
00004a  4620              MOV      r0,r4                 ;717
00004c  f7fffffe          BL       IAP_FlashWriteWordArrayAndCheck
000050  b900              CBNZ     r0,|L16.84|
000052  2500              MOVS     r5,#0                 ;719
                  |L16.84|
000054  f7fffffe          BL       fmc_lock
000058  b662              CPSIE    i                     ;723
00005a  4628              MOV      r0,r5                 ;725
00005c  e7e0              B        |L16.32|
;;;727    
                          ENDP

00005e  0000              DCW      0x0000
                  |L16.96|
                          DCD      0x08040000

                          AREA ||i.IAP_FlashWriteWordArrayAndCheck||, CODE, READONLY, ALIGN=2

                  IAP_FlashWriteWordArrayAndCheck PROC
;;;734    *******************************************************************************/
;;;735    BOOL IAP_FlashWriteWordArrayAndCheck(uint32 writeAddr, uint32 *pBuffer, uint16 numToWrite)   
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;736    { 			 		 
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;737    	uint16 i;
;;;738    	uint32 readWord;
;;;739    
;;;740    	// 参数判断
;;;741    	if (NULL == pBuffer)
00000a  2e00              CMP      r6,#0
00000c  d009              BEQ      |L17.34|
;;;742    	{
;;;743    		return FALSE;
;;;744    	}
;;;745    
;;;746    	// 参数检验是否非法
;;;747    	if ((writeAddr < IAP_GD32_FLASH_BASE) || ((writeAddr + numToWrite) > (IAP_GD32_FLASH_BASE+IAP_GD32_FLASH_SIZE+1024UL)))
00000e  f1b56f00          CMP      r5,#0x8000000
000012  d303              BCC      |L17.28|
000014  4917              LDR      r1,|L17.116|
000016  19e8              ADDS     r0,r5,r7
000018  4288              CMP      r0,r1
00001a  d904              BLS      |L17.38|
                  |L17.28|
;;;748    	{
;;;749    		return FALSE;	// 非法地址
00001c  2000              MOVS     r0,#0
                  |L17.30|
;;;750    	}
;;;751    	
;;;752    	for (i = 0; i < numToWrite; i++)
;;;753    	{
;;;754    		fmc_word_program(writeAddr, pBuffer[i]);		// 写
;;;755    		readWord = IAP_FlashReadWord(writeAddr);		// 读
;;;756    	  	writeAddr += 4;
;;;757    
;;;758    		fmc_flag_clear(FMC_FLAG_BANK0_END);
;;;759            fmc_flag_clear(FMC_FLAG_BANK0_WPERR);
;;;760            fmc_flag_clear(FMC_FLAG_BANK0_PGERR); 
;;;761    
;;;762    	  	// 写入FLASH中的缓冲区数据与读取的数据是否匹配
;;;763    		if (readWord == pBuffer[i])
;;;764    		{
;;;765    			continue;
;;;766    		}
;;;767    		else
;;;768    		{
;;;769    			return FALSE;
;;;770    		}
;;;771    	}  
;;;772    	return TRUE;
;;;773    } 
00001e  e8bd9ff0          POP      {r4-r12,pc}
                  |L17.34|
000022  2000              MOVS     r0,#0                 ;743
000024  e7fb              B        |L17.30|
                  |L17.38|
000026  2400              MOVS     r4,#0                 ;752
000028  f2403805          MOV      r8,#0x305             ;758
00002c  f44f7941          MOV      r9,#0x304             ;759
000030  f2403a02          MOV      r10,#0x302            ;760
000034  e018              B        |L17.104|
                  |L17.54|
000036  f8561024          LDR      r1,[r6,r4,LSL #2]     ;754
00003a  4628              MOV      r0,r5                 ;754
00003c  f7fffffe          BL       fmc_word_program
000040  4628              MOV      r0,r5                 ;755
000042  f7fffffe          BL       IAP_FlashReadWord
000046  4683              MOV      r11,r0                ;755
000048  1d2d              ADDS     r5,r5,#4              ;756
00004a  4640              MOV      r0,r8                 ;758
00004c  f7fffffe          BL       fmc_flag_clear
000050  4648              MOV      r0,r9                 ;759
000052  f7fffffe          BL       fmc_flag_clear
000056  4650              MOV      r0,r10                ;760
000058  f7fffffe          BL       fmc_flag_clear
00005c  f8560024          LDR      r0,[r6,r4,LSL #2]     ;763
000060  4558              CMP      r0,r11                ;763
000062  d105              BNE      |L17.112|
000064  1c64              ADDS     r4,r4,#1              ;752
000066  b2a4              UXTH     r4,r4                 ;752
                  |L17.104|
000068  42bc              CMP      r4,r7                 ;752
00006a  d3e4              BCC      |L17.54|
00006c  2001              MOVS     r0,#1                 ;772
00006e  e7d6              B        |L17.30|
                  |L17.112|
000070  2000              MOVS     r0,#0                 ;769
000072  e7d4              B        |L17.30|
;;;774    
                          ENDP

                  |L17.116|
                          DCD      0x08040400

                          AREA ||i.IAP_FlashWriteWordArrayWithErase||, CODE, READONLY, ALIGN=2

                  IAP_FlashWriteWordArrayWithErase PROC
;;;820    *******************************************************************************/
;;;821    BOOL IAP_FlashWriteWordArrayWithErase(uint32 writeAddr, uint32 *pBuffer, uint16 NumWordToWrite)	
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;822    {
000004  4682              MOV      r10,r0
000006  4689              MOV      r9,r1
;;;823    	BOOL writeStatus = TRUE;
000008  2001              MOVS     r0,#1
00000a  9000              STR      r0,[sp,#0]
;;;824    	uint32 pagePos = 0;						// 扇区地址
;;;825    	uint16 pageOffsent = 0;					// 在扇区内的偏移
;;;826    	uint16 pageRemain = 0;  				// 扇区剩余空间大小 
;;;827    	uint32 offaddr;    						// 去掉0X08000000后的地址
;;;828     	uint16 i = 0;
;;;829     	uint32 * pFlashBuff = NULL;				// 保存读取扇区的数据
;;;830     	uint16 numByteToWrite = NumWordToWrite * 4;
00000c  f64f70ff          MOV      r0,#0xffff
000010  ea000582          AND      r5,r0,r2,LSL #2
;;;831    	
;;;832    	// 参数判断
;;;833    	if (NULL == pBuffer|| (NULL == numByteToWrite))
000014  f1b90f00          CMP      r9,#0
000018  d00b              BEQ      |L18.50|
00001a  b155              CBZ      r5,|L18.50|
;;;834    	{
;;;835    		return FALSE;
;;;836    	}
;;;837    
;;;838    	// 参数检验是否非法
;;;839    	if ((writeAddr < IAP_GD32_FLASH_BASE) || ((writeAddr + numByteToWrite) > (IAP_GD32_FLASH_BASE+IAP_GD32_FLASH_SIZE + 1024UL)))
00001c  f1ba6f00          CMP      r10,#0x8000000
000020  d304              BCC      |L18.44|
000022  4947              LDR      r1,|L18.320|
000024  eb0a0005          ADD      r0,r10,r5
000028  4288              CMP      r0,r1
00002a  d904              BLS      |L18.54|
                  |L18.44|
;;;840    	{
;;;841    		return FALSE;	// 非法地址
00002c  2000              MOVS     r0,#0
                  |L18.46|
;;;842    	}
;;;843    
;;;844    	// 申请1024Byte空间保存页数据
;;;845    	pFlashBuff = (uint32 *)malloc(IAP_STM32_PAGE_SIZE);
;;;846    	if (NULL == pFlashBuff)
;;;847    	{
;;;848    		return FALSE;
;;;849    	}
;;;850    
;;;851    	offaddr = writeAddr - IAP_GD32_FLASH_BASE;		// 实际偏移地址
;;;852    	pagePos = offaddr / IAP_STM32_PAGE_SIZE;		// 页地址
;;;853    	pageOffsent = offaddr % IAP_STM32_PAGE_SIZE;	// 在页内偏移
;;;854    	pageRemain = IAP_STM32_PAGE_SIZE - pageOffsent;	// 页剩余空间大小
;;;855    
;;;856    	if (numByteToWrite <= pageRemain)
;;;857    	{
;;;858    		pageRemain = numByteToWrite;				// 不大于该页范围
;;;859    	}
;;;860    	
;;;861    	DI();				// 关闭总中断
;;;862    	fmc_unlock();		// 解锁
;;;863    
;;;864    	// 清除所有挂起标志位
;;;865    	fmc_flag_clear(FMC_FLAG_BANK0_END);
;;;866        fmc_flag_clear(FMC_FLAG_BANK0_WPERR);
;;;867        fmc_flag_clear(FMC_FLAG_BANK0_PGERR);
;;;868    
;;;869    	
;;;870    	while(1)
;;;871    	{
;;;872    		// 读出整个页的内容
;;;873    		IAP_FlashReadWordArray(pagePos*IAP_STM32_PAGE_SIZE+IAP_STM32_PAGE_SIZE, pFlashBuff, IAP_STM32_PAGE_SIZE/4);
;;;874    
;;;875    		for (i = 0; i < pageRemain/4; i++)	// 校验数据
;;;876    		{
;;;877    			if (pFlashBuff[pageOffsent/4 + i] != 0xFFFFFFFF)
;;;878    			{
;;;879    				// 里面的数据不全是0xFFFFFFFF，说明需要擦除
;;;880    				break;
;;;881    			}
;;;882    		}
;;;883    
;;;884    		if (i < pageRemain/4)					// 需要擦除
;;;885    		{
;;;886    			// 擦除这个页
;;;887    			//IAP_PageErase(pagePos * IAP_STM32_PAGE_SIZE + IAP_GD32_FLASH_BASE);
;;;888    			fmc_page_erase(pagePos * IAP_STM32_PAGE_SIZE + IAP_GD32_FLASH_BASE);
;;;889    
;;;890    			// 复制
;;;891    			for (i = 0; i < pageRemain/4; i++)
;;;892    			{
;;;893    				pFlashBuff[i + pageOffsent/4] = pBuffer[i]; 
;;;894    			}
;;;895    
;;;896    			// 写入整页
;;;897    			if (!IAP_FlashWriteWordArrayAndCheck(pagePos * IAP_STM32_PAGE_SIZE + IAP_GD32_FLASH_BASE, pFlashBuff, IAP_STM32_PAGE_SIZE/4))	
;;;898    			{
;;;899    				// 释放数据缓存区
;;;900    				free(pFlashBuff);
;;;901    
;;;902    				fmc_lock();			// 上锁
;;;903    				EI();				// 开启总中断
;;;904    				writeStatus = FALSE;
;;;905    				return writeStatus;
;;;906    			}
;;;907    		}
;;;908    		else 
;;;909    		{
;;;910    			// 写已经擦除了的,直接写入扇区剩余区间.
;;;911    			if (!IAP_FlashWriteWordArrayAndCheck(writeAddr, pBuffer, pageRemain/4))	
;;;912    			{
;;;913    				// 释放数据缓存区
;;;914    				free(pFlashBuff);
;;;915    
;;;916    				fmc_lock();			// 上锁
;;;917    				EI(); 				// 开启总中断
;;;918    				writeStatus = FALSE;
;;;919    				return writeStatus;
;;;920    			}
;;;921    		}
;;;922    		
;;;923    		if (numByteToWrite == pageRemain)
;;;924    		{
;;;925    			break;									// 写入结束了
;;;926    		}
;;;927    		else										// 写入未结束
;;;928    		{
;;;929    			pagePos++;								// 扇区地址增1
;;;930    			pageOffsent = 0;						// 偏移位置为0 	 
;;;931    
;;;932    		   	pBuffer += (pageRemain/4);  			// 指针偏移
;;;933    			writeAddr += pageRemain;				// 写地址偏移	   
;;;934    		   	numByteToWrite -= pageRemain;			// 字节数递减
;;;935    		   	
;;;936    			if (numByteToWrite > IAP_STM32_PAGE_SIZE)
;;;937    			{
;;;938    				pageRemain = IAP_STM32_PAGE_SIZE;	// 下一个扇区还是写不完
;;;939    			}
;;;940    			else
;;;941    			{
;;;942    				pageRemain = numByteToWrite;		// 下一个扇区可以写完了	
;;;943    			}
;;;944    		}	
;;;945    		
;;;946    	}
;;;947    
;;;948    	// 释放数据缓存区
;;;949    	free(pFlashBuff);	
;;;950    	fmc_lock();			// 上锁
;;;951    	EI(); 				// 开启总中断
;;;952    	return writeStatus;
;;;953    }
00002e  e8bd8ff8          POP      {r3-r11,pc}
                  |L18.50|
000032  2000              MOVS     r0,#0                 ;835
000034  e7fb              B        |L18.46|
                  |L18.54|
000036  f44f6000          MOV      r0,#0x800             ;845
00003a  f7fffffe          BL       malloc
00003e  4680              MOV      r8,r0                 ;845
000040  ea5f0008          MOVS     r0,r8                 ;846
000044  d023              BEQ      |L18.142|
000046  f1aa6000          SUB      r0,r10,#0x8000000     ;851
00004a  0ac7              LSRS     r7,r0,#11             ;852
00004c  f3c0060a          UBFX     r6,r0,#0,#11          ;853
000050  f5c66400          RSB      r4,r6,#0x800          ;854
000054  42a5              CMP      r5,r4                 ;856
000056  d800              BHI      |L18.90|
000058  462c              MOV      r4,r5                 ;858
                  |L18.90|
00005a  b672              CPSID    i                     ;861
00005c  f7fffffe          BL       fmc_unlock
000060  f2403005          MOV      r0,#0x305             ;865
000064  f7fffffe          BL       fmc_flag_clear
000068  f44f7041          MOV      r0,#0x304             ;866
00006c  f7fffffe          BL       fmc_flag_clear
000070  f2403002          MOV      r0,#0x302             ;867
000074  f7fffffe          BL       fmc_flag_clear
                  |L18.120|
000078  f44f6000          MOV      r0,#0x800             ;873
00007c  eb0020c7          ADD      r0,r0,r7,LSL #11      ;873
000080  f44f7200          MOV      r2,#0x200             ;873
000084  4641              MOV      r1,r8                 ;873
000086  f7fffffe          BL       IAP_FlashReadWordArray
00008a  2000              MOVS     r0,#0                 ;875
00008c  e009              B        |L18.162|
                  |L18.142|
00008e  2000              MOVS     r0,#0                 ;848
000090  e7cd              B        |L18.46|
                  |L18.146|
000092  eb000196          ADD      r1,r0,r6,LSR #2       ;877
000096  f8581021          LDR      r1,[r8,r1,LSL #2]     ;877
00009a  1c49              ADDS     r1,r1,#1              ;877
00009c  d104              BNE      |L18.168|
00009e  1c40              ADDS     r0,r0,#1              ;875
0000a0  b280              UXTH     r0,r0                 ;875
                  |L18.162|
0000a2  ebb00f94          CMP      r0,r4,LSR #2          ;875
0000a6  d3f4              BCC      |L18.146|
                  |L18.168|
0000a8  ebb00f94          CMP      r0,r4,LSR #2          ;884
0000ac  d222              BCS      |L18.244|
0000ae  f04f6000          MOV      r0,#0x8000000         ;888
0000b2  eb002bc7          ADD      r11,r0,r7,LSL #11     ;888
0000b6  4658              MOV      r0,r11                ;888
0000b8  f7fffffe          BL       fmc_page_erase
0000bc  2000              MOVS     r0,#0                 ;891
0000be  e007              B        |L18.208|
                  |L18.192|
0000c0  eb000296          ADD      r2,r0,r6,LSR #2       ;893
0000c4  f8591020          LDR      r1,[r9,r0,LSL #2]     ;893
0000c8  f8481022          STR      r1,[r8,r2,LSL #2]     ;893
0000cc  1c40              ADDS     r0,r0,#1              ;891
0000ce  b280              UXTH     r0,r0                 ;891
                  |L18.208|
0000d0  ebb00f94          CMP      r0,r4,LSR #2          ;891
0000d4  d3f4              BCC      |L18.192|
0000d6  4658              MOV      r0,r11                ;897
0000d8  f44f7200          MOV      r2,#0x200             ;897
0000dc  4641              MOV      r1,r8                 ;897
0000de  f7fffffe          BL       IAP_FlashWriteWordArrayAndCheck
0000e2  b968              CBNZ     r0,|L18.256|
0000e4  4640              MOV      r0,r8                 ;900
0000e6  f7fffffe          BL       free
0000ea  f7fffffe          BL       fmc_lock
0000ee  b662              CPSIE    i                     ;903
0000f0  2000              MOVS     r0,#0                 ;904
0000f2  e79c              B        |L18.46|
                  |L18.244|
0000f4  08a2              LSRS     r2,r4,#2              ;911
0000f6  4649              MOV      r1,r9                 ;911
0000f8  4650              MOV      r0,r10                ;911
0000fa  f7fffffe          BL       IAP_FlashWriteWordArrayAndCheck
0000fe  b148              CBZ      r0,|L18.276|
                  |L18.256|
000100  42a5              CMP      r5,r4                 ;923
000102  d10f              BNE      |L18.292|
000104  4640              MOV      r0,r8                 ;949
000106  f7fffffe          BL       free
00010a  f7fffffe          BL       fmc_lock
00010e  b662              CPSIE    i                     ;951
000110  9800              LDR      r0,[sp,#0]            ;925
000112  e78c              B        |L18.46|
                  |L18.276|
000114  4640              MOV      r0,r8                 ;914
000116  f7fffffe          BL       free
00011a  f7fffffe          BL       fmc_lock
00011e  b662              CPSIE    i                     ;917
000120  2000              MOVS     r0,#0                 ;918
000122  e784              B        |L18.46|
                  |L18.292|
000124  1c7f              ADDS     r7,r7,#1              ;929
000126  2600              MOVS     r6,#0                 ;930
000128  f0240003          BIC      r0,r4,#3              ;932
00012c  4481              ADD      r9,r9,r0              ;932
00012e  44a2              ADD      r10,r10,r4            ;933
000130  1b28              SUBS     r0,r5,r4              ;934
000132  b285              UXTH     r5,r0                 ;934
000134  f44f6400          MOV      r4,#0x800             ;936
000138  42a5              CMP      r5,r4                 ;936
00013a  d89d              BHI      |L18.120|
00013c  462c              MOV      r4,r5                 ;942
00013e  e79b              B        |L18.120|
;;;954    
                          ENDP

                  |L18.320|
                          DCD      0x08040400

                          AREA ||i.IAP_JumpToAppFun||, CODE, READONLY, ALIGN=2

                  IAP_JumpToAppFun PROC
;;;91     // 窗口时间到跳转到APP代码区运行
;;;92     void IAP_JumpToAppFun(uint32 param)
000000  4a07              LDR      r2,|L19.32|
;;;93     {
;;;94     	// 检查栈顶地址是否合法.
;;;95     	if(((*(uint32*)param) & 0x2FFE0000) != 0x20000000)	
000002  6801              LDR      r1,[r0,#0]
000004  4011              ANDS     r1,r1,r2
000006  f1b15f00          CMP      r1,#0x20000000
00000a  d107              BNE      |L19.28|
;;;96     	{
;;;97     		return;
;;;98     	}
;;;99     
;;;100    	// APP无效
;;;101    	if (((*(uint32*)(param+4)) & 0xFFF80000) != 0x08000000)
00000c  6841              LDR      r1,[r0,#4]
00000e  f44f7280          MOV      r2,#0x100
000012  ebb24fd1          CMP      r2,r1,LSR #19
000016  d101              BNE      |L19.28|
;;;102    	{
;;;103    		return;
;;;104    	}
;;;105    	
;;;106    	// 执行APP程序
;;;107    	IAP_RunAPP(param);
000018  f7ffbffe          B.W      IAP_RunAPP
                  |L19.28|
;;;108    }
00001c  4770              BX       lr
;;;109    
                          ENDP

00001e  0000              DCW      0x0000
                  |L19.32|
                          DCD      0x2ffe0000

                          AREA ||i.IAP_RunAPP||, CODE, READONLY, ALIGN=2

                  IAP_RunAPP PROC
;;;60     *******************************************************************************/
;;;61     void IAP_RunAPP(uint32 appAddr)
000000  4a08              LDR      r2,|L20.36|
;;;62     {
;;;63         // appAddr存放的是用户程序Flash的首地址，(*(vu32*)appAddr的意思是取用户程序首地址里面的数据，该数据是用户程序的堆栈地址
;;;64         // 堆栈地址指向RAM,而RAM的起始地址是0x20000000,因此上面的判断语句执行:判断用户代码的堆栈地址是否落在:0x20000000~0x2001ffff区间中，
;;;65         // 这个区间的大小较多落在<128K RAM的区间，因此需要进行下面的判断
;;;66     
;;;67     	//定义一个函数类型的参数	
;;;68     	typedef void (*IAP_Func)(void);
;;;69     	IAP_Func jumpToApp;
;;;70     
;;;71     	if(((*(uint32*)appAddr) & 0x2FFE0000) == 0x20000000)	// 检查栈顶地址是否合法.
000002  6801              LDR      r1,[r0,#0]
000004  400a              ANDS     r2,r2,r1
000006  f1b25f00          CMP      r2,#0x20000000
00000a  d109              BNE      |L20.32|
;;;72     	{ 
;;;73     		if (((*(uint32*)(appAddr+4)) & 0xFFF80000) != 0x08000000)   // APP无效
00000c  6840              LDR      r0,[r0,#4]
00000e  f44f7280          MOV      r2,#0x100
000012  ebb24fd0          CMP      r2,r0,LSR #19
000016  d103              BNE      |L20.32|
;;;74     		{
;;;75     			return;
;;;76     		}
;;;77     
;;;78     		// 跳转之前关总中断，复位外设为默认值
;;;79     		DI();
000018  b672              CPSID    i
00001a  f3818808          MSR      MSP,r1
;;;80     //		RCC_APB2PeriphResetCmd(0xFFFFFFFF, ENABLE);
;;;81     //		RCC_APB2PeriphResetCmd(0xFFFFFFFF, DISABLE);
;;;82     //		RCC_APB1PeriphResetCmd(0xFFFFFFFF, ENABLE);
;;;83     //		RCC_APB1PeriphResetCmd(0xFFFFFFFF, DISABLE);
;;;84     		
;;;85     		jumpToApp = (IAP_Func)*(uint32*)(appAddr+4);		// 用户代码区第二个字为程序开始地址(复位地址)		
;;;86     	  	__set_MSP(*(uint32*)appAddr);						// 初始化用户程序的堆栈指针
;;;87     		jumpToApp();									// 跳转到用户程序APP
00001e  4700              BX       r0
                  |L20.32|
;;;88     	}
;;;89     }
000020  4770              BX       lr
;;;90     
                          ENDP

000022  0000              DCW      0x0000
                  |L20.36|
                          DCD      0x2ffe0000

                          AREA ||i.IAP_WriteAppBin||, CODE, READONLY, ALIGN=2

                  IAP_WriteAppBin PROC
;;;133    *******************************************************************************/
;;;134    BOOL IAP_WriteAppBin(uint32 appAddr, uint8 *appBuf, uint32 appSize)
000000  b5f0              PUSH     {r4-r7,lr}
;;;135    {
000002  b0bf              SUB      sp,sp,#0xfc
;;;136    	uint16 i = 0;
000004  2400              MOVS     r4,#0
;;;137    	uint16 j = 0;
000006  2300              MOVS     r3,#0
;;;138    	uint32 curAppAddr = appAddr; 	// 当前写入的地址
;;;139    	uint16 iapBuf[125+1];			// 此16位数据需要和串口通讯协议一帧最长字节有关126*2=252个字节
;;;140    	BOOL writeStatus;
;;;141    	
;;;142    	// 参数判断
;;;143    	if (NULL == appBuf)
000008  2900              CMP      r1,#0
00000a  d007              BEQ      |L21.28|
;;;144    	{
;;;145    		return FALSE;
;;;146    	}
;;;147    
;;;148    	// 参数检验是否非法，地址不能是IAP本身代码地址，绝对不能自己把自己擦掉
;;;149    	if ((appAddr < IAP_FLASH_APP1_ADDR) || (appAddr >= (IAP_GD32_FLASH_BASE+IAP_GD32_FLASH_SIZE)))
00000c  4e0f              LDR      r6,|L21.76|
00000e  1985              ADDS     r5,r0,r6
000010  f5b53f60          CMP      r5,#0x38000
000014  d304              BCC      |L21.32|
;;;150    	{
;;;151    		return FALSE;	// 非法地址
000016  2000              MOVS     r0,#0
                  |L21.24|
;;;152    	}
;;;153    	
;;;154    	// 循环写入
;;;155    	for (j = 0; j < appSize; j += 2)
;;;156    	{
;;;157    		// 字节整合
;;;158    		iapBuf[i++] = (uint16)(*appBuf) + ((uint16)(*(appBuf+1)) << 8);
;;;159    		// 偏移2个字节
;;;160    		appBuf += 2;
;;;161    	}
;;;162    
;;;163    	// 直接写入FLASH
;;;164    	writeStatus = IAP_FlashWriteHalfWordArray(curAppAddr, iapBuf, appSize/2);	
;;;165    
;;;166    	return writeStatus;
;;;167    }
000018  b03f              ADD      sp,sp,#0xfc
00001a  bdf0              POP      {r4-r7,pc}
                  |L21.28|
00001c  2000              MOVS     r0,#0                 ;145
00001e  e7fb              B        |L21.24|
                  |L21.32|
000020  466f              MOV      r7,sp                 ;139
000022  e00b              B        |L21.60|
                  |L21.36|
000024  780d              LDRB     r5,[r1,#0]            ;158
000026  784e              LDRB     r6,[r1,#1]            ;158
000028  eb052506          ADD      r5,r5,r6,LSL #8       ;158
00002c  4626              MOV      r6,r4                 ;158
00002e  1c64              ADDS     r4,r4,#1              ;158
000030  b2a4              UXTH     r4,r4                 ;158
000032  f8275016          STRH     r5,[r7,r6,LSL #1]     ;158
000036  1c89              ADDS     r1,r1,#2              ;160
000038  1c9b              ADDS     r3,r3,#2              ;155
00003a  b29b              UXTH     r3,r3                 ;155
                  |L21.60|
00003c  4293              CMP      r3,r2                 ;155
00003e  d3f1              BCC      |L21.36|
000040  f3c2024f          UBFX     r2,r2,#1,#16          ;164
000044  4669              MOV      r1,sp                 ;164
000046  f7fffffe          BL       IAP_FlashWriteHalfWordArray
00004a  e7e5              B        |L21.24|
;;;168    
                          ENDP

                  |L21.76|
                          DCD      0xf7ff8000

                          AREA ||.data||, DATA, ALIGN=0

                  iapCB
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "User\\iap.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_iap_c_c37294e4____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___5_iap_c_c37294e4____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_iap_c_c37294e4____REVSH|
#line 128
|__asm___5_iap_c_c37294e4____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
