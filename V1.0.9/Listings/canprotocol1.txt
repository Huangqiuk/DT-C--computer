; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\canprotocol1.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\canprotocol1.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -I.\User\qrencode -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.1\Device\Include -D__MICROLIB -D__UVISION_VERSION=534 -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\canprotocol1.crf User\CanProtocol1.c]
                          THUMB

                          AREA ||i.CAN_PROTOCOL1_CALLBACK_UartBusError||, CODE, READONLY, ALIGN=1

                  CAN_PROTOCOL1_CALLBACK_UartBusError PROC
;;;571    // 	UART总线超时错误处理
;;;572    void CAN_PROTOCOL1_CALLBACK_UartBusError(uint32 param)
000000  4770              BX       lr
;;;573    {
;;;574    }
;;;575    
                          ENDP


                          AREA ||i.CAN_PROTOCOL1_CheckSUM||, CODE, READONLY, ALIGN=1

                  CAN_PROTOCOL1_CheckSUM PROC
;;;476    // 对传入的命令帧进行校验，返回校验结果
;;;477    BOOL CAN_PROTOCOL1_CheckSUM(CAN_PROTOCOL1_RX_CMD_FRAME *pCmdFrame)
000000  b530              PUSH     {r4,r5,lr}
;;;478    {
000002  4601              MOV      r1,r0
;;;479    	uint16 checkSum = 0;
000004  2400              MOVS     r4,#0
;;;480    	uint16 sumTemp;
;;;481    	uint16 i = 0;
000006  2300              MOVS     r3,#0
;;;482    
;;;483    	if (NULL == pCmdFrame)
000008  b909              CBNZ     r1,|L2.14|
;;;484    	{
;;;485    		return FALSE;
00000a  2000              MOVS     r0,#0
                  |L2.12|
;;;486    	}
;;;487    
;;;488    	// 从设备地址开始，到校验码之前的一个字节，依次进行累加运算
;;;489    	for (i = 1; i < pCmdFrame->length - 4; i++)
;;;490    	{
;;;491    		checkSum += pCmdFrame->buff[i];
;;;492    	}
;;;493    
;;;494    	// 累加和，低字节在前，高字节在后
;;;495    	sumTemp = pCmdFrame->buff[pCmdFrame->length - 3]; // 高字节
;;;496    	sumTemp <<= 8;
;;;497    	sumTemp += pCmdFrame->buff[pCmdFrame->length - 4]; // 低字节
;;;498    
;;;499    	// 判断计算得到的校验码与命令帧中的校验码是否相同
;;;500    	if (sumTemp != checkSum)
;;;501    	{
;;;502    		return FALSE;
;;;503    	}
;;;504    
;;;505    	return TRUE;
;;;506    }
00000c  bd30              POP      {r4,r5,pc}
                  |L2.14|
00000e  2301              MOVS     r3,#1                 ;489
000010  e005              B        |L2.30|
                  |L2.18|
000012  1c88              ADDS     r0,r1,#2              ;491
000014  5cc0              LDRB     r0,[r0,r3]            ;491
000016  4420              ADD      r0,r0,r4              ;491
000018  b284              UXTH     r4,r0                 ;491
00001a  1c58              ADDS     r0,r3,#1              ;489
00001c  b283              UXTH     r3,r0                 ;489
                  |L2.30|
00001e  f8b10098          LDRH     r0,[r1,#0x98]         ;489
000022  1f00              SUBS     r0,r0,#4              ;489
000024  4298              CMP      r0,r3                 ;489
000026  dcf4              BGT      |L2.18|
000028  f8b10098          LDRH     r0,[r1,#0x98]         ;495
00002c  1ec0              SUBS     r0,r0,#3              ;495
00002e  1c8d              ADDS     r5,r1,#2              ;495
000030  5c2a              LDRB     r2,[r5,r0]            ;495
000032  f64f70ff          MOV      r0,#0xffff            ;496
000036  ea002202          AND      r2,r0,r2,LSL #8       ;496
00003a  f8b10098          LDRH     r0,[r1,#0x98]         ;497
00003e  1f00              SUBS     r0,r0,#4              ;497
000040  5c28              LDRB     r0,[r5,r0]            ;497
000042  4410              ADD      r0,r0,r2              ;497
000044  b282              UXTH     r2,r0                 ;497
000046  42a2              CMP      r2,r4                 ;500
000048  d001              BEQ      |L2.78|
00004a  2000              MOVS     r0,#0                 ;502
00004c  e7de              B        |L2.12|
                  |L2.78|
00004e  2001              MOVS     r0,#1                 ;505
000050  e7dc              B        |L2.12|
;;;507    
                          ENDP


                          AREA ||i.CAN_PROTOCOL1_CmdFrameProcess||, CODE, READONLY, ALIGN=1

                  CAN_PROTOCOL1_CmdFrameProcess PROC
;;;508    // UART命令帧缓冲区处理
;;;509    void CAN_PROTOCOL1_CmdFrameProcess(CAN_PROTOCOL1_CB *pCB)
000000  b570              PUSH     {r4-r6,lr}
;;;510    {
000002  4604              MOV      r4,r0
;;;511    	CAN_PROTOCOL1_CMD cmd = CAN_PROTOCOL1_CMD_NULL;
000004  2600              MOVS     r6,#0
;;;512    	CAN_PROTOCOL1_RX_CMD_FRAME *pCmdFrame = NULL;
000006  2500              MOVS     r5,#0
;;;513    
;;;514    	// 参数合法性检验
;;;515    	if (NULL == pCB)
000008  b904              CBNZ     r4,|L3.12|
                  |L3.10|
;;;516    	{
;;;517    		return;
;;;518    	}
;;;519    
;;;520    	// 命令帧缓冲区为空，退出
;;;521    	if (pCB->rx.head == pCB->rx.end)
;;;522    	{
;;;523    		return;
;;;524    	}
;;;525    
;;;526    	// 获取当前要处理的命令帧指针
;;;527    	pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.head];
;;;528    
;;;529    	// 命令头非法，退出
;;;530    	if (CAN_PROTOCOL1_CMD_HEAD != pCmdFrame->buff[CAN_PROTOCOL1_CMD_HEAD_INDEX])
;;;531    	{
;;;532    		// 删除命令帧
;;;533    		pCB->rx.head++;
;;;534    		pCB->rx.head %= CAN_PROTOCOL1_RX_QUEUE_SIZE;
;;;535    		return;
;;;536    	}
;;;537    
;;;538    	// 命令头合法，则提取命令
;;;539    	cmd = (CAN_PROTOCOL1_CMD)pCmdFrame->buff[CAN_PROTOCOL1_CMD_CMD_INDEX];
;;;540    
;;;541    	// 执行命令帧
;;;542    	switch (cmd)
;;;543    	{
;;;544    	// 空命令，不予执行
;;;545    	case CAN_PROTOCOL1_CMD_NULL:
;;;546    		break;
;;;547    	// 测试
;;;548    	case 0x88:
;;;549    		CAN_PROTOCOL1_ReportWriteParamResult(TRUE);
;;;550    		break;
;;;551    	// 0x31,写配置信息应答
;;;552    	case CAN_PROTOCOL1_CMD_WRITE_CONTROL_PARAM_RESULT:
;;;553    		// 有应答代表配置信息升级成功
;;;554    		STATE_SwitchStep(STEP_CAN_SET_CONFIG_SUCCESS);
;;;555    		break;
;;;556    
;;;557    	// 0xc3,验证配置是否写成功
;;;558    	case CAN_PROTOCOL1_CMD_VERIFY_WRITE_RESULT:
;;;559    
;;;560    		break;
;;;561    
;;;562    	default:
;;;563    		break;
;;;564    	}
;;;565    
;;;566    	// 删除命令帧
;;;567    	pCB->rx.head++;
;;;568    	pCB->rx.head %= CAN_PROTOCOL1_RX_QUEUE_SIZE;
;;;569    }
00000a  bd70              POP      {r4-r6,pc}
                  |L3.12|
00000c  f8b413d0          LDRH     r1,[r4,#0x3d0]        ;521
000010  f8b403d2          LDRH     r0,[r4,#0x3d2]        ;521
000014  4281              CMP      r1,r0                 ;521
000016  d100              BNE      |L3.26|
000018  e7f7              B        |L3.10|
                  |L3.26|
00001a  f8b403d0          LDRH     r0,[r4,#0x3d0]        ;527
00001e  214d              MOVS     r1,#0x4d              ;527
000020  4348              MULS     r0,r1,r0              ;527
000022  f10401ce          ADD      r1,r4,#0xce           ;527
000026  eb010540          ADD      r5,r1,r0,LSL #1       ;527
00002a  78a8              LDRB     r0,[r5,#2]            ;530
00002c  283a              CMP      r0,#0x3a              ;530
00002e  d00e              BEQ      |L3.78|
000030  f8b403d0          LDRH     r0,[r4,#0x3d0]        ;533
000034  1c40              ADDS     r0,r0,#1              ;533
000036  f8a403d0          STRH     r0,[r4,#0x3d0]        ;533
00003a  f8b403d0          LDRH     r0,[r4,#0x3d0]        ;534
00003e  2105              MOVS     r1,#5                 ;534
000040  fb90f2f1          SDIV     r2,r0,r1              ;534
000044  fb010012          MLS      r0,r1,r2,r0           ;534
000048  f8a403d0          STRH     r0,[r4,#0x3d0]        ;534
00004c  e7dd              B        |L3.10|
                  |L3.78|
00004e  792e              LDRB     r6,[r5,#4]            ;539
000050  b136              CBZ      r6,|L3.96|
000052  2e88              CMP      r6,#0x88              ;542
000054  d005              BEQ      |L3.98|
000056  2ec1              CMP      r6,#0xc1              ;542
000058  d007              BEQ      |L3.106|
00005a  2ec3              CMP      r6,#0xc3              ;542
00005c  d10a              BNE      |L3.116|
00005e  e008              B        |L3.114|
                  |L3.96|
000060  e009              B        |L3.118|
                  |L3.98|
000062  2001              MOVS     r0,#1                 ;549
000064  f7fffffe          BL       CAN_PROTOCOL1_ReportWriteParamResult
000068  e005              B        |L3.118|
                  |L3.106|
00006a  2042              MOVS     r0,#0x42              ;554
00006c  f7fffffe          BL       STATE_SwitchStep
000070  e001              B        |L3.118|
                  |L3.114|
000072  e000              B        |L3.118|
                  |L3.116|
000074  bf00              NOP                            ;563
                  |L3.118|
000076  bf00              NOP                            ;546
000078  f8b403d0          LDRH     r0,[r4,#0x3d0]        ;567
00007c  1c40              ADDS     r0,r0,#1              ;567
00007e  f8a403d0          STRH     r0,[r4,#0x3d0]        ;567
000082  f8b403d0          LDRH     r0,[r4,#0x3d0]        ;568
000086  2105              MOVS     r1,#5                 ;568
000088  fb90f2f1          SDIV     r2,r0,r1              ;568
00008c  fb010012          MLS      r0,r1,r2,r0           ;568
000090  f8a403d0          STRH     r0,[r4,#0x3d0]        ;568
000094  bf00              NOP      
000096  e7b8              B        |L3.10|
;;;570    
                          ENDP


                          AREA ||i.CAN_PROTOCOL1_ConfirmTempCmdFrameBuff||, CODE, READONLY, ALIGN=1

                  CAN_PROTOCOL1_ConfirmTempCmdFrameBuff PROC
;;;257    // 将临时缓冲区添加到命令帧缓冲区中，其本质操作是承认临时缓冲区数据有效
;;;258    BOOL CAN_PROTOCOL1_ConfirmTempCmdFrameBuff(CAN_PROTOCOL1_CB *pCB)
000000  b510              PUSH     {r4,lr}
;;;259    {
000002  4601              MOV      r1,r0
;;;260    	CAN_PROTOCOL1_RX_CMD_FRAME *pCmdFrame = NULL;
000004  2200              MOVS     r2,#0
;;;261    
;;;262    	// 参数合法性检验
;;;263    	if (NULL == pCB)
000006  b909              CBNZ     r1,|L4.12|
;;;264    	{
;;;265    		return FALSE;
000008  2000              MOVS     r0,#0
                  |L4.10|
;;;266    	}
;;;267    
;;;268    	// 临时缓冲区为空，不予添加
;;;269    	pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.end];
;;;270    	if (0 == pCmdFrame->length)
;;;271    	{
;;;272    		return FALSE;
;;;273    	}
;;;274    
;;;275    	// 添加
;;;276    	pCB->rx.end++;
;;;277    	pCB->rx.end %= CAN_PROTOCOL1_RX_QUEUE_SIZE;
;;;278    	pCB->rx.cmdQueue[pCB->rx.end].length = 0; // 该行的作用是将新的添加位置有效数据个数清零，以便将这个位置当做临时帧缓冲区
;;;279    
;;;280    	return TRUE;
;;;281    }
00000a  bd10              POP      {r4,pc}
                  |L4.12|
00000c  f8b103d2          LDRH     r0,[r1,#0x3d2]        ;269
000010  234d              MOVS     r3,#0x4d              ;269
000012  4358              MULS     r0,r3,r0              ;269
000014  f10103ce          ADD      r3,r1,#0xce           ;269
000018  eb030240          ADD      r2,r3,r0,LSL #1       ;269
00001c  f8b20098          LDRH     r0,[r2,#0x98]         ;270
000020  b908              CBNZ     r0,|L4.38|
000022  2000              MOVS     r0,#0                 ;272
000024  e7f1              B        |L4.10|
                  |L4.38|
000026  f8b103d2          LDRH     r0,[r1,#0x3d2]        ;276
00002a  1c40              ADDS     r0,r0,#1              ;276
00002c  f8a103d2          STRH     r0,[r1,#0x3d2]        ;276
000030  f8b103d2          LDRH     r0,[r1,#0x3d2]        ;277
000034  2305              MOVS     r3,#5                 ;277
000036  fb90f4f3          SDIV     r4,r0,r3              ;277
00003a  fb030014          MLS      r0,r3,r4,r0           ;277
00003e  f8a103d2          STRH     r0,[r1,#0x3d2]        ;277
000042  2400              MOVS     r4,#0                 ;278
000044  f8b103d2          LDRH     r0,[r1,#0x3d2]        ;278
000048  234d              MOVS     r3,#0x4d              ;278
00004a  4358              MULS     r0,r3,r0              ;278
00004c  f10103ce          ADD      r3,r1,#0xce           ;278
000050  eb030040          ADD      r0,r3,r0,LSL #1       ;278
000054  f8a04098          STRH     r4,[r0,#0x98]         ;278
000058  2001              MOVS     r0,#1                 ;280
00005a  e7d6              B        |L4.10|
;;;282    
                          ENDP


                          AREA ||i.CAN_PROTOCOL1_DataStructInit||, CODE, READONLY, ALIGN=1

                  CAN_PROTOCOL1_DataStructInit PROC
;;;187    // 数据结构初始化
;;;188    void CAN_PROTOCOL1_DataStructInit(CAN_PROTOCOL1_CB *pCB)
000000  b510              PUSH     {r4,lr}
;;;189    {
;;;190    	uint16 i;
;;;191    
;;;192    	// 参数合法性检验
;;;193    	if (NULL == pCB)
000002  b900              CBNZ     r0,|L5.6|
                  |L5.4|
;;;194    	{
;;;195    		return;
;;;196    	}
;;;197    
;;;198    	pCB->tx.txBusy = FALSE;
;;;199    	pCB->tx.index = 0;
;;;200    	pCB->tx.head = 0;
;;;201    	pCB->tx.end = 0;
;;;202    	for (i = 0; i < CAN_PROTOCOL1_TX_QUEUE_SIZE; i++)
;;;203    	{
;;;204    		pCB->tx.cmdQueue[i].length = 0;
;;;205    	}
;;;206    
;;;207    	pCB->rxFIFO.head = 0;
;;;208    	pCB->rxFIFO.end = 0;
;;;209    	pCB->rxFIFO.currentProcessIndex = 0;
;;;210    
;;;211    	pCB->rx.head = 0;
;;;212    	pCB->rx.end = 0;
;;;213    	for (i = 0; i < CAN_PROTOCOL1_RX_QUEUE_SIZE; i++)
;;;214    	{
;;;215    		pCB->rx.cmdQueue[i].length = 0;
;;;216    	}
;;;217    }
000004  bd10              POP      {r4,pc}
                  |L5.6|
000006  2300              MOVS     r3,#0                 ;198
000008  f88038aa          STRB     r3,[r0,#0x8aa]        ;198
00000c  f8a038a8          STRH     r3,[r0,#0x8a8]        ;199
000010  f8a038a4          STRH     r3,[r0,#0x8a4]        ;200
000014  f8a038a6          STRH     r3,[r0,#0x8a6]        ;201
000018  2100              MOVS     r1,#0                 ;202
00001a  e00a              B        |L5.50|
                  |L5.28|
00001c  2400              MOVS     r4,#0                 ;204
00001e  224d              MOVS     r2,#0x4d              ;204
000020  434a              MULS     r2,r1,r2              ;204
000022  f5007375          ADD      r3,r0,#0x3d4          ;204
000026  eb030242          ADD      r2,r3,r2,LSL #1       ;204
00002a  f8a24098          STRH     r4,[r2,#0x98]         ;204
00002e  1c4a              ADDS     r2,r1,#1              ;202
000030  b291              UXTH     r1,r2                 ;202
                  |L5.50|
000032  2908              CMP      r1,#8                 ;202
000034  dbf2              BLT      |L5.28|
000036  2200              MOVS     r2,#0                 ;207
000038  f8202fc8          STRH     r2,[r0,#0xc8]!        ;207
00003c  8042              STRH     r2,[r0,#2]            ;208
00003e  8082              STRH     r2,[r0,#4]            ;209
000040  38c8              SUBS     r0,r0,#0xc8           ;209
000042  2300              MOVS     r3,#0                 ;211
000044  f8a033d0          STRH     r3,[r0,#0x3d0]        ;211
000048  f8a033d2          STRH     r3,[r0,#0x3d2]        ;212
00004c  2100              MOVS     r1,#0                 ;213
00004e  e00a              B        |L5.102|
                  |L5.80|
000050  2400              MOVS     r4,#0                 ;215
000052  224d              MOVS     r2,#0x4d              ;215
000054  434a              MULS     r2,r1,r2              ;215
000056  f10003ce          ADD      r3,r0,#0xce           ;215
00005a  eb030242          ADD      r2,r3,r2,LSL #1       ;215
00005e  f8a24098          STRH     r4,[r2,#0x98]         ;215
000062  1c4a              ADDS     r2,r1,#1              ;213
000064  b291              UXTH     r1,r2                 ;213
                  |L5.102|
000066  2905              CMP      r1,#5                 ;213
000068  dbf2              BLT      |L5.80|
00006a  bf00              NOP      
00006c  e7ca              B        |L5.4|
;;;218    
                          ENDP


                          AREA ||i.CAN_PROTOCOL1_Init||, CODE, READONLY, ALIGN=2

                  CAN_PROTOCOL1_Init PROC
;;;82     // 协议初始化
;;;83     void CAN_PROTOCOL1_Init(void)
000000  b500              PUSH     {lr}
;;;84     {
;;;85     	// 协议层数据结构初始化
;;;86     	CAN_PROTOCOL1_DataStructInit(&canProtocol1CB);
000002  4803              LDR      r0,|L6.16|
000004  f7fffffe          BL       CAN_PROTOCOL1_DataStructInit
;;;87     
;;;88     	// 向驱动层注册数据接收接口
;;;89     	// CAN_DRIVE_RegisterDataSendService(CAN_PROTOCOL1_MacProcess);
;;;90     
;;;91     	// 向驱动层注册数据发送接口
;;;92     	CAN_PROTOCOL1_RegisterDataSendService(CAN_DRIVE_AddTxArray);
000008  4802              LDR      r0,|L6.20|
00000a  f7fffffe          BL       CAN_PROTOCOL1_RegisterDataSendService
;;;93     	//
;;;94     	//	TIMER_AddTask(TIMER_ID_CAN_TEST,
;;;95     	//				1500,
;;;96     	//				can_test,
;;;97     	//				TRUE,
;;;98     	//				4,
;;;99     	//				ACTION_MODE_ADD_TO_QUEUE);
;;;100    }
00000e  bd00              POP      {pc}
;;;101    
                          ENDP

                  |L6.16|
                          DCD      canProtocol1CB
                  |L6.20|
                          DCD      CAN_DRIVE_AddTxArray

                          AREA ||i.CAN_PROTOCOL1_MacProcess||, CODE, READONLY, ALIGN=2

                  CAN_PROTOCOL1_MacProcess PROC
;;;219    // UART报文接收处理函数(注意根据具体模块修改)
;;;220    void CAN_PROTOCOL1_MacProcess(uint32 standarID, uint8 *pData, uint16 length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;221    {
000004  4606              MOV      r6,r0
;;;222    	uint16 end = canProtocol1CB.rxFIFO.end;
000006  4f23              LDR      r7,|L7.148|
000008  f8b750ca          LDRH     r5,[r7,#0xca]  ; canProtocol1CB
;;;223    	uint16 head = canProtocol1CB.rxFIFO.head;
00000c  f8b700c8          LDRH     r0,[r7,#0xc8]  ; canProtocol1CB
;;;224    	uint16 i = 0;
000010  2300              MOVS     r3,#0
;;;225    	uint8 *rxdata = pData;
000012  460c              MOV      r4,r1
;;;226    
;;;227    	// ■■环形列队，入队■■
;;;228    	//  一级缓冲区已满，不予接收
;;;229    	if ((end + 1) % CAN_PROTOCOL1_RX_FIFO_SIZE == head)
000014  1c6f              ADDS     r7,r5,#1
000016  f04f0cc8          MOV      r12,#0xc8
00001a  fb97f8fc          SDIV     r8,r7,r12
00001e  fb0c7718          MLS      r7,r12,r8,r7
000022  4287              CMP      r7,r0
000024  d101              BNE      |L7.42|
                  |L7.38|
;;;230    	{
;;;231    		return;
;;;232    	}
;;;233    
;;;234    	for (i = 0; i < length; i++)
;;;235    	{
;;;236    		// 单个字节读取，并放入FIFO中
;;;237    		canProtocol1CB.rxFIFO.buff[canProtocol1CB.rxFIFO.end] = *rxdata++;
;;;238    
;;;239    		canProtocol1CB.rxFIFO.end++;
;;;240    
;;;241    		// 一级缓冲区已满，不予接收
;;;242    		if ((canProtocol1CB.rxFIFO.end + 1) % CAN_PROTOCOL1_RX_FIFO_SIZE == head)
;;;243    		{
;;;244    			break;
;;;245    		}
;;;246    
;;;247    		canProtocol1CB.rxFIFO.end %= CAN_PROTOCOL1_RX_FIFO_SIZE;
;;;248    	}
;;;249    }
000026  e8bd81f0          POP      {r4-r8,pc}
                  |L7.42|
00002a  2300              MOVS     r3,#0                 ;234
00002c  e02c              B        |L7.136|
                  |L7.46|
00002e  f8147b01          LDRB     r7,[r4],#1            ;237
000032  f8dfc060          LDR      r12,|L7.148|
000036  f8bcc0ca          LDRH     r12,[r12,#0xca]       ;237  ; canProtocol1CB
00003a  f8df8058          LDR      r8,|L7.148|
00003e  f808700c          STRB     r7,[r8,r12]           ;237
000042  4647              MOV      r7,r8                 ;239
000044  f8b770ca          LDRH     r7,[r7,#0xca]         ;239  ; canProtocol1CB
000048  1c7f              ADDS     r7,r7,#1              ;239
00004a  46c4              MOV      r12,r8                ;239
00004c  f8ac70ca          STRH     r7,[r12,#0xca]        ;239
000050  4647              MOV      r7,r8                 ;242
000052  f8b770ca          LDRH     r7,[r7,#0xca]         ;242  ; canProtocol1CB
000056  1c7f              ADDS     r7,r7,#1              ;242
000058  f04f0cc8          MOV      r12,#0xc8             ;242
00005c  fb97f8fc          SDIV     r8,r7,r12             ;242
000060  fb0c7718          MLS      r7,r12,r8,r7          ;242
000064  4287              CMP      r7,r0                 ;242
000066  d100              BNE      |L7.106|
000068  e010              B        |L7.140|
                  |L7.106|
00006a  4f0a              LDR      r7,|L7.148|
00006c  f8b770ca          LDRH     r7,[r7,#0xca]         ;247  ; canProtocol1CB
000070  f04f0cc8          MOV      r12,#0xc8             ;247
000074  fb97f8fc          SDIV     r8,r7,r12             ;247
000078  fb0c7718          MLS      r7,r12,r8,r7          ;247
00007c  f8dfc014          LDR      r12,|L7.148|
000080  f8ac70ca          STRH     r7,[r12,#0xca]        ;247
000084  1c5f              ADDS     r7,r3,#1              ;234
000086  b2bb              UXTH     r3,r7                 ;234
                  |L7.136|
000088  4293              CMP      r3,r2                 ;234
00008a  dbd0              BLT      |L7.46|
                  |L7.140|
00008c  bf00              NOP                            ;244
00008e  bf00              NOP      
000090  e7c9              B        |L7.38|
;;;250    
                          ENDP

000092  0000              DCW      0x0000
                  |L7.148|
                          DCD      canProtocol1CB

                          AREA ||i.CAN_PROTOCOL1_RegisterDataSendService||, CODE, READONLY, ALIGN=2

                  CAN_PROTOCOL1_RegisterDataSendService PROC
;;;251    // UART协议层向驱动层注册数据发送接口
;;;252    void CAN_PROTOCOL1_RegisterDataSendService(BOOL (*service)(uint32 id, uint8 *pData, uint8 length))
000000  4901              LDR      r1,|L8.8|
;;;253    {
;;;254    	canProtocol1CB.sendDataThrowService = service;
000002  f8c108ac          STR      r0,[r1,#0x8ac]  ; canProtocol1CB
;;;255    }
000006  4770              BX       lr
;;;256    
                          ENDP

                  |L8.8|
                          DCD      canProtocol1CB

                          AREA ||i.CAN_PROTOCOL1_ReportWriteParamResult||, CODE, READONLY, ALIGN=1

                  CAN_PROTOCOL1_ReportWriteParamResult PROC
;;;576    // 上报写配置参数结果
;;;577    void CAN_PROTOCOL1_ReportWriteParamResult(uint32 param)
000000  b510              PUSH     {r4,lr}
;;;578    {
000002  4604              MOV      r4,r0
;;;579    	// 添加命令头
;;;580    	CAN_PROTOCOL1_TxAddData(CAN_PROTOCOL1_CMD_HEAD);
000004  203a              MOVS     r0,#0x3a
000006  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;581    
;;;582    	// 添加设备地址
;;;583    	CAN_PROTOCOL1_TxAddData(CAN_PROTOCOL1_CMD_DEVICE_ADDR);
00000a  201a              MOVS     r0,#0x1a
00000c  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;584    
;;;585    	// 添加命令字
;;;586    	CAN_PROTOCOL1_TxAddData(CAN_PROTOCOL1_CMD_WRITE_CONTROL_PARAM_RESULT);
000010  20c1              MOVS     r0,#0xc1
000012  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;587    
;;;588    	// 添加数据长度
;;;589    	CAN_PROTOCOL1_TxAddData(1);
000016  2001              MOVS     r0,#1
000018  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;590    
;;;591    	// 写入结果
;;;592    	CAN_PROTOCOL1_TxAddData(param);
00001c  b2e0              UXTB     r0,r4
00001e  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;593    
;;;594    	// 添加检验和与结束符，并添加至发送
;;;595    	CAN_PROTOCOL1_TxAddFrame();
000022  f7fffffe          BL       CAN_PROTOCOL1_TxAddFrame
;;;596    }
000026  bd10              POP      {r4,pc}
;;;597    
                          ENDP


                          AREA ||i.CAN_PROTOCOL1_RxFIFOProcess||, CODE, READONLY, ALIGN=1

                  CAN_PROTOCOL1_RxFIFOProcess PROC
;;;316    // 一级接收缓冲区处理，从一级接收缓冲区中取出一个字节添加到命令帧缓冲区中
;;;317    void CAN_PROTOCOL1_RxFIFOProcess(CAN_PROTOCOL1_CB *pCB)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;318    {
000004  4604              MOV      r4,r0
;;;319    	uint16 end = pCB->rxFIFO.end;
000006  f8b470ca          LDRH     r7,[r4,#0xca]
;;;320    	uint16 head = pCB->rxFIFO.head;
00000a  f8b490c8          LDRH     r9,[r4,#0xc8]
;;;321    	CAN_PROTOCOL1_RX_CMD_FRAME *pCmdFrame = NULL;
00000e  2500              MOVS     r5,#0
;;;322    	uint16 length = 0;
000010  46a8              MOV      r8,r5
;;;323    	uint8 currentData = 0;
000012  2600              MOVS     r6,#0
;;;324    
;;;325    	// 参数合法性检验
;;;326    	if (NULL == pCB)
000014  b90c              CBNZ     r4,|L10.26|
                  |L10.22|
;;;327    	{
;;;328    		return;
;;;329    	}
;;;330    
;;;331    	// 一级缓冲区为空，退出
;;;332    	if (head == end)
;;;333    	{
;;;334    		return;
;;;335    	}
;;;336    
;;;337    	// 获取临时缓冲区指针
;;;338    	pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.end];
;;;339    	// 取出当前要处理的字节
;;;340    	currentData = pCB->rxFIFO.buff[pCB->rxFIFO.currentProcessIndex];
;;;341    
;;;342    	// 临时缓冲区长度为0时，搜索首字节
;;;343    	if (0 == pCmdFrame->length)
;;;344    	{
;;;345    		// 命令头错误，删除当前字节并退出
;;;346    		if (CAN_PROTOCOL1_CMD_HEAD != currentData)
;;;347    		{
;;;348    			pCB->rxFIFO.head++;
;;;349    			pCB->rxFIFO.head %= CAN_PROTOCOL1_RX_FIFO_SIZE;
;;;350    			pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;351    
;;;352    			return;
;;;353    		}
;;;354    
;;;355    		// 命令头正确，但无临时缓冲区可用，退出
;;;356    		if ((pCB->rx.end + 1) % CAN_PROTOCOL1_RX_QUEUE_SIZE == pCB->rx.head)
;;;357    		{
;;;358    			return;
;;;359    		}
;;;360    
;;;361    		// 添加UART通讯超时时间设置-2016.1.5增加
;;;362    #if CAN_PROTOCOL1_RX_TIME_OUT_CHECK_ENABLE
;;;363    		TIMER_AddTask(TIMER_ID_UART_RX_TIME_OUT_CONTROL,
;;;364    					  CAN_PROTOCOL1_BUS_UNIDIRECTIONAL_TIME_OUT,
;;;365    					  CAN_PROTOCOL1_CALLBACK_RxTimeOut,
;;;366    					  0,
;;;367    					  1,
;;;368    					  ACTION_MODE_ADD_TO_QUEUE);
;;;369    #endif
;;;370    
;;;371    		// 命令头正确，有临时缓冲区可用，则将其添加到命令帧临时缓冲区中
;;;372    		pCmdFrame->buff[pCmdFrame->length++] = currentData;
;;;373    		pCB->rxFIFO.currentProcessIndex++;
;;;374    		pCB->rxFIFO.currentProcessIndex %= CAN_PROTOCOL1_RX_FIFO_SIZE;
;;;375    	}
;;;376    	// 非首字节，将数据添加到命令帧临时缓冲区中，但暂不删除当前数据
;;;377    	else
;;;378    	{
;;;379    		// 临时缓冲区溢出，说明当前正在接收的命令帧是错误的，正确的命令帧不会出现长度溢出的情况
;;;380    		if (pCmdFrame->length >= CAN_PROTOCOL1_RX_CMD_FRAME_LENGTH_MAX)
;;;381    		{
;;;382    #if CAN_PROTOCOL1_RX_TIME_OUT_CHECK_ENABLE
;;;383    			// 停止RX通讯超时检测
;;;384    			CAN_PROTOCOL1_StopRxTimeOutCheck();
;;;385    #endif
;;;386    
;;;387    			// 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;388    			pCmdFrame->length = 0; // 2016.1.5增加
;;;389    			// 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;390    			pCB->rxFIFO.head++;
;;;391    			pCB->rxFIFO.head %= CAN_PROTOCOL1_RX_FIFO_SIZE;
;;;392    			pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;393    
;;;394    			return;
;;;395    		}
;;;396    
;;;397    		// 一直取到末尾
;;;398    		while (end != pCB->rxFIFO.currentProcessIndex)
;;;399    		{
;;;400    			// 取出当前要处理的字节
;;;401    			currentData = pCB->rxFIFO.buff[pCB->rxFIFO.currentProcessIndex];
;;;402    			// 缓冲区未溢出，正常接收，将数据添加到临时缓冲区中
;;;403    			pCmdFrame->buff[pCmdFrame->length++] = currentData;
;;;404    			pCB->rxFIFO.currentProcessIndex++;
;;;405    			pCB->rxFIFO.currentProcessIndex %= CAN_PROTOCOL1_RX_FIFO_SIZE;
;;;406    
;;;407    			// ■■接下来，需要检查命令帧是否完整，如果完整，则将命令帧临时缓冲区扶正■■
;;;408    
;;;409    			// 首先判断命令帧最小长度，一个完整的命令字至少包括8个字节: 命令头、设备地址、命令字、数据长度、校验和L、校验和H、结束标识0xD、结束标识OxA，因此不足8个字节的必定不完整
;;;410    			if (pCmdFrame->length < CAN_PROTOCOL1_CMD_FRAME_LENGTH_MIN)
;;;411    			{
;;;412    				// 继续接收
;;;413    				continue;
;;;414    			}
;;;415    
;;;416    			// 命令帧长度数值越界，说明当前命令帧错误，停止接收
;;;417    			if (pCmdFrame->buff[CAN_PROTOCOL1_CMD_LENGTH_INDEX] > CAN_PROTOCOL1_RX_CMD_FRAME_LENGTH_MAX - CAN_PROTOCOL1_CMD_FRAME_LENGTH_MIN)
;;;418    			{
;;;419    #if CAN_PROTOCOL1_RX_TIME_OUT_CHECK_ENABLE
;;;420    				// 停止RX通讯超时检测
;;;421    				CAN_PROTOCOL1_StopRxTimeOutCheck();
;;;422    #endif
;;;423    
;;;424    				// 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;425    				pCmdFrame->length = 0;
;;;426    				// 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;427    				pCB->rxFIFO.head++;
;;;428    				pCB->rxFIFO.head %= CAN_PROTOCOL1_RX_FIFO_SIZE;
;;;429    				pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;430    
;;;431    				return;
;;;432    			}
;;;433    
;;;434    			// 命令帧长度校验，在命令长度描述字的数值上，增加命令头、设备地址、命令字、数据长度、校验和L、校验和H、结束标识0xD、结束标识OxA，即为命令帧实际长度
;;;435    			length = pCmdFrame->length;
;;;436    			if (length < pCmdFrame->buff[CAN_PROTOCOL1_CMD_LENGTH_INDEX] + CAN_PROTOCOL1_CMD_FRAME_LENGTH_MIN)
;;;437    			{
;;;438    				// 长度要求不一致，说明未接收完毕，退出继续
;;;439    				continue;
;;;440    			}
;;;441    
;;;442    			// 命令帧长度OK，则进行校验，失败时删除命令头
;;;443    			if (!CAN_PROTOCOL1_CheckSUM(pCmdFrame))
;;;444    			{
;;;445    #if CAN_PROTOCOL1_RX_TIME_OUT_CHECK_ENABLE
;;;446    				// 停止RX通讯超时检测
;;;447    				CAN_PROTOCOL1_StopRxTimeOutCheck();
;;;448    #endif
;;;449    
;;;450    				// 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;451    				pCmdFrame->length = 0;
;;;452    				// 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;453    				pCB->rxFIFO.head++;
;;;454    				pCB->rxFIFO.head %= CAN_PROTOCOL1_RX_FIFO_SIZE;
;;;455    				pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;456    
;;;457    				return;
;;;458    			}
;;;459    
;;;460    #if CAN_PROTOCOL1_RX_TIME_OUT_CHECK_ENABLE
;;;461    			// 停止RX通讯超时检测
;;;462    			CAN_PROTOCOL1_StopRxTimeOutCheck();
;;;463    #endif
;;;464    
;;;465    			// 执行到这里，即说明接收到了一个完整并且正确的命令帧，此时需将处理过的数据从一级缓冲区中删除，并将该命令帧扶正
;;;466    			pCB->rxFIFO.head += length;
;;;467    			pCB->rxFIFO.head %= CAN_PROTOCOL1_RX_FIFO_SIZE;
;;;468    			pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;469    			CAN_PROTOCOL1_ConfirmTempCmdFrameBuff(pCB);
;;;470    
;;;471    			return;
;;;472    		}
;;;473    	}
;;;474    }
000016  e8bd83f0          POP      {r4-r9,pc}
                  |L10.26|
00001a  45b9              CMP      r9,r7                 ;332
00001c  d100              BNE      |L10.32|
00001e  e7fa              B        |L10.22|
                  |L10.32|
000020  f8b403d2          LDRH     r0,[r4,#0x3d2]        ;338
000024  214d              MOVS     r1,#0x4d              ;338
000026  4348              MULS     r0,r1,r0              ;338
000028  f10401ce          ADD      r1,r4,#0xce           ;338
00002c  eb010540          ADD      r5,r1,r0,LSL #1       ;338
000030  f8b400cc          LDRH     r0,[r4,#0xcc]         ;340
000034  5c26              LDRB     r6,[r4,r0]            ;340
000036  f8b50098          LDRH     r0,[r5,#0x98]         ;343
00003a  bb90              CBNZ     r0,|L10.162|
00003c  2e3a              CMP      r6,#0x3a              ;346
00003e  d00e              BEQ      |L10.94|
000040  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;348
000044  1c40              ADDS     r0,r0,#1              ;348
000046  8020              STRH     r0,[r4,#0]            ;348
000048  8820              LDRH     r0,[r4,#0]            ;349
00004a  21c8              MOVS     r1,#0xc8              ;349
00004c  fb90f2f1          SDIV     r2,r0,r1              ;349
000050  fb010012          MLS      r0,r1,r2,r0           ;349
000054  8020              STRH     r0,[r4,#0]            ;349
000056  8820              LDRH     r0,[r4,#0]            ;350
000058  80a0              STRH     r0,[r4,#4]            ;350
00005a  3cc8              SUBS     r4,r4,#0xc8           ;350
00005c  e7db              B        |L10.22|
                  |L10.94|
00005e  f8b403d2          LDRH     r0,[r4,#0x3d2]        ;356
000062  1c40              ADDS     r0,r0,#1              ;356
000064  2105              MOVS     r1,#5                 ;356
000066  fb90f2f1          SDIV     r2,r0,r1              ;356
00006a  fb010112          MLS      r1,r1,r2,r0           ;356
00006e  f8b403d0          LDRH     r0,[r4,#0x3d0]        ;356
000072  4281              CMP      r1,r0                 ;356
000074  d100              BNE      |L10.120|
000076  e7ce              B        |L10.22|
                  |L10.120|
000078  f8351f98          LDRH     r1,[r5,#0x98]!        ;372
00007c  8828              LDRH     r0,[r5,#0]            ;372
00007e  1c40              ADDS     r0,r0,#1              ;372
000080  f8250998          STRH     r0,[r5],#-0x98        ;372
000084  1ca8              ADDS     r0,r5,#2              ;372
000086  5446              STRB     r6,[r0,r1]            ;372
000088  f8340fcc          LDRH     r0,[r4,#0xcc]!        ;373
00008c  1c40              ADDS     r0,r0,#1              ;373
00008e  8020              STRH     r0,[r4,#0]            ;373
000090  8820              LDRH     r0,[r4,#0]            ;374
000092  21c8              MOVS     r1,#0xc8              ;374
000094  fb90f2f1          SDIV     r2,r0,r1              ;374
000098  fb010012          MLS      r0,r1,r2,r0           ;374
00009c  f82409cc          STRH     r0,[r4],#-0xcc        ;374
0000a0  e07b              B        |L10.410|
                  |L10.162|
0000a2  e7ff              B        |L10.164|
                  |L10.164|
0000a4  f8b50098          LDRH     r0,[r5,#0x98]         ;380
0000a8  2896              CMP      r0,#0x96              ;380
0000aa  db11              BLT      |L10.208|
0000ac  2000              MOVS     r0,#0                 ;388
0000ae  f8a50098          STRH     r0,[r5,#0x98]         ;388
0000b2  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;390
0000b6  1c40              ADDS     r0,r0,#1              ;390
0000b8  8020              STRH     r0,[r4,#0]            ;390
0000ba  8820              LDRH     r0,[r4,#0]            ;391
0000bc  21c8              MOVS     r1,#0xc8              ;391
0000be  fb90f2f1          SDIV     r2,r0,r1              ;391
0000c2  fb010012          MLS      r0,r1,r2,r0           ;391
0000c6  8020              STRH     r0,[r4,#0]            ;391
0000c8  8820              LDRH     r0,[r4,#0]            ;392
0000ca  80a0              STRH     r0,[r4,#4]            ;392
0000cc  3cc8              SUBS     r4,r4,#0xc8           ;392
0000ce  e7a2              B        |L10.22|
                  |L10.208|
0000d0  e05f              B        |L10.402|
                  |L10.210|
0000d2  f8b400cc          LDRH     r0,[r4,#0xcc]         ;401
0000d6  5c26              LDRB     r6,[r4,r0]            ;401
0000d8  f8351f98          LDRH     r1,[r5,#0x98]!        ;403
0000dc  8828              LDRH     r0,[r5,#0]            ;403
0000de  1c40              ADDS     r0,r0,#1              ;403
0000e0  f8250998          STRH     r0,[r5],#-0x98        ;403
0000e4  1ca8              ADDS     r0,r5,#2              ;403
0000e6  5446              STRB     r6,[r0,r1]            ;403
0000e8  f8340fcc          LDRH     r0,[r4,#0xcc]!        ;404
0000ec  1c40              ADDS     r0,r0,#1              ;404
0000ee  8020              STRH     r0,[r4,#0]            ;404
0000f0  8820              LDRH     r0,[r4,#0]            ;405
0000f2  21c8              MOVS     r1,#0xc8              ;405
0000f4  fb90f2f1          SDIV     r2,r0,r1              ;405
0000f8  fb010012          MLS      r0,r1,r2,r0           ;405
0000fc  f82409cc          STRH     r0,[r4],#-0xcc        ;405
000100  f8b50098          LDRH     r0,[r5,#0x98]         ;410
000104  2808              CMP      r0,#8                 ;410
000106  da00              BGE      |L10.266|
000108  e043              B        |L10.402|
                  |L10.266|
00010a  7968              LDRB     r0,[r5,#5]            ;417
00010c  288e              CMP      r0,#0x8e              ;417
00010e  dd11              BLE      |L10.308|
000110  2000              MOVS     r0,#0                 ;425
000112  f8a50098          STRH     r0,[r5,#0x98]         ;425
000116  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;427
00011a  1c40              ADDS     r0,r0,#1              ;427
00011c  8020              STRH     r0,[r4,#0]            ;427
00011e  8820              LDRH     r0,[r4,#0]            ;428
000120  21c8              MOVS     r1,#0xc8              ;428
000122  fb90f2f1          SDIV     r2,r0,r1              ;428
000126  fb010012          MLS      r0,r1,r2,r0           ;428
00012a  8020              STRH     r0,[r4,#0]            ;428
00012c  8820              LDRH     r0,[r4,#0]            ;429
00012e  80a0              STRH     r0,[r4,#4]            ;429
000130  3cc8              SUBS     r4,r4,#0xc8           ;429
000132  e770              B        |L10.22|
                  |L10.308|
000134  f8b58098          LDRH     r8,[r5,#0x98]         ;435
000138  7968              LDRB     r0,[r5,#5]            ;436
00013a  3008              ADDS     r0,r0,#8              ;436
00013c  4540              CMP      r0,r8                 ;436
00013e  dd00              BLE      |L10.322|
000140  e027              B        |L10.402|
                  |L10.322|
000142  4628              MOV      r0,r5                 ;443
000144  f7fffffe          BL       CAN_PROTOCOL1_CheckSUM
000148  b988              CBNZ     r0,|L10.366|
00014a  2000              MOVS     r0,#0                 ;451
00014c  f8a50098          STRH     r0,[r5,#0x98]         ;451
000150  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;453
000154  1c40              ADDS     r0,r0,#1              ;453
000156  8020              STRH     r0,[r4,#0]            ;453
000158  8820              LDRH     r0,[r4,#0]            ;454
00015a  21c8              MOVS     r1,#0xc8              ;454
00015c  fb90f2f1          SDIV     r2,r0,r1              ;454
000160  fb010012          MLS      r0,r1,r2,r0           ;454
000164  8020              STRH     r0,[r4,#0]            ;454
000166  8820              LDRH     r0,[r4,#0]            ;455
000168  80a0              STRH     r0,[r4,#4]            ;455
00016a  3cc8              SUBS     r4,r4,#0xc8           ;455
00016c  e753              B        |L10.22|
                  |L10.366|
00016e  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;466
000172  4440              ADD      r0,r0,r8              ;466
000174  8020              STRH     r0,[r4,#0]            ;466
000176  8820              LDRH     r0,[r4,#0]            ;467
000178  21c8              MOVS     r1,#0xc8              ;467
00017a  fb90f2f1          SDIV     r2,r0,r1              ;467
00017e  fb010012          MLS      r0,r1,r2,r0           ;467
000182  8020              STRH     r0,[r4,#0]            ;467
000184  8820              LDRH     r0,[r4,#0]            ;468
000186  80a0              STRH     r0,[r4,#4]            ;468
000188  3cc8              SUBS     r4,r4,#0xc8           ;468
00018a  4620              MOV      r0,r4                 ;469
00018c  f7fffffe          BL       CAN_PROTOCOL1_ConfirmTempCmdFrameBuff
000190  e741              B        |L10.22|
                  |L10.402|
000192  f8b400cc          LDRH     r0,[r4,#0xcc]         ;398
000196  42b8              CMP      r0,r7                 ;398
000198  d19b              BNE      |L10.210|
                  |L10.410|
00019a  bf00              NOP      
00019c  e73b              B        |L10.22|
;;;475    
                          ENDP


                          AREA ||i.CAN_PROTOCOL1_SendCmdNoResult||, CODE, READONLY, ALIGN=1

                  CAN_PROTOCOL1_SendCmdNoResult PROC
;;;641    // 发送命令无结果
;;;642    void CAN_PROTOCOL1_SendCmdNoResult(uint8 cmdWord)
000000  b510              PUSH     {r4,lr}
;;;643    {
000002  4604              MOV      r4,r0
;;;644    	// 添加命令头
;;;645    	CAN_PROTOCOL1_TxAddData(CAN_PROTOCOL1_CMD_HEAD);
000004  203a              MOVS     r0,#0x3a
000006  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;646    
;;;647    	// 添加设备地址
;;;648    	CAN_PROTOCOL1_TxAddData(CAN_PROTOCOL1_CMD_DEVICE_ADDR);
00000a  201a              MOVS     r0,#0x1a
00000c  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;649    
;;;650    	// 添加命令字
;;;651    	CAN_PROTOCOL1_TxAddData(cmdWord);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;652    
;;;653    	CAN_PROTOCOL1_TxAddData(0); // 数据长度
000016  2000              MOVS     r0,#0
000018  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;654    
;;;655    	CAN_PROTOCOL1_TxAddFrame();
00001c  f7fffffe          BL       CAN_PROTOCOL1_TxAddFrame
;;;656    }
000020  bd10              POP      {r4,pc}
                          ENDP


                          AREA ||i.CAN_PROTOCOL1_SendCmdWithResult||, CODE, READONLY, ALIGN=1

                  CAN_PROTOCOL1_SendCmdWithResult PROC
;;;621    // 发送命令带结果
;;;622    void CAN_PROTOCOL1_SendCmdWithResult(uint8 cmdWord, uint8 result)
000000  b530              PUSH     {r4,r5,lr}
;;;623    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;624    	// 添加命令头
;;;625    	CAN_PROTOCOL1_TxAddData(CAN_PROTOCOL1_CMD_HEAD);
000006  203a              MOVS     r0,#0x3a
000008  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;626    
;;;627    	// 添加设备地址
;;;628    	CAN_PROTOCOL1_TxAddData(CAN_PROTOCOL1_CMD_DEVICE_ADDR);
00000c  201a              MOVS     r0,#0x1a
00000e  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;629    
;;;630    	// 添加命令字
;;;631    	CAN_PROTOCOL1_TxAddData(cmdWord);
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;632    
;;;633    	// 添加数据长度
;;;634    	CAN_PROTOCOL1_TxAddData(1);
000018  2001              MOVS     r0,#1
00001a  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;635    
;;;636    	CAN_PROTOCOL1_TxAddData(result);
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;637    
;;;638    	CAN_PROTOCOL1_TxAddFrame();
000024  f7fffffe          BL       CAN_PROTOCOL1_TxAddFrame
;;;639    }
000028  bd30              POP      {r4,r5,pc}
;;;640    
                          ENDP


                          AREA ||i.CAN_PROTOCOL1_SendLdoV||, CODE, READONLY, ALIGN=1

                  CAN_PROTOCOL1_SendLdoV PROC
;;;598    // 发送命令带结果
;;;599    void CAN_PROTOCOL1_SendLdoV(uint8 cmdWord, uint32 result)
000000  b530              PUSH     {r4,r5,lr}
;;;600    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;601    	// 添加命令头
;;;602    	CAN_PROTOCOL1_TxAddData(CAN_PROTOCOL1_CMD_HEAD);
000006  203a              MOVS     r0,#0x3a
000008  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;603    
;;;604    	// 添加设备地址
;;;605    	CAN_PROTOCOL1_TxAddData(CAN_PROTOCOL1_CMD_DEVICE_ADDR);
00000c  201a              MOVS     r0,#0x1a
00000e  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;606    
;;;607    	// 添加命令字
;;;608    	CAN_PROTOCOL1_TxAddData(cmdWord);
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;609    
;;;610    	// 添加数据长度
;;;611    	CAN_PROTOCOL1_TxAddData(4);
000018  2004              MOVS     r0,#4
00001a  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;612    
;;;613    	CAN_PROTOCOL1_TxAddData((result >> 24) & 0xFF);
00001e  0e20              LSRS     r0,r4,#24
000020  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;614    	CAN_PROTOCOL1_TxAddData((result >> 16) & 0xFF);
000024  f3c44007          UBFX     r0,r4,#16,#8
000028  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;615    	CAN_PROTOCOL1_TxAddData((result >> 8) & 0xFF);
00002c  f3c42007          UBFX     r0,r4,#8,#8
000030  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;616    	CAN_PROTOCOL1_TxAddData((result >> 0) & 0xFF);
000034  b2e0              UXTB     r0,r4
000036  f7fffffe          BL       CAN_PROTOCOL1_TxAddData
;;;617    
;;;618    	CAN_PROTOCOL1_TxAddFrame();
00003a  f7fffffe          BL       CAN_PROTOCOL1_TxAddFrame
;;;619    }
00003e  bd30              POP      {r4,r5,pc}
;;;620    
                          ENDP


                          AREA ||i.CAN_PROTOCOL1_StartTimeoutCheckTask||, CODE, READONLY, ALIGN=1

                  CAN_PROTOCOL1_StartTimeoutCheckTask PROC
;;;72     // 启动通讯超时判断任务
;;;73     void CAN_PROTOCOL1_StartTimeoutCheckTask(void)
000000  4770              BX       lr
;;;74     {
;;;75     }
;;;76     
                          ENDP


                          AREA ||i.CAN_PROTOCOL1_TxAddData||, CODE, READONLY, ALIGN=2

                  CAN_PROTOCOL1_TxAddData PROC
;;;115    // 向发送命令帧队列中添加数据
;;;116    void CAN_PROTOCOL1_TxAddData(uint8 data)
000000  b530              PUSH     {r4,r5,lr}
;;;117    {
000002  4602              MOV      r2,r0
;;;118    	uint16 head = canProtocol1CB.tx.head;
000004  4912              LDR      r1,|L15.80|
000006  f8b138a4          LDRH     r3,[r1,#0x8a4]
;;;119    	uint16 end = canProtocol1CB.tx.end;
00000a  f8b148a6          LDRH     r4,[r1,#0x8a6]
;;;120    	CAN_PROTOCOL1_TX_CMD_FRAME *pCmdFrame = &canProtocol1CB.tx.cmdQueue[canProtocol1CB.tx.end];
00000e  f8b118a6          LDRH     r1,[r1,#0x8a6]
000012  254d              MOVS     r5,#0x4d
000014  4369              MULS     r1,r5,r1
000016  4d0f              LDR      r5,|L15.84|
000018  eb050041          ADD      r0,r5,r1,LSL #1
;;;121    
;;;122    	// 发送缓冲区已满，不予接收
;;;123    	if ((end + 1) % CAN_PROTOCOL1_TX_QUEUE_SIZE == head)
00001c  1c61              ADDS     r1,r4,#1
00001e  17cd              ASRS     r5,r1,#31
000020  eb017555          ADD      r5,r1,r5,LSR #29
000024  10ed              ASRS     r5,r5,#3
000026  eba105c5          SUB      r5,r1,r5,LSL #3
00002a  429d              CMP      r5,r3
00002c  d100              BNE      |L15.48|
                  |L15.46|
;;;124    	{
;;;125    		return;
;;;126    	}
;;;127    
;;;128    	// 队尾命令帧已满，退出
;;;129    	if (pCmdFrame->length >= CAN_PROTOCOL1_TX_CMD_FRAME_LENGTH_MAX)
;;;130    	{
;;;131    		return;
;;;132    	}
;;;133    
;;;134    	// 数据添加到帧末尾，并更新帧长度
;;;135    	pCmdFrame->buff[pCmdFrame->length] = data;
;;;136    	pCmdFrame->length++;
;;;137    }
00002e  bd30              POP      {r4,r5,pc}
                  |L15.48|
000030  f8b01098          LDRH     r1,[r0,#0x98]         ;129
000034  2996              CMP      r1,#0x96              ;129
000036  db00              BLT      |L15.58|
000038  e7f9              B        |L15.46|
                  |L15.58|
00003a  f8b05098          LDRH     r5,[r0,#0x98]         ;135
00003e  1c81              ADDS     r1,r0,#2              ;135
000040  554a              STRB     r2,[r1,r5]            ;135
000042  f8b01098          LDRH     r1,[r0,#0x98]         ;136
000046  1c49              ADDS     r1,r1,#1              ;136
000048  f8a01098          STRH     r1,[r0,#0x98]         ;136
00004c  bf00              NOP      
00004e  e7ee              B        |L15.46|
;;;138    
                          ENDP

                  |L15.80|
                          DCD      canProtocol1CB
                  |L15.84|
                          DCD      canProtocol1CB+0x3d4

                          AREA ||i.CAN_PROTOCOL1_TxAddFrame||, CODE, READONLY, ALIGN=2

                  CAN_PROTOCOL1_TxAddFrame PROC
;;;139    // 确认添加命令帧，即承认之前填充的数据为命令帧，将其添加到发送队列中，由main进行调度发送，本函数内会自动校正命令长度，并添加校验码
;;;140    void CAN_PROTOCOL1_TxAddFrame(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;141    {
;;;142    	uint16 checkSum = 0;
000002  2200              MOVS     r2,#0
;;;143    	uint16 i = 0;
000004  2300              MOVS     r3,#0
;;;144    	uint16 head = canProtocol1CB.tx.head;
000006  4c3a              LDR      r4,|L16.240|
000008  f8b458a4          LDRH     r5,[r4,#0x8a4]
;;;145    	uint16 end = canProtocol1CB.tx.end;
00000c  f8b468a6          LDRH     r6,[r4,#0x8a6]
;;;146    	CAN_PROTOCOL1_TX_CMD_FRAME *pCmdFrame = &canProtocol1CB.tx.cmdQueue[canProtocol1CB.tx.end];
000010  f8b448a6          LDRH     r4,[r4,#0x8a6]
000014  274d              MOVS     r7,#0x4d
000016  437c              MULS     r4,r7,r4
000018  4f36              LDR      r7,|L16.244|
00001a  eb070044          ADD      r0,r7,r4,LSL #1
;;;147    	uint16 length = pCmdFrame->length;
00001e  f8b01098          LDRH     r1,[r0,#0x98]
;;;148    
;;;149    	// 发送缓冲区已满，不予接收
;;;150    	if ((end + 1) % CAN_PROTOCOL1_TX_QUEUE_SIZE == head)
000022  1c74              ADDS     r4,r6,#1
000024  17e7              ASRS     r7,r4,#31
000026  eb047757          ADD      r7,r4,r7,LSR #29
00002a  10ff              ASRS     r7,r7,#3
00002c  eba407c7          SUB      r7,r4,r7,LSL #3
000030  42af              CMP      r7,r5
000032  d100              BNE      |L16.54|
                  |L16.52|
;;;151    	{
;;;152    		return;
;;;153    	}
;;;154    
;;;155    	// 命令帧长度不足，清除已填充的数据，退出
;;;156    	if (CAN_PROTOCOL1_CMD_FRAME_LENGTH_MIN - 4 > length) // 减去"校验和L、校验和H、结束标识0xD、结束标识OxA"4个字节
;;;157    	{
;;;158    		pCmdFrame->length = 0;
;;;159    
;;;160    		return;
;;;161    	}
;;;162    
;;;163    	// 队尾命令帧已满，退出
;;;164    	if ((length >= CAN_PROTOCOL1_TX_CMD_FRAME_LENGTH_MAX) || (length + 1 >= CAN_PROTOCOL1_TX_CMD_FRAME_LENGTH_MAX) || (length + 2 >= CAN_PROTOCOL1_TX_CMD_FRAME_LENGTH_MAX) || (length + 3 >= CAN_PROTOCOL1_TX_CMD_FRAME_LENGTH_MAX))
;;;165    	{
;;;166    		return;
;;;167    	}
;;;168    
;;;169    	// 重新设置数据长度，系统在准备数据时，填充的"数据长度"可以为任意值，并且不需要添加校验码，在这里重新设置为正确的值
;;;170    	pCmdFrame->buff[CAN_PROTOCOL1_CMD_LENGTH_INDEX] = length - 4; // 重设数据长度，减去"命令头、设备地址、命令字、数据长度"4个字节
;;;171    	for (i = 1; i < length; i++)
;;;172    	{
;;;173    		checkSum += pCmdFrame->buff[i];
;;;174    	}
;;;175    	pCmdFrame->buff[pCmdFrame->length++] = (checkSum & 0x00FF);		   // 低字节在前
;;;176    	pCmdFrame->buff[pCmdFrame->length++] = ((checkSum >> 8) & 0x00FF); // 高字节在后
;;;177    
;;;178    	// 结束标识
;;;179    	pCmdFrame->buff[pCmdFrame->length++] = 0x0D;
;;;180    	pCmdFrame->buff[pCmdFrame->length++] = 0x0A;
;;;181    
;;;182    	canProtocol1CB.tx.end++;
;;;183    	canProtocol1CB.tx.end %= CAN_PROTOCOL1_TX_QUEUE_SIZE;
;;;184    	// pCB->tx.cmdQueue[pCB->tx.end].length = 0;   //2015.12.2修改
;;;185    }
000034  bdf0              POP      {r4-r7,pc}
                  |L16.54|
000036  2904              CMP      r1,#4                 ;156
000038  da03              BGE      |L16.66|
00003a  2400              MOVS     r4,#0                 ;158
00003c  f8a04098          STRH     r4,[r0,#0x98]         ;158
000040  e7f8              B        |L16.52|
                  |L16.66|
000042  2996              CMP      r1,#0x96              ;164
000044  da08              BGE      |L16.88|
000046  1c4c              ADDS     r4,r1,#1              ;164
000048  2c96              CMP      r4,#0x96              ;164
00004a  da05              BGE      |L16.88|
00004c  1c8c              ADDS     r4,r1,#2              ;164
00004e  2c96              CMP      r4,#0x96              ;164
000050  da02              BGE      |L16.88|
000052  1ccc              ADDS     r4,r1,#3              ;164
000054  2c96              CMP      r4,#0x96              ;164
000056  db00              BLT      |L16.90|
                  |L16.88|
000058  e7ec              B        |L16.52|
                  |L16.90|
00005a  1f0c              SUBS     r4,r1,#4              ;170
00005c  7144              STRB     r4,[r0,#5]            ;170
00005e  2301              MOVS     r3,#1                 ;171
000060  e005              B        |L16.110|
                  |L16.98|
000062  1c84              ADDS     r4,r0,#2              ;173
000064  5ce4              LDRB     r4,[r4,r3]            ;173
000066  4414              ADD      r4,r4,r2              ;173
000068  b2a2              UXTH     r2,r4                 ;173
00006a  1c5c              ADDS     r4,r3,#1              ;171
00006c  b2a3              UXTH     r3,r4                 ;171
                  |L16.110|
00006e  428b              CMP      r3,r1                 ;171
000070  dbf7              BLT      |L16.98|
000072  f8b0c098          LDRH     r12,[r0,#0x98]        ;175
000076  f10c0401          ADD      r4,r12,#1             ;175
00007a  f8a04098          STRH     r4,[r0,#0x98]         ;175
00007e  1c84              ADDS     r4,r0,#2              ;175
000080  f804200c          STRB     r2,[r4,r12]           ;175
000084  0a17              LSRS     r7,r2,#8              ;176
000086  f8b0c098          LDRH     r12,[r0,#0x98]        ;176
00008a  f10c0401          ADD      r4,r12,#1             ;176
00008e  f8a04098          STRH     r4,[r0,#0x98]         ;176
000092  1c84              ADDS     r4,r0,#2              ;176
000094  f804700c          STRB     r7,[r4,r12]           ;176
000098  270d              MOVS     r7,#0xd               ;179
00009a  f8b0c098          LDRH     r12,[r0,#0x98]        ;179
00009e  f10c0401          ADD      r4,r12,#1             ;179
0000a2  f8a04098          STRH     r4,[r0,#0x98]         ;179
0000a6  1c84              ADDS     r4,r0,#2              ;179
0000a8  f804700c          STRB     r7,[r4,r12]           ;179
0000ac  270a              MOVS     r7,#0xa               ;180
0000ae  f8b0c098          LDRH     r12,[r0,#0x98]        ;180
0000b2  f10c0401          ADD      r4,r12,#1             ;180
0000b6  f8a04098          STRH     r4,[r0,#0x98]         ;180
0000ba  1c84              ADDS     r4,r0,#2              ;180
0000bc  f804700c          STRB     r7,[r4,r12]           ;180
0000c0  4c0b              LDR      r4,|L16.240|
0000c2  f8b448a6          LDRH     r4,[r4,#0x8a6]        ;182
0000c6  1c64              ADDS     r4,r4,#1              ;182
0000c8  b2a7              UXTH     r7,r4                 ;182
0000ca  4c09              LDR      r4,|L16.240|
0000cc  f8a478a6          STRH     r7,[r4,#0x8a6]        ;182
0000d0  4627              MOV      r7,r4                 ;183
0000d2  f8b748a6          LDRH     r4,[r7,#0x8a6]        ;183
0000d6  17e7              ASRS     r7,r4,#31             ;183
0000d8  eb047757          ADD      r7,r4,r7,LSR #29      ;183
0000dc  10ff              ASRS     r7,r7,#3              ;183
0000de  eba407c7          SUB      r7,r4,r7,LSL #3       ;183
0000e2  fa1ffc87          UXTH     r12,r7                ;183
0000e6  4f02              LDR      r7,|L16.240|
0000e8  f8a7c8a6          STRH     r12,[r7,#0x8a6]       ;183
0000ec  bf00              NOP      
0000ee  e7a1              B        |L16.52|
;;;186    
                          ENDP

                  |L16.240|
                          DCD      canProtocol1CB
                  |L16.244|
                          DCD      canProtocol1CB+0x3d4

                          AREA ||i.CAN_PROTOCOL1_TxStateProcess||, CODE, READONLY, ALIGN=2

                  CAN_PROTOCOL1_TxStateProcess PROC
;;;283    // 协议层发送处理过程
;;;284    void CAN_PROTOCOL1_TxStateProcess(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;285    {
;;;286    	uint16 head = canProtocol1CB.tx.head;
000004  4822              LDR      r0,|L17.144|
000006  f8b048a4          LDRH     r4,[r0,#0x8a4]
;;;287    	uint16 end = canProtocol1CB.tx.end;
00000a  f8b058a6          LDRH     r5,[r0,#0x8a6]
;;;288    	uint16 length = canProtocol1CB.tx.cmdQueue[head].length;
00000e  204d              MOVS     r0,#0x4d
000010  4360              MULS     r0,r4,r0
000012  4920              LDR      r1,|L17.148|
000014  eb010040          ADD      r0,r1,r0,LSL #1
000018  f8b06098          LDRH     r6,[r0,#0x98]
;;;289    	uint8 *pCmd = canProtocol1CB.tx.cmdQueue[head].buff;
00001c  204d              MOVS     r0,#0x4d
00001e  4360              MULS     r0,r4,r0
000020  eb010040          ADD      r0,r1,r0,LSL #1
000024  1c87              ADDS     r7,r0,#2
;;;290    	uint16 localDeviceID = canProtocol1CB.tx.cmdQueue[head].deviceID;
000026  204d              MOVS     r0,#0x4d
000028  4360              MULS     r0,r4,r0
00002a  f8318010          LDRH     r8,[r1,r0,LSL #1]
;;;291    
;;;292    	// 发送缓冲区为空，说明无数据
;;;293    	if (head == end)
00002e  42ac              CMP      r4,r5
000030  d101              BNE      |L17.54|
                  |L17.50|
;;;294    	{
;;;295    		return;
;;;296    	}
;;;297    
;;;298    	// 发送函数没有注册直接返回
;;;299    	if (NULL == canProtocol1CB.sendDataThrowService)
;;;300    	{
;;;301    		return;
;;;302    	}
;;;303    
;;;304    	// 协议层有数据需要发送到驱动层
;;;305    	if (!(*canProtocol1CB.sendDataThrowService)(localDeviceID, pCmd, length))
;;;306    	{
;;;307    		return;
;;;308    	}
;;;309    
;;;310    	// 发送环形队列更新位置
;;;311    	canProtocol1CB.tx.cmdQueue[head].length = 0;
;;;312    	canProtocol1CB.tx.head++;
;;;313    	canProtocol1CB.tx.head %= CAN_PROTOCOL1_TX_QUEUE_SIZE;
;;;314    }
000032  e8bd81f0          POP      {r4-r8,pc}
                  |L17.54|
000036  4816              LDR      r0,|L17.144|
000038  f8d008ac          LDR      r0,[r0,#0x8ac]        ;299  ; canProtocol1CB
00003c  b900              CBNZ     r0,|L17.64|
00003e  e7f8              B        |L17.50|
                  |L17.64|
000040  b2f2              UXTB     r2,r6                 ;305
000042  4813              LDR      r0,|L17.144|
000044  4639              MOV      r1,r7                 ;305
000046  f8d038ac          LDR      r3,[r0,#0x8ac]        ;305  ; canProtocol1CB
00004a  4640              MOV      r0,r8                 ;305
00004c  4798              BLX      r3                    ;305
00004e  b900              CBNZ     r0,|L17.82|
000050  e7ef              B        |L17.50|
                  |L17.82|
000052  2200              MOVS     r2,#0                 ;311
000054  204d              MOVS     r0,#0x4d              ;311
000056  4360              MULS     r0,r4,r0              ;311
000058  490e              LDR      r1,|L17.148|
00005a  eb010040          ADD      r0,r1,r0,LSL #1       ;311
00005e  f8a02098          STRH     r2,[r0,#0x98]         ;311
000062  480b              LDR      r0,|L17.144|
000064  f8b008a4          LDRH     r0,[r0,#0x8a4]        ;312
000068  1c40              ADDS     r0,r0,#1              ;312
00006a  b281              UXTH     r1,r0                 ;312
00006c  4808              LDR      r0,|L17.144|
00006e  f8a018a4          STRH     r1,[r0,#0x8a4]        ;312
000072  4601              MOV      r1,r0                 ;313
000074  f8b108a4          LDRH     r0,[r1,#0x8a4]        ;313
000078  17c1              ASRS     r1,r0,#31             ;313
00007a  eb007151          ADD      r1,r0,r1,LSR #29      ;313
00007e  10c9              ASRS     r1,r1,#3              ;313
000080  eba001c1          SUB      r1,r0,r1,LSL #3       ;313
000084  b28a              UXTH     r2,r1                 ;313
000086  4902              LDR      r1,|L17.144|
000088  f8a128a4          STRH     r2,[r1,#0x8a4]        ;313
00008c  bf00              NOP      
00008e  e7d0              B        |L17.50|
;;;315    
                          ENDP

                  |L17.144|
                          DCD      canProtocol1CB
                  |L17.148|
                          DCD      canProtocol1CB+0x3d4

                          AREA ||i.CAN_PROTOCOL_Process_3A||, CODE, READONLY, ALIGN=2

                  CAN_PROTOCOL_Process_3A PROC
;;;102    // UART协议层过程处理
;;;103    void CAN_PROTOCOL_Process_3A(void)
000000  b510              PUSH     {r4,lr}
;;;104    {
;;;105    	// UART接收FIFO缓冲区处理
;;;106    	CAN_PROTOCOL1_RxFIFOProcess(&canProtocol1CB);
000002  4804              LDR      r0,|L18.20|
000004  f7fffffe          BL       CAN_PROTOCOL1_RxFIFOProcess
;;;107    
;;;108    	// UART接收命令缓冲区处理
;;;109    	CAN_PROTOCOL1_CmdFrameProcess(&canProtocol1CB);
000008  4802              LDR      r0,|L18.20|
00000a  f7fffffe          BL       CAN_PROTOCOL1_CmdFrameProcess
;;;110    
;;;111    	// UART协议层发送处理过程
;;;112    	CAN_PROTOCOL1_TxStateProcess();
00000e  f7fffffe          BL       CAN_PROTOCOL1_TxStateProcess
;;;113    }
000012  bd10              POP      {r4,pc}
;;;114    
                          ENDP

                  |L18.20|
                          DCD      canProtocol1CB

                          AREA ||i.can_test||, CODE, READONLY, ALIGN=1

                  can_test PROC
;;;76     
;;;77     void can_test(uint32 temp)
000000  b510              PUSH     {r4,lr}
;;;78     {
000002  4604              MOV      r4,r0
;;;79     	CAN_PROTOCOL1_SendCmdWithResult(0x88, FALSE);
000004  2100              MOVS     r1,#0
000006  2088              MOVS     r0,#0x88
000008  f7fffffe          BL       CAN_PROTOCOL1_SendCmdWithResult
;;;80     }
00000c  bd10              POP      {r4,pc}
;;;81     
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  canProtocol1CB
                          %        2224

;*** Start embedded assembler ***

#line 1 "User\\CanProtocol1.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_CanProtocol1_c_a6b80008____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___14_CanProtocol1_c_a6b80008____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_CanProtocol1_c_a6b80008____REVSH|
#line 128
|__asm___14_CanProtocol1_c_a6b80008____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
