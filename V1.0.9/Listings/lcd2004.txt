; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\lcd2004.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\lcd2004.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -I.\User\qrencode -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.3\Device\Include -D__MICROLIB -D__UVISION_VERSION=539 -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\lcd2004.crf User\Lcd2004.c]
                          THUMB

                          AREA ||i.Clear_All_Lines||, CODE, READONLY, ALIGN=1

                  Clear_All_Lines PROC
;;;460    **************************************************************/
;;;461    void Clear_All_Lines(void)
000000  b510              PUSH     {r4,lr}
;;;462    {
;;;463        uint8_t y;
;;;464    
;;;465        for (y = 0; y < MAX_LINES; y++)
000002  2400              MOVS     r4,#0
                  |L1.4|
;;;466        {
;;;467            Clear_Line(y);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       Clear_Line
00000a  1c64              ADDS     r4,r4,#1              ;465
00000c  b2e4              UXTB     r4,r4                 ;465
00000e  2c04              CMP      r4,#4                 ;465
000010  d3f8              BCC      |L1.4|
;;;468        }
;;;469    }
000012  bd10              POP      {r4,pc}
;;;470    
                          ENDP


                          AREA ||i.Clear_Line||, CODE, READONLY, ALIGN=2

                  Clear_Line PROC
;;;436    **************************************************************/
;;;437    void Clear_Line(uint8_t y)
000000  b57c              PUSH     {r2-r6,lr}
;;;438    {
;;;439        uint8_t i;
;;;440        uint8_t line[5] = {0x00, 0x40, 0x14, 0x54};
000002  490b              LDR      r1,|L2.48|
000004  c906              LDM      r1,{r1,r2}
000006  e9cd1200          STRD     r1,r2,[sp,#0]
;;;441        uint8_t lineOffset = 0;
;;;442    
;;;443        // 计算行偏移地址，最高位设置为1，表示控制命令
;;;444        lineOffset = line[y] | 0x80;
00000a  f81d0000          LDRB     r0,[sp,r0]
00000e  f0400580          ORR      r5,r0,#0x80
;;;445    
;;;446        for (i = 0; i < MAX_ONE_LINES_LENGTH; i++)
000012  2400              MOVS     r4,#0
                  |L2.20|
;;;447        {
;;;448            wr_lcd(comm, lineOffset + i);
000014  1928              ADDS     r0,r5,r4
000016  b2c1              UXTB     r1,r0
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       wr_lcd
;;;449            wr_lcd(dat, ' '); // 用空格字符替换内容
00001e  2120              MOVS     r1,#0x20
000020  2001              MOVS     r0,#1
000022  f7fffffe          BL       wr_lcd
000026  1c64              ADDS     r4,r4,#1              ;446
000028  b2e4              UXTB     r4,r4                 ;446
00002a  2c14              CMP      r4,#0x14              ;446
00002c  d3f2              BCC      |L2.20|
;;;450        }
;;;451    }
00002e  bd7c              POP      {r2-r6,pc}
;;;452    
                          ENDP

                  |L2.48|
                          DCD      ||.constdata||

                          AREA ||i.Display_Centered||, CODE, READONLY, ALIGN=2

                  Display_Centered PROC
;;;294    **************************************************************/
;;;295    void Display_Centered(uint8_t y, const char *code)
000000  b5f8              PUSH     {r3-r7,lr}
;;;296    {
000002  4606              MOV      r6,r0
000004  460f              MOV      r7,r1
;;;297        uint8_t line[] = {0x00, 0x40, 0x14, 0x54};
000006  a012              ADR      r0,|L3.80|
000008  6800              LDR      r0,[r0,#0]
00000a  9000              STR      r0,[sp,#0]
;;;298        uint8_t x = 0;
;;;299        uint8_t lineOffset = 0;
;;;300        uint8_t i = 0;
00000c  2400              MOVS     r4,#0
;;;301        uint8_t len = 0;
;;;302    
;;;303        len = strlen(code);
00000e  4638              MOV      r0,r7
000010  f7fffffe          BL       strlen
000014  b2c5              UXTB     r5,r0
;;;304        if (MAX_ONE_LINES_LENGTH < len)
000016  2d14              CMP      r5,#0x14
000018  d900              BLS      |L3.28|
;;;305        {
;;;306            len = MAX_ONE_LINES_LENGTH;
00001a  2514              MOVS     r5,#0x14
                  |L3.28|
;;;307        }
;;;308    
;;;309        // 计算居中的起始位置
;;;310        x = (MAX_ONE_LINES_LENGTH - len) / 2;
00001c  f1c50014          RSB      r0,r5,#0x14
000020  eb0070d0          ADD      r0,r0,r0,LSR #31
000024  f3c00047          UBFX     r0,r0,#1,#8
;;;311        lineOffset = line[y] | 0x80;
000028  f81d1006          LDRB     r1,[sp,r6]
00002c  f0410180          ORR      r1,r1,#0x80
;;;312        for (i = 0; i < len; i++)
;;;313        {
;;;314            wr_lcd(comm, lineOffset + x + i);
000030  180e              ADDS     r6,r1,r0
000032  e00a              B        |L3.74|
                  |L3.52|
000034  1930              ADDS     r0,r6,r4
000036  b2c1              UXTB     r1,r0
000038  2000              MOVS     r0,#0
00003a  f7fffffe          BL       wr_lcd
;;;315            wr_lcd(dat, code[i]);
00003e  5d39              LDRB     r1,[r7,r4]
000040  2001              MOVS     r0,#1
000042  f7fffffe          BL       wr_lcd
000046  1c64              ADDS     r4,r4,#1              ;312
000048  b2e4              UXTB     r4,r4                 ;312
                  |L3.74|
00004a  42ac              CMP      r4,r5                 ;312
00004c  d3f2              BCC      |L3.52|
;;;316        }
;;;317    }
00004e  bdf8              POP      {r3-r7,pc}
;;;318    
                          ENDP

                  |L3.80|
000050  00                DCB      0
000051  401454            DCB      "@",20,"T"

                          AREA ||i.Display_Centered_Format||, CODE, READONLY, ALIGN=2

                  Display_Centered_Format PROC
;;;380     */
;;;381    void Display_Centered_Format(uint8_t y, const char *format, ...)
000000  b40f              PUSH     {r0-r3}
;;;382    {
000002  b5f0              PUSH     {r4-r7,lr}
000004  b089              SUB      sp,sp,#0x24
000006  4607              MOV      r7,r0
;;;383        uint8_t len = 0;
;;;384        uint8_t line[] = {0x00, 0x40, 0x14, 0x54};
000008  a01a              ADR      r0,|L4.116|
00000a  6800              LDR      r0,[r0,#0]
00000c  9008              STR      r0,[sp,#0x20]
;;;385        int n = 0;
;;;386        uint8_t x = 0;
;;;387        uint8_t lineOffset = 0;
;;;388        uint8_t i = 0;
00000e  2400              MOVS     r4,#0
;;;389    
;;;390        // 将可变参数列表存储在va_list中
;;;391        va_list args;
;;;392        va_start(args, format);
000010  ab10              ADD      r3,sp,#0x40
;;;393    
;;;394        // 假设显示的字符串最长为20个字符
;;;395        char code[MAX_ONE_LINES_LENGTH + 1];
;;;396    
;;;397        // 使用vsnprintf来格式化可变参数列表
;;;398        n = vsnprintf(code, sizeof(code), format, args);
000012  2115              MOVS     r1,#0x15
000014  a801              ADD      r0,sp,#4
000016  9a0f              LDR      r2,[sp,#0x3c]
000018  f7fffffe          BL       vsnprintf
00001c  4606              MOV      r6,r0
;;;399        len = strlen(code);
00001e  a801              ADD      r0,sp,#4
000020  f7fffffe          BL       strlen
000024  b2c5              UXTB     r5,r0
;;;400    
;;;401        // 清理va_list
;;;402        va_end(args);
000026  2000              MOVS     r0,#0
000028  9007              STR      r0,[sp,#0x1c]
;;;403    
;;;404        // 格式化失败或结果字符串长度超过了最大长度
;;;405        if ((n < 0) || (n >= sizeof(code)))
00002a  2e00              CMP      r6,#0
00002c  db1e              BLT      |L4.108|
00002e  2e15              CMP      r6,#0x15
000030  d21c              BCS      |L4.108|
;;;406        {
;;;407            return;
;;;408        }
;;;409    
;;;410        if (MAX_ONE_LINES_LENGTH < len)
000032  2d14              CMP      r5,#0x14
000034  d900              BLS      |L4.56|
;;;411        {
;;;412            len = MAX_ONE_LINES_LENGTH;
000036  2514              MOVS     r5,#0x14
                  |L4.56|
;;;413        }
;;;414    
;;;415        // 计算居中的起始位置
;;;416        x = (MAX_ONE_LINES_LENGTH - len) / 2;
000038  f1c50014          RSB      r0,r5,#0x14
00003c  eb0070d0          ADD      r0,r0,r0,LSR #31
000040  f3c00147          UBFX     r1,r0,#1,#8
;;;417        lineOffset = line[y] | 0x80;
000044  a808              ADD      r0,sp,#0x20
000046  5dc0              LDRB     r0,[r0,r7]
000048  f0400080          ORR      r0,r0,#0x80
00004c  af01              ADD      r7,sp,#4              ;395
;;;418    
;;;419        for (i = 0; i < len; i++)
;;;420        {
;;;421            wr_lcd(comm, lineOffset + x + i);
00004e  1846              ADDS     r6,r0,r1
000050  e00a              B        |L4.104|
                  |L4.82|
000052  1930              ADDS     r0,r6,r4
000054  b2c1              UXTB     r1,r0
000056  2000              MOVS     r0,#0
000058  f7fffffe          BL       wr_lcd
;;;422            wr_lcd(dat, code[i]);
00005c  5d39              LDRB     r1,[r7,r4]
00005e  2001              MOVS     r0,#1
000060  f7fffffe          BL       wr_lcd
000064  1c64              ADDS     r4,r4,#1              ;419
000066  b2e4              UXTB     r4,r4                 ;419
                  |L4.104|
000068  42ac              CMP      r4,r5                 ;419
00006a  d3f2              BCC      |L4.82|
                  |L4.108|
;;;423        }
;;;424    }
00006c  b009              ADD      sp,sp,#0x24
00006e  bcf0              POP      {r4-r7}
000070  f85dfb14          LDR      pc,[sp],#0x14
;;;425    
                          ENDP

                  |L4.116|
000074  00                DCB      0
000075  401454            DCB      "@",20,"T"

                          AREA ||i.Display_Max||, CODE, READONLY, ALIGN=2

                  Display_Max PROC
;;;152    **************************************************************/
;;;153    void Display_Max(const char *code)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;154    {
000004  4606              MOV      r6,r0
;;;155        // 每一行的起始地址
;;;156        uint8_t line[] = {0x00, 0x40, 0x14, 0x54};
000006  a013              ADR      r0,|L5.84|
000008  6800              LDR      r0,[r0,#0]
00000a  9000              STR      r0,[sp,#0]
;;;157        uint8_t lineOffset = 0;
;;;158        uint8_t i = 0;
00000c  2400              MOVS     r4,#0
;;;159        uint8_t len = strlen(code);
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       strlen
000014  b2c5              UXTB     r5,r0
;;;160    
;;;161        // 如果长度超过LCD屏幕显示的最大长度，进行截断
;;;162        if (MAX_ALL_LENGTH > len)
000016  2d50              CMP      r5,#0x50
000018  d200              BCS      |L5.28|
;;;163        {
;;;164            len = MAX_ALL_LENGTH;
00001a  2550              MOVS     r5,#0x50
                  |L5.28|
00001c  466f              MOV      r7,sp                 ;156
00001e  f04f0814          MOV      r8,#0x14              ;158
;;;165        }
;;;166    
;;;167        for (i = 0; i < len; i++)
000022  e013              B        |L5.76|
                  |L5.36|
;;;168        {
;;;169            // 当字符序号为一行最大长度时，需要切换到下一行
;;;170            if ((MAX_ONE_LINES_LENGTH == i)
000024  2c14              CMP      r4,#0x14
000026  d003              BEQ      |L5.48|
;;;171                    || (MAX_TWO_LINES_LENGTH == i) || (MAX_THREE_LENGTH_LENGTH == i))
000028  2c28              CMP      r4,#0x28
00002a  d001              BEQ      |L5.48|
00002c  2c3c              CMP      r4,#0x3c
00002e  d107              BNE      |L5.64|
                  |L5.48|
;;;172            {
;;;173                lineOffset = line[i / MAX_ONE_LINES_LENGTH] | 0x80;   // 计算下一行的LCD命令值
000030  fbb4f0f8          UDIV     r0,r4,r8
000034  5c38              LDRB     r0,[r7,r0]
000036  f0400180          ORR      r1,r0,#0x80
;;;174                wr_lcd(comm, lineOffset);           // 发送LCD命令值切换到下一行
00003a  2000              MOVS     r0,#0
00003c  f7fffffe          BL       wr_lcd
                  |L5.64|
;;;175            }
;;;176    
;;;177            wr_lcd(dat, code[i]);   // 发送字符数据到LCD进行显示
000040  5d31              LDRB     r1,[r6,r4]
000042  2001              MOVS     r0,#1
000044  f7fffffe          BL       wr_lcd
000048  1c64              ADDS     r4,r4,#1              ;167
00004a  b2e4              UXTB     r4,r4                 ;167
                  |L5.76|
00004c  42ac              CMP      r4,r5                 ;167
00004e  d3e9              BCC      |L5.36|
;;;178        }
;;;179    }
000050  e8bd83f8          POP      {r3-r9,pc}
;;;180    
                          ENDP

                  |L5.84|
000054  00                DCB      0
000055  401454            DCB      "@",20,"T"

                          AREA ||i.Display_Y||, CODE, READONLY, ALIGN=2

                  Display_Y PROC
;;;116    **************************************************************/
;;;117    void Display_Y(uint8_t y, const char *code)
000000  b5f8              PUSH     {r3-r7,lr}
;;;118    {
000002  4607              MOV      r7,r0
000004  460e              MOV      r6,r1
;;;119        uint8_t len = 0;
;;;120        uint8_t i = 0;
000006  2400              MOVS     r4,#0
;;;121    
;;;122        // 每一行的起始地址
;;;123        uint8_t line[] = {0x00, 0x40, 0x14, 0x54};
000008  a00d              ADR      r0,|L6.64|
00000a  6800              LDR      r0,[r0,#0]
00000c  9000              STR      r0,[sp,#0]
;;;124    
;;;125        // 获取字符串的长度
;;;126        len = strlen(code);
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       strlen
000014  b2c5              UXTB     r5,r0
;;;127    
;;;128        // 如果长度超过一行的最大长度，进行截断
;;;129        if (MAX_ONE_LINES_LENGTH < len)
000016  2d14              CMP      r5,#0x14
000018  d900              BLS      |L6.28|
;;;130        {
;;;131            len = MAX_ONE_LINES_LENGTH;
00001a  2514              MOVS     r5,#0x14
                  |L6.28|
;;;132        }
;;;133    
;;;134        // 设置光标位置到指定行数
;;;135        wr_lcd(comm, line[y] | 0x80);
00001c  f81d0007          LDRB     r0,[sp,r7]
000020  f0400180          ORR      r1,r0,#0x80
000024  2000              MOVS     r0,#0
000026  f7fffffe          BL       wr_lcd
;;;136    
;;;137        // 逐个字符写入数据
;;;138        for (i = 0; i < len; i++)
00002a  e005              B        |L6.56|
                  |L6.44|
;;;139        {
;;;140            wr_lcd(dat, code[i]);
00002c  5d31              LDRB     r1,[r6,r4]
00002e  2001              MOVS     r0,#1
000030  f7fffffe          BL       wr_lcd
000034  1c64              ADDS     r4,r4,#1              ;138
000036  b2e4              UXTB     r4,r4                 ;138
                  |L6.56|
000038  42ac              CMP      r4,r5                 ;138
00003a  d3f7              BCC      |L6.44|
;;;141        }
;;;142    }
00003c  bdf8              POP      {r3-r7,pc}
;;;143    
                          ENDP

00003e  0000              DCW      0x0000
                  |L6.64|
000040  00                DCB      0
000041  401454            DCB      "@",20,"T"

                          AREA ||i.Display_YX||, CODE, READONLY, ALIGN=2

                  Display_YX PROC
;;;264    **************************************************************/
;;;265    void Display_YX(uint8_t y, uint8_t x, const char *code)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;266    {
000004  460f              MOV      r7,r1
000006  4616              MOV      r6,r2
;;;267        uint8_t i;
;;;268        uint8_t lineOffset = 0;
;;;269    
;;;270        // 行偏移地址，每一行对应一个偏移值
;;;271        uint8_t line[] = {0x00, 0x40, 0x14, 0x54};
000008  a10e              ADR      r1,|L7.68|
00000a  6809              LDR      r1,[r1,#0]
00000c  9100              STR      r1,[sp,#0]
;;;272    
;;;273        // 计算行偏移地址，最高位设置为1，表示控制命令
;;;274        lineOffset = line[y] | 0x80;
00000e  f81d0000          LDRB     r0,[sp,r0]
000012  f0400880          ORR      r8,r0,#0x80
;;;275    
;;;276        // 遍历从x开始的字符，并检查是否超过屏幕范围或遇到字符串结束符
;;;277        for (i = x; (MAX_ONE_LINES_LENGTH > i) && (code[i - x] != '\0'); i++)
000016  463c              MOV      r4,r7
000018  e00b              B        |L7.50|
                  |L7.26|
;;;278        {
;;;279            wr_lcd(comm, lineOffset + i);    // 发送控制命令，设置显示位置为指定行的第i列
00001a  eb080004          ADD      r0,r8,r4
00001e  b2c1              UXTB     r1,r0
000020  2000              MOVS     r0,#0
000022  f7fffffe          BL       wr_lcd
;;;280            wr_lcd(dat, code[i - x]);     // 发送数据，将指定字符显示在屏幕上
000026  5d71              LDRB     r1,[r6,r5]
000028  2001              MOVS     r0,#1
00002a  f7fffffe          BL       wr_lcd
00002e  1c64              ADDS     r4,r4,#1              ;277
000030  b2e4              UXTB     r4,r4                 ;277
                  |L7.50|
000032  2c14              CMP      r4,#0x14              ;277
000034  d203              BCS      |L7.62|
000036  1be5              SUBS     r5,r4,r7              ;277
000038  5d70              LDRB     r0,[r6,r5]            ;277
00003a  2800              CMP      r0,#0                 ;277
00003c  d1ed              BNE      |L7.26|
                  |L7.62|
;;;281        }
;;;282    }
00003e  e8bd83f8          POP      {r3-r9,pc}
;;;283    
                          ENDP

000042  0000              DCW      0x0000
                  |L7.68|
000044  00                DCB      0
000045  401454            DCB      "@",20,"T"

                          AREA ||i.Display_YX_Format||, CODE, READONLY, ALIGN=2

                  Display_YX_Format PROC
;;;331    **************************************************************/
;;;332    void Display_YX_Format(uint8_t y, uint8_t x, const char *format, ...)
000000  b40f              PUSH     {r0-r3}
;;;333    {
000002  b5f0              PUSH     {r4-r7,lr}
000004  b087              SUB      sp,sp,#0x1c
000006  4607              MOV      r7,r0
000008  460d              MOV      r5,r1
;;;334        uint8_t line[] = {0x00, 0x40, 0x14, 0x54};
00000a  a019              ADR      r0,|L8.112|
00000c  6800              LDR      r0,[r0,#0]
00000e  9006              STR      r0,[sp,#0x18]
;;;335        uint8_t lineOffset = 0;
;;;336        uint8_t len = 0;
;;;337        uint8_t i = 0;
000010  2400              MOVS     r4,#0
;;;338        int n = 0;
;;;339    
;;;340        // 显示的字符串最长为20个字符
;;;341        char code[MAX_ONE_LINES_LENGTH];
;;;342    
;;;343        // 将可变参数列表存储在va_list中
;;;344        va_list args;
;;;345        va_start(args, format);
000012  ab0f              ADD      r3,sp,#0x3c
;;;346    
;;;347        // 使用vsnprintf来格式化可变参数列表
;;;348        n = vsnprintf(code, sizeof(code), format, args);
000014  2114              MOVS     r1,#0x14
000016  a801              ADD      r0,sp,#4
000018  9a0e              LDR      r2,[sp,#0x38]
00001a  f7fffffe          BL       vsnprintf
;;;349    
;;;350        // 清理va_list
;;;351        va_end(args);
00001e  2100              MOVS     r1,#0
000020  9100              STR      r1,[sp,#0]
;;;352    
;;;353        // 格式化失败或结果字符串长度超过了最大长度
;;;354        if (n < 0 || n >= sizeof(code))
000022  2800              CMP      r0,#0
000024  db1f              BLT      |L8.102|
000026  2814              CMP      r0,#0x14
000028  d21d              BCS      |L8.102|
;;;355        {
;;;356            return;
;;;357        }
;;;358    
;;;359        // 根据指定的坐标进行显示
;;;360        len = strlen(code);
00002a  a801              ADD      r0,sp,#4
00002c  f7fffffe          BL       strlen
000030  b2c0              UXTB     r0,r0
;;;361        len = (len > (MAX_ONE_LINES_LENGTH - x)) ? (MAX_ONE_LINES_LENGTH - x) : len;
000032  f1c50214          RSB      r2,r5,#0x14
000036  4282              CMP      r2,r0
000038  da00              BGE      |L8.60|
00003a  4610              MOV      r0,r2
                  |L8.60|
00003c  b2c6              UXTB     r6,r0
;;;362        lineOffset = line[y] | 0x80;
00003e  a806              ADD      r0,sp,#0x18
000040  5dc0              LDRB     r0,[r0,r7]
000042  f0400080          ORR      r0,r0,#0x80
000046  af01              ADD      r7,sp,#4              ;341
;;;363    
;;;364        for (i = 0; i < len; i++)
;;;365        {
;;;366            wr_lcd(comm, lineOffset + x + i);
000048  4405              ADD      r5,r5,r0
00004a  e00a              B        |L8.98|
                  |L8.76|
00004c  1928              ADDS     r0,r5,r4
00004e  b2c1              UXTB     r1,r0
000050  2000              MOVS     r0,#0
000052  f7fffffe          BL       wr_lcd
;;;367            wr_lcd(dat, code[i]);
000056  5d39              LDRB     r1,[r7,r4]
000058  2001              MOVS     r0,#1
00005a  f7fffffe          BL       wr_lcd
00005e  1c64              ADDS     r4,r4,#1              ;364
000060  b2e4              UXTB     r4,r4                 ;364
                  |L8.98|
000062  42b4              CMP      r4,r6                 ;364
000064  d3f2              BCC      |L8.76|
                  |L8.102|
;;;368        }
;;;369    }
000066  b007              ADD      sp,sp,#0x1c
000068  bcf0              POP      {r4-r7}
00006a  f85dfb14          LDR      pc,[sp],#0x14
;;;370    
                          ENDP

00006e  0000              DCW      0x0000
                  |L8.112|
000070  00                DCB      0
000071  401454            DCB      "@",20,"T"

                          AREA ||i.Display_YX_Max||, CODE, READONLY, ALIGN=2

                  Display_YX_Max PROC
;;;192    **************************************************************/
;;;193    void Display_YX_Max(uint8_t y, uint8_t x, const char *code)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;194    {
000004  b0b4              SUB      sp,sp,#0xd0
000006  460c              MOV      r4,r1
;;;195        char new_code[200];
;;;196        int spaces = 0;
000008  2300              MOVS     r3,#0
;;;197        uint8_t len = 0;
;;;198        uint8_t i = 0;
00000a  2100              MOVS     r1,#0
;;;199        uint8_t lineOffset = 0;
;;;200    
;;;201        // 每一行的起始地址
;;;202        uint8_t line[] = {0x00, 0x40, 0x14, 0x54};
00000c  a523              ADR      r5,|L9.156|
00000e  682d              LDR      r5,[r5,#0]
000010  9501              STR      r5,[sp,#4]
;;;203    
;;;204    
;;;205        // 根据行数计算填充空格数
;;;206        if (y == 0)
000012  2800              CMP      r0,#0
000014  d006              BEQ      |L9.36|
;;;207        {
;;;208            spaces = x;
;;;209        }
;;;210        else if (y == 1)
000016  2801              CMP      r0,#1
000018  d006              BEQ      |L9.40|
;;;211        {
;;;212            spaces = 20 + x;
;;;213        }
;;;214        else if (y == 2)
00001a  2802              CMP      r0,#2
00001c  d007              BEQ      |L9.46|
;;;215        {
;;;216            spaces = 40 + x;
;;;217        }
;;;218        else if (y == 3)
00001e  2803              CMP      r0,#3
000020  d008              BEQ      |L9.52|
000022  e009              B        |L9.56|
                  |L9.36|
000024  4623              MOV      r3,r4                 ;208
000026  e007              B        |L9.56|
                  |L9.40|
000028  f1040314          ADD      r3,r4,#0x14           ;212
00002c  e004              B        |L9.56|
                  |L9.46|
00002e  f1040328          ADD      r3,r4,#0x28           ;216
000032  e001              B        |L9.56|
                  |L9.52|
;;;219        {
;;;220            spaces = 60 + x;
000034  f104033c          ADD      r3,r4,#0x3c
                  |L9.56|
000038  ae02              ADD      r6,sp,#8              ;195
;;;221        }
;;;222    
;;;223        // 填充空格
;;;224        for (i = 0; i < spaces; i++)
;;;225        {
;;;226            new_code[i] = ' ';
00003a  2020              MOVS     r0,#0x20
00003c  e002              B        |L9.68|
                  |L9.62|
00003e  5470              STRB     r0,[r6,r1]
000040  1c49              ADDS     r1,r1,#1              ;224
000042  b2c9              UXTB     r1,r1                 ;224
                  |L9.68|
000044  4299              CMP      r1,r3                 ;224
000046  dbfa              BLT      |L9.62|
;;;227        }
;;;228    
;;;229        // 将字符串 code 复制到 new_code 中，起始位置为 new_code + spaces
;;;230        strcpy(new_code + spaces, code);
000048  18f0              ADDS     r0,r6,r3
00004a  4611              MOV      r1,r2
00004c  f7fffffe          BL       strcpy
;;;231        len = strlen(new_code);
000050  a802              ADD      r0,sp,#8
000052  f7fffffe          BL       strlen
000056  b2c5              UXTB     r5,r0
;;;232    
;;;233        // 如果长度超过LCD屏幕显示的最大长度，进行截断
;;;234        if (MAX_ALL_LENGTH < len)
000058  2d50              CMP      r5,#0x50
00005a  d900              BLS      |L9.94|
;;;235        {
;;;236            len = MAX_ALL_LENGTH;
00005c  2550              MOVS     r5,#0x50
                  |L9.94|
;;;237        }
;;;238    
;;;239        for (i = 0; i < len; i++)
00005e  2400              MOVS     r4,#0
000060  af01              ADD      r7,sp,#4              ;202
000062  f04f0814          MOV      r8,#0x14              ;198
000066  e013              B        |L9.144|
                  |L9.104|
;;;240        {
;;;241            // 当字符序号为一行最大长度时，需要切换到下一行
;;;242            if ((MAX_ONE_LINES_LENGTH == i)
000068  2c14              CMP      r4,#0x14
00006a  d003              BEQ      |L9.116|
;;;243                    || (MAX_TWO_LINES_LENGTH == i) || (MAX_THREE_LENGTH_LENGTH ==  i))
00006c  2c28              CMP      r4,#0x28
00006e  d001              BEQ      |L9.116|
000070  2c3c              CMP      r4,#0x3c
000072  d107              BNE      |L9.132|
                  |L9.116|
;;;244            {
;;;245                lineOffset = line[i / MAX_ONE_LINES_LENGTH] | 0x80;   // 计算下一行的LCD命令值
000074  fbb4f0f8          UDIV     r0,r4,r8
000078  5c38              LDRB     r0,[r7,r0]
00007a  f0400180          ORR      r1,r0,#0x80
;;;246                wr_lcd(comm, lineOffset);           // 发送LCD命令值切换到下一行
00007e  2000              MOVS     r0,#0
000080  f7fffffe          BL       wr_lcd
                  |L9.132|
;;;247            }
;;;248    
;;;249            wr_lcd(dat, new_code[i]);   // 发送字符数据到LCD进行显示
000084  5d31              LDRB     r1,[r6,r4]
000086  2001              MOVS     r0,#1
000088  f7fffffe          BL       wr_lcd
00008c  1c64              ADDS     r4,r4,#1              ;239
00008e  b2e4              UXTB     r4,r4                 ;239
                  |L9.144|
000090  42ac              CMP      r4,r5                 ;239
000092  d3e9              BCC      |L9.104|
;;;250        }
;;;251    }
000094  b034              ADD      sp,sp,#0xd0
000096  e8bd81f0          POP      {r4-r8,pc}
;;;252    
                          ENDP

00009a  0000              DCW      0x0000
                  |L9.156|
00009c  00                DCB      0
00009d  401454            DCB      "@",20,"T"

                          AREA ||i.Init_Lcd||, CODE, READONLY, ALIGN=2

                  Init_Lcd PROC
;;;35     **************************************************************/
;;;36     void Init_Lcd(void)
000000  b570              PUSH     {r4-r6,lr}
;;;37     {
;;;38         rcu_periph_clock_enable(RCU_GPIOB);
000002  f2406003          MOV      r0,#0x603
000006  f7fffffe          BL       rcu_periph_clock_enable
;;;39         rcu_periph_clock_enable(RCU_GPIOE);
00000a  f2406006          MOV      r0,#0x606
00000e  f7fffffe          BL       rcu_periph_clock_enable
;;;40     
;;;41         // data
;;;42         gpio_init(GPIOE, GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_8);
000012  4c3e              LDR      r4,|L10.268|
000014  f44f7380          MOV      r3,#0x100
000018  2203              MOVS     r2,#3
00001a  2110              MOVS     r1,#0x10
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       gpio_init
;;;43         gpio_init(GPIOE, GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_9);
000022  1563              ASRS     r3,r4,#21
000024  2203              MOVS     r2,#3
000026  2110              MOVS     r1,#0x10
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       gpio_init
;;;44         gpio_init(GPIOE, GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_10);
00002e  1523              ASRS     r3,r4,#20
000030  2203              MOVS     r2,#3
000032  2110              MOVS     r1,#0x10
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       gpio_init
;;;45         gpio_init(GPIOE, GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_11);
00003a  14e3              ASRS     r3,r4,#19
00003c  2203              MOVS     r2,#3
00003e  2110              MOVS     r1,#0x10
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       gpio_init
;;;46         gpio_init(GPIOE, GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_12);
000046  14a3              ASRS     r3,r4,#18
000048  2203              MOVS     r2,#3
00004a  2110              MOVS     r1,#0x10
00004c  4620              MOV      r0,r4
00004e  f7fffffe          BL       gpio_init
;;;47         gpio_init(GPIOE, GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_13);
000052  1463              ASRS     r3,r4,#17
000054  2203              MOVS     r2,#3
000056  2110              MOVS     r1,#0x10
000058  4620              MOV      r0,r4
00005a  f7fffffe          BL       gpio_init
;;;48         gpio_init(GPIOE, GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_14);
00005e  f44f4380          MOV      r3,#0x4000
000062  2203              MOVS     r2,#3
000064  2110              MOVS     r1,#0x10
000066  4620              MOV      r0,r4
000068  f7fffffe          BL       gpio_init
;;;49         gpio_init(GPIOE, GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_15);
00006c  f44f4300          MOV      r3,#0x8000
000070  2203              MOVS     r2,#3
000072  2110              MOVS     r1,#0x10
000074  4620              MOV      r0,r4
000076  f7fffffe          BL       gpio_init
;;;50     
;;;51         gpio_init(GPIOE, GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_7);
00007a  2380              MOVS     r3,#0x80
00007c  2203              MOVS     r2,#3
00007e  2110              MOVS     r1,#0x10
000080  4620              MOV      r0,r4
000082  f7fffffe          BL       gpio_init
;;;52         gpio_init(GPIOE, GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_2);
000086  2304              MOVS     r3,#4
000088  2203              MOVS     r2,#3
00008a  2110              MOVS     r1,#0x10
00008c  4620              MOV      r0,r4
00008e  f7fffffe          BL       gpio_init
;;;53         gpio_init(GPIOE, GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_3);
000092  2308              MOVS     r3,#8
000094  2203              MOVS     r2,#3
000096  2110              MOVS     r1,#0x10
000098  4620              MOV      r0,r4
00009a  f7fffffe          BL       gpio_init
;;;54     
;;;55         // 背光负极
;;;56         gpio_init(GPIOB, GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_1);
00009e  4d1c              LDR      r5,|L10.272|
0000a0  2302              MOVS     r3,#2
0000a2  2203              MOVS     r2,#3
0000a4  2110              MOVS     r1,#0x10
0000a6  4628              MOV      r0,r5
0000a8  f7fffffe          BL       gpio_init
;;;57     
;;;58         WR_DATA(0);
0000ac  2000              MOVS     r0,#0
0000ae  f7fffffe          BL       WR_DATA
;;;59     
;;;60     
;;;61         E_1();
0000b2  2108              MOVS     r1,#8
0000b4  4620              MOV      r0,r4
0000b6  f7fffffe          BL       gpio_bit_set
;;;62         WR_1();
0000ba  2104              MOVS     r1,#4
0000bc  4620              MOV      r0,r4
0000be  f7fffffe          BL       gpio_bit_set
;;;63         RS_1();
0000c2  2180              MOVS     r1,#0x80
0000c4  4620              MOV      r0,r4
0000c6  f7fffffe          BL       gpio_bit_set
;;;64     
;;;65         E_0();
0000ca  2108              MOVS     r1,#8
0000cc  4620              MOV      r0,r4
0000ce  f7fffffe          BL       gpio_bit_reset
;;;66         wr_lcd(comm, 0x01); // 清屏
0000d2  2101              MOVS     r1,#1
0000d4  2000              MOVS     r0,#0
0000d6  f7fffffe          BL       wr_lcd
;;;67         wr_lcd(comm, 0x06); // 地址自动+1（光标右移）
0000da  2106              MOVS     r1,#6
0000dc  2000              MOVS     r0,#0
0000de  f7fffffe          BL       wr_lcd
;;;68         wr_lcd(comm, 0x0c); // 开显示 关光标
0000e2  210c              MOVS     r1,#0xc
0000e4  2000              MOVS     r0,#0
0000e6  f7fffffe          BL       wr_lcd
;;;69         wr_lcd(comm, 0x38); // 八位总线 两行显示
0000ea  2138              MOVS     r1,#0x38
0000ec  2000              MOVS     r0,#0
0000ee  f7fffffe          BL       wr_lcd
;;;70     
;;;71         // 打开背光
;;;72         LCD_ON();
0000f2  2302              MOVS     r3,#2
0000f4  2203              MOVS     r2,#3
0000f6  2110              MOVS     r1,#0x10
0000f8  4628              MOV      r0,r5
0000fa  f7fffffe          BL       gpio_init
0000fe  4628              MOV      r0,r5
000100  e8bd4070          POP      {r4-r6,lr}
000104  2102              MOVS     r1,#2
000106  f7ffbffe          B.W      gpio_bit_set
;;;73     }
;;;74     
                          ENDP

00010a  0000              DCW      0x0000
                  |L10.268|
                          DCD      0x40011800
                  |L10.272|
                          DCD      0x40010c00

                          AREA ||i.POWER_ON_Information||, CODE, READONLY, ALIGN=2

                  POWER_ON_Information PROC
;;;580    **************************************************************/
;;;581    void POWER_ON_Information(void)
000000  2200              MOVS     r2,#0
;;;582    {
;;;583        Vertical_Scrolling_Display(startMsgBuff, 2, 0);
000002  2102              MOVS     r1,#2
000004  4801              LDR      r0,|L11.12|
000006  f7ffbffe          B.W      Vertical_Scrolling_Display
;;;584    }
                          ENDP

00000a  0000              DCW      0x0000
                  |L11.12|
                          DCD      ||.data||

                          AREA ||i.Vertical_Scrolling_Display||, CODE, READONLY, ALIGN=1

                  Vertical_Scrolling_Display PROC
;;;481    
;;;482    void Vertical_Scrolling_Display(char (* const Msg)[MAX_ONE_LINES_LENGTH], uchar numLines, uchar currentStartLine)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;483    {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;484        uchar startLine = currentStartLine;
;;;485        uchar lineIndex = 0;
;;;486        uchar i = 0; // 用于循环计数
00000a  2400              MOVS     r4,#0
00000c  e012              B        |L12.52|
                  |L12.14|
;;;487    
;;;488        // 逐行显示消息
;;;489        for (i = 0; i < numLines; i++)
;;;490        {
;;;491            Clear_Line(i); // 清空LCD第i行内容
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       Clear_Line
;;;492            lineIndex = (startLine + i) % numLines;  // 计算消息数组中的行索引
000014  1930              ADDS     r0,r6,r4
000016  fbb0f1f5          UDIV     r1,r0,r5
00001a  fb050011          MLS      r0,r5,r1,r0
00001e  b2c0              UXTB     r0,r0
;;;493    
;;;494            // 在LCD第i行显示消息
;;;495            Display_YX(i, 0, Msg[lineIndex]);  // 第i行第0列开始显示
000020  eb000080          ADD      r0,r0,r0,LSL #2
000024  eb070280          ADD      r2,r7,r0,LSL #2
000028  2100              MOVS     r1,#0
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       Display_YX
000030  1c64              ADDS     r4,r4,#1              ;489
000032  b2e4              UXTB     r4,r4                 ;489
                  |L12.52|
000034  42ac              CMP      r4,r5                 ;489
000036  d3ea              BCC      |L12.14|
;;;496        }
;;;497    }
000038  e8bd81f0          POP      {r4-r8,pc}
;;;498    
                          ENDP


                          AREA ||i.WR_DATA||, CODE, READONLY, ALIGN=2

                  WR_DATA PROC
;;;20     **************************************************************/
;;;21     void WR_DATA(uint32_t data) 
000000  0200              LSLS     r0,r0,#8
;;;22     { 
;;;23         data = data<<8;
;;;24         data |=  dut_info.VLKFlag;
000002  4903              LDR      r1,|L13.16|
000004  f891110b          LDRB     r1,[r1,#0x10b]  ; dut_info
000008  4301              ORRS     r1,r1,r0
;;;25         GPIO_OCTL(GPIOE) = (data);
00000a  4802              LDR      r0,|L13.20|
00000c  6001              STR      r1,[r0,#0]
;;;26     }
00000e  4770              BX       lr
;;;27     
                          ENDP

                  |L13.16|
                          DCD      dut_info
                  |L13.20|
                          DCD      0x4001180c

                          AREA ||i.addFormattedString||, CODE, READONLY, ALIGN=1

                  addFormattedString PROC
;;;533    
;;;534    void addFormattedString(uchar line, uchar column, const char *format, char Msg[MAX_LINES][MAX_ONE_LINES_LENGTH], ...)
000000  b40f              PUSH     {r0-r3}
;;;535    {
000002  e92d43f8          PUSH     {r3-r9,lr}
000006  4681              MOV      r9,r0
000008  460f              MOV      r7,r1
00000a  4698              MOV      r8,r3
;;;536        int i = 0;
00000c  2400              MOVS     r4,#0
;;;537        int j = 0;
;;;538    
;;;539        if (line < MAX_LINES && column < MAX_ONE_LINES_LENGTH)
00000e  f1b90f04          CMP      r9,#4
000012  d22c              BCS      |L14.110|
000014  2f14              CMP      r7,#0x14
000016  d22a              BCS      |L14.110|
;;;540        {
;;;541            // 对Msg数组每一行进行字符补齐
;;;542            for (i = 0; i < MAX_LINES; i++)
;;;543            {
;;;544                int length = strlen(Msg[i]);
;;;545                for (j = length; j < MAX_ONE_LINES_LENGTH; j++)
;;;546                {
;;;547                    Msg[i][j] = ' ';  // 用空格补齐字符
000018  2520              MOVS     r5,#0x20
                  |L14.26|
00001a  eb040084          ADD      r0,r4,r4,LSL #2       ;544
00001e  eb080080          ADD      r0,r8,r0,LSL #2       ;544
000022  4606              MOV      r6,r0                 ;544
000024  f7fffffe          BL       strlen
000028  e001              B        |L14.46|
                  |L14.42|
00002a  5435              STRB     r5,[r6,r0]
00002c  1c40              ADDS     r0,r0,#1              ;545
                  |L14.46|
00002e  2814              CMP      r0,#0x14              ;545
000030  dbfb              BLT      |L14.42|
000032  1c64              ADDS     r4,r4,#1              ;542
000034  2c04              CMP      r4,#4                 ;542
000036  dbf0              BLT      |L14.26|
;;;548                }
;;;549            }
;;;550    
;;;551            // 格式化字符串
;;;552            va_list args;
;;;553            va_start(args, format);
000038  ae0b              ADD      r6,sp,#0x2c
;;;554            char formattedStr[MAX_ONE_LINES_LENGTH - column];
00003a  f1c70414          RSB      r4,r7,#0x14
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       malloc
000044  4605              MOV      r5,r0
;;;555            vsnprintf(formattedStr, sizeof(formattedStr), format, args);
000046  4633              MOV      r3,r6
000048  4621              MOV      r1,r4
00004a  4628              MOV      r0,r5
00004c  9a0a              LDR      r2,[sp,#0x28]
00004e  f7fffffe          BL       vsnprintf
;;;556    
;;;557            // 复制格式化后的字符串到指定位置
;;;558            strncpy(Msg[line] + column, formattedStr, MAX_ONE_LINES_LENGTH - column);
000052  eb090089          ADD      r0,r9,r9,LSL #2
000056  eb080080          ADD      r0,r8,r0,LSL #2
00005a  4622              MOV      r2,r4
00005c  4438              ADD      r0,r0,r7
00005e  4629              MOV      r1,r5
000060  f7fffffe          BL       strncpy
;;;559    
;;;560            // 结束可变参数的使用
;;;561            va_end(args);
000064  2000              MOVS     r0,#0
000066  9000              STR      r0,[sp,#0]
000068  4628              MOV      r0,r5
00006a  f7fffffe          BL       free
                  |L14.110|
;;;562        }
;;;563    }
00006e  e8bd03f8          POP      {r3-r9}
000072  f85dfb14          LDR      pc,[sp],#0x14
;;;564    
                          ENDP


                          AREA ||i.addString||, CODE, READONLY, ALIGN=1

                  addString PROC
;;;511    *******************************************************/
;;;512    void addString(uchar line, uchar column, const char *str, char Msg[MAX_LINES][MAX_ONE_LINES_LENGTH])
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;513    {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4691              MOV      r9,r2
00000a  461e              MOV      r6,r3
;;;514        int i = 0;
00000c  2400              MOVS     r4,#0
;;;515        int j = 0;
;;;516    
;;;517        if (line < MAX_LINES && column < MAX_ONE_LINES_LENGTH)
00000e  2f04              CMP      r7,#4
000010  d21f              BCS      |L15.82|
000012  2d14              CMP      r5,#0x14
000014  d21d              BCS      |L15.82|
;;;518        {
;;;519            // 对Msg数组每一行进行字符补齐
;;;520            for (i = 0; i < MAX_LINES; i++)
;;;521            {
;;;522                int length = strlen(Msg[i]);
;;;523                for (j = length; j < MAX_ONE_LINES_LENGTH; j++)
;;;524                {
;;;525                    Msg[i][j] = ' ';  // 用空格补齐字符
000016  f04f0820          MOV      r8,#0x20
                  |L15.26|
00001a  eb040084          ADD      r0,r4,r4,LSL #2       ;522
00001e  eb060080          ADD      r0,r6,r0,LSL #2       ;522
000022  4682              MOV      r10,r0                ;522
000024  f7fffffe          BL       strlen
000028  e002              B        |L15.48|
                  |L15.42|
00002a  f80a8000          STRB     r8,[r10,r0]
00002e  1c40              ADDS     r0,r0,#1              ;523
                  |L15.48|
000030  2814              CMP      r0,#0x14              ;523
000032  dbfa              BLT      |L15.42|
000034  1c64              ADDS     r4,r4,#1              ;520
000036  2c04              CMP      r4,#4                 ;520
000038  dbef              BLT      |L15.26|
;;;526                }
;;;527            }
;;;528    
;;;529            // 复制字符串到指定位置
;;;530            strncpy(Msg[line] + column, str, MAX_ONE_LINES_LENGTH - column);
00003a  eb070087          ADD      r0,r7,r7,LSL #2
00003e  eb060080          ADD      r0,r6,r0,LSL #2
000042  f1c50214          RSB      r2,r5,#0x14
000046  4428              ADD      r0,r0,r5
000048  4649              MOV      r1,r9
00004a  e8bd47f0          POP      {r4-r10,lr}
00004e  f7ffbffe          B.W      strncpy
                  |L15.82|
;;;531        }
;;;532    }
000052  e8bd87f0          POP      {r4-r10,pc}
;;;533    
                          ENDP


                          AREA ||i.wr_lcd||, CODE, READONLY, ALIGN=2

                  wr_lcd PROC
;;;87     **************************************************************/
;;;88     void wr_lcd(uint8_t dat_cmd, uint8_t content)
000000  b510              PUSH     {r4,lr}
;;;89     {
000002  4602              MOV      r2,r0
000004  4608              MOV      r0,r1
;;;90         WR_DATA(content); // 写入数据或命令
000006  f7fffffe          BL       WR_DATA
;;;91         if (dat_cmd)
;;;92         {
;;;93             RS_1(); // 数据模式
00000a  4c10              LDR      r4,|L16.76|
00000c  b142              CBZ      r2,|L16.32|
00000e  2180              MOVS     r1,#0x80
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       gpio_bit_set
;;;94             WR_0(); // 写使能
000016  2104              MOVS     r1,#4
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       gpio_bit_reset
00001e  e007              B        |L16.48|
                  |L16.32|
;;;95         }
;;;96         else
;;;97         {
;;;98             RS_0(); // 命令模式
000020  2180              MOVS     r1,#0x80
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       gpio_bit_reset
;;;99             WR_0(); // 写使能
000028  2104              MOVS     r1,#4
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       gpio_bit_reset
                  |L16.48|
;;;100        }
;;;101    
;;;102        E_1(); // 使能
000030  2108              MOVS     r1,#8
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       gpio_bit_set
;;;103        Delayms(1); // 延时1ms
000038  2001              MOVS     r0,#1
00003a  f7fffffe          BL       Delayms
;;;104        E_0(); // 失能
00003e  4620              MOV      r0,r4
000040  e8bd4010          POP      {r4,lr}
000044  2108              MOVS     r1,#8
000046  f7ffbffe          B.W      gpio_bit_reset
;;;105    }
;;;106    
                          ENDP

00004a  0000              DCW      0x0000
                  |L16.76|
                          DCD      0x40011800

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

000000  00401454          DCB      0x00,0x40,0x14,0x54
000004  00                DCB      0x00

                          AREA ||.data||, DATA, ALIGN=0

                  startMsgBuff
000000  20202020          DCB      0x20,0x20,0x20,0x20
000004  44696769          DCB      0x44,0x69,0x67,0x69
000008  77697365          DCB      0x77,0x69,0x73,0x65
00000c  20445441          DCB      0x20,0x44,0x54,0x41
000010  00000000          DCB      0x00,0x00,0x00,0x00
000014  20202054          DCB      0x20,0x20,0x20,0x54
000018  65737420          DCB      0x65,0x73,0x74,0x20
00001c  45717569          DCB      0x45,0x71,0x75,0x69
000020  706d656e          DCB      0x70,0x6d,0x65,0x6e
000024  74200000          DCB      0x74,0x20,0x00,0x00

;*** Start embedded assembler ***

#line 1 "User\\Lcd2004.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_Lcd2004_c_WR_DATA____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___9_Lcd2004_c_WR_DATA____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_Lcd2004_c_WR_DATA____REVSH|
#line 128
|__asm___9_Lcd2004_c_WR_DATA____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
