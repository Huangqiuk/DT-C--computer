; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\record.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\record.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -I.\User\qrencode -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.1\Device\Include -D__MICROLIB -D__UVISION_VERSION=534 -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER -DGD32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\record.crf User\record.c]
                          THUMB

                          AREA ||i.RECORD_CALLBACK_DoBackup||, CODE, READONLY, ALIGN=2

                  RECORD_CALLBACK_DoBackup PROC
;;;207    // 写入一个骑行记录点，如果当前缓冲区内无数据，则更新开始时间；如果缓冲区已有数据，则只更新结束时间
;;;208    void RECORD_CALLBACK_DoBackup(uint32 param)
000000  b57c              PUSH     {r2-r6,lr}
;;;209    {
;;;210    	TIME_E time;
;;;211    	uint32 temp1, temp2;
;;;212    
;;;213    	DS1302_GetDateCB(&time);
000002  4668              MOV      r0,sp
000004  f7fffffe          BL       DS1302_GetDateCB
;;;214    	
;;;215    	// 当前无数据，则写入开始时间
;;;216    	if(!RECORD_IsDirty())
000008  f7fffffe          BL       RECORD_IsDirty
;;;217    	{
;;;218    		// 清除参数层保存的用户最大速度
;;;219    		PARAM_ClearUserMaxSpeed();
00000c  4c38              LDR      r4,|L1.240|
;;;220    
;;;221    		// 保存起始参数
;;;222    		recordCB.start.ridingTime = PARAM_GetTotalRidingTime();
00000e  4e39              LDR      r6,|L1.244|
000010  bbd8              CBNZ     r0,|L1.138|
000012  2000              MOVS     r0,#0                 ;219
000014  f8a40260          STRH     r0,[r4,#0x260]        ;219
000018  f8d40348          LDR      r0,[r4,#0x348]  ; paramCB
00001c  6170              STR      r0,[r6,#0x14]  ; recordCB
;;;223    		recordCB.start.distance = paramCB.nvm.param.common.record.total.distance;
00001e  f8d4033c          LDR      r0,[r4,#0x33c]  ; paramCB
000022  61b0              STR      r0,[r6,#0x18]  ; recordCB
;;;224    		recordCB.start.calories = PARAM_GetTotalCalories();
000024  f8d4034c          LDR      r0,[r4,#0x34c]  ; paramCB
000028  61f0              STR      r0,[r6,#0x1c]  ; recordCB
;;;225    		
;;;226    		// 判断蓝牙是否校准过时间
;;;227    		// 蓝牙校准过，则数据第0个字节保存为1；
;;;228    		// 蓝牙校没准过，则数据第0个字节保存为0；
;;;229    		// 注意上电需要排查该校验位，非1则改写为0xFF；
;;;230    		DS1302_WriteRAM(RECORD_PARAM_ADDR_IS_CHECK_BLE_TIME, (uint8)bleProtocolCB.isTimeCheck);
00002a  4833              LDR      r0,|L1.248|
00002c  f890174c          LDRB     r1,[r0,#0x74c]  ; bleProtocolCB
000030  2011              MOVS     r0,#0x11
000032  f7fffffe          BL       DS1302_WriteRAM
;;;231    		
;;;232    		DS1302_WriteRAM(RECORD_PARAM_ADDR_DATE_YEAR, time.year%100);			// 年份只保留十位和个位
000036  f8bd0000          LDRH     r0,[sp,#0]
00003a  2164              MOVS     r1,#0x64
00003c  fbb0f2f1          UDIV     r2,r0,r1
000040  fb010112          MLS      r1,r1,r2,r0
000044  2002              MOVS     r0,#2
000046  f7fffffe          BL       DS1302_WriteRAM
;;;233    		DS1302_WriteRAM(RECORD_PARAM_ADDR_DATE_MONTH, time.month);
00004a  f89d1002          LDRB     r1,[sp,#2]
00004e  2003              MOVS     r0,#3
000050  f7fffffe          BL       DS1302_WriteRAM
;;;234    		DS1302_WriteRAM(RECORD_PARAM_ADDR_DATE_DAY, time.day);
000054  f89d1003          LDRB     r1,[sp,#3]
000058  2004              MOVS     r0,#4
00005a  f7fffffe          BL       DS1302_WriteRAM
;;;235    		DS1302_WriteRAM(RECORD_PARAM_ADDR_DATE_HOUR, time.hour);
00005e  f89d1004          LDRB     r1,[sp,#4]
000062  2005              MOVS     r0,#5
000064  f7fffffe          BL       DS1302_WriteRAM
;;;236    		DS1302_WriteRAM(RECORD_PARAM_ADDR_DATE_MINUTE, time.minute);
000068  f89d1005          LDRB     r1,[sp,#5]
00006c  2006              MOVS     r0,#6
00006e  f7fffffe          BL       DS1302_WriteRAM
;;;237    		DS1302_WriteRAM(RECORD_PARAM_ADDR_DATE_SECOND, time.second);
000072  f89d1006          LDRB     r1,[sp,#6]
000076  2007              MOVS     r0,#7
000078  f7fffffe          BL       DS1302_WriteRAM
;;;238    
;;;239    		// 保存所属时间段
;;;240    		DS1302_WriteRAM(RECODE_PARAM_ADDR_TIMESLOT, time.hour);
00007c  f89d1004          LDRB     r1,[sp,#4]
000080  2010              MOVS     r0,#0x10
000082  f7fffffe          BL       DS1302_WriteRAM
;;;241    
;;;242    		// 写入开始时间后，设置脏标识
;;;243    		RECORD_SetDirtyFlag();
000086  f7fffffe          BL       RECORD_SetDirtyFlag
                  |L1.138|
;;;244    	}
;;;245    
;;;246    
;;;247    	// 到目前为止的骑行时间，单位:s
;;;248    	temp2 = PARAM_GetTotalRidingTime() - recordCB.start.ridingTime;
00008a  f204340e          ADD      r4,r4,#0x30e
00008e  8ab1              LDRH     r1,[r6,#0x14]  ; recordCB
000090  8f60              LDRH     r0,[r4,#0x3a]  ; paramCB
000092  1a45              SUBS     r5,r0,r1
;;;249    	
;;;250    	DS1302_WriteRAM(RECODE_PARAM_ADDR_TRIPTIMER_H, temp2>>8);
000094  f3c52107          UBFX     r1,r5,#8,#8
000098  2008              MOVS     r0,#8
00009a  f7fffffe          BL       DS1302_WriteRAM
;;;251    	DS1302_WriteRAM(RECODE_PARAM_ADDR_TRIPTIMER_L, temp2&0x00FF);
00009e  b2e9              UXTB     r1,r5
0000a0  2009              MOVS     r0,#9
0000a2  f7fffffe          BL       DS1302_WriteRAM
;;;252    	
;;;253    	// 保存最大速度
;;;254    	DS1302_WriteRAM(RECORD_PARAM_ADDR_MAXSPEED_H, PARAM_GetUserMaxSpeed()>>8);
0000a6  f8340cae          LDRH     r0,[r4,#-0xae]  ; paramCB
0000aa  0a01              LSRS     r1,r0,#8
0000ac  200a              MOVS     r0,#0xa
0000ae  f7fffffe          BL       DS1302_WriteRAM
;;;255    	DS1302_WriteRAM(RECORD_PARAM_ADDR_MAXSPEED_L, PARAM_GetUserMaxSpeed()&0x00FF);
0000b2  f8141cae          LDRB     r1,[r4,#-0xae]  ; paramCB
0000b6  200b              MOVS     r0,#0xb
0000b8  f7fffffe          BL       DS1302_WriteRAM
;;;256    
;;;257    	// 保存到目前为止的卡路里消耗
;;;258    	temp1 = PARAM_GetTotalCalories() - recordCB.start.calories;
0000bc  8fe0              LDRH     r0,[r4,#0x3e]  ; paramCB
0000be  8bb1              LDRH     r1,[r6,#0x1c]  ; recordCB
0000c0  1a45              SUBS     r5,r0,r1
;;;259    	DS1302_WriteRAM(RECORD_PARAM_ADDR_KCAL_H, temp1>>8);
0000c2  f3c52107          UBFX     r1,r5,#8,#8
0000c6  200c              MOVS     r0,#0xc
0000c8  f7fffffe          BL       DS1302_WriteRAM
;;;260    	DS1302_WriteRAM(RECORD_PARAM_ADDR_KCAL_L, temp1&0x00FF);
0000cc  b2e9              UXTB     r1,r5
0000ce  200d              MOVS     r0,#0xd
0000d0  f7fffffe          BL       DS1302_WriteRAM
;;;261    
;;;262    	// 保存到目前为止的骑行距离
;;;263    	temp1 = paramCB.nvm.param.common.record.total.distance - recordCB.start.distance;
0000d4  8de0              LDRH     r0,[r4,#0x2e]  ; paramCB
0000d6  8b31              LDRH     r1,[r6,#0x18]  ; recordCB
0000d8  1a44              SUBS     r4,r0,r1
;;;264    	DS1302_WriteRAM(RECORD_PARAM_ADDR_TRIP_H, temp1>>8);
0000da  f3c42107          UBFX     r1,r4,#8,#8
0000de  200e              MOVS     r0,#0xe
0000e0  f7fffffe          BL       DS1302_WriteRAM
;;;265    	DS1302_WriteRAM(RECORD_PARAM_ADDR_TRIP_L, temp1&0x00FF);
0000e4  b2e1              UXTB     r1,r4
0000e6  200f              MOVS     r0,#0xf
0000e8  f7fffffe          BL       DS1302_WriteRAM
;;;266    }
0000ec  bd7c              POP      {r2-r6,pc}
;;;267    
                          ENDP

0000ee  0000              DCW      0x0000
                  |L1.240|
                          DCD      paramCB
                  |L1.244|
                          DCD      ||.bss||+0xb48
                  |L1.248|
                          DCD      bleProtocolCB

                          AREA ||i.RECORD_CALLBACK_IsDoBackup||, CODE, READONLY, ALIGN=1

                  RECORD_CALLBACK_IsDoBackup PROC
;;;268    // 判断是否需要备份与更新
;;;269    void RECORD_CALLBACK_IsDoBackup(uint32 param)
000000  2000              MOVS     r0,#0
;;;270    {	
;;;271    	RECORD_CALLBACK_DoBackup(0);
000002  f7ffbffe          B.W      RECORD_CALLBACK_DoBackup
;;;272    }
;;;273    
                          ENDP


                          AREA ||i.RECORD_Check||, CODE, READONLY, ALIGN=1

                  RECORD_Check PROC
;;;89     // 骑行记录校验
;;;90     uint8_t RECORD_Check(uint8_t *ptr, uint8_t len)
000000  b510              PUSH     {r4,lr}
;;;91     {
;;;92     	uint8_t i;
;;;93     	uint8_t cc = 0;
000002  2300              MOVS     r3,#0
;;;94     	
;;;95     	for(i=0; i<len; i++)
000004  2200              MOVS     r2,#0
000006  e003              B        |L3.16|
                  |L3.8|
;;;96     	{
;;;97     		cc ^= ptr[i];
000008  5c84              LDRB     r4,[r0,r2]
00000a  4063              EORS     r3,r3,r4
00000c  1c52              ADDS     r2,r2,#1              ;95
00000e  b2d2              UXTB     r2,r2                 ;95
                  |L3.16|
000010  428a              CMP      r2,r1                 ;95
000012  d3f9              BCC      |L3.8|
;;;98     	}
;;;99     	return (~cc) ;
000014  43d8              MVNS     r0,r3
000016  b2c0              UXTB     r0,r0
;;;100    }
000018  bd10              POP      {r4,pc}
;;;101    
                          ENDP


                          AREA ||i.RECORD_ClearDirtyFlag||, CODE, READONLY, ALIGN=1

                  RECORD_ClearDirtyFlag PROC
;;;59     // 清除脏标识
;;;60     void RECORD_ClearDirtyFlag(void)
000000  2100              MOVS     r1,#0
;;;61     {
;;;62     	// 清除脏标识
;;;63     	DS1302_WriteRAM(RECORD_PARAM_ADDR_DIRTY_FLAG, 0);
000002  2001              MOVS     r0,#1
000004  f7ffbffe          B.W      DS1302_WriteRAM
;;;64     }
;;;65     
                          ENDP


                          AREA ||i.RECORD_ClearRecords||, CODE, READONLY, ALIGN=2

                  RECORD_ClearRecords PROC
;;;191    // 清空数据记录
;;;192    void RECORD_ClearRecords(void)
000000  b510              PUSH     {r4,lr}
;;;193    {
;;;194    	// 记录条数清零
;;;195    	SPI_FLASH_WriteHalfWord(RECORD_ADDR_TOTAL, 0);
000002  2100              MOVS     r1,#0
000004  4807              LDR      r0,|L5.36|
000006  f7fffffe          BL       SPI_FLASH_WriteHalfWord
;;;196    
;;;197    	// 已发送计数值清零
;;;198    	SPI_FLASH_WriteHalfWord(RECORD_ADDR_SEND_COUNT, 0);
00000a  4806              LDR      r0,|L5.36|
00000c  2100              MOVS     r1,#0
00000e  1c80              ADDS     r0,r0,#2
000010  f7fffffe          BL       SPI_FLASH_WriteHalfWord
;;;199    
;;;200    	// 清除脏标识
;;;201    	RECORD_ClearDirtyFlag();
000014  f7fffffe          BL       RECORD_ClearDirtyFlag
;;;202    
;;;203    	// 参数层记录的数据记录条数清零
;;;204    	PARAM_SetRecordCount(0);
000018  4903              LDR      r1,|L5.40|
00001a  2000              MOVS     r0,#0
00001c  f8a1022a          STRH     r0,[r1,#0x22a]
;;;205    }
000020  bd10              POP      {r4,pc}
;;;206    
                          ENDP

000022  0000              DCW      0x0000
                  |L5.36|
                          DCD      0x0038000f
                  |L5.40|
                          DCD      paramCB

                          AREA ||i.RECORD_EnterState||, CODE, READONLY, ALIGN=2

                  RECORD_EnterState PROC
;;;543    // 每个状态的入口处理
;;;544    void RECORD_EnterState(uint32 state)
000000  b510              PUSH     {r4,lr}
;;;545    {
;;;546    	// 让当前的状态成为历史
;;;547    	recordCB.preState = recordCB.state;
000002  4919              LDR      r1,|L6.104|
000004  7bca              LDRB     r2,[r1,#0xf]  ; recordCB
000006  740a              STRB     r2,[r1,#0x10]
;;;548    
;;;549    	// 设置新的状态
;;;550    	recordCB.state = (RECORD_STATE_E)state;
000008  73c8              STRB     r0,[r1,#0xf]
;;;551    
;;;552    	// 当无蓝牙时候不往下执行
;;;553    	if (!PARAM_GetExistBle())
00000a  4c18              LDR      r4,|L6.108|
00000c  f8941323          LDRB     r1,[r4,#0x323]  ; paramCB
000010  2900              CMP      r1,#0
000012  d027              BEQ      |L6.100|
;;;554    	{
;;;555    		return;
;;;556    	}
;;;557    	
;;;558    	// 各状态的入口设定
;;;559    	switch(state)
000014  2800              CMP      r0,#0
000016  d025              BEQ      |L6.100|
;;;560    	{
;;;561    		// ■■ 空状态 ■■
;;;562    		case RECORD_STATE_NULL:
;;;563    			break;
;;;564    
;;;565    		// ■■ 待机状态入口处理 ■■
;;;566    		case RECORD_STATE_STANDBY:
;;;567    		
;;;568    			// 停止记录定时器
;;;569    //			TIMER_KillTask(TIMER_ID_RECORD_CONTROL);
;;;570    
;;;571    			if (bleProtocolCB.isTimeCheck == FALSE)
000018  4915              LDR      r1,|L6.112|
00001a  2801              CMP      r0,#1                 ;559
00001c  f891174c          LDRB     r1,[r1,#0x74c]
000020  d007              BEQ      |L6.50|
000022  2802              CMP      r0,#2                 ;559
000024  d11e              BNE      |L6.100|
;;;572    			{
;;;573    				RECORD_Update(1);
;;;574    			}
;;;575    			else
;;;576    			{
;;;577    				// 每次进入待机状态，都保存一次
;;;578    				RECORD_SaveToNVM();
;;;579    			}
;;;580    
;;;581    			// 判断蓝牙是否连接，是否有历史数据
;;;582    			if((PARAM_GetBleConnectState()) && (RECORD_IsHistoricalData()) && (PARAM_GetSpeed() == 0))
;;;583    			{
;;;584    				// 先立刻启动一次同步数据请求
;;;585    //				BLE_PROTOCOL_TxStartHistoryData(TRUE);
;;;586    				
;;;587    				// 如果没有接收到应答，五秒中循环发送请求同步数据
;;;588    //				TIMER_AddTask(TIMER_ID_BLE_START_HISTORICAL_DATA_UP,
;;;589    //								5000,
;;;590    //								BLE_PROTOCOL_TxStartHistoryData,
;;;591    //								UINT32_NULL,
;;;592    //								TIMER_LOOP_FOREVER,
;;;593    //								ACTION_MODE_ADD_TO_QUEUE);
;;;594    			}
;;;595    
;;;596    			break;
;;;597    
;;;598    		// ■■ 记录中状态入口处理 ■■
;;;599    		case RECORD_STATE_RECORDING:
;;;600    		
;;;601    			// 开始进入骑行记录,上电只能进来一次
;;;602    			if (bleProtocolCB.isTimeCheck == FALSE)
000026  b1b9              CBZ      r1,|L6.88|
;;;603    			{
;;;604    				if (recordTmpCB.tripFlag == 0)
;;;605    				{
;;;606    					recordTmpCB.tripFlag = 1;
;;;607    					
;;;608    //					TIMER_AddTask(TIMER_ID_RECORD_COUNT,
;;;609    //									1000UL,
;;;610    //									RECORD_Update,
;;;611    //									0,
;;;612    //									TIMER_LOOP_FOREVER,
;;;613    //									ACTION_MODE_ADD_TO_QUEUE);
;;;614    				}
;;;615    			}
;;;616    			else
;;;617    			{
;;;618    				// 每次进入此状态，都记录一次数据
;;;619    				RECORD_CALLBACK_DoBackup(0);
000028  e8bd4010          POP      {r4,lr}
00002c  2000              MOVS     r0,#0
00002e  f7ffbffe          B.W      RECORD_CALLBACK_DoBackup
                  |L6.50|
000032  b169              CBZ      r1,|L6.80|
000034  f7fffffe          BL       RECORD_SaveToNVM
                  |L6.56|
000038  f8940203          LDRB     r0,[r4,#0x203]        ;582  ; paramCB
00003c  2800              CMP      r0,#0                 ;582
00003e  d011              BEQ      |L6.100|
000040  f7fffffe          BL       RECORD_IsHistoricalData
000044  2800              CMP      r0,#0                 ;582
000046  d00d              BEQ      |L6.100|
000048  e8bd4010          POP      {r4,lr}               ;582
00004c  f7ffbffe          B.W      PARAM_GetSpeed
                  |L6.80|
000050  2001              MOVS     r0,#1                 ;573
000052  f7fffffe          BL       RECORD_Update
000056  e7ef              B        |L6.56|
                  |L6.88|
000058  4806              LDR      r0,|L6.116|
00005a  7801              LDRB     r1,[r0,#0]            ;604  ; recordTmpCB
00005c  2900              CMP      r1,#0                 ;604
00005e  d101              BNE      |L6.100|
000060  2101              MOVS     r1,#1                 ;606
000062  7001              STRB     r1,[r0,#0]            ;606
                  |L6.100|
;;;620    
;;;621    				// 首次进入此状态，开启定时器任务，每秒记录一次(不要随意改，否则出错)
;;;622    				if(recordCB.preState != recordCB.state)
;;;623    				{
;;;624    //					TIMER_AddTask(TIMER_ID_RECORD_CONTROL,
;;;625    //									1000UL,
;;;626    //									RECORD_CALLBACK_IsDoBackup,
;;;627    //									0,
;;;628    //									TIMER_LOOP_FOREVER,
;;;629    //									ACTION_MODE_ADD_TO_QUEUE);
;;;630    				}
;;;631    			}
;;;632    			break;
;;;633    
;;;634    		default:
;;;635    			break;
;;;636    	}
;;;637    }
000064  bd10              POP      {r4,pc}
;;;638    
                          ENDP

000066  0000              DCW      0x0000
                  |L6.104|
                          DCD      ||.bss||+0xb48
                  |L6.108|
                          DCD      paramCB
                  |L6.112|
                          DCD      bleProtocolCB
                  |L6.116|
                          DCD      ||.bss||

                          AREA ||i.RECORD_FormatNVM||, CODE, READONLY, ALIGN=2

                  RECORD_FormatNVM PROC
;;;167    // 格式化NVM
;;;168    void RECORD_FormatNVM(void)
000000  b510              PUSH     {r4,lr}
;;;169    {
;;;170    	uint8 i;
;;;171    
;;;172    	// 初始化单元参数
;;;173    	for (i = 0; i < RECORD_NVM_FORMAT_FLAG_SIZE; i++)
000002  2000              MOVS     r0,#0
;;;174    	{
;;;175    		recordCB.nvmFormat[i] = constFormatFlag[i];
000004  490d              LDR      r1,|L7.60|
000006  4a0e              LDR      r2,|L7.64|
                  |L7.8|
000008  5c0b              LDRB     r3,[r1,r0]
00000a  5413              STRB     r3,[r2,r0]
00000c  1c40              ADDS     r0,r0,#1              ;173
00000e  b2c0              UXTB     r0,r0                 ;173
000010  280f              CMP      r0,#0xf               ;173
000012  d3f9              BCC      |L7.8|
;;;176    	}
;;;177    
;;;178    	// 写格式化密匙
;;;179    	SPI_FLASH_WriteWithErase(recordCB.nvmFormat, RECORD_ADDR_BASE, RECORD_NVM_FORMAT_FLAG_SIZE);
000014  220f              MOVS     r2,#0xf
000016  f44f1160          MOV      r1,#0x380000
00001a  4809              LDR      r0,|L7.64|
00001c  f7fffffe          BL       SPI_FLASH_WriteWithErase
;;;180    
;;;181    	// 初始化记录条为0
;;;182    	SPI_FLASH_WriteHalfWord(RECORD_ADDR_TOTAL, 0);
000020  2100              MOVS     r1,#0
000022  4808              LDR      r0,|L7.68|
000024  f7fffffe          BL       SPI_FLASH_WriteHalfWord
;;;183    
;;;184    	// 已读路线编号为0
;;;185    	SPI_FLASH_WriteHalfWord(RECORD_ADDR_SEND_COUNT, 0);
000028  4806              LDR      r0,|L7.68|
00002a  2100              MOVS     r1,#0
00002c  1c80              ADDS     r0,r0,#2
00002e  f7fffffe          BL       SPI_FLASH_WriteHalfWord
;;;186    
;;;187    	// 参数层记录的数据记录条数清零
;;;188    	PARAM_SetRecordCount(0);
000032  4905              LDR      r1,|L7.72|
000034  2000              MOVS     r0,#0
000036  f8a1022a          STRH     r0,[r1,#0x22a]
;;;189    }
00003a  bd10              POP      {r4,pc}
;;;190    
                          ENDP

                  |L7.60|
                          DCD      ||.constdata||
                  |L7.64|
                          DCD      ||.bss||+0xb48
                  |L7.68|
                          DCD      0x0038000f
                  |L7.72|
                          DCD      paramCB

                          AREA ||i.RECORD_GetRecordCount||, CODE, READONLY, ALIGN=2

                  RECORD_GetRecordCount PROC
;;;77     // 获取骑行记录条数，包括未同步时间的记录
;;;78     uint16 RECORD_GetRecordCount(void)
000000  4801              LDR      r0,|L8.8|
;;;79     {
;;;80     	return SPI_FLASH_ReadHalfWord(RECORD_ADDR_TOTAL);
000002  f7ffbffe          B.W      SPI_FLASH_ReadHalfWord
;;;81     }
;;;82     
                          ENDP

000006  0000              DCW      0x0000
                  |L8.8|
                          DCD      0x0038000f

                          AREA ||i.RECORD_GetRecordSendCount||, CODE, READONLY, ALIGN=2

                  RECORD_GetRecordSendCount PROC
;;;83     // 获取已发送记录条数
;;;84     uint16 RECORD_GetRecordSendCount(void)
000000  4801              LDR      r0,|L9.8|
;;;85     {
;;;86     	return SPI_FLASH_ReadHalfWord(RECORD_ADDR_SEND_COUNT);
000002  f7ffbffe          B.W      SPI_FLASH_ReadHalfWord
;;;87     }
;;;88     
                          ENDP

000006  0000              DCW      0x0000
                  |L9.8|
                          DCD      0x00380011

                          AREA ||i.RECORD_GetState||, CODE, READONLY, ALIGN=2

                  RECORD_GetState PROC
;;;693    // 获取记录状态
;;;694    RECORD_STATE_E RECORD_GetState(void)
000000  4801              LDR      r0,|L10.8|
;;;695    {
;;;696    	return recordCB.state;
000002  7bc0              LDRB     r0,[r0,#0xf]  ; recordCB
;;;697    }
000004  4770              BX       lr
;;;698    
                          ENDP

000006  0000              DCW      0x0000
                  |L10.8|
                          DCD      ||.bss||+0xb48

                          AREA ||i.RECORD_Init||, CODE, READONLY, ALIGN=2

                  RECORD_Init PROC
;;;486    // 骑行信息模块上电初始化准备
;;;487    void RECORD_Init(void)
000000  b510              PUSH     {r4,lr}
;;;488    {
;;;489    //	int16 i;
;;;490    //	uint16 count;
;;;491    //	uint16 tempCount;
;;;492    //	uint32 addr;
;;;493    
;;;494    	// 未格式化，则格式化
;;;495    	if (!RECORD_IsFormatOK())
000002  f7fffffe          BL       RECORD_IsFormatOK
000006  b908              CBNZ     r0,|L11.12|
;;;496    	{
;;;497    		RECORD_FormatNVM();
000008  f7fffffe          BL       RECORD_FormatNVM
                  |L11.12|
;;;498    	}
;;;499    	else
;;;500    	{
;;;501    //		// 获取总记录条数
;;;502    //		count = RECORD_GetRecordCount();
;;;503    //		tempCount = count;
;;;504    //		if ((count != 0x00) && (count < (uint16)RECORD_COUNT_MAX))
;;;505    //		{
;;;506    //			// 轮询Flash地址，将IsTimeCheck位为0的清除为0xFF
;;;507    //			for (i = count-1; i >= 0; i--)
;;;508    //			{
;;;509    //				addr = RECORD_ADDR_BLE_CHECK_TIME_START + (i * sizeof(RECORD_PARAM_CB));
;;;510    //				if ((0x00 == SPI_FLASH_ReadByte(addr))		// 上次开机临时存储的记录
;;;511    //					|| (0x01 != SPI_FLASH_ReadByte(addr)))	// 其他原因导致该记录无效
;;;512    //				{
;;;513    //					SPI_FLASH_WriteByte(addr, 0xFF);
;;;514    //			
;;;515    //					// 更新记录的条数
;;;516    //					tempCount--;
;;;517    //					SPI_FLASH_WriteHalfWord(RECORD_ADDR_TOTAL, tempCount);	
;;;518    //				}
;;;519    //			}
;;;520    //		}
;;;521    	}
;;;522    
;;;523    #if RECORD_UNIT_TEST_ON
;;;524    	RECORD_UnitTest();
;;;525    #endif
;;;526    
;;;527    	// 默认状态为空
;;;528    	recordCB.state = RECORD_STATE_NULL;
00000c  4804              LDR      r0,|L11.32|
00000e  2100              MOVS     r1,#0
000010  73c1              STRB     r1,[r0,#0xf]
;;;529    	recordCB.preState = RECORD_STATE_NULL;
000012  7401              STRB     r1,[r0,#0x10]
;;;530    
;;;531    	// 将记录条数传给参数层
;;;532    	PARAM_SetRecordCount(RECORD_GetRecordCount());
000014  f7fffffe          BL       RECORD_GetRecordCount
000018  4902              LDR      r1,|L11.36|
00001a  f8a1022a          STRH     r0,[r1,#0x22a]
;;;533    
;;;534    	// 指定时间后进入待机
;;;535    //	TIMER_AddTask(TIMER_ID_RECORD_CONTROL,
;;;536    //					500UL,
;;;537    //					RECORD_EnterState,
;;;538    //					RECORD_STATE_STANDBY,
;;;539    //					1,
;;;540    //					ACTION_MODE_ADD_TO_QUEUE);
;;;541    }
00001e  bd10              POP      {r4,pc}
;;;542    
                          ENDP

                  |L11.32|
                          DCD      ||.bss||+0xb48
                  |L11.36|
                          DCD      paramCB

                          AREA ||i.RECORD_IsDirty||, CODE, READONLY, ALIGN=1

                  RECORD_IsDirty PROC
;;;66     // 读取脏标识是否有效
;;;67     BOOL RECORD_IsDirty(void)
000000  b510              PUSH     {r4,lr}
;;;68     {
;;;69     	if(0x55 == DS1302_ReadRAM(RECORD_PARAM_ADDR_DIRTY_FLAG))
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       DS1302_ReadRAM
000008  2855              CMP      r0,#0x55
00000a  d001              BEQ      |L12.16|
;;;70     	{
;;;71     		return TRUE;
;;;72     	}
;;;73     	
;;;74     	return FALSE;
00000c  2000              MOVS     r0,#0
;;;75     }
00000e  bd10              POP      {r4,pc}
                  |L12.16|
000010  2001              MOVS     r0,#1                 ;71
000012  bd10              POP      {r4,pc}
;;;76     
                          ENDP


                          AREA ||i.RECORD_IsFormatOK||, CODE, READONLY, ALIGN=2

                  RECORD_IsFormatOK PROC
;;;147    // 判断NVM是否已格式化
;;;148    BOOL RECORD_IsFormatOK(void)
000000  b510              PUSH     {r4,lr}
;;;149    {
;;;150    	uint8 i;
;;;151    
;;;152    	// 读取格式化标志
;;;153    	SPI_FLASH_ReadArray(recordCB.nvmFormat, RECORD_ADDR_BASE, RECORD_NVM_FORMAT_FLAG_SIZE);
000002  220f              MOVS     r2,#0xf
000004  f44f1160          MOV      r1,#0x380000
000008  4808              LDR      r0,|L13.44|
00000a  f7fffffe          BL       SPI_FLASH_ReadArray
;;;154    
;;;155    	// 逐个比较，只要发现一个不同，即认为未格式化
;;;156    	for (i = 0; i < RECORD_NVM_FORMAT_FLAG_SIZE; i++)
00000e  2000              MOVS     r0,#0
000010  4a06              LDR      r2,|L13.44|
;;;157    	{
;;;158    		if(constFormatFlag[i] != recordCB.nvmFormat[i])
000012  4907              LDR      r1,|L13.48|
                  |L13.20|
000014  5c14              LDRB     r4,[r2,r0]
000016  5c0b              LDRB     r3,[r1,r0]
000018  42a3              CMP      r3,r4
00001a  d001              BEQ      |L13.32|
;;;159    		{
;;;160    			return FALSE;
00001c  2000              MOVS     r0,#0
;;;161    		}
;;;162    	}
;;;163    
;;;164    	return TRUE;
;;;165    }
00001e  bd10              POP      {r4,pc}
                  |L13.32|
000020  1c40              ADDS     r0,r0,#1              ;156
000022  b2c0              UXTB     r0,r0                 ;156
000024  280f              CMP      r0,#0xf               ;156
000026  d3f5              BCC      |L13.20|
000028  2001              MOVS     r0,#1                 ;164
00002a  bd10              POP      {r4,pc}
;;;166    
                          ENDP

                  |L13.44|
                          DCD      ||.bss||+0xb48
                  |L13.48|
                          DCD      ||.constdata||

                          AREA ||i.RECORD_IsHistoricalData||, CODE, READONLY, ALIGN=2

                  RECORD_IsHistoricalData PROC
;;;699    // 查询是否有未同步历史数据
;;;700    BOOL RECORD_IsHistoricalData(void)
000000  b510              PUSH     {r4,lr}
;;;701    {
;;;702    	uint16 totalCount, readCount;
;;;703    
;;;704    	// 读取已有记录条数和已读出条数
;;;705    	totalCount = SPI_FLASH_ReadHalfWord(RECORD_ADDR_TOTAL);
000002  4807              LDR      r0,|L14.32|
000004  f7fffffe          BL       SPI_FLASH_ReadHalfWord
000008  4604              MOV      r4,r0
;;;706    	readCount = SPI_FLASH_ReadHalfWord(RECORD_ADDR_SEND_COUNT);
00000a  4805              LDR      r0,|L14.32|
00000c  1c80              ADDS     r0,r0,#2
00000e  f7fffffe          BL       SPI_FLASH_ReadHalfWord
;;;707    
;;;708    	if(readCount < totalCount)
000012  42a0              CMP      r0,r4
000014  d201              BCS      |L14.26|
;;;709    	{
;;;710    		return TRUE;
000016  2001              MOVS     r0,#1
;;;711    	}
;;;712    	else
;;;713    	{
;;;714    		return FALSE;
;;;715    	}
;;;716    }
000018  bd10              POP      {r4,pc}
                  |L14.26|
00001a  2000              MOVS     r0,#0                 ;714
00001c  bd10              POP      {r4,pc}
;;;717    
                          ENDP

00001e  0000              DCW      0x0000
                  |L14.32|
                          DCD      0x0038000f

                          AREA ||i.RECORD_Process||, CODE, READONLY, ALIGN=2

                  RECORD_Process PROC
;;;639    // 每个状态下的过程处理
;;;640    void RECORD_Process(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;641    {
;;;642    	TIME_E time;
;;;643    	static uint8 lastSecond;
;;;644    	
;;;645    	switch(recordCB.state)
000002  4818              LDR      r0,|L15.100|
000004  7bc0              LDRB     r0,[r0,#0xf]  ; recordCB
000006  2800              CMP      r0,#0
000008  d01f              BEQ      |L15.74|
;;;646    	{
;;;647    		// ■■ 空状态 ■■
;;;648    		case RECORD_STATE_NULL:
;;;649    			break;
;;;650    
;;;651    		// ■■ 待机状态过程处理 ■■
;;;652    		case RECORD_STATE_STANDBY:
;;;653    			// 运动时间达到或超过门限，开始记录
;;;654    			if(PARAM_GetMoveTimeKeepTime() >= RECORD_MOVE_TIME_THRESHOLD)
00000a  4c17              LDR      r4,|L15.104|
00000c  2801              CMP      r0,#1                 ;645
00000e  d015              BEQ      |L15.60|
000010  2802              CMP      r0,#2                 ;645
000012  d11a              BNE      |L15.74|
;;;655    			{
;;;656    				// 进入记录中状态
;;;657    				RECORD_EnterState(RECORD_STATE_RECORDING);
;;;658    			}
;;;659    			break;
;;;660    
;;;661    		// ■■ 记录中状态过程处理 ■■
;;;662    		case RECORD_STATE_RECORDING:
;;;663    			// 静止时间达到或超过门限，停止记录
;;;664    			if(PARAM_GetStopTimeKeepTime() >= RECORD_STOP_TIME_THRESHOLD)
000014  f8b4025e          LDRH     r0,[r4,#0x25e]  ; paramCB
000018  280a              CMP      r0,#0xa
00001a  d307              BCC      |L15.44|
;;;665    			{
;;;666    				// 进入待机状态
;;;667    				RECORD_EnterState(RECORD_STATE_STANDBY);
00001c  2001              MOVS     r0,#1
00001e  f7fffffe          BL       RECORD_EnterState
;;;668    
;;;669    				// 蓝牙上报状态消息
;;;670    				if(PARAM_GetBleConnectState())
000022  f8940203          LDRB     r0,[r4,#0x203]  ; paramCB
000026  b108              CBZ      r0,|L15.44|
;;;671    				{
;;;672    					BLE_PROTOCOL_SendCmdStatusAck();
000028  f7fffffe          BL       BLE_PROTOCOL_SendCmdStatusAck
                  |L15.44|
;;;673    				}
;;;674    			}
;;;675    
;;;676    			// 骑行状态过程中，整点存储一条数据
;;;677    			DS1302_GetDateCB(&time);
00002c  4668              MOV      r0,sp
00002e  f7fffffe          BL       DS1302_GetDateCB
;;;678    			if((0 == time.minute) && (0 == time.second) && (59 == lastSecond))
000032  f89d0005          LDRB     r0,[sp,#5]
000036  4c0d              LDR      r4,|L15.108|
000038  b140              CBZ      r0,|L15.76|
00003a  e00f              B        |L15.92|
                  |L15.60|
00003c  f8b4025c          LDRH     r0,[r4,#0x25c]        ;654  ; paramCB
000040  2808              CMP      r0,#8                 ;654
000042  d302              BCC      |L15.74|
000044  2002              MOVS     r0,#2                 ;657
000046  f7fffffe          BL       RECORD_EnterState
                  |L15.74|
;;;679    			{
;;;680    				// 每次进入整点状态都保存一次
;;;681    				RECORD_SaveToNVM();
;;;682    			}
;;;683    
;;;684    			// 更新上一次秒数，重复进入整点记录数据
;;;685    			lastSecond = time.second;
;;;686    			break;
;;;687    
;;;688    		default:
;;;689    			break;
;;;690    	}
;;;691    }
00004a  bd1c              POP      {r2-r4,pc}
                  |L15.76|
00004c  f89d0006          LDRB     r0,[sp,#6]            ;678
000050  b920              CBNZ     r0,|L15.92|
000052  7860              LDRB     r0,[r4,#1]            ;678  ; lastSecond
000054  283b              CMP      r0,#0x3b              ;678
000056  d101              BNE      |L15.92|
000058  f7fffffe          BL       RECORD_SaveToNVM
                  |L15.92|
00005c  f89d0006          LDRB     r0,[sp,#6]            ;685
000060  7060              STRB     r0,[r4,#1]            ;685
000062  bd1c              POP      {r2-r4,pc}
;;;692    
                          ENDP

                  |L15.100|
                          DCD      ||.bss||+0xb48
                  |L15.104|
                          DCD      paramCB
                  |L15.108|
                          DCD      ||.data||

                          AREA ||i.RECORD_ReadBuffer||, CODE, READONLY, ALIGN=1

                  RECORD_ReadBuffer PROC
;;;102    // 从缓冲区中读取一个过程统计数据
;;;103    void RECORD_ReadBuffer(RECORD_ITEM_CB* pTrackCB)
000000  b570              PUSH     {r4-r6,lr}
;;;104    {
000002  4604              MOV      r4,r0
;;;105    	uint16 temp;
;;;106    	
;;;107    	if(NULL == pTrackCB)
000004  2c00              CMP      r4,#0
000006  d04e              BEQ      |L16.166|
;;;108    	{
;;;109    		return;
;;;110    	}
;;;111    
;;;112    	// 将当前记录写入缓存
;;;113    	pTrackCB->param.dateTime.year = DS1302_ReadRAM(RECORD_PARAM_ADDR_DATE_YEAR);			// 年份只保留十位和个位
000008  2002              MOVS     r0,#2
00000a  f7fffffe          BL       DS1302_ReadRAM
00000e  7020              STRB     r0,[r4,#0]
;;;114    	pTrackCB->param.dateTime.month = DS1302_ReadRAM(RECORD_PARAM_ADDR_DATE_MONTH);
000010  2003              MOVS     r0,#3
000012  f7fffffe          BL       DS1302_ReadRAM
000016  7060              STRB     r0,[r4,#1]
;;;115    	pTrackCB->param.dateTime.day = DS1302_ReadRAM(RECORD_PARAM_ADDR_DATE_DAY);
000018  2004              MOVS     r0,#4
00001a  f7fffffe          BL       DS1302_ReadRAM
00001e  70a0              STRB     r0,[r4,#2]
;;;116    	pTrackCB->param.dateTime.hour = DS1302_ReadRAM(RECORD_PARAM_ADDR_DATE_HOUR);
000020  2005              MOVS     r0,#5
000022  f7fffffe          BL       DS1302_ReadRAM
000026  70e0              STRB     r0,[r4,#3]
;;;117    	pTrackCB->param.dateTime.min = DS1302_ReadRAM(RECORD_PARAM_ADDR_DATE_MINUTE);
000028  2006              MOVS     r0,#6
00002a  f7fffffe          BL       DS1302_ReadRAM
00002e  7120              STRB     r0,[r4,#4]
;;;118    	pTrackCB->param.dateTime.sec = DS1302_ReadRAM(RECORD_PARAM_ADDR_DATE_SECOND);
000030  2007              MOVS     r0,#7
000032  f7fffffe          BL       DS1302_ReadRAM
000036  7160              STRB     r0,[r4,#5]
;;;119    
;;;120    	temp = DS1302_ReadRAM(RECODE_PARAM_ADDR_TRIPTIMER_H);
000038  2008              MOVS     r0,#8
00003a  f7fffffe          BL       DS1302_ReadRAM
;;;121    	temp <<= 8;
00003e  f64f75ff          MOV      r5,#0xffff
000042  ea052600          AND      r6,r5,r0,LSL #8
;;;122    	temp += DS1302_ReadRAM(RECODE_PARAM_ADDR_TRIPTIMER_L);
000046  2009              MOVS     r0,#9
000048  f7fffffe          BL       DS1302_ReadRAM
00004c  4430              ADD      r0,r0,r6
;;;123    	pTrackCB->param.tripTimer = temp;
00004e  80e0              STRH     r0,[r4,#6]
;;;124    
;;;125    	temp = DS1302_ReadRAM(RECORD_PARAM_ADDR_MAXSPEED_H);
000050  200a              MOVS     r0,#0xa
000052  f7fffffe          BL       DS1302_ReadRAM
;;;126    	temp <<= 8;
000056  ea052600          AND      r6,r5,r0,LSL #8
;;;127    	temp += DS1302_ReadRAM(RECORD_PARAM_ADDR_MAXSPEED_L);
00005a  200b              MOVS     r0,#0xb
00005c  f7fffffe          BL       DS1302_ReadRAM
000060  4430              ADD      r0,r0,r6
;;;128    	pTrackCB->param.speedMax = temp;
000062  8120              STRH     r0,[r4,#8]
;;;129    
;;;130    	temp = DS1302_ReadRAM(RECORD_PARAM_ADDR_KCAL_H);
000064  200c              MOVS     r0,#0xc
000066  f7fffffe          BL       DS1302_ReadRAM
;;;131    	temp <<= 8;
00006a  ea052600          AND      r6,r5,r0,LSL #8
;;;132    	temp += DS1302_ReadRAM(RECORD_PARAM_ADDR_KCAL_L);
00006e  200d              MOVS     r0,#0xd
000070  f7fffffe          BL       DS1302_ReadRAM
000074  4430              ADD      r0,r0,r6
;;;133    	pTrackCB->param.calories = temp;
000076  8160              STRH     r0,[r4,#0xa]
;;;134    
;;;135    	temp = DS1302_ReadRAM(RECORD_PARAM_ADDR_TRIP_H);
000078  200e              MOVS     r0,#0xe
00007a  f7fffffe          BL       DS1302_ReadRAM
;;;136    	temp <<= 8;
00007e  ea052500          AND      r5,r5,r0,LSL #8
;;;137    	temp += DS1302_ReadRAM(RECORD_PARAM_ADDR_TRIP_L);
000082  200f              MOVS     r0,#0xf
000084  f7fffffe          BL       DS1302_ReadRAM
000088  4428              ADD      r0,r0,r5
;;;138    	pTrackCB->param.trip = temp;
00008a  81a0              STRH     r0,[r4,#0xc]
;;;139    
;;;140    	pTrackCB->param.timeSlot = DS1302_ReadRAM(RECODE_PARAM_ADDR_TIMESLOT);
00008c  2010              MOVS     r0,#0x10
00008e  f7fffffe          BL       DS1302_ReadRAM
000092  73a0              STRB     r0,[r4,#0xe]
;;;141    
;;;142    	pTrackCB->param.isTimeCheck = DS1302_ReadRAM(RECORD_PARAM_ADDR_IS_CHECK_BLE_TIME);
000094  2011              MOVS     r0,#0x11
000096  f7fffffe          BL       DS1302_ReadRAM
00009a  73e0              STRB     r0,[r4,#0xf]
;;;143    	
;;;144    	pTrackCB->param.packCheck = RECORD_Check(pTrackCB->array, sizeof(RECORD_ITEM_CB) - 1);
00009c  2110              MOVS     r1,#0x10
00009e  4620              MOV      r0,r4
0000a0  f7fffffe          BL       RECORD_Check
0000a4  7420              STRB     r0,[r4,#0x10]
                  |L16.166|
;;;145    }
0000a6  bd70              POP      {r4-r6,pc}
;;;146    
                          ENDP


                          AREA ||i.RECORD_ReadFromNVM||, CODE, READONLY, ALIGN=2

                  RECORD_ReadFromNVM PROC
;;;406    // 读取最早的一条的记录
;;;407    BOOL RECORD_ReadFromNVM(RECORD_ITEM_CB* pTrack)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;408    {
000004  4605              MOV      r5,r0
;;;409    	uint16 totalCount, readCount;
;;;410    	uint32 addr;
;;;411    
;;;412    	if(NULL == pTrack)
000006  2d00              CMP      r5,#0
000008  d010              BEQ      |L17.44|
;;;413    	{
;;;414    		return FALSE;
;;;415    	}
;;;416    
;;;417    	// 读取已有记录条数和已读出条数
;;;418    	totalCount = SPI_FLASH_ReadHalfWord(RECORD_ADDR_TOTAL);
00000a  4818              LDR      r0,|L17.108|
00000c  f7fffffe          BL       SPI_FLASH_ReadHalfWord
000010  4607              MOV      r7,r0
;;;419    	readCount = SPI_FLASH_ReadHalfWord(RECORD_ADDR_SEND_COUNT);
000012  4e16              LDR      r6,|L17.108|
000014  1cb6              ADDS     r6,r6,#2
000016  4630              MOV      r0,r6
000018  f7fffffe          BL       SPI_FLASH_ReadHalfWord
00001c  4604              MOV      r4,r0
;;;420    	
;;;421    	// 已读出数达到或超出总条数，退出，清除历史记录
;;;422    	if(readCount >= totalCount)
00001e  42bc              CMP      r4,r7
000020  d306              BCC      |L17.48|
;;;423    	{
;;;424    		RECORD_ClearRecords();
000022  f7fffffe          BL       RECORD_ClearRecords
;;;425    		return FALSE;
000026  2000              MOVS     r0,#0
                  |L17.40|
;;;426    	}
;;;427    
;;;428    	// 计算读取的首地址
;;;429    	addr = sizeof(RECORD_PARAM_CB);
;;;430    	addr *= readCount;
;;;431    	addr += RECORD_ADDR_DATA_START;
;;;432    
;;;433    	// 读取
;;;434    	SPI_FLASH_ReadArray(pTrack->array, addr, sizeof(RECORD_PARAM_CB));
;;;435    	
;;;436    	// 判断校验位是否是正确的数据
;;;437    	if (pTrack->param.packCheck != RECORD_Check(pTrack->array, sizeof(RECORD_ITEM_CB) - 1))
;;;438    	{
;;;439    		return FALSE;
;;;440    	}
;;;441    
;;;442    	// 判断是否是蓝牙校准之后的数据，如果不是，则屏蔽掉这条数据上传并更新发送数据条数
;;;443    	if (0x01 != pTrack->param.isTimeCheck)
;;;444    	{
;;;445    		// 更新已发送历史条数
;;;446    		SPI_FLASH_WriteHalfWord(RECORD_ADDR_SEND_COUNT, readCount+1);
;;;447    		return FALSE;
;;;448    	}
;;;449    	
;;;450    	// 更新已读取计数
;;;451    	//SPI_FLASH_WriteHalfWord(RECORD_ADDR_SEND_COUNT, readCount+1);	 
;;;452    	
;;;453    	return TRUE;
;;;454    }
000028  e8bd81f0          POP      {r4-r8,pc}
                  |L17.44|
00002c  2000              MOVS     r0,#0                 ;414
00002e  e7fb              B        |L17.40|
                  |L17.48|
000030  eb041104          ADD      r1,r4,r4,LSL #4       ;430
000034  f5011160          ADD      r1,r1,#0x380000       ;431
000038  3113              ADDS     r1,r1,#0x13           ;431
00003a  2211              MOVS     r2,#0x11              ;434
00003c  4628              MOV      r0,r5                 ;434
00003e  f7fffffe          BL       SPI_FLASH_ReadArray
000042  2110              MOVS     r1,#0x10              ;437
000044  4628              MOV      r0,r5                 ;437
000046  f7fffffe          BL       RECORD_Check
00004a  7c29              LDRB     r1,[r5,#0x10]         ;437
00004c  4288              CMP      r0,r1                 ;437
00004e  d001              BEQ      |L17.84|
000050  2000              MOVS     r0,#0                 ;439
000052  e7e9              B        |L17.40|
                  |L17.84|
000054  7be8              LDRB     r0,[r5,#0xf]          ;443
000056  2801              CMP      r0,#1                 ;443
000058  d006              BEQ      |L17.104|
00005a  1c64              ADDS     r4,r4,#1              ;446
00005c  b2a1              UXTH     r1,r4                 ;446
00005e  4630              MOV      r0,r6                 ;446
000060  f7fffffe          BL       SPI_FLASH_WriteHalfWord
000064  2000              MOVS     r0,#0                 ;447
000066  e7df              B        |L17.40|
                  |L17.104|
000068  2001              MOVS     r0,#1                 ;453
00006a  e7dd              B        |L17.40|
;;;455    
                          ENDP

                  |L17.108|
                          DCD      0x0038000f

                          AREA ||i.RECORD_RefreashSaveCount||, CODE, READONLY, ALIGN=2

                  RECORD_RefreashSaveCount PROC
;;;477    // 刷新写入写入骑行历史数据条数
;;;478    void RECORD_RefreashSaveCount(void)
000000  b510              PUSH     {r4,lr}
;;;479    {
;;;480    	uint16 totalCount;
;;;481    	totalCount = SPI_FLASH_ReadHalfWord(RECORD_ADDR_TOTAL);
000002  4c05              LDR      r4,|L18.24|
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       SPI_FLASH_ReadHalfWord
;;;482    	
;;;483    	SPI_FLASH_WriteHalfWord(RECORD_ADDR_TOTAL, totalCount+1);
00000a  1c40              ADDS     r0,r0,#1
00000c  b281              UXTH     r1,r0
00000e  4620              MOV      r0,r4
000010  e8bd4010          POP      {r4,lr}
000014  f7ffbffe          B.W      SPI_FLASH_WriteHalfWord
;;;484    }
;;;485    
                          ENDP

                  |L18.24|
                          DCD      0x0038000f

                          AREA ||i.RECORD_RefreashSendCount||, CODE, READONLY, ALIGN=2

                  RECORD_RefreashSendCount PROC
;;;456    // 刷新已发送历史数据条数
;;;457    BOOL RECORD_RefreashSendCount(void)
000000  b570              PUSH     {r4-r6,lr}
;;;458    {
;;;459    	uint16 totalCount,readCount;
;;;460    
;;;461    	// 读取已有记录条数和已读出条数
;;;462    	totalCount = SPI_FLASH_ReadHalfWord(RECORD_ADDR_TOTAL);	
000002  480a              LDR      r0,|L19.44|
000004  f7fffffe          BL       SPI_FLASH_ReadHalfWord
000008  4604              MOV      r4,r0
;;;463    	readCount = SPI_FLASH_ReadHalfWord(RECORD_ADDR_SEND_COUNT);
00000a  4d08              LDR      r5,|L19.44|
00000c  1cad              ADDS     r5,r5,#2
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       SPI_FLASH_ReadHalfWord
;;;464    	
;;;465    	// 已读出数达到或超出总条数，退出
;;;466    	if(readCount >= totalCount)
000014  42a0              CMP      r0,r4
000016  d301              BCC      |L19.28|
;;;467    	{
;;;468    		return FALSE;
000018  2000              MOVS     r0,#0
;;;469    	}
;;;470    
;;;471    	// 更新已发送历史条数
;;;472    	SPI_FLASH_WriteHalfWord(RECORD_ADDR_SEND_COUNT, readCount+1);
;;;473    	
;;;474    	return TRUE;
;;;475    }
00001a  bd70              POP      {r4-r6,pc}
                  |L19.28|
00001c  1c40              ADDS     r0,r0,#1              ;472
00001e  b281              UXTH     r1,r0                 ;472
000020  4628              MOV      r0,r5                 ;472
000022  f7fffffe          BL       SPI_FLASH_WriteHalfWord
000026  2001              MOVS     r0,#1                 ;474
000028  bd70              POP      {r4-r6,pc}
;;;476    
                          ENDP

00002a  0000              DCW      0x0000
                  |L19.44|
                          DCD      0x0038000f

                          AREA ||i.RECORD_SaveToNVM||, CODE, READONLY, ALIGN=2

                  RECORD_SaveToNVM PROC
;;;365    // 将当前缓存写入NVM
;;;366    void RECORD_SaveToNVM(void)
000000  b530              PUSH     {r4,r5,lr}
;;;367    {
000002  b085              SUB      sp,sp,#0x14
;;;368    	uint16 count;
;;;369    	uint32 addr;
;;;370    	RECORD_ITEM_CB track;
;;;371    	
;;;372    	// 当前无缓存，退出
;;;373    	if(!RECORD_IsDirty())
000004  f7fffffe          BL       RECORD_IsDirty
000008  2800              CMP      r0,#0
00000a  d01e              BEQ      |L20.74|
;;;374    	{
;;;375    		return ;
;;;376    	}
;;;377    
;;;378    	// 已有记录条数达到或超过允许数量，退出
;;;379    	count = SPI_FLASH_ReadHalfWord(RECORD_ADDR_TOTAL);
00000c  4d10              LDR      r5,|L20.80|
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       SPI_FLASH_ReadHalfWord
000014  4604              MOV      r4,r0
;;;380    	if(count >= (uint16)RECORD_COUNT_MAX)
000016  f646700d          MOV      r0,#0x6f0d
00001a  4284              CMP      r4,r0
00001c  d215              BCS      |L20.74|
;;;381    	{
;;;382    		return ;
;;;383    	}
;;;384    
;;;385    	// 读取缓存
;;;386    	RECORD_ReadBuffer(&track);
00001e  4668              MOV      r0,sp
000020  f7fffffe          BL       RECORD_ReadBuffer
;;;387    
;;;388    	// 计算待写入位置的首地址
;;;389    	addr = sizeof(RECORD_PARAM_CB);
;;;390    	addr *= count;
000024  eb041104          ADD      r1,r4,r4,LSL #4
;;;391    	addr += RECORD_ADDR_DATA_START;
000028  f5011160          ADD      r1,r1,#0x380000
00002c  3113              ADDS     r1,r1,#0x13
;;;392    
;;;393    	// 写入数据
;;;394    	SPI_FLASH_WriteWithErase(track.array, addr, sizeof(RECORD_PARAM_CB));	
00002e  2211              MOVS     r2,#0x11
000030  4668              MOV      r0,sp
000032  f7fffffe          BL       SPI_FLASH_WriteWithErase
;;;395    
;;;396    	// 记录条数累加
;;;397    	SPI_FLASH_WriteHalfWord(RECORD_ADDR_TOTAL, count+1);
000036  1c64              ADDS     r4,r4,#1
000038  b2a1              UXTH     r1,r4
00003a  4628              MOV      r0,r5
00003c  f7fffffe          BL       SPI_FLASH_WriteHalfWord
;;;398    
;;;399    	// 清除缓存
;;;400    	RECORD_ClearDirtyFlag();
000040  f7fffffe          BL       RECORD_ClearDirtyFlag
;;;401    
;;;402    	// 更新参数层记录的数据记录条数
;;;403    	PARAM_SetRecordCount(count+1);
000044  4803              LDR      r0,|L20.84|
000046  f8a0422a          STRH     r4,[r0,#0x22a]
                  |L20.74|
;;;404    }
00004a  b005              ADD      sp,sp,#0x14
00004c  bd30              POP      {r4,r5,pc}
;;;405    
                          ENDP

00004e  0000              DCW      0x0000
                  |L20.80|
                          DCD      0x0038000f
                  |L20.84|
                          DCD      paramCB

                          AREA ||i.RECORD_SetDirtyFlag||, CODE, READONLY, ALIGN=1

                  RECORD_SetDirtyFlag PROC
;;;52     // 设置脏标识
;;;53     void RECORD_SetDirtyFlag(void)
000000  2155              MOVS     r1,#0x55
;;;54     {
;;;55     	// 写统计数据后，设置脏标识
;;;56     	DS1302_WriteRAM(RECORD_PARAM_ADDR_DIRTY_FLAG, 0x55);
000002  2001              MOVS     r0,#1
000004  f7ffbffe          B.W      DS1302_WriteRAM
;;;57     }
;;;58     
                          ENDP


                          AREA ||i.RECORD_Update||, CODE, READONLY, ALIGN=2

                  RECORD_Update PROC
;;;274    // 未授时骑行记录更新
;;;275    void RECORD_Update(uint32 param)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;276    {
;;;277    	static uint8 updateFlag;
;;;278    	//static uint32 ridingTime;
;;;279    	static uint32 distance;
;;;280    	static uint32 calories;
;;;281    	static uint16 tripTimeTmp;
;;;282    	
;;;283    	recordTmpCB.tirpTime++;
000004  4b55              LDR      r3,|L22.348|
000006  6859              LDR      r1,[r3,#4]  ; recordTmpCB
000008  1c49              ADDS     r1,r1,#1
00000a  6059              STR      r1,[r3,#4]  ; recordTmpCB
;;;284    	tripTimeTmp++;
00000c  4e54              LDR      r6,|L22.352|
00000e  8871              LDRH     r1,[r6,#2]  ; tripTimeTmp
000010  1c49              ADDS     r1,r1,#1
000012  b28d              UXTH     r5,r1
000014  8075              STRH     r5,[r6,#2]
;;;285    
;;;286    	// 首次进来备份当前信息
;;;287    	if (updateFlag == 0)
;;;288    	{
;;;289    		// 清除参数层保存的用户最大速度
;;;290    		PARAM_ClearUserMaxSpeed();
000016  4c53              LDR      r4,|L22.356|
000018  f8969000          LDRB     r9,[r6,#0]            ;287  ; updateFlag
00001c  2700              MOVS     r7,#0                 ;287
00001e  f8d4234c          LDR      r2,[r4,#0x34c]        ;287
000022  f8d4133c          LDR      r1,[r4,#0x33c]        ;287
;;;291    	
;;;292    		//ridingTime = PARAM_GetTotalRidingTime();
;;;293    		distance = paramCB.nvm.param.common.record.total.distance;
;;;294    		calories = PARAM_GetTotalCalories();
;;;295    		
;;;296    		updateFlag = 1;
;;;297    		
;;;298    		tripTimeTmp = 1;
;;;299    	}else if ((param == 1) && (updateFlag == 1))
;;;300    	{
;;;301    		updateFlag = 0;
;;;302    
;;;303    		if (recordTmpCB.tirpNum >= RECORD_RIDING_COUNT)
000026  f44f7890          MOV      r8,#0x120
;;;304    		{
;;;305    			return;
;;;306    		}
;;;307    		
;;;308    		// 骑行时间段时间,此时间段内的里程为0，则不更新骑行时间
;;;309    		if (paramCB.nvm.param.common.record.total.distance - distance != 0)
;;;310    		{
;;;311    			recordTmpCB.recordItemTmp[recordTmpCB.tirpNum].recordparam.ridingTime += tripTimeTmp;
;;;312    		}
;;;313    		
;;;314    		// 骑行累计分钟时刻
;;;315    		recordTmpCB.recordItemTmp[recordTmpCB.tirpNum].recordparam.min = (uint16)(recordTmpCB.tirpTime/60);
00002a  f04f0c3c          MOV      r12,#0x3c
00002e  f1b90f00          CMP      r9,#0                 ;287
000032  d002              BEQ      |L22.58|
000034  2801              CMP      r0,#1                 ;299
000036  d008              BEQ      |L22.74|
000038  e04a              B        |L22.208|
                  |L22.58|
00003a  f8a47260          STRH     r7,[r4,#0x260]        ;290
00003e  6071              STR      r1,[r6,#4]            ;293  ; distance
000040  60b2              STR      r2,[r6,#8]            ;294  ; calories
000042  2001              MOVS     r0,#1                 ;296
000044  7030              STRB     r0,[r6,#0]            ;296
000046  8070              STRH     r0,[r6,#2]            ;298
000048  e042              B        |L22.208|
                  |L22.74|
00004a  f1b90f01          CMP      r9,#1                 ;299
00004e  d13f              BNE      |L22.208|
000050  7037              STRB     r7,[r6,#0]            ;301
000052  f8b39002          LDRH     r9,[r3,#2]            ;303  ; recordTmpCB
000056  45c1              CMP      r9,r8                 ;303
000058  d27d              BCS      |L22.342|
00005a  6870              LDR      r0,[r6,#4]            ;309  ; distance
00005c  4281              CMP      r1,r0                 ;309
00005e  d008              BEQ      |L22.114|
000060  eb090989          ADD      r9,r9,r9,LSL #2       ;311
000064  eb030949          ADD      r9,r3,r9,LSL #1       ;311
000068  f8b9a010          LDRH     r10,[r9,#0x10]        ;311
00006c  4455              ADD      r5,r5,r10             ;311
00006e  f8a95010          STRH     r5,[r9,#0x10]         ;311
                  |L22.114|
000072  685d              LDR      r5,[r3,#4]  ; recordTmpCB
000074  fbb5f9fc          UDIV     r9,r5,r12
000078  885d              LDRH     r5,[r3,#2]  ; recordTmpCB
00007a  eb050585          ADD      r5,r5,r5,LSL #2
00007e  eb030545          ADD      r5,r3,r5,LSL #1
000082  f8a5900e          STRH     r9,[r5,#0xe]
;;;316    		
;;;317    		// 骑行最大速度
;;;318    		if (recordTmpCB.recordItemTmp[recordTmpCB.tirpNum].recordparam.speedMax < PARAM_GetUserMaxSpeed())
000086  885d              LDRH     r5,[r3,#2]  ; recordTmpCB
000088  f8b4a260          LDRH     r10,[r4,#0x260]  ; paramCB
00008c  eb050585          ADD      r5,r5,r5,LSL #2
000090  eb030545          ADD      r5,r3,r5,LSL #1
000094  f8b5900c          LDRH     r9,[r5,#0xc]
000098  45d1              CMP      r9,r10
00009a  d201              BCS      |L22.160|
;;;319    		{
;;;320    			recordTmpCB.recordItemTmp[recordTmpCB.tirpNum].recordparam.speedMax = PARAM_GetUserMaxSpeed();
00009c  f8a5a00c          STRH     r10,[r5,#0xc]
                  |L22.160|
;;;321    		}
;;;322    		
;;;323    		// 骑行卡路里
;;;324    		recordTmpCB.recordItemTmp[recordTmpCB.tirpNum].recordparam.calories += PARAM_GetTotalCalories() - calories;;
0000a0  885d              LDRH     r5,[r3,#2]  ; recordTmpCB
0000a2  f896a008          LDRB     r10,[r6,#8]  ; calories
0000a6  eb050585          ADD      r5,r5,r5,LSL #2
0000aa  eb030545          ADD      r5,r3,r5,LSL #1
0000ae  eba20a0a          SUB      r10,r2,r10
0000b2  f8959009          LDRB     r9,[r5,#9]
0000b6  44d1              ADD      r9,r9,r10
0000b8  f8859009          STRB     r9,[r5,#9]
;;;325    		
;;;326    		// 骑行里程
;;;327    		recordTmpCB.recordItemTmp[recordTmpCB.tirpNum].recordparam.trip += paramCB.nvm.param.common.record.total.distance - distance;
0000bc  885d              LDRH     r5,[r3,#2]  ; recordTmpCB
0000be  1a08              SUBS     r0,r1,r0
0000c0  eb050585          ADD      r5,r5,r5,LSL #2
0000c4  eb030545          ADD      r5,r3,r5,LSL #1
0000c8  f895900a          LDRB     r9,[r5,#0xa]
0000cc  4448              ADD      r0,r0,r9
0000ce  72a8              STRB     r0,[r5,#0xa]
                  |L22.208|
;;;328    	}
;;;329    	
;;;330    	// 未授时情况下，一旦开始骑行就开始每5min记录一次数据
;;;331    	if (recordTmpCB.tirpTime%RECORD_RIDING_TIME == 0)
0000d0  6858              LDR      r0,[r3,#4]  ; recordTmpCB
0000d2  f44f7596          MOV      r5,#0x12c
0000d6  fbb0f9f5          UDIV     r9,r0,r5
0000da  fb050019          MLS      r0,r5,r9,r0
0000de  2800              CMP      r0,#0
0000e0  d139              BNE      |L22.342|
;;;332    	{
;;;333    		updateFlag = 0;
0000e2  7037              STRB     r7,[r6,#0]
;;;334    
;;;335    		if (recordTmpCB.tirpNum >= RECORD_RIDING_COUNT)
0000e4  8858              LDRH     r0,[r3,#2]  ; recordTmpCB
0000e6  4540              CMP      r0,r8
0000e8  d235              BCS      |L22.342|
;;;336    		{
;;;337    			return;
;;;338    		}
;;;339    		
;;;340    		// 骑行时间段时间,此时间段内的里程为0，则不更新骑行时间
;;;341    		if (paramCB.nvm.param.common.record.total.distance - distance != 0)
0000ea  6875              LDR      r5,[r6,#4]  ; distance
0000ec  42a9              CMP      r1,r5
0000ee  d008              BEQ      |L22.258|
;;;342    		{
;;;343    			recordTmpCB.recordItemTmp[recordTmpCB.tirpNum].recordparam.ridingTime += tripTimeTmp;
0000f0  eb000080          ADD      r0,r0,r0,LSL #2
0000f4  eb030040          ADD      r0,r3,r0,LSL #1
0000f8  f8b68002          LDRH     r8,[r6,#2]  ; tripTimeTmp
0000fc  8a07              LDRH     r7,[r0,#0x10]
0000fe  4447              ADD      r7,r7,r8
000100  8207              STRH     r7,[r0,#0x10]
                  |L22.258|
;;;344    		}
;;;345    		
;;;346    		// 骑行累计分钟时刻
;;;347    		recordTmpCB.recordItemTmp[recordTmpCB.tirpNum].recordparam.min = (uint16)(recordTmpCB.tirpTime/60);
000102  6858              LDR      r0,[r3,#4]  ; recordTmpCB
000104  fbb0f7fc          UDIV     r7,r0,r12
000108  8858              LDRH     r0,[r3,#2]  ; recordTmpCB
00010a  eb000080          ADD      r0,r0,r0,LSL #2
00010e  eb030040          ADD      r0,r3,r0,LSL #1
000112  81c7              STRH     r7,[r0,#0xe]
;;;348    		
;;;349    		// 骑行最大速度
;;;350    		if (recordTmpCB.recordItemTmp[recordTmpCB.tirpNum].recordparam.speedMax < PARAM_GetUserMaxSpeed())
000114  8858              LDRH     r0,[r3,#2]  ; recordTmpCB
000116  f8b44260          LDRH     r4,[r4,#0x260]  ; paramCB
00011a  eb000080          ADD      r0,r0,r0,LSL #2
00011e  eb030040          ADD      r0,r3,r0,LSL #1
000122  8987              LDRH     r7,[r0,#0xc]
000124  42a7              CMP      r7,r4
000126  d200              BCS      |L22.298|
;;;351    		{
;;;352    			recordTmpCB.recordItemTmp[recordTmpCB.tirpNum].recordparam.speedMax = PARAM_GetUserMaxSpeed();
000128  8184              STRH     r4,[r0,#0xc]
                  |L22.298|
;;;353    		}
;;;354    		
;;;355    		// 骑行卡路里
;;;356    		recordTmpCB.recordItemTmp[recordTmpCB.tirpNum].recordparam.calories += PARAM_GetTotalCalories() - calories;;
00012a  8858              LDRH     r0,[r3,#2]  ; recordTmpCB
00012c  7a36              LDRB     r6,[r6,#8]  ; calories
00012e  eb000080          ADD      r0,r0,r0,LSL #2
000132  eb030040          ADD      r0,r3,r0,LSL #1
000136  1b92              SUBS     r2,r2,r6
000138  7a44              LDRB     r4,[r0,#9]
00013a  4422              ADD      r2,r2,r4
00013c  7242              STRB     r2,[r0,#9]
;;;357    		
;;;358    		// 骑行里程
;;;359    		recordTmpCB.recordItemTmp[recordTmpCB.tirpNum].recordparam.trip += paramCB.nvm.param.common.record.total.distance - distance;
00013e  8858              LDRH     r0,[r3,#2]  ; recordTmpCB
000140  1b49              SUBS     r1,r1,r5
000142  eb000080          ADD      r0,r0,r0,LSL #2
000146  eb030040          ADD      r0,r3,r0,LSL #1
00014a  7a82              LDRB     r2,[r0,#0xa]
00014c  4411              ADD      r1,r1,r2
00014e  7281              STRB     r1,[r0,#0xa]
;;;360    
;;;361    		recordTmpCB.tirpNum++;
000150  8858              LDRH     r0,[r3,#2]  ; recordTmpCB
000152  1c40              ADDS     r0,r0,#1
000154  8058              STRH     r0,[r3,#2]
                  |L22.342|
;;;362    	}
;;;363    }
000156  e8bd87f0          POP      {r4-r10,pc}
;;;364    
                          ENDP

00015a  0000              DCW      0x0000
                  |L22.348|
                          DCD      ||.bss||
                  |L22.352|
                          DCD      ||.data||
                  |L22.356|
                          DCD      paramCB

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  recordTmpCB
                          %        2888
                  recordCB
                          %        52

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  constFormatFlag
000000  32303230          DCB      0x32,0x30,0x32,0x30
000004  30383036          DCB      0x30,0x38,0x30,0x36
000008  31333431          DCB      0x31,0x33,0x34,0x31
00000c  303100            DCB      0x30,0x31,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  updateFlag
000000  00                DCB      0x00
                  lastSecond
000001  00                DCB      0x00
                  tripTimeTmp
000002  0000              DCB      0x00,0x00
                  distance
                          DCD      0x00000000
                  calories
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "User\\record.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_record_c_6d18042d____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___8_record_c_6d18042d____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_record_c_6d18042d____REVSH|
#line 128
|__asm___8_record_c_6d18042d____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
