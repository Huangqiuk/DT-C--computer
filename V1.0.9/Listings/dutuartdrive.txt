; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\dutuartdrive.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\dutuartdrive.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -I.\User\qrencode -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.3\Device\Include -D__MICROLIB -D__UVISION_VERSION=539 -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\dutuartdrive.crf User\DutUartDrive.c]
                          THUMB

                          AREA ||i.CHANGE_Init||, CODE, READONLY, ALIGN=2

                  CHANGE_Init PROC
;;;32     
;;;33     void CHANGE_Init(void)
000000  b510              PUSH     {r4,lr}
;;;34     {
;;;35     	// 打开时钟
;;;36     	rcu_periph_clock_enable(RCU_GPIOC);
000002  f2406004          MOV      r0,#0x604
000006  f7fffffe          BL       rcu_periph_clock_enable
;;;37     	
;;;38     	// 配置为高阻态模式
;;;39     	gpio_init(GPIOC, GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_8); // 3V3_5V_CHANGE
00000a  4c08              LDR      r4,|L1.44|
00000c  f44f7380          MOV      r3,#0x100
000010  2203              MOVS     r2,#3
000012  2110              MOVS     r1,#0x10
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       gpio_init
;;;40     	gpio_init(GPIOC, GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_9); // VCCB_EN
00001a  1563              ASRS     r3,r4,#21
00001c  4620              MOV      r0,r4
00001e  2203              MOVS     r2,#3
000020  e8bd4010          POP      {r4,lr}
000024  2110              MOVS     r1,#0x10
000026  f7ffbffe          B.W      gpio_init
;;;41     }
;;;42     
                          ENDP

00002a  0000              DCW      0x0000
                  |L1.44|
                          DCD      0x40011000

                          AREA ||i.UART3_IRQHandler||, CODE, READONLY, ALIGN=2

                  UART3_IRQHandler PROC
;;;139     *************************************************************/
;;;140    void UART3_IRQHandler(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;141    {
;;;142    	// 判断DR是否有数据，中断接收
;;;143    	if (usart_interrupt_flag_get(UART_DRIVE_TYPE_DEF, USART_INT_FLAG_RBNE) != RESET)
000002  4d41              LDR      r5,|L2.264|
000004  493f              LDR      r1,|L2.260|
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       usart_interrupt_flag_get
;;;144    	{
;;;145    		uint8 rxdata = 0x00;
;;;146    
;;;147    		// 接收数据
;;;148    		rxdata = (uint8)usart_data_receive(UART_DRIVE_TYPE_DEF);
;;;149    
;;;150    		if (NULL != uartDriveCB.receiveDataThrowService)
00000c  4e3f              LDR      r6,|L2.268|
00000e  2700              MOVS     r7,#0                 ;143
000010  b1f8              CBZ      r0,|L2.82|
000012  9700              STR      r7,[sp,#0]            ;145
000014  4628              MOV      r0,r5                 ;148
000016  f7fffffe          BL       usart_data_receive
00001a  9000              STR      r0,[sp,#0]            ;148
00001c  6830              LDR      r0,[r6,#0]  ; uartDriveCB
00001e  b1c0              CBZ      r0,|L2.82|
;;;151    		{
;;;152                    if(dut_info.passThroughControl)           
000020  4c3b              LDR      r4,|L2.272|
000022  f8940120          LDRB     r0,[r4,#0x120]  ; dut_info
000026  b170              CBZ      r0,|L2.70|
;;;153                    {
;;;154                        dut_info.online_dete_cnt++;            
000028  f5047492          ADD      r4,r4,#0x124
00002c  6820              LDR      r0,[r4,#0]  ; dut_info
00002e  1c40              ADDS     r0,r0,#1
000030  6020              STR      r0,[r4,#0]  ; dut_info
;;;155                        TIMER_ResetTimer(TIMER_ID_ONLINE_DETECT);
000032  2011              MOVS     r0,#0x11
000034  f7fffffe          BL       TIMER_ResetTimer
;;;156                        
;;;157            //            // 防止累加越界
;;;158            //            if(2 < dut_info.online_dete_cnt)
;;;159            //            {
;;;160            //                dut_info.online_dete_cnt = 2;
;;;161            //            }
;;;162                        
;;;163                        if(1 == dut_info.online_dete_cnt)
000038  6820              LDR      r0,[r4,#0]  ; dut_info
00003a  2801              CMP      r0,#1
00003c  d103              BNE      |L2.70|
;;;164                        {
;;;165                           // 上报仪表启动状态
;;;166                           STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_ONLINE_DETECTION,TRUE);
00003e  2101              MOVS     r1,#1
000040  2018              MOVS     r0,#0x18
000042  f7fffffe          BL       STS_PROTOCOL_SendCmdParamAck
                  |L2.70|
;;;167                        }
;;;168                    }
;;;169    			(*uartDriveCB.receiveDataThrowService)(0xFFF, &rxdata, 1);
000046  6833              LDR      r3,[r6,#0]  ; uartDriveCB
000048  2201              MOVS     r2,#1
00004a  4669              MOV      r1,sp
00004c  f64070ff          MOV      r0,#0xfff
000050  4798              BLX      r3
                  |L2.82|
;;;170    		}
;;;171    	}
;;;172    
;;;173    // 中断模式发送
;;;174    #if (UART_DRIVE_TX_MODE == UART_DRIVE_INTERRUPT_TX_MODE)
;;;175    	// 判断DR是否有数据，中断发送
;;;176    	if (usart_interrupt_flag_get(UART_DRIVE_TYPE_DEF, USART_INT_FLAG_TC) != RESET)
000052  4930              LDR      r1,|L2.276|
000054  4628              MOV      r0,r5
000056  f7fffffe          BL       usart_interrupt_flag_get
00005a  b3d0              CBZ      r0,|L2.210|
;;;177    	{
;;;178    		uint16 head = uartDriveCB.tx.head;
00005c  4c2e              LDR      r4,|L2.280|
00005e  f8b40a40          LDRH     r0,[r4,#0xa40]  ; uartDriveCB
;;;179    		uint16 end;
;;;180    		uint16 index = uartDriveCB.tx.index;
000062  f8b41a44          LDRH     r1,[r4,#0xa44]  ; uartDriveCB
;;;181    		uint8 txdata = 0x00;
;;;182    
;;;183    		// 执行到这里，说明上一个数据已经发送完毕，当前命令帧未发送完时，取出一个字节放到发送寄存器中
;;;184    		if (index < uartDriveCB.tx.cmdQueue[head].length)
000066  224d              MOVS     r2,#0x4d
000068  4350              MULS     r0,r2,r0
00006a  eb060240          ADD      r2,r6,r0,LSL #1
00006e  f8b2009c          LDRH     r0,[r2,#0x9c]
000072  4288              CMP      r0,r1
000074  d90a              BLS      |L2.140|
;;;185    		{
;;;186    			txdata = uartDriveCB.tx.cmdQueue[head].buff[uartDriveCB.tx.index++];
000076  f8b41a44          LDRH     r1,[r4,#0xa44]  ; uartDriveCB
00007a  1c48              ADDS     r0,r1,#1
00007c  f8a40a44          STRH     r0,[r4,#0xa44]
000080  1888              ADDS     r0,r1,r2
000082  7981              LDRB     r1,[r0,#6]
;;;187    
;;;188    			// 填充数据
;;;189    			usart_data_transmit(UART_DRIVE_TYPE_DEF, txdata);
000084  4628              MOV      r0,r5
000086  f7fffffe          BL       usart_data_transmit
00008a  e02a              B        |L2.226|
                  |L2.140|
;;;190    		}
;;;191    		// 当前命令帧发送完时，删除之
;;;192    		else
;;;193    		{
;;;194    			uartDriveCB.tx.cmdQueue[head].length = 0;
00008c  f8a2709c          STRH     r7,[r2,#0x9c]
;;;195    			uartDriveCB.tx.head++;
000090  f5046424          ADD      r4,r4,#0xa40
000094  8820              LDRH     r0,[r4,#0]  ; uartDriveCB
000096  1c40              ADDS     r0,r0,#1
000098  8020              STRH     r0,[r4,#0]
;;;196    			uartDriveCB.tx.head %= UART_DRIVE_TX_QUEUE_SIZE;
00009a  8820              LDRH     r0,[r4,#0]  ; uartDriveCB
00009c  2196              MOVS     r1,#0x96
00009e  fbb0f2f1          UDIV     r2,r0,r1
0000a2  fb010012          MLS      r0,r1,r2,r0
0000a6  8020              STRH     r0,[r4,#0]
;;;197    			uartDriveCB.tx.index = 0;
0000a8  80a7              STRH     r7,[r4,#4]
;;;198    
;;;199    			head = uartDriveCB.tx.head;
0000aa  8822              LDRH     r2,[r4,#0]  ; uartDriveCB
;;;200    			end = uartDriveCB.tx.end;
0000ac  8860              LDRH     r0,[r4,#2]  ; uartDriveCB
0000ae  f5a46424          SUB      r4,r4,#0xa40
;;;201    
;;;202    			// 命令帧队列非空，继续发送下一个命令帧
;;;203    			if (head != end)
0000b2  4282              CMP      r2,r0
0000b4  d00e              BEQ      |L2.212|
;;;204    			{
;;;205    				txdata = uartDriveCB.tx.cmdQueue[head].buff[uartDriveCB.tx.index++];
0000b6  f8b41a44          LDRH     r1,[r4,#0xa44]  ; uartDriveCB
0000ba  1c48              ADDS     r0,r1,#1
0000bc  f8a40a44          STRH     r0,[r4,#0xa44]
0000c0  204d              MOVS     r0,#0x4d
0000c2  4342              MULS     r2,r0,r2
0000c4  eb060042          ADD      r0,r6,r2,LSL #1
0000c8  4408              ADD      r0,r0,r1
0000ca  7981              LDRB     r1,[r0,#6]
;;;206    
;;;207    				// 填充数据
;;;208    				usart_data_transmit(UART_DRIVE_TYPE_DEF, txdata);
0000cc  4628              MOV      r0,r5
0000ce  f7fffffe          BL       usart_data_transmit
                  |L2.210|
0000d2  e006              B        |L2.226|
                  |L2.212|
;;;209    			}
;;;210    			// 命令帧队列为空停止发送，设置空闲
;;;211    			else
;;;212    			{
;;;213    				// 关闭发送空中断
;;;214    				usart_interrupt_disable(UART_DRIVE_TYPE_DEF, USART_INT_TC);
0000d4  f2403106          MOV      r1,#0x306
0000d8  4628              MOV      r0,r5
0000da  f7fffffe          BL       usart_interrupt_disable
;;;215    
;;;216    				uartDriveCB.tx.txBusy = FALSE;
0000de  f8847a46          STRB     r7,[r4,#0xa46]
                  |L2.226|
;;;217    			}
;;;218    		}
;;;219    	}
;;;220    #endif
;;;221    
;;;222    	// Other USARTx interrupts handler can go here ...
;;;223    	if (usart_interrupt_flag_get(UART_DRIVE_TYPE_DEF, USART_INT_FLAG_ERR_ORERR) != RESET) //----------------------- 接收溢出中断
0000e2  490e              LDR      r1,|L2.284|
0000e4  4628              MOV      r0,r5
0000e6  f7fffffe          BL       usart_interrupt_flag_get
0000ea  2800              CMP      r0,#0
0000ec  d008              BEQ      |L2.256|
;;;224    	{
;;;225    		usart_flag_get(UART_DRIVE_TYPE_DEF, USART_FLAG_ORERR); //----------------------- 清除接收溢出中断标志位
0000ee  2103              MOVS     r1,#3
0000f0  4628              MOV      r0,r5
0000f2  f7fffffe          BL       usart_flag_get
;;;226    		usart_data_receive(UART_DRIVE_TYPE_DEF);			   //----------------------- 清空寄存器
0000f6  4628              MOV      r0,r5
0000f8  e8bd40f8          POP      {r3-r7,lr}
0000fc  f7ffbffe          B.W      usart_data_receive
                  |L2.256|
;;;227    	}
;;;228    }
000100  bdf8              POP      {r3-r7,pc}
;;;229    
                          ENDP

000102  0000              DCW      0x0000
                  |L2.260|
                          DCD      0x00050305
                  |L2.264|
                          DCD      0x40004c00
                  |L2.268|
                          DCD      ||.bss||
                  |L2.272|
                          DCD      dut_info
                  |L2.276|
                          DCD      0x00060306
                  |L2.280|
                          DCD      ||.bss||+0x5000
                  |L2.284|
                          DCD      0x00030500

                          AREA ||i.UART_DRIVE_AddTxArray||, CODE, READONLY, ALIGN=2

                  UART_DRIVE_AddTxArray PROC
;;;337    // 向发送缓冲区中添加一条待发送序列
;;;338    BOOL UART_DRIVE_AddTxArray(uint16 id, uint8 *pArray, uint16 length)
000000  b5f0              PUSH     {r4-r7,lr}
;;;339    {
;;;340    	uint16 i;
;;;341    	uint16 head = uartDriveCB.tx.head;
000002  4b1e              LDR      r3,|L3.124|
000004  f8b37a40          LDRH     r7,[r3,#0xa40]  ; uartDriveCB
;;;342    	uint16 end = uartDriveCB.tx.end;
000008  f8b34a42          LDRH     r4,[r3,#0xa42]  ; uartDriveCB
;;;343    
;;;344    	// 参数检验
;;;345    	if ((NULL == pArray) || (0 == length))
00000c  2900              CMP      r1,#0
00000e  d00a              BEQ      |L3.38|
000010  b14a              CBZ      r2,|L3.38|
;;;346    	{
;;;347    		return FALSE;
;;;348    	}
;;;349    
;;;350    	// 发送缓冲区已满，不予接收
;;;351    	if ((end + 1) % UART_DRIVE_TX_QUEUE_SIZE == head)
000012  1c66              ADDS     r6,r4,#1
000014  2596              MOVS     r5,#0x96
000016  fbb6fcf5          UDIV     r12,r6,r5
00001a  fb05661c          MLS      r6,r5,r12,r6
00001e  42be              CMP      r6,r7
000020  d103              BNE      |L3.42|
;;;352    	{
;;;353    		return FALSE;
000022  2000              MOVS     r0,#0
;;;354    	}
;;;355    
;;;356    	uartDriveCB.tx.cmdQueue[end].deviceID = id;
;;;357    	for (i = 0; i < length; i++)
;;;358    	{
;;;359    		uartDriveCB.tx.cmdQueue[end].buff[i] = *pArray++;
;;;360    	}
;;;361    	uartDriveCB.tx.cmdQueue[end].length = length;
;;;362    
;;;363    	// 发送环形队列更新位置
;;;364    	uartDriveCB.tx.end++;
;;;365    	uartDriveCB.tx.end %= UART_DRIVE_TX_QUEUE_SIZE;
;;;366    	uartDriveCB.tx.cmdQueue[uartDriveCB.tx.end].length = 0;
;;;367    
;;;368    	return TRUE;
;;;369    }
000024  bdf0              POP      {r4-r7,pc}
                  |L3.38|
000026  2000              MOVS     r0,#0                 ;347
000028  bdf0              POP      {r4-r7,pc}
                  |L3.42|
00002a  264d              MOVS     r6,#0x4d              ;356
00002c  4374              MULS     r4,r6,r4              ;356
00002e  4e14              LDR      r6,|L3.128|
000030  eb060444          ADD      r4,r6,r4,LSL #1       ;356
000034  80a0              STRH     r0,[r4,#4]            ;356
000036  2000              MOVS     r0,#0                 ;357
000038  e007              B        |L3.74|
                  |L3.58|
00003a  eb040c00          ADD      r12,r4,r0             ;359
00003e  f8117b01          LDRB     r7,[r1],#1            ;359
000042  f88c7006          STRB     r7,[r12,#6]           ;359
000046  1c40              ADDS     r0,r0,#1              ;357
000048  b280              UXTH     r0,r0                 ;357
                  |L3.74|
00004a  4290              CMP      r0,r2                 ;357
00004c  d3f5              BCC      |L3.58|
00004e  f8a4209c          STRH     r2,[r4,#0x9c]         ;361
000052  f6032342          ADD      r3,r3,#0xa42          ;364
000056  8818              LDRH     r0,[r3,#0]            ;364  ; uartDriveCB
000058  1c40              ADDS     r0,r0,#1              ;364
00005a  8018              STRH     r0,[r3,#0]            ;364
00005c  8818              LDRH     r0,[r3,#0]            ;365  ; uartDriveCB
00005e  fbb0f1f5          UDIV     r1,r0,r5              ;365
000062  fb050011          MLS      r0,r5,r1,r0           ;365
000066  8018              STRH     r0,[r3,#0]            ;365
000068  8818              LDRH     r0,[r3,#0]            ;366  ; uartDriveCB
00006a  2100              MOVS     r1,#0                 ;366
00006c  224d              MOVS     r2,#0x4d              ;366
00006e  4350              MULS     r0,r2,r0              ;366
000070  eb060040          ADD      r0,r6,r0,LSL #1       ;366
000074  f8a0109c          STRH     r1,[r0,#0x9c]         ;366
000078  2001              MOVS     r0,#1                 ;368
00007a  bdf0              POP      {r4-r7,pc}
                          ENDP

                  |L3.124|
                          DCD      ||.bss||+0x5000
                  |L3.128|
                          DCD      ||.bss||

                          AREA ||i.UART_DRIVE_BC_SendData||, CODE, READONLY, ALIGN=2

                  UART_DRIVE_BC_SendData PROC
;;;243    // 阻塞发送一个字节数据
;;;244    void UART_DRIVE_BC_SendData(uint8 data)
000000  b570              PUSH     {r4-r6,lr}
;;;245    {
000002  4605              MOV      r5,r0
;;;246    	// 防止丢失第一个字节(清除空标志位,务必加)
;;;247    	usart_flag_get(UART_DRIVE_TYPE_DEF, USART_FLAG_TC);
000004  4c07              LDR      r4,|L4.36|
000006  2106              MOVS     r1,#6
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       usart_flag_get
;;;248    
;;;249    	// 填充数据
;;;250    	usart_data_transmit(UART_DRIVE_TYPE_DEF, data);
00000e  4629              MOV      r1,r5
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       usart_data_transmit
                  |L4.22|
;;;251    
;;;252    	// 未发送完，持续等待
;;;253    	while (usart_flag_get(UART_DRIVE_TYPE_DEF, USART_FLAG_TC) != SET)
000016  2106              MOVS     r1,#6
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       usart_flag_get
00001e  2801              CMP      r0,#1
000020  d1f9              BNE      |L4.22|
;;;254    		;
;;;255    }
000022  bd70              POP      {r4-r6,pc}
;;;256    
                          ENDP

                  |L4.36|
                          DCD      0x40004c00

                          AREA ||i.UART_DRIVE_BC_StartTx||, CODE, READONLY, ALIGN=1

                  UART_DRIVE_BC_StartTx PROC
;;;257    // 启动阻塞发送
;;;258    void UART_DRIVE_BC_StartTx(UART_DRIVE_CB *pCB)
000000  b570              PUSH     {r4-r6,lr}
;;;259    {
;;;260    	uint16 index = pCB->tx.index;
000002  f50044a0          ADD      r4,r0,#0x5000
000006  f8b41a44          LDRH     r1,[r4,#0xa44]
;;;261    	uint16 head = pCB->tx.head;
00000a  f8b42a40          LDRH     r2,[r4,#0xa40]
;;;262    	uint16 end = pCB->tx.end;
00000e  f8b43a42          LDRH     r3,[r4,#0xa42]
;;;263    
;;;264    	// 参数合法性检验
;;;265    	if (NULL == pCB)
000012  2800              CMP      r0,#0
000014  d025              BEQ      |L5.98|
;;;266    	{
;;;267    		return;
;;;268    	}
;;;269    
;;;270    	// 队列为空，不处理
;;;271    	if (head == end)
000016  429a              CMP      r2,r3
000018  d023              BEQ      |L5.98|
;;;272    	{
;;;273    		return;
;;;274    	}
;;;275    
;;;276    	// 当前命令帧未发送完时，持续发送
;;;277    	while (index < pCB->tx.cmdQueue[head].length)
;;;278    	{
;;;279    		// 一直填充发送
;;;280    		UART_DRIVE_BC_SendData(pCB->tx.cmdQueue[head].buff[pCB->tx.index++]);
00001a  234d              MOVS     r3,#0x4d
00001c  435a              MULS     r2,r3,r2
00001e  eb000542          ADD      r5,r0,r2,LSL #1
000022  e00a              B        |L5.58|
                  |L5.36|
000024  f8b40a44          LDRH     r0,[r4,#0xa44]
000028  1c41              ADDS     r1,r0,#1
00002a  f8a41a44          STRH     r1,[r4,#0xa44]
00002e  4428              ADD      r0,r0,r5
000030  7980              LDRB     r0,[r0,#6]
000032  f7fffffe          BL       UART_DRIVE_BC_SendData
;;;281    
;;;282    		index = pCB->tx.index;
000036  f8b41a44          LDRH     r1,[r4,#0xa44]
                  |L5.58|
00003a  f8b5009c          LDRH     r0,[r5,#0x9c]         ;277
00003e  4288              CMP      r0,r1                 ;277
000040  d8f0              BHI      |L5.36|
;;;283    	}
;;;284    
;;;285    	// 当前命令帧发送完时，删除之
;;;286    	pCB->tx.cmdQueue[head].length = 0;
000042  2200              MOVS     r2,#0
000044  f8a5209c          STRH     r2,[r5,#0x9c]
;;;287    	pCB->tx.head++;
000048  f5046424          ADD      r4,r4,#0xa40
00004c  8820              LDRH     r0,[r4,#0]
00004e  1c40              ADDS     r0,r0,#1
000050  8020              STRH     r0,[r4,#0]
;;;288    	pCB->tx.head %= UART_DRIVE_TX_QUEUE_SIZE;
000052  8820              LDRH     r0,[r4,#0]
000054  2196              MOVS     r1,#0x96
000056  fbb0f3f1          UDIV     r3,r0,r1
00005a  fb010013          MLS      r0,r1,r3,r0
00005e  8020              STRH     r0,[r4,#0]
;;;289    	pCB->tx.index = 0;
000060  80a2              STRH     r2,[r4,#4]
                  |L5.98|
;;;290    }
000062  bd70              POP      {r4-r6,pc}
;;;291    
                          ENDP


                          AREA ||i.UART_DRIVE_DataStructInit||, CODE, READONLY, ALIGN=1

                  UART_DRIVE_DataStructInit PROC
;;;76     // 数据结构初始化
;;;77     void UART_DRIVE_DataStructInit(UART_DRIVE_CB *pCB)
000000  2800              CMP      r0,#0
;;;78     {
000002  d013              BEQ      |L6.44|
;;;79     	uint16 i;
;;;80     
;;;81     	// 参数合法性检验
;;;82     	if (NULL == pCB)
;;;83     	{
;;;84     		return;
;;;85     	}
;;;86     
;;;87     	pCB->tx.txBusy = FALSE;
000004  f50041a0          ADD      r1,r0,#0x5000
000008  f5016124          ADD      r1,r1,#0xa40
00000c  2200              MOVS     r2,#0
00000e  718a              STRB     r2,[r1,#6]
;;;88     	pCB->tx.index = 0;
000010  808a              STRH     r2,[r1,#4]
;;;89     	pCB->tx.head = 0;
000012  800a              STRH     r2,[r1,#0]
;;;90     	pCB->tx.end = 0;
000014  804a              STRH     r2,[r1,#2]
;;;91     	for (i = 0; i < UART_DRIVE_TX_QUEUE_SIZE; i++)
000016  2100              MOVS     r1,#0
                  |L6.24|
;;;92     	{
;;;93     		pCB->tx.cmdQueue[i].length = 0;
000018  234d              MOVS     r3,#0x4d
00001a  434b              MULS     r3,r1,r3
00001c  eb000343          ADD      r3,r0,r3,LSL #1
000020  f8a3209c          STRH     r2,[r3,#0x9c]
000024  1c49              ADDS     r1,r1,#1              ;91
000026  b289              UXTH     r1,r1                 ;91
000028  2996              CMP      r1,#0x96              ;91
00002a  d3f5              BCC      |L6.24|
                  |L6.44|
;;;94     	}
;;;95     }
00002c  4770              BX       lr
;;;96     
                          ENDP


                          AREA ||i.UART_DRIVE_HwInit||, CODE, READONLY, ALIGN=2

                  UART_DRIVE_HwInit PROC
;;;97     // UART初始化
;;;98     void UART_DRIVE_HwInit(uint32 baud)
000000  b570              PUSH     {r4-r6,lr}
;;;99     {
000002  4605              MOV      r5,r0
;;;100    	// GD32
;;;101    	// 时钟配置
;;;102    	rcu_periph_clock_enable(RCU_GPIOC);
000004  f2406004          MOV      r0,#0x604
000008  f7fffffe          BL       rcu_periph_clock_enable
;;;103    
;;;104    	// GPIO配置
;;;105    	gpio_init(GPIOC, GPIO_MODE_AF_PP, GPIO_OSPEED_2MHZ, GPIO_PIN_10); // 复用推挽
00000c  4c22              LDR      r4,|L7.152|
00000e  f44f6380          MOV      r3,#0x400
000012  2202              MOVS     r2,#2
000014  2118              MOVS     r1,#0x18
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       gpio_init
;;;106    
;;;107    	gpio_init(GPIOC, GPIO_MODE_IPU, GPIO_OSPEED_2MHZ, GPIO_PIN_11); // 上拉输入
00001c  14e3              ASRS     r3,r4,#19
00001e  2202              MOVS     r2,#2
000020  2148              MOVS     r1,#0x48
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       gpio_init
;;;108    
;;;109    	// UART时钟配置
;;;110    	rcu_periph_clock_enable(RCU_UART3); // 时能USART时钟
000028  f2407013          MOV      r0,#0x713
00002c  f7fffffe          BL       rcu_periph_clock_enable
;;;111    	usart_deinit(UART_DRIVE_TYPE_DEF);	 // 复位串口
000030  4c1a              LDR      r4,|L7.156|
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       usart_deinit
;;;112    
;;;113    	// 串口配置
;;;114    	usart_baudrate_set(UART_DRIVE_TYPE_DEF, baud);							// 波特率
000038  4629              MOV      r1,r5
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       usart_baudrate_set
;;;115    	usart_word_length_set(UART_DRIVE_TYPE_DEF, USART_WL_8BIT);				// 8位数据位
000040  2100              MOVS     r1,#0
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       usart_word_length_set
;;;116    	usart_stop_bit_set(UART_DRIVE_TYPE_DEF, USART_STB_1BIT);				// 一个停止位
000048  2100              MOVS     r1,#0
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       usart_stop_bit_set
;;;117    	usart_parity_config(UART_DRIVE_TYPE_DEF, USART_PM_NONE);				// 无奇偶校验
000050  2100              MOVS     r1,#0
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       usart_parity_config
;;;118    	usart_hardware_flow_rts_config(UART_DRIVE_TYPE_DEF, USART_RTS_DISABLE); // 无硬件数据流控制
000058  2100              MOVS     r1,#0
00005a  4620              MOV      r0,r4
00005c  f7fffffe          BL       usart_hardware_flow_rts_config
;;;119    	usart_hardware_flow_cts_config(UART_DRIVE_TYPE_DEF, USART_CTS_DISABLE);
000060  2100              MOVS     r1,#0
000062  4620              MOV      r0,r4
000064  f7fffffe          BL       usart_hardware_flow_cts_config
;;;120    	usart_transmit_config(UART_DRIVE_TYPE_DEF, USART_TRANSMIT_ENABLE); // 使能发射
000068  2108              MOVS     r1,#8
00006a  4620              MOV      r0,r4
00006c  f7fffffe          BL       usart_transmit_config
;;;121    	usart_receive_config(UART_DRIVE_TYPE_DEF, USART_RECEIVE_ENABLE);   // 使能接收
000070  2104              MOVS     r1,#4
000072  4620              MOV      r0,r4
000074  f7fffffe          BL       usart_receive_config
;;;122    
;;;123    	// 中断配置
;;;124    	nvic_irq_enable(UART_DRIVE_IRQn_DEF, 2, 1);
000078  2201              MOVS     r2,#1
00007a  2102              MOVS     r1,#2
00007c  2034              MOVS     r0,#0x34
00007e  f7fffffe          BL       nvic_irq_enable
;;;125    
;;;126    	usart_interrupt_enable(UART_DRIVE_TYPE_DEF, USART_INT_RBNE); // 开启中断
000082  f2403105          MOV      r1,#0x305
000086  4620              MOV      r0,r4
000088  f7fffffe          BL       usart_interrupt_enable
;;;127    
;;;128    	usart_enable(UART_DRIVE_TYPE_DEF); // 使能串口
00008c  4620              MOV      r0,r4
00008e  e8bd4070          POP      {r4-r6,lr}
000092  f7ffbffe          B.W      usart_enable
;;;129    }
;;;130    
                          ENDP

000096  0000              DCW      0x0000
                  |L7.152|
                          DCD      0x40011000
                  |L7.156|
                          DCD      0x40004c00

                          AREA ||i.UART_DRIVE_IR_StartSendData||, CODE, READONLY, ALIGN=2

                  UART_DRIVE_IR_StartSendData PROC
;;;230    // 启动中断字节发送
;;;231    void UART_DRIVE_IR_StartSendData(uint8 data)
000000  b570              PUSH     {r4-r6,lr}
;;;232    {
000002  4605              MOV      r5,r0
;;;233    	// 先读SR，再填充DR会把TC标志清掉
;;;234    	usart_flag_get(UART_DRIVE_TYPE_DEF, USART_FLAG_TC);
000004  4c07              LDR      r4,|L8.36|
000006  2106              MOVS     r1,#6
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       usart_flag_get
;;;235    
;;;236    	// 发送一个字节
;;;237    	usart_data_transmit(UART_DRIVE_TYPE_DEF, data);
00000e  4629              MOV      r1,r5
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       usart_data_transmit
;;;238    
;;;239    	// 打开发送完成中断
;;;240    	usart_interrupt_enable(UART_DRIVE_TYPE_DEF, USART_INT_TC);
000016  4620              MOV      r0,r4
000018  e8bd4070          POP      {r4-r6,lr}
00001c  f2403106          MOV      r1,#0x306
000020  f7ffbffe          B.W      usart_interrupt_enable
;;;241    }
;;;242    
                          ENDP

                  |L8.36|
                          DCD      0x40004c00

                          AREA ||i.UART_DRIVE_Init||, CODE, READONLY, ALIGN=2

                  UART_DRIVE_Init PROC
;;;44     // UART初始化
;;;45     void UART_DRIVE_Init(void)
000000  b510              PUSH     {r4,lr}
;;;46     {
;;;47     	// 硬件UART配置
;;;48     	UART_DRIVE_HwInit(UART_DRIVE_BAUD_RATE);
000002  f44f30e1          MOV      r0,#0x1c200
000006  f7fffffe          BL       UART_DRIVE_HwInit
;;;49     
;;;50     	// UART数据结构初始化
;;;51     	UART_DRIVE_DataStructInit(&uartDriveCB);
00000a  e8bd4010          POP      {r4,lr}
00000e  4801              LDR      r0,|L9.20|
000010  f7ffbffe          B.W      UART_DRIVE_DataStructInit
;;;52     }
;;;53     
                          ENDP

                  |L9.20|
                          DCD      ||.bss||

                          AREA ||i.UART_DRIVE_InitSelect||, CODE, READONLY, ALIGN=2

                  UART_DRIVE_InitSelect PROC
;;;53     
;;;54     void UART_DRIVE_InitSelect(uint32 baud)
000000  b510              PUSH     {r4,lr}
;;;55     {
;;;56     	// 硬件UART配置
;;;57     	UART_DRIVE_HwInit(baud);
000002  f7fffffe          BL       UART_DRIVE_HwInit
;;;58     
;;;59     	// UART数据结构初始化
;;;60     	UART_DRIVE_DataStructInit(&uartDriveCB);
000006  e8bd4010          POP      {r4,lr}
00000a  4801              LDR      r0,|L10.16|
00000c  f7ffbffe          B.W      UART_DRIVE_DataStructInit
;;;61     }
;;;62     
                          ENDP

                  |L10.16|
                          DCD      ||.bss||

                          AREA ||i.UART_DRIVE_Process||, CODE, READONLY, ALIGN=2

                  UART_DRIVE_Process PROC
;;;63     // UART模块处理入口
;;;64     void UART_DRIVE_Process(void)
000000  4801              LDR      r0,|L11.8|
;;;65     {
;;;66     	// 内部通讯接口的发送处理
;;;67     	UART_DRIVE_TxProcess(&uartDriveCB);
000002  f7ffbffe          B.W      UART_DRIVE_TxProcess
;;;68     }
;;;69     
                          ENDP

000006  0000              DCW      0x0000
                  |L11.8|
                          DCD      ||.bss||

                          AREA ||i.UART_DRIVE_RegisterDataSendService||, CODE, READONLY, ALIGN=2

                  UART_DRIVE_RegisterDataSendService PROC
;;;70     // 向协议层注册数据接收接口
;;;71     void UART_DRIVE_RegisterDataSendService(void (*service)(uint16 id, uint8 *pData, uint16 length))
000000  4901              LDR      r1,|L12.8|
;;;72     {
;;;73     	uartDriveCB.receiveDataThrowService = service;
000002  6008              STR      r0,[r1,#0]  ; uartDriveCB
;;;74     }
000004  4770              BX       lr
;;;75     
                          ENDP

000006  0000              DCW      0x0000
                  |L12.8|
                          DCD      ||.bss||

                          AREA ||i.UART_DRIVE_TxProcess||, CODE, READONLY, ALIGN=1

                  UART_DRIVE_TxProcess PROC
;;;292    // 发送处理,发现发送缓冲区非空时,启动中断发送
;;;293    void UART_DRIVE_TxProcess(UART_DRIVE_CB *pCB)
000000  b570              PUSH     {r4-r6,lr}
;;;294    {
;;;295    // 中断方式
;;;296    #if (UART_DRIVE_TX_MODE == UART_DRIVE_INTERRUPT_TX_MODE)
;;;297    	uint16 index = pCB->tx.index;						   // 当前发送数据的索引号
000002  f50044a0          ADD      r4,r0,#0x5000
000006  f8b41a44          LDRH     r1,[r4,#0xa44]
;;;298    	uint16 length = pCB->tx.cmdQueue[pCB->tx.head].length; // 当前发送的命令帧的长度
00000a  f8b42a40          LDRH     r2,[r4,#0xa40]
00000e  234d              MOVS     r3,#0x4d
000010  435a              MULS     r2,r3,r2
000012  eb000242          ADD      r2,r0,r2,LSL #1
000016  f8b2309c          LDRH     r3,[r2,#0x9c]
;;;299    	uint16 head = pCB->tx.head;							   // 发送命令帧队列头索引号
00001a  f8b42a40          LDRH     r2,[r4,#0xa40]
;;;300    	uint16 end = pCB->tx.end;							   // 发送命令帧队列尾索引号
00001e  f8b45a42          LDRH     r5,[r4,#0xa42]
;;;301    
;;;302    	// 参数合法性检验
;;;303    	if (NULL == pCB)
000022  2800              CMP      r0,#0
000024  d016              BEQ      |L13.84|
;;;304    	{
;;;305    		return;
;;;306    	}
;;;307    
;;;308    	// 队列为空，不处理
;;;309    	if (head == end)
000026  42aa              CMP      r2,r5
000028  d014              BEQ      |L13.84|
;;;310    	{
;;;311    		return;
;;;312    	}
;;;313    
;;;314    	// 发送忙，退出
;;;315    	if (pCB->tx.txBusy)
00002a  f8945a46          LDRB     r5,[r4,#0xa46]
00002e  2d00              CMP      r5,#0
000030  d110              BNE      |L13.84|
;;;316    	{
;;;317    		return;
;;;318    	}
;;;319    
;;;320    	// ■■执行到这里，说明队列非空■■
;;;321    
;;;322    	// 当前命令帧未发送完时，取出一个字节放到发送寄存器中
;;;323    	if (index < length)
000032  4299              CMP      r1,r3
000034  d20e              BCS      |L13.84|
;;;324    	{
;;;325    		UART_DRIVE_IR_StartSendData(pCB->tx.cmdQueue[head].buff[pCB->tx.index++]);
000036  f6042444          ADD      r4,r4,#0xa44
00003a  8821              LDRH     r1,[r4,#0]
00003c  1c4b              ADDS     r3,r1,#1
00003e  8023              STRH     r3,[r4,#0]
000040  234d              MOVS     r3,#0x4d
000042  435a              MULS     r2,r3,r2
000044  eb000042          ADD      r0,r0,r2,LSL #1
000048  4408              ADD      r0,r0,r1
00004a  7980              LDRB     r0,[r0,#6]
00004c  f7fffffe          BL       UART_DRIVE_IR_StartSendData
;;;326    
;;;327    		// 设置发送忙状态
;;;328    		pCB->tx.txBusy = TRUE;
000050  2001              MOVS     r0,#1
000052  70a0              STRB     r0,[r4,#2]
                  |L13.84|
;;;329    	}
;;;330    
;;;331    // 阻塞方式时启动发送
;;;332    #else
;;;333    	UART_DRIVE_BC_StartTx(pCB);
;;;334    #endif
;;;335    }
000054  bd70              POP      {r4-r6,pc}
;;;336    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  uartDriveCB
                          %        23112

;*** Start embedded assembler ***

#line 1 "User\\DutUartDrive.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_DutUartDrive_c_7fc652a9____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___14_DutUartDrive_c_7fc652a9____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_DutUartDrive_c_7fc652a9____REVSH|
#line 128
|__asm___14_DutUartDrive_c_7fc652a9____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
