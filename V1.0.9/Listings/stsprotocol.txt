; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\stsprotocol.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\stsprotocol.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -I.\User\qrencode -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.3\Device\Include -D__MICROLIB -D__UVISION_VERSION=539 -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\stsprotocol.crf User\StsProtocol.c]
                          THUMB

                          AREA ||i.DutTimeOut||, CODE, READONLY, ALIGN=1

                  DutTimeOut PROC
;;;2881   // DUT通讯超时处理
;;;2882   void DutTimeOut(uint32 param)
000000  2100              MOVS     r1,#0
;;;2883   {
;;;2884       STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_ONLINE_DETECTION, SHUTDOWN);
000002  2018              MOVS     r0,#0x18
000004  f7ffbffe          B.W      STS_PROTOCOL_SendCmdParamAck
;;;2885   }
;;;2886   
                          ENDP


                          AREA ||i.OperateVerTimeOut||, CODE, READONLY, ALIGN=1

                  OperateVerTimeOut PROC
;;;2893   // 版本操作超时处理
;;;2894   void OperateVerTimeOut(uint32 param)
000000  2100              MOVS     r1,#0
;;;2895   {
;;;2896       STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_CHECK_VERSION_INFO, FALSE);
000002  2002              MOVS     r0,#2
000004  f7ffbffe          B.W      STS_PROTOCOL_SendCmdParamAck
;;;2897   }
;;;2898   
                          ENDP


                          AREA ||i.Report_Identity||, CODE, READONLY, ALIGN=1

                  Report_Identity PROC
;;;2899   // 身份上报
;;;2900   void Report_Identity(uint32 param)
000000  2034              MOVS     r0,#0x34
;;;2901   {
;;;2902       STS_PROTOCOL_SendCmdAck(STS_PROTOCOL_CMD_REPORT_OF_IDENTITY);
000002  f7ffbffe          B.W      STS_PROTOCOL_SendCmdAck
;;;2903   }
;;;2904   
                          ENDP


                          AREA ||i.SELECT_PROTOCOL_SendCmdAck||, CODE, READONLY, ALIGN=2

                  SELECT_PROTOCOL_SendCmdAck PROC
;;;2937   // 选择协议发送命令
;;;2938   void SELECT_PROTOCOL_SendCmdAck(uint8 paramm)
000000  4906              LDR      r1,|L4.28|
;;;2939   {
;;;2940       if (dut_info.commProt)
000002  f8912109          LDRB     r2,[r1,#0x109]  ; dut_info
000006  2a00              CMP      r2,#0
000008  d002              BEQ      |L4.16|
;;;2941       {
;;;2942           UART_PROTOCOL_XM_SendCmdAck(UART_PROTOCOL_XM_CMD_READ_FLAG_DATA);
00000a  2081              MOVS     r0,#0x81
00000c  f7ffbffe          B.W      UART_PROTOCOL_XM_SendCmdAck
                  |L4.16|
;;;2943       }
;;;2944       else
;;;2945       {
;;;2946           if (dut_info.dutBusType)
000010  7e89              LDRB     r1,[r1,#0x1a]  ; dut_info
000012  b109              CBZ      r1,|L4.24|
;;;2947           {
;;;2948               CAN_PROTOCOL_TEST_SendCmdAck(paramm);
000014  f7ffbffe          B.W      CAN_PROTOCOL_TEST_SendCmdAck
                  |L4.24|
;;;2949           }
;;;2950           else
;;;2951           {
;;;2952               DUT_PROTOCOL_SendCmdAck(paramm);
000018  f7ffbffe          B.W      DUT_PROTOCOL_SendCmdAck
;;;2953           }
;;;2954       }
;;;2955   }
;;;2956   
                          ENDP

                  |L4.28|
                          DCD      dut_info

                          AREA ||i.SELECT_PROTOCOL_SendCmdParamAck||, CODE, READONLY, ALIGN=2

                  SELECT_PROTOCOL_SendCmdParamAck PROC
;;;2957   // 发送命令，带一个参数
;;;2958   void SELECT_PROTOCOL_SendCmdParamAck(uint8 ackCmd, uint8 ackParam)
000000  4a0c              LDR      r2,|L5.52|
;;;2959   {
;;;2960       if (dut_info.commProt)
000002  f8923109          LDRB     r3,[r2,#0x109]  ; dut_info
000006  2b00              CMP      r3,#0
000008  d00d              BEQ      |L5.38|
;;;2961       {
;;;2962           if (ackParam == 0)
00000a  b121              CBZ      r1,|L5.22|
;;;2963           {
;;;2964               ackParam = 1;
;;;2965           }
;;;2966           else if (ackParam == 1)
00000c  2901              CMP      r1,#1
00000e  d004              BEQ      |L5.26|
;;;2967           {
;;;2968               ackParam = 2;
;;;2969           }
;;;2970           else if (ackParam == 2)
000010  2902              CMP      r1,#2
000012  d004              BEQ      |L5.30|
000014  e004              B        |L5.32|
                  |L5.22|
000016  2101              MOVS     r1,#1                 ;2964
000018  e002              B        |L5.32|
                  |L5.26|
00001a  2102              MOVS     r1,#2                 ;2968
00001c  e000              B        |L5.32|
                  |L5.30|
;;;2971           {
;;;2972               ackParam = 3;
00001e  2103              MOVS     r1,#3
                  |L5.32|
;;;2973           }
;;;2974           UART_PROTOCOL_XM_SendCmdParamAck(UART_PROTOCOL_XM_CMD_READ_VERSION_TYPE, ackParam);
000020  2084              MOVS     r0,#0x84
000022  f7ffbffe          B.W      UART_PROTOCOL_XM_SendCmdParamAck
                  |L5.38|
;;;2975       }
;;;2976       else
;;;2977       {
;;;2978           if (dut_info.dutBusType)
000026  7e92              LDRB     r2,[r2,#0x1a]  ; dut_info
000028  b10a              CBZ      r2,|L5.46|
;;;2979           {
;;;2980               CAN_PROTOCOL_TEST_SendCmdParamAck(ackCmd, ackParam);
00002a  f7ffbffe          B.W      CAN_PROTOCOL_TEST_SendCmdParamAck
                  |L5.46|
;;;2981           }
;;;2982           else
;;;2983           {
;;;2984               DUT_PROTOCOL_SendCmdParamAck(ackCmd, ackParam);
00002e  f7ffbffe          B.W      DUT_PROTOCOL_SendCmdParamAck
;;;2985           }
;;;2986       }
;;;2987   }
;;;2988   
                          ENDP

000032  0000              DCW      0x0000
                  |L5.52|
                          DCD      dut_info

                          AREA ||i.SELECT_PROTOCOL_WriteFlag||, CODE, READONLY, ALIGN=2

                  SELECT_PROTOCOL_WriteFlag PROC
;;;2905   // 选择协议写入标志区数据
;;;2906   void SELECT_PROTOCOL_WriteFlag(uint8 placeParam, uint8 shutdownFlagParam)
000000  4a07              LDR      r2,|L6.32|
;;;2907   {
;;;2908       if (dut_info.commProt)
000002  f8923109          LDRB     r3,[r2,#0x109]  ; dut_info
000006  2b00              CMP      r3,#0
000008  d004              BEQ      |L6.20|
;;;2909       {
;;;2910   //        if (placeParam == 2)
;;;2911   //        {
;;;2912   //            placeParam = 3;
;;;2913   //        }
;;;2914   //        else if (placeParam == 0)
;;;2915   //        {
;;;2916   //            placeParam = 1;
;;;2917   //        }
;;;2918   //        else if (placeParam == 1)
;;;2919   //        {
;;;2920   //            placeParam = 2;
;;;2921   //        }
;;;2922           UART_PROTOCOL_XM_SendCmdTwoParamAck(UART_PROTOCOL_XM_CMD_WRITE_FLAG_DATA, placeParam, 2);
00000a  2202              MOVS     r2,#2
00000c  4601              MOV      r1,r0
00000e  2082              MOVS     r0,#0x82
000010  f7ffbffe          B.W      UART_PROTOCOL_XM_SendCmdTwoParamAck
                  |L6.20|
;;;2923       }
;;;2924       else
;;;2925       {
;;;2926           if (dut_info.dutBusType)
000014  7e92              LDRB     r2,[r2,#0x1a]  ; dut_info
000016  b10a              CBZ      r2,|L6.28|
;;;2927           {
;;;2928               CAN_PROTOCOL_TEST_WriteFlag(placeParam, shutdownFlagParam);
000018  f7ffbffe          B.W      CAN_PROTOCOL_TEST_WriteFlag
                  |L6.28|
;;;2929           }
;;;2930           else
;;;2931           {
;;;2932               DUT_PROTOCOL_WriteFlag(placeParam, shutdownFlagParam);
00001c  f7ffbffe          B.W      DUT_PROTOCOL_WriteFlag
;;;2933           }
;;;2934       }
;;;2935   }
;;;2936   
                          ENDP

                  |L6.32|
                          DCD      dut_info

                          AREA ||i.STS_PROTOCOL_CheckSUM||, CODE, READONLY, ALIGN=1

                  STS_PROTOCOL_CheckSUM PROC
;;;620    // 对传入的命令帧进行校验，返回校验结果
;;;621    BOOL STS_PROTOCOL_CheckSUM(STS_PROTOCOL_RX_CMD_FRAME *pCmdFrame)
000000  b530              PUSH     {r4,r5,lr}
;;;622    {
;;;623        uint8 cc = 0;
000002  2200              MOVS     r2,#0
;;;624        uint16 i = 0;
000004  2100              MOVS     r1,#0
;;;625    
;;;626        if (NULL == pCmdFrame)
000006  2800              CMP      r0,#0
000008  d003              BEQ      |L7.18|
;;;627        {
;;;628            return FALSE;
;;;629        }
;;;630    
;;;631        // 从命令头开始，到校验码之前的一个字节，依次进行异或运算
;;;632        for (i = 0; i < pCmdFrame->length - 1; i++)
00000a  f8b05098          LDRH     r5,[r0,#0x98]
00000e  1e6b              SUBS     r3,r5,#1
000010  e006              B        |L7.32|
                  |L7.18|
000012  2000              MOVS     r0,#0                 ;628
;;;633        {
;;;634            cc ^= pCmdFrame->buff[i];
;;;635        }
;;;636    
;;;637        // 判断计算得到的校验码与命令帧中的校验码是否相同
;;;638        if (pCmdFrame->buff[pCmdFrame->length - 1] != cc)
;;;639        {
;;;640            return FALSE;
;;;641        }
;;;642    
;;;643        return TRUE;
;;;644    }
000014  bd30              POP      {r4,r5,pc}
                  |L7.22|
000016  1844              ADDS     r4,r0,r1              ;634
000018  78a4              LDRB     r4,[r4,#2]            ;634
00001a  4062              EORS     r2,r2,r4              ;634
00001c  1c49              ADDS     r1,r1,#1              ;632
00001e  b289              UXTH     r1,r1                 ;632
                  |L7.32|
000020  428b              CMP      r3,r1                 ;632
000022  dcf8              BGT      |L7.22|
000024  1c40              ADDS     r0,r0,#1              ;638
000026  5c28              LDRB     r0,[r5,r0]            ;638
000028  4290              CMP      r0,r2                 ;638
00002a  d001              BEQ      |L7.48|
00002c  2000              MOVS     r0,#0                 ;640
00002e  bd30              POP      {r4,r5,pc}
                  |L7.48|
000030  2001              MOVS     r0,#1                 ;643
000032  bd30              POP      {r4,r5,pc}
;;;645    
                          ENDP


                          AREA ||i.STS_PROTOCOL_CmdFrameProcess||, CODE, READONLY, ALIGN=2

                  STS_PROTOCOL_CmdFrameProcess PROC
;;;1059   // STS命令帧缓冲区处理
;;;1060   void STS_PROTOCOL_CmdFrameProcess(STS_PROTOCOL_CB *pCB)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1061   {
000004  b09d              SUB      sp,sp,#0x74
000006  4681              MOV      r9,r0
;;;1062       STS_PROTOCOL_CMD cmd = STS_CMD_MAX;
;;;1063       STS_PROTOCOL_RX_CMD_FRAME *pCmdFrame = NULL;
;;;1064   
;;;1065       BOOL writeRes;
;;;1066   
;;;1067       uint8 versionBoot[3] = {0};
000008  2400              MOVS     r4,#0
00000a  941c              STR      r4,[sp,#0x70]
;;;1068       uint8 versionApp[3] = {0};
00000c  941b              STR      r4,[sp,#0x6c]
;;;1069       uint8 packetSize = 0;
;;;1070       uint8 addr1 = 0;
;;;1071       uint8 addr2 = 0;
;;;1072       uint8 addr3 = 0;
;;;1073       uint8 addr4 = 0;
;;;1074       uint32 writeAddr = 0;
;;;1075       static uint32 allPacketSize = 0;
;;;1076   //    static uint32 powerPacketSize = 0;
;;;1077       static uint8 allPacket[4] = {0};
;;;1078       uint8 communication_Type = 0;
;;;1079       uint8 baudRate_value = 0;
;;;1080       uint16 can_baudRate = 0;
00000e  46a2              MOV      r10,r4
;;;1081       uint32 uart_baudRate = 0;
000010  2600              MOVS     r6,#0
;;;1082       uint8 frame_Type = 0;
;;;1083       uint8 test_Item = 0;
;;;1084       uint16 load_voltage = 0;
;;;1085       uint16 voltage_error = 0;
;;;1086       uint8 load_current = 0;
;;;1087       uint16 current_error = 0;
;;;1088       uint16 real_load_voltage = 0;
;;;1089       uint16 real_load_current = 0;
;;;1090       uint32 voltageTarget = 0;
;;;1091       uint16 voltageTarget_error = 0;
;;;1092       uint8 upItem = 0;
;;;1093       uint8 clearItem = 0;
;;;1094       uint8 dutAll[50] = {0};
000012  2134              MOVS     r1,#0x34
000014  a80e              ADD      r0,sp,#0x38
000016  f7fffffe          BL       __aeabi_memclr4
;;;1095       uint8 dutName_i = 0;
;;;1096       uint8 dataLen = 0;
;;;1097       uint8 endItem = 0;
;;;1098       uint8 ctrlState = 0;
;;;1099       uint8 dut_info_len = 0;
;;;1100       uint8 size[4] = {0};
00001a  940d              STR      r4,[sp,#0x34]
;;;1101       static uint32 currPacketNum = 0xFFFF;
;;;1102       uint8_t infoLen = 0;
;;;1103       uint32_t i = 0;
00001c  2500              MOVS     r5,#0
;;;1104       uint32_t j = 0;
;;;1105       uint8 noNumber[43] = {0};  // 42个配置参数
00001e  212c              MOVS     r1,#0x2c
000020  a802              ADD      r0,sp,#8
000022  f7fffffe          BL       __aeabi_memclr4
;;;1106       uint8 k = 0;
;;;1107       uint8 lenght = 0;
;;;1108       uint8 keyNumber = 0;
;;;1109       uint8 cmdLength = 0;
;;;1110   
;;;1111       // 参数合法性检验
;;;1112       if (NULL == pCB)
000026  f1b90f00          CMP      r9,#0
00002a  d016              BEQ      |L8.90|
;;;1113       {
;;;1114           return;
;;;1115       }
;;;1116   
;;;1117       // 命令帧缓冲区为空，退出
;;;1118       if (pCB->rx.head == pCB->rx.end)
00002c  f8b9029c          LDRH     r0,[r9,#0x29c]
000030  f8b9129e          LDRH     r1,[r9,#0x29e]
000034  4288              CMP      r0,r1
000036  d010              BEQ      |L8.90|
;;;1119       {
;;;1120           return;
;;;1121       }
;;;1122   
;;;1123       // 获取当前要处理的命令帧指针
;;;1124       pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.head];
000038  214d              MOVS     r1,#0x4d
00003a  4341              MULS     r1,r0,r1
00003c  eb090441          ADD      r4,r9,r1,LSL #1
000040  34ce              ADDS     r4,r4,#0xce
;;;1125   
;;;1126       // 命令头非法，退出
;;;1127       if (STS_PROTOCOL_CMD_HEAD != pCmdFrame->buff[STS_PROTOCOL_CMD_HEAD_INDEX])
000042  78a1              LDRB     r1,[r4,#2]
000044  2955              CMP      r1,#0x55
000046  d00b              BEQ      |L8.96|
;;;1128       {
;;;1129           // 删除命令帧
;;;1130           pCB->rx.head++;
000048  1c40              ADDS     r0,r0,#1
00004a  b280              UXTH     r0,r0
;;;1131           pCB->rx.head %= STS_PROTOCOL_RX_QUEUE_SIZE;
00004c  2103              MOVS     r1,#3
00004e  fbb0f2f1          UDIV     r2,r0,r1
000052  fb010012          MLS      r0,r1,r2,r0
000056  f8a9029c          STRH     r0,[r9,#0x29c]
                  |L8.90|
;;;1132           return;
;;;1133       }
;;;1134   
;;;1135       // 命令头合法，则提取命令
;;;1136       cmd = (STS_PROTOCOL_CMD)pCmdFrame->buff[STS_PROTOCOL_CMD_CMD_INDEX];
;;;1137   
;;;1138       // 执行命令帧
;;;1139       switch (cmd)
;;;1140       {
;;;1141       // 空命令
;;;1142       case STS_PROTOCOL_CMD_NULL:
;;;1143           break;
;;;1144   
;;;1145       // DTA身份上报
;;;1146       case STS_PROTOCOL_CMD_REPORT_OF_IDENTITY:
;;;1147           TIMER_KillTask(TIMER_ID_REPORT_OF_IDENTITY);
;;;1148           break;
;;;1149   
;;;1150       // 过站标志校验（命令字=0x01）
;;;1151       case STS_PROTOCOL_CMD_CHECK_STATION_FLAG:
;;;1152   
;;;1153           // 获取站位编号
;;;1154           stationNumber = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA2_INDEX];
;;;1155           offFlag = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA3_INDEX];
;;;1156   
;;;1157           // 写入处理
;;;1158           if (0x01 == (pCmdFrame->buff[STS_PROTOCOL_CMD_DATA1_INDEX] & 0x01))
;;;1159           {
;;;1160               // 写入标志区数据
;;;1161               SELECT_PROTOCOL_WriteFlag(stationNumber, offFlag);
;;;1162   
;;;1163               // 写入超时定时器
;;;1164               TIMER_AddTask(TIMER_ID_WRITE_FLAG_TIMEOUT,
;;;1165                             3000,
;;;1166                             WriteFlagTimeOut,
;;;1167                             0,
;;;1168                             1,
;;;1169                             ACTION_MODE_ADD_TO_QUEUE);
;;;1170           }
;;;1171   
;;;1172           // 对比校验
;;;1173           if (0x02 == (pCmdFrame->buff[STS_PROTOCOL_CMD_DATA1_INDEX] & 0x02))
;;;1174           {
;;;1175               // 读取标志区数据
;;;1176               SELECT_PROTOCOL_SendCmdAck(DUT_PROTOCOL_CMD_READ_FLAG_DATA);
;;;1177   
;;;1178               // 超时定时器
;;;1179               TIMER_AddTask(TIMER_ID_WRITE_FLAG_TIMEOUT,
;;;1180                             3000,
;;;1181                             WriteFlagTimeOut,
;;;1182                             0,
;;;1183                             1,
;;;1184                             ACTION_MODE_ADD_TO_QUEUE);
;;;1185           }
;;;1186   
;;;1187           // LCD显示
;;;1188           Vertical_Scrolling_Display(verTestMsgBuff, 4, 0);
;;;1189           break;
;;;1190   
;;;1191       // 版本信息校验命令（命令字=0x02）
;;;1192       case STS_PROTOCOL_CMD_CHECK_VERSION_INFO:
;;;1193   
;;;1194           // 版本类型
;;;1195           dutverType = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA2_INDEX];
;;;1196   
;;;1197           // 信息长度
;;;1198           infoLen = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA3_INDEX];
;;;1199   
;;;1200           // 类型信息
;;;1201           strcpy(dutverBuff, (const char *)&pCmdFrame->buff[STS_PROTOCOL_CMD_DATA4_INDEX]);
;;;1202           dutverBuff[infoLen] = 0;
;;;1203   
;;;1204           // 写入校验
;;;1205           if (0x01 == (pCmdFrame->buff[STS_PROTOCOL_CMD_DATA1_INDEX] & 0x01))
;;;1206           {
;;;1207               // 标志
;;;1208               verwriteFlag = TRUE;
;;;1209   
;;;1210               // 写入版本类型信息
;;;1211               if (dut_info.dutBusType)
;;;1212               {
;;;1213                   // CAN
;;;1214                   CAN_PROTOCOL_TEST_TxAddData(DUT_PROTOCOL_CMD_HEAD);
;;;1215                   CAN_PROTOCOL_TEST_TxAddData(DUT_PROTOCOL_CMD_WRITE_VERSION_TYPE_DATA);
;;;1216                   CAN_PROTOCOL_TEST_TxAddData(infoLen + 2);
;;;1217                   CAN_PROTOCOL_TEST_TxAddData(dutverType);
;;;1218                   CAN_PROTOCOL_TEST_TxAddData(infoLen);
;;;1219                   for (i = 0; i < infoLen; i++)
;;;1220                   {
;;;1221                       CAN_PROTOCOL_TEST_TxAddData(pCmdFrame->buff[6 + i]);
;;;1222                   }
;;;1223                   CAN_PROTOCOL_TEST_TxAddFrame();
;;;1224   
;;;1225               }
;;;1226               else
;;;1227               {
;;;1228                   // UART
;;;1229                   if (dut_info.commProt)
;;;1230                   {
;;;1231                       if (dutverType == 0)
;;;1232                       {
;;;1233                           dutverType = 1;
;;;1234                       }
;;;1235                       else if (dutverType == 1)
;;;1236                       {
;;;1237                           dutverType = 2;
;;;1238                       }
;;;1239                       else if (dutverType == 2)
;;;1240                       {
;;;1241                           dutverType = 3;
;;;1242                       }
;;;1243   
;;;1244                       UART_PROTOCOL_XM_TxAddData(UART_PROTOCOL_XM_CMD_HEAD);
;;;1245                       UART_PROTOCOL_XM_TxAddData(UART_PROTOCOL_XM_CMD_DEVICE);
;;;1246                       UART_PROTOCOL_XM_TxAddData(UART_PROTOCOL_XM_CMD_WRITE_VERSION_TYPE);
;;;1247                       UART_PROTOCOL_XM_TxAddData(infoLen + 2);
;;;1248                       UART_PROTOCOL_XM_TxAddData(dutverType);
;;;1249   
;;;1250                       if (dutverType == 3)
;;;1251                       {
;;;1252                           if (UART_BAUD_RATE_19200 == dut_info.uart_baudRate)
;;;1253                           {
;;;1254                               UART_PROTOCOL_XM_TxAddData(infoLen + 1);
;;;1255                           }
;;;1256                           else
;;;1257                           {
;;;1258                               UART_PROTOCOL_XM_TxAddData(infoLen);
;;;1259                           }
;;;1260                           UART_PROTOCOL_XM_TxAddData(infoLen + 1);
;;;1261                       }
;;;1262                       else
;;;1263                       {
;;;1264                           UART_PROTOCOL_XM_TxAddData(infoLen);
;;;1265                       }
;;;1266   
;;;1267                       for (i = 0; i < infoLen; i++)
;;;1268                       {
;;;1269                           UART_PROTOCOL_XM_TxAddData(pCmdFrame->buff[6 + i]);
;;;1270                       }
;;;1271                       UART_PROTOCOL_XM_TxAddFrame();
;;;1272                   }
;;;1273                   else
;;;1274                   {
;;;1275                       DUT_PROTOCOL_TxAddData(DUT_PROTOCOL_CMD_HEAD);
;;;1276                       DUT_PROTOCOL_TxAddData(DUT_PROTOCOL_CMD_WRITE_VERSION_TYPE_DATA);
;;;1277                       DUT_PROTOCOL_TxAddData(infoLen + 2);
;;;1278                       DUT_PROTOCOL_TxAddData(dutverType);
;;;1279                       DUT_PROTOCOL_TxAddData(infoLen);
;;;1280   
;;;1281                       for (i = 0; i < infoLen; i++)
;;;1282                       {
;;;1283                           DUT_PROTOCOL_TxAddData(pCmdFrame->buff[6 + i]);
;;;1284                       }
;;;1285                       DUT_PROTOCOL_TxAddFrame();
;;;1286                   }
;;;1287               }
;;;1288           }
;;;1289   
;;;1290           // 读取
;;;1291           if (0x02 == (pCmdFrame->buff[STS_PROTOCOL_CMD_DATA1_INDEX] & 0x02))
;;;1292           {
;;;1293               // 标志
;;;1294               verreadFlag = TRUE;
;;;1295   
;;;1296               // 读取版本类型信息
;;;1297               SELECT_PROTOCOL_SendCmdParamAck(DUT_PROTOCOL_CMD_READ_VERSION_TYPE_INFO, dutverType);
;;;1298           }
;;;1299   
;;;1300           // 版本操作超时定时器
;;;1301           TIMER_AddTask(TIMER_ID_OPERATE_VER_TIMEOUT,
;;;1302                         3000,
;;;1303                         OperateVerTimeOut,
;;;1304                         0,
;;;1305                         1,
;;;1306                         ACTION_MODE_ADD_TO_QUEUE);
;;;1307   
;;;1308           // LCD显示
;;;1309           Vertical_Scrolling_Display(verTestMsgBuff, 4, 1);
;;;1310           break;
;;;1311   
;;;1312       // 获取DTA软件信息
;;;1313       case STS_PROTOCOL_CMD_GET_SOFTWARE_INFO:                                 // 0x30,
;;;1314           SPI_FLASH_ReadArray(versionBoot, SPI_FLASH_BOOT_VERSION_ADDEESS, 3); // 获取BOOT版本
;;;1315           SPI_FLASH_ReadArray(versionApp, SPI_FLASH_APP_VERSION_ADDEESS, 3);   // 获取APP版本
;;;1316           STS_PROTOCOL_TxAddData(STS_PROTOCOL_CMD_HEAD);                       // 添加命令头
;;;1317           STS_PROTOCOL_TxAddData(STS_PROTOCOL_CMD_GET_SOFTWARE_INFO);              // 添加命令字
;;;1318           STS_PROTOCOL_TxAddData(0x00);                                        // 数据长度临时为0
;;;1319           STS_PROTOCOL_TxAddData(versionBoot[0]);                              // 添加BOOT版本
;;;1320           STS_PROTOCOL_TxAddData(versionBoot[1]);
;;;1321           STS_PROTOCOL_TxAddData(versionBoot[2]);
;;;1322           STS_PROTOCOL_TxAddData(versionApp[0]); // 添加APP版本
;;;1323           STS_PROTOCOL_TxAddData(versionApp[1]);
;;;1324           STS_PROTOCOL_TxAddData(versionApp[2]);
;;;1325           STS_PROTOCOL_TxAddFrame(); // 设置数据长度和添加校验
;;;1326           break;
;;;1327   
;;;1328       // DTA工具升级开始
;;;1329       case STS_PROTOCOL_CMD_CLEAR_APP:
;;;1330           SPI_FLASH_EraseRoom(SPI_FLASH_TOOL_APP_ADDEESS, 256 * 1024);     // 256k
;;;1331           allPacketSize = 0;
;;;1332           STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_CLEAR_APP, TRUE);
;;;1333   
;;;1334           // LCD显示
;;;1335           Vertical_Scrolling_Display(dtaUpMsgBuff, 4, 0);
;;;1336           break;
;;;1337   
;;;1338       // DTA升级文件数据写入
;;;1339       case STS_PROTOCOL_CMD_TOOL_UP_APP:
;;;1340   
;;;1341           // 向片外flash写入STS发送的数据
;;;1342           packetSize = pCmdFrame->buff[STS_PROTOCOL_CMD_LENGTH_INDEX] - 4;
;;;1343           addr1 = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA1_INDEX];
;;;1344           addr2 = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA2_INDEX];
;;;1345           addr3 = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA3_INDEX];
;;;1346           addr4 = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA4_INDEX];
;;;1347           writeAddr = (addr1 << 24) | (addr2 << 16) | (addr3 << 8) | (addr4);
;;;1348           writeRes = SPI_FLASH_WriteWithCheck(&pCmdFrame->buff[STS_PROTOCOL_CMD_DATA5_INDEX], SPI_FLASH_TOOL_APP_ADDEESS + writeAddr, packetSize);
;;;1349   
;;;1350           // 返回信息给STS
;;;1351           STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_TOOL_UP_APP, TRUE);
;;;1352           allPacketSize++;
;;;1353   
;;;1354           if (showFlag)
;;;1355           {
;;;1356               // LCD显示
;;;1357               Vertical_Scrolling_Display(dtaUpMsgBuff, 4, 1);
;;;1358               showFlag = FALSE;
;;;1359           }
;;;1360           break;
;;;1361   
;;;1362       // DTA升级结束
;;;1363       case STS_PROTOCOL_CMD_TOOL_UP_END:
;;;1364   
;;;1365           // 发送升级成功应答
;;;1366           // 设置升级标志位标志
;;;1367           allPacket[0] = allPacketSize >> 24;
;;;1368           allPacket[1] = allPacketSize >> 16;
;;;1369           allPacket[2] = allPacketSize >> 8;
;;;1370           allPacket[3] = allPacketSize;
;;;1371   
;;;1372           SPI_FLASH_EraseSector(SPI_FLASH_TOOL_UPDATA_FLAG_ADDEESS); // 擦除标志位存储区
;;;1373           SPI_FLASH_EraseSector(SPI_FLASH_TOOL_APP_DATA_SIZE);       // 擦除大小存储区
;;;1374   
;;;1375           SPI_FLASH_WriteByte(SPI_FLASH_TOOL_UPDATA_FLAG_ADDEESS, 0xAA);
;;;1376           SPI_FLASH_WriteArray(allPacket, SPI_FLASH_TOOL_APP_DATA_SIZE, 4);
;;;1377   
;;;1378           STS_PROTOCOL_SendCmdAck(STS_PROTOCOL_CMD_TOOL_UP_END);
;;;1379   
;;;1380           /*100ms后跳转回BOOT，读取标志位，然后替换替换工具APP区*/
;;;1381           TIMER_AddTask(TIMER_ID_TOOL_APP_TO_BOOT,
;;;1382                         100,
;;;1383                         IAP_JumpToAppFun,
;;;1384                         IAP_GD32_FLASH_BASE,
;;;1385                         1,
;;;1386                         ACTION_MODE_ADD_TO_QUEUE);
;;;1387   
;;;1388           // LCD显示
;;;1389           Vertical_Scrolling_Display(dtaUpMsgBuff, 4, 2);
;;;1390           showFlag = TRUE;
;;;1391           break;
;;;1392   
;;;1393       // 设置DUT通讯参数
;;;1394       case STS_PROTOCOL_CMD_TOOL_SET_DUT_COMM_PARAM:
;;;1395           cmdLength = pCmdFrame->buff[STS_PROTOCOL_CMD_LENGTH_INDEX];
;;;1396           baudRate_value = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA2_INDEX];
;;;1397           online_detection_cnt = 0;
;;;1398   
;;;1399           // 设置波特率
;;;1400           switch (baudRate_value)
;;;1401           {
;;;1402           case 0x01:
;;;1403               uart_baudRate = UART_BAUD_RATE_1200;
;;;1404               can_baudRate = CAN_BAUD_RATE_100K;
;;;1405               break;
;;;1406   
;;;1407           case 0x02:
;;;1408               uart_baudRate = UART_BAUD_RATE_2400;
;;;1409               can_baudRate = CAN_BAUD_RATE_125K;
;;;1410               break;
;;;1411   
;;;1412           case 0x03:
;;;1413               uart_baudRate = UART_BAUD_RATE_4800;
;;;1414               can_baudRate = CAN_BAUD_RATE_150K;
;;;1415               break;
;;;1416   
;;;1417           case 0x04:
;;;1418               uart_baudRate = UART_BAUD_RATE_9600;
;;;1419               can_baudRate = CAN_BAUD_RATE_200K;
;;;1420               break;
;;;1421   
;;;1422           case 0x05:
;;;1423               uart_baudRate = UART_BAUD_RATE_14400;
;;;1424               can_baudRate = CAN_BAUD_RATE_250K;
;;;1425               break;
;;;1426   
;;;1427           case 0x06:
;;;1428               uart_baudRate = UART_BAUD_RATE_19200;
;;;1429               can_baudRate = CAN_BAUD_RATE_300K;
;;;1430               break;
;;;1431   
;;;1432           case 0x07:
;;;1433               uart_baudRate = UART_BAUD_RATE_38400;
;;;1434               can_baudRate = CAN_BAUD_RATE_400K;
;;;1435               break;
;;;1436   
;;;1437           case 0x08:
;;;1438               uart_baudRate = UART_BAUD_RATE_43000;
;;;1439               can_baudRate = CAN_BAUD_RATE_500K;
;;;1440               break;
;;;1441   
;;;1442           case 0x09:
;;;1443               uart_baudRate = UART_BAUD_RATE_57600;
;;;1444               can_baudRate = CAN_BAUD_RATE_600K;
;;;1445               break;
;;;1446   
;;;1447           case 0x0A:
;;;1448               uart_baudRate = UART_BAUD_RATE_76800;
;;;1449               can_baudRate = CAN_BAUD_RATE_900K;
;;;1450               break;
;;;1451   
;;;1452           case 0x0B:
;;;1453               uart_baudRate = UART_BAUD_RATE_115200;
;;;1454               break;
;;;1455   
;;;1456           case 0x0C:
;;;1457               uart_baudRate = UART_BAUD_RATE_128000;
;;;1458               break;
;;;1459   
;;;1460           default:
;;;1461               break;
;;;1462           }
;;;1463   
;;;1464           dut_info.uart_baudRate = uart_baudRate;
;;;1465           dut_info.can_baudRate  = can_baudRate;
;;;1466   
;;;1467           // 设置帧类型
;;;1468           frame_Type = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA3_INDEX];
;;;1469   
;;;1470   //            switch (frame_Type)
;;;1471   //            {
;;;1472   //                case 0x01:
;;;1473   //                    dut_info.can = CAN_STANDARD;
;;;1474   //                    break;
;;;1475   
;;;1476   //                case 0x02:
;;;1477   //                    dut_info.can = CAN_EXTENDED;
;;;1478   //                    break;
;;;1479   
;;;1480   //                default:
;;;1481   //                    break;
;;;1482   //            }
;;;1483   
;;;1484           // 设置通讯协议  0:DTA协议   1：小米协议
;;;1485           if ((3 < cmdLength) && (pCmdFrame->buff[STS_PROTOCOL_CMD_DATA4_INDEX]))
;;;1486           {
;;;1487               dut_info.commProt = TRUE;
;;;1488           }
;;;1489           else
;;;1490           {
;;;1491               dut_info.commProt = FALSE;
;;;1492           }
;;;1493   
;;;1494           // 设置通讯方式并初始化
;;;1495           communication_Type = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA1_INDEX];
;;;1496   
;;;1497           // 电源使能、八方高标VLK供电
;;;1498           if (4 < cmdLength)
;;;1499           {
;;;1500               dut_info.VLKFlag = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA5_INDEX];
;;;1501               _5VOUT_EN(dut_info.VLKFlag);
;;;1502           }
;;;1503   
;;;1504           switch (communication_Type)
;;;1505           {
;;;1506           // 3.3V串口通讯
;;;1507           case 0x01:
;;;1508               CHANGE_Init();
;;;1509               _5V_CHANGE_OFF();
;;;1510               VCCB_EN_ON();
;;;1511               UART_DRIVE_InitSelect(uart_baudRate);        // UART驱动层初始化
;;;1512               DUT_PROTOCOL_Init();                         // UART协议层初始化
;;;1513               UART_PROTOCOL_XM_Init();
;;;1514               dut_info.dutBusType = FALSE;
;;;1515   
;;;1516               // LCD显示
;;;1517               Vertical_Scrolling_Display(dtaUpMsgBuff, 4, 3);
;;;1518   
;;;1519               // 上报执行结果
;;;1520               STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_TOOL_SET_DUT_COMM_PARAM, TRUE);
;;;1521   
;;;1522               TIMER_AddTask(TIMER_ID_ONLINE_DETECT,
;;;1523                             3000,
;;;1524                             DutTimeOut,
;;;1525                             0,
;;;1526                             1,
;;;1527                             ACTION_MODE_ADD_TO_QUEUE);
;;;1528               break;
;;;1529   
;;;1530           // 5V串口通讯
;;;1531           case 0x02:
;;;1532               CHANGE_Init();
;;;1533               _5V_CHANGE_ON();
;;;1534               VCCB_EN_ON();
;;;1535               UART_DRIVE_InitSelect(uart_baudRate);        // UART驱动层初始化
;;;1536               DUT_PROTOCOL_Init();                         // UART协议层初始化
;;;1537               UART_PROTOCOL_XM_Init();
;;;1538               dut_info.dutBusType = FALSE;
;;;1539   
;;;1540               // LCD显示
;;;1541               Vertical_Scrolling_Display(dtaUpMsgBuff, 4, 3);
;;;1542   
;;;1543               // 上报执行结果
;;;1544               STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_TOOL_SET_DUT_COMM_PARAM, TRUE);
;;;1545   
;;;1546               TIMER_AddTask(TIMER_ID_ONLINE_DETECT,
;;;1547                             3000,
;;;1548                             DutTimeOut,
;;;1549                             0,
;;;1550                             1,
;;;1551                             ACTION_MODE_ADD_TO_QUEUE);
;;;1552               break;
;;;1553   
;;;1554           // CAN通讯
;;;1555           case 0x03:
;;;1556               CAN_PROTOCOL_TEST_Init(dut_info.can_baudRate);       // CAN驱动层初始化
;;;1557               dut_info.dutBusType = TRUE;
;;;1558   
;;;1559               // LCD显示
;;;1560               Vertical_Scrolling_Display(dtaUpMsgBuff, 4, 3);
;;;1561   
;;;1562               // 上报执行结果
;;;1563               STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_TOOL_SET_DUT_COMM_PARAM, TRUE);
;;;1564   
;;;1565               TIMER_AddTask(TIMER_ID_ONLINE_DETECT,
;;;1566                             3000,
;;;1567                             DutTimeOut,
;;;1568                             0,
;;;1569                             1,
;;;1570                             ACTION_MODE_ADD_TO_QUEUE);
;;;1571               break;
;;;1572   
;;;1573           default:
;;;1574               break;
;;;1575           }
;;;1576           dut_info.passThroughControl = FALSE;
;;;1577           break;
;;;1578   
;;;1579       case STS_PROTOCOL_CMD_MULTIPLE_TEST:     // 接收到多项测试指令 0xDF
;;;1580           test_Item = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA1_INDEX];  // 获取测试类型
;;;1581           testFlag = TRUE;
;;;1582   
;;;1583           // 获取目标电压值
;;;1584           voltageTarget = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA2_INDEX];
;;;1585           voltageTarget = voltageTarget << 8;
;;;1586           voltageTarget = voltageTarget | pCmdFrame->buff[STS_PROTOCOL_CMD_DATA3_INDEX];
;;;1587           voltageTarget = voltageTarget << 8;
;;;1588           voltageTarget = voltageTarget | pCmdFrame->buff[STS_PROTOCOL_CMD_DATA4_INDEX];
;;;1589           voltageTarget = voltageTarget << 8;
;;;1590           voltageTarget = voltageTarget | pCmdFrame->buff[STS_PROTOCOL_CMD_DATA5_INDEX];
;;;1591   
;;;1592           // 获取电压误差值
;;;1593           voltageTarget_error = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA6_INDEX];
;;;1594           voltageTarget_error = voltageTarget_error << 8;
;;;1595           voltageTarget_error = voltageTarget_error | pCmdFrame->buff[STS_PROTOCOL_CMD_DATA7_INDEX];
;;;1596   
;;;1597           // 换算得电压误差范围
;;;1598           dut_info.voltageMax = voltageTarget + voltageTarget_error;
;;;1599           dut_info.voltageMin = voltageTarget - voltageTarget_error;
;;;1600   
;;;1601           // 大灯测试
;;;1602           if (0x01 == (test_Item & 0x01))
;;;1603           {
;;;1604               if (dut_info.commProt)
;;;1605               {
;;;1606                   dut_info.test = TEST_TYPE_XM_HEADLIGHT;
;;;1607                   enterState();
;;;1608               }
;;;1609               else
;;;1610               {
;;;1611                   dut_info.test = TEST_TYPE_HEADLIGHT;
;;;1612                   enterState();
;;;1613               }
;;;1614   
;;;1615           }
;;;1616   
;;;1617           // 左转向灯测试
;;;1618           if (0x02 == (test_Item & 0x02))
;;;1619           {
;;;1620               if (dut_info.commProt)
;;;1621               {
;;;1622                   dut_info.test = TEST_TYPE_XM_LEFT_TURN_SIGNAL;
;;;1623                   enterState();
;;;1624               }
;;;1625               else
;;;1626               {
;;;1627                   dut_info.test = TEST_TYPE_LEFT_TURN_SIGNAL;
;;;1628                   enterState();
;;;1629               }
;;;1630           }
;;;1631   
;;;1632           // 右转向灯测试
;;;1633           if (0x03 == (test_Item & 0x03))
;;;1634           {
;;;1635               if (dut_info.commProt)
;;;1636               {
;;;1637                   dut_info.test = TEST_TYPE_XM_RIGHT_TURN_SIGNAL;
;;;1638                   enterState();
;;;1639               }
;;;1640               else
;;;1641               {
;;;1642                   dut_info.test = TEST_TYPE_RIGHT_TURN_SIGNAL;
;;;1643                   enterState();
;;;1644               }            ;
;;;1645           }
;;;1646   
;;;1647           // 近光灯测试
;;;1648           if (0x04 == (test_Item & 0x04))
;;;1649           {
;;;1650               dut_info.test = TEST_TYPE_LBEAM;
;;;1651               enterState();
;;;1652           }
;;;1653   
;;;1654           // 远光灯测试
;;;1655           if (0x05 == (test_Item & 0x05))
;;;1656           {
;;;1657               dut_info.test = TEST_TYPE_HBEAM;
;;;1658               enterState();
;;;1659           }
;;;1660   
;;;1661           // 油门测试
;;;1662           if (0x06 == (test_Item & 0x06))
;;;1663           {
;;;1664               if (dut_info.commProt)
;;;1665               {
;;;1666                   dut_info.test = TEST_TYPE_XM_THROTTLE;
;;;1667                   enterState();
;;;1668               }
;;;1669               else
;;;1670               {
;;;1671                   dut_info.test = TEST_TYPE_THROTTLE;
;;;1672                   enterState();
;;;1673               }
;;;1674           }
;;;1675   
;;;1676           // 刹把测试
;;;1677           if (0x07 == (test_Item & 0x07))
;;;1678           {
;;;1679               if (dut_info.commProt)
;;;1680               {
;;;1681                   dut_info.test = TEST_TYPE_XM_BRAKE;
;;;1682                   enterState();
;;;1683               }
;;;1684               else
;;;1685               {
;;;1686                   dut_info.test = TEST_TYPE_BRAKE;
;;;1687                   enterState();
;;;1688               }
;;;1689           }
;;;1690   
;;;1691           // VLK测试
;;;1692           if (0x08 == (test_Item & 0x08))
;;;1693           {
;;;1694               dut_info.test = TEST_TYPE_VLK;
;;;1695               enterState();
;;;1696   
;;;1697               // LCD显示
;;;1698               Vertical_Scrolling_Display(volTestMsgBuff, 4, 2);
;;;1699           }
;;;1700   
;;;1701           // 电子变速测试
;;;1702           if (0x09 == (test_Item & 0x09))
;;;1703           {
;;;1704               dut_info.test = TEST_TYPE_DERAILLEUR;
;;;1705               enterState();
;;;1706   
;;;1707               // LCD显示
;;;1708               Vertical_Scrolling_Display(deTestMsgBuff, 4, 0);
;;;1709           }
;;;1710           break;
;;;1711   
;;;1712       // GND测试
;;;1713       case STS_PROTOCOL_CMD_GND_TEST: // 0x04
;;;1714   
;;;1715           // 配置刹把和电子变速GND测试项
;;;1716           if (5 == pCmdFrame->buff[STS_PROTOCOL_CMD_DATA1_INDEX])
;;;1717           {
;;;1718               dut_info.timeout_Period = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA2_INDEX];
;;;1719               dut_info.test = TEST_TYPE_GND;
;;;1720               dut_info.gnd = GND_TYPE_BRAKE_DERAILLEUR;
;;;1721               enterState();
;;;1722           }
;;;1723   
;;;1724           // 配置电子变速GND测试项
;;;1725           if (4 == pCmdFrame->buff[STS_PROTOCOL_CMD_DATA1_INDEX])
;;;1726           {
;;;1727               dut_info.timeout_Period = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA2_INDEX];
;;;1728               dut_info.test = TEST_TYPE_GND;
;;;1729               dut_info.gnd = GND_TYPE_DERAILLEUR;
;;;1730               enterState();
;;;1731           }
;;;1732   
;;;1733           // 配置刹把、油门GND测试项
;;;1734           if (3 == pCmdFrame->buff[STS_PROTOCOL_CMD_DATA1_INDEX])
;;;1735           {
;;;1736               dut_info.timeout_Period = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA2_INDEX];
;;;1737               dut_info.test = TEST_TYPE_GND;
;;;1738               dut_info.gnd = GND_TYPE_THROTTLE_BRAKE;
;;;1739               enterState();
;;;1740           }
;;;1741   
;;;1742           // 配置刹把GND测试项
;;;1743           if (2 == pCmdFrame->buff[STS_PROTOCOL_CMD_DATA1_INDEX])
;;;1744           {
;;;1745               dut_info.timeout_Period = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA2_INDEX];
;;;1746               dut_info.test = TEST_TYPE_GND;
;;;1747               dut_info.gnd = GND_TYPE_BRAKE;
;;;1748               enterState();
;;;1749           }
;;;1750   
;;;1751           // 配置油门GND测试项
;;;1752           if (1 == pCmdFrame->buff[STS_PROTOCOL_CMD_DATA1_INDEX])
;;;1753           {
;;;1754               dut_info.timeout_Period = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA2_INDEX];
;;;1755               dut_info.test = TEST_TYPE_GND;
;;;1756               dut_info.gnd = GND_TYPE_THROTTLE;
;;;1757               enterState();
;;;1758           }
;;;1759   
;;;1760   
;;;1761           break;
;;;1762   
;;;1763       // USB充电测试（负载设置）
;;;1764       case STS_PROTOCOL_CMD_USB_CHARGE_TEST: // 0x14
;;;1765   
;;;1766           // LCD显示
;;;1767           Vertical_Scrolling_Display(showTestMsgBuff, 4, 3);
;;;1768   
;;;1769           // 获取负载电压
;;;1770           load_voltage = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA1_INDEX];
;;;1771           load_voltage = load_voltage << 8;
;;;1772           load_voltage = load_voltage | pCmdFrame->buff[STS_PROTOCOL_CMD_DATA2_INDEX];
;;;1773   
;;;1774           // 获取电压误差
;;;1775           voltage_error = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA3_INDEX];
;;;1776           voltage_error = voltage_error << 8;
;;;1777           voltage_error = voltage_error | pCmdFrame->buff[STS_PROTOCOL_CMD_DATA4_INDEX];
;;;1778   
;;;1779           // 获取负载电流
;;;1780           load_current = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA5_INDEX];
;;;1781   
;;;1782           // 获取电流误差
;;;1783           current_error = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA6_INDEX];
;;;1784           current_error = current_error << 8;
;;;1785           current_error = current_error | pCmdFrame->buff[STS_PROTOCOL_CMD_DATA7_INDEX];
;;;1786   
;;;1787           // 调整USB负载
;;;1788           // 500MA
;;;1789           if (0x00 == load_current)
;;;1790           {
;;;1791               //调整USB负载
;;;1792               DUT_USB_EN1_OFF();
;;;1793               DUT_USB_EN3_OFF();
;;;1794               DUT_USB_EN2_ON();
;;;1795               Delayms(400);
;;;1796   
;;;1797   //                // 通过mcu获取USB充电电压
;;;1798   //                real_load_voltage = USB_ADC_Read();
;;;1799               real_load_voltage = USB_ADC_Read();
;;;1800   
;;;1801               // 实际测得的负载电压在误差允许的范围内
;;;1802               if (((load_voltage - voltage_error) < real_load_voltage) && (real_load_voltage < (load_voltage + voltage_error)))
;;;1803               {
;;;1804   //                    // 通过mcu获取USB充电电流
;;;1805                   real_load_current = USB_CURRENT_Read();
;;;1806   //real_load_current = adcCB.usbcurrent.voltage;
;;;1807   
;;;1808                   // 实际测得的负载电流在误差允许的范围内
;;;1809                   if (((500 - current_error) < real_load_current) && (real_load_current < (500 + current_error)))
;;;1810                   {
;;;1811                       // 上报STS测试通过
;;;1812                       Clear_All_Lines();
;;;1813                       Display_Centered(0, "USB Charging ");
;;;1814                       Display_Centered(1, "Test Pass");
;;;1815                       STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_USB_CHARGE_TEST, TRUE);
;;;1816                   }
;;;1817                   else
;;;1818                   {
;;;1819                       // 测试失败
;;;1820                       STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_USB_CHARGE_TEST, FALSE);
;;;1821                   }
;;;1822               }
;;;1823               else
;;;1824               {
;;;1825                   // 测试失败
;;;1826                   STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_USB_CHARGE_TEST, FALSE);
;;;1827               }
;;;1828           }
;;;1829   
;;;1830           // 1A
;;;1831           if (0x01 == (load_current & 0x01))    // 1A
;;;1832           {
;;;1833               //调整USB负载
;;;1834               DUT_USB_EN1_ON();
;;;1835               DUT_USB_EN2_OFF();
;;;1836               DUT_USB_EN3_OFF();
;;;1837               Delayms(400);
;;;1838               
;;;1839               // 通过mcu获取USB充电电压
;;;1840               real_load_voltage = USB_ADC_Read();
;;;1841   
;;;1842               // 实际测得的负载电压在误差允许的范围内
;;;1843               if (((load_voltage - voltage_error) < real_load_voltage) && (real_load_voltage < (load_voltage + voltage_error)))
;;;1844               {
;;;1845                   // 通过mcu获取USB充电电流
;;;1846                   real_load_current = USB_CURRENT_Read();
;;;1847   
;;;1848                   // 实际测得的负载电流在误差允许的范围内
;;;1849                   if (((1000 - current_error) < real_load_current) && (real_load_current < (1000 + current_error)))
;;;1850                   {
;;;1851                       Clear_All_Lines();
;;;1852                       Display_Centered(0, "USB Charging ");
;;;1853                       Display_Centered(1, "Test Pass");
;;;1854   
;;;1855                       // 上报STS测试通过
;;;1856                       STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_USB_CHARGE_TEST, TRUE);
;;;1857                   }
;;;1858                   else
;;;1859                   {
;;;1860                       STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_USB_CHARGE_TEST, FALSE);
;;;1861                   }
;;;1862               }
;;;1863               else
;;;1864               {
;;;1865                   STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_USB_CHARGE_TEST, FALSE);
;;;1866               }
;;;1867   
;;;1868           }
;;;1869   
;;;1870           // 2A
;;;1871           if (0x02 == (load_current & 0x02))    // 2A
;;;1872           {
;;;1873               //调整USB负载
;;;1874               DUT_USB_EN1_ON();
;;;1875               DUT_USB_EN2_ON();
;;;1876               DUT_USB_EN3_ON();
;;;1877               Delayms(400);
;;;1878               // 通过mcu获取USB充电电压
;;;1879               real_load_voltage = USB_ADC_Read();
;;;1880   
;;;1881               // 实际测得的负载电压在误差允许的范围内
;;;1882               if (((load_voltage - voltage_error) < real_load_voltage) && (real_load_voltage < (load_voltage + voltage_error)))
;;;1883               {
;;;1884   
;;;1885                   // 通过mcu获取USB充电电流
;;;1886                   real_load_current = USB_CURRENT_Read();
;;;1887   
;;;1888                   // 实际测得的负载电流在误差允许的范围内
;;;1889                   if (((2000 - current_error) < real_load_current) && (real_load_current < (2000 + current_error)))
;;;1890                   {
;;;1891                       Clear_All_Lines();
;;;1892                       Display_Centered(0, "USB Charging ");
;;;1893                       Display_Centered(1, "Test Pass");
;;;1894   
;;;1895                       // 上报STS测试通过
;;;1896                       STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_USB_CHARGE_TEST, TRUE);
;;;1897                   }
;;;1898                   else
;;;1899                   {
;;;1900                       STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_USB_CHARGE_TEST, FALSE);
;;;1901                   }
;;;1902               }
;;;1903               else
;;;1904               {
;;;1905                   STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_USB_CHARGE_TEST, FALSE);
;;;1906               }
;;;1907           }
;;;1908           break;
;;;1909   
;;;1910       // 电压校准（多级校准）
;;;1911       case STS_PROTOCOL_CMD_VOLTAGE_CALIBRATION: // 0xDD
;;;1912   
;;;1913           // LCD显示
;;;1914           Vertical_Scrolling_Display(volTestMsgBuff, 3, 0);
;;;1915   
;;;1916           // 获取校准级别
;;;1917           dut_info.cal_number = pCmdFrame->buff[STS_PROTOCOL_CMD_LENGTH_INDEX];
;;;1918   
;;;1919           // 一级校准
;;;1920           if (0x01 == dut_info.cal_number)
;;;1921           {
;;;1922               calibration.data[0] = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA1_INDEX];
;;;1923               dut_info.test = TEST_TYPE_VOLTAGE;
;;;1924               enterState();
;;;1925               dut_info.cali_cnt = 1;
;;;1926           }
;;;1927   
;;;1928           // 二级校准
;;;1929           if (0x02 == dut_info.cal_number)
;;;1930           {
;;;1931               calibration.data[0] = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA1_INDEX];
;;;1932               calibration.data[1] = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA2_INDEX];
;;;1933               dut_info.test = TEST_TYPE_VOLTAGE;
;;;1934               enterState();
;;;1935               dut_info.cali_cnt = 2;
;;;1936           }
;;;1937   
;;;1938           // 三级校准
;;;1939           if (0x03 == dut_info.cal_number)
;;;1940           {
;;;1941               calibration.data[0] = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA1_INDEX];
;;;1942               calibration.data[1] = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA2_INDEX];
;;;1943               calibration.data[2] = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA3_INDEX];
;;;1944               dut_info.test = TEST_TYPE_VOLTAGE;
;;;1945               enterState();
;;;1946               dut_info.cali_cnt = 3;
;;;1947           }
;;;1948           break;
;;;1949   
;;;1950       // 调整仪表供电电压
;;;1951       case STS_PROTOCOL_CMD_ADJUST_DUT_VOLTAGE:      // 0x16
;;;1952           dut_info.adjustState = TRUE;
;;;1953   
;;;1954           // 通知电源板调整DUT供电电压
;;;1955           POWER_PROTOCOL_SendCmdParamAck(POWER_PROTOCOL_CMD_ADJUST_DUT_POWER_SUPPLY_VOLTAGE, pCmdFrame->buff[STS_PROTOCOL_CMD_DATA1_INDEX]);
;;;1956           break;
;;;1957   
;;;1958       // 写标志区数据
;;;1959       case STS_PROTOCOL_CMD_WRITE_FLAG_DATA:
;;;1960   
;;;1961           // 关闭VLK供电
;;;1962           VLK_PW_EN_OFF();
;;;1963           UART_DRIVE_AddTxArray(0, pCmdFrame->buff, pCmdFrame->length);
;;;1964           Clear_All_Lines();
;;;1965           Display_Centered(0, "VLK CLOSE");
;;;1966           break;
;;;1967   
;;;1968       // UART测试
;;;1969       case STS_PROTOCOL_CMD_UART_TEST:      // 0x19 - UART测试命令
;;;1970           dut_info.test = TEST_TYPE_UART;
;;;1971           enterState();
;;;1972   
;;;1973           // LCD显示
;;;1974           Vertical_Scrolling_Display(volTestMsgBuff, 3, 1);
;;;1975           break;
;;;1976   
;;;1977       // Flash 校验测试
;;;1978       case STS_PROTOCOL_CMD_FLASH_CHECK_TEST:
;;;1979           TIMER_ChangeTime(TIMER_ID_ONLINE_DETECT, 7000);
;;;1980   
;;;1981           if (dut_info.dutBusType)
;;;1982           {
;;;1983               CAN_TEST_DRIVE_AddTxArray(0, pCmdFrame->buff, pCmdFrame->length);
;;;1984           }
;;;1985           else
;;;1986           {
;;;1987               UART_DRIVE_AddTxArray(0, pCmdFrame->buff, pCmdFrame->length);
;;;1988           }
;;;1989           break;
;;;1990   
;;;1991       // 仪表电源控制
;;;1992       case STS_PROTOCOL_CMD_CONTROL_DUT_POWER:
;;;1993           dut_info.powerOnFlag = TRUE;
;;;1994   
;;;1995           // 开启电源
;;;1996           if (pCmdFrame->buff[STS_PROTOCOL_CMD_DATA1_INDEX])
;;;1997           {
;;;1998               POWER_PROTOCOL_SendCmdParamAck(POWER_PROTOCOL_CMD_ADJUST_DUT_POWER_SWITCH, TRUE);
;;;1999           }
;;;2000   
;;;2001           // 关闭电源
;;;2002           if (!pCmdFrame->buff[STS_PROTOCOL_CMD_DATA1_INDEX])
;;;2003           {
;;;2004               // 关闭vlk供电
;;;2005   //                VLK_PW_EN_OFF();
;;;2006               POWER_PROTOCOL_SendCmdParamAck(POWER_PROTOCOL_CMD_ADJUST_DUT_POWER_SWITCH, FALSE);
;;;2007           }
;;;2008           break;
;;;2009   
;;;2010       // 获取WAKE电压
;;;2011       case STS_PROTOCOL_CMD_OBTAIN_WAKE_UP_VOL:
;;;2012           STS_PROTOCOL_TxAddData(STS_PROTOCOL_CMD_HEAD);
;;;2013           STS_PROTOCOL_TxAddData(STS_PROTOCOL_CMD_OBTAIN_WAKE_UP_VOL);
;;;2014           STS_PROTOCOL_TxAddData(0x02);
;;;2015           STS_PROTOCOL_TxAddData(KEY_ADC_Read() >> 8);
;;;2016           STS_PROTOCOL_TxAddData(KEY_ADC_Read() & 0xFF);
;;;2017           STS_PROTOCOL_TxAddFrame();
;;;2018           break;
;;;2019   
;;;2020       // 笔段屏/数码管显示测试
;;;2021       case STS_PROTOCOL_CMD_DISPLAY_TEST:
;;;2022   
;;;2023           if (dut_info.commProt)
;;;2024           {
;;;2025               // 只取数据透传
;;;2026               UART_PROTOCOL_XM_TxAddData(UART_PROTOCOL_XM_CMD_HEAD);
;;;2027               UART_PROTOCOL_XM_TxAddData(UART_PROTOCOL_XM_CMD_DEVICE);
;;;2028               UART_PROTOCOL_XM_TxAddData(UART_PROTOCOL_XM_CMD_TEST_LED);  // 数码管显示指令
;;;2029               UART_PROTOCOL_XM_TxAddData(0);                             // 数据长度
;;;2030   
;;;2031               for (i = 0; i < pCmdFrame->buff[STS_PROTOCOL_CMD_LENGTH_INDEX] - 1; i++) // 减去测试模式一个字节
;;;2032               {
;;;2033                   UART_PROTOCOL_XM_TxAddData(pCmdFrame->buff[STS_PROTOCOL_CMD_DATA1_INDEX + 1 + i]);
;;;2034               }
;;;2035   
;;;2036               UART_PROTOCOL_XM_TxAddFrame();
;;;2037   
;;;2038   //                UART_PROTOCOL_XM_TxAddData(UART_PROTOCOL_XM_CMD_HEAD);
;;;2039   //                UART_PROTOCOL_XM_TxAddData(UART_PROTOCOL_XM_CMD_DEVICE);
;;;2040   //                UART_PROTOCOL_XM_TxAddData(UART_PROTOCOL_XM_CMD_TEST_LED);  // 数码管显示指令
;;;2041   
;;;2042   //                for(i = 0 ; i< 14 ;i++)
;;;2043   //                {
;;;2044   //                    UART_PROTOCOL_XM_TxAddData();
;;;2045   //                }
;;;2046   //                UART_PROTOCOL_XM_TxAddFrame();
;;;2047           }
;;;2048           else
;;;2049           {
;;;2050               if (dut_info.dutBusType)
;;;2051               {
;;;2052                   CAN_TEST_DRIVE_AddTxArray(0, pCmdFrame->buff, pCmdFrame->length);
;;;2053                   testFlag = TRUE;
;;;2054               }
;;;2055               else
;;;2056               {
;;;2057                   UART_DRIVE_AddTxArray(0, pCmdFrame->buff, pCmdFrame->length);
;;;2058               }
;;;2059           }
;;;2060           break;
;;;2061   
;;;2062       // 蜂鸣器控制测试
;;;2063       case STS_PROTOCOL_CMD_BUZZER_TEST:
;;;2064   
;;;2065           if (dut_info.commProt)
;;;2066           {
;;;2067               UART_PROTOCOL_XM_SendCmdAck(UART_PROTOCOL_XM_CMD_TEST_BEEP);
;;;2068           }
;;;2069           else
;;;2070           {
;;;2071               if (dut_info.dutBusType)
;;;2072               {
;;;2073                   CAN_TEST_DRIVE_AddTxArray(0, pCmdFrame->buff, pCmdFrame->length);
;;;2074                   testFlag = TRUE;
;;;2075               }
;;;2076               else
;;;2077               {
;;;2078                   UART_DRIVE_AddTxArray(0, pCmdFrame->buff, pCmdFrame->length);
;;;2079               }
;;;2080           }
;;;2081           break;
;;;2082   
;;;2083       // 蓝牙测试
;;;2084       case STS_PROTOCOL_CMD_BLE_TEST:
;;;2085   
;;;2086           // 若测4lite
;;;2087           if (dut_info.commProt)
;;;2088           {
;;;2089               for (i = 0 ; i < pCmdFrame->buff[STS_PROTOCOL_CMD_LENGTH_INDEX]; i++)
;;;2090               {
;;;2091                   verBle[i] = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA1_INDEX + i];
;;;2092               }
;;;2093   
;;;2094               // 先查询蓝牙固件版本
;;;2095               UART_PROTOCOL_XM_TxAddData(UART_PROTOCOL_XM_CMD_HEAD);
;;;2096               UART_PROTOCOL_XM_TxAddData(UART_PROTOCOL_XM_CMD_DEVICE);
;;;2097               UART_PROTOCOL_XM_TxAddData(UART_PROTOCOL_XM_CMD_TEST_BLE_VERSION);  // 获取OOB参数指令
;;;2098               UART_PROTOCOL_XM_TxAddData(0x00);                                   // 数据长度
;;;2099               UART_PROTOCOL_XM_TxAddFrame();
;;;2100           }
;;;2101           else
;;;2102           {
;;;2103               if (dut_info.dutBusType)
;;;2104               {
;;;2105                   CAN_TEST_DRIVE_AddTxArray(0, pCmdFrame->buff, pCmdFrame->length);
;;;2106                   testFlag = TRUE;
;;;2107               }
;;;2108               else
;;;2109               {
;;;2110                   UART_DRIVE_AddTxArray(0, pCmdFrame->buff, pCmdFrame->length);
;;;2111               }
;;;2112           }
;;;2113           break;
;;;2114   
;;;2115       // 按键测试
;;;2116       case STS_PROTOCOL_CMD_KEY_TEST:
;;;2117   
;;;2118           dut_info.buttonSimulationFlag = FALSE;
;;;2119   
;;;2120           // 若测4lite
;;;2121           if (dut_info.commProt)
;;;2122           {
;;;2123               // 按键测试
;;;2124               UART_PROTOCOL_XM_TxAddData(UART_PROTOCOL_XM_CMD_HEAD);
;;;2125               UART_PROTOCOL_XM_TxAddData(UART_PROTOCOL_XM_CMD_DEVICE);
;;;2126               UART_PROTOCOL_XM_TxAddData(UART_PROTOCOL_XM_CMD_TEST_KEY);  // 获取OOB参数指令
;;;2127               UART_PROTOCOL_XM_TxAddData(0x00);         // 数据长度
;;;2128               UART_PROTOCOL_XM_TxAddFrame();
;;;2129           }
;;;2130           else
;;;2131           {
;;;2132               if (dut_info.dutBusType)
;;;2133               {
;;;2134                   CAN_TEST_DRIVE_AddTxArray(0, pCmdFrame->buff, pCmdFrame->length);
;;;2135                   testFlag = TRUE;
;;;2136               }
;;;2137               else
;;;2138               {
;;;2139                   UART_DRIVE_AddTxArray(0, pCmdFrame->buff, pCmdFrame->length);
;;;2140               }
;;;2141           }
;;;2142           break;
;;;2143   
;;;2144       // 模拟按键测试
;;;2145       case STS_PROTOCOL_CMD_SIMULATION_KEY_TEST:
;;;2146   
;;;2147           dut_info.buttonSimulationFlag = TRUE;
;;;2148   
;;;2149           // 按键测试
;;;2150           // 若测4lite
;;;2151           if (dut_info.commProt)
;;;2152           {
;;;2153               // 按键测试
;;;2154               UART_PROTOCOL_XM_TxAddData(UART_PROTOCOL_XM_CMD_HEAD);
;;;2155               UART_PROTOCOL_XM_TxAddData(UART_PROTOCOL_XM_CMD_DEVICE);
;;;2156               UART_PROTOCOL_XM_TxAddData(UART_PROTOCOL_XM_CMD_TEST_KEY);  // 获取OOB参数指令
;;;2157               UART_PROTOCOL_XM_TxAddData(0x00);         // 数据长度
;;;2158               UART_PROTOCOL_XM_TxAddFrame();
;;;2159           }
;;;2160           else
;;;2161           {
;;;2162               if (dut_info.dutBusType)
;;;2163               {
;;;2164                   CAN_PROTOCOL_TEST_SendCmdAck(CAN_PROTOCOL_TEST_CMD_KEY_TEST);
;;;2165                   testFlag = TRUE;
;;;2166               }
;;;2167               else
;;;2168               {
;;;2169                   DUT_PROTOCOL_SendCmdAck(DUT_PROTOCOL_CMD_KEY_TEST);
;;;2170               }
;;;2171           }
;;;2172   
;;;2173           keyNumber = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA1_INDEX];
;;;2174           keyValue  = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA2_INDEX];
;;;2175   
;;;2176           // 模拟按键按下
;;;2177           switch (keyNumber)
;;;2178           {
;;;2179           case KEY_NUMBER_ZERO:
;;;2180               KEY_TEST_EN0_ON();
;;;2181               Delayms(100);
;;;2182               KEY_TEST_EN0_OFF();
;;;2183               break;
;;;2184   
;;;2185           case KEY_NUMBER_ONE:
;;;2186               KEY_TEST_EN1_ON();
;;;2187               Delayms(100);
;;;2188               KEY_TEST_EN1_OFF();
;;;2189               break;
;;;2190   
;;;2191           case KEY_NUMBER_TWO:
;;;2192               KEY_TEST_EN2_ON();
;;;2193               Delayms(100);
;;;2194               KEY_TEST_EN2_OFF();
;;;2195               break;
;;;2196   
;;;2197           case KEY_NUMBER_THREE:
;;;2198               KEY_TEST_EN3_ON();
;;;2199               Delayms(100);
;;;2200               KEY_TEST_EN3_OFF();
;;;2201               break;
;;;2202   
;;;2203           case KEY_NUMBER_FOUR:
;;;2204               KEY_TEST_EN4_ON();
;;;2205               Delayms(100);
;;;2206               KEY_TEST_EN4_OFF();
;;;2207               break;
;;;2208   
;;;2209           case KEY_NUMBER_FIVE:
;;;2210               KEY_TEST_EN5_ON();
;;;2211               Delayms(100);
;;;2212               KEY_TEST_EN5_OFF();
;;;2213               break;
;;;2214   
;;;2215           case KEY_NUMBER_SIX:
;;;2216               KEY_TEST_EN6_ON();
;;;2217               Delayms(100);
;;;2218               KEY_TEST_EN6_OFF();
;;;2219               break;
;;;2220   
;;;2221           case KEY_NUMBER_SEVEN:
;;;2222               KEY_TEST_EN7_ON();
;;;2223               Delayms(100);
;;;2224               KEY_TEST_EN7_OFF();
;;;2225               break;
;;;2226   
;;;2227           default:
;;;2228               // 处理无效的按键编号
;;;2229               break;
;;;2230           }
;;;2231           break;
;;;2232   
;;;2233       // 获取DUT供电电流
;;;2234       case STS_PROTOCOL_CMD_OBTAIN_DUT_CURRENT:
;;;2235           POWER_PROTOCOL_SendCmdAck(POWER_PROTOCOL_CMD_GET_POWER_SUPPLY_CURRENT);
;;;2236           break;
;;;2237   
;;;2238   //        // 升级DUT控制命令
;;;2239   //        case STS_PROTOCOL_CMD_TOOL_DUT_UP:
;;;2240   
;;;2241   //            // 关闭在线检测
;;;2242   //            TIMER_KillTask(TIMER_ID_ONLINE_DETECT);
;;;2243   
;;;2244   //            upItem = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA1_INDEX];
;;;2245   //            ctrlState = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA2_INDEX];
;;;2246   
;;;2247   //            // 设置要升级的项
;;;2248   //            setUpItem(upItem, ctrlState);
;;;2249   
;;;2250   //            // 设置进度上报信息
;;;2251   //            setDutProgressReportInfo();
;;;2252   
;;;2253   //            // 根据升级信息，进入不同的状态机
;;;2254   //            enterUpState();
;;;2255   
;;;2256   //            // 应答
;;;2257   //            STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_TOOL_DUT_UP, TRUE);
;;;2258   
;;;2259   //            // LCD显示
;;;2260   //            Vertical_Scrolling_Display(dutUpMsgBuff, 4, 1);
;;;2261   //            break;
;;;2262   
;;;2263   //        // 0x41 - DUT升级进度上报
;;;2264   //        case STS_PROTOCOL_CMD_TOOL_DUT_PROCESS:
;;;2265   //            break;
;;;2266   
;;;2267   //        // 0x42 - 清空升级缓冲区
;;;2268   //        case STS_PROTOCOL_CMD_TOOL_CLEAR_BUFF:
;;;2269   //            clearItem = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA1_INDEX];
;;;2270   //            if (0x01 == (clearItem & 0x01))
;;;2271   //            {
;;;2272   //                /*擦除片外的dut_boot区*/
;;;2273   //                dut_info.bootSize = 0;
;;;2274   //                SPI_FLASH_EraseRoom(SPI_FLASH_DUT_BOOT_ADDEESS, 128 * 1024); // 128k
;;;2275   //            }
;;;2276   //            if (0x02 == (clearItem & 0x02))
;;;2277   //            {
;;;2278   //                /*擦除片外的dut_app区*/
;;;2279   //                dut_info.appSize = 0;
;;;2280   //                SPI_FLASH_EraseRoom(SPI_FLASH_DUT_APP_ADDEESS, 1024 * 1024); // 1M
;;;2281   //            }
;;;2282   //            if (0x08 == (clearItem & 0x08))
;;;2283   //            {
;;;2284   //                /*擦除片外的dut_config区*/
;;;2285   //                SPI_FLASH_EraseSector(SPI_FLASH_DUT_CONFIG_ADDEESS); // 4k
;;;2286   //            }
;;;2287   //            SPI_FLASH_EraseSector(SPI_FLASH_DUT_INFO); // 擦除dut机型信息
;;;2288   //            STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_TOOL_CLEAR_BUFF, TRUE);
;;;2289   //            break;
;;;2290   
;;;2291   //        // 0x43 - DTA写入DUT机型信息
;;;2292   //        case STS_PROTOCOL_CMD_TOOL_SET_DUT_INFO:
;;;2293   //            dut_info_len = pCmdFrame->buff[STS_PROTOCOL_CMD_LENGTH_INDEX] - 3;
;;;2294   
;;;2295   //            for (dutName_i = 0; dutName_i < dut_info_len; dutName_i++)
;;;2296   //            {
;;;2297   //                dutAll[dutName_i] = pCmdFrame->buff[dutName_i + 3 + 3];
;;;2298   //            }
;;;2299   //            dutAll[20] = dut_info_len;                                  // 长度
;;;2300   //            //        dutAll[21] = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA1_INDEX]; // 电压
;;;2301   //            //        dutAll[22] = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA2_INDEX]; // 通讯类型
;;;2302   //            dutAll[23] = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA1_INDEX]; // bootType
;;;2303   //            dutAll[24] = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA2_INDEX]; // appType
;;;2304   //            dutAll[25] = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA3_INDEX]; // uiType
;;;2305   //            dutAll[26] = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA4_INDEX]; // configType
;;;2306   
;;;2307   //            /* 将机型信息写入到片外flash */
;;;2308   //            SPI_FLASH_EraseSector(SPI_FLASH_DUT_INFO);
;;;2309   //            writeRes = SPI_FLASH_WriteWithCheck(dutAll, SPI_FLASH_DUT_INFO, 30);
;;;2310   
;;;2311   //            if (writeRes)
;;;2312   //            {
;;;2313   //                DutInfoUpdata(); // 更新dutinfo数据
;;;2314   //            }
;;;2315   //            /* 返回信息给STS */
;;;2316   //            STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_TOOL_SET_DUT_INFO, writeRes);
;;;2317   //            break;
;;;2318   
;;;2319   //        case STS_PROTOCOL_CMD_TOOL_GET_DUT_INFO: // 0x44 - 获取DTA记录的DUT机型信息
;;;2320   //            SPI_FLASH_ReadArray(dutAll, SPI_FLASH_DUT_INFO, 30);
;;;2321   //            if (0xFF == dutAll[20]) // 机型为空
;;;2322   //            {
;;;2323   //                dutAll[20] = 10;
;;;2324   //            }
;;;2325   //            STS_PROTOCOL_TxAddData(STS_PROTOCOL_CMD_HEAD);           // 添加命令头
;;;2326   //            STS_PROTOCOL_TxAddData(STS_PROTOCOL_CMD_TOOL_GET_DUT_INFO);  // 添加命令字
;;;2327   //            STS_PROTOCOL_TxAddData(24);                              // 数据长度临时为0
;;;2328   //            STS_PROTOCOL_TxAddData(dutAll[23]);                      // bootType
;;;2329   //            STS_PROTOCOL_TxAddData(dutAll[24]);                      // appType
;;;2330   //            STS_PROTOCOL_TxAddData(dutAll[25]);                      // uiType
;;;2331   //            STS_PROTOCOL_TxAddData(dutAll[26]);                      // configType
;;;2332   //            for (dutName_i = 0; dutName_i < dutAll[20]; dutName_i++) // 添加机型信息
;;;2333   //            {
;;;2334   //                STS_PROTOCOL_TxAddData(dutAll[dutName_i]);
;;;2335   //            }
;;;2336   //            STS_PROTOCOL_TxAddFrame(); // 设置数据长度和添加校验
;;;2337   //            break;
;;;2338   
;;;2339   //        case STS_PROTOCOL_CMD_UP_CONFIG: // 0x50 - 写入DUT配置参数
;;;2340   //            SPI_FLASH_EraseSector(SPI_FLASH_DUT_CONFIG_ADDEESS); // 4k
;;;2341   
;;;2342   //            // 读取配置信息的flash区，然后写入DUT
;;;2343   //            dataLen = pCmdFrame->buff[STS_PROTOCOL_CMD_LENGTH_INDEX];
;;;2344   //            writeRes = SPI_FLASH_WriteWithCheck(&(pCmdFrame->buff[STS_PROTOCOL_CMD_LENGTH_INDEX]), SPI_FLASH_DUT_CONFIG_ADDEESS, dataLen + 1);
;;;2345   
;;;2346   //            // 返回信息给STS
;;;2347   //            STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_UP_CONFIG, writeRes);
;;;2348   //            break;
;;;2349   
;;;2350   //        case STS_PROTOCOL_CMD_UP_BOOT:   // 0x51 - BOOT数据写入
;;;2351   
;;;2352   //            // 读取BOOT的flash区，然后写入DUT
;;;2353   //            packetSize = pCmdFrame->buff[STS_PROTOCOL_CMD_LENGTH_INDEX] - 4;
;;;2354   //            addr1 = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA1_INDEX];
;;;2355   //            addr2 = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA2_INDEX];
;;;2356   //            addr3 = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA3_INDEX];
;;;2357   //            addr4 = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA4_INDEX];
;;;2358   //            writeAddr = (addr1 << 24) | (addr2 << 16) | (addr3 << 8) | (addr4);
;;;2359   
;;;2360   //            if (currPacketNum != writeAddr)
;;;2361   //            {
;;;2362   //                dut_info.bootSize++;
;;;2363   //                currPacketNum = writeAddr;
;;;2364   //            }
;;;2365   
;;;2366   //            writeRes = SPI_FLASH_WriteWithCheck(&pCmdFrame->buff[STS_PROTOCOL_CMD_DATA5_INDEX], SPI_FLASH_DUT_BOOT_ADDEESS + writeAddr, packetSize);
;;;2367   
;;;2368   //            // 返回信息给STS
;;;2369   //            STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_UP_BOOT, writeRes);
;;;2370   //            break;
;;;2371   
;;;2372   //        case STS_PROTOCOL_CMD_UP_APP:    // 0x52 - APP数据写入
;;;2373   //            packetSize = pCmdFrame->buff[STS_PROTOCOL_CMD_LENGTH_INDEX] - 4;
;;;2374   //            addr1 = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA1_INDEX];
;;;2375   //            addr2 = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA2_INDEX];
;;;2376   //            addr3 = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA3_INDEX];
;;;2377   //            addr4 = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA4_INDEX];
;;;2378   //            writeAddr = (addr1 << 24) | (addr2 << 16) | (addr3 << 8) | (addr4);
;;;2379   
;;;2380   //            if (currPacketNum != writeAddr)
;;;2381   //            {
;;;2382   //                dut_info.appSize++;
;;;2383   //                currPacketNum = writeAddr;
;;;2384   //            }
;;;2385   
;;;2386   //            writeRes = SPI_FLASH_WriteWithCheck(&pCmdFrame->buff[STS_PROTOCOL_CMD_DATA5_INDEX], SPI_FLASH_DUT_APP_ADDEESS + writeAddr, packetSize);
;;;2387   //            STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_UP_APP, writeRes);
;;;2388   
;;;2389   //            if (dutFlag)
;;;2390   //            {
;;;2391   //                // LCD显示
;;;2392   //                Vertical_Scrolling_Display(dutUpMsgBuff, 4, 0);
;;;2393   //                dutFlag = FALSE;
;;;2394   //            }
;;;2395   //            break;
;;;2396   
;;;2397   //        case STS_PROTOCOL_CMD_UP_END:    // 0x53 - 升级项结束
;;;2398   //            endItem = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA1_INDEX];
;;;2399   
;;;2400   //            switch (endItem)
;;;2401   //            {
;;;2402   //                case 0:
;;;2403   //                    SPI_FLASH_EraseSector(SPI_FLASH_DUT_BOOT_SIZE_ADDEESS);
;;;2404   //                    size[0] = dut_info.bootSize >> 24;
;;;2405   //                    size[1] = dut_info.bootSize >> 16;
;;;2406   //                    size[2] = dut_info.bootSize >> 8;
;;;2407   //                    size[3] = dut_info.bootSize;
;;;2408   //                    SPI_FLASH_WriteArray(size, SPI_FLASH_DUT_BOOT_SIZE_ADDEESS, 4);
;;;2409   //                    break;
;;;2410   //                case 1:
;;;2411   //                    SPI_FLASH_EraseSector(SPI_FLASH_DUT_APP_SIZE_ADDEESS);
;;;2412   //                    size[0] = dut_info.appSize >> 24;
;;;2413   //                    size[1] = dut_info.appSize >> 16;
;;;2414   //                    size[2] = dut_info.appSize >> 8;
;;;2415   //                    size[3] = dut_info.appSize;
;;;2416   //                    SPI_FLASH_WriteArray(size, SPI_FLASH_DUT_APP_SIZE_ADDEESS, 4);
;;;2417   //                    break;
;;;2418   //                case 2:
;;;2419   //                    SPI_FLASH_EraseSector(SPI_FLASH_DUT_UI_SIZE_ADDEESS);
;;;2420   //                    size[0] = dut_info.uiSize >> 24;
;;;2421   //                    size[1] = dut_info.uiSize >> 16;
;;;2422   //                    size[2] = dut_info.uiSize >> 8;
;;;2423   //                    size[3] = dut_info.uiSize;
;;;2424   //                    SPI_FLASH_WriteArray(size, SPI_FLASH_DUT_UI_SIZE_ADDEESS, 4);
;;;2425   //                    break;
;;;2426   //            }
;;;2427   //            currPacketNum = 0xFFFF;
;;;2428   
;;;2429   //            // 返回信息给STS
;;;2430   //            STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_UP_END, endItem);
;;;2431   
;;;2432   //            // LCD显示
;;;2433   //            Vertical_Scrolling_Display(dutUpMsgBuff, 4, 3);
;;;2434   //            dutFlag = TRUE;
;;;2435   //            break;
;;;2436   
;;;2437   //        // 设置不写入项
;;;2438   //        case STS_PROTOCOL_CMD_SET_NOT_WRITTEN:
;;;2439   
;;;2440   //            // 读取配置数据
;;;2441   //            memset(configs, 0, sizeof(configs));
;;;2442   //            memset(resultArray, 0, sizeof(resultArray));
;;;2443   //            memset(verifiedBuff, 0, sizeof(verifiedBuff));
;;;2444   //            memset(paramLength, 0, sizeof(paramLength));
;;;2445   //            memset(paramNumber, 0, sizeof(paramNumber));
;;;2446   //            resultIndex = 0;
;;;2447   //            verifiedIndex = 0;
;;;2448   
;;;2449   //            SPI_FLASH_ReadArray(configs, SPI_FLASH_DUT_CONFIG_ADDEESS, 170);
;;;2450   
;;;2451   //            // 获取不写入项序号
;;;2452   //            noLenght = pCmdFrame->buff[STS_PROTOCOL_CMD_LENGTH_INDEX];
;;;2453   //            for (i = 0; i < noLenght ; i++)
;;;2454   //            {
;;;2455   //                noNumber[i] = pCmdFrame->buff[3 + i];
;;;2456   //            }
;;;2457   
;;;2458   //            // 设置不写入项，获取不写入项序号
;;;2459   //            if (noLenght)
;;;2460   //            {
;;;2461   //                // 对参数进行处理，提取参数内容
;;;2462   //                for (i = 0; i < configs[0] ;)
;;;2463   //                {
;;;2464   //                    paramLength[i] = configs[i + 1];   // 参数长度
;;;2465   //                    paramNumber[i] = configs[i + 2];   // 参数序号
;;;2466   
;;;2467   //                    for (k = 0; k < noLenght; k++)
;;;2468   //                    {
;;;2469   //                        if (noNumber[k] != configs[i + 2])
;;;2470   //                        {
;;;2471   //                            // 拼接配置参数
;;;2472   //                            for (j = 0 ; j < paramLength[i]; j++)
;;;2473   //                            {
;;;2474   //                                paramContent[paramNumber[i]][j] = configs[i + 2 + j + 1];
;;;2475   
;;;2476   //                                // 将数据添加到结果数组
;;;2477   //                                resultArray[resultIndex++] = paramContent[paramNumber[i]][j];
;;;2478   //                            }
;;;2479   //                        }
;;;2480   //                        i = i + 1 + paramLength[i] + 1;
;;;2481   //                    }
;;;2482   //                }
;;;2483   
;;;2484   //                // 获取待校验buff，去掉系统时间
;;;2485   //                for (k = 0; k < noLenght; k++)
;;;2486   //                {
;;;2487   //                    // 会写入系统的时间
;;;2488   //                    if (noNumber[k] != 3)
;;;2489   //                    {
;;;2490   //                        for (i = 0; i < resultIndex ; i++)
;;;2491   //                        {
;;;2492   //                            if (i == 2)
;;;2493   //                            {
;;;2494   //                                i = i + 5;
;;;2495   //                            }
;;;2496   //                            verifiedBuff[verifiedIndex++] = resultArray[i];
;;;2497   //                        }
;;;2498   //                    }
;;;2499   
;;;2500   //                    // 不会写入系统时间
;;;2501   //                    if (noNumber[k] == 3)
;;;2502   //                    {
;;;2503   //                        for (i = 0; i < resultIndex ; i++)
;;;2504   //                        {
;;;2505   //                            verifiedBuff[verifiedIndex++] = resultArray[i];
;;;2506   //                        }
;;;2507   //                    }
;;;2508   //                }
;;;2509   //            }
;;;2510   
;;;2511   //            // 不设置
;;;2512   //            if (!noLenght)
;;;2513   //            {
;;;2514   //                for (i = 0; i < configs[0] ;)
;;;2515   //                {
;;;2516   //                    paramLength[i] = configs[i + 1];
;;;2517   //                    paramNumber[i] = configs[i + 2];
;;;2518   //                    for (j = 0 ; j < paramLength[i]; j++)
;;;2519   //                    {
;;;2520   //                        paramContent[paramNumber[i]][j] = configs[i + 2 + j + 1];
;;;2521   
;;;2522   //                        // 将数据添加到结果数组
;;;2523   //                        resultArray[resultIndex++] = paramContent[paramNumber[i]][j];
;;;2524   //                    }
;;;2525   //                    i = i + 1 + paramLength[i] + 1;
;;;2526   //                }
;;;2527   
;;;2528   //                // 获取待校验buff，去掉系统时间
;;;2529   //                for (i = 0; i < resultIndex ; i++)
;;;2530   //                {
;;;2531   //                    if (i == 2)
;;;2532   //                    {
;;;2533   //                        i = i + 5;
;;;2534   //                    }
;;;2535   //                    verifiedBuff[verifiedIndex++] = resultArray[i];
;;;2536   //                }
;;;2537   //            }
;;;2538   
;;;2539   //            // 返回信息给STS
;;;2540   //            STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_SET_NOT_WRITTEN, TRUE);
;;;2541   //            break;
;;;2542   
;;;2543       // 获取POWER软件信息
;;;2544       case STS_PROTOCOL_CMD_POWER_GET_SOFTWARE_INFO:
;;;2545           POWER_PROTOCOL_SendCmdAck(POWER_PROTOCOL_CMD_GET_SOFTWARE_INFO);
;;;2546           break;
;;;2547   
;;;2548       // POWER-APP2数据擦除
;;;2549       case STS_PROTOCOL_CMD_POWER_UP_APP_ERASE:
;;;2550           powerPacketSize = 0;
;;;2551           POWER_PROTOCOL_TxAddData(POWER_PROTOCOL_CMD_HEAD);
;;;2552           POWER_PROTOCOL_TxAddData(POWER_PROTOCOL_CMD_DEVICE_ADDR);
;;;2553           POWER_PROTOCOL_TxAddData(POWER_PROTOCOL_CMD_ECO_APP2_ERASE);
;;;2554           POWER_PROTOCOL_TxAddData(0);
;;;2555           POWER_PROTOCOL_TxAddFrame();
;;;2556           break;
;;;2557   
;;;2558       // POWER-APP2数据写入
;;;2559       case STS_PROTOCOL_CMD_POWER_UP_APP_WRITE:
;;;2560           lenght = pCmdFrame->buff[STS_PROTOCOL_CMD_LENGTH_INDEX];
;;;2561           addr1 = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA1_INDEX];
;;;2562           addr2 = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA2_INDEX];
;;;2563           addr3 = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA3_INDEX];
;;;2564           addr4 = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA4_INDEX];
;;;2565           writeAddr = (addr1 << 24) | (addr2 << 16) | (addr3 << 8) | (addr4);
;;;2566   
;;;2567           if (currPacketNum != writeAddr)
;;;2568           {
;;;2569               powerPacketSize++;
;;;2570               currPacketNum = writeAddr;
;;;2571           }
;;;2572   
;;;2573           POWER_PROTOCOL_TxAddData(POWER_PROTOCOL_CMD_HEAD);
;;;2574           POWER_PROTOCOL_TxAddData(POWER_PROTOCOL_CMD_DEVICE_ADDR);
;;;2575           POWER_PROTOCOL_TxAddData(POWER_PROTOCOL_CMD_ECO_APP2_WRITE);
;;;2576           POWER_PROTOCOL_TxAddData(lenght);
;;;2577   
;;;2578           for (i = 0; i < lenght; i++)
;;;2579           {
;;;2580               POWER_PROTOCOL_TxAddData(pCmdFrame->buff[3 + i]);
;;;2581           }
;;;2582   
;;;2583           POWER_PROTOCOL_TxAddFrame();
;;;2584           break;
;;;2585   
;;;2586       // POWER-APP数据写入完成
;;;2587       case STS_PROTOCOL_CMD_POWER_UP_APP_WRITE_FINISH:
;;;2588           POWER_PROTOCOL_SendCmdAck(POWER_PROTOCOL_CMD_ECO_APP_WRITE_FINISH);
;;;2589           break;
;;;2590   
;;;2591       // 设置透传DUT通讯参数
;;;2592       case STS_PROTOCOL_CMD_TOOL_SET_TRAN_DUT_COMM_PARAM:
;;;2593           cmdLength = pCmdFrame->buff[STS_PROTOCOL_CMD_LENGTH_INDEX];
;;;2594           baudRate_value = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA2_INDEX];
;;;2595           online_detection_cnt = 0;
;;;2596   
;;;2597           // 设置波特率
;;;2598           switch (baudRate_value)
;;;2599           {
;;;2600           case 0x01:
;;;2601               uart_baudRate = UART_BAUD_RATE_1200;
;;;2602               can_baudRate = CAN_BAUD_RATE_100K;
;;;2603               break;
;;;2604   
;;;2605           case 0x02:
;;;2606               uart_baudRate = UART_BAUD_RATE_2400;
;;;2607               can_baudRate = CAN_BAUD_RATE_125K;
;;;2608               break;
;;;2609   
;;;2610           case 0x03:
;;;2611               uart_baudRate = UART_BAUD_RATE_4800;
;;;2612               can_baudRate = CAN_BAUD_RATE_150K;
;;;2613               break;
;;;2614   
;;;2615           case 0x04:
;;;2616               uart_baudRate = UART_BAUD_RATE_9600;
;;;2617               can_baudRate = CAN_BAUD_RATE_200K;
;;;2618               break;
;;;2619   
;;;2620           case 0x05:
;;;2621               uart_baudRate = UART_BAUD_RATE_14400;
;;;2622               can_baudRate = CAN_BAUD_RATE_250K;
;;;2623               break;
;;;2624   
;;;2625           case 0x06:
;;;2626               uart_baudRate = UART_BAUD_RATE_19200;
;;;2627               can_baudRate = CAN_BAUD_RATE_300K;
;;;2628               break;
;;;2629   
;;;2630           case 0x07:
;;;2631               uart_baudRate = UART_BAUD_RATE_38400;
;;;2632               can_baudRate = CAN_BAUD_RATE_400K;
;;;2633               break;
;;;2634   
;;;2635           case 0x08:
;;;2636               uart_baudRate = UART_BAUD_RATE_43000;
;;;2637               can_baudRate = CAN_BAUD_RATE_500K;
;;;2638               break;
;;;2639   
;;;2640           case 0x09:
;;;2641               uart_baudRate = UART_BAUD_RATE_57600;
;;;2642               can_baudRate = CAN_BAUD_RATE_600K;
;;;2643               break;
;;;2644   
;;;2645           case 0x0A:
;;;2646               uart_baudRate = UART_BAUD_RATE_76800;
;;;2647               can_baudRate = CAN_BAUD_RATE_900K;
;;;2648               break;
;;;2649   
;;;2650           case 0x0B:
;;;2651               uart_baudRate = UART_BAUD_RATE_115200;
;;;2652               break;
;;;2653   
;;;2654           case 0x0C:
;;;2655               uart_baudRate = UART_BAUD_RATE_128000;
;;;2656               break;
;;;2657   
;;;2658           default:
;;;2659               break;
;;;2660           }
;;;2661   
;;;2662           dut_info.uart_baudRate = uart_baudRate;
;;;2663           dut_info.can_baudRate  = can_baudRate;
;;;2664   
;;;2665           // 设置帧类型
;;;2666           frame_Type = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA3_INDEX];
;;;2667   
;;;2668   //            switch (frame_Type)
;;;2669   //            {
;;;2670   //                case 0x01:
;;;2671   //                    dut_info.can = CAN_STANDARD;
;;;2672   //                    break;
;;;2673   
;;;2674   //                case 0x02:
;;;2675   //                    dut_info.can = CAN_EXTENDED;
;;;2676   //                    break;
;;;2677   
;;;2678   //                default:
;;;2679   //                    break;
;;;2680   //            }
;;;2681   
;;;2682           // 设置通讯协议  0:DTA协议   1：小米协议
;;;2683   //           if((3 < cmdLength)&&(pCmdFrame->buff[STS_PROTOCOL_CMD_DATA4_INDEX]))
;;;2684   //           {
;;;2685   //               dut_info.commProt = TRUE;
;;;2686   //           }
;;;2687   //           else
;;;2688   //           {
;;;2689   //               dut_info.commProt = FALSE;
;;;2690   //           }
;;;2691   
;;;2692           // 设置通讯方式并初始化
;;;2693           communication_Type = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA1_INDEX];
;;;2694   
;;;2695   //            // 电源使能、八方高标VLK供电
;;;2696   //           if(4 < cmdLength)
;;;2697   //           {
;;;2698   //                dut_info.VLKFlag = pCmdFrame->buff[STS_PROTOCOL_CMD_DATA5_INDEX];
;;;2699   //                _5VOUT_EN(dut_info.VLKFlag);
;;;2700   //           }
;;;2701   
;;;2702           switch (communication_Type)
;;;2703           {
;;;2704           // 3.3V串口通讯
;;;2705           case 0x01:
;;;2706               CHANGE_Init();
;;;2707               _5V_CHANGE_OFF();
;;;2708               VCCB_EN_ON();
;;;2709               UART_DRIVE_InitSelect(uart_baudRate);        // UART驱动层初始化
;;;2710               UART_PROTOCOL_Init();        // 55升级协议
;;;2711               UART_PROTOCOL4_Init();
;;;2712               dut_info.dutBusType = FALSE;
;;;2713   
;;;2714               // LCD显示
;;;2715               Vertical_Scrolling_Display(dtaUpMsgBuff, 4, 3);
;;;2716   
;;;2717               // 上报执行结果
;;;2718               STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_TOOL_SET_TRAN_DUT_COMM_PARAM, TRUE);
;;;2719   
;;;2720               TIMER_AddTask(TIMER_ID_ONLINE_DETECT,
;;;2721                             3000,
;;;2722                             DutTimeOut,
;;;2723                             0,
;;;2724                             1,
;;;2725                             ACTION_MODE_ADD_TO_QUEUE);
;;;2726               break;
;;;2727   
;;;2728           // 5V串口通讯
;;;2729           case 0x02:
;;;2730               CHANGE_Init();
;;;2731               _5V_CHANGE_ON();
;;;2732               VCCB_EN_ON();
;;;2733               UART_DRIVE_InitSelect(uart_baudRate);        // UART驱动层初始化
;;;2734               dut_info.dutBusType = FALSE;
;;;2735               UART_PROTOCOL4_Init();
;;;2736   
;;;2737               // LCD显示
;;;2738               Vertical_Scrolling_Display(dtaUpMsgBuff, 4, 3);
;;;2739   
;;;2740               // 上报执行结果
;;;2741               STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_TOOL_SET_TRAN_DUT_COMM_PARAM, TRUE);
;;;2742   
;;;2743               TIMER_AddTask(TIMER_ID_ONLINE_DETECT,
;;;2744                             3000,
;;;2745                             DutTimeOut,
;;;2746                             0,
;;;2747                             1,
;;;2748                             ACTION_MODE_ADD_TO_QUEUE);
;;;2749               break;
;;;2750   
;;;2751           // CAN通讯
;;;2752           case 0x03:
;;;2753               CAN_PROTOCOL_TEST_Init(dut_info.can_baudRate);       // CAN驱动层初始化
;;;2754   
;;;2755               CAN_PROTOCOL1_Init();  // 通用配置初始化
;;;2756   
;;;2757               dut_info.dutBusType = TRUE;
;;;2758   
;;;2759               // LCD显示
;;;2760               Vertical_Scrolling_Display(dtaUpMsgBuff, 4, 3);
;;;2761   
;;;2762               // 上报执行结果
;;;2763               STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_TOOL_SET_TRAN_DUT_COMM_PARAM, TRUE);
;;;2764   
;;;2765               TIMER_AddTask(TIMER_ID_ONLINE_DETECT,
;;;2766                             3000,
;;;2767                             DutTimeOut,
;;;2768                             0,
;;;2769                             1,
;;;2770                             ACTION_MODE_ADD_TO_QUEUE);
;;;2771               break;
;;;2772   
;;;2773           default:
;;;2774               break;
;;;2775           }
;;;2776           break;
;;;2777   
;;;2778       // 透传DUT指令控制
;;;2779       case STS_PROTOCOL_CMD_TRAN_DUT_INSTRUCTION_CONTROL:
;;;2780           if (pCmdFrame->buff[STS_PROTOCOL_CMD_DATA1_INDEX])
;;;2781           {
;;;2782               dut_info.passThroughControl = TRUE;
;;;2783           }
;;;2784           else
;;;2785           {
;;;2786               dut_info.passThroughControl = FALSE;
;;;2787           }
;;;2788   
;;;2789           // 上报执行结果
;;;2790           STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_TRAN_DUT_INSTRUCTION_CONTROL, TRUE);
;;;2791           break;
;;;2792   
;;;2793       default:
;;;2794           if (dut_info.dutBusType)
;;;2795           {
;;;2796               CAN_TEST_DRIVE_AddTxArray(0, pCmdFrame->buff, pCmdFrame->length);
;;;2797               testFlag = TRUE;
;;;2798           }
;;;2799           else
;;;2800           {
;;;2801               UART_DRIVE_AddTxArray(0, pCmdFrame->buff, pCmdFrame->length);
;;;2802           }
;;;2803   
;;;2804           // LCD显示
;;;2805           Vertical_Scrolling_Display(volTestMsgBuff, 4, 3);
;;;2806           break;
;;;2807       }
;;;2808   
;;;2809       // 删除命令帧
;;;2810       pCB->rx.head++;
;;;2811       pCB->rx.head %= STS_PROTOCOL_RX_QUEUE_SIZE;
;;;2812   }
00005a  b01d              ADD      sp,sp,#0x74
00005c  e8bd8ff0          POP      {r4-r11,pc}
                  |L8.96|
000060  f894c003          LDRB     r12,[r4,#3]           ;1136
000064  f8df84c4          LDR      r8,|L8.1324|
000068  2701              MOVS     r7,#1                 ;1062
00006a  f8dfb4c4          LDR      r11,|L8.1328|
00006e  f898001a          LDRB     r0,[r8,#0x1a]         ;1211
000072  f8981109          LDRB     r1,[r8,#0x109]        ;1229
000076  f1bc0f1d          CMP      r12,#0x1d             ;1139
00007a  d07c              BEQ      |L8.374|
00007c  dc16              BGT      |L8.172|
00007e  f64f76ff          MOV      r6,#0xffff            ;1594
000082  f04f0a02          MOV      r10,#2                ;1062
000086  f1bc0f1b          CMP      r12,#0x1b             ;1139
00008a  d248              BCS      |L8.286|
00008c  e8dff00c          TBB      [pc,r12]              ;1139
000090  55568647          DCB      0x55,0x56,0x86,0x47
000094  f8f7f6f5          DCB      0xf8,0xf7,0xf6,0xf5
000098  47f447f3          DCB      0x47,0xf4,0x47,0xf3
00009c  f2474747          DCB      0xf2,0x47,0x47,0x47
0000a0  47474747          DCB      0x47,0x47,0x47,0x47
0000a4  f1f0ef47          DCB      0xf1,0xf0,0xef,0x47
0000a8  47eeed00          DCB      0x47,0xee,0xed,0x00
                  |L8.172|
0000ac  f1bc0f35          CMP      r12,#0x35             ;1139
0000b0  d070              BEQ      |L8.404|
0000b2  dc17              BGT      |L8.228|
0000b4  f1bc0f31          CMP      r12,#0x31             ;1139
0000b8  d06d              BEQ      |L8.406|
0000ba  dc09              BGT      |L8.208|
0000bc  f1bc0f1e          CMP      r12,#0x1e             ;1139
0000c0  d06a              BEQ      |L8.408|
0000c2  f1bc0f1f          CMP      r12,#0x1f             ;1139
0000c6  d068              BEQ      |L8.410|
0000c8  f1bc0f30          CMP      r12,#0x30             ;1139
0000cc  d127              BNE      |L8.286|
0000ce  e12a              B        |L8.806|
                  |L8.208|
0000d0  f1bc0f32          CMP      r12,#0x32             ;1139
0000d4  d07e              BEQ      |L8.468|
0000d6  f1bc0f33          CMP      r12,#0x33             ;1139
0000da  d07c              BEQ      |L8.470|
0000dc  f1bc0f34          CMP      r12,#0x34             ;1139
0000e0  d11d              BNE      |L8.286|
0000e2  e027              B        |L8.308|
                  |L8.228|
0000e4  f44f6116          MOV      r1,#0x960             ;1408
0000e8  004a              LSLS     r2,r1,#1              ;1413
0000ea  008b              LSLS     r3,r1,#2              ;1418
0000ec  f44f5e61          MOV      lr,#0x3840            ;1423
0000f0  f1bc0f45          CMP      r12,#0x45             ;1139
0000f4  d070              BEQ      |L8.472|
0000f6  dc09              BGT      |L8.268|
0000f8  f1bc0f36          CMP      r12,#0x36             ;1139
0000fc  d06d              BEQ      |L8.474|
0000fe  f1bc0f37          CMP      r12,#0x37             ;1139
000102  d06b              BEQ      |L8.476|
000104  f1bc0f38          CMP      r12,#0x38             ;1139
000108  d109              BNE      |L8.286|
00010a  e3f4              B        |L8.2294|
                  |L8.268|
00010c  f1bc0f47          CMP      r12,#0x47             ;1139
000110  d070              BEQ      |L8.500|
000112  f1bc0f48          CMP      r12,#0x48             ;1139
000116  d06e              BEQ      |L8.502|
000118  f1bc0fa7          CMP      r12,#0xa7             ;1139
00011c  d06c              BEQ      |L8.504|
                  |L8.286|
00011e  2800              CMP      r0,#0                 ;2794
000120  d06b              BEQ      |L8.506|
000122  f8942098          LDRB     r2,[r4,#0x98]         ;2796
000126  1ca1              ADDS     r1,r4,#2              ;2796
000128  2000              MOVS     r0,#0                 ;2796
00012a  f7fffffe          BL       CAN_TEST_DRIVE_AddTxArray
00012e  f88b7002          STRB     r7,[r11,#2]           ;2797
000132  e3fc              B        |L8.2350|
                  |L8.308|
000134  2014              MOVS     r0,#0x14              ;1147
000136  f7fffffe          BL       TIMER_KillTask
                  |L8.314|
00013a  e273              B        |L8.1572|
00013c  79a0              LDRB     r0,[r4,#6]            ;1154
00013e  f88b0004          STRB     r0,[r11,#4]           ;1154
000142  79e1              LDRB     r1,[r4,#7]            ;1155
000144  f88b1005          STRB     r1,[r11,#5]           ;1155
000148  7962              LDRB     r2,[r4,#5]            ;1158
00014a  07d2              LSLS     r2,r2,#31             ;1158
00014c  d00a              BEQ      |L8.356|
00014e  f7fffffe          BL       SELECT_PROTOCOL_WriteFlag
000152  9700              STR      r7,[sp,#0]            ;1164
000154  2300              MOVS     r3,#0                 ;1164
000156  4af7              LDR      r2,|L8.1332|
000158  f64031b8          MOV      r1,#0xbb8             ;1164
00015c  2012              MOVS     r0,#0x12              ;1164
00015e  9701              STR      r7,[sp,#4]            ;1164
000160  f7fffffe          BL       TIMER_AddTask
                  |L8.356|
000164  7960              LDRB     r0,[r4,#5]            ;1173
000166  0780              LSLS     r0,r0,#30             ;1173
000168  d50d              BPL      |L8.390|
00016a  20a6              MOVS     r0,#0xa6              ;1176
00016c  f7fffffe          BL       SELECT_PROTOCOL_SendCmdAck
000170  9700              STR      r7,[sp,#0]            ;1179
000172  2300              MOVS     r3,#0                 ;1179
000174  e000              B        |L8.376|
                  |L8.374|
000176  e3ea              B        |L8.2382|
                  |L8.376|
000178  4aee              LDR      r2,|L8.1332|
00017a  f64031b8          MOV      r1,#0xbb8             ;1179
00017e  2012              MOVS     r0,#0x12              ;1179
000180  9701              STR      r7,[sp,#4]            ;1179
000182  f7fffffe          BL       TIMER_AddTask
                  |L8.390|
000186  48ea              LDR      r0,|L8.1328|
000188  2200              MOVS     r2,#0                 ;1188
00018a  2104              MOVS     r1,#4                 ;1188
00018c  30c0              ADDS     r0,r0,#0xc0           ;1188
00018e  f7fffffe          BL       Vertical_Scrolling_Display
000192  e7d2              B        |L8.314|
                  |L8.404|
000194  e3f4              B        |L8.2432|
                  |L8.406|
000196  e0f5              B        |L8.900|
                  |L8.408|
000198  e3f3              B        |L8.2434|
                  |L8.410|
00019a  e3f3              B        |L8.2436|
00019c  79a0              LDRB     r0,[r4,#6]            ;1195
00019e  f88b0000          STRB     r0,[r11,#0]           ;1195
0001a2  79e6              LDRB     r6,[r4,#7]            ;1198
0001a4  f1040108          ADD      r1,r4,#8              ;1201
0001a8  48e3              LDR      r0,|L8.1336|
0001aa  f7fffffe          BL       strcpy
0001ae  49e2              LDR      r1,|L8.1336|
0001b0  2000              MOVS     r0,#0                 ;1202
0001b2  5588              STRB     r0,[r1,r6]            ;1202
0001b4  7960              LDRB     r0,[r4,#5]            ;1205
0001b6  07c0              LSLS     r0,r0,#31             ;1205
0001b8  d029              BEQ      |L8.526|
0001ba  f88b7006          STRB     r7,[r11,#6]           ;1208
0001be  f898001a          LDRB     r0,[r8,#0x1a]         ;1211  ; dut_info
0001c2  b328              CBZ      r0,|L8.528|
0001c4  2055              MOVS     r0,#0x55              ;1214
0001c6  f7fffffe          BL       CAN_PROTOCOL_TEST_TxAddData
0001ca  20a8              MOVS     r0,#0xa8              ;1215
0001cc  f7fffffe          BL       CAN_PROTOCOL_TEST_TxAddData
0001d0  1cb0              ADDS     r0,r6,#2              ;1216
0001d2  e004              B        |L8.478|
                  |L8.468|
0001d4  e0e9              B        |L8.938|
                  |L8.470|
0001d6  e110              B        |L8.1018|
                  |L8.472|
0001d8  e141              B        |L8.1118|
                  |L8.474|
0001da  e3fd              B        |L8.2520|
                  |L8.476|
0001dc  e3fd              B        |L8.2522|
                  |L8.478|
0001de  b2c0              UXTB     r0,r0                 ;1216
0001e0  f7fffffe          BL       CAN_PROTOCOL_TEST_TxAddData
0001e4  f89b0000          LDRB     r0,[r11,#0]           ;1217  ; dutverType
0001e8  f7fffffe          BL       CAN_PROTOCOL_TEST_TxAddData
0001ec  4630              MOV      r0,r6                 ;1218
0001ee  f7fffffe          BL       CAN_PROTOCOL_TEST_TxAddData
0001f2  e008              B        |L8.518|
                  |L8.500|
0001f4  e3f2              B        |L8.2524|
                  |L8.502|
0001f6  e3f2              B        |L8.2526|
                  |L8.504|
0001f8  e3f2              B        |L8.2528|
                  |L8.506|
0001fa  e3f2              B        |L8.2530|
                  |L8.508|
0001fc  1960              ADDS     r0,r4,r5              ;1221
0001fe  7a00              LDRB     r0,[r0,#8]            ;1221
000200  f7fffffe          BL       CAN_PROTOCOL_TEST_TxAddData
000204  1c6d              ADDS     r5,r5,#1              ;1219
                  |L8.518|
000206  42b5              CMP      r5,r6                 ;1219
000208  d3f8              BCC      |L8.508|
00020a  f7fffffe          BL       CAN_PROTOCOL_TEST_TxAddFrame
                  |L8.526|
00020e  e070              B        |L8.754|
                  |L8.528|
000210  f8980109          LDRB     r0,[r8,#0x109]        ;1229  ; dut_info
000214  b3a8              CBZ      r0,|L8.642|
000216  f89b0000          LDRB     r0,[r11,#0]           ;1231  ; dutverType
00021a  b120              CBZ      r0,|L8.550|
00021c  2801              CMP      r0,#1                 ;1235
00021e  d005              BEQ      |L8.556|
000220  2802              CMP      r0,#2                 ;1239
000222  d006              BEQ      |L8.562|
000224  e008              B        |L8.568|
                  |L8.550|
000226  f88b7000          STRB     r7,[r11,#0]           ;1233
00022a  e005              B        |L8.568|
                  |L8.556|
00022c  f88ba000          STRB     r10,[r11,#0]          ;1237
000230  e002              B        |L8.568|
                  |L8.562|
000232  2003              MOVS     r0,#3                 ;1241
000234  f88b0000          STRB     r0,[r11,#0]           ;1241
                  |L8.568|
000238  205a              MOVS     r0,#0x5a              ;1244
00023a  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
00023e  2012              MOVS     r0,#0x12              ;1245
000240  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
000244  2083              MOVS     r0,#0x83              ;1246
000246  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
00024a  1cb0              ADDS     r0,r6,#2              ;1247
00024c  b2c0              UXTB     r0,r0                 ;1247
00024e  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
000252  f89b0000          LDRB     r0,[r11,#0]           ;1248  ; dutverType
000256  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
00025a  f89b0000          LDRB     r0,[r11,#0]           ;1250  ; dutverType
00025e  2803              CMP      r0,#3                 ;1250
000260  d010              BEQ      |L8.644|
000262  4630              MOV      r0,r6                 ;1264
000264  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
000268  e023              B        |L8.690|
00026a  e3f9              B        |L8.2656|
00026c  e3f9              B        |L8.2658|
00026e  e3f9              B        |L8.2660|
000270  e3c2              B        |L8.2552|
000272  e2ab              B        |L8.1996|
000274  e3f7              B        |L8.2662|
000276  e1d6              B        |L8.1574|
000278  e3f6              B        |L8.2664|
00027a  e3f6              B        |L8.2666|
00027c  e3f6              B        |L8.2668|
00027e  e3f6              B        |L8.2670|
000280  e264              B        |L8.1868|
                  |L8.642|
000282  e01b              B        |L8.700|
                  |L8.644|
000284  f8d80020          LDR      r0,[r8,#0x20]         ;1252  ; dut_info
000288  f5b04f96          CMP      r0,#0x4b00            ;1252
00028c  d007              BEQ      |L8.670|
00028e  4630              MOV      r0,r6                 ;1258
000290  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
                  |L8.660|
000294  1c70              ADDS     r0,r6,#1              ;1260
000296  b2c0              UXTB     r0,r0                 ;1260
000298  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
00029c  e009              B        |L8.690|
                  |L8.670|
00029e  1c70              ADDS     r0,r6,#1              ;1254
0002a0  b2c0              UXTB     r0,r0                 ;1254
0002a2  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
0002a6  e7f5              B        |L8.660|
                  |L8.680|
0002a8  1960              ADDS     r0,r4,r5              ;1269
0002aa  7a00              LDRB     r0,[r0,#8]            ;1269
0002ac  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
0002b0  1c6d              ADDS     r5,r5,#1              ;1267
                  |L8.690|
0002b2  42b5              CMP      r5,r6                 ;1267
0002b4  d3f8              BCC      |L8.680|
0002b6  f7fffffe          BL       UART_PROTOCOL_XM_TxAddFrame
0002ba  e01a              B        |L8.754|
                  |L8.700|
0002bc  2055              MOVS     r0,#0x55              ;1275
0002be  f7fffffe          BL       DUT_PROTOCOL_TxAddData
0002c2  20a8              MOVS     r0,#0xa8              ;1276
0002c4  f7fffffe          BL       DUT_PROTOCOL_TxAddData
0002c8  1cb0              ADDS     r0,r6,#2              ;1277
0002ca  b2c0              UXTB     r0,r0                 ;1277
0002cc  f7fffffe          BL       DUT_PROTOCOL_TxAddData
0002d0  f89b0000          LDRB     r0,[r11,#0]           ;1278  ; dutverType
0002d4  f7fffffe          BL       DUT_PROTOCOL_TxAddData
0002d8  4630              MOV      r0,r6                 ;1279
0002da  f7fffffe          BL       DUT_PROTOCOL_TxAddData
0002de  e004              B        |L8.746|
                  |L8.736|
0002e0  1960              ADDS     r0,r4,r5              ;1283
0002e2  7a00              LDRB     r0,[r0,#8]            ;1283
0002e4  f7fffffe          BL       DUT_PROTOCOL_TxAddData
0002e8  1c6d              ADDS     r5,r5,#1              ;1281
                  |L8.746|
0002ea  42b5              CMP      r5,r6                 ;1281
0002ec  d3f8              BCC      |L8.736|
0002ee  f7fffffe          BL       DUT_PROTOCOL_TxAddFrame
                  |L8.754|
0002f2  7960              LDRB     r0,[r4,#5]            ;1291
0002f4  0780              LSLS     r0,r0,#30             ;1291
0002f6  d506              BPL      |L8.774|
0002f8  f88b7007          STRB     r7,[r11,#7]           ;1294
0002fc  f89b1000          LDRB     r1,[r11,#0]           ;1297  ; dutverType
000300  20a9              MOVS     r0,#0xa9              ;1297
000302  f7fffffe          BL       SELECT_PROTOCOL_SendCmdParamAck
                  |L8.774|
000306  9700              STR      r7,[sp,#0]            ;1301
000308  2300              MOVS     r3,#0                 ;1301
00030a  4a8c              LDR      r2,|L8.1340|
00030c  f64031b8          MOV      r1,#0xbb8             ;1301
000310  2013              MOVS     r0,#0x13              ;1301
000312  9701              STR      r7,[sp,#4]            ;1301
000314  f7fffffe          BL       TIMER_AddTask
000318  4885              LDR      r0,|L8.1328|
00031a  2201              MOVS     r2,#1                 ;1309
00031c  2104              MOVS     r1,#4                 ;1309
00031e  30c0              ADDS     r0,r0,#0xc0           ;1309
000320  f7fffffe          BL       Vertical_Scrolling_Display
                  |L8.804|
000324  e709              B        |L8.314|
                  |L8.806|
000326  2203              MOVS     r2,#3                 ;1314
000328  f44f11b2          MOV      r1,#0x164000          ;1314
00032c  a81c              ADD      r0,sp,#0x70           ;1314
00032e  f7fffffe          BL       SPI_FLASH_ReadArray
000332  2203              MOVS     r2,#3                 ;1315
000334  4982              LDR      r1,|L8.1344|
000336  a81b              ADD      r0,sp,#0x6c           ;1315
000338  f7fffffe          BL       SPI_FLASH_ReadArray
00033c  2055              MOVS     r0,#0x55              ;1316
00033e  f7fffffe          BL       STS_PROTOCOL_TxAddData
000342  2030              MOVS     r0,#0x30              ;1317
000344  f7fffffe          BL       STS_PROTOCOL_TxAddData
000348  2000              MOVS     r0,#0                 ;1318
00034a  f7fffffe          BL       STS_PROTOCOL_TxAddData
00034e  f89d0070          LDRB     r0,[sp,#0x70]         ;1319
000352  f7fffffe          BL       STS_PROTOCOL_TxAddData
000356  f89d0071          LDRB     r0,[sp,#0x71]         ;1320
00035a  f7fffffe          BL       STS_PROTOCOL_TxAddData
00035e  f89d0072          LDRB     r0,[sp,#0x72]         ;1321
000362  f7fffffe          BL       STS_PROTOCOL_TxAddData
000366  f89d006c          LDRB     r0,[sp,#0x6c]         ;1322
00036a  f7fffffe          BL       STS_PROTOCOL_TxAddData
00036e  f89d006d          LDRB     r0,[sp,#0x6d]         ;1323
000372  f7fffffe          BL       STS_PROTOCOL_TxAddData
000376  f89d006e          LDRB     r0,[sp,#0x6e]         ;1324
00037a  f7fffffe          BL       STS_PROTOCOL_TxAddData
00037e  f7fffffe          BL       STS_PROTOCOL_TxAddFrame
000382  e6da              B        |L8.314|
                  |L8.900|
000384  f44f2180          MOV      r1,#0x40000           ;1330
000388  2000              MOVS     r0,#0                 ;1330
00038a  f7fffffe          BL       SPI_FLASH_EraseRoom
00038e  2000              MOVS     r0,#0                 ;1331
000390  f8cb0010          STR      r0,[r11,#0x10]        ;1331  ; allPacketSize
000394  2101              MOVS     r1,#1                 ;1332
000396  2031              MOVS     r0,#0x31              ;1332
000398  f7fffffe          BL       STS_PROTOCOL_SendCmdParamAck
00039c  4864              LDR      r0,|L8.1328|
00039e  2200              MOVS     r2,#0                 ;1335
0003a0  2104              MOVS     r1,#4                 ;1335
0003a2  3020              ADDS     r0,r0,#0x20           ;1335
0003a4  f7fffffe          BL       Vertical_Scrolling_Display
0003a8  e6c7              B        |L8.314|
                  |L8.938|
0003aa  7920              LDRB     r0,[r4,#4]            ;1342
0003ac  1f00              SUBS     r0,r0,#4              ;1342
0003ae  b2c2              UXTB     r2,r0                 ;1342
0003b0  7961              LDRB     r1,[r4,#5]            ;1343
0003b2  79a3              LDRB     r3,[r4,#6]            ;1344
0003b4  79e5              LDRB     r5,[r4,#7]            ;1345
0003b6  7a20              LDRB     r0,[r4,#8]            ;1346
0003b8  0609              LSLS     r1,r1,#24             ;1347
0003ba  ea414103          ORR      r1,r1,r3,LSL #16      ;1347
0003be  ea412105          ORR      r1,r1,r5,LSL #8       ;1347
0003c2  4301              ORRS     r1,r1,r0              ;1347
0003c4  f1040009          ADD      r0,r4,#9              ;1348
0003c8  f7fffffe          BL       SPI_FLASH_WriteWithCheck
0003cc  2101              MOVS     r1,#1                 ;1351
0003ce  2032              MOVS     r0,#0x32              ;1351
0003d0  f7fffffe          BL       STS_PROTOCOL_SendCmdParamAck
0003d4  f8db0010          LDR      r0,[r11,#0x10]        ;1352  ; allPacketSize
0003d8  1c40              ADDS     r0,r0,#1              ;1352
0003da  f8cb0010          STR      r0,[r11,#0x10]        ;1352  ; allPacketSize
0003de  f89b0001          LDRB     r0,[r11,#1]           ;1354  ; showFlag
0003e2  2800              CMP      r0,#0                 ;1354
0003e4  d09e              BEQ      |L8.804|
0003e6  4852              LDR      r0,|L8.1328|
0003e8  2201              MOVS     r2,#1                 ;1357
0003ea  2104              MOVS     r1,#4                 ;1357
0003ec  3020              ADDS     r0,r0,#0x20           ;1357
0003ee  f7fffffe          BL       Vertical_Scrolling_Display
0003f2  2000              MOVS     r0,#0                 ;1358
0003f4  f88b0001          STRB     r0,[r11,#1]           ;1358
0003f8  e69f              B        |L8.314|
                  |L8.1018|
0003fa  f8db0010          LDR      r0,[r11,#0x10]        ;1367  ; allPacketSize
0003fe  494c              LDR      r1,|L8.1328|
000400  0e02              LSRS     r2,r0,#24             ;1367
000402  3114              ADDS     r1,r1,#0x14           ;1367
000404  700a              STRB     r2,[r1,#0]            ;1367
000406  0c02              LSRS     r2,r0,#16             ;1368
000408  704a              STRB     r2,[r1,#1]            ;1368
00040a  0a02              LSRS     r2,r0,#8              ;1369
00040c  708a              STRB     r2,[r1,#2]            ;1369
00040e  70c8              STRB     r0,[r1,#3]            ;1370
000410  4d4c              LDR      r5,|L8.1348|
000412  4628              MOV      r0,r5                 ;1372
000414  f7fffffe          BL       SPI_FLASH_EraseSector
000418  f44f14b1          MOV      r4,#0x162000          ;1373
00041c  4620              MOV      r0,r4                 ;1373
00041e  f7fffffe          BL       SPI_FLASH_EraseSector
000422  21aa              MOVS     r1,#0xaa              ;1375
000424  4628              MOV      r0,r5                 ;1375
000426  f7fffffe          BL       SPI_FLASH_WriteByte
00042a  4841              LDR      r0,|L8.1328|
00042c  2204              MOVS     r2,#4                 ;1376
00042e  4621              MOV      r1,r4                 ;1376
000430  3014              ADDS     r0,r0,#0x14           ;1376
000432  f7fffffe          BL       SPI_FLASH_WriteArray
000436  2033              MOVS     r0,#0x33              ;1378
000438  f7fffffe          BL       STS_PROTOCOL_SendCmdAck
00043c  9700              STR      r7,[sp,#0]            ;1381
00043e  03eb              LSLS     r3,r5,#15             ;1381
000440  4a41              LDR      r2,|L8.1352|
000442  2164              MOVS     r1,#0x64              ;1381
000444  2001              MOVS     r0,#1                 ;1381
000446  9701              STR      r7,[sp,#4]            ;1381
000448  f7fffffe          BL       TIMER_AddTask
00044c  4838              LDR      r0,|L8.1328|
00044e  2202              MOVS     r2,#2                 ;1389
000450  2104              MOVS     r1,#4                 ;1389
000452  3020              ADDS     r0,r0,#0x20           ;1389
000454  f7fffffe          BL       Vertical_Scrolling_Display
000458  f88b7001          STRB     r7,[r11,#1]           ;1390
00045c  e66d              B        |L8.314|
                  |L8.1118|
00045e  7920              LDRB     r0,[r4,#4]            ;1395
000460  f894c006          LDRB     r12,[r4,#6]           ;1396
000464  f8dfb0e4          LDR      r11,|L8.1356|
000468  2500              MOVS     r5,#0                 ;1397
00046a  f8cb5000          STR      r5,[r11,#0]           ;1397  ; online_detection_cnt
00046e  f1bc0f0d          CMP      r12,#0xd              ;1400
000472  d23b              BCS      |L8.1260|
000474  e8dff00c          TBB      [pc,r12]              ;1400
000478  3a070c10          DCB      0x3a,0x07,0x0c,0x10
00047c  14181c21          DCB      0x14,0x18,0x1c,0x21
000480  262b3035          DCB      0x26,0x2b,0x30,0x35
000484  3800              DCB      0x38,0x00
000486  f44f6696          MOV      r6,#0x4b0             ;1403
00048a  f04f0a64          MOV      r10,#0x64             ;1404
00048e  e02d              B        |L8.1260|
000490  460e              MOV      r6,r1                 ;1408
000492  f04f0a7d          MOV      r10,#0x7d             ;1409
000496  e029              B        |L8.1260|
000498  4616              MOV      r6,r2                 ;1413
00049a  f04f0a96          MOV      r10,#0x96             ;1414
00049e  e025              B        |L8.1260|
0004a0  461e              MOV      r6,r3                 ;1418
0004a2  f04f0ac8          MOV      r10,#0xc8             ;1419
0004a6  e021              B        |L8.1260|
0004a8  4676              MOV      r6,lr                 ;1423
0004aa  f04f0afa          MOV      r10,#0xfa             ;1424
0004ae  e01d              B        |L8.1260|
0004b0  f44f4696          MOV      r6,#0x4b00            ;1428
0004b4  f44f7a96          MOV      r10,#0x12c            ;1429
0004b8  e018              B        |L8.1260|
0004ba  f44f4616          MOV      r6,#0x9600            ;1433
0004be  f44f7ac8          MOV      r10,#0x190            ;1434
0004c2  e013              B        |L8.1260|
0004c4  f24a76f8          MOV      r6,#0xa7f8            ;1438
0004c8  f44f7afa          MOV      r10,#0x1f4            ;1439
0004cc  e00e              B        |L8.1260|
0004ce  f44f4661          MOV      r6,#0xe100            ;1443
0004d2  f44f7a16          MOV      r10,#0x258            ;1444
0004d6  e009              B        |L8.1260|
0004d8  f44f3696          MOV      r6,#0x12c00           ;1448
0004dc  f44f7a61          MOV      r10,#0x384            ;1449
0004e0  e004              B        |L8.1260|
0004e2  f44f36e1          MOV      r6,#0x1c200           ;1453
0004e6  e001              B        |L8.1260|
0004e8  f44f36fa          MOV      r6,#0x1f400           ;1457
                  |L8.1260|
0004ec  f8c86020          STR      r6,[r8,#0x20]         ;1464  ; dut_info
0004f0  f8a8a01c          STRH     r10,[r8,#0x1c]        ;1465
0004f4  2803              CMP      r0,#3                 ;1485
0004f6  d904              BLS      |L8.1282|
0004f8  7a21              LDRB     r1,[r4,#8]            ;1485
0004fa  b111              CBZ      r1,|L8.1282|
0004fc  f8887109          STRB     r7,[r8,#0x109]        ;1487
000500  e001              B        |L8.1286|
                  |L8.1282|
000502  f8885109          STRB     r5,[r8,#0x109]        ;1491
                  |L8.1286|
000506  f894a005          LDRB     r10,[r4,#5]           ;1495
00050a  2804              CMP      r0,#4                 ;1498
00050c  d904              BLS      |L8.1304|
00050e  7a60              LDRB     r0,[r4,#9]            ;1500
000510  f888010b          STRB     r0,[r8,#0x10b]        ;1500
000514  f7fffffe          BL       _5VOUT_EN
                  |L8.1304|
000518  f1ba0f01          CMP      r10,#1                ;1504
00051c  d018              BEQ      |L8.1360|
00051e  f1ba0f02          CMP      r10,#2                ;1504
000522  d03d              BEQ      |L8.1440|
000524  f1ba0f03          CMP      r10,#3                ;1504
000528  d17a              BNE      |L8.1568|
00052a  e061              B        |L8.1520|
                  |L8.1324|
                          DCD      dut_info
                  |L8.1328|
                          DCD      ||.data||
                  |L8.1332|
                          DCD      WriteFlagTimeOut
                  |L8.1336|
                          DCD      ||.bss||
                  |L8.1340|
                          DCD      OperateVerTimeOut
                  |L8.1344|
                          DCD      0x00165000
                  |L8.1348|
                          DCD      0x00161000
                  |L8.1352|
                          DCD      IAP_JumpToAppFun
                  |L8.1356|
                          DCD      online_detection_cnt
                  |L8.1360|
000550  f7fffffe          BL       CHANGE_Init
000554  4cfe              LDR      r4,|L8.2384|
000556  f44f7180          MOV      r1,#0x100             ;1509
00055a  4620              MOV      r0,r4                 ;1509
00055c  f7fffffe          BL       gpio_bit_reset
000560  1561              ASRS     r1,r4,#21             ;1510
000562  4620              MOV      r0,r4                 ;1510
000564  f7fffffe          BL       gpio_bit_set
000568  4630              MOV      r0,r6                 ;1511
00056a  f7fffffe          BL       UART_DRIVE_InitSelect
00056e  f7fffffe          BL       DUT_PROTOCOL_Init
000572  f7fffffe          BL       UART_PROTOCOL_XM_Init
000576  f888501a          STRB     r5,[r8,#0x1a]         ;1514
00057a  2203              MOVS     r2,#3                 ;1517
00057c  2104              MOVS     r1,#4                 ;1517
00057e  48f5              LDR      r0,|L8.2388|
000580  f7fffffe          BL       Vertical_Scrolling_Display
000584  2101              MOVS     r1,#1                 ;1520
000586  2045              MOVS     r0,#0x45              ;1520
000588  f7fffffe          BL       STS_PROTOCOL_SendCmdParamAck
00058c  9700              STR      r7,[sp,#0]            ;1522
00058e  2300              MOVS     r3,#0                 ;1522
000590  4af1              LDR      r2,|L8.2392|
000592  f64031b8          MOV      r1,#0xbb8             ;1522
000596  2011              MOVS     r0,#0x11              ;1522
000598  9701              STR      r7,[sp,#4]            ;1522
00059a  f7fffffe          BL       TIMER_AddTask
00059e  e03f              B        |L8.1568|
                  |L8.1440|
0005a0  f7fffffe          BL       CHANGE_Init
0005a4  4cea              LDR      r4,|L8.2384|
0005a6  f44f7180          MOV      r1,#0x100             ;1533
0005aa  4620              MOV      r0,r4                 ;1533
0005ac  f7fffffe          BL       gpio_bit_set
0005b0  1561              ASRS     r1,r4,#21             ;1534
0005b2  4620              MOV      r0,r4                 ;1534
0005b4  f7fffffe          BL       gpio_bit_set
0005b8  4630              MOV      r0,r6                 ;1535
0005ba  f7fffffe          BL       UART_DRIVE_InitSelect
0005be  f7fffffe          BL       DUT_PROTOCOL_Init
0005c2  f7fffffe          BL       UART_PROTOCOL_XM_Init
0005c6  f888501a          STRB     r5,[r8,#0x1a]         ;1538
0005ca  2203              MOVS     r2,#3                 ;1541
0005cc  2104              MOVS     r1,#4                 ;1541
0005ce  48e1              LDR      r0,|L8.2388|
0005d0  f7fffffe          BL       Vertical_Scrolling_Display
0005d4  2101              MOVS     r1,#1                 ;1544
0005d6  2045              MOVS     r0,#0x45              ;1544
0005d8  f7fffffe          BL       STS_PROTOCOL_SendCmdParamAck
0005dc  9700              STR      r7,[sp,#0]            ;1546
0005de  2300              MOVS     r3,#0                 ;1546
0005e0  4add              LDR      r2,|L8.2392|
0005e2  f64031b8          MOV      r1,#0xbb8             ;1546
0005e6  2011              MOVS     r0,#0x11              ;1546
0005e8  9701              STR      r7,[sp,#4]            ;1546
0005ea  f7fffffe          BL       TIMER_AddTask
0005ee  e017              B        |L8.1568|
                  |L8.1520|
0005f0  f8b8001c          LDRH     r0,[r8,#0x1c]         ;1556  ; dut_info
0005f4  f7fffffe          BL       CAN_PROTOCOL_TEST_Init
0005f8  f888701a          STRB     r7,[r8,#0x1a]         ;1557
0005fc  2203              MOVS     r2,#3                 ;1560
0005fe  2104              MOVS     r1,#4                 ;1560
000600  48d4              LDR      r0,|L8.2388|
000602  f7fffffe          BL       Vertical_Scrolling_Display
000606  2101              MOVS     r1,#1                 ;1563
000608  2045              MOVS     r0,#0x45              ;1563
00060a  f7fffffe          BL       STS_PROTOCOL_SendCmdParamAck
00060e  9700              STR      r7,[sp,#0]            ;1565
000610  2300              MOVS     r3,#0                 ;1565
000612  4ad1              LDR      r2,|L8.2392|
000614  f64031b8          MOV      r1,#0xbb8             ;1565
000618  2011              MOVS     r0,#0x11              ;1565
00061a  9701              STR      r7,[sp,#4]            ;1565
00061c  f7fffffe          BL       TIMER_AddTask
                  |L8.1568|
000620  f8885120          STRB     r5,[r8,#0x120]        ;1576
                  |L8.1572|
000624  e091              B        |L8.1866|
                  |L8.1574|
000626  7965              LDRB     r5,[r4,#5]            ;1580
000628  f88b7002          STRB     r7,[r11,#2]           ;1581
00062c  79a0              LDRB     r0,[r4,#6]            ;1584
00062e  0202              LSLS     r2,r0,#8              ;1585
000630  79e0              LDRB     r0,[r4,#7]            ;1586
000632  4310              ORRS     r0,r0,r2              ;1586
000634  0202              LSLS     r2,r0,#8              ;1587
000636  7a20              LDRB     r0,[r4,#8]            ;1588
000638  4310              ORRS     r0,r0,r2              ;1588
00063a  0202              LSLS     r2,r0,#8              ;1589
00063c  7a60              LDRB     r0,[r4,#9]            ;1590
00063e  4310              ORRS     r0,r0,r2              ;1590
000640  7aa2              LDRB     r2,[r4,#0xa]          ;1593
000642  ea062302          AND      r3,r6,r2,LSL #8       ;1594
000646  7ae2              LDRB     r2,[r4,#0xb]          ;1595
000648  431a              ORRS     r2,r2,r3              ;1595
00064a  1883              ADDS     r3,r0,r2              ;1598
00064c  f8c83034          STR      r3,[r8,#0x34]         ;1598  ; dut_info
000650  1a80              SUBS     r0,r0,r2              ;1599
000652  f8c80038          STR      r0,[r8,#0x38]         ;1599  ; dut_info
000656  07e8              LSLS     r0,r5,#31             ;1602
000658  d00b              BEQ      |L8.1650|
00065a  b129              CBZ      r1,|L8.1640|
00065c  2010              MOVS     r0,#0x10              ;1606
00065e  f8880017          STRB     r0,[r8,#0x17]         ;1606
000662  f7fffffe          BL       enterState
000666  e004              B        |L8.1650|
                  |L8.1640|
000668  2003              MOVS     r0,#3                 ;1611
00066a  f8880017          STRB     r0,[r8,#0x17]         ;1611
00066e  f7fffffe          BL       enterState
                  |L8.1650|
000672  07a8              LSLS     r0,r5,#30             ;1618
000674  d50d              BPL      |L8.1682|
000676  f8980109          LDRB     r0,[r8,#0x109]        ;1620  ; dut_info
00067a  b128              CBZ      r0,|L8.1672|
00067c  2011              MOVS     r0,#0x11              ;1622
00067e  f8880017          STRB     r0,[r8,#0x17]         ;1622
000682  f7fffffe          BL       enterState
000686  e004              B        |L8.1682|
                  |L8.1672|
000688  2006              MOVS     r0,#6                 ;1627
00068a  f8880017          STRB     r0,[r8,#0x17]         ;1627
00068e  f7fffffe          BL       enterState
                  |L8.1682|
000692  43ec              MVNS     r4,r5                 ;1633
000694  07a0              LSLS     r0,r4,#30             ;1633
000696  d10d              BNE      |L8.1716|
000698  f8980109          LDRB     r0,[r8,#0x109]        ;1635  ; dut_info
00069c  b128              CBZ      r0,|L8.1706|
00069e  2012              MOVS     r0,#0x12              ;1637
0006a0  f8880017          STRB     r0,[r8,#0x17]         ;1637
0006a4  f7fffffe          BL       enterState
0006a8  e004              B        |L8.1716|
                  |L8.1706|
0006aa  2007              MOVS     r0,#7                 ;1642
0006ac  f8880017          STRB     r0,[r8,#0x17]         ;1642
0006b0  f7fffffe          BL       enterState
                  |L8.1716|
0006b4  0768              LSLS     r0,r5,#29             ;1648
0006b6  d504              BPL      |L8.1730|
0006b8  2004              MOVS     r0,#4                 ;1650
0006ba  f8880017          STRB     r0,[r8,#0x17]         ;1650
0006be  f7fffffe          BL       enterState
                  |L8.1730|
0006c2  2005              MOVS     r0,#5                 ;1655
0006c4  ea300105          BICS     r1,r0,r5              ;1655
0006c8  d103              BNE      |L8.1746|
0006ca  f8880017          STRB     r0,[r8,#0x17]         ;1657
0006ce  f7fffffe          BL       enterState
                  |L8.1746|
0006d2  f3c50041          UBFX     r0,r5,#1,#2           ;1662
0006d6  2803              CMP      r0,#3                 ;1662
0006d8  d10d              BNE      |L8.1782|
0006da  f8980109          LDRB     r0,[r8,#0x109]        ;1664  ; dut_info
0006de  b128              CBZ      r0,|L8.1772|
0006e0  2013              MOVS     r0,#0x13              ;1666
0006e2  f8880017          STRB     r0,[r8,#0x17]         ;1666
0006e6  f7fffffe          BL       enterState
0006ea  e004              B        |L8.1782|
                  |L8.1772|
0006ec  2008              MOVS     r0,#8                 ;1671
0006ee  f8880017          STRB     r0,[r8,#0x17]         ;1671
0006f2  f7fffffe          BL       enterState
                  |L8.1782|
0006f6  0760              LSLS     r0,r4,#29             ;1677
0006f8  f04f0409          MOV      r4,#9                 ;1062
0006fc  d10c              BNE      |L8.1816|
0006fe  f8980109          LDRB     r0,[r8,#0x109]        ;1679  ; dut_info
000702  b128              CBZ      r0,|L8.1808|
000704  2014              MOVS     r0,#0x14              ;1681
000706  f8880017          STRB     r0,[r8,#0x17]         ;1681
00070a  f7fffffe          BL       enterState
00070e  e003              B        |L8.1816|
                  |L8.1808|
000710  f8884017          STRB     r4,[r8,#0x17]         ;1686
000714  f7fffffe          BL       enterState
                  |L8.1816|
000718  0728              LSLS     r0,r5,#28             ;1692
00071a  d509              BPL      |L8.1840|
00071c  200d              MOVS     r0,#0xd               ;1694
00071e  f8880017          STRB     r0,[r8,#0x17]         ;1694
000722  f7fffffe          BL       enterState
000726  2202              MOVS     r2,#2                 ;1698
000728  2104              MOVS     r1,#4                 ;1698
00072a  488c              LDR      r0,|L8.2396|
00072c  f7fffffe          BL       Vertical_Scrolling_Display
                  |L8.1840|
000730  43ac              BICS     r4,r4,r5              ;1702
000732  d10a              BNE      |L8.1866|
000734  200a              MOVS     r0,#0xa               ;1704
000736  f8880017          STRB     r0,[r8,#0x17]         ;1704
00073a  f7fffffe          BL       enterState
00073e  4887              LDR      r0,|L8.2396|
000740  2200              MOVS     r2,#0                 ;1708
000742  2104              MOVS     r1,#4                 ;1708
000744  3050              ADDS     r0,r0,#0x50           ;1708
000746  f7fffffe          BL       Vertical_Scrolling_Display
                  |L8.1866|
00074a  e144              B        |L8.2518|
                  |L8.1868|
00074c  7960              LDRB     r0,[r4,#5]            ;1716
00074e  2805              CMP      r0,#5                 ;1716
000750  d109              BNE      |L8.1894|
000752  79a0              LDRB     r0,[r4,#6]            ;1718
000754  f888002f          STRB     r0,[r8,#0x2f]         ;1718
000758  f888a017          STRB     r10,[r8,#0x17]        ;1719
00075c  2005              MOVS     r0,#5                 ;1720
00075e  f8880018          STRB     r0,[r8,#0x18]         ;1720
000762  f7fffffe          BL       enterState
                  |L8.1894|
000766  7960              LDRB     r0,[r4,#5]            ;1725
000768  2804              CMP      r0,#4                 ;1725
00076a  d109              BNE      |L8.1920|
00076c  79a0              LDRB     r0,[r4,#6]            ;1727
00076e  f888002f          STRB     r0,[r8,#0x2f]         ;1727
000772  f888a017          STRB     r10,[r8,#0x17]        ;1728
000776  2004              MOVS     r0,#4                 ;1729
000778  f8880018          STRB     r0,[r8,#0x18]         ;1729
00077c  f7fffffe          BL       enterState
                  |L8.1920|
000780  7960              LDRB     r0,[r4,#5]            ;1734
000782  2803              CMP      r0,#3                 ;1734
000784  d109              BNE      |L8.1946|
000786  79a0              LDRB     r0,[r4,#6]            ;1736
000788  f888002f          STRB     r0,[r8,#0x2f]         ;1736
00078c  f888a017          STRB     r10,[r8,#0x17]        ;1737
000790  2003              MOVS     r0,#3                 ;1738
000792  f8880018          STRB     r0,[r8,#0x18]         ;1738
000796  f7fffffe          BL       enterState
                  |L8.1946|
00079a  7960              LDRB     r0,[r4,#5]            ;1743
00079c  2802              CMP      r0,#2                 ;1743
00079e  d108              BNE      |L8.1970|
0007a0  79a0              LDRB     r0,[r4,#6]            ;1745
0007a2  f888002f          STRB     r0,[r8,#0x2f]         ;1745
0007a6  f888a017          STRB     r10,[r8,#0x17]        ;1746
0007aa  f888a018          STRB     r10,[r8,#0x18]        ;1747
0007ae  f7fffffe          BL       enterState
                  |L8.1970|
0007b2  7960              LDRB     r0,[r4,#5]            ;1752
0007b4  2801              CMP      r0,#1                 ;1752
0007b6  d1c8              BNE      |L8.1866|
0007b8  79a0              LDRB     r0,[r4,#6]            ;1754
0007ba  f888002f          STRB     r0,[r8,#0x2f]         ;1754
0007be  f888a017          STRB     r10,[r8,#0x17]        ;1755
0007c2  f8887018          STRB     r7,[r8,#0x18]         ;1756
0007c6  f7fffffe          BL       enterState
0007ca  e104              B        |L8.2518|
                  |L8.1996|
0007cc  4863              LDR      r0,|L8.2396|
0007ce  2203              MOVS     r2,#3                 ;1767
0007d0  2104              MOVS     r1,#4                 ;1767
0007d2  3850              SUBS     r0,r0,#0x50           ;1767
0007d4  f7fffffe          BL       Vertical_Scrolling_Display
0007d8  7960              LDRB     r0,[r4,#5]            ;1770
0007da  ea062000          AND      r0,r6,r0,LSL #8       ;1771
0007de  79a5              LDRB     r5,[r4,#6]            ;1772
0007e0  4305              ORRS     r5,r5,r0              ;1772
0007e2  79e0              LDRB     r0,[r4,#7]            ;1775
0007e4  ea062000          AND      r0,r6,r0,LSL #8       ;1776
0007e8  7a27              LDRB     r7,[r4,#8]            ;1777
0007ea  4307              ORRS     r7,r7,r0              ;1777
0007ec  f8948009          LDRB     r8,[r4,#9]            ;1780
0007f0  7aa0              LDRB     r0,[r4,#0xa]          ;1783
0007f2  ea062000          AND      r0,r6,r0,LSL #8       ;1784
0007f6  7ae4              LDRB     r4,[r4,#0xb]          ;1785
0007f8  4304              ORRS     r4,r4,r0              ;1785
0007fa  4e59              LDR      r6,|L8.2400|
0007fc  f1b80f00          CMP      r8,#0                 ;1789
000800  d13f              BNE      |L8.2178|
000802  2110              MOVS     r1,#0x10              ;1792
000804  4630              MOV      r0,r6                 ;1792
000806  f7fffffe          BL       gpio_bit_reset
00080a  2140              MOVS     r1,#0x40              ;1793
00080c  4630              MOV      r0,r6                 ;1793
00080e  f7fffffe          BL       gpio_bit_reset
000812  2320              MOVS     r3,#0x20              ;1794
000814  2203              MOVS     r2,#3                 ;1794
000816  2110              MOVS     r1,#0x10              ;1794
000818  4630              MOV      r0,r6                 ;1794
00081a  f7fffffe          BL       gpio_init
00081e  2120              MOVS     r1,#0x20              ;1794
000820  4630              MOV      r0,r6                 ;1794
000822  f7fffffe          BL       gpio_bit_set
000826  f44f70c8          MOV      r0,#0x190             ;1795
00082a  f7fffffe          BL       Delayms
00082e  f7fffffe          BL       USB_ADC_Read
000832  1be9              SUBS     r1,r5,r7              ;1802
000834  4281              CMP      r1,r0                 ;1802
000836  da20              BGE      |L8.2170|
000838  19e9              ADDS     r1,r5,r7              ;1802
00083a  4281              CMP      r1,r0                 ;1802
00083c  d91d              BLS      |L8.2170|
00083e  f7fffffe          BL       USB_CURRENT_Read
000842  f5c471fa          RSB      r1,r4,#0x1f4          ;1809
000846  4281              CMP      r1,r0                 ;1809
000848  da12              BGE      |L8.2160|
00084a  f50471fa          ADD      r1,r4,#0x1f4          ;1809
00084e  4288              CMP      r0,r1                 ;1809
000850  d20e              BCS      |L8.2160|
000852  f7fffffe          BL       Clear_All_Lines
000856  a143              ADR      r1,|L8.2404|
000858  2000              MOVS     r0,#0                 ;1813
00085a  f7fffffe          BL       Display_Centered
00085e  a145              ADR      r1,|L8.2420|
000860  2001              MOVS     r0,#1                 ;1814
000862  f7fffffe          BL       Display_Centered
000866  2101              MOVS     r1,#1                 ;1815
000868  2014              MOVS     r0,#0x14              ;1815
00086a  f7fffffe          BL       STS_PROTOCOL_SendCmdParamAck
00086e  e008              B        |L8.2178|
                  |L8.2160|
000870  2100              MOVS     r1,#0                 ;1820
000872  2014              MOVS     r0,#0x14              ;1820
000874  f7fffffe          BL       STS_PROTOCOL_SendCmdParamAck
000878  e003              B        |L8.2178|
                  |L8.2170|
00087a  2100              MOVS     r1,#0                 ;1826
00087c  2014              MOVS     r0,#0x14              ;1826
00087e  f7fffffe          BL       STS_PROTOCOL_SendCmdParamAck
                  |L8.2178|
000882  ea5f70c8          LSLS     r0,r8,#31             ;1831
000886  d040              BEQ      |L8.2314|
000888  2310              MOVS     r3,#0x10              ;1834
00088a  2203              MOVS     r2,#3                 ;1834
00088c  4619              MOV      r1,r3                 ;1834
00088e  4630              MOV      r0,r6                 ;1834
000890  f7fffffe          BL       gpio_init
000894  2110              MOVS     r1,#0x10              ;1834
000896  4630              MOV      r0,r6                 ;1834
000898  f7fffffe          BL       gpio_bit_set
00089c  2120              MOVS     r1,#0x20              ;1835
00089e  4630              MOV      r0,r6                 ;1835
0008a0  f7fffffe          BL       gpio_bit_reset
0008a4  2140              MOVS     r1,#0x40              ;1836
0008a6  4630              MOV      r0,r6                 ;1836
0008a8  f7fffffe          BL       gpio_bit_reset
0008ac  f44f70c8          MOV      r0,#0x190             ;1837
0008b0  f7fffffe          BL       Delayms
0008b4  f7fffffe          BL       USB_ADC_Read
0008b8  1be9              SUBS     r1,r5,r7              ;1843
0008ba  4281              CMP      r1,r0                 ;1843
0008bc  da21              BGE      |L8.2306|
0008be  19e9              ADDS     r1,r5,r7              ;1843
0008c0  4281              CMP      r1,r0                 ;1843
0008c2  d91e              BLS      |L8.2306|
0008c4  f7fffffe          BL       USB_CURRENT_Read
0008c8  f5c4717a          RSB      r1,r4,#0x3e8          ;1849
0008cc  4281              CMP      r1,r0                 ;1849
0008ce  da13              BGE      |L8.2296|
0008d0  f504717a          ADD      r1,r4,#0x3e8          ;1849
0008d4  4288              CMP      r0,r1                 ;1849
0008d6  d20f              BCS      |L8.2296|
0008d8  f7fffffe          BL       Clear_All_Lines
0008dc  a121              ADR      r1,|L8.2404|
0008de  2000              MOVS     r0,#0                 ;1852
0008e0  f7fffffe          BL       Display_Centered
0008e4  a123              ADR      r1,|L8.2420|
0008e6  2001              MOVS     r0,#1                 ;1853
0008e8  f7fffffe          BL       Display_Centered
0008ec  2101              MOVS     r1,#1                 ;1856
0008ee  2014              MOVS     r0,#0x14              ;1856
0008f0  f7fffffe          BL       STS_PROTOCOL_SendCmdParamAck
0008f4  e009              B        |L8.2314|
                  |L8.2294|
0008f6  e2fa              B        |L8.3822|
                  |L8.2296|
0008f8  2100              MOVS     r1,#0                 ;1860
0008fa  2014              MOVS     r0,#0x14              ;1860
0008fc  f7fffffe          BL       STS_PROTOCOL_SendCmdParamAck
000900  e003              B        |L8.2314|
                  |L8.2306|
000902  2100              MOVS     r1,#0                 ;1865
000904  2014              MOVS     r0,#0x14              ;1865
000906  f7fffffe          BL       STS_PROTOCOL_SendCmdParamAck
                  |L8.2314|
00090a  ea5f7088          LSLS     r0,r8,#30             ;1871
00090e  d562              BPL      |L8.2518|
000910  2310              MOVS     r3,#0x10              ;1874
000912  2203              MOVS     r2,#3                 ;1874
000914  4619              MOV      r1,r3                 ;1874
000916  4630              MOV      r0,r6                 ;1874
000918  f7fffffe          BL       gpio_init
00091c  2110              MOVS     r1,#0x10              ;1874
00091e  4630              MOV      r0,r6                 ;1874
000920  f7fffffe          BL       gpio_bit_set
000924  2320              MOVS     r3,#0x20              ;1875
000926  2203              MOVS     r2,#3                 ;1875
000928  2110              MOVS     r1,#0x10              ;1875
00092a  4630              MOV      r0,r6                 ;1875
00092c  e000              B        |L8.2352|
                  |L8.2350|
00092e  e3ad              B        |L8.4236|
                  |L8.2352|
000930  f7fffffe          BL       gpio_init
000934  2120              MOVS     r1,#0x20              ;1875
000936  4630              MOV      r0,r6                 ;1875
000938  f7fffffe          BL       gpio_bit_set
00093c  2340              MOVS     r3,#0x40              ;1876
00093e  2203              MOVS     r2,#3                 ;1876
000940  2110              MOVS     r1,#0x10              ;1876
000942  4630              MOV      r0,r6                 ;1876
000944  f7fffffe          BL       gpio_init
000948  2140              MOVS     r1,#0x40              ;1876
00094a  4630              MOV      r0,r6                 ;1876
00094c  e01b              B        |L8.2438|
                  |L8.2382|
00094e  e0de              B        |L8.2830|
                  |L8.2384|
                          DCD      0x40011000
                  |L8.2388|
                          DCD      ||.data||+0x20
                  |L8.2392|
                          DCD      DutTimeOut
                  |L8.2396|
                          DCD      ||.data||+0x160
                  |L8.2400|
                          DCD      0x40011800
                  |L8.2404|
000964  55534220          DCB      "USB Charging ",0
000968  43686172
00096c  67696e67
000970  2000    
000972  00                DCB      0
000973  00                DCB      0
                  |L8.2420|
000974  54657374          DCB      "Test Pass",0
000978  20506173
00097c  7300    
00097e  00                DCB      0
00097f  00                DCB      0
                  |L8.2432|
000980  e272              B        |L8.3688|
                  |L8.2434|
000982  e169              B        |L8.3160|
                  |L8.2436|
000984  e26c              B        |L8.3680|
                  |L8.2438|
000986  f7fffffe          BL       gpio_bit_set
00098a  f44f70c8          MOV      r0,#0x190             ;1877
00098e  f7fffffe          BL       Delayms
000992  f7fffffe          BL       USB_ADC_Read
000996  1be9              SUBS     r1,r5,r7              ;1882
000998  4281              CMP      r1,r0                 ;1882
00099a  da28              BGE      |L8.2542|
00099c  19e9              ADDS     r1,r5,r7              ;1882
00099e  4281              CMP      r1,r0                 ;1882
0009a0  d925              BLS      |L8.2542|
0009a2  f7fffffe          BL       USB_CURRENT_Read
0009a6  f5c461fa          RSB      r1,r4,#0x7d0          ;1889
0009aa  4281              CMP      r1,r0                 ;1889
0009ac  da1a              BGE      |L8.2532|
0009ae  f50464fa          ADD      r4,r4,#0x7d0          ;1889
0009b2  42a0              CMP      r0,r4                 ;1889
0009b4  d216              BCS      |L8.2532|
0009b6  f7fffffe          BL       Clear_All_Lines
0009ba  f2af0158          ADR      r1,|L8.2404|
0009be  2000              MOVS     r0,#0                 ;1892
0009c0  f7fffffe          BL       Display_Centered
0009c4  f2af0154          ADR      r1,|L8.2420|
0009c8  2001              MOVS     r0,#1                 ;1893
0009ca  f7fffffe          BL       Display_Centered
0009ce  2101              MOVS     r1,#1                 ;1896
0009d0  2014              MOVS     r0,#0x14              ;1896
0009d2  f7fffffe          BL       STS_PROTOCOL_SendCmdParamAck
                  |L8.2518|
0009d6  e35e              B        |L8.4246|
                  |L8.2520|
0009d8  e24a              B        |L8.3696|
                  |L8.2522|
0009da  e25b              B        |L8.3732|
                  |L8.2524|
0009dc  e28b              B        |L8.3830|
                  |L8.2526|
0009de  e342              B        |L8.4198|
                  |L8.2528|
0009e0  e04d              B        |L8.2686|
                  |L8.2530|
0009e2  e34d              B        |L8.4224|
                  |L8.2532|
0009e4  2100              MOVS     r1,#0                 ;1900
0009e6  2014              MOVS     r0,#0x14              ;1900
0009e8  f7fffffe          BL       STS_PROTOCOL_SendCmdParamAck
0009ec  e353              B        |L8.4246|
                  |L8.2542|
0009ee  2100              MOVS     r1,#0                 ;1905
0009f0  2014              MOVS     r0,#0x14              ;1905
0009f2  f7fffffe          BL       STS_PROTOCOL_SendCmdParamAck
0009f6  e34e              B        |L8.4246|
                  |L8.2552|
0009f8  2200              MOVS     r2,#0                 ;1914
0009fa  2103              MOVS     r1,#3                 ;1914
0009fc  48fe              LDR      r0,|L8.3576|
0009fe  f7fffffe          BL       Vertical_Scrolling_Display
000a02  7920              LDRB     r0,[r4,#4]            ;1917
000a04  f8880046          STRB     r0,[r8,#0x46]         ;1917
000a08  4dfc              LDR      r5,|L8.3580|
000a0a  260e              MOVS     r6,#0xe               ;1923
000a0c  2801              CMP      r0,#1                 ;1920
000a0e  d107              BNE      |L8.2592|
000a10  7960              LDRB     r0,[r4,#5]            ;1922
000a12  7068              STRB     r0,[r5,#1]            ;1922
000a14  f8886017          STRB     r6,[r8,#0x17]         ;1923
000a18  f7fffffe          BL       enterState
000a1c  f8887030          STRB     r7,[r8,#0x30]         ;1925
                  |L8.2592|
000a20  f8980046          LDRB     r0,[r8,#0x46]         ;1929  ; dut_info
000a24  2802              CMP      r0,#2                 ;1929
000a26  d109              BNE      |L8.2620|
000a28  7960              LDRB     r0,[r4,#5]            ;1931
000a2a  7068              STRB     r0,[r5,#1]            ;1931
000a2c  79a0              LDRB     r0,[r4,#6]            ;1932
000a2e  70a8              STRB     r0,[r5,#2]            ;1932
000a30  f8886017          STRB     r6,[r8,#0x17]         ;1933
000a34  f7fffffe          BL       enterState
000a38  f888a030          STRB     r10,[r8,#0x30]        ;1935
                  |L8.2620|
000a3c  f8980046          LDRB     r0,[r8,#0x46]         ;1939  ; dut_info
000a40  2803              CMP      r0,#3                 ;1939
000a42  d1c8              BNE      |L8.2518|
000a44  7960              LDRB     r0,[r4,#5]            ;1941
000a46  7068              STRB     r0,[r5,#1]            ;1941
000a48  79a0              LDRB     r0,[r4,#6]            ;1942
000a4a  70a8              STRB     r0,[r5,#2]            ;1942
000a4c  79e0              LDRB     r0,[r4,#7]            ;1943
000a4e  70e8              STRB     r0,[r5,#3]            ;1943
000a50  f8886017          STRB     r6,[r8,#0x17]         ;1944
000a54  f7fffffe          BL       enterState
000a58  2003              MOVS     r0,#3                 ;1946
000a5a  f8880030          STRB     r0,[r8,#0x30]         ;1946
                  |L8.2654|
000a5e  e31a              B        |L8.4246|
                  |L8.2656|
000a60  e045              B        |L8.2798|
                  |L8.2658|
000a62  e024              B        |L8.2734|
                  |L8.2660|
000a64  e004              B        |L8.2672|
                  |L8.2662|
000a66  e0a9              B        |L8.3004|
                  |L8.2664|
000a68  e02b              B        |L8.2754|
                  |L8.2666|
000a6a  e091              B        |L8.2960|
                  |L8.2668|
000a6c  e065              B        |L8.2874|
                  |L8.2670|
000a6e  e0cf              B        |L8.3088|
                  |L8.2672|
000a70  f888702d          STRB     r7,[r8,#0x2d]         ;1952
000a74  7961              LDRB     r1,[r4,#5]            ;1955
000a76  2004              MOVS     r0,#4                 ;1955
000a78  f7fffffe          BL       POWER_PROTOCOL_SendCmdParamAck
000a7c  e30b              B        |L8.4246|
                  |L8.2686|
000a7e  4de0              LDR      r5,|L8.3584|
000a80  2380              MOVS     r3,#0x80              ;1962
000a82  2203              MOVS     r2,#3                 ;1962
000a84  2110              MOVS     r1,#0x10              ;1962
000a86  4628              MOV      r0,r5                 ;1962
000a88  f7fffffe          BL       gpio_init
000a8c  2180              MOVS     r1,#0x80              ;1962
000a8e  4628              MOV      r0,r5                 ;1962
000a90  f7fffffe          BL       gpio_bit_reset
000a94  f8b42098          LDRH     r2,[r4,#0x98]         ;1963
000a98  1ca1              ADDS     r1,r4,#2              ;1963
000a9a  2000              MOVS     r0,#0                 ;1963
000a9c  f7fffffe          BL       UART_DRIVE_AddTxArray
000aa0  f7fffffe          BL       Clear_All_Lines
000aa4  a1d7              ADR      r1,|L8.3588|
000aa6  2000              MOVS     r0,#0                 ;1965
000aa8  f7fffffe          BL       Display_Centered
000aac  e2f3              B        |L8.4246|
                  |L8.2734|
000aae  f8887017          STRB     r7,[r8,#0x17]         ;1970
000ab2  f7fffffe          BL       enterState
000ab6  2201              MOVS     r2,#1                 ;1974
000ab8  2103              MOVS     r1,#3                 ;1974
000aba  48cf              LDR      r0,|L8.3576|
000abc  f7fffffe          BL       Vertical_Scrolling_Display
000ac0  e2e9              B        |L8.4246|
                  |L8.2754|
000ac2  f6413158          MOV      r1,#0x1b58            ;1979
000ac6  2011              MOVS     r0,#0x11              ;1979
000ac8  f7fffffe          BL       TIMER_ChangeTime
000acc  f898001a          LDRB     r0,[r8,#0x1a]         ;1981  ; dut_info
000ad0  b130              CBZ      r0,|L8.2784|
000ad2  f8942098          LDRB     r2,[r4,#0x98]         ;1983
000ad6  1ca1              ADDS     r1,r4,#2              ;1983
000ad8  2000              MOVS     r0,#0                 ;1983
000ada  f7fffffe          BL       CAN_TEST_DRIVE_AddTxArray
000ade  e2da              B        |L8.4246|
                  |L8.2784|
000ae0  f8b42098          LDRH     r2,[r4,#0x98]         ;1987
000ae4  1ca1              ADDS     r1,r4,#2              ;1987
000ae6  2000              MOVS     r0,#0                 ;1987
000ae8  f7fffffe          BL       UART_DRIVE_AddTxArray
000aec  e2d3              B        |L8.4246|
                  |L8.2798|
000aee  f888702e          STRB     r7,[r8,#0x2e]         ;1993
000af2  7960              LDRB     r0,[r4,#5]            ;1996
000af4  b118              CBZ      r0,|L8.2814|
000af6  2101              MOVS     r1,#1                 ;1998
000af8  2005              MOVS     r0,#5                 ;1998
000afa  f7fffffe          BL       POWER_PROTOCOL_SendCmdParamAck
                  |L8.2814|
000afe  7960              LDRB     r0,[r4,#5]            ;2002
000b00  2800              CMP      r0,#0                 ;2002
000b02  d1ac              BNE      |L8.2654|
000b04  2100              MOVS     r1,#0                 ;2006
000b06  2005              MOVS     r0,#5                 ;2006
000b08  f7fffffe          BL       POWER_PROTOCOL_SendCmdParamAck
000b0c  e2c3              B        |L8.4246|
                  |L8.2830|
000b0e  2055              MOVS     r0,#0x55              ;2012
000b10  f7fffffe          BL       STS_PROTOCOL_TxAddData
000b14  201d              MOVS     r0,#0x1d              ;2013
000b16  f7fffffe          BL       STS_PROTOCOL_TxAddData
000b1a  2002              MOVS     r0,#2                 ;2014
000b1c  f7fffffe          BL       STS_PROTOCOL_TxAddData
000b20  f7fffffe          BL       KEY_ADC_Read
000b24  0a00              LSRS     r0,r0,#8              ;2015
000b26  f7fffffe          BL       STS_PROTOCOL_TxAddData
000b2a  f7fffffe          BL       KEY_ADC_Read
000b2e  b2c0              UXTB     r0,r0                 ;2016
000b30  f7fffffe          BL       STS_PROTOCOL_TxAddData
000b34  f7fffffe          BL       STS_PROTOCOL_TxAddFrame
000b38  e2ad              B        |L8.4246|
                  |L8.2874|
000b3a  b1c1              CBZ      r1,|L8.2926|
000b3c  205a              MOVS     r0,#0x5a              ;2026
000b3e  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
000b42  2012              MOVS     r0,#0x12              ;2027
000b44  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
000b48  2085              MOVS     r0,#0x85              ;2028
000b4a  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
000b4e  2000              MOVS     r0,#0                 ;2029
000b50  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
000b54  e004              B        |L8.2912|
                  |L8.2902|
000b56  1960              ADDS     r0,r4,r5              ;2033
000b58  7980              LDRB     r0,[r0,#6]            ;2033
000b5a  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
000b5e  1c6d              ADDS     r5,r5,#1              ;2031
                  |L8.2912|
000b60  7920              LDRB     r0,[r4,#4]            ;2031
000b62  1e40              SUBS     r0,r0,#1              ;2031
000b64  42a8              CMP      r0,r5                 ;2031
000b66  d8f6              BHI      |L8.2902|
000b68  f7fffffe          BL       UART_PROTOCOL_XM_TxAddFrame
000b6c  e293              B        |L8.4246|
                  |L8.2926|
000b6e  b140              CBZ      r0,|L8.2946|
000b70  f8942098          LDRB     r2,[r4,#0x98]         ;2052
000b74  1ca1              ADDS     r1,r4,#2              ;2052
000b76  2000              MOVS     r0,#0                 ;2052
000b78  f7fffffe          BL       CAN_TEST_DRIVE_AddTxArray
000b7c  f88b7002          STRB     r7,[r11,#2]           ;2053
000b80  e289              B        |L8.4246|
                  |L8.2946|
000b82  f8b42098          LDRH     r2,[r4,#0x98]         ;2057
000b86  1ca1              ADDS     r1,r4,#2              ;2057
000b88  2000              MOVS     r0,#0                 ;2057
000b8a  f7fffffe          BL       UART_DRIVE_AddTxArray
000b8e  e282              B        |L8.4246|
                  |L8.2960|
000b90  b119              CBZ      r1,|L8.2970|
000b92  209a              MOVS     r0,#0x9a              ;2067
000b94  f7fffffe          BL       UART_PROTOCOL_XM_SendCmdAck
000b98  e27d              B        |L8.4246|
                  |L8.2970|
000b9a  b140              CBZ      r0,|L8.2990|
000b9c  f8942098          LDRB     r2,[r4,#0x98]         ;2073
000ba0  1ca1              ADDS     r1,r4,#2              ;2073
000ba2  2000              MOVS     r0,#0                 ;2073
000ba4  f7fffffe          BL       CAN_TEST_DRIVE_AddTxArray
000ba8  f88b7002          STRB     r7,[r11,#2]           ;2074
                  |L8.2988|
000bac  e273              B        |L8.4246|
                  |L8.2990|
000bae  f8b42098          LDRH     r2,[r4,#0x98]         ;2078
000bb2  1ca1              ADDS     r1,r4,#2              ;2078
000bb4  2000              MOVS     r0,#0                 ;2078
000bb6  f7fffffe          BL       UART_DRIVE_AddTxArray
000bba  e26c              B        |L8.4246|
                  |L8.3004|
000bbc  b1b9              CBZ      r1,|L8.3054|
000bbe  4894              LDR      r0,|L8.3600|
000bc0  e003              B        |L8.3018|
                  |L8.3010|
000bc2  1961              ADDS     r1,r4,r5              ;2091
000bc4  7949              LDRB     r1,[r1,#5]            ;2091
000bc6  5541              STRB     r1,[r0,r5]            ;2091
000bc8  1c6d              ADDS     r5,r5,#1              ;2089
                  |L8.3018|
000bca  7921              LDRB     r1,[r4,#4]            ;2089
000bcc  42a9              CMP      r1,r5                 ;2089
000bce  d8f8              BHI      |L8.3010|
000bd0  205a              MOVS     r0,#0x5a              ;2095
000bd2  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
000bd6  2012              MOVS     r0,#0x12              ;2096
000bd8  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
000bdc  2090              MOVS     r0,#0x90              ;2097
000bde  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
000be2  2000              MOVS     r0,#0                 ;2098
000be4  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
000be8  f7fffffe          BL       UART_PROTOCOL_XM_TxAddFrame
000bec  e253              B        |L8.4246|
                  |L8.3054|
000bee  b140              CBZ      r0,|L8.3074|
000bf0  f8942098          LDRB     r2,[r4,#0x98]         ;2105
000bf4  1ca1              ADDS     r1,r4,#2              ;2105
000bf6  2000              MOVS     r0,#0                 ;2105
000bf8  f7fffffe          BL       CAN_TEST_DRIVE_AddTxArray
000bfc  f88b7002          STRB     r7,[r11,#2]           ;2106
000c00  e249              B        |L8.4246|
                  |L8.3074|
000c02  f8b42098          LDRH     r2,[r4,#0x98]         ;2110
000c06  1ca1              ADDS     r1,r4,#2              ;2110
000c08  2000              MOVS     r0,#0                 ;2110
000c0a  f7fffffe          BL       UART_DRIVE_AddTxArray
000c0e  e242              B        |L8.4246|
                  |L8.3088|
000c10  2200              MOVS     r2,#0                 ;2118
000c12  f888210a          STRB     r2,[r8,#0x10a]        ;2118
000c16  b171              CBZ      r1,|L8.3126|
000c18  205a              MOVS     r0,#0x5a              ;2124
000c1a  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
000c1e  2012              MOVS     r0,#0x12              ;2125
000c20  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
000c24  2089              MOVS     r0,#0x89              ;2126
000c26  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
000c2a  2000              MOVS     r0,#0                 ;2127
000c2c  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
000c30  f7fffffe          BL       UART_PROTOCOL_XM_TxAddFrame
000c34  e22f              B        |L8.4246|
                  |L8.3126|
000c36  b140              CBZ      r0,|L8.3146|
000c38  f8942098          LDRB     r2,[r4,#0x98]         ;2134
000c3c  1ca1              ADDS     r1,r4,#2              ;2134
000c3e  2000              MOVS     r0,#0                 ;2134
000c40  f7fffffe          BL       CAN_TEST_DRIVE_AddTxArray
000c44  f88b7002          STRB     r7,[r11,#2]           ;2135
000c48  e225              B        |L8.4246|
                  |L8.3146|
000c4a  f8b42098          LDRH     r2,[r4,#0x98]         ;2139
000c4e  1ca1              ADDS     r1,r4,#2              ;2139
000c50  2000              MOVS     r0,#0                 ;2139
000c52  f7fffffe          BL       UART_DRIVE_AddTxArray
000c56  e21e              B        |L8.4246|
                  |L8.3160|
000c58  f888710a          STRB     r7,[r8,#0x10a]        ;2147
000c5c  b171              CBZ      r1,|L8.3196|
000c5e  205a              MOVS     r0,#0x5a              ;2154
000c60  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
000c64  2012              MOVS     r0,#0x12              ;2155
000c66  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
000c6a  2089              MOVS     r0,#0x89              ;2156
000c6c  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
000c70  2000              MOVS     r0,#0                 ;2157
000c72  f7fffffe          BL       UART_PROTOCOL_XM_TxAddData
000c76  f7fffffe          BL       UART_PROTOCOL_XM_TxAddFrame
000c7a  e009              B        |L8.3216|
                  |L8.3196|
000c7c  b128              CBZ      r0,|L8.3210|
000c7e  2005              MOVS     r0,#5                 ;2164
000c80  f7fffffe          BL       CAN_PROTOCOL_TEST_SendCmdAck
000c84  f88b7002          STRB     r7,[r11,#2]           ;2165
000c88  e002              B        |L8.3216|
                  |L8.3210|
000c8a  2005              MOVS     r0,#5                 ;2169
000c8c  f7fffffe          BL       DUT_PROTOCOL_SendCmdAck
                  |L8.3216|
000c90  7960              LDRB     r0,[r4,#5]            ;2173
000c92  79a1              LDRB     r1,[r4,#6]            ;2174
000c94  f88b1003          STRB     r1,[r11,#3]           ;2174
000c98  4c5e              LDR      r4,|L8.3604|
000c9a  4d5f              LDR      r5,|L8.3608|
000c9c  2808              CMP      r0,#8                 ;2177
000c9e  d285              BCS      |L8.2988|
000ca0  e8dff000          TBB      [pc,r0]               ;2177
000ca4  0418324c          DCB      0x04,0x18,0x32,0x4c
000ca8  66809ac5          DCB      0x66,0x80,0x9a,0xc5
000cac  f44f4500          MOV      r5,#0x8000            ;2180
000cb0  462b              MOV      r3,r5                 ;2180
000cb2  2203              MOVS     r2,#3                 ;2180
000cb4  2110              MOVS     r1,#0x10              ;2180
000cb6  4620              MOV      r0,r4                 ;2180
000cb8  f7fffffe          BL       gpio_init
000cbc  4629              MOV      r1,r5                 ;2180
000cbe  4620              MOV      r0,r4                 ;2180
000cc0  f7fffffe          BL       gpio_bit_set
000cc4  2064              MOVS     r0,#0x64              ;2181
000cc6  f7fffffe          BL       Delayms
000cca  4629              MOV      r1,r5                 ;2182
000ccc  4620              MOV      r0,r4                 ;2182
000cce  f7fffffe          BL       gpio_bit_reset
000cd2  e1e0              B        |L8.4246|
000cd4  f44f4580          MOV      r5,#0x4000            ;2186
000cd8  462b              MOV      r3,r5                 ;2186
000cda  2203              MOVS     r2,#3                 ;2186
000cdc  2110              MOVS     r1,#0x10              ;2186
000cde  4620              MOV      r0,r4                 ;2186
000ce0  f7fffffe          BL       gpio_init
000ce4  4629              MOV      r1,r5                 ;2186
000ce6  4620              MOV      r0,r4                 ;2186
000ce8  f7fffffe          BL       gpio_bit_set
000cec  2064              MOVS     r0,#0x64              ;2187
000cee  f7fffffe          BL       Delayms
000cf2  462b              MOV      r3,r5                 ;2188
000cf4  2203              MOVS     r2,#3                 ;2188
000cf6  2110              MOVS     r1,#0x10              ;2188
000cf8  4620              MOV      r0,r4                 ;2188
000cfa  f7fffffe          BL       gpio_init
000cfe  4629              MOV      r1,r5                 ;2188
000d00  4620              MOV      r0,r4                 ;2188
000d02  f7fffffe          BL       gpio_bit_reset
000d06  e1c6              B        |L8.4246|
000d08  f44f6580          MOV      r5,#0x400             ;2192
000d0c  462b              MOV      r3,r5                 ;2192
000d0e  2203              MOVS     r2,#3                 ;2192
000d10  2110              MOVS     r1,#0x10              ;2192
000d12  4620              MOV      r0,r4                 ;2192
000d14  f7fffffe          BL       gpio_init
000d18  4629              MOV      r1,r5                 ;2192
000d1a  4620              MOV      r0,r4                 ;2192
000d1c  f7fffffe          BL       gpio_bit_set
000d20  2064              MOVS     r0,#0x64              ;2193
000d22  f7fffffe          BL       Delayms
000d26  462b              MOV      r3,r5                 ;2194
000d28  2203              MOVS     r2,#3                 ;2194
000d2a  2110              MOVS     r1,#0x10              ;2194
000d2c  4620              MOV      r0,r4                 ;2194
000d2e  f7fffffe          BL       gpio_init
000d32  4629              MOV      r1,r5                 ;2194
000d34  4620              MOV      r0,r4                 ;2194
000d36  f7fffffe          BL       gpio_bit_reset
000d3a  e1ac              B        |L8.4246|
000d3c  f44f7500          MOV      r5,#0x200             ;2198
000d40  462b              MOV      r3,r5                 ;2198
000d42  2203              MOVS     r2,#3                 ;2198
000d44  2110              MOVS     r1,#0x10              ;2198
000d46  4620              MOV      r0,r4                 ;2198
000d48  f7fffffe          BL       gpio_init
000d4c  4629              MOV      r1,r5                 ;2198
000d4e  4620              MOV      r0,r4                 ;2198
000d50  f7fffffe          BL       gpio_bit_set
000d54  2064              MOVS     r0,#0x64              ;2199
000d56  f7fffffe          BL       Delayms
000d5a  462b              MOV      r3,r5                 ;2200
000d5c  2203              MOVS     r2,#3                 ;2200
000d5e  2110              MOVS     r1,#0x10              ;2200
000d60  4620              MOV      r0,r4                 ;2200
000d62  f7fffffe          BL       gpio_init
000d66  4629              MOV      r1,r5                 ;2200
000d68  4620              MOV      r0,r4                 ;2200
000d6a  f7fffffe          BL       gpio_bit_reset
000d6e  e192              B        |L8.4246|
000d70  f44f6400          MOV      r4,#0x800             ;2204
000d74  4623              MOV      r3,r4                 ;2204
000d76  2203              MOVS     r2,#3                 ;2204
000d78  2110              MOVS     r1,#0x10              ;2204
000d7a  4628              MOV      r0,r5                 ;2204
000d7c  f7fffffe          BL       gpio_init
000d80  4621              MOV      r1,r4                 ;2204
000d82  4628              MOV      r0,r5                 ;2204
000d84  f7fffffe          BL       gpio_bit_set
000d88  2064              MOVS     r0,#0x64              ;2205
000d8a  f7fffffe          BL       Delayms
000d8e  4623              MOV      r3,r4                 ;2206
000d90  2203              MOVS     r2,#3                 ;2206
000d92  2110              MOVS     r1,#0x10              ;2206
000d94  4628              MOV      r0,r5                 ;2206
000d96  f7fffffe          BL       gpio_init
000d9a  4621              MOV      r1,r4                 ;2206
000d9c  4628              MOV      r0,r5                 ;2206
000d9e  f7fffffe          BL       gpio_bit_reset
000da2  e178              B        |L8.4246|
000da4  f44f5480          MOV      r4,#0x1000            ;2210
000da8  4623              MOV      r3,r4                 ;2210
000daa  2203              MOVS     r2,#3                 ;2210
000dac  2110              MOVS     r1,#0x10              ;2210
000dae  4628              MOV      r0,r5                 ;2210
000db0  f7fffffe          BL       gpio_init
000db4  4621              MOV      r1,r4                 ;2210
000db6  4628              MOV      r0,r5                 ;2210
000db8  f7fffffe          BL       gpio_bit_set
000dbc  2064              MOVS     r0,#0x64              ;2211
000dbe  f7fffffe          BL       Delayms
000dc2  4623              MOV      r3,r4                 ;2212
000dc4  2203              MOVS     r2,#3                 ;2212
000dc6  2110              MOVS     r1,#0x10              ;2212
000dc8  4628              MOV      r0,r5                 ;2212
000dca  f7fffffe          BL       gpio_init
000dce  4621              MOV      r1,r4                 ;2212
000dd0  4628              MOV      r0,r5                 ;2212
000dd2  f7fffffe          BL       gpio_bit_reset
000dd6  e15e              B        |L8.4246|
000dd8  2340              MOVS     r3,#0x40              ;2216
000dda  2203              MOVS     r2,#3                 ;2216
000ddc  2110              MOVS     r1,#0x10              ;2216
000dde  4620              MOV      r0,r4                 ;2216
000de0  f7fffffe          BL       gpio_init
000de4  2140              MOVS     r1,#0x40              ;2216
000de6  4620              MOV      r0,r4                 ;2216
000de8  f7fffffe          BL       gpio_bit_set
000dec  2064              MOVS     r0,#0x64              ;2217
000dee  f7fffffe          BL       Delayms
000df2  2340              MOVS     r3,#0x40              ;2218
000df4  2203              MOVS     r2,#3                 ;2218
000df6  e011              B        |L8.3612|
                  |L8.3576|
                          DCD      ||.data||+0x160
                  |L8.3580|
                          DCD      ||.data||+0x1c
                  |L8.3584|
                          DCD      0x40010c00
                  |L8.3588|
000e04  564c4b20          DCB      "VLK CLOSE",0
000e08  434c4f53
000e0c  4500    
000e0e  00                DCB      0
000e0f  00                DCB      0
                  |L8.3600|
                          DCD      ||.bss||+0x64
                  |L8.3604|
                          DCD      0x40011400
                  |L8.3608|
                          DCD      0x40010800
                  |L8.3612|
000e1c  2110              MOVS     r1,#0x10              ;2218
000e1e  4620              MOV      r0,r4                 ;2218
000e20  f7fffffe          BL       gpio_init
000e24  2140              MOVS     r1,#0x40              ;2218
000e26  4620              MOV      r0,r4                 ;2218
000e28  f7fffffe          BL       gpio_bit_reset
000e2c  e133              B        |L8.4246|
000e2e  4ca1              LDR      r4,|L8.4276|
000e30  2340              MOVS     r3,#0x40              ;2222
000e32  2203              MOVS     r2,#3                 ;2222
000e34  2110              MOVS     r1,#0x10              ;2222
000e36  4620              MOV      r0,r4                 ;2222
000e38  f7fffffe          BL       gpio_init
000e3c  2140              MOVS     r1,#0x40              ;2222
000e3e  4620              MOV      r0,r4                 ;2222
000e40  f7fffffe          BL       gpio_bit_set
000e44  2064              MOVS     r0,#0x64              ;2223
000e46  f7fffffe          BL       Delayms
000e4a  2340              MOVS     r3,#0x40              ;2224
000e4c  2203              MOVS     r2,#3                 ;2224
000e4e  2110              MOVS     r1,#0x10              ;2224
000e50  4620              MOV      r0,r4                 ;2224
000e52  f7fffffe          BL       gpio_init
000e56  2140              MOVS     r1,#0x40              ;2224
000e58  4620              MOV      r0,r4                 ;2224
000e5a  f7fffffe          BL       gpio_bit_reset
000e5e  e11a              B        |L8.4246|
                  |L8.3680|
000e60  2003              MOVS     r0,#3                 ;2235
000e62  f7fffffe          BL       POWER_PROTOCOL_SendCmdAck
000e66  e116              B        |L8.4246|
                  |L8.3688|
000e68  200a              MOVS     r0,#0xa               ;2545
000e6a  f7fffffe          BL       POWER_PROTOCOL_SendCmdAck
000e6e  e112              B        |L8.4246|
                  |L8.3696|
000e70  2000              MOVS     r0,#0                 ;2550
000e72  f8cb000c          STR      r0,[r11,#0xc]         ;2550  ; powerPacketSize
000e76  203a              MOVS     r0,#0x3a              ;2551
000e78  f7fffffe          BL       POWER_PROTOCOL_TxAddData
000e7c  201a              MOVS     r0,#0x1a              ;2552
000e7e  f7fffffe          BL       POWER_PROTOCOL_TxAddData
000e82  200b              MOVS     r0,#0xb               ;2553
000e84  f7fffffe          BL       POWER_PROTOCOL_TxAddData
000e88  2000              MOVS     r0,#0                 ;2554
000e8a  f7fffffe          BL       POWER_PROTOCOL_TxAddData
000e8e  f7fffffe          BL       POWER_PROTOCOL_TxAddFrame
000e92  e100              B        |L8.4246|
                  |L8.3732|
000e94  7926              LDRB     r6,[r4,#4]            ;2560
000e96  7960              LDRB     r0,[r4,#5]            ;2561
000e98  79a2              LDRB     r2,[r4,#6]            ;2562
000e9a  79e3              LDRB     r3,[r4,#7]            ;2563
000e9c  7a21              LDRB     r1,[r4,#8]            ;2564
000e9e  0600              LSLS     r0,r0,#24             ;2565
000ea0  ea404002          ORR      r0,r0,r2,LSL #16      ;2565
000ea4  ea402003          ORR      r0,r0,r3,LSL #8       ;2565
000ea8  4308              ORRS     r0,r0,r1              ;2565
000eaa  f8db1018          LDR      r1,[r11,#0x18]        ;2567  ; currPacketNum
000eae  4281              CMP      r1,r0                 ;2567
000eb0  d006              BEQ      |L8.3776|
000eb2  f8db100c          LDR      r1,[r11,#0xc]         ;2569  ; powerPacketSize
000eb6  1c49              ADDS     r1,r1,#1              ;2569
000eb8  f8cb100c          STR      r1,[r11,#0xc]         ;2569  ; powerPacketSize
000ebc  f8cb0018          STR      r0,[r11,#0x18]        ;2570  ; currPacketNum
                  |L8.3776|
000ec0  203a              MOVS     r0,#0x3a              ;2573
000ec2  f7fffffe          BL       POWER_PROTOCOL_TxAddData
000ec6  201a              MOVS     r0,#0x1a              ;2574
000ec8  f7fffffe          BL       POWER_PROTOCOL_TxAddData
000ecc  200c              MOVS     r0,#0xc               ;2575
000ece  f7fffffe          BL       POWER_PROTOCOL_TxAddData
000ed2  4630              MOV      r0,r6                 ;2576
000ed4  f7fffffe          BL       POWER_PROTOCOL_TxAddData
000ed8  e004              B        |L8.3812|
                  |L8.3802|
000eda  1960              ADDS     r0,r4,r5              ;2580
000edc  7940              LDRB     r0,[r0,#5]            ;2580
000ede  f7fffffe          BL       POWER_PROTOCOL_TxAddData
000ee2  1c6d              ADDS     r5,r5,#1              ;2578
                  |L8.3812|
000ee4  42b5              CMP      r5,r6                 ;2578
000ee6  d3f8              BCC      |L8.3802|
000ee8  f7fffffe          BL       POWER_PROTOCOL_TxAddFrame
000eec  e0d3              B        |L8.4246|
                  |L8.3822|
000eee  200d              MOVS     r0,#0xd               ;2588
000ef0  f7fffffe          BL       POWER_PROTOCOL_SendCmdAck
000ef4  e0cf              B        |L8.4246|
                  |L8.3830|
000ef6  79a0              LDRB     r0,[r4,#6]            ;2594
000ef8  f8dfc1bc          LDR      r12,|L8.4280|
000efc  2500              MOVS     r5,#0                 ;2595
000efe  f8cc5000          STR      r5,[r12,#0]           ;2595  ; online_detection_cnt
000f02  280d              CMP      r0,#0xd               ;2598
000f04  d23b              BCS      |L8.3966|
000f06  e8dff000          TBB      [pc,r0]               ;2598
000f0a  3a07              DCB      0x3a,0x07
000f0c  0c101418          DCB      0x0c,0x10,0x14,0x18
000f10  1c21262b          DCB      0x1c,0x21,0x26,0x2b
000f14  30353800          DCB      0x30,0x35,0x38,0x00
000f18  f44f6696          MOV      r6,#0x4b0             ;2601
000f1c  f04f0a64          MOV      r10,#0x64             ;2602
000f20  e02d              B        |L8.3966|
000f22  460e              MOV      r6,r1                 ;2606
000f24  f04f0a7d          MOV      r10,#0x7d             ;2607
000f28  e029              B        |L8.3966|
000f2a  4616              MOV      r6,r2                 ;2611
000f2c  f04f0a96          MOV      r10,#0x96             ;2612
000f30  e025              B        |L8.3966|
000f32  461e              MOV      r6,r3                 ;2616
000f34  f04f0ac8          MOV      r10,#0xc8             ;2617
000f38  e021              B        |L8.3966|
000f3a  4676              MOV      r6,lr                 ;2621
000f3c  f04f0afa          MOV      r10,#0xfa             ;2622
000f40  e01d              B        |L8.3966|
000f42  f44f4696          MOV      r6,#0x4b00            ;2626
000f46  f44f7a96          MOV      r10,#0x12c            ;2627
000f4a  e018              B        |L8.3966|
000f4c  f44f4616          MOV      r6,#0x9600            ;2631
000f50  f44f7ac8          MOV      r10,#0x190            ;2632
000f54  e013              B        |L8.3966|
000f56  f24a76f8          MOV      r6,#0xa7f8            ;2636
000f5a  f44f7afa          MOV      r10,#0x1f4            ;2637
000f5e  e00e              B        |L8.3966|
000f60  f44f4661          MOV      r6,#0xe100            ;2641
000f64  f44f7a16          MOV      r10,#0x258            ;2642
000f68  e009              B        |L8.3966|
000f6a  f44f3696          MOV      r6,#0x12c00           ;2646
000f6e  f44f7a61          MOV      r10,#0x384            ;2647
000f72  e004              B        |L8.3966|
000f74  f44f36e1          MOV      r6,#0x1c200           ;2651
000f78  e001              B        |L8.3966|
000f7a  f44f36fa          MOV      r6,#0x1f400           ;2655
                  |L8.3966|
000f7e  f8c86020          STR      r6,[r8,#0x20]         ;2662  ; dut_info
000f82  f8a8a01c          STRH     r10,[r8,#0x1c]        ;2663
000f86  7960              LDRB     r0,[r4,#5]            ;2693
000f88  2801              CMP      r0,#1                 ;2702
000f8a  d004              BEQ      |L8.3990|
000f8c  2802              CMP      r0,#2                 ;2702
000f8e  d02a              BEQ      |L8.4070|
000f90  2803              CMP      r0,#3                 ;2702
000f92  d127              BNE      |L8.4068|
000f94  e04d              B        |L8.4146|
                  |L8.3990|
000f96  f7fffffe          BL       CHANGE_Init
000f9a  4c48              LDR      r4,|L8.4284|
000f9c  f44f7180          MOV      r1,#0x100             ;2707
000fa0  4620              MOV      r0,r4                 ;2707
000fa2  f7fffffe          BL       gpio_bit_reset
000fa6  1561              ASRS     r1,r4,#21             ;2708
000fa8  4620              MOV      r0,r4                 ;2708
000faa  f7fffffe          BL       gpio_bit_set
000fae  4630              MOV      r0,r6                 ;2709
000fb0  f7fffffe          BL       UART_DRIVE_InitSelect
000fb4  f7fffffe          BL       UART_PROTOCOL_Init
000fb8  f7fffffe          BL       UART_PROTOCOL4_Init
000fbc  f888501a          STRB     r5,[r8,#0x1a]         ;2712
000fc0  2203              MOVS     r2,#3                 ;2715
000fc2  2104              MOVS     r1,#4                 ;2715
000fc4  483e              LDR      r0,|L8.4288|
000fc6  f7fffffe          BL       Vertical_Scrolling_Display
000fca  2101              MOVS     r1,#1                 ;2718
000fcc  2047              MOVS     r0,#0x47              ;2718
000fce  f7fffffe          BL       STS_PROTOCOL_SendCmdParamAck
000fd2  9700              STR      r7,[sp,#0]            ;2720
000fd4  2300              MOVS     r3,#0                 ;2720
000fd6  4a3b              LDR      r2,|L8.4292|
000fd8  f64031b8          MOV      r1,#0xbb8             ;2720
000fdc  2011              MOVS     r0,#0x11              ;2720
000fde  9701              STR      r7,[sp,#4]            ;2720
000fe0  f7fffffe          BL       TIMER_AddTask
                  |L8.4068|
000fe4  e057              B        |L8.4246|
                  |L8.4070|
000fe6  f7fffffe          BL       CHANGE_Init
000fea  4c34              LDR      r4,|L8.4284|
000fec  f44f7180          MOV      r1,#0x100             ;2731
000ff0  4620              MOV      r0,r4                 ;2731
000ff2  f7fffffe          BL       gpio_bit_set
000ff6  1561              ASRS     r1,r4,#21             ;2732
000ff8  4620              MOV      r0,r4                 ;2732
000ffa  f7fffffe          BL       gpio_bit_set
000ffe  4630              MOV      r0,r6                 ;2733
001000  f7fffffe          BL       UART_DRIVE_InitSelect
001004  f888501a          STRB     r5,[r8,#0x1a]         ;2734
001008  f7fffffe          BL       UART_PROTOCOL4_Init
00100c  2203              MOVS     r2,#3                 ;2738
00100e  2104              MOVS     r1,#4                 ;2738
001010  482b              LDR      r0,|L8.4288|
001012  f7fffffe          BL       Vertical_Scrolling_Display
001016  2101              MOVS     r1,#1                 ;2741
001018  2047              MOVS     r0,#0x47              ;2741
00101a  f7fffffe          BL       STS_PROTOCOL_SendCmdParamAck
00101e  9700              STR      r7,[sp,#0]            ;2743
001020  2300              MOVS     r3,#0                 ;2743
001022  4a28              LDR      r2,|L8.4292|
001024  f64031b8          MOV      r1,#0xbb8             ;2743
001028  2011              MOVS     r0,#0x11              ;2743
00102a  9701              STR      r7,[sp,#4]            ;2743
00102c  f7fffffe          BL       TIMER_AddTask
001030  e031              B        |L8.4246|
                  |L8.4146|
001032  4650              MOV      r0,r10                ;2753
001034  f7fffffe          BL       CAN_PROTOCOL_TEST_Init
001038  f7fffffe          BL       CAN_PROTOCOL1_Init
00103c  f888701a          STRB     r7,[r8,#0x1a]         ;2757
001040  2203              MOVS     r2,#3                 ;2760
001042  2104              MOVS     r1,#4                 ;2760
001044  481e              LDR      r0,|L8.4288|
001046  f7fffffe          BL       Vertical_Scrolling_Display
00104a  2101              MOVS     r1,#1                 ;2763
00104c  2047              MOVS     r0,#0x47              ;2763
00104e  f7fffffe          BL       STS_PROTOCOL_SendCmdParamAck
001052  9700              STR      r7,[sp,#0]            ;2765
001054  2300              MOVS     r3,#0                 ;2765
001056  4a1b              LDR      r2,|L8.4292|
001058  f64031b8          MOV      r1,#0xbb8             ;2765
00105c  2011              MOVS     r0,#0x11              ;2765
00105e  9701              STR      r7,[sp,#4]            ;2765
001060  f7fffffe          BL       TIMER_AddTask
001064  e017              B        |L8.4246|
                  |L8.4198|
001066  7960              LDRB     r0,[r4,#5]            ;2780
001068  b110              CBZ      r0,|L8.4208|
00106a  f8887120          STRB     r7,[r8,#0x120]        ;2782
00106e  e002              B        |L8.4214|
                  |L8.4208|
001070  2000              MOVS     r0,#0                 ;2786
001072  f8880120          STRB     r0,[r8,#0x120]        ;2786
                  |L8.4214|
001076  2101              MOVS     r1,#1                 ;2790
001078  2048              MOVS     r0,#0x48              ;2790
00107a  f7fffffe          BL       STS_PROTOCOL_SendCmdParamAck
00107e  e00a              B        |L8.4246|
                  |L8.4224|
001080  f8b42098          LDRH     r2,[r4,#0x98]         ;2801
001084  1ca1              ADDS     r1,r4,#2              ;2801
001086  2000              MOVS     r0,#0                 ;2801
001088  f7fffffe          BL       UART_DRIVE_AddTxArray
                  |L8.4236|
00108c  2203              MOVS     r2,#3                 ;2805
00108e  2104              MOVS     r1,#4                 ;2805
001090  480d              LDR      r0,|L8.4296|
001092  f7fffffe          BL       Vertical_Scrolling_Display
                  |L8.4246|
001096  f8b9029c          LDRH     r0,[r9,#0x29c]        ;2810
00109a  1c40              ADDS     r0,r0,#1              ;2810
00109c  b280              UXTH     r0,r0                 ;2810
00109e  2103              MOVS     r1,#3                 ;2811
0010a0  fbb0f2f1          UDIV     r2,r0,r1              ;2811
0010a4  fb010012          MLS      r0,r1,r2,r0           ;2811
0010a8  f8a9029c          STRH     r0,[r9,#0x29c]        ;2811
0010ac  b01d              ADD      sp,sp,#0x74
0010ae  e8bd8ff0          POP      {r4-r11,pc}
;;;2813   
                          ENDP

0010b2  0000              DCW      0x0000
                  |L8.4276|
                          DCD      0x40010c00
                  |L8.4280|
                          DCD      online_detection_cnt
                  |L8.4284|
                          DCD      0x40011000
                  |L8.4288|
                          DCD      ||.data||+0x20
                  |L8.4292|
                          DCD      DutTimeOut
                  |L8.4296|
                          DCD      ||.data||+0x160

                          AREA ||i.STS_PROTOCOL_ConfirmTempCmdFrameBuff||, CODE, READONLY, ALIGN=1

                  STS_PROTOCOL_ConfirmTempCmdFrameBuff PROC
;;;397    // 将临时缓冲区添加到命令帧缓冲区中，其本质操作是承认临时缓冲区数据有效
;;;398    BOOL STS_PROTOCOL_ConfirmTempCmdFrameBuff(STS_PROTOCOL_CB *pCB)
000000  2800              CMP      r0,#0
;;;399    {
000002  d01a              BEQ      |L9.58|
;;;400        STS_PROTOCOL_RX_CMD_FRAME *pCmdFrame = NULL;
;;;401    
;;;402        // 参数合法性检验
;;;403        if (NULL == pCB)
;;;404        {
;;;405            return FALSE;
;;;406        }
;;;407    
;;;408        // 临时缓冲区为空，不予添加
;;;409        pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.end];
000004  f8b0129e          LDRH     r1,[r0,#0x29e]
000008  224d              MOVS     r2,#0x4d
00000a  434a              MULS     r2,r1,r2
00000c  eb000242          ADD      r2,r0,r2,LSL #1
;;;410        if (0 == pCmdFrame->length)
000010  f8b22166          LDRH     r2,[r2,#0x166]
000014  b19a              CBZ      r2,|L9.62|
;;;411        {
;;;412            return FALSE;
;;;413        }
;;;414    
;;;415        // 添加
;;;416        pCB->rx.end++;
000016  1c49              ADDS     r1,r1,#1
000018  b289              UXTH     r1,r1
;;;417        pCB->rx.end %= STS_PROTOCOL_RX_QUEUE_SIZE;
00001a  2203              MOVS     r2,#3
00001c  fbb1f3f2          UDIV     r3,r1,r2
000020  fb021113          MLS      r1,r2,r3,r1
000024  f8a0129e          STRH     r1,[r0,#0x29e]
;;;418        pCB->rx.cmdQueue[pCB->rx.end].length = 0; // 该行的作用是将新的添加位置有效数据个数清零，以便将这个位置当做临时帧缓冲区
000028  2200              MOVS     r2,#0
00002a  234d              MOVS     r3,#0x4d
00002c  4359              MULS     r1,r3,r1
00002e  eb000041          ADD      r0,r0,r1,LSL #1
000032  f8a02166          STRH     r2,[r0,#0x166]
;;;419    
;;;420        return TRUE;
000036  2001              MOVS     r0,#1
;;;421    }
000038  4770              BX       lr
                  |L9.58|
00003a  2000              MOVS     r0,#0                 ;405
00003c  4770              BX       lr
                  |L9.62|
00003e  2000              MOVS     r0,#0                 ;412
000040  4770              BX       lr
;;;422    
                          ENDP


                          AREA ||i.STS_PROTOCOL_DataStructInit||, CODE, READONLY, ALIGN=1

                  STS_PROTOCOL_DataStructInit PROC
;;;319    // 数据结构初始化
;;;320    void STS_PROTOCOL_DataStructInit(STS_PROTOCOL_CB *pCB)
000000  2800              CMP      r0,#0
;;;321    {
000002  d027              BEQ      |L10.84|
;;;322        uint16 i;
;;;323    
;;;324        // 参数合法性检验
;;;325        if (NULL == pCB)
;;;326        {
;;;327            return;
;;;328        }
;;;329    
;;;330        pCB->tx.txBusy = FALSE;
000004  2200              MOVS     r2,#0
000006  f8802474          STRB     r2,[r0,#0x474]
;;;331        pCB->tx.index = 0;
00000a  f8a02472          STRH     r2,[r0,#0x472]
;;;332        pCB->tx.head = 0;
00000e  f8a0246e          STRH     r2,[r0,#0x46e]
;;;333        pCB->tx.end = 0;
000012  f8a02470          STRH     r2,[r0,#0x470]
;;;334        for (i = 0; i < STS_PROTOCOL_TX_QUEUE_SIZE; i++)
000016  2100              MOVS     r1,#0
                  |L10.24|
;;;335        {
;;;336            pCB->tx.cmdQueue[i].length = 0;
000018  234d              MOVS     r3,#0x4d
00001a  434b              MULS     r3,r1,r3
00001c  eb000343          ADD      r3,r0,r3,LSL #1
000020  f8a32338          STRH     r2,[r3,#0x338]
000024  1c49              ADDS     r1,r1,#1              ;334
000026  b289              UXTH     r1,r1                 ;334
000028  2903              CMP      r1,#3                 ;334
00002a  d3f5              BCC      |L10.24|
;;;337        }
;;;338    
;;;339        pCB->rxFIFO.head = 0;
00002c  f8202fc8          STRH     r2,[r0,#0xc8]!
;;;340        pCB->rxFIFO.end = 0;
000030  8042              STRH     r2,[r0,#2]
;;;341        pCB->rxFIFO.currentProcessIndex = 0;
000032  8082              STRH     r2,[r0,#4]
;;;342    
;;;343        pCB->rx.head = 0;
000034  f8a021d4          STRH     r2,[r0,#0x1d4]
;;;344        pCB->rx.end = 0;
000038  f8a021d6          STRH     r2,[r0,#0x1d6]
00003c  38c8              SUBS     r0,r0,#0xc8
;;;345        for (i = 0; i < STS_PROTOCOL_RX_QUEUE_SIZE; i++)
00003e  2100              MOVS     r1,#0
                  |L10.64|
;;;346        {
;;;347            pCB->rx.cmdQueue[i].length = 0;
000040  234d              MOVS     r3,#0x4d
000042  434b              MULS     r3,r1,r3
000044  eb000343          ADD      r3,r0,r3,LSL #1
000048  f8a32166          STRH     r2,[r3,#0x166]
00004c  1c49              ADDS     r1,r1,#1              ;345
00004e  b289              UXTH     r1,r1                 ;345
000050  2903              CMP      r1,#3                 ;345
000052  d3f5              BCC      |L10.64|
                  |L10.84|
;;;348        }
;;;349    
;;;350    //  pCB->isTimeCheck = FALSE;
;;;351    }
000054  4770              BX       lr
;;;352    
                          ENDP


                          AREA ||i.STS_PROTOCOL_Init||, CODE, READONLY, ALIGN=2

                  STS_PROTOCOL_Init PROC
;;;224    // 协议初始化
;;;225    void STS_PROTOCOL_Init(void)
000000  b510              PUSH     {r4,lr}
;;;226    {
;;;227        // 协议层数据结构初始化
;;;228        STS_PROTOCOL_DataStructInit(&STSProtocolCB);
000002  4805              LDR      r0,|L11.24|
000004  f7fffffe          BL       STS_PROTOCOL_DataStructInit
;;;229    
;;;230        // 向驱动层注册数据接收接口
;;;231        STS_UART_RegisterDataSendService(STS_PROTOCOL_MacProcess);
000008  4804              LDR      r0,|L11.28|
00000a  f7fffffe          BL       STS_UART_RegisterDataSendService
;;;232    
;;;233        // 向驱动层注册数据发送接口
;;;234        STS_PROTOCOL_RegisterDataSendService(STS_UART_AddTxArray);
00000e  e8bd4010          POP      {r4,lr}
000012  4803              LDR      r0,|L11.32|
000014  f7ffbffe          B.W      STS_PROTOCOL_RegisterDataSendService
;;;235    }
;;;236    
                          ENDP

                  |L11.24|
                          DCD      ||.bss||+0x78
                  |L11.28|
                          DCD      STS_PROTOCOL_MacProcess
                  |L11.32|
                          DCD      STS_UART_AddTxArray

                          AREA ||i.STS_PROTOCOL_MacProcess||, CODE, READONLY, ALIGN=2

                  STS_PROTOCOL_MacProcess PROC
;;;353    // UART报文接收处理函数(注意根据具体模块修改)
;;;354    void STS_PROTOCOL_MacProcess(uint16 standarID, uint8 *pData, uint16 length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;355    {
;;;356        uint16 end = STSProtocolCB.rxFIFO.end;
000004  4c15              LDR      r4,|L12.92|
000006  f8b450ca          LDRH     r5,[r4,#0xca]  ; STSProtocolCB
;;;357        uint16 head = STSProtocolCB.rxFIFO.head;
00000a  f8b460c8          LDRH     r6,[r4,#0xc8]  ; STSProtocolCB
;;;358        uint8 rxdata = 0x00;
;;;359    
;;;360        // 接收数据
;;;361        rxdata = *pData;
00000e  780f              LDRB     r7,[r1,#0]
;;;362    
;;;363        if (dut_info.passThroughControl)
000010  4b13              LDR      r3,|L12.96|
000012  f893c120          LDRB     r12,[r3,#0x120]  ; dut_info
000016  f1bc0f00          CMP      r12,#0
00001a  d00a              BEQ      |L12.50|
;;;364        {
;;;365            if (dut_info.dutBusType)
00001c  7e9b              LDRB     r3,[r3,#0x1a]  ; dut_info
00001e  b133              CBZ      r3,|L12.46|
;;;366            {
;;;367                CAN_TEST_DRIVE_AddTxArray(standarID, pData, length);
000020  b2d2              UXTB     r2,r2
000022  f7fffffe          BL       CAN_TEST_DRIVE_AddTxArray
;;;368                testFlag = TRUE;
000026  490f              LDR      r1,|L12.100|
000028  2001              MOVS     r0,#1
00002a  7088              STRB     r0,[r1,#2]
00002c  e001              B        |L12.50|
                  |L12.46|
;;;369            }
;;;370            else
;;;371            {
;;;372                UART_DRIVE_AddTxArray(standarID, pData, length);
00002e  f7fffffe          BL       UART_DRIVE_AddTxArray
                  |L12.50|
;;;373            }
;;;374        }
;;;375    
;;;376        // 一级缓冲区已满，不予接收
;;;377        if ((end + 1) % STS_PROTOCOL_RX_FIFO_SIZE == head)
000032  1c68              ADDS     r0,r5,#1
000034  21c8              MOVS     r1,#0xc8
000036  fbb0f2f1          UDIV     r2,r0,r1
00003a  fb010012          MLS      r0,r1,r2,r0
00003e  42b0              CMP      r0,r6
000040  d00a              BEQ      |L12.88|
;;;378        {
;;;379            return;
;;;380        }
;;;381        // 一级缓冲区未满，接收
;;;382        else
;;;383        {
;;;384            // 将接收到的数据放到临时缓冲区中
;;;385            STSProtocolCB.rxFIFO.buff[end] = rxdata;
000042  5567              STRB     r7,[r4,r5]
;;;386            STSProtocolCB.rxFIFO.end++;
000044  f8340fca          LDRH     r0,[r4,#0xca]!  ; STSProtocolCB
000048  1c40              ADDS     r0,r0,#1
00004a  8020              STRH     r0,[r4,#0]
;;;387            STSProtocolCB.rxFIFO.end %= STS_PROTOCOL_RX_FIFO_SIZE;
00004c  8820              LDRH     r0,[r4,#0]  ; STSProtocolCB
00004e  fbb0f2f1          UDIV     r2,r0,r1
000052  fb010012          MLS      r0,r1,r2,r0
000056  8020              STRH     r0,[r4,#0]
                  |L12.88|
;;;388        }
;;;389    }
000058  e8bd81f0          POP      {r4-r8,pc}
;;;390    
                          ENDP

                  |L12.92|
                          DCD      ||.bss||+0x78
                  |L12.96|
                          DCD      dut_info
                  |L12.100|
                          DCD      ||.data||

                          AREA ||i.STS_PROTOCOL_Process||, CODE, READONLY, ALIGN=2

                  STS_PROTOCOL_Process PROC
;;;237    // STS协议层过程处理
;;;238    void STS_PROTOCOL_Process(void)
000000  b510              PUSH     {r4,lr}
;;;239    {
;;;240        // STS接收FIFO缓冲区处理
;;;241        STS_PROTOCOL_RxFIFOProcess(&STSProtocolCB);
000002  4805              LDR      r0,|L13.24|
000004  f7fffffe          BL       STS_PROTOCOL_RxFIFOProcess
;;;242    
;;;243        // STS接收命令缓冲区处理
;;;244        STS_PROTOCOL_CmdFrameProcess(&STSProtocolCB);
000008  4803              LDR      r0,|L13.24|
00000a  f7fffffe          BL       STS_PROTOCOL_CmdFrameProcess
;;;245    
;;;246        // STS协议层发送处理过程
;;;247        STS_PROTOCOL_TxStateProcess();
00000e  e8bd4010          POP      {r4,lr}
000012  f7ffbffe          B.W      STS_PROTOCOL_TxStateProcess
;;;248    }
;;;249    
                          ENDP

000016  0000              DCW      0x0000
                  |L13.24|
                          DCD      ||.bss||+0x78

                          AREA ||i.STS_PROTOCOL_RegisterDataSendService||, CODE, READONLY, ALIGN=2

                  STS_PROTOCOL_RegisterDataSendService PROC
;;;391    // UART协议层向驱动层注册数据发送接口
;;;392    void STS_PROTOCOL_RegisterDataSendService(BOOL (*service)(uint16 id, uint8 *pData, uint16 length))
000000  4901              LDR      r1,|L14.8|
;;;393    {
;;;394        STSProtocolCB.sendDataThrowService = service;
000002  f8c10478          STR      r0,[r1,#0x478]  ; STSProtocolCB
;;;395    }
000006  4770              BX       lr
;;;396    
                          ENDP

                  |L14.8|
                          DCD      ||.bss||+0x78

                          AREA ||i.STS_PROTOCOL_RxFIFOProcess||, CODE, READONLY, ALIGN=1

                  STS_PROTOCOL_RxFIFOProcess PROC
;;;456    // 一级接收缓冲区处理，从一级接收缓冲区中取出一个字节添加到命令帧缓冲区中
;;;457    void STS_PROTOCOL_RxFIFOProcess(STS_PROTOCOL_CB *pCB)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;458    {
000004  4604              MOV      r4,r0
;;;459        uint16 end = pCB->rxFIFO.end;
000006  f8b410ca          LDRH     r1,[r4,#0xca]
;;;460        uint16 head = pCB->rxFIFO.head;
00000a  f8b400c8          LDRH     r0,[r4,#0xc8]
;;;461        STS_PROTOCOL_RX_CMD_FRAME *pCmdFrame = NULL;
;;;462        uint16 length = 0;
;;;463        uint8 currentData = 0;
;;;464    
;;;465        // 参数合法性检验
;;;466        if (NULL == pCB)
00000e  2c00              CMP      r4,#0
000010  d021              BEQ      |L15.86|
;;;467        {
;;;468            return;
;;;469        }
;;;470    
;;;471        // 一级缓冲区为空，退出
;;;472        if (head == end)
000012  4288              CMP      r0,r1
000014  d01f              BEQ      |L15.86|
;;;473        {
;;;474            return;
;;;475        }
;;;476    
;;;477        // 获取临时缓冲区指针
;;;478        pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.end];
000016  f8b4229e          LDRH     r2,[r4,#0x29e]
00001a  204d              MOVS     r0,#0x4d
00001c  4350              MULS     r0,r2,r0
00001e  eb040540          ADD      r5,r4,r0,LSL #1
000022  35ce              ADDS     r5,r5,#0xce
;;;479    
;;;480        // 取出当前要处理的字节
;;;481        currentData = pCB->rxFIFO.buff[pCB->rxFIFO.currentProcessIndex];
000024  f8b400cc          LDRH     r0,[r4,#0xcc]
000028  5c20              LDRB     r0,[r4,r0]
;;;482    
;;;483        // 临时缓冲区长度为0时，搜索首字节
;;;484        if (0 == pCmdFrame->length)
00002a  f8b53098          LDRH     r3,[r5,#0x98]
;;;485        {
;;;486            // 命令头错误，删除当前字节并退出
;;;487            if (STS_PROTOCOL_CMD_HEAD != currentData)
;;;488            {
;;;489                pCB->rxFIFO.head++;
;;;490                pCB->rxFIFO.head %= STS_PROTOCOL_RX_FIFO_SIZE;
00002e  27c8              MOVS     r7,#0xc8
000030  b19b              CBZ      r3,|L15.90|
;;;491                pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;492    
;;;493                return;
;;;494            }
;;;495    
;;;496            // 命令头正确，但无临时缓冲区可用，退出
;;;497            if ((pCB->rx.end + 1) % STS_PROTOCOL_RX_QUEUE_SIZE == pCB->rx.head)
;;;498            {
;;;499                return;
;;;500            }
;;;501    
;;;502            // 添加UART通讯超时时间设置-2016.1.5增加
;;;503    #if BLE_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;504            TIMER_AddTask(TIMER_ID_UART_RX_TIME_OUT_CONTROL,
;;;505                          BLE_PROTOCOL_BUS_UNIDIRECTIONAL_TIME_OUT,
;;;506                          BLE_PROTOCOL_CALLBACK_RxTimeOut,
;;;507                          0,
;;;508                          1,
;;;509                          ACTION_MODE_ADD_TO_QUEUE);
;;;510    #endif
;;;511    
;;;512            // 命令头正确，有临时缓冲区可用，则将其添加到命令帧临时缓冲区中
;;;513            pCmdFrame->buff[pCmdFrame->length++] = currentData;
;;;514            pCB->rxFIFO.currentProcessIndex++;
;;;515            pCB->rxFIFO.currentProcessIndex %= STS_PROTOCOL_RX_FIFO_SIZE;
;;;516        }
;;;517        // 非首字节，将数据添加到命令帧临时缓冲区中，但暂不删除当前数据
;;;518        else
;;;519        {
;;;520            // 临时缓冲区溢出，说明当前正在接收的命令帧是错误的，正确的命令帧不会出现长度溢出的情况
;;;521            if (pCmdFrame->length >= STS_PROTOCOL_RX_CMD_FRAME_LENGTH_MAX)
000032  f04f0800          MOV      r8,#0
000036  2b96              CMP      r3,#0x96
000038  d37e              BCC      |L15.312|
;;;522            {
;;;523    #if BLE_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;524                // 停止RX通讯超时检测
;;;525                BLE_PROTOCOL_StopRxTimeOutCheck();
;;;526    #endif
;;;527    
;;;528                // 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;529                pCmdFrame->length = 0; // 2016.1.5增加
00003a  f8a58098          STRH     r8,[r5,#0x98]
;;;530    
;;;531                // 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;532                pCB->rxFIFO.head++;
00003e  f8340fc8          LDRH     r0,[r4,#0xc8]!
000042  1c40              ADDS     r0,r0,#1
000044  8020              STRH     r0,[r4,#0]
;;;533                pCB->rxFIFO.head %= STS_PROTOCOL_RX_FIFO_SIZE;
000046  8820              LDRH     r0,[r4,#0]
000048  fbb0f1f7          UDIV     r1,r0,r7
00004c  fb070011          MLS      r0,r7,r1,r0
000050  8020              STRH     r0,[r4,#0]
;;;534                pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
000052  8820              LDRH     r0,[r4,#0]
000054  80a0              STRH     r0,[r4,#4]
                  |L15.86|
;;;535    
;;;536                return;
;;;537            }
;;;538    
;;;539            // 一直取到末尾
;;;540            while (end != pCB->rxFIFO.currentProcessIndex)
;;;541            {
;;;542                // 取出当前要处理的字节
;;;543                currentData = pCB->rxFIFO.buff[pCB->rxFIFO.currentProcessIndex];
;;;544    
;;;545                // 缓冲区未溢出，正常接收，将数据添加到临时缓冲区中
;;;546                pCmdFrame->buff[pCmdFrame->length++] = currentData;
;;;547                pCB->rxFIFO.currentProcessIndex++;
;;;548                pCB->rxFIFO.currentProcessIndex %= STS_PROTOCOL_RX_FIFO_SIZE;
;;;549    
;;;550                // ■■接下来，需要检查命令帧是否完整，如果完整，则将命令帧临时缓冲区扶正 ■■
;;;551    
;;;552                // 首先判断命令帧最小长度，一个完整的命令字至少包括4个字节: 命令头、命令字、数据长度
;;;553                if (pCmdFrame->length < STS_PROTOCOL_CMD_FRAME_LENGTH_MIN)
;;;554                {
;;;555                    // 继续接收
;;;556                    continue;
;;;557                }
;;;558    
;;;559                // 命令帧长度数值越界，说明当前命令帧错误，停止接收
;;;560                if (pCmdFrame->buff[STS_PROTOCOL_CMD_LENGTH_INDEX] > (STS_PROTOCOL_RX_CMD_FRAME_LENGTH_MAX - STS_PROTOCOL_CMD_FRAME_LENGTH_MIN))
;;;561                {
;;;562    #if BLE_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;563                    // 停止RX通讯超时检测
;;;564                    BLE_PROTOCOL_StopRxTimeOutCheck();
;;;565    #endif
;;;566    
;;;567                    // 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;568                    pCmdFrame->length = 0;
;;;569    
;;;570                    // 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;571                    pCB->rxFIFO.head++;
;;;572                    pCB->rxFIFO.head %= STS_PROTOCOL_RX_FIFO_SIZE;
;;;573                    pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;574    
;;;575                    return;
;;;576                }
;;;577    
;;;578                // 命令帧长度校验
;;;579                length = pCmdFrame->length;
;;;580                if (length < pCmdFrame->buff[STS_PROTOCOL_CMD_LENGTH_INDEX] + STS_PROTOCOL_CMD_FRAME_LENGTH_MIN)
;;;581                {
;;;582                    // 长度要求不一致，说明未接收完毕，退出继续
;;;583                    continue;
;;;584                }
;;;585    
;;;586                // 命令帧长度OK，则进行校验，失败时删除命令头
;;;587                if (!STS_PROTOCOL_CheckSUM(pCmdFrame))
;;;588                {
;;;589    #if BLE_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;590                    // 停止RX通讯超时检测
;;;591                    BLE_PROTOCOL_StopRxTimeOutCheck();
;;;592    #endif
;;;593    
;;;594                    // 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;595                    pCmdFrame->length = 0;
;;;596    
;;;597                    // 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;598                    pCB->rxFIFO.head++;
;;;599                    pCB->rxFIFO.head %= STS_PROTOCOL_RX_FIFO_SIZE;
;;;600                    pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;601    
;;;602                    return;
;;;603                }
;;;604    
;;;605    #if BLE_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;606                // 停止RX通讯超时检测
;;;607                BLE_PROTOCOL_StopRxTimeOutCheck();
;;;608    #endif
;;;609                // 执行到这里，即说明接收到了一个完整并且正确的命令帧，此时需将处理过的数据从一级缓冲区中删除，并将该命令帧扶正
;;;610                pCB->rxFIFO.head += length;
;;;611                pCB->rxFIFO.head %= STS_PROTOCOL_RX_FIFO_SIZE;
;;;612                pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;613                STS_PROTOCOL_ConfirmTempCmdFrameBuff(pCB);
;;;614    
;;;615                return;
;;;616            }
;;;617        }
;;;618    }
000056  e8bd81f0          POP      {r4-r8,pc}
                  |L15.90|
00005a  2855              CMP      r0,#0x55              ;487
00005c  d00c              BEQ      |L15.120|
00005e  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;489
000062  1c40              ADDS     r0,r0,#1              ;489
000064  8020              STRH     r0,[r4,#0]            ;489
000066  8820              LDRH     r0,[r4,#0]            ;490
000068  fbb0f1f7          UDIV     r1,r0,r7              ;490
00006c  fb070011          MLS      r0,r7,r1,r0           ;490
000070  8020              STRH     r0,[r4,#0]            ;490
000072  8820              LDRH     r0,[r4,#0]            ;491
000074  80a0              STRH     r0,[r4,#4]            ;491
000076  e7ee              B        |L15.86|
                  |L15.120|
000078  1c52              ADDS     r2,r2,#1              ;497
00007a  2103              MOVS     r1,#3                 ;497
00007c  fbb2f3f1          UDIV     r3,r2,r1              ;497
000080  fb012113          MLS      r1,r1,r3,r2           ;497
000084  f8b4229c          LDRH     r2,[r4,#0x29c]        ;497
000088  4291              CMP      r1,r2                 ;497
00008a  d0e4              BEQ      |L15.86|
00008c  2101              MOVS     r1,#1                 ;513
00008e  f8a51098          STRH     r1,[r5,#0x98]         ;513
000092  70a8              STRB     r0,[r5,#2]            ;513
000094  f8340fcc          LDRH     r0,[r4,#0xcc]!        ;514
000098  1c40              ADDS     r0,r0,#1              ;514
00009a  b280              UXTH     r0,r0                 ;514
00009c  fbb0f1f7          UDIV     r1,r0,r7              ;515
0000a0  fb070011          MLS      r0,r7,r1,r0           ;515
0000a4  8020              STRH     r0,[r4,#0]            ;515
0000a6  e7d6              B        |L15.86|
                  |L15.168|
0000a8  5c22              LDRB     r2,[r4,r0]            ;543
0000aa  f8b50098          LDRH     r0,[r5,#0x98]         ;546
0000ae  1c43              ADDS     r3,r0,#1              ;546
0000b0  4428              ADD      r0,r0,r5              ;546
0000b2  f8a53098          STRH     r3,[r5,#0x98]         ;546
0000b6  7082              STRB     r2,[r0,#2]            ;546
0000b8  f8b400cc          LDRH     r0,[r4,#0xcc]         ;547
0000bc  1c40              ADDS     r0,r0,#1              ;547
0000be  b280              UXTH     r0,r0                 ;547
0000c0  fbb0f2f7          UDIV     r2,r0,r7              ;548
0000c4  fb070012          MLS      r0,r7,r2,r0           ;548
0000c8  f8a400cc          STRH     r0,[r4,#0xcc]         ;548
0000cc  f8b56098          LDRH     r6,[r5,#0x98]         ;553
0000d0  2e04              CMP      r6,#4                 ;553
0000d2  d33b              BCC      |L15.332|
0000d4  7928              LDRB     r0,[r5,#4]            ;560
0000d6  2892              CMP      r0,#0x92              ;560
0000d8  d90e              BLS      |L15.248|
0000da  f8a58098          STRH     r8,[r5,#0x98]         ;568
0000de  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;571
0000e2  1c40              ADDS     r0,r0,#1              ;571
0000e4  8020              STRH     r0,[r4,#0]            ;571
0000e6  8820              LDRH     r0,[r4,#0]            ;572
0000e8  fbb0f1f7          UDIV     r1,r0,r7              ;572
0000ec  fb070011          MLS      r0,r7,r1,r0           ;572
0000f0  8020              STRH     r0,[r4,#0]            ;572
0000f2  8820              LDRH     r0,[r4,#0]            ;573
0000f4  80a0              STRH     r0,[r4,#4]            ;573
0000f6  e7ae              B        |L15.86|
                  |L15.248|
0000f8  1d00              ADDS     r0,r0,#4              ;580
0000fa  42b0              CMP      r0,r6                 ;580
0000fc  d826              BHI      |L15.332|
0000fe  4628              MOV      r0,r5                 ;587
000100  f7fffffe          BL       STS_PROTOCOL_CheckSUM
000104  b188              CBZ      r0,|L15.298|
000106  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;610
00010a  4430              ADD      r0,r0,r6              ;610
00010c  8020              STRH     r0,[r4,#0]            ;610
00010e  8820              LDRH     r0,[r4,#0]            ;611
000110  fbb0f1f7          UDIV     r1,r0,r7              ;611
000114  fb070011          MLS      r0,r7,r1,r0           ;611
000118  8020              STRH     r0,[r4,#0]            ;611
00011a  8820              LDRH     r0,[r4,#0]            ;612
00011c  80a0              STRH     r0,[r4,#4]            ;612
00011e  3cc8              SUBS     r4,r4,#0xc8           ;612
000120  4620              MOV      r0,r4                 ;613
000122  e8bd41f0          POP      {r4-r8,lr}            ;613
000126  f7ffbffe          B.W      STS_PROTOCOL_ConfirmTempCmdFrameBuff
                  |L15.298|
00012a  f8a58098          STRH     r8,[r5,#0x98]         ;595
00012e  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;598
000132  1c40              ADDS     r0,r0,#1              ;598
000134  8020              STRH     r0,[r4,#0]            ;598
000136  e000              B        |L15.314|
                  |L15.312|
000138  e008              B        |L15.332|
                  |L15.314|
00013a  8820              LDRH     r0,[r4,#0]            ;599
00013c  fbb0f1f7          UDIV     r1,r0,r7              ;599
000140  fb070011          MLS      r0,r7,r1,r0           ;599
000144  8020              STRH     r0,[r4,#0]            ;599
000146  8820              LDRH     r0,[r4,#0]            ;600
000148  80a0              STRH     r0,[r4,#4]            ;600
00014a  e784              B        |L15.86|
                  |L15.332|
00014c  f8b400cc          LDRH     r0,[r4,#0xcc]         ;540
000150  4288              CMP      r0,r1                 ;540
000152  d1a9              BNE      |L15.168|
000154  e77f              B        |L15.86|
;;;619    
                          ENDP


                          AREA ||i.STS_PROTOCOL_SendCmdAck||, CODE, READONLY, ALIGN=1

                  STS_PROTOCOL_SendCmdAck PROC
;;;2851   // 发送命令回复
;;;2852   void STS_PROTOCOL_SendCmdAck(uint8 ackCmd)
000000  b510              PUSH     {r4,lr}
;;;2853   {
000002  4604              MOV      r4,r0
;;;2854       STS_PROTOCOL_TxAddData(STS_PROTOCOL_CMD_HEAD);
000004  2055              MOVS     r0,#0x55
000006  f7fffffe          BL       STS_PROTOCOL_TxAddData
;;;2855       STS_PROTOCOL_TxAddData(ackCmd);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       STS_PROTOCOL_TxAddData
;;;2856       STS_PROTOCOL_TxAddData(0x00);
000010  2000              MOVS     r0,#0
000012  f7fffffe          BL       STS_PROTOCOL_TxAddData
;;;2857       STS_PROTOCOL_TxAddFrame();
000016  e8bd4010          POP      {r4,lr}
00001a  f7ffbffe          B.W      STS_PROTOCOL_TxAddFrame
;;;2858   }
;;;2859   
                          ENDP


                          AREA ||i.STS_PROTOCOL_SendCmdParamAck||, CODE, READONLY, ALIGN=1

                  STS_PROTOCOL_SendCmdParamAck PROC
;;;2860   // 发送命令回复，带一个参数
;;;2861   void STS_PROTOCOL_SendCmdParamAck(uint8 ackCmd, uint8 ackParam)
000000  b530              PUSH     {r4,r5,lr}
;;;2862   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;2863       STS_PROTOCOL_TxAddData(STS_PROTOCOL_CMD_HEAD);
000006  2055              MOVS     r0,#0x55
000008  f7fffffe          BL       STS_PROTOCOL_TxAddData
;;;2864       STS_PROTOCOL_TxAddData(ackCmd);
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       STS_PROTOCOL_TxAddData
;;;2865       STS_PROTOCOL_TxAddData(0x01);
000012  2001              MOVS     r0,#1
000014  f7fffffe          BL       STS_PROTOCOL_TxAddData
;;;2866       STS_PROTOCOL_TxAddData(ackParam);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       STS_PROTOCOL_TxAddData
;;;2867       STS_PROTOCOL_TxAddFrame();
00001e  e8bd4030          POP      {r4,r5,lr}
000022  f7ffbffe          B.W      STS_PROTOCOL_TxAddFrame
;;;2868   }
;;;2869   
                          ENDP


                          AREA ||i.STS_PROTOCOL_SendCmdParamTwoAck||, CODE, READONLY, ALIGN=1

                  STS_PROTOCOL_SendCmdParamTwoAck PROC
;;;2870   // 发送命令回复，带两个参数
;;;2871   void STS_PROTOCOL_SendCmdParamTwoAck(uint8 ackCmd, uint8 ackParam, uint8 twoParam)
000000  b570              PUSH     {r4-r6,lr}
;;;2872   {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;2873       STS_PROTOCOL_TxAddData(STS_PROTOCOL_CMD_HEAD);
000008  2055              MOVS     r0,#0x55
00000a  f7fffffe          BL       STS_PROTOCOL_TxAddData
;;;2874       STS_PROTOCOL_TxAddData(ackCmd);
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       STS_PROTOCOL_TxAddData
;;;2875       STS_PROTOCOL_TxAddData(0x02);
000014  2002              MOVS     r0,#2
000016  f7fffffe          BL       STS_PROTOCOL_TxAddData
;;;2876       STS_PROTOCOL_TxAddData(ackParam);
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       STS_PROTOCOL_TxAddData
;;;2877       STS_PROTOCOL_TxAddData(twoParam);
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       STS_PROTOCOL_TxAddData
;;;2878       STS_PROTOCOL_TxAddFrame();
000026  e8bd4070          POP      {r4-r6,lr}
00002a  f7ffbffe          B.W      STS_PROTOCOL_TxAddFrame
;;;2879   }
;;;2880   
                          ENDP


                          AREA ||i.STS_PROTOCOL_TxAddData||, CODE, READONLY, ALIGN=2

                  STS_PROTOCOL_TxAddData PROC
;;;250    // 向发送命令帧队列中添加数据
;;;251    void STS_PROTOCOL_TxAddData(uint8 data)
000000  b530              PUSH     {r4,r5,lr}
;;;252    {
;;;253        uint16 head = STSProtocolCB.tx.head;
000002  490f              LDR      r1,|L19.64|
000004  f8b1446e          LDRH     r4,[r1,#0x46e]  ; STSProtocolCB
;;;254        uint16 end = STSProtocolCB.tx.end;
000008  f8b12470          LDRH     r2,[r1,#0x470]  ; STSProtocolCB
;;;255        STS_PROTOCOL_TX_CMD_FRAME *pCmdFrame = &STSProtocolCB.tx.cmdQueue[STSProtocolCB.tx.end];
00000c  234d              MOVS     r3,#0x4d
00000e  4353              MULS     r3,r2,r3
000010  eb010143          ADD      r1,r1,r3,LSL #1
000014  f5017128          ADD      r1,r1,#0x2a0
;;;256    
;;;257        // 发送缓冲区已满，不予接收
;;;258        if ((end + 1) % STS_PROTOCOL_TX_QUEUE_SIZE == head)
000018  1c52              ADDS     r2,r2,#1
00001a  2303              MOVS     r3,#3
00001c  fbb2f5f3          UDIV     r5,r2,r3
000020  fb032215          MLS      r2,r3,r5,r2
000024  42a2              CMP      r2,r4
000026  d009              BEQ      |L19.60|
;;;259        {
;;;260            return;
;;;261        }
;;;262    
;;;263        // 队尾命令帧已满，退出
;;;264        if (pCmdFrame->length >= STS_PROTOCOL_TX_CMD_FRAME_LENGTH_MAX)
000028  f8b12098          LDRH     r2,[r1,#0x98]
00002c  2a96              CMP      r2,#0x96
00002e  d205              BCS      |L19.60|
;;;265        {
;;;266            return;
;;;267        }
;;;268    
;;;269        // 数据添加到帧末尾，并更新帧长度
;;;270        pCmdFrame->buff[pCmdFrame->length] = data;
000030  1c8b              ADDS     r3,r1,#2
000032  54d0              STRB     r0,[r2,r3]
;;;271        pCmdFrame->length++;
000034  f8310f98          LDRH     r0,[r1,#0x98]!
000038  1c40              ADDS     r0,r0,#1
00003a  8008              STRH     r0,[r1,#0]
                  |L19.60|
;;;272    }
00003c  bd30              POP      {r4,r5,pc}
;;;273    
                          ENDP

00003e  0000              DCW      0x0000
                  |L19.64|
                          DCD      ||.bss||+0x78

                          AREA ||i.STS_PROTOCOL_TxAddFrame||, CODE, READONLY, ALIGN=2

                  STS_PROTOCOL_TxAddFrame PROC
;;;274    // 确认添加命令帧，即承认之前填充的数据为命令帧，将其添加到发送队列中，由main进行调度发送，本函数内会自动校正命令长度，并添加校验码
;;;275    void STS_PROTOCOL_TxAddFrame(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;276    {
;;;277        uint16 cc = 0;
000002  2300              MOVS     r3,#0
;;;278        uint16 i = 0;
000004  2100              MOVS     r1,#0
;;;279        uint16 head = STSProtocolCB.tx.head;
000006  4d20              LDR      r5,|L20.136|
000008  f8b5746e          LDRH     r7,[r5,#0x46e]  ; STSProtocolCB
;;;280        uint16 end = STSProtocolCB.tx.end;
00000c  f8b54470          LDRH     r4,[r5,#0x470]  ; STSProtocolCB
;;;281        STS_PROTOCOL_TX_CMD_FRAME *pCmdFrame = &STSProtocolCB.tx.cmdQueue[STSProtocolCB.tx.end];
000010  204d              MOVS     r0,#0x4d
000012  4360              MULS     r0,r4,r0
000014  eb050040          ADD      r0,r5,r0,LSL #1
000018  f5007028          ADD      r0,r0,#0x2a0
;;;282        uint16 length = pCmdFrame->length;
00001c  f8b02098          LDRH     r2,[r0,#0x98]
;;;283    
;;;284        // 发送缓冲区已满，不予接收
;;;285        if ((end + 1) % STS_PROTOCOL_TX_QUEUE_SIZE == head)
000020  1c64              ADDS     r4,r4,#1
000022  2603              MOVS     r6,#3
000024  fbb4fcf6          UDIV     r12,r4,r6
000028  fb06441c          MLS      r4,r6,r12,r4
00002c  42bc              CMP      r4,r7
00002e  d00d              BEQ      |L20.76|
;;;286        {
;;;287            return;
;;;288        }
;;;289    
;;;290        // 队尾命令帧已满，退出
;;;291        if ((length >= STS_PROTOCOL_TX_CMD_FRAME_LENGTH_MAX) || (length + 1 >= STS_PROTOCOL_TX_CMD_FRAME_LENGTH_MAX)
000030  2a96              CMP      r2,#0x96
000032  d208              BCS      |L20.70|
000034  1c54              ADDS     r4,r2,#1
000036  2c96              CMP      r4,#0x96
000038  d205              BCS      |L20.70|
;;;292                || (length + 2 >= STS_PROTOCOL_TX_CMD_FRAME_LENGTH_MAX) || (length + 3 >= STS_PROTOCOL_TX_CMD_FRAME_LENGTH_MAX))
00003a  1c94              ADDS     r4,r2,#2
00003c  2c96              CMP      r4,#0x96
00003e  d202              BCS      |L20.70|
000040  1cd4              ADDS     r4,r2,#3
000042  2c96              CMP      r4,#0x96
000044  d303              BCC      |L20.78|
                  |L20.70|
;;;293        {
;;;294            pCmdFrame->length = 0;
000046  2100              MOVS     r1,#0
000048  f8a01098          STRH     r1,[r0,#0x98]
                  |L20.76|
;;;295    
;;;296            return;
;;;297        }
;;;298    
;;;299        // 队尾命令帧已满，退出
;;;300        if (length >= STS_PROTOCOL_TX_CMD_FRAME_LENGTH_MAX)
;;;301        {
;;;302            return;
;;;303        }
;;;304    
;;;305        // 重新设置数据长度，系统在准备数据时，填充的"数据长度"可以为任意值，并且不需要添加校验码，在这里重新设置为正确的值
;;;306        pCmdFrame->buff[STS_PROTOCOL_CMD_LENGTH_INDEX] = length - 3;   // 重设数据长度，减去"命令头、命令字、数据长度"4个字节
;;;307    
;;;308        for (i = 0; i < length; i++)
;;;309        {
;;;310            cc ^= pCmdFrame->buff[i];
;;;311        }
;;;312        pCmdFrame->buff[pCmdFrame->length++] = cc ;
;;;313    
;;;314        STSProtocolCB.tx.end++;
;;;315        STSProtocolCB.tx.end %= STS_PROTOCOL_TX_QUEUE_SIZE;
;;;316        // pCB->tx.cmdQueue[pCB->tx.end].length = 0;   //2015.12.2修改
;;;317    }
00004c  bdf0              POP      {r4-r7,pc}
                  |L20.78|
00004e  1ed4              SUBS     r4,r2,#3              ;306
000050  7104              STRB     r4,[r0,#4]            ;306
000052  e004              B        |L20.94|
                  |L20.84|
000054  1844              ADDS     r4,r0,r1              ;310
000056  78a4              LDRB     r4,[r4,#2]            ;310
000058  4063              EORS     r3,r3,r4              ;310
00005a  1c49              ADDS     r1,r1,#1              ;308
00005c  b289              UXTH     r1,r1                 ;308
                  |L20.94|
00005e  4291              CMP      r1,r2                 ;308
000060  d3f8              BCC      |L20.84|
000062  f8b01098          LDRH     r1,[r0,#0x98]         ;312
000066  1c4a              ADDS     r2,r1,#1              ;312
000068  f8a02098          STRH     r2,[r0,#0x98]         ;312
00006c  4408              ADD      r0,r0,r1              ;312
00006e  7083              STRB     r3,[r0,#2]            ;312
000070  f8b50470          LDRH     r0,[r5,#0x470]        ;314  ; STSProtocolCB
000074  1c40              ADDS     r0,r0,#1              ;314
000076  b280              UXTH     r0,r0                 ;314
000078  fbb0f1f6          UDIV     r1,r0,r6              ;315
00007c  fb060011          MLS      r0,r6,r1,r0           ;315
000080  f8a50470          STRH     r0,[r5,#0x470]        ;315
000084  bdf0              POP      {r4-r7,pc}
;;;318    
                          ENDP

000086  0000              DCW      0x0000
                  |L20.136|
                          DCD      ||.bss||+0x78

                          AREA ||i.STS_PROTOCOL_TxStateProcess||, CODE, READONLY, ALIGN=2

                  STS_PROTOCOL_TxStateProcess PROC
;;;423    // 协议层发送处理过程
;;;424    void STS_PROTOCOL_TxStateProcess(void)
000000  b570              PUSH     {r4-r6,lr}
;;;425    {
;;;426        uint16 head = STSProtocolCB.tx.head;
000002  4c14              LDR      r4,|L21.84|
000004  f8b4346e          LDRH     r3,[r4,#0x46e]  ; STSProtocolCB
;;;427        uint16 end = STSProtocolCB.tx.end;
000008  f8b46470          LDRH     r6,[r4,#0x470]  ; STSProtocolCB
;;;428        uint16 length = STSProtocolCB.tx.cmdQueue[head].length;
00000c  204d              MOVS     r0,#0x4d
00000e  4358              MULS     r0,r3,r0
000010  eb040040          ADD      r0,r4,r0,LSL #1
000014  4605              MOV      r5,r0
000016  f8b02338          LDRH     r2,[r0,#0x338]
;;;429        uint8 *pCmd = STSProtocolCB.tx.cmdQueue[head].buff;
00001a  f20021a2          ADD      r1,r0,#0x2a2
;;;430        uint16 localDeviceID = STSProtocolCB.tx.cmdQueue[head].deviceID;
00001e  f8b002a0          LDRH     r0,[r0,#0x2a0]
;;;431    
;;;432        // 发送缓冲区为空，说明无数据
;;;433        if (head == end)
000022  42b3              CMP      r3,r6
000024  d014              BEQ      |L21.80|
;;;434        {
;;;435            return;
;;;436        }
;;;437    
;;;438        // 发送函数没有注册直接返回
;;;439        if (NULL == STSProtocolCB.sendDataThrowService)
000026  f8d43478          LDR      r3,[r4,#0x478]  ; STSProtocolCB
00002a  2b00              CMP      r3,#0
00002c  d010              BEQ      |L21.80|
;;;440        {
;;;441            return;
;;;442        }
;;;443    
;;;444        // 协议层有数据需要发送到驱动层
;;;445        if (!(*STSProtocolCB.sendDataThrowService)(localDeviceID, pCmd, length))
00002e  4798              BLX      r3
000030  2800              CMP      r0,#0
000032  d00d              BEQ      |L21.80|
;;;446        {
;;;447            return;
;;;448        }
;;;449    
;;;450        // 发送环形队列更新位置
;;;451        STSProtocolCB.tx.cmdQueue[head].length = 0;
000034  2000              MOVS     r0,#0
000036  f8a50338          STRH     r0,[r5,#0x338]
;;;452        STSProtocolCB.tx.head++;
00003a  f8b4046e          LDRH     r0,[r4,#0x46e]  ; STSProtocolCB
00003e  1c40              ADDS     r0,r0,#1
000040  b280              UXTH     r0,r0
;;;453        STSProtocolCB.tx.head %= STS_PROTOCOL_TX_QUEUE_SIZE;
000042  2103              MOVS     r1,#3
000044  fbb0f2f1          UDIV     r2,r0,r1
000048  fb010012          MLS      r0,r1,r2,r0
00004c  f8a4046e          STRH     r0,[r4,#0x46e]
                  |L21.80|
;;;454    }
000050  bd70              POP      {r4-r6,pc}
;;;455    
                          ENDP

000052  0000              DCW      0x0000
                  |L21.84|
                          DCD      ||.bss||+0x78

                          AREA ||i.WriteFlagTimeOut||, CODE, READONLY, ALIGN=1

                  WriteFlagTimeOut PROC
;;;2887   // 写入标志超时处理
;;;2888   void WriteFlagTimeOut(uint32 param)
000000  2100              MOVS     r1,#0
;;;2889   {
;;;2890       STS_PROTOCOL_SendCmdParamAck(STS_PROTOCOL_CMD_CHECK_STATION_FLAG, FALSE);
000002  2001              MOVS     r0,#1
000004  f7ffbffe          B.W      STS_PROTOCOL_SendCmdParamAck
;;;2891   }
;;;2892   
                          ENDP


                          AREA ||i.dutProgressReport||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  dutProgressReport PROC
;;;645    
;;;646    void dutProgressReport(uint32 temp)
000000  b570              PUSH     {r4-r6,lr}
;;;647    {
;;;648        uint8 i;
;;;649    
;;;650        if (dut_info.appUpFlag)
000002  4d50              LDR      r5,|L23.324|
000004  2400              MOVS     r4,#0
000006  f8950025          LDRB     r0,[r5,#0x25]  ; dut_info
00000a  2800              CMP      r0,#0
00000c  d008              BEQ      |L23.32|
;;;651        {
;;;652            dut_info.dutProgress[3] = (dut_info.currentAppSize * 100) / dut_info.appSize;
00000e  6da8              LDR      r0,[r5,#0x58]  ; dut_info
000010  2164              MOVS     r1,#0x64
000012  4348              MULS     r0,r1,r0
000014  6ce9              LDR      r1,[r5,#0x4c]  ; dut_info
000016  fbb0f0f1          UDIV     r0,r0,r1
00001a  f885006b          STRB     r0,[r5,#0x6b]
00001e  e019              B        |L23.84|
                  |L23.32|
;;;653        }
;;;654        else if (dut_info.uiUpFlag)
000020  f8950027          LDRB     r0,[r5,#0x27]  ; dut_info
000024  b140              CBZ      r0,|L23.56|
;;;655        {
;;;656            dut_info.dutProgress[5] = (dut_info.currentUiSize * 100) / dut_info.uiSize;
000026  6de8              LDR      r0,[r5,#0x5c]  ; dut_info
000028  2164              MOVS     r1,#0x64
00002a  4348              MULS     r0,r1,r0
00002c  6d29              LDR      r1,[r5,#0x50]  ; dut_info
00002e  fbb0f0f1          UDIV     r0,r0,r1
000032  f885006d          STRB     r0,[r5,#0x6d]
000036  e00d              B        |L23.84|
                  |L23.56|
;;;657        }
;;;658        else if (dut_info.configUpFlag)
000038  f8950026          LDRB     r0,[r5,#0x26]  ; dut_info
00003c  b950              CBNZ     r0,|L23.84|
;;;659        {
;;;660            // 配置信息进度只有0%和100%。
;;;661        }
;;;662        else
;;;663        {
;;;664            // 所有项升级完毕
;;;665            TIMER_KillTask(TIMER_ID_SET_DUT_PROGRESS_REPORT);
00003e  2003              MOVS     r0,#3
000040  f7fffffe          BL       TIMER_KillTask
;;;666            TIMER_KillTask(TIMER_ID_SET_DUT_CONFIG);
000044  2002              MOVS     r0,#2
000046  f7fffffe          BL       TIMER_KillTask
;;;667            dut_info.configUpFaile = FALSE;
00004a  3561              ADDS     r5,r5,#0x61
00004c  70ac              STRB     r4,[r5,#2]
;;;668            dut_info.appUpFaile = FALSE;
00004e  702c              STRB     r4,[r5,#0]
;;;669            dut_info.uiUpFaile = FALSE;
000050  706c              STRB     r4,[r5,#1]
000052  3d61              SUBS     r5,r5,#0x61
                  |L23.84|
;;;670        }
;;;671    
;;;672        if (dut_info.appUpFaile) // app升级失败
;;;673        {
;;;674            dut_info.appUpFaile = FALSE;
;;;675            dut_info.dutProgress[3] = 102;
000054  2666              MOVS     r6,#0x66
000056  f8950061          LDRB     r0,[r5,#0x61]         ;672  ; dut_info
00005a  b160              CBZ      r0,|L23.118|
00005c  f8854061          STRB     r4,[r5,#0x61]         ;674
000060  f885606b          STRB     r6,[r5,#0x6b]
;;;676            dut_info.currentAppSize = 0;
000064  65ac              STR      r4,[r5,#0x58]  ; dut_info
;;;677            TIMER_KillTask(TIMER_ID_SET_DUT_PROGRESS_REPORT);
000066  2003              MOVS     r0,#3
000068  f7fffffe          BL       TIMER_KillTask
;;;678            TIMER_KillTask(TIMER_ID_SET_DUT_PROGRESS_LCD_REPORT);
00006c  2015              MOVS     r0,#0x15
00006e  f7fffffe          BL       TIMER_KillTask
;;;679            dut_info.appUpFlag = FALSE;
000072  f8854025          STRB     r4,[r5,#0x25]
                  |L23.118|
;;;680        }
;;;681    
;;;682        if (dut_info.configUpFaile) // config升级失败
000076  f8950063          LDRB     r0,[r5,#0x63]  ; dut_info
00007a  b158              CBZ      r0,|L23.148|
;;;683        {
;;;684            dut_info.dutProgress[7] = 102;
00007c  f885606f          STRB     r6,[r5,#0x6f]
;;;685            TIMER_KillTask(TIMER_ID_SET_DUT_PROGRESS_REPORT);
000080  2003              MOVS     r0,#3
000082  f7fffffe          BL       TIMER_KillTask
;;;686            TIMER_KillTask(TIMER_ID_SET_DUT_PROGRESS_LCD_REPORT);
000086  2015              MOVS     r0,#0x15
000088  f7fffffe          BL       TIMER_KillTask
;;;687            dut_info.configUpFaile = FALSE;
00008c  f8854063          STRB     r4,[r5,#0x63]
;;;688            dut_info.configUpFlag = FALSE;
000090  f8854026          STRB     r4,[r5,#0x26]
                  |L23.148|
;;;689        }
;;;690    
;;;691        if (dut_info.appUpSuccesss)
000094  f8951067          LDRB     r1,[r5,#0x67]  ; dut_info
;;;692        {
;;;693            dut_info.dutProgress[3] = 100;
000098  2064              MOVS     r0,#0x64
00009a  b121              CBZ      r1,|L23.166|
00009c  f885006b          STRB     r0,[r5,#0x6b]
;;;694            dut_info.currentAppSize = 0;
0000a0  65ac              STR      r4,[r5,#0x58]  ; dut_info
;;;695            dut_info.appUpSuccesss = FALSE;
0000a2  f8854067          STRB     r4,[r5,#0x67]
                  |L23.166|
;;;696        }
;;;697    
;;;698        if (dut_info.configUpSuccesss)
0000a6  f8951065          LDRB     r1,[r5,#0x65]  ; dut_info
0000aa  b119              CBZ      r1,|L23.180|
;;;699        {
;;;700            dut_info.dutProgress[7] = 100;
0000ac  f885006f          STRB     r0,[r5,#0x6f]
;;;701            dut_info.configUpSuccesss = FALSE;
0000b0  f8854065          STRB     r4,[r5,#0x65]
                  |L23.180|
;;;702        }
;;;703        STS_PROTOCOL_TxAddData(STS_PROTOCOL_CMD_HEAD);         // 添加命令头
0000b4  2055              MOVS     r0,#0x55
0000b6  f7fffffe          BL       STS_PROTOCOL_TxAddData
;;;704        STS_PROTOCOL_TxAddData(STS_PROTOCOL_CMD_TOOL_DUT_PROCESS); // 添加命令字
0000ba  2041              MOVS     r0,#0x41
0000bc  f7fffffe          BL       STS_PROTOCOL_TxAddData
;;;705        STS_PROTOCOL_TxAddData(0x00);                          // 数据长度临时为0
0000c0  2000              MOVS     r0,#0
0000c2  f7fffffe          BL       STS_PROTOCOL_TxAddData
;;;706        for (i = 0; i < 8; i++)
0000c6  2400              MOVS     r4,#0
                  |L23.200|
;;;707        {
;;;708            STS_PROTOCOL_TxAddData(dut_info.dutProgress[i]);
0000c8  1928              ADDS     r0,r5,r4
0000ca  f8900068          LDRB     r0,[r0,#0x68]
0000ce  f7fffffe          BL       STS_PROTOCOL_TxAddData
0000d2  1c64              ADDS     r4,r4,#1              ;706
0000d4  b2e4              UXTB     r4,r4                 ;706
0000d6  2c08              CMP      r4,#8                 ;706
0000d8  d3f6              BCC      |L23.200|
;;;709        }
;;;710    
;;;711        STS_PROTOCOL_TxAddFrame(); // 设置数据长度和添加校验
0000da  f7fffffe          BL       STS_PROTOCOL_TxAddFrame
;;;712    
;;;713        // LCD显示
;;;714        if (dut_info.appUpFlag)
0000de  f8950025          LDRB     r0,[r5,#0x25]  ; dut_info
0000e2  b198              CBZ      r0,|L23.268|
;;;715        {
;;;716            sprintf(progressStr, "%d", dut_info.dutProgress[3]); // 将dut_info.dutProgress[3]转换为字符串
0000e4  f895206b          LDRB     r2,[r5,#0x6b]  ; dut_info
0000e8  a117              ADR      r1,|L23.328|
0000ea  4818              LDR      r0,|L23.332|
0000ec  f7fffffe          BL       __2sprintf
;;;717            addFormattedString(2, 12, progressStr, dutUpMsgBuff); // 将转换后的字符串传递给addFormattedString函数
0000f0  4b16              LDR      r3,|L23.332|
0000f2  4a16              LDR      r2,|L23.332|
0000f4  3368              ADDS     r3,r3,#0x68
0000f6  210c              MOVS     r1,#0xc
0000f8  2002              MOVS     r0,#2
0000fa  f7fffffe          BL       addFormattedString
;;;718            addString(2, 15, "%", dutUpMsgBuff);
0000fe  4b13              LDR      r3,|L23.332|
000100  a213              ADR      r2,|L23.336|
000102  3368              ADDS     r3,r3,#0x68
000104  210f              MOVS     r1,#0xf
000106  2002              MOVS     r0,#2
000108  f7fffffe          BL       addString
                  |L23.268|
;;;719        }
;;;720    
;;;721        if (dut_info.configUpFlag)
00010c  f8950026          LDRB     r0,[r5,#0x26]  ; dut_info
000110  2800              CMP      r0,#0
000112  d015              BEQ      |L23.320|
;;;722        {
;;;723            sprintf(progressStr, "%d", dut_info.dutProgress[7]); // 将dut_info.dutProgress[3]转换为字符串
000114  f895206f          LDRB     r2,[r5,#0x6f]  ; dut_info
000118  a10b              ADR      r1,|L23.328|
00011a  480c              LDR      r0,|L23.332|
00011c  f7fffffe          BL       __2sprintf
;;;724            addFormattedString(2, 12, progressStr, dutUpMsgBuff); // 将转换后的字符串传递给addFormattedString函数
000120  4b0a              LDR      r3,|L23.332|
000122  4a0a              LDR      r2,|L23.332|
000124  3368              ADDS     r3,r3,#0x68
000126  210c              MOVS     r1,#0xc
000128  2002              MOVS     r0,#2
00012a  f7fffffe          BL       addFormattedString
;;;725            addString(2, 15, "%", dutUpMsgBuff);
00012e  4b07              LDR      r3,|L23.332|
000130  e8bd4070          POP      {r4-r6,lr}
000134  3368              ADDS     r3,r3,#0x68
000136  210f              MOVS     r1,#0xf
000138  a205              ADR      r2,|L23.336|
00013a  2002              MOVS     r0,#2
00013c  f7ffbffe          B.W      addString
                  |L23.320|
;;;726        }
;;;727    }
000140  bd70              POP      {r4-r6,pc}
;;;728    
                          ENDP

000142  0000              DCW      0x0000
                  |L23.324|
                          DCD      dut_info
                  |L23.328|
000148  256400            DCB      "%d",0
00014b  00                DCB      0
                  |L23.332|
                          DCD      ||.data||+0x8
                  |L23.336|
000150  2500              DCB      "%",0
000152  00                DCB      0
000153  00                DCB      0

                          AREA ||i.enterState||, CODE, READONLY, ALIGN=2

                  enterState PROC
;;;824    // 根据通讯方式进入不同的状态机
;;;825    void enterState(void)
000000  4836              LDR      r0,|L24.220|
;;;826    {
;;;827        switch (dut_info.dutBusType)
000002  7e81              LDRB     r1,[r0,#0x1a]  ; dut_info
;;;828        {
;;;829        case 0: // 串口
;;;830    
;;;831            switch (dut_info.test)
000004  7dc0              LDRB     r0,[r0,#0x17]
000006  2900              CMP      r1,#0                 ;827
000008  d004              BEQ      |L24.20|
00000a  2901              CMP      r1,#1                 ;827
00000c  d041              BEQ      |L24.146|
;;;832            {
;;;833            // 进入UART测试
;;;834            case TEST_TYPE_UART:
;;;835                STATE_EnterState(STATE_UART_TEST);
;;;836                break;
;;;837    
;;;838            // 进入GND测试
;;;839            case TEST_TYPE_GND:
;;;840                STATE_EnterState(STATE_UART_GND_TEST);
;;;841                break;
;;;842    
;;;843            // 进入大灯测试
;;;844            case TEST_TYPE_HEADLIGHT:
;;;845                STATE_EnterState(STATE_UART_HEADLIGHT_TEST);
;;;846                break;
;;;847    
;;;848            // 进入近光灯测试
;;;849            case TEST_TYPE_LBEAM:
;;;850                STATE_EnterState(STATE_UART_LBEAM_TEST);
;;;851                break;
;;;852    
;;;853            // 进入远光灯测试
;;;854            case TEST_TYPE_HBEAM:
;;;855                STATE_EnterState(STATE_UART_HBEAM_TEST);
;;;856                break;
;;;857    
;;;858            // 进入左转向灯测试
;;;859            case TEST_TYPE_LEFT_TURN_SIGNAL:
;;;860                STATE_EnterState(STATE_UART_LEFT_TURN_SIGNAL_TEST);
;;;861                break;
;;;862    
;;;863            // 进入右转向灯测试
;;;864            case TEST_TYPE_RIGHT_TURN_SIGNAL:
;;;865                STATE_EnterState(STATE_UART_RIGHT_TURN_SIGNAL_TEST);
;;;866                break;
;;;867    
;;;868            // 进入油门测试
;;;869            case TEST_TYPE_THROTTLE:
;;;870                STATE_EnterState(STATE_UART_THROTTLE_TEST);
;;;871                break;
;;;872    
;;;873            // 进入刹把测试
;;;874            case TEST_TYPE_BRAKE:
;;;875                STATE_EnterState(STATE_UART_BRAKE_TEST);
;;;876                break;
;;;877    
;;;878            // 进入VLK测试
;;;879            case TEST_TYPE_VLK:
;;;880                STATE_EnterState(STATE_UART_VLK_TEST);
;;;881                break;
;;;882    
;;;883            // 进入电压校准测试
;;;884            case TEST_TYPE_VOLTAGE:
;;;885                STATE_EnterState(STATE_UART_VOLTAGE_TEST);
;;;886                break;
;;;887    
;;;888            // 进入(小米)大灯测试
;;;889            case TEST_TYPE_XM_HEADLIGHT:
;;;890                STATE_EnterState(STATE_UART_XM_HEADLIGHT_TEST);
;;;891                break;
;;;892    
;;;893            // 进入(小米)左转向灯测试
;;;894            case TEST_TYPE_XM_LEFT_TURN_SIGNAL:
;;;895                STATE_EnterState(STATE_UART_XM_LEFT_TURN_SIGNAL_TEST);
;;;896                break;
;;;897    
;;;898            // 进入(小米)右转向灯测试
;;;899            case TEST_TYPE_XM_RIGHT_TURN_SIGNAL:
;;;900                STATE_EnterState(STATE_UART_XM_RIGHT_TURN_SIGNAL_TEST);
;;;901                break;
;;;902    
;;;903            // 进入(小米)油门测试
;;;904            case TEST_TYPE_XM_THROTTLE:
;;;905                STATE_EnterState(STATE_UART_XM_THROTTLE_TEST);
;;;906                break;
;;;907    
;;;908            // 进入(小米)刹把测试
;;;909            case TEST_TYPE_XM_BRAKE:
;;;910                STATE_EnterState(STATE_UART_XM_BRAKE_TEST);
;;;911                break;
;;;912    
;;;913            default:
;;;914                break;
;;;915            }
;;;916            break;
;;;917    
;;;918        case 1: // CAN
;;;919            switch (dut_info.test)
;;;920            {
;;;921            // 进入GND测试
;;;922            case TEST_TYPE_GND:
;;;923                STATE_EnterState(STATE_UART_GND_TEST);
;;;924                break;
;;;925    
;;;926            // 进入大灯测试
;;;927            case TEST_TYPE_HEADLIGHT:
;;;928                STATE_EnterState(STATE_CAN_HEADLIGHT_TEST);
;;;929                break;
;;;930    
;;;931            // 进入左转向灯测试
;;;932            case TEST_TYPE_LEFT_TURN_SIGNAL:
;;;933                STATE_EnterState(STATE_CAN_LEFT_TURN_SIGNAL_TEST);
;;;934                break;
;;;935    
;;;936            // 进入右转向灯测试
;;;937            case TEST_TYPE_RIGHT_TURN_SIGNAL:
;;;938                STATE_EnterState(STATE_CAN_RIGHT_TURN_SIGNAL_TEST);
;;;939                break;
;;;940    
;;;941            // 进入油门测试
;;;942            case TEST_TYPE_THROTTLE:
;;;943                STATE_EnterState(STATE_CAN_THROTTLE_TEST);
;;;944                break;
;;;945    
;;;946            // 进入刹把测试
;;;947            case TEST_TYPE_BRAKE:
;;;948                STATE_EnterState(STATE_CAN_BRAKE_TEST);
;;;949                break;
;;;950    
;;;951            // 进入VLK测试
;;;952            case TEST_TYPE_VLK:
;;;953                STATE_EnterState(STATE_CAN_VLK_TEST);
;;;954                break;
;;;955    
;;;956            // 进入电压校准测试
;;;957            case TEST_TYPE_VOLTAGE:
;;;958                STATE_EnterState(STATE_CAN_VOLTAGE_TEST);
;;;959                break;
;;;960    
;;;961            default:
;;;962                break;
;;;963            }
;;;964            break;
;;;965    
;;;966        default:
;;;967            STATE_EnterState(STATE_STANDBY);
00000e  2001              MOVS     r0,#1
000010  f7ffbffe          B.W      STATE_EnterState
                  |L24.20|
000014  2815              CMP      r0,#0x15              ;831
000016  d260              BCS      |L24.218|
000018  e8dff000          TBB      [pc,r0]               ;831
00001c  5f0b0e11          DCB      0x5f,0x0b,0x0e,0x11
000020  14171a1d          DCB      0x14,0x17,0x1a,0x1d
000024  20235f5f          DCB      0x20,0x23,0x5f,0x5f
000028  5f26295f          DCB      0x5f,0x26,0x29,0x5f
00002c  2c2f3235          DCB      0x2c,0x2f,0x32,0x35
000030  3800              DCB      0x38,0x00
000032  2002              MOVS     r0,#2                 ;835
000034  f7ffbffe          B.W      STATE_EnterState
000038  2003              MOVS     r0,#3                 ;840
00003a  f7ffbffe          B.W      STATE_EnterState
00003e  2004              MOVS     r0,#4                 ;845
000040  f7ffbffe          B.W      STATE_EnterState
000044  2005              MOVS     r0,#5                 ;850
000046  f7ffbffe          B.W      STATE_EnterState
00004a  2006              MOVS     r0,#6                 ;855
00004c  f7ffbffe          B.W      STATE_EnterState
000050  2007              MOVS     r0,#7                 ;860
000052  f7ffbffe          B.W      STATE_EnterState
000056  2008              MOVS     r0,#8                 ;865
000058  f7ffbffe          B.W      STATE_EnterState
00005c  2009              MOVS     r0,#9                 ;870
00005e  f7ffbffe          B.W      STATE_EnterState
000062  200a              MOVS     r0,#0xa               ;875
000064  f7ffbffe          B.W      STATE_EnterState
000068  200d              MOVS     r0,#0xd               ;880
00006a  f7ffbffe          B.W      STATE_EnterState
00006e  200e              MOVS     r0,#0xe               ;885
000070  f7ffbffe          B.W      STATE_EnterState
000074  2029              MOVS     r0,#0x29              ;890
000076  f7ffbffe          B.W      STATE_EnterState
00007a  202a              MOVS     r0,#0x2a              ;895
00007c  f7ffbffe          B.W      STATE_EnterState
000080  202b              MOVS     r0,#0x2b              ;900
000082  f7ffbffe          B.W      STATE_EnterState
000086  202c              MOVS     r0,#0x2c              ;905
000088  f7ffbffe          B.W      STATE_EnterState
00008c  202d              MOVS     r0,#0x2d              ;910
00008e  f7ffbffe          B.W      STATE_EnterState
                  |L24.146|
000092  1e80              SUBS     r0,r0,#2              ;919
000094  280d              CMP      r0,#0xd               ;919
000096  d220              BCS      |L24.218|
000098  e8dff000          TBB      [pc,r0]               ;919
00009c  070a1f1f          DCB      0x07,0x0a,0x1f,0x1f
0000a0  0d101316          DCB      0x0d,0x10,0x13,0x16
0000a4  1f1f1f19          DCB      0x1f,0x1f,0x1f,0x19
0000a8  1c00              DCB      0x1c,0x00
0000aa  2003              MOVS     r0,#3                 ;923
0000ac  f7ffbffe          B.W      STATE_EnterState
0000b0  2011              MOVS     r0,#0x11              ;928
0000b2  f7ffbffe          B.W      STATE_EnterState
0000b6  2014              MOVS     r0,#0x14              ;933
0000b8  f7ffbffe          B.W      STATE_EnterState
0000bc  2015              MOVS     r0,#0x15              ;938
0000be  f7ffbffe          B.W      STATE_EnterState
0000c2  2016              MOVS     r0,#0x16              ;943
0000c4  f7ffbffe          B.W      STATE_EnterState
0000c8  2017              MOVS     r0,#0x17              ;948
0000ca  f7ffbffe          B.W      STATE_EnterState
0000ce  201a              MOVS     r0,#0x1a              ;953
0000d0  f7ffbffe          B.W      STATE_EnterState
0000d4  201b              MOVS     r0,#0x1b              ;958
0000d6  f7ffbffe          B.W      STATE_EnterState
                  |L24.218|
;;;968            break;
;;;969        }
;;;970    
;;;971    }
0000da  4770              BX       lr
;;;972    
                          ENDP

                  |L24.220|
                          DCD      dut_info

                          AREA ||i.enterUpState||, CODE, READONLY, ALIGN=2

                  enterUpState PROC
;;;973    // 根据升级信息进入不同的状态机
;;;974    void enterUpState()
000000  4821              LDR      r0,|L25.136|
;;;975    {
;;;976        if (dut_info.appUpFlag || dut_info.configUpFlag)
000002  f8901025          LDRB     r1,[r0,#0x25]  ; dut_info
000006  2900              CMP      r1,#0
000008  d102              BNE      |L25.16|
00000a  f8901026          LDRB     r1,[r0,#0x26]  ; dut_info
00000e  b3b1              CBZ      r1,|L25.126|
                  |L25.16|
;;;977        {
;;;978            switch (dut_info.dutBusType)
000010  7e81              LDRB     r1,[r0,#0x1a]  ; dut_info
000012  481d              LDR      r0,|L25.136|
;;;979            {
;;;980            case 0: // 串口
;;;981                switch (dut_info.ID)
000014  7d80              LDRB     r0,[r0,#0x16]
000016  b149              CBZ      r1,|L25.44|
000018  2901              CMP      r1,#1                 ;978
00001a  d133              BNE      |L25.132|
;;;982                {
;;;983                case DUT_TYPE_SEG:
;;;984                    // 进入数码管、段码屏升级
;;;985                    STATE_EnterState(STATE_CM_UART_SEG_UPGRADE);
;;;986                    break;
;;;987    
;;;988                case DUT_TYPE_CM:
;;;989                    // 进入通用彩屏升级
;;;990                    STATE_EnterState(STATE_CM_UART_BC_UPGRADE);
;;;991                    break;
;;;992    
;;;993                case DUT_TYPE_HUAXIN:
;;;994                    // 进入华芯微特升级
;;;995                    STATE_EnterState(STATE_HUAXIN_UART_BC_UPGRADE);
;;;996                    break;
;;;997    
;;;998                case DUT_TYPE_KAIYANG:
;;;999                    // 进入开阳升级
;;;1000                   STATE_EnterState(STATE_KAIYANG_UART_BC_UPGRADE);
;;;1001                   break;
;;;1002   
;;;1003               case DUT_TYPE_LIME:
;;;1004                   // 进入LIME升级
;;;1005                   STATE_EnterState(STATE_LIME_UART_BC_UPGRADE);
;;;1006                   break;
;;;1007   
;;;1008               default:
;;;1009                   break;
;;;1010               }
;;;1011   
;;;1012               break;
;;;1013   
;;;1014           case 1: // can
;;;1015               switch (dut_info.ID)
00001c  2808              CMP      r0,#8
00001e  d22b              BCS      |L25.120|
000020  e8dff000          TBB      [pc,r0]
000024  2a1b2a21          DCB      0x2a,0x1b,0x2a,0x21
000028  1e242a27          DCB      0x1e,0x24,0x2a,0x27
                  |L25.44|
00002c  1e80              SUBS     r0,r0,#2              ;981
00002e  2805              CMP      r0,#5                 ;981
000030  d228              BCS      |L25.132|
000032  e8dff000          TBB      [pc,r0]               ;981
000036  0609              DCB      0x06,0x09
000038  030c0f00          DCB      0x03,0x0c,0x0f,0x00
00003c  2024              MOVS     r0,#0x24              ;985
00003e  f7ffbffe          B.W      STATE_EnterState
000042  2025              MOVS     r0,#0x25              ;990
000044  f7ffbffe          B.W      STATE_EnterState
000048  2026              MOVS     r0,#0x26              ;995
00004a  f7ffbffe          B.W      STATE_EnterState
00004e  2027              MOVS     r0,#0x27              ;1000
000050  f7ffbffe          B.W      STATE_EnterState
000054  2028              MOVS     r0,#0x28              ;1005
000056  f7ffbffe          B.W      STATE_EnterState
;;;1016               {
;;;1017               case DUT_TYPE_GB:
;;;1018                   // 进入高标升级
;;;1019                   STATE_EnterState(STATE_GAOBIAO_CAN_UPGRADE);
00005a  201e              MOVS     r0,#0x1e
00005c  f7ffbffe          B.W      STATE_EnterState
;;;1020                   break;
;;;1021   
;;;1022               case DUT_TYPE_SEG:
;;;1023                   // 进入数码管、段码屏升级
;;;1024                   STATE_EnterState(STATE_SEG_CAN_UPGRADE);
000060  2021              MOVS     r0,#0x21
000062  f7ffbffe          B.W      STATE_EnterState
;;;1025                   break;
;;;1026   
;;;1027               case DUT_TYPE_HUAXIN:
;;;1028                   // 华芯微特升级
;;;1029                   STATE_EnterState(STATE_HUAXIN_CAN_UPGRADE);
000066  2020              MOVS     r0,#0x20
000068  f7ffbffe          B.W      STATE_EnterState
;;;1030                   break;
;;;1031   
;;;1032               case DUT_TYPE_KAIYANG:
;;;1033                   // 进入开阳升级
;;;1034                   STATE_EnterState(STATE_KAIYANG_CAN_UPGRADE);
00006c  2022              MOVS     r0,#0x22
00006e  f7ffbffe          B.W      STATE_EnterState
;;;1035                   break;
;;;1036   
;;;1037               case DUT_TYPE_SPARROW:
;;;1038                   // 进入sparrow升级
;;;1039                   STATE_EnterState(STATE_SPARROW_CAN_UPGRADE);
000072  2023              MOVS     r0,#0x23
000074  f7ffbffe          B.W      STATE_EnterState
                  |L25.120|
;;;1040                   break;
;;;1041   
;;;1042               default:
;;;1043                   // 进入通用can升级
;;;1044                   STATE_EnterState(STATE_CM_CAN_UPGRADE);
000078  201f              MOVS     r0,#0x1f
00007a  f7ffbffe          B.W      STATE_EnterState
                  |L25.126|
;;;1045                   break;
;;;1046               }
;;;1047               break;
;;;1048   
;;;1049           default:
;;;1050               break;
;;;1051           }
;;;1052       }
;;;1053       else
;;;1054       {
;;;1055           STATE_EnterState(STATE_STANDBY);
00007e  2001              MOVS     r0,#1
000080  f7ffbffe          B.W      STATE_EnterState
                  |L25.132|
;;;1056       }
;;;1057   }
000084  4770              BX       lr
;;;1058   
                          ENDP

000086  0000              DCW      0x0000
                  |L25.136|
                          DCD      dut_info

                          AREA ||i.lcdProgressReport||, CODE, READONLY, ALIGN=2

                  lcdProgressReport PROC
;;;729    // LCD进度上报
;;;730    void lcdProgressReport(uint32 temp)
000000  b510              PUSH     {r4,lr}
;;;731    {
;;;732        if ((dut_info.dutProgress[3] > 0) && (dut_info.dutProgress[3] < 100))
000002  480d              LDR      r0,|L26.56|
000004  f890006b          LDRB     r0,[r0,#0x6b]  ; dut_info
000008  1e41              SUBS     r1,r0,#1
00000a  2963              CMP      r1,#0x63
00000c  d206              BCS      |L26.28|
;;;733        {
;;;734            Vertical_Scrolling_Display(dutUpMsgBuff, 4, 2);
00000e  2202              MOVS     r2,#2
000010  e8bd4010          POP      {r4,lr}
000014  2104              MOVS     r1,#4
000016  4809              LDR      r0,|L26.60|
000018  f7ffbffe          B.W      Vertical_Scrolling_Display
                  |L26.28|
;;;735        }
;;;736        else if (100 == dut_info.dutProgress[3])
00001c  2864              CMP      r0,#0x64
00001e  d109              BNE      |L26.52|
;;;737        {
;;;738            Vertical_Scrolling_Display(dutUpMsgBuff, 4, 3);
000020  2203              MOVS     r2,#3
000022  2104              MOVS     r1,#4
000024  4805              LDR      r0,|L26.60|
000026  f7fffffe          BL       Vertical_Scrolling_Display
;;;739            TIMER_KillTask(TIMER_ID_SET_DUT_PROGRESS_LCD_REPORT);
00002a  e8bd4010          POP      {r4,lr}
00002e  2015              MOVS     r0,#0x15
000030  f7ffbffe          B.W      TIMER_KillTask
                  |L26.52|
;;;740        }
;;;741    }
000034  bd10              POP      {r4,pc}
;;;742    
                          ENDP

000036  0000              DCW      0x0000
                  |L26.56|
                          DCD      dut_info
                  |L26.60|
                          DCD      ||.data||+0x70

                          AREA ||i.setDutProgressReportInfo||, CODE, READONLY, ALIGN=2

                  setDutProgressReportInfo PROC
;;;769    // 设置进度上报信息
;;;770    void setDutProgressReportInfo()
000000  b57c              PUSH     {r2-r6,lr}
;;;771    {
;;;772        dut_info.dutProgress[0] = 0;   // boot
000002  481d              LDR      r0,|L27.120|
000004  2100              MOVS     r1,#0
000006  7001              STRB     r1,[r0,#0]
;;;773        dut_info.dutProgress[1] = 101; // boot
000008  2265              MOVS     r2,#0x65
00000a  7042              STRB     r2,[r0,#1]
;;;774        dut_info.dutProgress[2] = 1;   // app
00000c  2401              MOVS     r4,#1
00000e  7084              STRB     r4,[r0,#2]
;;;775        dut_info.dutProgress[4] = 2;   // ui
000010  2302              MOVS     r3,#2
000012  7103              STRB     r3,[r0,#4]
;;;776        dut_info.dutProgress[6] = 3;   // config
000014  2303              MOVS     r3,#3
000016  7183              STRB     r3,[r0,#6]
;;;777    
;;;778        if (!dut_info.appUpFlag)
000018  f8103c43          LDRB     r3,[r0,#-0x43]  ; dut_info
00001c  3868              SUBS     r0,r0,#0x68
00001e  2b00              CMP      r3,#0
000020  d020              BEQ      |L27.100|
;;;779        {
;;;780            dut_info.dutProgress[3] = 101;
;;;781        }
;;;782        else
;;;783        {
;;;784            dut_info.dutProgress[3] = 0;
000022  f880106b          STRB     r1,[r0,#0x6b]
                  |L27.38|
;;;785        }
;;;786    
;;;787        if (!dut_info.uiUpFlag)
000026  f8903027          LDRB     r3,[r0,#0x27]  ; dut_info
00002a  b1f3              CBZ      r3,|L27.106|
;;;788        {
;;;789            dut_info.dutProgress[5] = 101;
;;;790        }
;;;791        else
;;;792        {
;;;793            dut_info.dutProgress[5] = 0;
00002c  f880106d          STRB     r1,[r0,#0x6d]
                  |L27.48|
;;;794        }
;;;795    
;;;796        if (!dut_info.configUpFlag)
000030  f8903026          LDRB     r3,[r0,#0x26]  ; dut_info
000034  b1e3              CBZ      r3,|L27.112|
;;;797        {
;;;798            dut_info.dutProgress[7] = 101;
;;;799        }
;;;800        else
;;;801        {
;;;802            dut_info.dutProgress[7] = 0;
000036  f880106f          STRB     r1,[r0,#0x6f]
                  |L27.58|
;;;803        }
;;;804    
;;;805        // 上报STS
;;;806        TIMER_AddTask(TIMER_ID_SET_DUT_PROGRESS_REPORT,
00003a  f04f35ff          MOV      r5,#0xffffffff
00003e  e9cd5400          STRD     r5,r4,[sp,#0]
000042  2301              MOVS     r3,#1
000044  4a0d              LDR      r2,|L27.124|
000046  f44f7196          MOV      r1,#0x12c
00004a  2003              MOVS     r0,#3
00004c  f7fffffe          BL       TIMER_AddTask
;;;807                      300,
;;;808                      dutProgressReport,
;;;809                      TRUE,
;;;810                      TIMER_LOOP_FOREVER,
;;;811                      ACTION_MODE_ADD_TO_QUEUE);
;;;812    
;;;813        // LCD显示
;;;814        TIMER_AddTask(TIMER_ID_SET_DUT_PROGRESS_LCD_REPORT,
000050  e9cd5400          STRD     r5,r4,[sp,#0]
000054  2301              MOVS     r3,#1
000056  4a0a              LDR      r2,|L27.128|
000058  f44f51fa          MOV      r1,#0x1f40
00005c  2015              MOVS     r0,#0x15
00005e  f7fffffe          BL       TIMER_AddTask
;;;815                      8000,
;;;816                      lcdProgressReport,
;;;817                      TRUE,
;;;818                      TIMER_LOOP_FOREVER,
;;;819                      ACTION_MODE_ADD_TO_QUEUE);
;;;820    
;;;821    }
000062  bd7c              POP      {r2-r6,pc}
                  |L27.100|
000064  f880206b          STRB     r2,[r0,#0x6b]         ;780
000068  e7dd              B        |L27.38|
                  |L27.106|
00006a  f880206d          STRB     r2,[r0,#0x6d]         ;789
00006e  e7df              B        |L27.48|
                  |L27.112|
000070  f880206f          STRB     r2,[r0,#0x6f]         ;798
000074  e7e1              B        |L27.58|
;;;822    
                          ENDP

000076  0000              DCW      0x0000
                  |L27.120|
                          DCD      dut_info+0x68
                  |L27.124|
                          DCD      dutProgressReport
                  |L27.128|
                          DCD      lcdProgressReport

                          AREA ||i.setUpItem||, CODE, READONLY, ALIGN=2

                  setUpItem PROC
;;;743    // 升级项控制
;;;744    void setUpItem(uint8 upItem, uint8 ctrlState)
000000  b530              PUSH     {r4,r5,lr}
;;;745    {
;;;746        dut_info.appUpFlag = FALSE;
000002  4b0c              LDR      r3,|L28.52|
000004  2200              MOVS     r2,#0
000006  f8832025          STRB     r2,[r3,#0x25]
;;;747        dut_info.uiUpFlag = FALSE;
00000a  f8832027          STRB     r2,[r3,#0x27]
;;;748        dut_info.configUpFlag = FALSE;
00000e  f8832026          STRB     r2,[r3,#0x26]
;;;749    
;;;750        // 清除状态
;;;751        dut_info.currentAppSize = 0;
000012  659a              STR      r2,[r3,#0x58]  ; dut_info
;;;752        dut_info.currentUiSize = 0;
000014  65da              STR      r2,[r3,#0x5c]  ; dut_info
;;;753        if (1 == ctrlState)
000016  2901              CMP      r1,#1
000018  d10a              BNE      |L28.48|
;;;754        {
;;;755            if (0x02 == (upItem & 0x02)) // 升级app
;;;756            {
;;;757                dut_info.appUpFlag = TRUE;
;;;758                testFlag = FALSE;
00001a  4c07              LDR      r4,|L28.56|
00001c  0785              LSLS     r5,r0,#30             ;755
00001e  d502              BPL      |L28.38|
000020  f8831025          STRB     r1,[r3,#0x25]         ;757
000024  70a2              STRB     r2,[r4,#2]
                  |L28.38|
;;;759            }
;;;760    
;;;761            if (0x08 == (upItem & 0x08)) // 升级config
000026  0700              LSLS     r0,r0,#28
000028  d502              BPL      |L28.48|
;;;762            {
;;;763                dut_info.configUpFlag = TRUE;
00002a  f8831026          STRB     r1,[r3,#0x26]
;;;764                testFlag = TRUE;
00002e  70a1              STRB     r1,[r4,#2]
                  |L28.48|
;;;765            }
;;;766        }
;;;767    }
000030  bd30              POP      {r4,r5,pc}
;;;768    
                          ENDP

000032  0000              DCW      0x0000
                  |L28.52|
                          DCD      dut_info
                  |L28.56|
                          DCD      ||.data||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  dutverBuff
                          %        100
                  verBle
                          %        20
                  STSProtocolCB
                          %        1156

                          AREA ||area_number.31||, DATA, NOINIT, ALIGN=0

                          EXPORTAS ||area_number.31||, ||.bss||
                  paramLength
                          %        150

                          AREA ||area_number.32||, DATA, NOINIT, ALIGN=0

                          EXPORTAS ||area_number.32||, ||.bss||
                  paramNumber
                          %        150

                          AREA ||area_number.33||, DATA, NOINIT, ALIGN=0

                          EXPORTAS ||area_number.33||, ||.bss||
                  paramContent
                          %        2500

                          AREA ||area_number.34||, DATA, NOINIT, ALIGN=0

                          EXPORTAS ||area_number.34||, ||.bss||
                  configs
                          %        300

                          AREA ||area_number.35||, DATA, NOINIT, ALIGN=0

                          EXPORTAS ||area_number.35||, ||.bss||
                  resultArray
                          %        150

                          AREA ||area_number.36||, DATA, NOINIT, ALIGN=0

                          EXPORTAS ||area_number.36||, ||.bss||
                  verifiedBuff
                          %        150

                          AREA ||.data||, DATA, ALIGN=2

                  dutverType
000000  00                DCB      0x00
                  showFlag
000001  01                DCB      0x01
                  testFlag
000002  00                DCB      0x00
                  keyValue
000003  00                DCB      0x00
                  stationNumber
000004  00                DCB      0x00
                  offFlag
000005  00                DCB      0x00
                  verwriteFlag
000006  00                DCB      0x00
                  verreadFlag
000007  00                DCB      0x00
                  progressStr
000008  00000000          DCB      0x00,0x00,0x00,0x00
                  powerPacketSize
                          DCD      0x00000000
                  allPacketSize
                          DCD      0x00000000
                  allPacket
000014  00000000          DCB      0x00,0x00,0x00,0x00
                  currPacketNum
                          DCD      0x0000ffff
                  calibration
                          DCD      0x00000000
                  dtaUpMsgBuff
000020  45726173          DCB      0x45,0x72,0x61,0x73
000024  75726520          DCB      0x75,0x72,0x65,0x20
000028  41505020          DCB      0x41,0x50,0x50,0x20
00002c  44617461          DCB      0x44,0x61,0x74,0x61
000030  00000000          DCB      0x00,0x00,0x00,0x00
000034  57726974          DCB      0x57,0x72,0x69,0x74
000038  696e6720          DCB      0x69,0x6e,0x67,0x20
00003c  41505020          DCB      0x41,0x50,0x50,0x20
000040  44617461          DCB      0x44,0x61,0x74,0x61
000044  00000000          DCB      0x00,0x00,0x00,0x00
000048  55706461          DCB      0x55,0x70,0x64,0x61
00004c  74696e67          DCB      0x74,0x69,0x6e,0x67
000050  20445441          DCB      0x20,0x44,0x54,0x41
000054  20000000          DCB      0x20,0x00,0x00,0x00
                          DCD      0x00000000
00005c  53657420          DCB      0x53,0x65,0x74,0x20
000060  50617261          DCB      0x50,0x61,0x72,0x61
000064  6d205375          DCB      0x6d,0x20,0x53,0x75
000068  63636565          DCB      0x63,0x63,0x65,0x65
00006c  64000000          DCB      0x64,0x00,0x00,0x00
                  dutUpMsgBuff
000070  57726974          DCB      0x57,0x72,0x69,0x74
000074  696e6720          DCB      0x69,0x6e,0x67,0x20
000078  41505020          DCB      0x41,0x50,0x50,0x20
00007c  44617461          DCB      0x44,0x61,0x74,0x61
000080  00000000          DCB      0x00,0x00,0x00,0x00
000084  55706461          DCB      0x55,0x70,0x64,0x61
000088  74696e67          DCB      0x74,0x69,0x6e,0x67
00008c  20445554          DCB      0x20,0x44,0x55,0x54
000090  20000000          DCB      0x20,0x00,0x00,0x00
                          DCD      0x00000000
000098  55702050          DCB      0x55,0x70,0x20,0x50
00009c  726f6772          DCB      0x72,0x6f,0x67,0x72
0000a0  65737320          DCB      0x65,0x73,0x73,0x20
0000a4  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
0000ac  44555420          DCB      0x44,0x55,0x54,0x20
0000b0  55702043          DCB      0x55,0x70,0x20,0x43
0000b4  6f6d706c          DCB      0x6f,0x6d,0x70,0x6c
0000b8  65746564          DCB      0x65,0x74,0x65,0x64
0000bc  00000000          DCB      0x00,0x00,0x00,0x00
                  verTestMsgBuff
0000c0  53746120          DCB      0x53,0x74,0x61,0x20
0000c4  56657269          DCB      0x56,0x65,0x72,0x69
0000c8  66696361          DCB      0x66,0x69,0x63,0x61
0000cc  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
0000d4  56657220          DCB      0x56,0x65,0x72,0x20
0000d8  56657269          DCB      0x56,0x65,0x72,0x69
0000dc  66696361          DCB      0x66,0x69,0x63,0x61
0000e0  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
0000e8  4c434400          DCB      0x4c,0x43,0x44,0x00
                          %        16
0000fc  4b455900          DCB      0x4b,0x45,0x59,0x00
                          %        16
                  showTestMsgBuff
000110  53484f57          DCB      0x53,0x48,0x4f,0x57
000114  00000000          DCB      0x00,0x00,0x00,0x00
                          %        12
000124  464c4153          DCB      0x46,0x4c,0x41,0x53
000128  48205665          DCB      0x48,0x20,0x56,0x65
00012c  72690000          DCB      0x72,0x69,0x00,0x00
                          %        8
000138  42540000          DCB      0x42,0x54,0x00,0x00
                          %        16
00014c  55534200          DCB      0x55,0x53,0x42,0x00
                          %        16
                  volTestMsgBuff
000160  564f4c00          DCB      0x56,0x4f,0x4c,0x00
                          %        16
000174  55415254          DCB      0x55,0x41,0x52,0x54
000178  00000000          DCB      0x00,0x00,0x00,0x00
                          %        12
000188  564c4b00          DCB      0x56,0x4c,0x4b,0x00
                          %        16
00019c  50617373          DCB      0x50,0x61,0x73,0x73
0001a0  696e6720          DCB      0x69,0x6e,0x67,0x20
0001a4  5468726f          DCB      0x54,0x68,0x72,0x6f
0001a8  75676800          DCB      0x75,0x67,0x68,0x00
                          DCD      0x00000000
                  deTestMsgBuff
0001b0  44455241          DCB      0x44,0x45,0x52,0x41
0001b4  494c4c45          DCB      0x49,0x4c,0x4c,0x45
0001b8  55520000          DCB      0x55,0x52,0x00,0x00
                          %        8

                          AREA ||area_number.39||, DATA, ALIGN=0

                          EXPORTAS ||area_number.39||, ||.data||
                  dutFlag
000000  01                DCB      0x01

                          AREA ||area_number.40||, DATA, ALIGN=0

                          EXPORTAS ||area_number.40||, ||.data||
                  resultIndex
000000  00                DCB      0x00

                          AREA ||area_number.41||, DATA, ALIGN=0

                          EXPORTAS ||area_number.41||, ||.data||
                  verifiedIndex
000000  00                DCB      0x00

                          AREA ||area_number.42||, DATA, ALIGN=0

                          EXPORTAS ||area_number.42||, ||.data||
                  noLenght
000000  00                DCB      0x00

                          AREA ||area_number.43||, DATA, ALIGN=0

                          EXPORTAS ||area_number.43||, ||.data||
                  shutdownFlag
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "User\\StsProtocol.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_StsProtocol_c_096a2f9a____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___13_StsProtocol_c_096a2f9a____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_StsProtocol_c_096a2f9a____REVSH|
#line 128
|__asm___13_StsProtocol_c_096a2f9a____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
