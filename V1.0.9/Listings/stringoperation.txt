; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\stringoperation.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\stringoperation.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -I.\User\qrencode -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.3\Device\Include -D__MICROLIB -D__UVISION_VERSION=539 -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\stringoperation.crf User\stringOperation.c]
                          THUMB

                          AREA ||i.HexToChar||, CODE, READONLY, ALIGN=1

                  HexToChar PROC
;;;484    // 16进制转char
;;;485    unsigned char HexToChar(unsigned char bChar)
000000  f1a00130          SUB      r1,r0,#0x30
;;;486    {
;;;487        if ((bChar >= '0') && (bChar <= '9'))
000004  2909              CMP      r1,#9
000006  d801              BHI      |L1.12|
;;;488        {
;;;489            bChar -= 0x30;
000008  b2c8              UXTB     r0,r1
;;;490        }
;;;491        else if ((bChar >= 0x41) && (bChar <= 0x46)) // Capital
;;;492        {
;;;493            bChar -= 0x37;
;;;494        }
;;;495        else if ((bChar >= 0x61) && (bChar <= 0x66)) //littlecase
;;;496        {
;;;497            bChar -= 0x57;
;;;498        }
;;;499        else
;;;500        {
;;;501            bChar = 0xff;
;;;502        }
;;;503        return bChar;
;;;504    }
00000a  4770              BX       lr
                  |L1.12|
00000c  f1a00141          SUB      r1,r0,#0x41           ;491
000010  2905              CMP      r1,#5                 ;491
000012  d802              BHI      |L1.26|
000014  3837              SUBS     r0,r0,#0x37           ;493
000016  b2c0              UXTB     r0,r0                 ;493
000018  4770              BX       lr
                  |L1.26|
00001a  f1a00161          SUB      r1,r0,#0x61           ;495
00001e  2905              CMP      r1,#5                 ;495
000020  d802              BHI      |L1.40|
000022  3857              SUBS     r0,r0,#0x57           ;497
000024  b2c0              UXTB     r0,r0                 ;497
000026  4770              BX       lr
                  |L1.40|
000028  20ff              MOVS     r0,#0xff              ;501
00002a  4770              BX       lr
;;;505    
                          ENDP


                          AREA ||i.HexToCharHigh||, CODE, READONLY, ALIGN=1

                  HexToCharHigh PROC
;;;506    // 16进制高四位转char
;;;507    unsigned char HexToCharHigh(unsigned char hexValue)
000000  0900              LSRS     r0,r0,#4
;;;508    {
;;;509        unsigned char highNibble = (hexValue >> 4) & 0x0F; // 获取高四位的值
;;;510        if (highNibble >= 0x0 && highNibble <= 0x9)
000002  2809              CMP      r0,#9
000004  d802              BHI      |L2.12|
;;;511        {
;;;512            return highNibble + 0x30; // 如果高四位是 '0' 到 '9'，则返回对应的字符值
000006  3030              ADDS     r0,r0,#0x30
000008  b2c0              UXTB     r0,r0
;;;513        }
;;;514        else if (highNibble >= 0xA && highNibble <= 0xF)
;;;515        {
;;;516            return highNibble + 0x37; // 如果高四位是大写字母 A 到 F，则返回对应的字符值
;;;517        }
;;;518        else if (highNibble >= 0xa && highNibble <= 0xf)
;;;519        {
;;;520            return highNibble + 0x57; // 如果低四位是大写字母 a 到 f，则返回对应的字符值
;;;521        }
;;;522        else
;;;523        {
;;;524            return 0xff; // 如果高四位不在上述范围内，则返回 0xff，表示转换失败
;;;525        }
;;;526    }
00000a  4770              BX       lr
                  |L2.12|
00000c  f1a0010a          SUB      r1,r0,#0xa            ;514
000010  2905              CMP      r1,#5                 ;514
000012  d802              BHI      |L2.26|
000014  3037              ADDS     r0,r0,#0x37           ;516
000016  b2c0              UXTB     r0,r0                 ;516
000018  4770              BX       lr
                  |L2.26|
00001a  20ff              MOVS     r0,#0xff              ;524
00001c  4770              BX       lr
;;;527    
                          ENDP


                          AREA ||i.HexToCharLow||, CODE, READONLY, ALIGN=1

                  HexToCharLow PROC
;;;528    // 16进制低四位转char
;;;529    unsigned char HexToCharLow(unsigned char hexValue)
000000  f000000f          AND      r0,r0,#0xf
;;;530    {
;;;531        unsigned char lowNibble = hexValue & 0x0F; // 获取低四位的值
;;;532        if (lowNibble >= 0x0 && lowNibble <= 0x9)
000004  2809              CMP      r0,#9
000006  d802              BHI      |L3.14|
;;;533        {
;;;534            return lowNibble + 0x30; // 如果低四位是 '0' 到 '9'，则返回对应的字符值
000008  3030              ADDS     r0,r0,#0x30
00000a  b2c0              UXTB     r0,r0
;;;535        }
;;;536        else if (lowNibble >= 0xA && lowNibble <= 0xF)
;;;537        {
;;;538            return lowNibble + 0x37; // 如果低四位是大写字母 A 到 F，则返回对应的字符值
;;;539        }
;;;540        else if (lowNibble >= 0xa && lowNibble <= 0xf)
;;;541        {
;;;542            return lowNibble + 0x57; // 如果低四位是大写字母 a 到 f，则返回对应的字符值
;;;543        }
;;;544        else
;;;545        {
;;;546            return 0xff; // 如果低四位不在上述范围内，则返回 0xff，表示转换失败
;;;547        }
;;;548    }
00000c  4770              BX       lr
                  |L3.14|
00000e  f1a0010a          SUB      r1,r0,#0xa            ;536
000012  2905              CMP      r1,#5                 ;536
000014  d802              BHI      |L3.28|
000016  3037              ADDS     r0,r0,#0x37           ;538
000018  b2c0              UXTB     r0,r0                 ;538
00001a  4770              BX       lr
                  |L3.28|
00001c  20ff              MOVS     r0,#0xff              ;546
00001e  4770              BX       lr
;;;549    
                          ENDP


                          AREA ||i.STRING_CalculateCh||, CODE, READONLY, ALIGN=1

                  STRING_CalculateCh PROC
;;;181    // 查找字符串中指定字符的个数
;;;182    int16 STRING_CalculateCh(const uint8 *str, uint8 ch)
000000  b510              PUSH     {r4,lr}
;;;183    {
;;;184        uint16 i = 0;
000002  2200              MOVS     r2,#0
;;;185        uint16 cnt = 0;
000004  2300              MOVS     r3,#0
;;;186    
;;;187        // 参数检验
;;;188        if (NULL == str)
000006  2800              CMP      r0,#0
000008  d107              BNE      |L4.26|
;;;189        {
;;;190            return -1;
00000a  1e40              SUBS     r0,r0,#1
;;;191        }
;;;192    
;;;193        while (str[i] != '\0')
;;;194        {
;;;195            if (str[i] == ch)
;;;196            {
;;;197                cnt++;
;;;198            }
;;;199            i++;
;;;200        }
;;;201    
;;;202        return cnt;
;;;203    }
00000c  bd10              POP      {r4,pc}
                  |L4.14|
00000e  428c              CMP      r4,r1                 ;195
000010  d101              BNE      |L4.22|
000012  1c5b              ADDS     r3,r3,#1              ;197
000014  b29b              UXTH     r3,r3                 ;197
                  |L4.22|
000016  1c52              ADDS     r2,r2,#1              ;199
000018  b292              UXTH     r2,r2                 ;199
                  |L4.26|
00001a  5c84              LDRB     r4,[r0,r2]            ;193
00001c  2c00              CMP      r4,#0                 ;193
00001e  d1f6              BNE      |L4.14|
000020  b218              SXTH     r0,r3                 ;202
000022  bd10              POP      {r4,pc}
;;;204    
                          ENDP


                          AREA ||i.STRING_CatStr||, CODE, READONLY, ALIGN=1

                  STRING_CatStr PROC
;;;71     // 将两个字符串连接在一起
;;;72     void STRING_CatStr(uint8 *dst, uint8 *src)
000000  b530              PUSH     {r4,r5,lr}
;;;73     {
;;;74         uint16 i = 0;
000002  2200              MOVS     r2,#0
;;;75         uint16 j = 0;
000004  2300              MOVS     r3,#0
;;;76     
;;;77         // 参数检验
;;;78         if ((NULL == dst) || (NULL == src))
000006  2800              CMP      r0,#0
000008  d016              BEQ      |L5.56|
00000a  2900              CMP      r1,#0
00000c  d014              BEQ      |L5.56|
00000e  e001              B        |L5.20|
                  |L5.16|
;;;79         {
;;;80             return;
;;;81         }
;;;82     
;;;83         while (dst[i] != '\0')
;;;84         {
;;;85             i++;
000010  1c52              ADDS     r2,r2,#1
000012  b292              UXTH     r2,r2
                  |L5.20|
000014  5c84              LDRB     r4,[r0,r2]            ;83
000016  2c00              CMP      r4,#0                 ;83
000018  d1fa              BNE      |L5.16|
00001a  e007              B        |L5.44|
                  |L5.28|
;;;86         }
;;;87     
;;;88         while (src[j] != '\0')
;;;89         {
;;;90             dst[i++] = src[j++];
00001c  461c              MOV      r4,r3
00001e  1c5b              ADDS     r3,r3,#1
000020  5d0d              LDRB     r5,[r1,r4]
000022  4614              MOV      r4,r2
000024  1c52              ADDS     r2,r2,#1
000026  b29b              UXTH     r3,r3
000028  b292              UXTH     r2,r2
00002a  5505              STRB     r5,[r0,r4]
                  |L5.44|
00002c  5ccc              LDRB     r4,[r1,r3]            ;88
00002e  2c00              CMP      r4,#0                 ;88
000030  d1f4              BNE      |L5.28|
;;;91         }
;;;92         dst[i + j] = '\0';  // 添加字符串结束标志'\0'
000032  441a              ADD      r2,r2,r3
000034  2100              MOVS     r1,#0
000036  5481              STRB     r1,[r0,r2]
                  |L5.56|
;;;93     
;;;94     }
000038  bd30              POP      {r4,r5,pc}
;;;95     
                          ENDP


                          AREA ||i.STRING_CmpStr||, CODE, READONLY, ALIGN=1

                  STRING_CmpStr PROC
;;;205    // 判断两个字符串是否相等
;;;206    BOOL STRING_CmpStr(const uint8 *str1, const uint8 *str2)
000000  2800              CMP      r0,#0
;;;207    {
000002  d001              BEQ      |L6.8|
;;;208        uint8 *localStr1 = (uint8 *)str1;
;;;209        uint8 *localStr2 = (uint8 *)str2;
;;;210    
;;;211        // 参数检验
;;;212        if ((NULL == str1) || (NULL == str2))
000004  000a              MOVS     r2,r1
000006  d116              BNE      |L6.54|
                  |L6.8|
;;;213        {
;;;214            return FALSE;
000008  2000              MOVS     r0,#0
;;;215        }
;;;216    
;;;217        while ((*localStr1 != '\0') && (*localStr2 != '\0'))
;;;218        {
;;;219            // 不区分大小写，如果是字母，需统一转换为大写
;;;220            if ((*localStr1 >= 'a') && (*localStr1 <= 'z'))
;;;221            {
;;;222                *localStr1 = *localStr1 - 32;
;;;223            }
;;;224    
;;;225            if ((*localStr2 >= 'a') && (*localStr2 <= 'z'))
;;;226            {
;;;227                *localStr2 = *localStr2 - 32;
;;;228            }
;;;229    
;;;230            if (*localStr1++ != *localStr2++)
;;;231            {
;;;232                return FALSE;
;;;233            }
;;;234        }
;;;235    
;;;236        if ((*localStr1 == '\0') && (*localStr2 == '\0'))
;;;237        {
;;;238            return TRUE;
;;;239        }
;;;240    
;;;241        return FALSE;
;;;242    }
00000a  4770              BX       lr
                  |L6.12|
00000c  f1a20361          SUB      r3,r2,#0x61           ;220
000010  2b19              CMP      r3,#0x19              ;220
000012  d801              BHI      |L6.24|
000014  3a20              SUBS     r2,r2,#0x20           ;222
000016  7002              STRB     r2,[r0,#0]            ;222
                  |L6.24|
000018  780a              LDRB     r2,[r1,#0]            ;225
00001a  f1a20361          SUB      r3,r2,#0x61           ;225
00001e  2b19              CMP      r3,#0x19              ;225
000020  d801              BHI      |L6.38|
000022  3a20              SUBS     r2,r2,#0x20           ;227
000024  700a              STRB     r2,[r1,#0]            ;227
                  |L6.38|
000026  f8102b01          LDRB     r2,[r0],#1            ;230
00002a  f8113b01          LDRB     r3,[r1],#1            ;230
00002e  429a              CMP      r2,r3                 ;230
000030  d001              BEQ      |L6.54|
000032  2000              MOVS     r0,#0                 ;232
000034  4770              BX       lr
                  |L6.54|
000036  7802              LDRB     r2,[r0,#0]            ;217
000038  b112              CBZ      r2,|L6.64|
00003a  780b              LDRB     r3,[r1,#0]            ;217
00003c  2b00              CMP      r3,#0                 ;217
00003e  d1e5              BNE      |L6.12|
                  |L6.64|
000040  7800              LDRB     r0,[r0,#0]            ;236
000042  b908              CBNZ     r0,|L6.72|
000044  7808              LDRB     r0,[r1,#0]            ;236
000046  b108              CBZ      r0,|L6.76|
                  |L6.72|
000048  2000              MOVS     r0,#0                 ;241
00004a  4770              BX       lr
                  |L6.76|
00004c  2001              MOVS     r0,#1                 ;238
00004e  4770              BX       lr
;;;243    
                          ENDP


                          AREA ||i.STRING_CmpareN||, CODE, READONLY, ALIGN=1

                  STRING_CmpareN PROC
;;;243    
;;;244    uint8 STRING_CmpareN(const uint8 *str1, const uint8 *str2, uint8 len)
000000  b530              PUSH     {r4,r5,lr}
;;;245    {
;;;246        uint16 i = 0;
000002  2300              MOVS     r3,#0
000004  e007              B        |L7.22|
                  |L7.6|
;;;247    
;;;248        while (i < len)
;;;249        {
;;;250            if (*(str1 + i) != *(str2 + i))
000006  5cc4              LDRB     r4,[r0,r3]
000008  5ccd              LDRB     r5,[r1,r3]
00000a  42ac              CMP      r4,r5
00000c  d001              BEQ      |L7.18|
;;;251            {
;;;252                return 0;
00000e  2000              MOVS     r0,#0
;;;253            }
;;;254            i++;
;;;255        }
;;;256        return 1;
;;;257    }
000010  bd30              POP      {r4,r5,pc}
                  |L7.18|
000012  1c5b              ADDS     r3,r3,#1              ;254
000014  b29b              UXTH     r3,r3                 ;254
                  |L7.22|
000016  4293              CMP      r3,r2                 ;248
000018  d3f5              BCC      |L7.6|
00001a  2001              MOVS     r0,#1                 ;256
00001c  bd30              POP      {r4,r5,pc}
;;;258    
                          ENDP


                          AREA ||i.STRING_DeleteCh||, CODE, READONLY, ALIGN=1

                  STRING_DeleteCh PROC
;;;260    // 删除指定字符串中的指定字符，返回成功删除的个数
;;;261    uint16 STRING_DeleteCh(uint8 str[], uint8 ch)
000000  b530              PUSH     {r4,r5,lr}
;;;262    {
;;;263        uint16 i, j;
;;;264        uint16 cnt = 0;
000002  2400              MOVS     r4,#0
;;;265    
;;;266        for (i = 0; str[i] != '\0'; i++)
000004  2300              MOVS     r3,#0
000006  e011              B        |L8.44|
                  |L8.8|
;;;267        {
;;;268            if (str[i] == ch)
000008  428a              CMP      r2,r1
00000a  d10d              BNE      |L8.40|
;;;269            {
;;;270                for (j = i; str[j] != '\0'; j++)
00000c  461a              MOV      r2,r3
00000e  e004              B        |L8.26|
                  |L8.16|
;;;271                {
;;;272                    str[j] = str[j + 1];
000010  1885              ADDS     r5,r0,r2
000012  786d              LDRB     r5,[r5,#1]
000014  5485              STRB     r5,[r0,r2]
000016  1c52              ADDS     r2,r2,#1              ;270
000018  b292              UXTH     r2,r2                 ;270
                  |L8.26|
00001a  5c85              LDRB     r5,[r0,r2]            ;270
00001c  2d00              CMP      r5,#0                 ;270
00001e  d1f7              BNE      |L8.16|
;;;273                }
;;;274                cnt++;
000020  1c64              ADDS     r4,r4,#1
000022  b2a4              UXTH     r4,r4
;;;275                i--;
000024  1e5b              SUBS     r3,r3,#1
000026  b29b              UXTH     r3,r3
                  |L8.40|
000028  1c5b              ADDS     r3,r3,#1              ;266
00002a  b29b              UXTH     r3,r3                 ;266
                  |L8.44|
00002c  5cc2              LDRB     r2,[r0,r3]            ;266
00002e  2a00              CMP      r2,#0                 ;266
000030  d1ea              BNE      |L8.8|
;;;276            }
;;;277        }
;;;278    
;;;279        return cnt;
000032  4620              MOV      r0,r4
;;;280    }
000034  bd30              POP      {r4,r5,pc}
;;;281    
                          ENDP


                          AREA ||i.STRING_Find||, CODE, READONLY, ALIGN=1

                  STRING_Find PROC
;;;97     // 在指定的字符串中搜索子串，存在则返回字符串中首次出现子串的下标地址，否则返回-1
;;;98     int16 STRING_Find(const uint8 *mStr, const uint8 *subStr)
000000  b5f8              PUSH     {r3-r7,lr}
;;;99     {
;;;100        uint8 *pCh = (uint8 *)mStr;
000002  4604              MOV      r4,r0
;;;101        uint8 *str1, *str2;
;;;102        volatile uint16 i = 0;   // 子串在母串中的下标
000004  2200              MOVS     r2,#0
000006  9200              STR      r2,[sp,#0]
;;;103    
;;;104        // 参数检验
;;;105        if ((NULL == mStr) || (NULL == subStr))
;;;106        {
;;;107            return -1;
000008  1e57              SUBS     r7,r2,#1
00000a  2800              CMP      r0,#0                 ;105
00000c  d005              BEQ      |L9.26|
00000e  b121              CBZ      r1,|L9.26|
;;;108        }
;;;109    
;;;110        if ('\0' == *mStr)
000010  7802              LDRB     r2,[r0,#0]
000012  b122              CBZ      r2,|L9.30|
;;;111        {
;;;112            return -1;
;;;113        }
;;;114    
;;;115        if ('\0' == *subStr)
000014  780a              LDRB     r2,[r1,#0]
000016  b122              CBZ      r2,|L9.34|
000018  e013              B        |L9.66|
                  |L9.26|
00001a  4638              MOV      r0,r7                 ;107
;;;116        {
;;;117            return -1;
;;;118        }
;;;119    
;;;120        while (*pCh != '\0')
;;;121        {
;;;122            str1 = pCh;
;;;123            str2 = (uint8 *)subStr;
;;;124    
;;;125            while ((*str1 != '\0') && (*str2 != '\0') && (*str1 == *str2))
;;;126            {
;;;127                str1++;
;;;128                str2++;
;;;129            }
;;;130            if (*str2 == '\0')
;;;131            {
;;;132                i = pCh - mStr;
;;;133    
;;;134                return i;
;;;135            }
;;;136    
;;;137            pCh++;
;;;138        }
;;;139    
;;;140        return -1;
;;;141    }
00001c  bdf8              POP      {r3-r7,pc}
                  |L9.30|
00001e  4638              MOV      r0,r7                 ;112
000020  bdf8              POP      {r3-r7,pc}
                  |L9.34|
000022  4638              MOV      r0,r7                 ;117
000024  bdf8              POP      {r3-r7,pc}
                  |L9.38|
000026  4623              MOV      r3,r4                 ;122
000028  460a              MOV      r2,r1                 ;123
00002a  e001              B        |L9.48|
                  |L9.44|
00002c  1c5b              ADDS     r3,r3,#1              ;127
00002e  1c52              ADDS     r2,r2,#1              ;128
                  |L9.48|
000030  781e              LDRB     r6,[r3,#0]            ;125
000032  b11e              CBZ      r6,|L9.60|
000034  7815              LDRB     r5,[r2,#0]            ;125
000036  b10d              CBZ      r5,|L9.60|
000038  42ae              CMP      r6,r5                 ;125
00003a  d0f7              BEQ      |L9.44|
                  |L9.60|
00003c  7812              LDRB     r2,[r2,#0]            ;130
00003e  b12a              CBZ      r2,|L9.76|
000040  1c64              ADDS     r4,r4,#1              ;137
                  |L9.66|
000042  7822              LDRB     r2,[r4,#0]            ;120
000044  2a00              CMP      r2,#0                 ;120
000046  d1ee              BNE      |L9.38|
000048  4638              MOV      r0,r7                 ;140
00004a  bdf8              POP      {r3-r7,pc}
                  |L9.76|
00004c  1a20              SUBS     r0,r4,r0              ;132
00004e  9000              STR      r0,[sp,#0]            ;132
000050  f8bd0000          LDRH     r0,[sp,#0]            ;134
000054  b200              SXTH     r0,r0                 ;134
000056  bdf8              POP      {r3-r7,pc}
;;;142    
                          ENDP


                          AREA ||i.STRING_FindCh||, CODE, READONLY, ALIGN=1

                  STRING_FindCh PROC
;;;158    // 查找字符串中指定字符，成功返回该字符首次出现的下标位置，否则返回-1
;;;159    int16 STRING_FindCh(const uint8 *str, uint8 ch)
000000  b510              PUSH     {r4,lr}
;;;160    {
;;;161        uint16 i = 0;
000002  2200              MOVS     r2,#0
;;;162    
;;;163        // 参数检验
;;;164        if (NULL == str)
;;;165        {
;;;166            return -1;
000004  1e54              SUBS     r4,r2,#1
000006  2800              CMP      r0,#0                 ;164
000008  d107              BNE      |L10.26|
00000a  4620              MOV      r0,r4
;;;167        }
;;;168    
;;;169        while (str[i] != '\0')
;;;170        {
;;;171            if (str[i] == ch)
;;;172            {
;;;173                return i;
;;;174            }
;;;175            i++;
;;;176        }
;;;177    
;;;178        return -1;
;;;179    }
00000c  bd10              POP      {r4,pc}
                  |L10.14|
00000e  428b              CMP      r3,r1                 ;171
000010  d101              BNE      |L10.22|
000012  b210              SXTH     r0,r2                 ;173
000014  bd10              POP      {r4,pc}
                  |L10.22|
000016  1c52              ADDS     r2,r2,#1              ;175
000018  b292              UXTH     r2,r2                 ;175
                  |L10.26|
00001a  5c83              LDRB     r3,[r0,r2]            ;169
00001c  2b00              CMP      r3,#0                 ;169
00001e  d1f6              BNE      |L10.14|
000020  4620              MOV      r0,r4                 ;178
000022  bd10              POP      {r4,pc}
;;;180    
                          ENDP


                          AREA ||i.STRING_FindLimitSpeedh||, CODE, READONLY, ALIGN=1

                  STRING_FindLimitSpeedh PROC
;;;142    
;;;143    uint8 STRING_FindLimitSpeedh(uint8 *str, uint8 ch)
000000  4602              MOV      r2,r0
;;;144    {
;;;145        uint8 i = 0;
000002  2000              MOVS     r0,#0
                  |L11.4|
;;;146    
;;;147        for (i = 0; i < 100; i++)
;;;148        {
;;;149            if (str[i] == ch)
000004  5c13              LDRB     r3,[r2,r0]
000006  428b              CMP      r3,r1
000008  d004              BEQ      |L11.20|
00000a  1c80              ADDS     r0,r0,#2              ;147
00000c  b2c0              UXTB     r0,r0                 ;147
00000e  2864              CMP      r0,#0x64              ;147
000010  d3f8              BCC      |L11.4|
;;;150            {
;;;151                return i;
;;;152            }
;;;153            i++;
;;;154        }
;;;155        return 0;
000012  2000              MOVS     r0,#0
                  |L11.20|
;;;156    }
000014  4770              BX       lr
;;;157    
                          ENDP


                          AREA ||i.STRING_FromTo||, CODE, READONLY, ALIGN=1

                  STRING_FromTo PROC
;;;376    // 从指定的字符串的第一个字符到第二个字符作为一个新的字串
;;;377    BOOL STRING_FromTo(const uint8 *str, uint8 firstChar, uint8 secondChar, uint8 arr[])
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;378    {
000004  460c              MOV      r4,r1
000006  4617              MOV      r7,r2
000008  4699              MOV      r9,r3
;;;379        uint8 *localStr = (uint8 *)str;
00000a  4680              MOV      r8,r0
;;;380        uint8 *localarr = arr;
;;;381        uint8 length = strlen((char *)str);
00000c  f7fffffe          BL       strlen
;;;382        int16 j, k;
;;;383        uint16 i;
;;;384    
;;;385        // 参数检验
;;;386        if ((NULL == localStr) || ('\0' == firstChar) || ('\0' == secondChar))
000010  ea5f0008          MOVS     r0,r8
000014  d00b              BEQ      |L12.46|
000016  b154              CBZ      r4,|L12.46|
000018  b14f              CBZ      r7,|L12.46|
;;;387        {
;;;388            return FALSE;
;;;389        }
;;;390    
;;;391        if (firstChar == secondChar)
00001a  42bc              CMP      r4,r7
00001c  d109              BNE      |L12.50|
;;;392        {
;;;393            // 数量不足2个
;;;394            if (STRING_CalculateCh(localStr, firstChar) < 2)
00001e  4621              MOV      r1,r4
000020  f7fffffe          BL       STRING_CalculateCh
000024  2802              CMP      r0,#2
000026  da04              BGE      |L12.50|
;;;395            {
;;;396                return FALSE;
000028  2000              MOVS     r0,#0
                  |L12.42|
;;;397            }
;;;398        }
;;;399    
;;;400        j = STRING_FindCh(localStr, firstChar);
;;;401        k = STRING_FindCh(localStr, secondChar);
;;;402        if ((-1 == j) || (-1 == k))
;;;403        {
;;;404            return FALSE;
;;;405        }
;;;406    
;;;407        // 取第二个字符之前的字符作为新字符串
;;;408        for (i = 0, ++j; localStr[j] != secondChar; i++, j++)
;;;409        {
;;;410            localarr[i] = localStr[j];
;;;411        }
;;;412        localarr[i] = '\0';
;;;413    
;;;414        return TRUE;
;;;415    }
00002a  e8bd87f0          POP      {r4-r10,pc}
                  |L12.46|
00002e  2000              MOVS     r0,#0                 ;388
000030  e7fb              B        |L12.42|
                  |L12.50|
000032  4621              MOV      r1,r4                 ;400
000034  4640              MOV      r0,r8                 ;400
000036  f7fffffe          BL       STRING_FindCh
00003a  4605              MOV      r5,r0                 ;400
00003c  4639              MOV      r1,r7                 ;401
00003e  4640              MOV      r0,r8                 ;401
000040  f7fffffe          BL       STRING_FindCh
000044  1c69              ADDS     r1,r5,#1              ;402
000046  d005              BEQ      |L12.84|
000048  1c40              ADDS     r0,r0,#1              ;402
00004a  d003              BEQ      |L12.84|
00004c  2400              MOVS     r4,#0                 ;408
00004e  1c6d              ADDS     r5,r5,#1              ;408
000050  b22d              SXTH     r5,r5                 ;408
000052  e007              B        |L12.100|
                  |L12.84|
000054  2000              MOVS     r0,#0                 ;404
000056  e7e8              B        |L12.42|
                  |L12.88|
000058  f8096004          STRB     r6,[r9,r4]            ;410
00005c  1c64              ADDS     r4,r4,#1              ;408
00005e  b2a4              UXTH     r4,r4                 ;408
000060  1c6d              ADDS     r5,r5,#1              ;408
000062  b22d              SXTH     r5,r5                 ;408
                  |L12.100|
000064  f8186005          LDRB     r6,[r8,r5]            ;408
000068  42be              CMP      r6,r7                 ;408
00006a  d1f5              BNE      |L12.88|
00006c  2000              MOVS     r0,#0                 ;412
00006e  f8090004          STRB     r0,[r9,r4]            ;412
000072  2001              MOVS     r0,#1                 ;414
000074  e7d9              B        |L12.42|
;;;416    
                          ENDP


                          AREA ||i.STRING_GPS_FormCommaStr||, CODE, READONLY, ALIGN=1

                  STRING_GPS_FormCommaStr PROC
;;;445    // 得到指定序号的第m个逗号和n个逗号之间的字符作为新字符串
;;;446    BOOL STRING_GPS_FormCommaStr(const uint8 *str, uint16 mNum, uint16 nNum, uint8 arr[])
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;447    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
00000a  461f              MOV      r7,r3
;;;448        int16 i, j;
;;;449        uint16 len = strlen((char *)str);
00000c  4630              MOV      r0,r6
00000e  f7fffffe          BL       strlen
000012  b280              UXTH     r0,r0
;;;450    
;;;451        // 参数检验
;;;452        if ((NULL == str) || (mNum > len) || (nNum > len) || (mNum > nNum))
000014  b12e              CBZ      r6,|L13.34|
000016  4284              CMP      r4,r0
000018  d803              BHI      |L13.34|
00001a  4285              CMP      r5,r0
00001c  d801              BHI      |L13.34|
00001e  42ac              CMP      r4,r5
000020  d902              BLS      |L13.40|
                  |L13.34|
;;;453        {
;;;454            return FALSE;
000022  2000              MOVS     r0,#0
                  |L13.36|
;;;455        }
;;;456    
;;;457        // 找不到逗号
;;;458        i = STRING_GPS_GetCommaPosition(str, mNum);
;;;459        j = STRING_GPS_GetCommaPosition(str, nNum);
;;;460        if ((i < 0) || (j < 0))
;;;461        {
;;;462            return FALSE;
;;;463        }
;;;464    
;;;465        // 两个逗号之间无数据
;;;466        if (1 == (j - i))
;;;467        {
;;;468            return FALSE;
;;;469        }
;;;470    
;;;471        // 截取两个逗号之间的字符组成新字符串
;;;472        if (STRING_FromTo(&str[i], ',', ',', arr))
;;;473        {
;;;474            return TRUE;
;;;475        }
;;;476        else
;;;477        {
;;;478            return FALSE;
;;;479        }
;;;480    }
000024  e8bd81f0          POP      {r4-r8,pc}
                  |L13.40|
000028  4621              MOV      r1,r4                 ;458
00002a  4630              MOV      r0,r6                 ;458
00002c  f7fffffe          BL       STRING_GPS_GetCommaPosition
000030  4604              MOV      r4,r0                 ;458
000032  4629              MOV      r1,r5                 ;459
000034  4630              MOV      r0,r6                 ;459
000036  f7fffffe          BL       STRING_GPS_GetCommaPosition
00003a  2c00              CMP      r4,#0                 ;460
00003c  db01              BLT      |L13.66|
00003e  2800              CMP      r0,#0                 ;460
000040  da01              BGE      |L13.70|
                  |L13.66|
000042  2000              MOVS     r0,#0                 ;462
000044  e7ee              B        |L13.36|
                  |L13.70|
000046  1b00              SUBS     r0,r0,r4              ;466
000048  2801              CMP      r0,#1                 ;466
00004a  d008              BEQ      |L13.94|
00004c  222c              MOVS     r2,#0x2c              ;472
00004e  1930              ADDS     r0,r6,r4              ;472
000050  463b              MOV      r3,r7                 ;472
000052  4611              MOV      r1,r2                 ;472
000054  f7fffffe          BL       STRING_FromTo
000058  b118              CBZ      r0,|L13.98|
00005a  2001              MOVS     r0,#1                 ;474
00005c  e7e2              B        |L13.36|
                  |L13.94|
00005e  2000              MOVS     r0,#0                 ;468
000060  e7e0              B        |L13.36|
                  |L13.98|
000062  2000              MOVS     r0,#0                 ;478
000064  e7de              B        |L13.36|
;;;481    
                          ENDP


                          AREA ||i.STRING_GPS_GetCommaPosition||, CODE, READONLY, ALIGN=1

                  STRING_GPS_GetCommaPosition PROC
;;;417    // 得到指定序号的逗号位置
;;;418    int16 STRING_GPS_GetCommaPosition(const uint8 *str, uint16 num)
000000  b570              PUSH     {r4-r6,lr}
;;;419    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;420        uint16 i, j;
;;;421        uint16 len = strlen((char *)str);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       strlen
00000c  b284              UXTH     r4,r0
;;;422    
;;;423        // 参数检验
;;;424        if ((NULL == str) || (num > len))
;;;425        {
;;;426            return -1;
00000e  f04f30ff          MOV      r0,#0xffffffff
000012  2d00              CMP      r5,#0                 ;424
000014  d00c              BEQ      |L14.48|
000016  42a6              CMP      r6,r4                 ;424
000018  d80a              BHI      |L14.48|
;;;427        }
;;;428    
;;;429        for (i = 0, j = 0; i < len; i++)
00001a  2200              MOVS     r2,#0
00001c  2300              MOVS     r3,#0
00001e  e00a              B        |L14.54|
                  |L14.32|
;;;430        {
;;;431            if (str[i] == ',')
000020  5ca9              LDRB     r1,[r5,r2]
000022  292c              CMP      r1,#0x2c
000024  d101              BNE      |L14.42|
;;;432            {
;;;433                j++;
000026  1c5b              ADDS     r3,r3,#1
000028  b29b              UXTH     r3,r3
                  |L14.42|
;;;434            }
;;;435    
;;;436            if (j == num)
00002a  42b3              CMP      r3,r6
00002c  d101              BNE      |L14.50|
;;;437            {
;;;438                return i;
00002e  b210              SXTH     r0,r2
                  |L14.48|
;;;439            }
;;;440        }
;;;441    
;;;442        return -1;
;;;443    }
000030  bd70              POP      {r4-r6,pc}
                  |L14.50|
000032  1c52              ADDS     r2,r2,#1              ;429
000034  b292              UXTH     r2,r2                 ;429
                  |L14.54|
000036  42a2              CMP      r2,r4                 ;429
000038  d3f2              BCC      |L14.32|
00003a  bd70              POP      {r4-r6,pc}
;;;444    
                          ENDP


                          AREA ||i.STRING_IntToStr||, CODE, READONLY, ALIGN=1

                  STRING_IntToStr PROC
;;;8      // 整形数转成字符串
;;;9      void STRING_IntToStr(uint32 param, uint8 *str)
000000  b570              PUSH     {r4-r6,lr}
;;;10     {
000002  b08a              SUB      sp,sp,#0x28
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;11         uint32 localParam = param;
;;;12     
;;;13         // param为1个字节的整数倍长度，预留最后一个字节存储'\0'，因此在基础上+1
;;;14         uint8 tempStr[(sizeof(param) * 8 + 1)] = {0};
000008  2124              MOVS     r1,#0x24
00000a  a801              ADD      r0,sp,#4
00000c  f7fffffe          BL       __aeabi_memclr4
;;;15     
;;;16         // 临时字符串区的最后一个为0，代表字符串结尾，按照倒序方式，从倒数第二个位置开始向下标减小的方向填充字符
;;;17         // 数组个数为sizeof(param)*8+1时，下标为[0,sizeof(param)*8]，因此倒数第二个位置在[sizeof(param)*8+1-2]
;;;18         int8 index = (sizeof(param) * 8 + 1) - 2;
000010  221f              MOVS     r2,#0x1f
;;;19     
;;;20         // 参数检验
;;;21         if (NULL == str)
000012  2d00              CMP      r5,#0
000014  d01d              BEQ      |L15.82|
;;;22         {
;;;23             return;
;;;24         }
;;;25     
;;;26         // 从倒数第二个位置开始，向下标减小的方向添加数据
;;;27         do
;;;28         {
;;;29             tempStr[index--] = (localParam % 10) + '0';
000016  200a              MOVS     r0,#0xa
000018  a901              ADD      r1,sp,#4              ;14
                  |L15.26|
00001a  fbb4f3f0          UDIV     r3,r4,r0
00001e  fb004313          MLS      r3,r0,r3,r4
000022  3330              ADDS     r3,r3,#0x30
000024  4616              MOV      r6,r2
000026  1e52              SUBS     r2,r2,#1
000028  b252              SXTB     r2,r2
00002a  558b              STRB     r3,[r1,r6]
;;;30             localParam /= 10;
00002c  fbb4f4f0          UDIV     r4,r4,r0
;;;31         }
;;;32         while ((0 != localParam) && (index > -1));
000030  b10c              CBZ      r4,|L15.54|
000032  2a00              CMP      r2,#0
000034  daf1              BGE      |L15.26|
                  |L15.54|
;;;33     
;;;34         // 由于经过了上述的运算后，index实际指向了最前面的一个空位置，因此这里++，将其指向第一个非空字符
;;;35         index++;
000036  1c52              ADDS     r2,r2,#1
000038  b250              SXTB     r0,r2
;;;36         while (0 != tempStr[index])
00003a  e005              B        |L15.72|
                  |L15.60|
;;;37         {
;;;38             *str++ = tempStr[index++];
00003c  4602              MOV      r2,r0
00003e  1c40              ADDS     r0,r0,#1
000040  5c8a              LDRB     r2,[r1,r2]
000042  b240              SXTB     r0,r0
000044  f8052b01          STRB     r2,[r5],#1
                  |L15.72|
000048  5c0a              LDRB     r2,[r1,r0]            ;36
00004a  2a00              CMP      r2,#0                 ;36
00004c  d1f6              BNE      |L15.60|
;;;39         }
;;;40         *str = '\0';    // 添加结束符
00004e  2000              MOVS     r0,#0
000050  7028              STRB     r0,[r5,#0]
                  |L15.82|
;;;41     }
000052  b00a              ADD      sp,sp,#0x28
000054  bd70              POP      {r4-r6,pc}
;;;42     
                          ENDP


                          AREA ||i.STRING_Left||, CODE, READONLY, ALIGN=1

                  STRING_Left PROC
;;;310    // 从指定的字符串的开始位置，截取count个字符为子串
;;;311    void STRING_Left(const uint8 *str, uint8 count, uint8 arr[])
000000  b570              PUSH     {r4-r6,lr}
;;;312    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;313        uint8 *localStr = (uint8 *)str;
;;;314        uint8 length = strlen((char *)str);
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       strlen
00000e  b2c1              UXTB     r1,r0
;;;315        uint8 i;
;;;316    
;;;317        // 参数检验
;;;318        if (NULL == str)
000010  2c00              CMP      r4,#0
000012  d00d              BEQ      |L16.48|
;;;319        {
;;;320            return;
;;;321        }
;;;322    
;;;323        // 长度不能越界
;;;324        if (count > length)
000014  428d              CMP      r5,r1
000016  d900              BLS      |L16.26|
;;;325        {
;;;326            count = length;
000018  460d              MOV      r5,r1
                  |L16.26|
;;;327        }
;;;328    
;;;329        for (i = 0; i < count; i++)
00001a  2300              MOVS     r3,#0
00001c  e004              B        |L16.40|
                  |L16.30|
;;;330        {
;;;331            arr[i] = *localStr++;
00001e  f8140b01          LDRB     r0,[r4],#1
000022  54f0              STRB     r0,[r6,r3]
000024  1c5b              ADDS     r3,r3,#1              ;329
000026  b2db              UXTB     r3,r3                 ;329
                  |L16.40|
000028  42ab              CMP      r3,r5                 ;329
00002a  d3f8              BCC      |L16.30|
;;;332        }
;;;333    
;;;334        arr[i] = '\0';
00002c  2000              MOVS     r0,#0
00002e  54f0              STRB     r0,[r6,r3]
                  |L16.48|
;;;335    }
000030  bd70              POP      {r4-r6,pc}
;;;336    
                          ENDP


                          AREA ||i.STRING_Mid||, CODE, READONLY, ALIGN=1

                  STRING_Mid PROC
;;;338    // 从指定的字符串的指定下标位置开始，截取中间count个字符作为子串
;;;339    void STRING_Mid(const uint8 *str, uint8 startNum, int8 count, uint8 arr[])
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;340    {
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
00000a  461c              MOV      r4,r3
;;;341        uint8 *localStr = (uint8 *)str;
;;;342        uint8 length = strlen((char *)str);
00000c  4638              MOV      r0,r7
00000e  f7fffffe          BL       strlen
000012  b2c2              UXTB     r2,r0
;;;343    
;;;344        // 参数检验
;;;345        if ((NULL == str) || (startNum > length))
000014  2f00              CMP      r7,#0
000016  d01b              BEQ      |L17.80|
000018  4296              CMP      r6,r2
00001a  d819              BHI      |L17.80|
;;;346        {
;;;347            return;
;;;348        }
;;;349    
;;;350        // 长度不能越界
;;;351        if (count > length)
00001c  4295              CMP      r5,r2
00001e  dd01              BLE      |L17.36|
;;;352        {
;;;353            count = length - startNum; // 从第m个到最后
000020  1b90              SUBS     r0,r2,r6
000022  b245              SXTB     r5,r0
                  |L17.36|
;;;354        }
;;;355    
;;;356        localStr += startNum;
000024  19b8              ADDS     r0,r7,r6
;;;357    
;;;358        if (count > 0)
000026  2d00              CMP      r5,#0
000028  dc03              BGT      |L17.50|
00002a  e00c              B        |L17.70|
                  |L17.44|
;;;359        {
;;;360            while ((count--) && ((*localStr) != '\0'))
;;;361            {
;;;362                *arr++ = *localStr++;
00002c  f8041b01          STRB     r1,[r4],#1
000030  1c40              ADDS     r0,r0,#1
                  |L17.50|
000032  1e6d              SUBS     r5,r5,#1              ;360
000034  b26d              SXTB     r5,r5                 ;360
000036  d309              BCC      |L17.76|
000038  7801              LDRB     r1,[r0,#0]            ;360
00003a  2900              CMP      r1,#0                 ;360
00003c  d1f6              BNE      |L17.44|
00003e  e005              B        |L17.76|
                  |L17.64|
;;;363            }
;;;364        }
;;;365        else
;;;366        {
;;;367            while ((*localStr) != '\0')
;;;368            {
;;;369                *arr++ = *localStr++;
000040  f8041b01          STRB     r1,[r4],#1
000044  1c40              ADDS     r0,r0,#1
                  |L17.70|
000046  7801              LDRB     r1,[r0,#0]            ;367
000048  2900              CMP      r1,#0                 ;367
00004a  d1f9              BNE      |L17.64|
                  |L17.76|
;;;370            }
;;;371        }
;;;372    
;;;373        *arr = '\0';
00004c  2000              MOVS     r0,#0
00004e  7020              STRB     r0,[r4,#0]
                  |L17.80|
;;;374    }
000050  e8bd81f0          POP      {r4-r8,pc}
;;;375    
                          ENDP


                          AREA ||i.STRING_Right||, CODE, READONLY, ALIGN=1

                  STRING_Right PROC
;;;282    // 从指定的字符串的末尾1开始获取从右向左前 count 个字符
;;;283    void STRING_Right(const char *str, uint8 count, char arr[])
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;284    {
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;285        uint8 *localStr = (uint8 *)str;
;;;286        uint8 length = strlen((char *)str);
00000a  4638              MOV      r0,r7
00000c  f7fffffe          BL       strlen
000010  b2c5              UXTB     r5,r0
;;;287    
;;;288        // 参数检验
;;;289        if (NULL == str)
000012  2f00              CMP      r7,#0
000014  d00d              BEQ      |L18.50|
;;;290        {
;;;291            return;
;;;292        }
;;;293    
;;;294        // 长度不能越界
;;;295        if (count > length)
000016  42ae              CMP      r6,r5
000018  d900              BLS      |L18.28|
;;;296        {
;;;297            count = length;
00001a  462e              MOV      r6,r5
                  |L18.28|
;;;298        }
;;;299    
;;;300        localStr += (length - count);   // 从右边第n个字符开始，到'\0'结束
00001c  1ba8              SUBS     r0,r5,r6
00001e  4438              ADD      r0,r0,r7
;;;301    
;;;302        while (*localStr != '\0')
000020  e002              B        |L18.40|
                  |L18.34|
;;;303        {
;;;304            *arr++ = *localStr++;
000022  f8041b01          STRB     r1,[r4],#1
000026  1c40              ADDS     r0,r0,#1
                  |L18.40|
000028  7801              LDRB     r1,[r0,#0]            ;302
00002a  2900              CMP      r1,#0                 ;302
00002c  d1f9              BNE      |L18.34|
;;;305        }
;;;306        *arr = '\0';
00002e  2000              MOVS     r0,#0
000030  7020              STRB     r0,[r4,#0]
                  |L18.50|
;;;307    
;;;308    }
000032  e8bd81f0          POP      {r4-r8,pc}
;;;309    
                          ENDP


                          AREA ||i.STRING_StrToVal||, CODE, READONLY, ALIGN=1

                  STRING_StrToVal PROC
;;;43     // 字符串转数值
;;;44     uint32 STRING_StrToVal(uint8 *str)
000000  2200              MOVS     r2,#0
;;;45     {
;;;46         uint32 value = 0;
;;;47         uint8 *localStr = str;
;;;48     
;;;49         // 参数检验
;;;50         if (NULL == str)
000002  2800              CMP      r0,#0
000004  d10c              BNE      |L19.32|
;;;51         {
;;;52             return 0;
;;;53         }
;;;54     
;;;55         while ('\0' != *localStr)
;;;56         {
;;;57             if (((*localStr) < '0') || ((*localStr) > '9'))
;;;58             {
;;;59                 return 0;
;;;60             }
;;;61     
;;;62             value *= 10;
;;;63             value += (*localStr) - '0';
;;;64             localStr ++;
;;;65         }
;;;66     
;;;67         return value;
;;;68     }
000006  4770              BX       lr
                  |L19.8|
000008  f1a10330          SUB      r3,r1,#0x30           ;57
00000c  2b0a              CMP      r3,#0xa               ;57
00000e  d301              BCC      |L19.20|
000010  2000              MOVS     r0,#0                 ;59
000012  4770              BX       lr
                  |L19.20|
000014  eb020282          ADD      r2,r2,r2,LSL #2       ;62
000018  0052              LSLS     r2,r2,#1              ;62
00001a  3a30              SUBS     r2,r2,#0x30           ;63
00001c  440a              ADD      r2,r2,r1              ;63
00001e  1c40              ADDS     r0,r0,#1              ;64
                  |L19.32|
000020  7801              LDRB     r1,[r0,#0]            ;55
000022  2900              CMP      r1,#0                 ;55
000024  d1f0              BNE      |L19.8|
000026  4610              MOV      r0,r2                 ;67
000028  4770              BX       lr
;;;69     
                          ENDP


;*** Start embedded assembler ***

#line 1 "User\\stringOperation.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___17_stringOperation_c_afa3751a____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___17_stringOperation_c_afa3751a____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___17_stringOperation_c_afa3751a____REVSH|
#line 128
|__asm___17_stringOperation_c_afa3751a____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
