; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\avopin.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\avopin.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -I.\User\qrencode -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.3\Device\Include -D__MICROLIB -D__UVISION_VERSION=539 -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\avopin.crf User\AvoPin.c]
                          THUMB

                          AREA ||i.ADC_HwInit||, CODE, READONLY, ALIGN=2

                  ADC_HwInit PROC
;;;256    // USB硬件ADC初始化
;;;257    void ADC_HwInit(void)
000000  b510              PUSH     {r4,lr}
;;;258    {
;;;259        rcu_periph_clock_enable(RCU_GPIOC);                                 // 时能GPIOC时钟
000002  f2406004          MOV      r0,#0x604
000006  f7fffffe          BL       rcu_periph_clock_enable
;;;260        rcu_periph_clock_enable(RCU_ADC0);                                  // 时能ADC0时钟
00000a  f2406009          MOV      r0,#0x609
00000e  f7fffffe          BL       rcu_periph_clock_enable
;;;261    
;;;262        adc_deinit(ADC0);                                                   // 复位ADC
000012  4c24              LDR      r4,|L1.164|
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       adc_deinit
;;;263        rcu_adc_clock_config(RCU_CKADC_CKAPB2_DIV6);                        // 72/6 = 12 Mhz(最大频率不能超过40M)
00001a  2002              MOVS     r0,#2
00001c  f7fffffe          BL       rcu_adc_clock_config
;;;264    
;;;265        gpio_init(GPIOC, GPIO_MODE_AIN, GPIO_OSPEED_50MHZ, GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2);     
000020  2307              MOVS     r3,#7
000022  2203              MOVS     r2,#3
000024  2100              MOVS     r1,#0
000026  4820              LDR      r0,|L1.168|
000028  f7fffffe          BL       gpio_init
;;;266    
;;;267        // ADC0 配置
;;;268        adc_mode_config(ADC_MODE_FREE);                                     // 独立模式
00002c  2000              MOVS     r0,#0
00002e  f7fffffe          BL       adc_mode_config
;;;269        adc_special_function_config(ADC0, ADC_SCAN_MODE, DISABLE);          // 扫描模式关闭
000032  2200              MOVS     r2,#0
000034  15a1              ASRS     r1,r4,#22
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       adc_special_function_config
;;;270        adc_special_function_config(ADC0, ADC_CONTINUOUS_MODE, DISABLE);    // 连续转换模式关闭
00003c  2200              MOVS     r2,#0
00003e  2102              MOVS     r1,#2
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       adc_special_function_config
;;;271        adc_external_trigger_source_config(ADC0, ADC_REGULAR_CHANNEL, ADC0_1_2_EXTTRIG_REGULAR_NONE);  // 常规通道，软件触发
000046  f44f2260          MOV      r2,#0xe0000
00004a  2101              MOVS     r1,#1
00004c  4620              MOV      r0,r4
00004e  f7fffffe          BL       adc_external_trigger_source_config
;;;272        adc_data_alignment_config(ADC0, ADC_DATAALIGN_RIGHT);               // 数据右对齐
000052  2100              MOVS     r1,#0
000054  4620              MOV      r0,r4
000056  f7fffffe          BL       adc_data_alignment_config
;;;273        adc_channel_length_config(ADC0, ADC_REGULAR_CHANNEL, 1);            // 常规通道数量1
00005a  2201              MOVS     r2,#1
00005c  4611              MOV      r1,r2
00005e  4620              MOV      r0,r4
000060  f7fffffe          BL       adc_channel_length_config
;;;274    
;;;275        // 设置ADC
;;;276        adc_regular_channel_config(ADC0, 0, ADC_CHANNEL_10, ADC_SAMPLETIME_55POINT5);
000064  2305              MOVS     r3,#5
000066  220a              MOVS     r2,#0xa
000068  2100              MOVS     r1,#0
00006a  4620              MOV      r0,r4
00006c  f7fffffe          BL       adc_regular_channel_config
;;;277        adc_regular_channel_config(ADC0, 0, ADC_CHANNEL_11, ADC_SAMPLETIME_55POINT5);
000070  2305              MOVS     r3,#5
000072  220b              MOVS     r2,#0xb
000074  2100              MOVS     r1,#0
000076  4620              MOV      r0,r4
000078  f7fffffe          BL       adc_regular_channel_config
;;;278    //    adc_regular_channel_config(ADC0, 0, ADC_CHANNEL_12, ADC_SAMPLETIME_55POINT5);
;;;279    
;;;280        adc_enable(ADC0);                                                   // 时能ADC0
00007c  4620              MOV      r0,r4
00007e  f7fffffe          BL       adc_enable
;;;281        Delayms(10);
000082  200a              MOVS     r0,#0xa
000084  f7fffffe          BL       Delayms
;;;282        adc_calibration_enable(ADC0);                                       // ADC校准和复位校准
000088  4620              MOV      r0,r4
00008a  f7fffffe          BL       adc_calibration_enable
;;;283    
;;;284        adc_external_trigger_config(ADC0, ADC_REGULAR_CHANNEL, ENABLE);     // 启动ADC0转换
00008e  2201              MOVS     r2,#1
000090  4611              MOV      r1,r2
000092  4620              MOV      r0,r4
000094  f7fffffe          BL       adc_external_trigger_config
;;;285        adc_software_trigger_enable(ADC0, ADC_REGULAR_CHANNEL);
000098  4620              MOV      r0,r4
00009a  e8bd4010          POP      {r4,lr}
00009e  2101              MOVS     r1,#1
0000a0  f7ffbffe          B.W      adc_software_trigger_enable
;;;286    }
;;;287    
                          ENDP

                  |L1.164|
                          DCD      0x40012400
                  |L1.168|
                          DCD      0x40011000

                          AREA ||i.AVO_PIN_Init||, CODE, READONLY, ALIGN=2

                  AVO_PIN_Init PROC
;;;5      // 测试引脚初始化
;;;6      void AVO_PIN_Init(void)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;7      {
;;;8          // 打开时钟
;;;9          rcu_periph_clock_enable(RCU_GPIOA);
000004  f2406002          MOV      r0,#0x602
000008  f7fffffe          BL       rcu_periph_clock_enable
;;;10         rcu_periph_clock_enable(RCU_GPIOB);
00000c  f2406003          MOV      r0,#0x603
000010  f7fffffe          BL       rcu_periph_clock_enable
;;;11         rcu_periph_clock_enable(RCU_GPIOC);
000014  f2406004          MOV      r0,#0x604
000018  f7fffffe          BL       rcu_periph_clock_enable
;;;12         rcu_periph_clock_enable(RCU_GPIOD);
00001c  f2406005          MOV      r0,#0x605
000020  f7fffffe          BL       rcu_periph_clock_enable
;;;13         rcu_periph_clock_enable(RCU_GPIOE);
000024  f2406006          MOV      r0,#0x606
000028  f7fffffe          BL       rcu_periph_clock_enable
;;;14     
;;;15         // 配置为高阻态模式
;;;16         gpio_init(GPIOD, GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_11);      // LED_VCC_TEST_EN
00002c  4d6a              LDR      r5,|L2.472|
00002e  f44f6400          MOV      r4,#0x800
000032  4623              MOV      r3,r4
000034  2203              MOVS     r2,#3
000036  2110              MOVS     r1,#0x10
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       gpio_init
;;;17         gpio_init(GPIOD, GPIO_MODE_IN_FLOATING, GPIO_OSPEED_50MHZ, GPIO_PIN_12); // LED_HBEAM_TEST_EN
00003e  0066              LSLS     r6,r4,#1
000040  4633              MOV      r3,r6
000042  2203              MOVS     r2,#3
000044  2104              MOVS     r1,#4
000046  4628              MOV      r0,r5
000048  f7fffffe          BL       gpio_init
;;;18         gpio_init(GPIOD, GPIO_MODE_IN_FLOATING, GPIO_OSPEED_50MHZ, GPIO_PIN_13); // LED_LBEAM_TEST_EN
00004c  00a7              LSLS     r7,r4,#2
00004e  463b              MOV      r3,r7
000050  2203              MOVS     r2,#3
000052  2104              MOVS     r1,#4
000054  4628              MOV      r0,r5
000056  f7fffffe          BL       gpio_init
;;;19     
;;;20         gpio_init(GPIOD, GPIO_MODE_IN_FLOATING, GPIO_OSPEED_50MHZ, GPIO_PIN_3);   // LEFT_VCC_TEST_EN_EN
00005a  2308              MOVS     r3,#8
00005c  2203              MOVS     r2,#3
00005e  2104              MOVS     r1,#4
000060  4628              MOV      r0,r5
000062  f7fffffe          BL       gpio_init
;;;21         gpio_init(GPIOD, GPIO_MODE_IN_FLOATING, GPIO_OSPEED_50MHZ, GPIO_PIN_4);   // RIGHT_VCC_TEST_EN_EN
000066  2310              MOVS     r3,#0x10
000068  2203              MOVS     r2,#3
00006a  2104              MOVS     r1,#4
00006c  4628              MOV      r0,r5
00006e  f7fffffe          BL       gpio_init
;;;22     
;;;23         gpio_init(GPIOB, GPIO_MODE_IN_FLOATING, GPIO_OSPEED_50MHZ, GPIO_PIN_12);   // LED_VCC_EN
000072  4633              MOV      r3,r6
000074  2203              MOVS     r2,#3
000076  2104              MOVS     r1,#4
000078  4858              LDR      r0,|L2.476|
00007a  f7fffffe          BL       gpio_init
;;;24         gpio_init(GPIOB, GPIO_MODE_IN_FLOATING, GPIO_OSPEED_50MHZ, GPIO_PIN_13);   // LED_HBEAM_EN
00007e  463b              MOV      r3,r7
000080  2203              MOVS     r2,#3
000082  2104              MOVS     r1,#4
000084  4855              LDR      r0,|L2.476|
000086  f7fffffe          BL       gpio_init
;;;25         gpio_init(GPIOB, GPIO_MODE_IN_FLOATING, GPIO_OSPEED_50MHZ, GPIO_PIN_14);   // LED_LBEAM_EN
00008a  00e3              LSLS     r3,r4,#3
00008c  2203              MOVS     r2,#3
00008e  2104              MOVS     r1,#4
000090  4852              LDR      r0,|L2.476|
000092  f7fffffe          BL       gpio_init
;;;26         gpio_init(GPIOB, GPIO_MODE_IN_FLOATING, GPIO_OSPEED_50MHZ, GPIO_PIN_15);   // LEFT_VCC_EN
000096  0127              LSLS     r7,r4,#4
000098  463b              MOV      r3,r7
00009a  2203              MOVS     r2,#3
00009c  2104              MOVS     r1,#4
00009e  484f              LDR      r0,|L2.476|
0000a0  f7fffffe          BL       gpio_init
;;;27         gpio_init(GPIOD, GPIO_MODE_IN_FLOATING, GPIO_OSPEED_50MHZ, GPIO_PIN_8);    // RIGHT_VCC_EN
0000a4  f44f7880          MOV      r8,#0x100
0000a8  4643              MOV      r3,r8
0000aa  2203              MOVS     r2,#3
0000ac  2104              MOVS     r1,#4
0000ae  4628              MOV      r0,r5
0000b0  f7fffffe          BL       gpio_init
;;;28     
;;;29         gpio_init(GPIOC, GPIO_MODE_IN_FLOATING, GPIO_OSPEED_50MHZ, GPIO_PIN_7);  // THROTTLE_GND_TEST_EN_ON
0000b4  f8df9128          LDR      r9,|L2.480|
0000b8  2380              MOVS     r3,#0x80
0000ba  2203              MOVS     r2,#3
0000bc  2104              MOVS     r1,#4
0000be  4648              MOV      r0,r9
0000c0  f7fffffe          BL       gpio_init
;;;30         gpio_init(GPIOA, GPIO_MODE_IN_FLOATING, GPIO_OSPEED_50MHZ, GPIO_PIN_15); // THROTTLE_VCC_TEST_EN_ON
0000c4  f8dfa11c          LDR      r10,|L2.484|
0000c8  463b              MOV      r3,r7
0000ca  2203              MOVS     r2,#3
0000cc  2104              MOVS     r1,#4
0000ce  4650              MOV      r0,r10
0000d0  f7fffffe          BL       gpio_init
;;;31         gpio_init(GPIOD, GPIO_MODE_IN_FLOATING, GPIO_OSPEED_50MHZ, GPIO_PIN_7);  // BRAKE_GND_TEST_EN_ON
0000d4  2380              MOVS     r3,#0x80
0000d6  2203              MOVS     r2,#3
0000d8  2104              MOVS     r1,#4
0000da  4628              MOV      r0,r5
0000dc  f7fffffe          BL       gpio_init
;;;32         gpio_init(GPIOC, GPIO_MODE_IN_FLOATING, GPIO_OSPEED_50MHZ, GPIO_PIN_6);  // BRAKE_VCC_TEST_EN_ON
0000e0  2340              MOVS     r3,#0x40
0000e2  2203              MOVS     r2,#3
0000e4  2104              MOVS     r1,#4
0000e6  4648              MOV      r0,r9
0000e8  f7fffffe          BL       gpio_init
;;;33     
;;;34         gpio_init(GPIOD, GPIO_MODE_IN_FLOATING, GPIO_OSPEED_50MHZ, GPIO_PIN_1);  // DUT_POWER_TEST_EN_ON
0000ec  2302              MOVS     r3,#2
0000ee  2203              MOVS     r2,#3
0000f0  2104              MOVS     r1,#4
0000f2  4628              MOV      r0,r5
0000f4  f7fffffe          BL       gpio_init
;;;35         gpio_init(GPIOD, GPIO_MODE_IN_FLOATING, GPIO_OSPEED_50MHZ, GPIO_PIN_5);  // DUT_VLK_TEST_EN_ON
0000f8  2320              MOVS     r3,#0x20
0000fa  2203              MOVS     r2,#3
0000fc  2104              MOVS     r1,#4
0000fe  4628              MOV      r0,r5
000100  f7fffffe          BL       gpio_init
;;;36     
;;;37         // USB负载测试
;;;38         gpio_init(GPIOE, GPIO_MODE_IN_FLOATING, GPIO_OSPEED_50MHZ, GPIO_PIN_4);  //
000104  f8dfb0e0          LDR      r11,|L2.488|
000108  2310              MOVS     r3,#0x10
00010a  2203              MOVS     r2,#3
00010c  2104              MOVS     r1,#4
00010e  4658              MOV      r0,r11
000110  f7fffffe          BL       gpio_init
;;;39         gpio_init(GPIOE, GPIO_MODE_IN_FLOATING, GPIO_OSPEED_50MHZ, GPIO_PIN_5);  //
000114  2320              MOVS     r3,#0x20
000116  2203              MOVS     r2,#3
000118  2104              MOVS     r1,#4
00011a  4658              MOV      r0,r11
00011c  f7fffffe          BL       gpio_init
;;;40         gpio_init(GPIOE, GPIO_MODE_IN_FLOATING, GPIO_OSPEED_50MHZ, GPIO_PIN_6);  //
000120  2340              MOVS     r3,#0x40
000122  2203              MOVS     r2,#3
000124  2104              MOVS     r1,#4
000126  4658              MOV      r0,r11
000128  f7fffffe          BL       gpio_init
;;;41     
;;;42         // UART
;;;43         gpio_init(GPIOA, GPIO_MODE_IN_FLOATING, GPIO_OSPEED_50MHZ, GPIO_PIN_8);  // DUT_TO_DTA_OFF
00012c  4643              MOV      r3,r8
00012e  2203              MOVS     r2,#3
000130  2104              MOVS     r1,#4
000132  4650              MOV      r0,r10
000134  f7fffffe          BL       gpio_init
;;;44         gpio_init(GPIOD, GPIO_MODE_IN_FLOATING, GPIO_OSPEED_50MHZ, GPIO_PIN_0);  // UART_TEST_EN
000138  2301              MOVS     r3,#1
00013a  2203              MOVS     r2,#3
00013c  2104              MOVS     r1,#4
00013e  4628              MOV      r0,r5
000140  f7fffffe          BL       gpio_init
;;;45     
;;;46         // VLK_PW_EN
;;;47         gpio_init(GPIOB, GPIO_MODE_IN_FLOATING, GPIO_OSPEED_50MHZ, GPIO_PIN_7);
000144  2380              MOVS     r3,#0x80
000146  2203              MOVS     r2,#3
000148  2104              MOVS     r1,#4
00014a  4824              LDR      r0,|L2.476|
00014c  f7fffffe          BL       gpio_init
;;;48         
;;;49         // KEY_TEST_EN0
;;;50         gpio_init(GPIOD, GPIO_MODE_IN_FLOATING, GPIO_OSPEED_50MHZ, GPIO_PIN_15);
000150  463b              MOV      r3,r7
000152  2203              MOVS     r2,#3
000154  2104              MOVS     r1,#4
000156  4628              MOV      r0,r5
000158  f7fffffe          BL       gpio_init
;;;51         // KEY_TEST_EN1
;;;52         gpio_init(GPIOD, GPIO_MODE_IN_FLOATING, GPIO_OSPEED_50MHZ, GPIO_PIN_14);
00015c  00e3              LSLS     r3,r4,#3
00015e  2203              MOVS     r2,#3
000160  2104              MOVS     r1,#4
000162  4628              MOV      r0,r5
000164  f7fffffe          BL       gpio_init
;;;53         // KEY_TEST_EN2
;;;54         gpio_init(GPIOD, GPIO_MODE_IN_FLOATING, GPIO_OSPEED_50MHZ, GPIO_PIN_10);
000168  1063              ASRS     r3,r4,#1
00016a  2203              MOVS     r2,#3
00016c  2104              MOVS     r1,#4
00016e  4628              MOV      r0,r5
000170  f7fffffe          BL       gpio_init
;;;55         // KEY_TEST_EN3
;;;56         gpio_init(GPIOD, GPIO_MODE_IN_FLOATING, GPIO_OSPEED_50MHZ, GPIO_PIN_9);
000174  10a3              ASRS     r3,r4,#2
000176  2203              MOVS     r2,#3
000178  2104              MOVS     r1,#4
00017a  4628              MOV      r0,r5
00017c  f7fffffe          BL       gpio_init
;;;57         // KEY_TEST_EN4
;;;58         gpio_init(GPIOA, GPIO_MODE_IN_FLOATING, GPIO_OSPEED_50MHZ, GPIO_PIN_11);
000180  4623              MOV      r3,r4
000182  2203              MOVS     r2,#3
000184  2104              MOVS     r1,#4
000186  4650              MOV      r0,r10
000188  f7fffffe          BL       gpio_init
;;;59         // KEY_TEST_EN5
;;;60         gpio_init(GPIOA, GPIO_MODE_IN_FLOATING, GPIO_OSPEED_50MHZ, GPIO_PIN_12);
00018c  4633              MOV      r3,r6
00018e  2203              MOVS     r2,#3
000190  2104              MOVS     r1,#4
000192  4650              MOV      r0,r10
000194  f7fffffe          BL       gpio_init
;;;61         // KEY_TEST_EN6
;;;62         gpio_init(GPIOD, GPIO_MODE_IN_FLOATING, GPIO_OSPEED_50MHZ, GPIO_PIN_6);
000198  2340              MOVS     r3,#0x40
00019a  2203              MOVS     r2,#3
00019c  2104              MOVS     r1,#4
00019e  4628              MOV      r0,r5
0001a0  f7fffffe          BL       gpio_init
;;;63         // KEY_TEST_EN7
;;;64         gpio_init(GPIOB, GPIO_MODE_IN_FLOATING, GPIO_OSPEED_50MHZ, GPIO_PIN_6);
0001a4  2340              MOVS     r3,#0x40
0001a6  2203              MOVS     r2,#3
0001a8  2104              MOVS     r1,#4
0001aa  480c              LDR      r0,|L2.476|
0001ac  f7fffffe          BL       gpio_init
;;;65         
;;;66         // 电子变速
;;;67         gpio_init(GPIOC, GPIO_MODE_IN_FLOATING, GPIO_OSPEED_50MHZ, GPIO_PIN_3);  // DERAILLEUR_VCC_TEST_EN
0001b0  2308              MOVS     r3,#8
0001b2  2203              MOVS     r2,#3
0001b4  2104              MOVS     r1,#4
0001b6  4648              MOV      r0,r9
0001b8  f7fffffe          BL       gpio_init
;;;68         gpio_init(GPIOA, GPIO_MODE_IN_FLOATING, GPIO_OSPEED_50MHZ, GPIO_PIN_1);  // DERAILLEUR_GND_TEST_EN
0001bc  2302              MOVS     r3,#2
0001be  2203              MOVS     r2,#3
0001c0  2104              MOVS     r1,#4
0001c2  4650              MOV      r0,r10
0001c4  f7fffffe          BL       gpio_init
;;;69         
;;;70         // 八方电路VLK5V供电使能
;;;71         gpio_init(GPIOE, GPIO_MODE_IN_FLOATING, GPIO_OSPEED_50MHZ, GPIO_PIN_0);  // 5VOUT_EN    
0001c8  4658              MOV      r0,r11
0001ca  e8bd5ff0          POP      {r4-r12,lr}
0001ce  2301              MOVS     r3,#1
0001d0  2203              MOVS     r2,#3
0001d2  2104              MOVS     r1,#4
0001d4  f7ffbffe          B.W      gpio_init
;;;72     }
;;;73     
                          ENDP

                  |L2.472|
                          DCD      0x40011400
                  |L2.476|
                          DCD      0x40010c00
                  |L2.480|
                          DCD      0x40011000
                  |L2.484|
                          DCD      0x40010800
                  |L2.488|
                          DCD      0x40011800

                          AREA ||i.AVO_PIN_Reset||, CODE, READONLY, ALIGN=2

                  AVO_PIN_Reset PROC
;;;74     // 测试引脚复位
;;;75     void AVO_PIN_Reset(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;76     {
;;;77         gpio_bit_reset(GPIOD, GPIO_PIN_11);
000004  4c29              LDR      r4,|L3.172|
000006  f44f6100          MOV      r1,#0x800
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       gpio_bit_reset
;;;78         gpio_bit_reset(GPIOD, GPIO_PIN_12);
000010  14a6              ASRS     r6,r4,#18
000012  4631              MOV      r1,r6
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       gpio_bit_reset
;;;79         gpio_bit_reset(GPIOD, GPIO_PIN_13);
00001a  1465              ASRS     r5,r4,#17
00001c  4629              MOV      r1,r5
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       gpio_bit_reset
;;;80     
;;;81         gpio_bit_reset(GPIOD, GPIO_PIN_3);
000024  2108              MOVS     r1,#8
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       gpio_bit_reset
;;;82         gpio_bit_reset(GPIOD, GPIO_PIN_4);
00002c  2110              MOVS     r1,#0x10
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       gpio_bit_reset
;;;83     
;;;84         gpio_bit_reset(GPIOB, GPIO_PIN_12);
000034  4631              MOV      r1,r6
000036  4e1e              LDR      r6,|L3.176|
000038  4630              MOV      r0,r6
00003a  f7fffffe          BL       gpio_bit_reset
;;;85         gpio_bit_reset(GPIOB, GPIO_PIN_13);
00003e  4629              MOV      r1,r5
000040  4630              MOV      r0,r6
000042  f7fffffe          BL       gpio_bit_reset
;;;86         gpio_bit_reset(GPIOB, GPIO_PIN_14);
000046  0069              LSLS     r1,r5,#1
000048  4630              MOV      r0,r6
00004a  f7fffffe          BL       gpio_bit_reset
;;;87         gpio_bit_reset(GPIOB, GPIO_PIN_15);
00004e  00ad              LSLS     r5,r5,#2
000050  4629              MOV      r1,r5
000052  4630              MOV      r0,r6
000054  f7fffffe          BL       gpio_bit_reset
;;;88         gpio_bit_reset(GPIOD, GPIO_PIN_8);
000058  15a6              ASRS     r6,r4,#22
00005a  4631              MOV      r1,r6
00005c  4620              MOV      r0,r4
00005e  f7fffffe          BL       gpio_bit_reset
;;;89     
;;;90         gpio_bit_reset(GPIOC, GPIO_PIN_7);  // THROTTLE_GND_TEST_EN_ON
000062  4f14              LDR      r7,|L3.180|
000064  2180              MOVS     r1,#0x80
000066  4638              MOV      r0,r7
000068  f7fffffe          BL       gpio_bit_reset
;;;91         gpio_bit_reset(GPIOA, GPIO_PIN_15); // THROTTLE_VCC_TEST_EN_ON
00006c  4629              MOV      r1,r5
00006e  4d12              LDR      r5,|L3.184|
000070  4628              MOV      r0,r5
000072  f7fffffe          BL       gpio_bit_reset
;;;92         gpio_bit_reset(GPIOD, GPIO_PIN_7);  // BRAKE_GND_TEST_EN_ON
000076  2180              MOVS     r1,#0x80
000078  4620              MOV      r0,r4
00007a  f7fffffe          BL       gpio_bit_reset
;;;93         gpio_bit_reset(GPIOC, GPIO_PIN_6);  // BRAKE_VCC_TEST_EN_ON
00007e  2140              MOVS     r1,#0x40
000080  4638              MOV      r0,r7
000082  f7fffffe          BL       gpio_bit_reset
;;;94     
;;;95         gpio_bit_reset(GPIOD, GPIO_PIN_1);
000086  2102              MOVS     r1,#2
000088  4620              MOV      r0,r4
00008a  f7fffffe          BL       gpio_bit_reset
;;;96         gpio_bit_reset(GPIOD, GPIO_PIN_5);
00008e  2120              MOVS     r1,#0x20
000090  4620              MOV      r0,r4
000092  f7fffffe          BL       gpio_bit_reset
;;;97     
;;;98         gpio_bit_reset(GPIOA, GPIO_PIN_8);  // DUT_TO_DTA_OFF
000096  4631              MOV      r1,r6
000098  4628              MOV      r0,r5
00009a  f7fffffe          BL       gpio_bit_reset
;;;99         gpio_bit_reset(GPIOD, GPIO_PIN_0);  // UART_TEST_EN
00009e  4620              MOV      r0,r4
0000a0  e8bd41f0          POP      {r4-r8,lr}
0000a4  2101              MOVS     r1,#1
0000a6  f7ffbffe          B.W      gpio_bit_reset
;;;100    
;;;101    }
;;;102    
                          ENDP

0000aa  0000              DCW      0x0000
                  |L3.172|
                          DCD      0x40011400
                  |L3.176|
                          DCD      0x40010c00
                  |L3.180|
                          DCD      0x40011000
                  |L3.184|
                          DCD      0x40010800

                          AREA ||i.DAC0_output||, CODE, READONLY, ALIGN=1

                  DAC0_output PROC
;;;172    // 油门DAC输出
;;;173    void DAC0_output(uint16_t value)
000000  b510              PUSH     {r4,lr}
;;;174    {
000002  4604              MOV      r4,r0
;;;175        dac_enable(DAC0); //使能 DAC0
000004  2000              MOVS     r0,#0
000006  f7fffffe          BL       dac_enable
;;;176        dac_data_set(DAC0, DAC_ALIGN_12B_R, (value / 2 * 4096 / 3300));  // 设置输出值
00000a  0860              LSRS     r0,r4,#1
00000c  0300              LSLS     r0,r0,#12
00000e  f64041e4          MOV      r1,#0xce4
000012  fbb0f0f1          UDIV     r0,r0,r1
000016  b282              UXTH     r2,r0
000018  2100              MOVS     r1,#0
00001a  4608              MOV      r0,r1
00001c  f7fffffe          BL       dac_data_set
;;;177        dac_software_trigger_enable(DAC0);
000020  e8bd4010          POP      {r4,lr}
000024  2000              MOVS     r0,#0
000026  f7ffbffe          B.W      dac_software_trigger_enable
;;;178    }
;;;179    
                          ENDP


                          AREA ||i.DAC1_output||, CODE, READONLY, ALIGN=1

                  DAC1_output PROC
;;;180    // 刹车DAC输出
;;;181    void DAC1_output(uint16_t value)
000000  b510              PUSH     {r4,lr}
;;;182    {
000002  4604              MOV      r4,r0
;;;183        dac_enable(DAC1); //使能 DAC0
000004  2001              MOVS     r0,#1
000006  f7fffffe          BL       dac_enable
;;;184    
;;;185        // 运放放大器放大两倍
;;;186        dac_data_set(DAC1, DAC_ALIGN_12B_R, (value / 2 * 4096 / 3300)); // 设置输出值
00000a  0860              LSRS     r0,r4,#1
00000c  0300              LSLS     r0,r0,#12
00000e  f64041e4          MOV      r1,#0xce4
000012  fbb0f0f1          UDIV     r0,r0,r1
000016  b282              UXTH     r2,r0
000018  2100              MOVS     r1,#0
00001a  2001              MOVS     r0,#1
00001c  f7fffffe          BL       dac_data_set
;;;187        dac_software_trigger_enable(DAC1);
000020  e8bd4010          POP      {r4,lr}
000024  2001              MOVS     r0,#1
000026  f7ffbffe          B.W      dac_software_trigger_enable
;;;188    }
;;;189    
                          ENDP


                          AREA ||i.DAC_Init||, CODE, READONLY, ALIGN=2

                  DAC_Init PROC
;;;145    // DAC初始化
;;;146    void DAC_Init(void)
000000  b510              PUSH     {r4,lr}
;;;147    {
;;;148        rcu_periph_clock_enable(RCU_DAC);
000002  f240701d          MOV      r0,#0x71d
000006  f7fffffe          BL       rcu_periph_clock_enable
;;;149        rcu_periph_clock_enable(RCU_GPIOA);
00000a  f2406002          MOV      r0,#0x602
00000e  f7fffffe          BL       rcu_periph_clock_enable
;;;150    
;;;151        gpio_init(GPIOA, GPIO_MODE_AIN, GPIO_OSPEED_50MHZ, GPIO_PIN_4);
000012  4c11              LDR      r4,|L6.88|
000014  2310              MOVS     r3,#0x10
000016  2203              MOVS     r2,#3
000018  2100              MOVS     r1,#0
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       gpio_init
;;;152        gpio_init(GPIOA, GPIO_MODE_AIN, GPIO_OSPEED_50MHZ, GPIO_PIN_5);
000020  2320              MOVS     r3,#0x20
000022  2203              MOVS     r2,#3
000024  2100              MOVS     r1,#0
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       gpio_init
;;;153    
;;;154        // 配置DAC1
;;;155        dac_trigger_disable(DAC0);
00002c  2000              MOVS     r0,#0
00002e  f7fffffe          BL       dac_trigger_disable
;;;156        dac_wave_mode_config(DAC0, DAC_WAVE_DISABLE);
000032  2100              MOVS     r1,#0
000034  4608              MOV      r0,r1
000036  f7fffffe          BL       dac_wave_mode_config
;;;157        dac_output_buffer_enable(DAC0);
00003a  2000              MOVS     r0,#0
00003c  f7fffffe          BL       dac_output_buffer_enable
;;;158    
;;;159        // 配置DAC2
;;;160        dac_trigger_disable(DAC1);
000040  2001              MOVS     r0,#1
000042  f7fffffe          BL       dac_trigger_disable
;;;161        dac_wave_mode_config(DAC1, DAC_WAVE_DISABLE);
000046  2100              MOVS     r1,#0
000048  2001              MOVS     r0,#1
00004a  f7fffffe          BL       dac_wave_mode_config
;;;162        dac_output_buffer_enable(DAC1);
00004e  e8bd4010          POP      {r4,lr}
000052  2001              MOVS     r0,#1
000054  f7ffbffe          B.W      dac_output_buffer_enable
;;;163    }
;;;164    
                          ENDP

                  |L6.88|
                          DCD      0x40010800

                          AREA ||i.DAC_Uinit||, CODE, READONLY, ALIGN=1

                  DAC_Uinit PROC
;;;165    // DAC失能
;;;166    void DAC_Uinit(void)
000000  b510              PUSH     {r4,lr}
;;;167    {
;;;168        dac_disable(DAC0);
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       dac_disable
;;;169        dac_disable(DAC1);
000008  e8bd4010          POP      {r4,lr}
00000c  2001              MOVS     r0,#1
00000e  f7ffbffe          B.W      dac_disable
;;;170    }
;;;171    
                          ENDP


                          AREA ||i.Delayms||, CODE, READONLY, ALIGN=1

                  Delayms PROC
;;;235    // 简单延时
;;;236    void Delayms(uint16 i)
000000  b510              PUSH     {r4,lr}
;;;237    {
;;;238        uint16 x;
;;;239        uint16 y;
;;;240    
;;;241        // 内核72MHz，1ms
;;;242        while (i--)
;;;243        {
;;;244            x = 1000;
000002  f44f747a          MOV      r4,#0x3e8
000006  e00a              B        |L8.30|
                  |L8.8|
000008  4622              MOV      r2,r4
;;;245            while (x--)
00000a  e005              B        |L8.24|
                  |L8.12|
;;;246            {
;;;247                y = 10;
00000c  210a              MOVS     r1,#0xa
;;;248                while (y--)
00000e  e000              B        |L8.18|
                  |L8.16|
;;;249                {
;;;250                    NOP();
000010  bf00              NOP      
                  |L8.18|
000012  1e49              SUBS     r1,r1,#1              ;248
000014  b289              UXTH     r1,r1                 ;248
000016  d2fb              BCS      |L8.16|
                  |L8.24|
000018  1e52              SUBS     r2,r2,#1              ;245
00001a  b292              UXTH     r2,r2                 ;245
00001c  d2f6              BCS      |L8.12|
                  |L8.30|
00001e  1e40              SUBS     r0,r0,#1              ;242
000020  b280              UXTH     r0,r0                 ;242
000022  d2f1              BCS      |L8.8|
;;;251                }
;;;252            }
;;;253        }
;;;254    }
000024  bd10              POP      {r4,pc}
;;;255    
                          ENDP


                          AREA ||i.Delayus||, CODE, READONLY, ALIGN=1

                  Delayus PROC
;;;190    // 简单延时
;;;191    void Delayus(uint16 i)
000000  e023              B        |L9.74|
                  |L9.2|
;;;192    {
;;;193        // 内核72MHz，1us
;;;194        while (i--)
;;;195        {
;;;196            NOP();
000002  bf00              NOP      
;;;197            NOP();
000004  bf00              NOP      
;;;198            NOP();
000006  bf00              NOP      
;;;199            NOP();
000008  bf00              NOP      
;;;200            NOP();
00000a  bf00              NOP      
;;;201            NOP();
00000c  bf00              NOP      
;;;202            NOP();
00000e  bf00              NOP      
;;;203            NOP();
000010  bf00              NOP      
;;;204            NOP();
000012  bf00              NOP      
;;;205            NOP();  // 10
000014  bf00              NOP      
;;;206            NOP();
000016  bf00              NOP      
;;;207            NOP();
000018  bf00              NOP      
;;;208            NOP();
00001a  bf00              NOP      
;;;209            NOP();
00001c  bf00              NOP      
;;;210            NOP();
00001e  bf00              NOP      
;;;211            NOP();
000020  bf00              NOP      
;;;212            NOP();
000022  bf00              NOP      
;;;213            NOP();
000024  bf00              NOP      
;;;214            NOP();
000026  bf00              NOP      
;;;215            NOP();  // 10
000028  bf00              NOP      
;;;216            NOP();
00002a  bf00              NOP      
;;;217            NOP();
00002c  bf00              NOP      
;;;218            NOP();
00002e  bf00              NOP      
;;;219            NOP();
000030  bf00              NOP      
;;;220            NOP();
000032  bf00              NOP      
;;;221            NOP();
000034  bf00              NOP      
;;;222            NOP();
000036  bf00              NOP      
;;;223            NOP();
000038  bf00              NOP      
;;;224            NOP();
00003a  bf00              NOP      
;;;225            NOP();  // 10
00003c  bf00              NOP      
;;;226            NOP();
00003e  bf00              NOP      
;;;227            NOP();
000040  bf00              NOP      
;;;228            NOP();
000042  bf00              NOP      
;;;229            NOP();
000044  bf00              NOP      
;;;230            NOP();
000046  bf00              NOP      
;;;231            NOP();  // 6
000048  bf00              NOP      
                  |L9.74|
00004a  1e40              SUBS     r0,r0,#1              ;194
00004c  b280              UXTH     r0,r0                 ;194
00004e  d2d8              BCS      |L9.2|
;;;232        }
;;;233    }
000050  4770              BX       lr
;;;234    
                          ENDP


                          AREA ||i.KEY_ADC_Read||, CODE, READONLY, ALIGN=2

                  KEY_ADC_Read PROC
;;;415    */
;;;416    uint16_t KEY_ADC_Read(void)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;417    {
000004  b086              SUB      sp,sp,#0x18
;;;418        uint16_t real_voltage = 0;
;;;419        uint16_t adc_values[10] = {0};
000006  2114              MOVS     r1,#0x14
000008  a801              ADD      r0,sp,#4
00000a  f7fffffe          BL       __aeabi_memclr4
;;;420        uint16_t min_value = adc_values[0];
00000e  f8bd5004          LDRH     r5,[sp,#4]
;;;421        uint16_t max_value = adc_values[0];
000012  462e              MOV      r6,r5
;;;422        uint16_t adcValue = 0;
;;;423        uint16_t vol = 0;
;;;424        uint16_t sum = 0;
000014  2700              MOVS     r7,#0
;;;425        int count = 0;
000016  46b8              MOV      r8,r7
;;;426        int i = 0;
000018  2400              MOVS     r4,#0
;;;427        int j = 0;
;;;428    
;;;429        // 采样ADC 10次
;;;430        for (i = 0; i < 10; i++)
;;;431        {
;;;432    		// 配置ADC通道转换顺序，采样时间为55.5个时钟周期
;;;433            adc_regular_channel_config(ADC0, 0, ADC_CHANNEL_12, ADC_SAMPLETIME_55POINT5);
00001a  f8dfa090          LDR      r10,|L10.172|
00001e  f10d0904          ADD      r9,sp,#4              ;419
                  |L10.34|
000022  2305              MOVS     r3,#5
000024  220c              MOVS     r2,#0xc
000026  2100              MOVS     r1,#0
000028  4650              MOV      r0,r10
00002a  f7fffffe          BL       adc_regular_channel_config
;;;434            
;;;435            // 由于没有采用外部触发，所以使用软件触发ADC转换
;;;436            adc_software_trigger_enable(ADC0, ADC_REGULAR_CHANNEL);				
00002e  2101              MOVS     r1,#1
000030  4650              MOV      r0,r10
000032  f7fffffe          BL       adc_software_trigger_enable
                  |L10.54|
;;;437    				
;;;438            while (!adc_flag_get(ADC0, ADC_FLAG_EOC));                      // 等待采样完成
000036  2102              MOVS     r1,#2
000038  4650              MOV      r0,r10
00003a  f7fffffe          BL       adc_flag_get
00003e  2800              CMP      r0,#0
000040  d0f9              BEQ      |L10.54|
;;;439            adc_flag_clear(ADC0, ADC_FLAG_EOC);                             // 清除结束标志
000042  2102              MOVS     r1,#2
000044  4650              MOV      r0,r10
000046  f7fffffe          BL       adc_flag_clear
;;;440            adc_values[i] = adc_regular_data_read(ADC0);                    // 读取ADC数据
00004a  4650              MOV      r0,r10
00004c  f7fffffe          BL       adc_regular_data_read
000050  f8290014          STRH     r0,[r9,r4,LSL #1]
000054  1c64              ADDS     r4,r4,#1              ;430
000056  2c0a              CMP      r4,#0xa               ;430
000058  dbe3              BLT      |L10.34|
;;;441        }
;;;442    
;;;443        // 对数组进行排序并去掉最大和最小值
;;;444        for (j = 1; j < 10; j++)
00005a  2001              MOVS     r0,#1
                  |L10.92|
;;;445        {
;;;446            if (adc_values[j] < min_value)
00005c  f8391010          LDRH     r1,[r9,r0,LSL #1]
000060  42a9              CMP      r1,r5
000062  d200              BCS      |L10.102|
;;;447            {
;;;448                min_value = adc_values[j];
000064  460d              MOV      r5,r1
                  |L10.102|
;;;449            }
;;;450            if (adc_values[j] > max_value)
000066  42b1              CMP      r1,r6
000068  d900              BLS      |L10.108|
;;;451            {
;;;452                max_value = adc_values[j];
00006a  460e              MOV      r6,r1
                  |L10.108|
00006c  1c40              ADDS     r0,r0,#1              ;444
00006e  280a              CMP      r0,#0xa               ;444
000070  dbf4              BLT      |L10.92|
;;;453            }
;;;454        }
;;;455    
;;;456        for (j = 0; j < 10; j++)
000072  2000              MOVS     r0,#0
                  |L10.116|
;;;457        {
;;;458            if (adc_values[j] != min_value && adc_values[j] != max_value)
000074  f8391010          LDRH     r1,[r9,r0,LSL #1]
000078  42a9              CMP      r1,r5
00007a  d005              BEQ      |L10.136|
00007c  42b1              CMP      r1,r6
00007e  d003              BEQ      |L10.136|
;;;459            {
;;;460                sum += adc_values[j];
000080  4439              ADD      r1,r1,r7
000082  b28f              UXTH     r7,r1
;;;461                count++;
000084  f1080801          ADD      r8,r8,#1
                  |L10.136|
000088  1c40              ADDS     r0,r0,#1              ;456
00008a  280a              CMP      r0,#0xa               ;456
00008c  dbf2              BLT      |L10.116|
;;;462            }
;;;463        }
;;;464    
;;;465        adcValue = sum / count;
00008e  fb97f0f8          SDIV     r0,r7,r8
000092  b280              UXTH     r0,r0
;;;466    //    adcValue = max_value;
;;;467    
;;;468        vol = adcValue * 3300 / 4095;                                   // 转换成电压值，单位mv
000094  f64041e4          MOV      r1,#0xce4
000098  4348              MULS     r0,r1,r0
00009a  f64071ff          MOV      r1,#0xfff
00009e  fbb0f0f1          UDIV     r0,r0,r1
0000a2  b280              UXTH     r0,r0
;;;469        real_voltage = vol ;// 2 * vol;     // 实际电压值
;;;470        return real_voltage;
;;;471    }
0000a4  b006              ADD      sp,sp,#0x18
0000a6  e8bd87f0          POP      {r4-r10,pc}
;;;472    
                          ENDP

0000aa  0000              DCW      0x0000
                  |L10.172|
                          DCD      0x40012400

                          AREA ||i.THROTTLE_VCC_TEST_EN||, CODE, READONLY, ALIGN=2

                  THROTTLE_VCC_TEST_EN PROC
;;;122    
;;;123    void THROTTLE_VCC_TEST_EN(uint8_t level)
000000  b570              PUSH     {r4-r6,lr}
;;;124    {
000002  4604              MOV      r4,r0
;;;125        //1.GPIO引脚时钟使能
;;;126        rcu_periph_clock_enable(RCU_GPIOA);
000004  f2406002          MOV      r0,#0x602
000008  f7fffffe          BL       rcu_periph_clock_enable
;;;127    
;;;128        //3.GPIO配置为推完输出模式
;;;129        gpio_init(GPIOA, GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_15);
00000c  4e0d              LDR      r6,|L11.68|
00000e  f44f4500          MOV      r5,#0x8000
000012  462b              MOV      r3,r5
000014  2203              MOVS     r2,#3
000016  2110              MOVS     r1,#0x10
000018  4630              MOV      r0,r6
00001a  f7fffffe          BL       gpio_init
;;;130    
;;;131        //4.重映射配置：JTAG-DP禁用和SW-DP使能
;;;132        gpio_pin_remap_config(GPIO_SWJ_SWDPENABLE_REMAP, ENABLE);
00001e  2101              MOVS     r1,#1
000020  4809              LDR      r0,|L11.72|
000022  f7fffffe          BL       gpio_pin_remap_config
;;;133    
;;;134        //5.引脚配置为低电平或高电平
;;;135        if (level == 1)
000026  2c01              CMP      r4,#1
000028  d005              BEQ      |L11.54|
;;;136        {
;;;137            gpio_bit_set(GPIOA, GPIO_PIN_15);
;;;138        }
;;;139        else
;;;140        {
;;;141            gpio_bit_reset(GPIOA, GPIO_PIN_15);
00002a  4629              MOV      r1,r5
00002c  4630              MOV      r0,r6
00002e  e8bd4070          POP      {r4-r6,lr}
000032  f7ffbffe          B.W      gpio_bit_reset
                  |L11.54|
000036  4629              MOV      r1,r5                 ;137
000038  4630              MOV      r0,r6                 ;137
00003a  e8bd4070          POP      {r4-r6,lr}            ;137
00003e  f7ffbffe          B.W      gpio_bit_set
;;;142        }
;;;143    }
;;;144    
                          ENDP

000042  0000              DCW      0x0000
                  |L11.68|
                          DCD      0x40010800
                  |L11.72|
                          DCD      0x00300200

                          AREA ||i.USB_ADC_Read||, CODE, READONLY, ALIGN=2

                  USB_ADC_Read PROC
;;;291    */
;;;292    uint16_t USB_ADC_Read(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;293    {
000004  b086              SUB      sp,sp,#0x18
;;;294        uint16_t real_voltage = 0;
;;;295        uint16_t adc_values[10] = {0};
000006  2114              MOVS     r1,#0x14
000008  a801              ADD      r0,sp,#4
00000a  f7fffffe          BL       __aeabi_memclr4
;;;296        uint16_t min_value = adc_values[0];
00000e  f8bd7004          LDRH     r7,[sp,#4]
;;;297        uint16_t max_value = adc_values[0];
000012  463e              MOV      r6,r7
;;;298        uint16_t adcValue = 0;
;;;299        uint16_t vol = 0;
;;;300    //    uint16_t sum = 0;
;;;301    //    int count = 0;
;;;302        int i = 0;
000014  2400              MOVS     r4,#0
;;;303        int j = 0;
;;;304    
;;;305        // 采样ADC 10次
;;;306        for (i = 0; i < 10; i++)
;;;307        {
;;;308    		
;;;309    		// 配置ADC通道转换顺序，采样时间为55.5个时钟周期
;;;310            adc_regular_channel_config(ADC0, 0, ADC_CHANNEL_10, ADC_SAMPLETIME_55POINT5);
000016  4d1d              LDR      r5,|L12.140|
000018  f10d0804          ADD      r8,sp,#4              ;295
                  |L12.28|
00001c  2305              MOVS     r3,#5
00001e  220a              MOVS     r2,#0xa
000020  2100              MOVS     r1,#0
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       adc_regular_channel_config
;;;311            
;;;312            // 由于没有采用外部触发，所以使用软件触发ADC转换
;;;313            adc_software_trigger_enable(ADC0, ADC_REGULAR_CHANNEL);				
000028  2101              MOVS     r1,#1
00002a  4628              MOV      r0,r5
00002c  f7fffffe          BL       adc_software_trigger_enable
                  |L12.48|
;;;314    				
;;;315            while (!adc_flag_get(ADC0, ADC_FLAG_EOC));                      // 等待采样完成
000030  2102              MOVS     r1,#2
000032  4628              MOV      r0,r5
000034  f7fffffe          BL       adc_flag_get
000038  2800              CMP      r0,#0
00003a  d0f9              BEQ      |L12.48|
;;;316            adc_flag_clear(ADC0, ADC_FLAG_EOC);                             // 清除结束标志
00003c  2102              MOVS     r1,#2
00003e  4628              MOV      r0,r5
000040  f7fffffe          BL       adc_flag_clear
;;;317            adc_values[i] = adc_regular_data_read(ADC0);                    // 读取ADC数据
000044  4628              MOV      r0,r5
000046  f7fffffe          BL       adc_regular_data_read
00004a  f8280014          STRH     r0,[r8,r4,LSL #1]
00004e  1c64              ADDS     r4,r4,#1              ;306
000050  2c0a              CMP      r4,#0xa               ;306
000052  dbe3              BLT      |L12.28|
;;;318    				
;;;319    
;;;320        }
;;;321    
;;;322        // 对数组进行排序并去掉最大和最小值
;;;323        for (j = 1; j < 10; j++)
000054  2001              MOVS     r0,#1
                  |L12.86|
;;;324        {
;;;325            if (adc_values[j] < min_value)
000056  f8385010          LDRH     r5,[r8,r0,LSL #1]
00005a  42bd              CMP      r5,r7
00005c  d200              BCS      |L12.96|
;;;326            {
;;;327                min_value = adc_values[j];
00005e  462f              MOV      r7,r5
                  |L12.96|
;;;328            }
;;;329            if (adc_values[j] > max_value)
000060  42b5              CMP      r5,r6
000062  d900              BLS      |L12.102|
;;;330            {
;;;331                max_value = adc_values[j];
000064  462e              MOV      r6,r5
                  |L12.102|
000066  1c40              ADDS     r0,r0,#1              ;323
000068  280a              CMP      r0,#0xa               ;323
00006a  dbf4              BLT      |L12.86|
;;;332            }
;;;333        }
;;;334    
;;;335    //    for (j = 0; j < 10; j++)
;;;336    //    {
;;;337    //        if (adc_values[j] != min_value && adc_values[j] != max_value)
;;;338    //        {
;;;339    //            sum += adc_values[j];
;;;340    //            count++;
;;;341    //        }
;;;342    //    }
;;;343    
;;;344    //    adcValue = sum / count;
;;;345        adcValue = max_value;
;;;346    
;;;347        vol = adcValue * 3300 / 4095;                                   // 转换成电压值，单位mv
00006c  f64040e4          MOV      r0,#0xce4
000070  4346              MULS     r6,r0,r6
000072  f64070ff          MOV      r0,#0xfff
000076  fbb6f0f0          UDIV     r0,r6,r0
00007a  b280              UXTH     r0,r0
;;;348        real_voltage = 2 * vol;     // 实际电压值
00007c  f64f71ff          MOV      r1,#0xffff
000080  ea010040          AND      r0,r1,r0,LSL #1
;;;349        return real_voltage;
;;;350    }
000084  b006              ADD      sp,sp,#0x18
000086  e8bd81f0          POP      {r4-r8,pc}
;;;351    
                          ENDP

00008a  0000              DCW      0x0000
                  |L12.140|
                          DCD      0x40012400

                          AREA ||i.USB_CURRENT_Read||, CODE, READONLY, ALIGN=2

                  USB_CURRENT_Read PROC
;;;355     */
;;;356    uint16_t USB_CURRENT_Read(void)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;357    {
000004  b086              SUB      sp,sp,#0x18
;;;358        uint16_t current = 0;
;;;359        uint16_t adc_values[10] = {0};
000006  2114              MOVS     r1,#0x14
000008  a801              ADD      r0,sp,#4
00000a  f7fffffe          BL       __aeabi_memclr4
;;;360        uint16_t min_value = adc_values[0];
00000e  f8bd5004          LDRH     r5,[sp,#4]
;;;361        uint16_t max_value = adc_values[0];
000012  462e              MOV      r6,r5
;;;362        uint16_t vol = 0;
;;;363        uint16_t adcValue = 0;
;;;364        uint16_t sum = 0;
000014  2700              MOVS     r7,#0
;;;365        int count = 0;
000016  46b8              MOV      r8,r7
;;;366        int i = 0;
000018  2400              MOVS     r4,#0
;;;367        int j = 0;
;;;368    
;;;369        // 采样ADC 10次
;;;370        for (i = 0; i < 10; i++)
;;;371        {
;;;372            // 配置ADC通道转换顺序，采样时间为55.5个时钟周期
;;;373            adc_regular_channel_config(ADC0, 0, ADC_CHANNEL_11, ADC_SAMPLETIME_55POINT5);
00001a  f8dfa09c          LDR      r10,|L13.184|
00001e  f10d0904          ADD      r9,sp,#4              ;359
                  |L13.34|
000022  2305              MOVS     r3,#5
000024  220b              MOVS     r2,#0xb
000026  2100              MOVS     r1,#0
000028  4650              MOV      r0,r10
00002a  f7fffffe          BL       adc_regular_channel_config
;;;374    
;;;375            // 由于没有采用外部触发，所以使用软件触发ADC转换
;;;376            adc_software_trigger_enable(ADC0, ADC_REGULAR_CHANNEL);
00002e  2101              MOVS     r1,#1
000030  4650              MOV      r0,r10
000032  f7fffffe          BL       adc_software_trigger_enable
                  |L13.54|
;;;377            while (!adc_flag_get(ADC0, ADC_FLAG_EOC));                      // 等待采样完成
000036  2102              MOVS     r1,#2
000038  4650              MOV      r0,r10
00003a  f7fffffe          BL       adc_flag_get
00003e  2800              CMP      r0,#0
000040  d0f9              BEQ      |L13.54|
;;;378            adc_flag_clear(ADC0, ADC_FLAG_EOC);                             // 清除结束标志
000042  2102              MOVS     r1,#2
000044  4650              MOV      r0,r10
000046  f7fffffe          BL       adc_flag_clear
;;;379            adc_values[i] = adc_regular_data_read(ADC0);                         // 读取ADC数据
00004a  4650              MOV      r0,r10
00004c  f7fffffe          BL       adc_regular_data_read
000050  f8290014          STRH     r0,[r9,r4,LSL #1]
000054  1c64              ADDS     r4,r4,#1              ;370
000056  2c0a              CMP      r4,#0xa               ;370
000058  dbe3              BLT      |L13.34|
;;;380        }
;;;381    
;;;382        // 对数组进行排序并去掉最大和最小值
;;;383        for (j = 1; j < 10; j++)
00005a  2001              MOVS     r0,#1
                  |L13.92|
;;;384        {
;;;385            if (adc_values[j] < min_value)
00005c  f8391010          LDRH     r1,[r9,r0,LSL #1]
000060  42a9              CMP      r1,r5
000062  d200              BCS      |L13.102|
;;;386            {
;;;387                min_value = adc_values[j];
000064  460d              MOV      r5,r1
                  |L13.102|
;;;388            }
;;;389            if (adc_values[j] > max_value)
000066  42b1              CMP      r1,r6
000068  d900              BLS      |L13.108|
;;;390            {
;;;391                max_value = adc_values[j];
00006a  460e              MOV      r6,r1
                  |L13.108|
00006c  1c40              ADDS     r0,r0,#1              ;383
00006e  280a              CMP      r0,#0xa               ;383
000070  dbf4              BLT      |L13.92|
;;;392            }
;;;393        }
;;;394    
;;;395        for (j = 0; j < 10; j++)
000072  2000              MOVS     r0,#0
                  |L13.116|
;;;396        {
;;;397            if (adc_values[j] != min_value && adc_values[j] != max_value)
000074  f8391010          LDRH     r1,[r9,r0,LSL #1]
000078  42a9              CMP      r1,r5
00007a  d005              BEQ      |L13.136|
00007c  42b1              CMP      r1,r6
00007e  d003              BEQ      |L13.136|
;;;398            {
;;;399                sum += adc_values[j];
000080  4439              ADD      r1,r1,r7
000082  b28f              UXTH     r7,r1
;;;400                count++;
000084  f1080801          ADD      r8,r8,#1
                  |L13.136|
000088  1c40              ADDS     r0,r0,#1              ;395
00008a  280a              CMP      r0,#0xa               ;395
00008c  dbf2              BLT      |L13.116|
;;;401            }
;;;402        }
;;;403    
;;;404        adcValue = sum / count;
00008e  fb97f0f8          SDIV     r0,r7,r8
000092  b280              UXTH     r0,r0
;;;405        vol = adcValue * 3300 / 4095;
000094  f64041e4          MOV      r1,#0xce4
000098  4348              MULS     r0,r1,r0
00009a  f64071ff          MOV      r1,#0xfff
00009e  fbb0f0f1          UDIV     r0,r0,r1
0000a2  b280              UXTH     r0,r0
;;;406    
;;;407        // 实际电流值，单位：A（20mR电阻，采集到的adc值被放大了50倍）
;;;408        current = vol * 1000/ 50 / 20 ;
0000a4  f44f717a          MOV      r1,#0x3e8
0000a8  4348              MULS     r0,r1,r0
0000aa  fbb0f0f1          UDIV     r0,r0,r1
0000ae  b280              UXTH     r0,r0
;;;409        return current;
;;;410    }
0000b0  b006              ADD      sp,sp,#0x18
0000b2  e8bd87f0          POP      {r4-r10,pc}
;;;411    
                          ENDP

0000b6  0000              DCW      0x0000
                  |L13.184|
                          DCD      0x40012400

                          AREA ||i._5VOUT_EN||, CODE, READONLY, ALIGN=2

                  _5VOUT_EN PROC
;;;103    // 电源使能、八方高标VLK供电
;;;104    void _5VOUT_EN(uint8_t level)
000000  b570              PUSH     {r4-r6,lr}
;;;105    {
000002  4604              MOV      r4,r0
;;;106        //1.GPIO引脚时钟使能
;;;107        rcu_periph_clock_enable(RCU_GPIOE);
000004  f2406006          MOV      r0,#0x606
000008  f7fffffe          BL       rcu_periph_clock_enable
;;;108    
;;;109        //2.GPIO配置为推完输出模式
;;;110        gpio_init(GPIOE, GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_0);
00000c  4d0a              LDR      r5,|L14.56|
00000e  2301              MOVS     r3,#1
000010  2203              MOVS     r2,#3
000012  2110              MOVS     r1,#0x10
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       gpio_init
;;;111    
;;;112        //3.引脚配置为低电平或高电平
;;;113        if (level == 1)
00001a  2c01              CMP      r4,#1
00001c  d005              BEQ      |L14.42|
;;;114        {
;;;115            gpio_bit_set(GPIOE, GPIO_PIN_0);
;;;116        }
;;;117        else
;;;118        {
;;;119            gpio_bit_reset(GPIOE, GPIO_PIN_0);
00001e  4628              MOV      r0,r5
000020  e8bd4070          POP      {r4-r6,lr}
000024  2101              MOVS     r1,#1
000026  f7ffbffe          B.W      gpio_bit_reset
                  |L14.42|
00002a  4628              MOV      r0,r5                 ;115
00002c  e8bd4070          POP      {r4-r6,lr}            ;115
000030  2101              MOVS     r1,#1                 ;115
000032  f7ffbffe          B.W      gpio_bit_set
;;;120        }
;;;121    }
;;;122    
                          ENDP

000036  0000              DCW      0x0000
                  |L14.56|
                          DCD      0x40011800

;*** Start embedded assembler ***

#line 1 "User\\AvoPin.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_AvoPin_c_cee49c21____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___8_AvoPin_c_cee49c21____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_AvoPin_c_cee49c21____REVSH|
#line 128
|__asm___8_AvoPin_c_cee49c21____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
