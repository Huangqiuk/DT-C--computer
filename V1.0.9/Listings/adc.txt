; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\adc.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\adc.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -I.\User\qrencode -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.3\Device\Include -D__MICROLIB -D__UVISION_VERSION=539 -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\adc.crf User\adc.c]
                          THUMB

                          AREA ||i.ADC_AddDataToBuff||, CODE, READONLY, ALIGN=2

                  ADC_AddDataToBuff PROC
;;;318    // 向缓冲区中添加一个数据
;;;319    void ADC_AddDataToBuff(ADC_CHANNEL_E channel, uint16 data)
000000  b570              PUSH     {r4-r6,lr}
;;;320    {
;;;321    	uint8 i;
;;;322    	uint32 total;
;;;323    	uint16 min = 0xFFFF, max = 0;
000002  f64f72ff          MOV      r2,#0xffff
000006  2300              MOVS     r3,#0
;;;324    
;;;325    	// 用来切换有电流和无电流数据填充的标志
;;;326    	static BOOL noCurrentActionFlag = TRUE;
;;;327    	static BOOL currentActionFlag = TRUE;
;;;328    	
;;;329    	switch(channel)
;;;330    	{
;;;331    		// level0
;;;332    		case ADC_CHANNEL_LEVEL_IN0:
;;;333    
;;;334    			adcCB.level0.adcBuff[adcCB.level0.index++] = data;
;;;335    			adcCB.level0.index %= ADC_LEVEL_DETECTOR_BUFF_SIZE;
000008  250a              MOVS     r5,#0xa
00000a  4c62              LDR      r4,|L1.404|
00000c  2805              CMP      r0,#5                 ;329
00000e  d224              BCS      |L1.90|
000010  e8dff000          TBB      [pc,r0]               ;329
000014  0324496f          DCB      0x03,0x24,0x49,0x6f
000018  9700              DCB      0x97,0x00
00001a  7e20              LDRB     r0,[r4,#0x18]         ;334  ; adcCB
00001c  1c46              ADDS     r6,r0,#1              ;334
00001e  eb040040          ADD      r0,r4,r0,LSL #1       ;334
000022  7626              STRB     r6,[r4,#0x18]         ;334
000024  8081              STRH     r1,[r0,#4]            ;334
000026  7e20              LDRB     r0,[r4,#0x18]  ; adcCB
000028  fbb0f1f5          UDIV     r1,r0,r5
00002c  fb050011          MLS      r0,r5,r1,r0
000030  7620              STRB     r0,[r4,#0x18]
;;;336    			
;;;337    			// 计算缓冲区的平均值
;;;338    			total = 0;
000032  2500              MOVS     r5,#0
;;;339    			for(i=0; i<ADC_LEVEL_DETECTOR_BUFF_SIZE; i++)
000034  2100              MOVS     r1,#0
                  |L1.54|
;;;340    			{
;;;341    				// 更新最小值
;;;342    				if(adcCB.level0.adcBuff[i] < min)
000036  eb040041          ADD      r0,r4,r1,LSL #1
00003a  8880              LDRH     r0,[r0,#4]
00003c  4290              CMP      r0,r2
00003e  d200              BCS      |L1.66|
;;;343    				{
;;;344    					min = adcCB.level0.adcBuff[i];
000040  4602              MOV      r2,r0
                  |L1.66|
;;;345    				}
;;;346    
;;;347    				// 更新最大值
;;;348    				if(adcCB.level0.adcBuff[i] > max)
000042  4298              CMP      r0,r3
000044  d900              BLS      |L1.72|
;;;349    				{
;;;350    					max = adcCB.level0.adcBuff[i];
000046  4603              MOV      r3,r0
                  |L1.72|
;;;351    				}
;;;352    				
;;;353    				total += adcCB.level0.adcBuff[i];
000048  4405              ADD      r5,r5,r0
00004a  1c49              ADDS     r1,r1,#1              ;339
00004c  b2c9              UXTB     r1,r1                 ;339
00004e  290a              CMP      r1,#0xa               ;339
000050  d3f1              BCC      |L1.54|
;;;354    			}
;;;355    
;;;356    			// 去掉最大最小值
;;;357    			total -= min;
000052  1aa8              SUBS     r0,r5,r2
;;;358    			total -= max;
000054  1ac0              SUBS     r0,r0,r3
;;;359    
;;;360    			// 计算ADC平均值
;;;361    			adcCB.level0.adcAverage = total / (ADC_LEVEL_DETECTOR_BUFF_SIZE - 2);
000056  08c0              LSRS     r0,r0,#3
000058  8360              STRH     r0,[r4,#0x1a]
                  |L1.90|
;;;362    
;;;363    			break;
;;;364    
;;;365    		// level1
;;;366    		case ADC_CHANNEL_LEVEL_IN1:
;;;367    
;;;368    			adcCB.level1.adcBuff[adcCB.level1.index++] = data;
;;;369    			adcCB.level1.index %= ADC_LEVEL_DETECTOR_BUFF_SIZE;
;;;370    
;;;371    			// 计算缓冲区的平均值
;;;372    			total = 0;
;;;373    			for(i=0; i<ADC_LEVEL_DETECTOR_BUFF_SIZE; i++)
;;;374    			{
;;;375    				// 更新最小值
;;;376    				if(adcCB.level1.adcBuff[i] < min)
;;;377    				{
;;;378    					min = adcCB.level1.adcBuff[i];
;;;379    				}
;;;380    
;;;381    				// 更新最大值
;;;382    				if(adcCB.level1.adcBuff[i] > max)
;;;383    				{
;;;384    					max = adcCB.level1.adcBuff[i];
;;;385    				}
;;;386    				
;;;387    				total += adcCB.level1.adcBuff[i];
;;;388    			}
;;;389    
;;;390    			// 去掉最大最小值
;;;391    			total -= min;
;;;392    			total -= max;
;;;393    
;;;394    			// 计算ADC平均值
;;;395    			adcCB.level1.adcAverage = total / (ADC_LEVEL_DETECTOR_BUFF_SIZE - 2);
;;;396    
;;;397    			break;
;;;398    
;;;399    		// LEVEL_IN2
;;;400    	    case ADC_CHANNEL_LEVEL_IN2:
;;;401    			adcCB.level2.adcBuff[adcCB.level2.index++] = data;
;;;402    			adcCB.level2.index %= ADC_LEVEL_DETECTOR_BUFF_SIZE;
;;;403    
;;;404    			// 计算缓冲区的平均值
;;;405    			total = 0;
;;;406    			for(i=0; i<ADC_LEVEL_DETECTOR_BUFF_SIZE; i++)
;;;407    			{
;;;408    				// 更新最小值
;;;409    				if(adcCB.level2.adcBuff[i] < min)
;;;410    				{
;;;411    					min = adcCB.level2.adcBuff[i];
;;;412    				}
;;;413    
;;;414    				// 更新最大值
;;;415    				if(adcCB.level2.adcBuff[i] > max)
;;;416    				{
;;;417    					max = adcCB.level2.adcBuff[i];
;;;418    				}
;;;419    				
;;;420    				total += adcCB.level2.adcBuff[i];
;;;421    			}
;;;422    
;;;423    			// 去掉最大最小值
;;;424    			total -= min;
;;;425    			total -= max;
;;;426    
;;;427    			// 计算ADC平均值
;;;428    			adcCB.level2.adcAverage = total / (ADC_LEVEL_DETECTOR_BUFF_SIZE - 2);
;;;429    
;;;430    	    	break;
;;;431    
;;;432    		// LEVEL_IN3
;;;433    	    case ADC_CHANNEL_LEVEL_IN3:
;;;434    			adcCB.level3.adcBuff[adcCB.level3.index++] = data;
;;;435    			adcCB.level3.index %= ADC_LEVEL_DETECTOR_BUFF_SIZE;
;;;436    
;;;437    			// 计算缓冲区的平均值
;;;438    			total = 0;
;;;439    			for(i=0; i<ADC_LEVEL_DETECTOR_BUFF_SIZE; i++)
;;;440    			{
;;;441    				// 更新最小值
;;;442    				if(adcCB.level3.adcBuff[i] < min)
;;;443    				{
;;;444    					min = adcCB.level3.adcBuff[i];
;;;445    				}
;;;446    
;;;447    				// 更新最大值
;;;448    				if(adcCB.level3.adcBuff[i] > max)
;;;449    				{
;;;450    					max = adcCB.level3.adcBuff[i];
;;;451    				}
;;;452    				
;;;453    				total += adcCB.level3.adcBuff[i];
;;;454    			}
;;;455    
;;;456    			// 去掉最大最小值
;;;457    			total -= min;
;;;458    			total -= max;
;;;459    
;;;460    			// 计算ADC平均值
;;;461    			adcCB.level3.adcAverage = total / (ADC_LEVEL_DETECTOR_BUFF_SIZE - 2);
;;;462    
;;;463    	    	break;
;;;464    
;;;465    		// LEVEL_IN4
;;;466    	    case ADC_CHANNEL_LEVEL_IN4:
;;;467    			adcCB.level4.adcBuff[adcCB.level4.index++] = data;
;;;468    			adcCB.level4.index %= ADC_LEVEL_DETECTOR_BUFF_SIZE;
;;;469    
;;;470    			// 计算缓冲区的平均值
;;;471    			total = 0;
;;;472    			for(i=0; i<ADC_LEVEL_DETECTOR_BUFF_SIZE; i++)
;;;473    			{
;;;474    				// 更新最小值
;;;475    				if(adcCB.level4.adcBuff[i] < min)
;;;476    				{
;;;477    					min = adcCB.level4.adcBuff[i];
;;;478    				}
;;;479    
;;;480    				// 更新最大值
;;;481    				if(adcCB.level4.adcBuff[i] > max)
;;;482    				{
;;;483    					max = adcCB.level4.adcBuff[i];
;;;484    				}
;;;485    				
;;;486    				total += adcCB.level4.adcBuff[i];
;;;487    			}
;;;488    
;;;489    			// 去掉最大最小值
;;;490    			total -= min;
;;;491    			total -= max;
;;;492    
;;;493    			// 计算ADC平均值
;;;494    			adcCB.level4.adcAverage = total / (ADC_LEVEL_DETECTOR_BUFF_SIZE - 2);
;;;495    
;;;496    	    	break;
;;;497    
;;;498    //		// DUT_USB_ADC
;;;499    //	    case ADC_CHANNEL_DUT_USB_ADC:
;;;500    //			adcCB.dutusb.adcBuff[adcCB.dutusb.index++] = data;
;;;501    //			adcCB.dutusb.index %= ADC_LEVEL_DETECTOR_BUFF_SIZE;
;;;502    
;;;503    //			// 计算缓冲区的平均值
;;;504    //			total = 0;
;;;505    //			for(i=0; i<ADC_LEVEL_DETECTOR_BUFF_SIZE; i++)
;;;506    //			{
;;;507    //				// 更新最小值
;;;508    //				if(adcCB.dutusb.adcBuff[i] < min)
;;;509    //				{
;;;510    //					min = adcCB.dutusb.adcBuff[i];
;;;511    //				}
;;;512    
;;;513    //				// 更新最大值
;;;514    //				if(adcCB.dutusb.adcBuff[i] > max)
;;;515    //				{
;;;516    //					max = adcCB.dutusb.adcBuff[i];
;;;517    //				}
;;;518    //				
;;;519    //				total += adcCB.dutusb.adcBuff[i];
;;;520    //			}
;;;521    
;;;522    //			// 去掉最大最小值
;;;523    //			total -= min;
;;;524    //			total -= max;
;;;525    
;;;526    //			// 计算ADC平均值
;;;527    //			adcCB.dutusb.adcAverage = total / (ADC_LEVEL_DETECTOR_BUFF_SIZE - 2);
;;;528    
;;;529    //	    	break;
;;;530    
;;;531    //		// USB_CURRENT
;;;532    //	    case ADC_CHANNEL_USB_CURRENT:
;;;533    //			adcCB.usbcurrent.adcBuff[adcCB.usbcurrent.index++] = data;
;;;534    //			adcCB.usbcurrent.index %= ADC_LEVEL_DETECTOR_BUFF_SIZE;
;;;535    
;;;536    //			// 计算缓冲区的平均值
;;;537    //			total = 0;
;;;538    //			for(i=0; i<ADC_LEVEL_DETECTOR_BUFF_SIZE; i++)
;;;539    //			{
;;;540    //				// 更新最小值
;;;541    //				if(adcCB.usbcurrent.adcBuff[i] < min)
;;;542    //				{
;;;543    //					min = adcCB.usbcurrent.adcBuff[i];
;;;544    //				}
;;;545    
;;;546    //				// 更新最大值
;;;547    //				if(adcCB.usbcurrent.adcBuff[i] > max)
;;;548    //				{
;;;549    //					max = adcCB.usbcurrent.adcBuff[i];
;;;550    //				}
;;;551    //				
;;;552    //				total += adcCB.usbcurrent.adcBuff[i];
;;;553    //			}
;;;554    
;;;555    //			// 去掉最大最小值
;;;556    //			total -= min;
;;;557    //			total -= max;
;;;558    
;;;559    //			// 计算ADC平均值
;;;560    //			adcCB.usbcurrent.adcAverage = total / (ADC_LEVEL_DETECTOR_BUFF_SIZE - 2);
;;;561    
;;;562    //	    	break;
;;;563    
;;;564    //		// KEY_ADC
;;;565    //	    case ADC_CHANNEL_KEY_ADC:
;;;566    //			adcCB.key.adcBuff[adcCB.key.index++] = data;
;;;567    //			adcCB.key.index %= ADC_LEVEL_DETECTOR_BUFF_SIZE;
;;;568    
;;;569    //			// 计算缓冲区的平均值
;;;570    //			total = 0;
;;;571    //			for(i=0; i<ADC_LEVEL_DETECTOR_BUFF_SIZE; i++)
;;;572    //			{
;;;573    //				// 更新最小值
;;;574    //				if(adcCB.key.adcBuff[i] < min)
;;;575    //				{
;;;576    //					min = adcCB.key.adcBuff[i];
;;;577    //				}
;;;578    
;;;579    //				// 更新最大值
;;;580    //				if(adcCB.key.adcBuff[i] > max)
;;;581    //				{
;;;582    //					max = adcCB.key.adcBuff[i];
;;;583    //				}
;;;584    //				
;;;585    //				total += adcCB.key.adcBuff[i];
;;;586    //			}
;;;587    
;;;588    //			// 去掉最大最小值
;;;589    //			total -= min;
;;;590    //			total -= max;
;;;591    
;;;592    //			// 计算ADC平均值
;;;593    //			adcCB.key.adcAverage = total / (ADC_LEVEL_DETECTOR_BUFF_SIZE - 2);
;;;594    
;;;595    //	    	break;
;;;596                
;;;597    		// 非法通道
;;;598    		default:
;;;599    			break;
;;;600    	}
;;;601    }
00005a  bd70              POP      {r4-r6,pc}
00005c  f8940034          LDRB     r0,[r4,#0x34]         ;368  ; adcCB
000060  1c46              ADDS     r6,r0,#1              ;368
000062  eb040040          ADD      r0,r4,r0,LSL #1       ;368
000066  f8846034          STRB     r6,[r4,#0x34]         ;368
00006a  8401              STRH     r1,[r0,#0x20]         ;368
00006c  f8940034          LDRB     r0,[r4,#0x34]         ;369  ; adcCB
000070  fbb0f1f5          UDIV     r1,r0,r5              ;369
000074  fb050011          MLS      r0,r5,r1,r0           ;369
000078  f8840034          STRB     r0,[r4,#0x34]         ;369
00007c  2500              MOVS     r5,#0                 ;372
00007e  2100              MOVS     r1,#0                 ;373
                  |L1.128|
000080  eb040041          ADD      r0,r4,r1,LSL #1       ;376
000084  8c00              LDRH     r0,[r0,#0x20]         ;376
000086  4290              CMP      r0,r2                 ;376
000088  d200              BCS      |L1.140|
00008a  4602              MOV      r2,r0                 ;378
                  |L1.140|
00008c  4298              CMP      r0,r3                 ;382
00008e  d900              BLS      |L1.146|
000090  4603              MOV      r3,r0                 ;384
                  |L1.146|
000092  4405              ADD      r5,r5,r0              ;387
000094  1c49              ADDS     r1,r1,#1              ;373
000096  b2c9              UXTB     r1,r1                 ;373
000098  290a              CMP      r1,#0xa               ;373
00009a  d3f1              BCC      |L1.128|
00009c  1aa8              SUBS     r0,r5,r2              ;391
00009e  1ac0              SUBS     r0,r0,r3              ;392
0000a0  08c0              LSRS     r0,r0,#3              ;395
0000a2  86e0              STRH     r0,[r4,#0x36]         ;395
0000a4  bd70              POP      {r4-r6,pc}
0000a6  f8940050          LDRB     r0,[r4,#0x50]         ;401  ; adcCB
0000aa  1c46              ADDS     r6,r0,#1              ;401
0000ac  eb040040          ADD      r0,r4,r0,LSL #1       ;401
0000b0  f8846050          STRB     r6,[r4,#0x50]         ;401
0000b4  8781              STRH     r1,[r0,#0x3c]         ;401
0000b6  f8940050          LDRB     r0,[r4,#0x50]         ;402  ; adcCB
0000ba  fbb0f1f5          UDIV     r1,r0,r5              ;402
0000be  fb050011          MLS      r0,r5,r1,r0           ;402
0000c2  f8840050          STRB     r0,[r4,#0x50]         ;402
0000c6  2500              MOVS     r5,#0                 ;405
0000c8  2100              MOVS     r1,#0                 ;406
                  |L1.202|
0000ca  eb040041          ADD      r0,r4,r1,LSL #1       ;409
0000ce  8f80              LDRH     r0,[r0,#0x3c]         ;409
0000d0  4290              CMP      r0,r2                 ;409
0000d2  d200              BCS      |L1.214|
0000d4  4602              MOV      r2,r0                 ;411
                  |L1.214|
0000d6  4298              CMP      r0,r3                 ;415
0000d8  d900              BLS      |L1.220|
0000da  4603              MOV      r3,r0                 ;417
                  |L1.220|
0000dc  4405              ADD      r5,r5,r0              ;420
0000de  1c49              ADDS     r1,r1,#1              ;406
0000e0  b2c9              UXTB     r1,r1                 ;406
0000e2  290a              CMP      r1,#0xa               ;406
0000e4  d3f1              BCC      |L1.202|
0000e6  1aa8              SUBS     r0,r5,r2              ;424
0000e8  1ac0              SUBS     r0,r0,r3              ;425
0000ea  08c0              LSRS     r0,r0,#3              ;428
0000ec  f8a40052          STRH     r0,[r4,#0x52]         ;428
0000f0  bd70              POP      {r4-r6,pc}
0000f2  f894006c          LDRB     r0,[r4,#0x6c]         ;434  ; adcCB
0000f6  1c46              ADDS     r6,r0,#1              ;434
0000f8  eb040040          ADD      r0,r4,r0,LSL #1       ;434
0000fc  f884606c          STRB     r6,[r4,#0x6c]         ;434
000100  f8a01058          STRH     r1,[r0,#0x58]         ;434
000104  f894006c          LDRB     r0,[r4,#0x6c]         ;435  ; adcCB
000108  fbb0f1f5          UDIV     r1,r0,r5              ;435
00010c  fb050011          MLS      r0,r5,r1,r0           ;435
000110  f884006c          STRB     r0,[r4,#0x6c]         ;435
000114  2500              MOVS     r5,#0                 ;438
000116  2100              MOVS     r1,#0                 ;439
                  |L1.280|
000118  eb040041          ADD      r0,r4,r1,LSL #1       ;442
00011c  f8b00058          LDRH     r0,[r0,#0x58]         ;442
000120  4290              CMP      r0,r2                 ;442
000122  d200              BCS      |L1.294|
000124  4602              MOV      r2,r0                 ;444
                  |L1.294|
000126  4298              CMP      r0,r3                 ;448
000128  d900              BLS      |L1.300|
00012a  4603              MOV      r3,r0                 ;450
                  |L1.300|
00012c  4405              ADD      r5,r5,r0              ;453
00012e  1c49              ADDS     r1,r1,#1              ;439
000130  b2c9              UXTB     r1,r1                 ;439
000132  290a              CMP      r1,#0xa               ;439
000134  d3f0              BCC      |L1.280|
000136  1aa8              SUBS     r0,r5,r2              ;457
000138  1ac0              SUBS     r0,r0,r3              ;458
00013a  08c0              LSRS     r0,r0,#3              ;461
00013c  f8a4006e          STRH     r0,[r4,#0x6e]         ;461
000140  bd70              POP      {r4-r6,pc}
000142  f8940088          LDRB     r0,[r4,#0x88]         ;467  ; adcCB
000146  1c46              ADDS     r6,r0,#1              ;467
000148  eb040040          ADD      r0,r4,r0,LSL #1       ;467
00014c  f8846088          STRB     r6,[r4,#0x88]         ;467
000150  f8a01074          STRH     r1,[r0,#0x74]         ;467
000154  f8940088          LDRB     r0,[r4,#0x88]         ;468  ; adcCB
000158  fbb0f1f5          UDIV     r1,r0,r5              ;468
00015c  fb050011          MLS      r0,r5,r1,r0           ;468
000160  f8840088          STRB     r0,[r4,#0x88]         ;468
000164  2500              MOVS     r5,#0                 ;471
000166  2100              MOVS     r1,#0                 ;472
                  |L1.360|
000168  eb040041          ADD      r0,r4,r1,LSL #1       ;475
00016c  f8b00074          LDRH     r0,[r0,#0x74]         ;475
000170  4290              CMP      r0,r2                 ;475
000172  d200              BCS      |L1.374|
000174  4602              MOV      r2,r0                 ;477
                  |L1.374|
000176  4298              CMP      r0,r3                 ;481
000178  d900              BLS      |L1.380|
00017a  4603              MOV      r3,r0                 ;483
                  |L1.380|
00017c  4405              ADD      r5,r5,r0              ;486
00017e  1c49              ADDS     r1,r1,#1              ;472
000180  b2c9              UXTB     r1,r1                 ;472
000182  290a              CMP      r1,#0xa               ;472
000184  d3f0              BCC      |L1.360|
000186  1aa8              SUBS     r0,r5,r2              ;490
000188  1ac0              SUBS     r0,r0,r3              ;491
00018a  08c0              LSRS     r0,r0,#3              ;494
00018c  f8a4008a          STRH     r0,[r4,#0x8a]         ;494
000190  bd70              POP      {r4-r6,pc}
                          ENDP

000192  0000              DCW      0x0000
                  |L1.404|
                          DCD      ||.bss||

                          AREA ||i.ADC_BaseInit||, CODE, READONLY, ALIGN=1

                  ADC_BaseInit PROC
;;;45     // 初始化
;;;46     void ADC_BaseInit(void)
000000  b510              PUSH     {r4,lr}
;;;47     {
;;;48     	// ADC硬件初始化
;;;49     	ADC_LevelHwInit();
000002  f7fffffe          BL       ADC_LevelHwInit
;;;50     
;;;51     	// 初始化结构体
;;;52     	ADC_InitStruct();
000006  f7fffffe          BL       ADC_InitStruct
;;;53     
;;;54     	// 开始扫描
;;;55     	ADC_Start();
00000a  e8bd4010          POP      {r4,lr}
00000e  f7ffbffe          B.W      ADC_Start
;;;56     }
;;;57     
                          ENDP


                          AREA ||i.ADC_CALLBACK_SetScanRequest||, CODE, READONLY, ALIGN=2

                  ADC_CALLBACK_SetScanRequest PROC
;;;312    // 设置读取请求回调函数，由定时器调用
;;;313    void ADC_CALLBACK_SetScanRequest(uint32 param)
000000  4901              LDR      r1,|L3.8|
;;;314    {
;;;315    	adcCB.scanRequest = TRUE;
000002  2001              MOVS     r0,#1
000004  7008              STRB     r0,[r1,#0]
;;;316    }
000006  4770              BX       lr
;;;317    
                          ENDP

                  |L3.8|
                          DCD      ||.bss||

                          AREA ||i.ADC_InitStruct||, CODE, READONLY, ALIGN=2

                  ADC_InitStruct PROC
;;;253    // 初始化结构体
;;;254    void ADC_InitStruct(void)
000000  4a21              LDR      r2,|L4.136|
;;;255    {
;;;256    	uint8 i;
;;;257    	
;;;258    	adcCB.scanRequest = FALSE;
000002  2100              MOVS     r1,#0
000004  7011              STRB     r1,[r2,#0]
;;;259    	adcCB.currentChannel = (ADC_CHANNEL_E)0;
000006  7051              STRB     r1,[r2,#1]
;;;260    
;;;261    	// level0相关数据结构初始化
;;;262    	for(i=0; i< ADC_LEVEL_DETECTOR_BUFF_SIZE ; i++)
000008  2000              MOVS     r0,#0
                  |L4.10|
;;;263    	{
;;;264    		adcCB.level0.adcBuff[i] = 0;
00000a  eb020340          ADD      r3,r2,r0,LSL #1
00000e  8099              STRH     r1,[r3,#4]
000010  1c40              ADDS     r0,r0,#1              ;262
000012  b2c0              UXTB     r0,r0                 ;262
000014  280a              CMP      r0,#0xa               ;262
000016  d3f8              BCC      |L4.10|
;;;265    	}
;;;266    	
;;;267    	adcCB.level0.index = 0;
000018  7611              STRB     r1,[r2,#0x18]
;;;268    	adcCB.level0.adcAverage = 0;
00001a  8351              STRH     r1,[r2,#0x1a]
;;;269    	adcCB.level0.voltage = 0;
00001c  61d1              STR      r1,[r2,#0x1c]  ; adcCB
;;;270    
;;;271    	// level1相关数据清零
;;;272    	for(i=0; i<ADC_LEVEL_DETECTOR_BUFF_SIZE; i++)
00001e  2000              MOVS     r0,#0
                  |L4.32|
;;;273    	{
;;;274    		adcCB.level1.adcBuff[i] = 0;
000020  eb020340          ADD      r3,r2,r0,LSL #1
000024  8419              STRH     r1,[r3,#0x20]
000026  1c40              ADDS     r0,r0,#1              ;272
000028  b2c0              UXTB     r0,r0                 ;272
00002a  280a              CMP      r0,#0xa               ;272
00002c  d3f8              BCC      |L4.32|
;;;275    	}
;;;276    	
;;;277    	adcCB.level1.index = 0;
00002e  f8821034          STRB     r1,[r2,#0x34]
;;;278    	adcCB.level1.adcAverage = 0;
000032  86d1              STRH     r1,[r2,#0x36]
;;;279    	adcCB.level1.voltage = 0;
000034  6391              STR      r1,[r2,#0x38]  ; adcCB
;;;280        
;;;281        // level2相关数据清零
;;;282    	for(i=0; i<ADC_LEVEL_DETECTOR_BUFF_SIZE; i++)
000036  2000              MOVS     r0,#0
                  |L4.56|
;;;283    	{
;;;284    		adcCB.level2.adcBuff[i] = 0;
000038  eb020340          ADD      r3,r2,r0,LSL #1
00003c  8799              STRH     r1,[r3,#0x3c]
00003e  1c40              ADDS     r0,r0,#1              ;282
000040  b2c0              UXTB     r0,r0                 ;282
000042  280a              CMP      r0,#0xa               ;282
000044  d3f8              BCC      |L4.56|
;;;285    	}
;;;286    	
;;;287    	adcCB.level2.index = 0;
000046  f8821050          STRB     r1,[r2,#0x50]
;;;288    	adcCB.level2.adcAverage = 0;
00004a  f8a21052          STRH     r1,[r2,#0x52]
;;;289    	adcCB.level2.voltage = 0;
00004e  6551              STR      r1,[r2,#0x54]  ; adcCB
;;;290        
;;;291        // level3相关数据清零
;;;292    	for(i=0; i<ADC_LEVEL_DETECTOR_BUFF_SIZE; i++)
000050  2000              MOVS     r0,#0
                  |L4.82|
;;;293    	{
;;;294    		adcCB.level3.adcBuff[i] = 0;
000052  eb020340          ADD      r3,r2,r0,LSL #1
000056  f8a31058          STRH     r1,[r3,#0x58]
00005a  1c40              ADDS     r0,r0,#1              ;292
00005c  b2c0              UXTB     r0,r0                 ;292
00005e  280a              CMP      r0,#0xa               ;292
000060  d3f7              BCC      |L4.82|
;;;295    	}
;;;296    	
;;;297    	adcCB.level3.index = 0;
000062  f882106c          STRB     r1,[r2,#0x6c]
;;;298    	adcCB.level3.adcAverage = 0;
000066  f8a2106e          STRH     r1,[r2,#0x6e]
;;;299    	adcCB.level3.voltage = 0;
00006a  6711              STR      r1,[r2,#0x70]  ; adcCB
;;;300        
;;;301        // level4相关数据清零
;;;302    	for(i=0; i<ADC_LEVEL_DETECTOR_BUFF_SIZE; i++)
00006c  2000              MOVS     r0,#0
                  |L4.110|
;;;303    	{
;;;304    		adcCB.level4.adcBuff[i] = 0;
00006e  eb020340          ADD      r3,r2,r0,LSL #1
000072  f8a31074          STRH     r1,[r3,#0x74]
000076  1c40              ADDS     r0,r0,#1              ;302
000078  b2c0              UXTB     r0,r0                 ;302
00007a  280a              CMP      r0,#0xa               ;302
00007c  d3f7              BCC      |L4.110|
;;;305    	}
;;;306    	
;;;307    	adcCB.level4.index = 0;
00007e  f8021f88          STRB     r1,[r2,#0x88]!
;;;308    	adcCB.level4.adcAverage = 0;
000082  8051              STRH     r1,[r2,#2]
;;;309    	adcCB.level4.voltage = 0;
000084  6051              STR      r1,[r2,#4]  ; adcCB
;;;310    }
000086  4770              BX       lr
;;;311    
                          ENDP

                  |L4.136|
                          DCD      ||.bss||

                          AREA ||i.ADC_LevelHwInit||, CODE, READONLY, ALIGN=2

                  ADC_LevelHwInit PROC
;;;219    // 硬件ADC0初始化
;;;220    void ADC_LevelHwInit(void)
000000  b570              PUSH     {r4-r6,lr}
;;;221    {
;;;222     	rcu_periph_clock_enable(RCU_GPIOA);									// 时能GPIOC时钟
000002  f2406002          MOV      r0,#0x602
000006  f7fffffe          BL       rcu_periph_clock_enable
;;;223        rcu_periph_clock_enable(RCU_GPIOB);									// 时能GPIOC时钟
00000a  f2406003          MOV      r0,#0x603
00000e  f7fffffe          BL       rcu_periph_clock_enable
;;;224     	rcu_periph_clock_enable(RCU_GPIOC);									// 时能GPIOC时钟
000012  f2406004          MOV      r0,#0x604
000016  f7fffffe          BL       rcu_periph_clock_enable
;;;225    	rcu_periph_clock_enable(RCU_ADC0);									// 时能ADC0时钟
00001a  f2406009          MOV      r0,#0x609
00001e  f7fffffe          BL       rcu_periph_clock_enable
;;;226    
;;;227    	adc_deinit(ADC0);													// 复位ADC
000022  4c2b              LDR      r4,|L5.208|
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       adc_deinit
;;;228    	rcu_adc_clock_config(RCU_CKADC_CKAPB2_DIV6);						// 72/6 = 12 Mhz(最大频率不能超过40M) 
00002a  2002              MOVS     r0,#2
00002c  f7fffffe          BL       rcu_adc_clock_config
;;;229    		
;;;230    	gpio_init(GPIOA, GPIO_MODE_AIN, GPIO_OSPEED_50MHZ, GPIO_PIN_6 | GPIO_PIN_7);		// PA0 - 模拟输入
000030  23c0              MOVS     r3,#0xc0
000032  2203              MOVS     r2,#3
000034  2100              MOVS     r1,#0
000036  4827              LDR      r0,|L5.212|
000038  f7fffffe          BL       gpio_init
;;;231    	gpio_init(GPIOB, GPIO_MODE_AIN, GPIO_OSPEED_50MHZ, GPIO_PIN_0);		                // PA0 - 模拟输入    
00003c  2301              MOVS     r3,#1
00003e  2203              MOVS     r2,#3
000040  2100              MOVS     r1,#0
000042  4825              LDR      r0,|L5.216|
000044  f7fffffe          BL       gpio_init
;;;232    	gpio_init(GPIOC, GPIO_MODE_AIN, GPIO_OSPEED_50MHZ, GPIO_PIN_4 | GPIO_PIN_5);		// PC3 -PC4 - 模拟输入
000048  4d24              LDR      r5,|L5.220|
00004a  2330              MOVS     r3,#0x30
00004c  2203              MOVS     r2,#3
00004e  2100              MOVS     r1,#0
000050  4628              MOV      r0,r5
000052  f7fffffe          BL       gpio_init
;;;233    	gpio_init(GPIOC, GPIO_MODE_AIN, GPIO_OSPEED_50MHZ, GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2);		
000056  2307              MOVS     r3,#7
000058  2203              MOVS     r2,#3
00005a  2100              MOVS     r1,#0
00005c  4628              MOV      r0,r5
00005e  f7fffffe          BL       gpio_init
;;;234        
;;;235    	// ADC0 配置
;;;236    	adc_mode_config(ADC_MODE_FREE); 									// 独立模式
000062  2000              MOVS     r0,#0
000064  f7fffffe          BL       adc_mode_config
;;;237    	adc_special_function_config(ADC0, ADC_SCAN_MODE, DISABLE);			// 扫描模式关闭
000068  2200              MOVS     r2,#0
00006a  15a1              ASRS     r1,r4,#22
00006c  4620              MOV      r0,r4
00006e  f7fffffe          BL       adc_special_function_config
;;;238    	adc_special_function_config(ADC0, ADC_CONTINUOUS_MODE, DISABLE);	// 连续转换模式关闭
000072  2200              MOVS     r2,#0
000074  2102              MOVS     r1,#2
000076  4620              MOV      r0,r4
000078  f7fffffe          BL       adc_special_function_config
;;;239    	adc_external_trigger_source_config(ADC0, ADC_REGULAR_CHANNEL, ADC0_1_2_EXTTRIG_REGULAR_NONE);  // 常规通道，软件触发
00007c  f44f2260          MOV      r2,#0xe0000
000080  2101              MOVS     r1,#1
000082  4620              MOV      r0,r4
000084  f7fffffe          BL       adc_external_trigger_source_config
;;;240    	adc_data_alignment_config(ADC0, ADC_DATAALIGN_RIGHT);				// 数据右对齐
000088  2100              MOVS     r1,#0
00008a  4620              MOV      r0,r4
00008c  f7fffffe          BL       adc_data_alignment_config
;;;241    	adc_channel_length_config(ADC0, ADC_REGULAR_CHANNEL, 1);			// 常规通道数量1
000090  2201              MOVS     r2,#1
000092  4611              MOV      r1,r2
000094  4620              MOV      r0,r4
000096  f7fffffe          BL       adc_channel_length_config
;;;242    
;;;243    	// 设置ADC
;;;244        adc_regular_channel_config(ADC0, 0, ADC_CHANNEL_6, ADC_SAMPLETIME_55POINT5);	
00009a  2305              MOVS     r3,#5
00009c  2206              MOVS     r2,#6
00009e  2100              MOVS     r1,#0
0000a0  4620              MOV      r0,r4
0000a2  f7fffffe          BL       adc_regular_channel_config
;;;245    	adc_enable(ADC0);													// 时能ADC0
0000a6  4620              MOV      r0,r4
0000a8  f7fffffe          BL       adc_enable
;;;246    	Delayms(10);
0000ac  200a              MOVS     r0,#0xa
0000ae  f7fffffe          BL       Delayms
;;;247    	adc_calibration_enable(ADC0);										// ADC校准和复位校准
0000b2  4620              MOV      r0,r4
0000b4  f7fffffe          BL       adc_calibration_enable
;;;248    	
;;;249    	adc_external_trigger_config(ADC0, ADC_REGULAR_CHANNEL, ENABLE);		// 启动ADC0转换
0000b8  2201              MOVS     r2,#1
0000ba  4611              MOV      r1,r2
0000bc  4620              MOV      r0,r4
0000be  f7fffffe          BL       adc_external_trigger_config
;;;250    	adc_software_trigger_enable(ADC0, ADC_REGULAR_CHANNEL);
0000c2  4620              MOV      r0,r4
0000c4  e8bd4070          POP      {r4-r6,lr}
0000c8  2101              MOVS     r1,#1
0000ca  f7ffbffe          B.W      adc_software_trigger_enable
;;;251    }
;;;252    
                          ENDP

0000ce  0000              DCW      0x0000
                  |L5.208|
                          DCD      0x40012400
                  |L5.212|
                          DCD      0x40010800
                  |L5.216|
                          DCD      0x40010c00
                  |L5.220|
                          DCD      0x40011000

                          AREA ||i.ADC_Process||, CODE, READONLY, ALIGN=2

                  ADC_Process PROC
;;;58     // 传感器处理，在main中调用
;;;59     void ADC_Process(void)
000000  b570              PUSH     {r4-r6,lr}
;;;60     {
;;;61     	uint16 adcData;
;;;62     	uint8 i;
;;;63     	uint8 vLevel = 1;
;;;64     	
;;;65     	// 有检测请求时，执行一次转换
;;;66     	if(adcCB.scanRequest)
000002  4c47              LDR      r4,|L6.288|
000004  7820              LDRB     r0,[r4,#0]  ; adcCB
000006  2800              CMP      r0,#0
000008  d07e              BEQ      |L6.264|
;;;67     	{
;;;68     		// 上次转换未完成，退出，等待转换完成
;;;69     		if(!ADC_CONVERT_IS_BUSY())
00000a  4e46              LDR      r6,|L6.292|
00000c  2102              MOVS     r1,#2
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       adc_flag_get
000014  2800              CMP      r0,#0
000016  d077              BEQ      |L6.264|
;;;70     		{
;;;71     			return;
;;;72     		}
;;;73     		
;;;74     		// 上次转换结束，清除转换请求
;;;75     		adcCB.scanRequest = FALSE;
000018  2000              MOVS     r0,#0
00001a  7020              STRB     r0,[r4,#0]
;;;76     
;;;77     		// 将数据添加到对应的缓冲区中
;;;78     		switch(adcCB.currentChannel)
00001c  7860              LDRB     r0,[r4,#1]  ; adcCB
;;;79     		{
;;;80     			// LEVEL_IN0
;;;81     			case ADC_CHANNEL_LEVEL_IN0:		
;;;82     
;;;83     				adcData = ADC_CONVERT_RESULT();
;;;84     				ADC_AddDataToBuff(ADC_CHANNEL_LEVEL_IN0, adcData);	
;;;85     				
;;;86                     // 计算电压
;;;87                     adcCB.level0.voltage = adcCB.level0.adcAverage * 3300 / 4095;
00001e  f64075ff          MOV      r5,#0xfff
000022  2805              CMP      r0,#5                 ;78
000024  d266              BCS      |L6.244|
000026  e8dff000          TBB      [pc,r0]               ;78
00002a  0316              DCB      0x03,0x16
00002c  293d5100          DCB      0x29,0x3d,0x51,0x00
000030  4630              MOV      r0,r6                 ;83
000032  f7fffffe          BL       adc_regular_data_read
000036  4601              MOV      r1,r0                 ;83
000038  2000              MOVS     r0,#0                 ;84
00003a  f7fffffe          BL       ADC_AddDataToBuff
00003e  8b60              LDRH     r0,[r4,#0x1a]  ; adcCB
000040  f64041e4          MOV      r1,#0xce4
000044  4348              MULS     r0,r1,r0
000046  fbb0f0f5          UDIV     r0,r0,r5
;;;88                     
;;;89                     adcCB.level0.voltage = adcCB.level0.voltage  * 11;             
00004a  eb000140          ADD      r1,r0,r0,LSL #1
00004e  eb0100c0          ADD      r0,r1,r0,LSL #3
000052  61e0              STR      r0,[r4,#0x1c]  ; adcCB
;;;90     				break;
000054  e04e              B        |L6.244|
;;;91     
;;;92                 // LEVEL_IN2
;;;93                 case ADC_CHANNEL_LEVEL_IN1:
;;;94                     adcData = ADC_CONVERT_RESULT();
000056  4630              MOV      r0,r6
000058  f7fffffe          BL       adc_regular_data_read
00005c  4601              MOV      r1,r0
;;;95     				ADC_AddDataToBuff(ADC_CHANNEL_LEVEL_IN1, adcData);	
00005e  2001              MOVS     r0,#1
000060  f7fffffe          BL       ADC_AddDataToBuff
;;;96                     
;;;97                     // 计算电压
;;;98                     adcCB.level1.voltage = adcCB.level1.adcAverage * 3300 / 4095;
000064  8ee0              LDRH     r0,[r4,#0x36]  ; adcCB
000066  f64041e4          MOV      r1,#0xce4
00006a  4348              MULS     r0,r1,r0
00006c  fbb0f0f5          UDIV     r0,r0,r5
;;;99                     
;;;100                    adcCB.level1.voltage = adcCB.level1.voltage * 11;               
000070  eb000140          ADD      r1,r0,r0,LSL #1
000074  eb0100c0          ADD      r0,r1,r0,LSL #3
000078  63a0              STR      r0,[r4,#0x38]  ; adcCB
;;;101                    break;
00007a  e03b              B        |L6.244|
;;;102                    
;;;103                // LEVEL_IN2
;;;104                case ADC_CHANNEL_LEVEL_IN2:
;;;105                    adcData = ADC_CONVERT_RESULT();
00007c  4630              MOV      r0,r6
00007e  f7fffffe          BL       adc_regular_data_read
000082  4601              MOV      r1,r0
;;;106                    
;;;107    				ADC_AddDataToBuff(ADC_CHANNEL_LEVEL_IN2, adcData);	
000084  2002              MOVS     r0,#2
000086  f7fffffe          BL       ADC_AddDataToBuff
;;;108                    
;;;109                    // 计算电压
;;;110                    adcCB.level2.voltage = adcCB.level2.adcAverage * 3300 / 4095;
00008a  f8b40052          LDRH     r0,[r4,#0x52]  ; adcCB
00008e  f64041e4          MOV      r1,#0xce4
000092  4348              MULS     r0,r1,r0
000094  fbb0f0f5          UDIV     r0,r0,r5
;;;111                    
;;;112                    adcCB.level2.voltage = adcCB.level2.voltage * 11;  
000098  eb000140          ADD      r1,r0,r0,LSL #1
00009c  eb0100c0          ADD      r0,r1,r0,LSL #3
0000a0  6560              STR      r0,[r4,#0x54]  ; adcCB
;;;113                    break;
0000a2  e027              B        |L6.244|
;;;114    
;;;115                // LEVEL_IN3
;;;116                case ADC_CHANNEL_LEVEL_IN3:
;;;117                    adcData = ADC_CONVERT_RESULT();
0000a4  4630              MOV      r0,r6
0000a6  f7fffffe          BL       adc_regular_data_read
0000aa  4601              MOV      r1,r0
;;;118                    
;;;119    				ADC_AddDataToBuff(ADC_CHANNEL_LEVEL_IN3, adcData);	
0000ac  2003              MOVS     r0,#3
0000ae  f7fffffe          BL       ADC_AddDataToBuff
;;;120                    
;;;121                    // 计算电压
;;;122                    adcCB.level3.voltage = adcCB.level3.adcAverage * 3300 / 4095;
0000b2  f8b4006e          LDRH     r0,[r4,#0x6e]  ; adcCB
0000b6  f64041e4          MOV      r1,#0xce4
0000ba  4348              MULS     r0,r1,r0
0000bc  fbb0f0f5          UDIV     r0,r0,r5
;;;123                    
;;;124                    adcCB.level3.voltage = adcCB.level3.voltage * 11;                  
0000c0  eb000140          ADD      r1,r0,r0,LSL #1
0000c4  eb0100c0          ADD      r0,r1,r0,LSL #3
0000c8  6720              STR      r0,[r4,#0x70]  ; adcCB
;;;125                    break;
0000ca  e013              B        |L6.244|
;;;126                    
;;;127                // LEVEL_IN4
;;;128                case ADC_CHANNEL_LEVEL_IN4:
;;;129                    adcData = ADC_CONVERT_RESULT();
0000cc  4630              MOV      r0,r6
0000ce  f7fffffe          BL       adc_regular_data_read
0000d2  4601              MOV      r1,r0
;;;130                    
;;;131    				ADC_AddDataToBuff(ADC_CHANNEL_LEVEL_IN4, adcData);	
0000d4  2004              MOVS     r0,#4
0000d6  f7fffffe          BL       ADC_AddDataToBuff
;;;132                    
;;;133                    // 计算电压
;;;134                    adcCB.level4.voltage = adcCB.level4.adcAverage * 3300 / 4095;
0000da  f8b4008a          LDRH     r0,[r4,#0x8a]  ; adcCB
0000de  f64041e4          MOV      r1,#0xce4
0000e2  4348              MULS     r0,r1,r0
0000e4  fbb0f0f5          UDIV     r0,r0,r5
;;;135                    
;;;136                    adcCB.level4.voltage = adcCB.level4.voltage * 11;                  
0000e8  eb000140          ADD      r1,r0,r0,LSL #1
0000ec  eb0100c0          ADD      r0,r1,r0,LSL #3
0000f0  f8c4008c          STR      r0,[r4,#0x8c]  ; adcCB
                  |L6.244|
;;;137                    break;
;;;138    
;;;139    //            // ADC_CHANNEL_DUT_USB_ADC
;;;140    //            case ADC_CHANNEL_DUT_USB_ADC:
;;;141    //                adcData = ADC_CONVERT_RESULT();
;;;142    //                
;;;143    //				ADC_AddDataToBuff(ADC_CHANNEL_DUT_USB_ADC, adcData);	
;;;144    //                
;;;145    //                // 计算电压
;;;146    //                adcCB.dutusb.voltage = adcCB.dutusb.adcAverage * 3300 / 4095;
;;;147    //                
;;;148    //                adcCB.dutusb.voltage = adcCB.dutusb.voltage * 2;                  
;;;149    //                break;
;;;150    
;;;151    //            // ADC_CHANNEL_USB_CURRENT
;;;152    //            case ADC_CHANNEL_USB_CURRENT:
;;;153    //                adcData = ADC_CONVERT_RESULT();
;;;154    //                
;;;155    //				ADC_AddDataToBuff(ADC_CHANNEL_USB_CURRENT, adcData);	
;;;156    //                
;;;157    //                // 计算电压
;;;158    //                adcCB.usbcurrent.voltage = adcCB.usbcurrent.adcAverage * 3300 / 4095;  // 单位毫伏，是经过放大100倍的
;;;159    //                
;;;160    ////                adcCB.usbcurrent.voltage = adcCB.usbcurrent.voltage / 50 / 20 ;                  
;;;161    //                break;
;;;162    
;;;163    //            // ADC_CHANNEL_KEY_ADC
;;;164    //            case ADC_CHANNEL_KEY_ADC:
;;;165    //                adcData = ADC_CONVERT_RESULT();
;;;166    //                
;;;167    //				ADC_AddDataToBuff(ADC_CHANNEL_KEY_ADC, adcData);	
;;;168    //                
;;;169    //                // 计算电压
;;;170    //                adcCB.key.voltage = adcCB.key.adcAverage * 3300 / 4095;
;;;171    //                
;;;172    //                adcCB.key.voltage = adcCB.key.voltage;                  
;;;173    //                break;
;;;174                    
;;;175                // 非法通道
;;;176                default:
;;;177                
;;;178                    break;
;;;179    				
;;;180    		}
;;;181    
;;;182    		// 切换至下一个通道
;;;183    		adcCB.currentChannel ++;
0000f4  7860              LDRB     r0,[r4,#1]  ; adcCB
0000f6  1c40              ADDS     r0,r0,#1
;;;184    		adcCB.currentChannel %= ADC_CHANNEL_MAX;
0000f8  f0000007          AND      r0,r0,#7
0000fc  7060              STRB     r0,[r4,#1]
;;;185    
;;;186    		// 选定下一个通道
;;;187    		ADC_CONVERT_CHANNEL(adc_channel[adcCB.currentChannel]);
0000fe  490a              LDR      r1,|L6.296|
000100  2305              MOVS     r3,#5
000102  5c0a              LDRB     r2,[r1,r0]
000104  2100              MOVS     r1,#0
000106  e000              B        |L6.266|
                  |L6.264|
000108  e008              B        |L6.284|
                  |L6.266|
00010a  4630              MOV      r0,r6
00010c  f7fffffe          BL       adc_regular_channel_config
;;;188    		
;;;189    		// 启动下一次转换
;;;190    		ADC_CONVERT_START();
000110  4630              MOV      r0,r6
000112  e8bd4070          POP      {r4-r6,lr}
000116  2101              MOVS     r1,#1
000118  f7ffbffe          B.W      adc_software_trigger_enable
                  |L6.284|
;;;191    	}
;;;192    }
00011c  bd70              POP      {r4-r6,pc}
;;;193    
                          ENDP

00011e  0000              DCW      0x0000
                  |L6.288|
                          DCD      ||.bss||
                  |L6.292|
                          DCD      0x40012400
                  |L6.296|
                          DCD      ||.data||

                          AREA ||i.ADC_Start||, CODE, READONLY, ALIGN=2

                  ADC_Start PROC
;;;194    // 启动NTC，即启动定时器任务，周期性地读取温度
;;;195    void ADC_Start(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;196    {
;;;197    	TIMER_KillTask(TIMER_ID_ADC_SCAN);
000002  2019              MOVS     r0,#0x19
000004  f7fffffe          BL       TIMER_KillTask
;;;198    
;;;199    	adcCB.currentChannel = ADC_CHANNEL_LEVEL_IN0;
000008  4908              LDR      r1,|L7.44|
00000a  2000              MOVS     r0,#0
00000c  7048              STRB     r0,[r1,#1]
;;;200    
;;;201    	// 注册定时器任务，周期性采样
;;;202    	TIMER_AddTask(TIMER_ID_ADC_SCAN,
00000e  1e41              SUBS     r1,r0,#1
000010  e9cd1000          STRD     r1,r0,[sp,#0]
000014  2301              MOVS     r3,#1
000016  4a06              LDR      r2,|L7.48|
000018  2105              MOVS     r1,#5
00001a  2019              MOVS     r0,#0x19
00001c  f7fffffe          BL       TIMER_AddTask
;;;203    				ADC_SCAN_TIME,
;;;204    				ADC_CALLBACK_SetScanRequest,
;;;205    				1,
;;;206    				TIMER_LOOP_FOREVER,
;;;207    				ACTION_MODE_DO_AT_ONCE);
;;;208    					
;;;209    	// 启动下一次转换
;;;210    	ADC_CONVERT_START();
000020  e8bd401c          POP      {r2-r4,lr}
000024  2101              MOVS     r1,#1
000026  4803              LDR      r0,|L7.52|
000028  f7ffbffe          B.W      adc_software_trigger_enable
;;;211    }
;;;212    
                          ENDP

                  |L7.44|
                          DCD      ||.bss||
                  |L7.48|
                          DCD      ADC_CALLBACK_SetScanRequest
                  |L7.52|
                          DCD      0x40012400

                          AREA ||i.ADC_Stop||, CODE, READONLY, ALIGN=1

                  ADC_Stop PROC
;;;213    // 停止检测
;;;214    void ADC_Stop(void)
000000  2019              MOVS     r0,#0x19
;;;215    {
;;;216    	TIMER_KillTask(TIMER_ID_ADC_SCAN);
000002  f7ffbffe          B.W      TIMER_KillTask
;;;217    }
;;;218    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  adcCB
                          %        228

                          AREA ||.data||, DATA, ALIGN=0

                  adc_channel
000000  06070e0f          DCB      0x06,0x07,0x0e,0x0f
000004  080c0000          DCB      0x08,0x0c,0x00,0x00

;*** Start embedded assembler ***

#line 1 "User\\adc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_adc_c_f4ac512c____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___5_adc_c_f4ac512c____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_adc_c_f4ac512c____REVSH|
#line 128
|__asm___5_adc_c_f4ac512c____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
