; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\uartprotocol.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\uartprotocol.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -I.\User\qrencode -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.3\Device\Include -D__MICROLIB -D__UVISION_VERSION=539 -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\uartprotocol.crf User\UartProtocol.c]
                          THUMB

                          AREA ||i.UART_PROTOCOL_CALLBACK_SetTxPeriodRequest||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL_CALLBACK_SetTxPeriodRequest PROC
;;;1121   // 码表设置周期下发数据请求标志
;;;1122   void UART_PROTOCOL_CALLBACK_SetTxPeriodRequest(uint32 param)
000000  4901              LDR      r1,|L1.8|
;;;1123   {
;;;1124   	uartProtocolCB.txPeriodRequest = (BOOL)param;
000002  f881047c          STRB     r0,[r1,#0x47c]
;;;1125   }
000006  4770              BX       lr
;;;1126   
                          ENDP

                  |L1.8|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOL_CALLBACK_UartBusError||, CODE, READONLY, ALIGN=1

                  UART_PROTOCOL_CALLBACK_UartBusError PROC
;;;1127   // 	UART总线超时错误处理
;;;1128   void UART_PROTOCOL_CALLBACK_UartBusError(uint32 param)
000000  4770              BX       lr
;;;1129   {
;;;1130   }
;;;1131   
                          ENDP


                          AREA ||i.UART_PROTOCOL_CheckSUM||, CODE, READONLY, ALIGN=1

                  UART_PROTOCOL_CheckSUM PROC
;;;495    // 对传入的命令帧进行校验，返回校验结果
;;;496    BOOL UART_PROTOCOL_CheckSUM(UART_PROTOCOL_RX_CMD_FRAME *pCmdFrame)
000000  b530              PUSH     {r4,r5,lr}
;;;497    {
;;;498    	uint8 cc = 0;
000002  2200              MOVS     r2,#0
;;;499    	uint16 i = 0;
000004  2100              MOVS     r1,#0
;;;500    
;;;501    	if (NULL == pCmdFrame)
000006  2800              CMP      r0,#0
000008  d003              BEQ      |L3.18|
;;;502    	{
;;;503    		return FALSE;
;;;504    	}
;;;505    
;;;506    	// 从命令头开始，到校验码之前的一个字节，依次进行异或运算
;;;507    	for (i = 0; i < pCmdFrame->length - 1; i++)
00000a  f8b05098          LDRH     r5,[r0,#0x98]
00000e  1e6b              SUBS     r3,r5,#1
000010  e006              B        |L3.32|
                  |L3.18|
000012  2000              MOVS     r0,#0                 ;503
;;;508    	{
;;;509    		cc ^= pCmdFrame->buff[i];
;;;510    	}
;;;511    
;;;512    	cc = ~cc;
;;;513    
;;;514    	// 判断计算得到的校验码与命令帧中的校验码是否相同
;;;515    	if (pCmdFrame->buff[pCmdFrame->length - 1] != cc)
;;;516    	{
;;;517    		return FALSE;
;;;518    	}
;;;519    
;;;520    	return TRUE;
;;;521    }
000014  bd30              POP      {r4,r5,pc}
                  |L3.22|
000016  1844              ADDS     r4,r0,r1              ;509
000018  78a4              LDRB     r4,[r4,#2]            ;509
00001a  4062              EORS     r2,r2,r4              ;509
00001c  1c49              ADDS     r1,r1,#1              ;507
00001e  b289              UXTH     r1,r1                 ;507
                  |L3.32|
000020  428b              CMP      r3,r1                 ;507
000022  dcf8              BGT      |L3.22|
000024  43d1              MVNS     r1,r2                 ;512
000026  b2c9              UXTB     r1,r1                 ;512
000028  1c40              ADDS     r0,r0,#1              ;515
00002a  5c28              LDRB     r0,[r5,r0]            ;515
00002c  4288              CMP      r0,r1                 ;515
00002e  d001              BEQ      |L3.52|
000030  2000              MOVS     r0,#0                 ;517
000032  bd30              POP      {r4,r5,pc}
                  |L3.52|
000034  2001              MOVS     r0,#1                 ;520
000036  bd30              POP      {r4,r5,pc}
;;;522    
                          ENDP


                          AREA ||i.UART_PROTOCOL_CmdFrameProcess||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL_CmdFrameProcess PROC
;;;610    // UART命令帧缓冲区处理
;;;611    void UART_PROTOCOL_CmdFrameProcess(UART_PROTOCOL_CB *pCB)
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;612    {
000004  4606              MOV      r6,r0
;;;613    	UART_PROTOCOL_CMD cmd = UART_PROTOCOL_CMD_NULL;
;;;614    	UART_PROTOCOL_RX_CMD_FRAME *pCmdFrame = NULL;
;;;615    
;;;616    	// 我的变量
;;;617    	uint8 eraResual = 0;
;;;618    
;;;619    	// 参数合法性检验
;;;620    	if (NULL == pCB)
000006  2e00              CMP      r6,#0
000008  d016              BEQ      |L4.56|
;;;621    	{
;;;622    		return;
;;;623    	}
;;;624    
;;;625    	// 命令帧缓冲区为空，退出
;;;626    	if (pCB->rx.head == pCB->rx.end)
00000a  f8b6029c          LDRH     r0,[r6,#0x29c]
00000e  f8b6129e          LDRH     r1,[r6,#0x29e]
000012  4288              CMP      r0,r1
000014  d010              BEQ      |L4.56|
;;;627    	{
;;;628    		return;
;;;629    	}
;;;630    
;;;631    	// 获取当前要处理的命令帧指针
;;;632    	pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.head];
000016  214d              MOVS     r1,#0x4d
000018  4341              MULS     r1,r0,r1
00001a  eb060441          ADD      r4,r6,r1,LSL #1
00001e  34ce              ADDS     r4,r4,#0xce
;;;633    
;;;634    	// 命令头非法，退出
;;;635    	if (UART_PROTOCOL_CMD_HEAD != pCmdFrame->buff[UART_PROTOCOL_CMD_HEAD_INDEX])
000020  78a1              LDRB     r1,[r4,#2]
000022  2955              CMP      r1,#0x55
000024  d00a              BEQ      |L4.60|
;;;636    	{
;;;637    		// 删除命令帧
;;;638    		pCB->rx.head++;
000026  1c40              ADDS     r0,r0,#1
000028  b280              UXTH     r0,r0
;;;639    		pCB->rx.head %= UART_PROTOCOL_RX_QUEUE_SIZE;
00002a  2103              MOVS     r1,#3
00002c  fbb0f2f1          UDIV     r2,r0,r1
000030  fb010012          MLS      r0,r1,r2,r0
000034  f8a6029c          STRH     r0,[r6,#0x29c]
                  |L4.56|
;;;640    		return;
;;;641    	}
;;;642    
;;;643    	// 命令头合法，则提取命令
;;;644    	cmd = (UART_PROTOCOL_CMD)pCmdFrame->buff[UART_PROTOCOL_CMD_CMD_INDEX];
;;;645    	switch (dut_info.ID)
;;;646    	{
;;;647            case DUT_TYPE_NULL:
;;;648                break;
;;;649    
;;;650            case DUT_TYPE_CM: // 串口通用升级
;;;651            
;;;652                switch (cmd)
;;;653                {
;;;654                    case UART_PROTOCOL_CMD_NULL: // = 0				// 空命令
;;;655                        break;
;;;656    
;;;657                    case UART_CMD_UP_PROJECT_APPLY: // 0x01			//DUT工程模式申请,bc280ul
;;;658                        // 发送允许进入工程模式
;;;659                        if (!dut_info.dutPowerOnAllow)
;;;660                        {
;;;661                            STATE_SwitchStep(STEP_CM_UART_BC_UPGRADE_UP_ALLOW);
;;;662                        }
;;;663                        else
;;;664                        {
;;;665                            /*不操作，仪表自动跳过工程模式*/
;;;666                        }
;;;667                        break;
;;;668    
;;;669                    case UART_CMD_UP_PROJECT_READY: // 0x03			//DUT工程模式准备就绪
;;;670                        // 选择升级
;;;671                        if (dut_info.appUpFlag)
;;;672                        {
;;;673                            STATE_SwitchStep(STEP_CM_UART_BC_UPGRADE_SEND_APP_EAR);
;;;674                        }
;;;675                        else if (dut_info.uiUpFlag)
;;;676                        {
;;;677                            STATE_SwitchStep(STEP_CM_UART_BC_UPGRADE_SEND_UI_EAR);
;;;678                        }
;;;679                        else if (dut_info.configUpFlag)
;;;680                        {
;;;681                            STATE_SwitchStep(STEP_UART_SET_CONFIG_ENTRY);
;;;682                        }
;;;683                        break;
;;;684    
;;;685                    case UART_CMD_DUT_UI_DATA_ERASE_ACK: // 0x13		//DUT_UI擦写成功
;;;686                        // 提取DUT_UI擦除结果
;;;687                        eraResual = pCmdFrame->buff[UART_PROTOCOL_CMD_DATA1_INDEX];
;;;688    
;;;689                        // 擦除失败
;;;690                        if (0 == eraResual)
;;;691                        {
;;;692                            // 擦除失败再擦除一次
;;;693                            STATE_SwitchStep(STEP_CM_UART_BC_UPGRADE_SEND_UI_EAR);
;;;694                            break;
;;;695                        }
;;;696                        // 擦除成功
;;;697                        dut_info.currentUiSize = 0;
;;;698                        STATE_SwitchStep(STEP_CM_UART_BC_UPGRADE_SEND_UI_PACKET);
;;;699                        break;
;;;700    
;;;701                    case UART_CMD_DUT_UI_DATA_WRITE_RES: // 0x15			//DUT_UI写入结果
;;;702                        eraResual = pCmdFrame->buff[UART_PROTOCOL_CMD_DATA1_INDEX];
;;;703    
;;;704                        if (0 == eraResual) // 如果仪表写入失败就退出
;;;705                        {
;;;706                            dut_info.currentUiSize--;
;;;707                        }
;;;708    
;;;709                        if (dut_info.currentUiSize < dut_info.uiSize)
;;;710                        {
;;;711                            STATE_SwitchStep(STEP_CM_UART_BC_UPGRADE_SEND_UI_PACKET);
;;;712                        }
;;;713                        else
;;;714                        {
;;;715                            STATE_SwitchStep(STEP_CM_UART_BC_UPGRADE_UI_UP_SUCCESS);
;;;716                        }
;;;717                        break;
;;;718    
;;;719                    case UART_CMD_DUT_APP_ERASE_FLASH: // 0x24		//DUT_APP擦写
;;;720                        break;
;;;721    
;;;722                    case UART_CMD_DUT_APP_ERASE_RESULT: // 0x25			//DUT_APP擦写结果查询
;;;723                        eraResual = pCmdFrame->buff[UART_PROTOCOL_CMD_DATA1_INDEX];
;;;724                        // 擦除失败
;;;725                        if (0 == eraResual)
;;;726                        {
;;;727                            // 擦除失败再擦除一次
;;;728                            STATE_SwitchStep(STEP_CM_UART_BC_UPGRADE_SEND_APP_EAR);
;;;729                            break;
;;;730                        }
;;;731    
;;;732                        // 发送第一帧数据
;;;733                        dut_info.currentAppSize = 0;
;;;734                        STATE_SwitchStep(STEP_CM_UART_BC_UPGRADE_SEND_APP_PACKET);
;;;735                        break;
;;;736    
;;;737                    case UART_CMD_DUT_APP_WRITE_FLASH: // 0x26		//DUT_APP写入
;;;738                        break;
;;;739    
;;;740                    case UART_CMD_DUT_APP_WRITE_FLASH_RES: // 0x27		//DUT_APP写入结果
;;;741                        eraResual = pCmdFrame->buff[UART_PROTOCOL_CMD_DATA1_INDEX];
;;;742    
;;;743                        if (0 == eraResual) // 如果仪表写入失败就退出
;;;744                        {
;;;745                            dut_info.currentAppSize--;
;;;746                        }
;;;747                        if (dut_info.currentAppSize < dut_info.appSize)
;;;748                        {
;;;749                            STATE_SwitchStep(STEP_CM_UART_BC_UPGRADE_SEND_APP_PACKET);
;;;750                        }
;;;751                        else
;;;752                        {
;;;753                            STATE_SwitchStep(STEP_CM_UART_BC_UPGRADE_APP_UP_SUCCESS);
;;;754                        }
;;;755                        break;
;;;756    
;;;757                    case UART_CMD_UP_UPDATA_FINISH_RESULT: // 0x2B  			//DUT写入结果确定
;;;758                        STATE_SwitchStep(STEP_CM_UART_BC_UPGRADE_ITEM_FINISH);
;;;759                        break;
;;;760    
;;;761                    default:
;;;762                        break;
;;;763                    }
;;;764                    break;
;;;765                    
;;;766                case DUT_TYPE_HUAXIN: // 华芯微特串口升级
;;;767                
;;;768                    // 执行命令帧
;;;769                    switch (cmd)
;;;770                    {
;;;771                        // 收到仪表发送的ECO请求
;;;772                        case UART_CMD_UP_PROJECT_ALLOW:	   // 02
;;;773                            if (!dut_info.dutPowerOnAllow) // 允许开机就不应答
;;;774                            {
;;;775                                STATE_SwitchStep(STEP_HUAXIN_UART_BC_UPGRADE_UP_ALLOW);
;;;776                            }
;;;777                            break;
;;;778    
;;;779                        // 仪表回应准备就绪
;;;780                        case UART_CMD_UP_PROJECT_READY: // 03
;;;781    
;;;782                            /*判断还有是否要升级的标志位*/
;;;783                            if (dut_info.appUpFlag)
;;;784                            {
;;;785                                // 向仪表发送擦除app区命令
;;;786                                STATE_SwitchStep(STEP_HUAXIN_UART_BC_UPGRADE_SEND_APP_EAR);
;;;787                            }
;;;788                            else if (dut_info.uiUpFlag)
;;;789                            {
;;;790                                // 向仪表发送擦除ui区命令
;;;791                                STATE_SwitchStep(STEP_HUAXIN_UART_BC_UPGRADE_SEND_UI_EAR);
;;;792                            }
;;;793                            else if (dut_info.configUpFlag)
;;;794                            {
;;;795                                STATE_SwitchStep(STEP_UART_SET_CONFIG_ENTRY);
;;;796                            }
;;;797                            break;
;;;798    
;;;799                        case UART_CMD_UP_APP_EAR: // 05
;;;800                            // 提取仪表擦除结果
;;;801                            eraResual = pCmdFrame->buff[UART_PROTOCOL_CMD_DATA1_INDEX];
;;;802    
;;;803                            // 擦除失败
;;;804                            if (0 == eraResual)
;;;805                            {
;;;806                                // 擦除失败再擦除一次
;;;807                                STATE_SwitchStep(STEP_HUAXIN_UART_BC_UPGRADE_SEND_APP_EAR);
;;;808                                break;
;;;809                            }
;;;810                            // 擦除成功
;;;811                            STATE_SwitchStep(STEP_HUAXIN_UART_BC_UPGRADE_SEND_FIRST_APP_PACKET);
;;;812                            break;
;;;813    
;;;814                        case UART_CMD_UP_APP_UP: // 06,app写入
;;;815                            eraResual = pCmdFrame->buff[UART_PROTOCOL_CMD_DATA1_INDEX];
;;;816                            if (0 == eraResual) // 如果仪表写入失败
;;;817                            {
;;;818                                dut_info.currentAppSize--;
;;;819                            }
;;;820    
;;;821                            if (dut_info.currentAppSize < dut_info.appSize)
;;;822                            {
;;;823                                STATE_SwitchStep(STEP_HUAXIN_UART_BC_UPGRADE_SEND_APP_PACKET);
;;;824                            }
;;;825                            else
;;;826                            {
;;;827                                STATE_SwitchStep(STEP_HUAXIN_UART_BC_UPGRADE_APP_UP_SUCCESS);
;;;828                            }
;;;829    
;;;830                            break;
;;;831    
;;;832                        case UART_CMD_UP_APP_UP_OVER: // 07，升级项结束，开始升级下一项
;;;833                            STATE_SwitchStep(STEP_HUAXIN_UART_BC_UPGRADE_ITEM_FINISH);
;;;834    
;;;835                            break;
;;;836    
;;;837                        case UART_CMD_DUT_UI_DATA_ERASE: // 0x12,ui擦除
;;;838    
;;;839                            break;
;;;840    
;;;841                        case UART_CMD_DUT_UI_DATA_ERASE_ACK: // 0x13,ui擦除应答
;;;842                        
;;;843                            // 提取DUT_UI擦除结果
;;;844                            eraResual = pCmdFrame->buff[UART_PROTOCOL_CMD_DATA1_INDEX];
;;;845    
;;;846                            // 擦除失败
;;;847                            if (0 == eraResual)
;;;848                            {
;;;849                                // 擦除失败再擦除一次
;;;850                                STATE_SwitchStep(STEP_HUAXIN_UART_BC_UPGRADE_SEND_UI_EAR);
;;;851                                break;
;;;852                            }
;;;853                            // 擦除成功
;;;854                            dut_info.currentUiSize = 0;
;;;855                            STATE_SwitchStep(STEP_HUAXIN_UART_BC_UPGRADE_SEND_FIRST_UI_PACKET);
;;;856                            break;
;;;857                        case UART_CMD_DUT_UI_DATA_WRITE: // 0x14,ui写入
;;;858    
;;;859                            break;
;;;860                        case UART_CMD_DUT_UI_DATA_WRITE_RES: // 0x15,ui写入结果
;;;861    
;;;862                            eraResual = pCmdFrame->buff[UART_PROTOCOL_CMD_DATA1_INDEX];
;;;863    
;;;864                            if (0 == eraResual) // 如果仪表写入失败就退出
;;;865                            {
;;;866                                dut_info.currentUiSize--;
;;;867                            }
;;;868    
;;;869                            if (dut_info.currentUiSize < dut_info.uiSize)
;;;870                            {
;;;871                                STATE_SwitchStep(STEP_HUAXIN_UART_BC_UPGRADE_SEND_UI_PACKET);
;;;872                            }
;;;873                            else
;;;874                            {
;;;875                                STATE_SwitchStep(STEP_HUAXIN_UART_BC_UPGRADE_UI_UP_SUCCESS);
;;;876                            }
;;;877                            break;
;;;878                        default:
;;;879                            break;
;;;880                    }
;;;881    
;;;882                    break;
;;;883    
;;;884            // 串口段码屏升级
;;;885            case DUT_TYPE_SEG:
;;;886                switch (cmd)
;;;887                {
;;;888                    // 收到仪表发送的ECO请求
;;;889                    case UART_CMD_UP_PROJECT_ALLOW: // 02
;;;890                    
;;;891                        // 发送允许进入工程模式
;;;892                        STATE_SwitchStep(STEP_CM_UART_SEG_UPGRADE_UP_ALLOW);
;;;893                        break;
;;;894                        
;;;895                    case UART_CMD_UP_PROJECT_READY: // 03
;;;896                    
;;;897                        // 发送app擦除指令
;;;898                        if (dut_info.appUpFlag)
;;;899                        {
;;;900                            STATE_SwitchStep(STEP_CM_UART_SEG_UPGRADE_SEND_APP_EAR);
;;;901                        }
;;;902                        else if (dut_info.configUpFlag)
;;;903                        {
;;;904                            STATE_SwitchStep(STEP_CM_UART_SEG_UPGRADE_ITEM_FINISH);
;;;905                        }
;;;906                        break;
;;;907    
;;;908                    // dut擦除结果查询
;;;909                    case UART_CMD_UP_APP_EAR:
;;;910                    
;;;911                        // 提取仪表擦除结果
;;;912                        eraResual = pCmdFrame->buff[UART_PROTOCOL_CMD_DATA1_INDEX];
;;;913    
;;;914                        // 擦除失败
;;;915                        if (0 == eraResual)
;;;916                        {
;;;917                            // 擦除失败再擦除一次
;;;918                            STATE_SwitchStep(STEP_CM_UART_SEG_UPGRADE_SEND_APP_EAR);
;;;919                            break;
;;;920                        }
;;;921                        // 擦除成功
;;;922                        // 发送第一包数据
;;;923                        STATE_SwitchStep(STEP_CM_UART_SEG_UPGRADE_SEND_FIRST_APP_PACKET);
;;;924                        break;
;;;925                        
;;;926                    case UART_CMD_UP_APP_UP: // 06,app数据写入
;;;927                        eraResual = pCmdFrame->buff[UART_PROTOCOL_CMD_DATA1_INDEX];
;;;928    
;;;929                        if (0 == eraResual) // 如果仪表写入失败
;;;930                        {
;;;931                            break;
;;;932                        }
;;;933                        else
;;;934                        {
;;;935                            if (dut_info.currentAppSize < dut_info.appSize)
;;;936                            {
;;;937                                STATE_SwitchStep(STEP_CM_UART_SEG_UPGRADE_SEND_APP_PACKET); // 发送app数据包
;;;938                            }
;;;939                            else
;;;940                            {
;;;941                                STATE_SwitchStep(STEP_CM_UART_SEG_UPGRADE_APP_UP_SUCCESS);
;;;942                            }
;;;943                        }
;;;944                        break;
;;;945                        
;;;946                    case UART_CMD_UP_APP_UP_OVER: // 07，app升级完毕
;;;947                        STATE_SwitchStep(STEP_CM_UART_SEG_UPGRADE_APP_UP_SUCCESS_RESET);
;;;948                        break;
;;;949                        
;;;950                    default:
;;;951                        break;
;;;952                }
;;;953                break;
;;;954    		
;;;955    	// 开阳升级流程
;;;956    	case DUT_TYPE_KAIYANG:
;;;957    		// 执行命令帧
;;;958    		switch (cmd)
;;;959    		{
;;;960    		// 收到仪表发送的ECO请求
;;;961    		case UART_CMD_UP_PROJECT_APPLY: // 01
;;;962    			if (!dut_info.dutPowerOnAllow)
;;;963    			{
;;;964    				if (dut_info.uiUpFlag || dut_info.appUpFlag)
;;;965    				{
;;;966    					STATE_SwitchStep(STEP_KAIYANG_UART_UPGRADE_UP_ALLOW);
;;;967    				}
;;;968    				else if (dut_info.configUpFlag)
;;;969    				{
;;;970    					STATE_SwitchStep(STEP_UART_SET_CONFIG_ENTRY);
;;;971    				}
;;;972    				dut_info.dutPowerOnAllow = TRUE; // 不在接收eco请求
;;;973    			}
;;;974    			break;
;;;975    
;;;976    		// 仪表回应准备就绪
;;;977    		case UART_CMD_UP_PROJECT_ALLOW: // 02
;;;978    			if (dut_info.appUpFlag)
;;;979    			{
;;;980    				dut_info.currentAppSize = 0;
;;;981    				STATE_SwitchStep(STEP_KAIYANG_UART_UPGRADE_SEND_APP_WRITE);
;;;982    				TIMER_AddTask(TIMER_ID_RECONNECTION, 
;;;983    							1000, 
;;;984    							STATE_SwitchStep, 
;;;985    							STEP_KAIYANG_UART_UPGRADE_SEND_APP_AGAIN, 
;;;986    							TIMER_LOOP_FOREVER, 
;;;987    							ACTION_MODE_ADD_TO_QUEUE);
;;;988    			}
;;;989    			else if (dut_info.uiUpFlag)
;;;990    			{
;;;991    				dut_info.currentUiSize = 0;
;;;992    				STATE_SwitchStep(STEP_KAIYANG_UART_UPGRADE_SEND_UI_WRITE);
;;;993    				TIMER_AddTask(TIMER_ID_RECONNECTION, 
;;;994    							1000, 
;;;995    							STATE_SwitchStep, 
;;;996    							STEP_KAIYANG_UART_UPGRADE_SEND_UI_AGAIN, 
;;;997    							TIMER_LOOP_FOREVER, 
;;;998    							ACTION_MODE_ADD_TO_QUEUE);
;;;999    			}
;;;1000   			break;
;;;1001   
;;;1002   		case UART_CMD_UP_PROJECT_READY: // 03
;;;1003   			TIMER_ResetTimer(TIMER_ID_DUT_TIMEOUT);	// 喂狗
;;;1004   			if (dut_info.appUpFlag)
;;;1005   			{
;;;1006   				if (dut_info.currentAppSize < dut_info.appSize - 1)
;;;1007   				{
;;;1008   					if (pCmdFrame->buff[UART_PROTOCOL_CMD_DATA1_INDEX])
;;;1009   					{
;;;1010   						dut_info.currentAppSize++;
;;;1011   					}
;;;1012   					STATE_SwitchStep(STEP_KAIYANG_UART_UPGRADE_SEND_APP_WRITE);
;;;1013   				}
;;;1014   				else
;;;1015   				{
;;;1016   					STATE_SwitchStep(STEP_KAIYANG_UART_UPGRADE_APP_UP_SUCCESS);
;;;1017   				}
;;;1018   			}
;;;1019   			else if (dut_info.uiUpFlag)
;;;1020   			{
;;;1021   				if (dut_info.currentUiSize < dut_info.uiSize - 1)
;;;1022   				{
;;;1023   					if (pCmdFrame->buff[UART_PROTOCOL_CMD_DATA1_INDEX])
;;;1024   					{
;;;1025   						dut_info.currentUiSize++;
;;;1026   					}
;;;1027   					STATE_SwitchStep(STEP_KAIYANG_UART_UPGRADE_SEND_UI_WRITE);
;;;1028   				}
;;;1029   				else
;;;1030   				{
;;;1031   					STATE_SwitchStep(STEP_KAIYANG_UART_UPGRADE_APP_UP_SUCCESS);
;;;1032   				}
;;;1033   			}
;;;1034   			break;
;;;1035               
;;;1036   		case UART_ECO_CMD_ECO_JUMP_APP: // 04
;;;1037   			if (pCmdFrame->buff[UART_PROTOCOL_CMD_DATA1_INDEX])
;;;1038   			{
;;;1039   				// 升级成功
;;;1040   				if (dut_info.appUpFlag)
;;;1041   				{
;;;1042   					dut_info.appUpSuccesss = TRUE;
;;;1043   					dut_info.appUpFlag = FALSE;
;;;1044   				}
;;;1045   				else if (dut_info.uiUpFlag)
;;;1046   				{
;;;1047   					dut_info.uiUpSuccesss = TRUE;
;;;1048   					dut_info.uiUpFlag = FALSE;
;;;1049   				}
;;;1050   			}
;;;1051   			else // 升级失败
;;;1052   			{
;;;1053   				if (dut_info.appUpFlag)
;;;1054   				{
;;;1055   					dut_info.appUpFaile = TRUE;
;;;1056   					dut_info.appUpFlag = FALSE;
;;;1057   				}
;;;1058   				else if (dut_info.uiUpFlag)
;;;1059   				{
;;;1060   					dut_info.appUpFaile = TRUE;
;;;1061   					dut_info.uiUpFlag = FALSE;
;;;1062   				}
;;;1063   			}
;;;1064   			TIMER_KillTask(TIMER_ID_DUT_TIMEOUT);
;;;1065   			STATE_SwitchStep(STEP_KAIYANG_UART_UPGRADE_ITEM_FINISH);
;;;1066   			break;
;;;1067   
;;;1068   		default:
;;;1069   			break;
;;;1070   		}
;;;1071   		break;
;;;1072                   
;;;1073               default:
;;;1074                   break;
;;;1075   	}
;;;1076   
;;;1077   	// 删除命令帧
;;;1078   	pCB->rx.head++;
;;;1079   	pCB->rx.head %= UART_PROTOCOL_RX_QUEUE_SIZE;
;;;1080   }
000038  e8bd9fff          POP      {r0-r12,pc}
                  |L4.60|
00003c  78e1              LDRB     r1,[r4,#3]            ;644
00003e  4df3              LDR      r5,|L4.1036|
000040  2300              MOVS     r3,#0                 ;645
000042  462f              MOV      r7,r5                 ;645
000044  f895b016          LDRB     r11,[r5,#0x16]        ;645  ; dut_info
000048  f8d7a05c          LDR      r10,[r7,#0x5c]        ;706
00004c  f8978064          LDRB     r8,[r7,#0x64]         ;659
000050  f8970025          LDRB     r0,[r7,#0x25]         ;671
000054  f8972027          LDRB     r2,[r7,#0x27]         ;675
000058  f897c026          LDRB     r12,[r7,#0x26]        ;679
00005c  f8d79050          LDR      r9,[r7,#0x50]         ;709
000060  f8cd900c          STR      r9,[sp,#0xc]          ;645
000064  f8d79058          LDR      r9,[r7,#0x58]         ;645
000068  f8cd9008          STR      r9,[sp,#8]            ;745
00006c  6cff              LDR      r7,[r7,#0x4c]         ;747
00006e  f1aa0a01          SUB      r10,r10,#1            ;706
000072  f1a90901          SUB      r9,r9,#1              ;745
000076  f1bb0f06          CMP      r11,#6                ;645
00007a  d22c              BCS      |L4.214|
00007c  e8dff00b          TBB      [pc,r11]              ;645
000080  2b2b037a          DCB      0x2b,0x2b,0x03,0x7a
000084  ecfb              DCB      0xec,0xfb
000086  f2401b17          MOV      r11,#0x117            ;673
00008a  2924              CMP      r1,#0x24              ;652
                  |L4.140|
00008c  d023              BEQ      |L4.214|
00008e  dc10              BGT      |L4.178|
000090  f240171b          MOV      r7,#0x11b             ;677
000094  2903              CMP      r1,#3                 ;652
000096  d01f              BEQ      |L4.216|
000098  dc04              BGT      |L4.164|
00009a  2900              CMP      r1,#0                 ;652
00009c  d0f6              BEQ      |L4.140|
00009e  2901              CMP      r1,#1                 ;652
                  |L4.160|
0000a0  d119              BNE      |L4.214|
0000a2  e011              B        |L4.200|
                  |L4.164|
0000a4  f240121d          MOV      r2,#0x11d             ;698
0000a8  2913              CMP      r1,#0x13              ;652
0000aa  d027              BEQ      |L4.252|
0000ac  2915              CMP      r1,#0x15              ;652
0000ae  d1f7              BNE      |L4.160|
0000b0  e02f              B        |L4.274|
                  |L4.178|
0000b2  f2401219          MOV      r2,#0x119             ;734
0000b6  2925              CMP      r1,#0x25              ;652
0000b8  d03c              BEQ      |L4.308|
0000ba  2926              CMP      r1,#0x26              ;652
0000bc  d0e6              BEQ      |L4.140|
0000be  2927              CMP      r1,#0x27              ;652
0000c0  d043              BEQ      |L4.330|
0000c2  292b              CMP      r1,#0x2b              ;652
0000c4  d1ec              BNE      |L4.160|
0000c6  e050              B        |L4.362|
                  |L4.200|
0000c8  f1b80f00          CMP      r8,#0                 ;659
0000cc  d1e8              BNE      |L4.160|
0000ce  f2401015          MOV      r0,#0x115             ;661
0000d2  f7fffffe          BL       STATE_SwitchStep
                  |L4.214|
0000d6  e18c              B        |L4.1010|
                  |L4.216|
0000d8  b118              CBZ      r0,|L4.226|
0000da  4658              MOV      r0,r11                ;673
0000dc  f7fffffe          BL       STATE_SwitchStep
0000e0  e187              B        |L4.1010|
                  |L4.226|
0000e2  b11a              CBZ      r2,|L4.236|
0000e4  4638              MOV      r0,r7                 ;677
0000e6  f7fffffe          BL       STATE_SwitchStep
0000ea  e182              B        |L4.1010|
                  |L4.236|
0000ec  f1bc0f00          CMP      r12,#0                ;679
0000f0  d0f1              BEQ      |L4.214|
0000f2  f240104d          MOV      r0,#0x14d             ;681
0000f6  f7fffffe          BL       STATE_SwitchStep
0000fa  e17a              B        |L4.1010|
                  |L4.252|
0000fc  7960              LDRB     r0,[r4,#5]            ;687
0000fe  b120              CBZ      r0,|L4.266|
000100  65eb              STR      r3,[r5,#0x5c]         ;697  ; dut_info
000102  4610              MOV      r0,r2                 ;698
000104  f7fffffe          BL       STATE_SwitchStep
000108  e173              B        |L4.1010|
                  |L4.266|
00010a  4638              MOV      r0,r7                 ;693
00010c  f7fffffe          BL       STATE_SwitchStep
000110  e16f              B        |L4.1010|
                  |L4.274|
000112  7960              LDRB     r0,[r4,#5]            ;702
000114  b908              CBNZ     r0,|L4.282|
000116  f8c5a05c          STR      r10,[r5,#0x5c]        ;706  ; dut_info
                  |L4.282|
00011a  6de9              LDR      r1,[r5,#0x5c]         ;709  ; dut_info
00011c  9803              LDR      r0,[sp,#0xc]          ;709
00011e  4281              CMP      r1,r0                 ;709
000120  d203              BCS      |L4.298|
000122  4610              MOV      r0,r2                 ;711
000124  f7fffffe          BL       STATE_SwitchStep
000128  e163              B        |L4.1010|
                  |L4.298|
00012a  f44f708f          MOV      r0,#0x11e             ;715
00012e  f7fffffe          BL       STATE_SwitchStep
000132  e15e              B        |L4.1010|
                  |L4.308|
000134  7960              LDRB     r0,[r4,#5]            ;723
000136  b120              CBZ      r0,|L4.322|
000138  65ab              STR      r3,[r5,#0x58]         ;733  ; dut_info
00013a  4610              MOV      r0,r2                 ;734
00013c  f7fffffe          BL       STATE_SwitchStep
000140  e157              B        |L4.1010|
                  |L4.322|
000142  4658              MOV      r0,r11                ;728
000144  f7fffffe          BL       STATE_SwitchStep
000148  e153              B        |L4.1010|
                  |L4.330|
00014a  7960              LDRB     r0,[r4,#5]            ;741
00014c  b908              CBNZ     r0,|L4.338|
00014e  f8c59058          STR      r9,[r5,#0x58]         ;745  ; dut_info
                  |L4.338|
000152  6da8              LDR      r0,[r5,#0x58]         ;747  ; dut_info
000154  42b8              CMP      r0,r7                 ;747
000156  d203              BCS      |L4.352|
000158  4610              MOV      r0,r2                 ;749
00015a  f7fffffe          BL       STATE_SwitchStep
00015e  e148              B        |L4.1010|
                  |L4.352|
000160  f44f708d          MOV      r0,#0x11a             ;753
000164  f7fffffe          BL       STATE_SwitchStep
000168  e143              B        |L4.1010|
                  |L4.362|
00016a  f240101f          MOV      r0,#0x11f             ;758
00016e  f7fffffe          BL       STATE_SwitchStep
000172  e13e              B        |L4.1010|
000174  f2401b27          MOV      r11,#0x127            ;791
000178  2907              CMP      r1,#7                 ;769
00017a  d04a              BEQ      |L4.530|
00017c  dc0a              BGT      |L4.404|
00017e  2902              CMP      r1,#2                 ;769
000180  d011              BEQ      |L4.422|
000182  f2401323          MOV      r3,#0x123             ;786
000186  2903              CMP      r1,#3                 ;769
000188  d015              BEQ      |L4.438|
00018a  2905              CMP      r1,#5                 ;769
00018c  d025              BEQ      |L4.474|
00018e  2906              CMP      r1,#6                 ;769
000190  d1a1              BNE      |L4.214|
000192  e02d              B        |L4.496|
                  |L4.404|
000194  2912              CMP      r1,#0x12              ;769
000196  d09e              BEQ      |L4.214|
000198  2913              CMP      r1,#0x13              ;769
00019a  d03f              BEQ      |L4.540|
00019c  2914              CMP      r1,#0x14              ;769
00019e  d09a              BEQ      |L4.214|
0001a0  2915              CMP      r1,#0x15              ;769
0001a2  d198              BNE      |L4.214|
0001a4  e046              B        |L4.564|
                  |L4.422|
0001a6  f1b80f00          CMP      r8,#0                 ;773
0001aa  d194              BNE      |L4.214|
0001ac  f44f7091          MOV      r0,#0x122             ;775
0001b0  f7fffffe          BL       STATE_SwitchStep
0001b4  e11d              B        |L4.1010|
                  |L4.438|
0001b6  b118              CBZ      r0,|L4.448|
0001b8  4618              MOV      r0,r3                 ;786
0001ba  f7fffffe          BL       STATE_SwitchStep
0001be  e118              B        |L4.1010|
                  |L4.448|
0001c0  b11a              CBZ      r2,|L4.458|
0001c2  4658              MOV      r0,r11                ;791
0001c4  f7fffffe          BL       STATE_SwitchStep
0001c8  e113              B        |L4.1010|
                  |L4.458|
0001ca  f1bc0f00          CMP      r12,#0                ;793
0001ce  d003              BEQ      |L4.472|
0001d0  f240104d          MOV      r0,#0x14d             ;795
0001d4  f7fffffe          BL       STATE_SwitchStep
                  |L4.472|
0001d8  e10b              B        |L4.1010|
                  |L4.474|
0001da  7960              LDRB     r0,[r4,#5]            ;801
0001dc  b120              CBZ      r0,|L4.488|
0001de  f44f7092          MOV      r0,#0x124             ;811
0001e2  f7fffffe          BL       STATE_SwitchStep
0001e6  e104              B        |L4.1010|
                  |L4.488|
0001e8  4618              MOV      r0,r3                 ;807
0001ea  f7fffffe          BL       STATE_SwitchStep
0001ee  e100              B        |L4.1010|
                  |L4.496|
0001f0  7960              LDRB     r0,[r4,#5]            ;815
0001f2  b908              CBNZ     r0,|L4.504|
0001f4  f8c59058          STR      r9,[r5,#0x58]         ;818  ; dut_info
                  |L4.504|
0001f8  6da8              LDR      r0,[r5,#0x58]         ;821  ; dut_info
0001fa  42b8              CMP      r0,r7                 ;821
0001fc  d204              BCS      |L4.520|
0001fe  f2401025          MOV      r0,#0x125             ;823
000202  f7fffffe          BL       STATE_SwitchStep
000206  e0f4              B        |L4.1010|
                  |L4.520|
000208  f44f7093          MOV      r0,#0x126             ;827
00020c  f7fffffe          BL       STATE_SwitchStep
000210  e0ef              B        |L4.1010|
                  |L4.530|
000212  f240102b          MOV      r0,#0x12b             ;833
000216  f7fffffe          BL       STATE_SwitchStep
00021a  e0ea              B        |L4.1010|
                  |L4.540|
00021c  7960              LDRB     r0,[r4,#5]            ;844
00021e  b128              CBZ      r0,|L4.556|
000220  65eb              STR      r3,[r5,#0x5c]         ;854  ; dut_info
000222  f44f7094          MOV      r0,#0x128             ;855
000226  f7fffffe          BL       STATE_SwitchStep
00022a  e0e2              B        |L4.1010|
                  |L4.556|
00022c  4658              MOV      r0,r11                ;850
00022e  f7fffffe          BL       STATE_SwitchStep
000232  e0de              B        |L4.1010|
                  |L4.564|
000234  7960              LDRB     r0,[r4,#5]            ;862
000236  b908              CBNZ     r0,|L4.572|
000238  f8c5a05c          STR      r10,[r5,#0x5c]        ;866  ; dut_info
                  |L4.572|
00023c  6de9              LDR      r1,[r5,#0x5c]         ;869  ; dut_info
00023e  9803              LDR      r0,[sp,#0xc]          ;869
000240  4281              CMP      r1,r0                 ;869
000242  d204              BCS      |L4.590|
000244  f2401029          MOV      r0,#0x129             ;871
000248  f7fffffe          BL       STATE_SwitchStep
00024c  e0d1              B        |L4.1010|
                  |L4.590|
00024e  f44f7095          MOV      r0,#0x12a             ;875
000252  f7fffffe          BL       STATE_SwitchStep
000256  e0cc              B        |L4.1010|
000258  1e89              SUBS     r1,r1,#2              ;886
00025a  f2401231          MOV      r2,#0x131             ;900
00025e  2906              CMP      r1,#6                 ;886
000260  d208              BCS      |L4.628|
000262  e8dff001          TBB      [pc,r1]               ;886
000266  0309              DCB      0x03,0x09
000268  c6162130          DCB      0xc6,0x16,0x21,0x30
00026c  f44f7098          MOV      r0,#0x130             ;892
000270  f7fffffe          BL       STATE_SwitchStep
                  |L4.628|
000274  e0bd              B        |L4.1010|
000276  e02b              B        |L4.720|
000278  b118              CBZ      r0,|L4.642|
00027a  4610              MOV      r0,r2                 ;900
00027c  f7fffffe          BL       STATE_SwitchStep
000280  e0b7              B        |L4.1010|
                  |L4.642|
000282  f1bc0f00          CMP      r12,#0                ;902
000286  d003              BEQ      |L4.656|
000288  f44f709b          MOV      r0,#0x136             ;904
00028c  f7fffffe          BL       STATE_SwitchStep
                  |L4.656|
000290  e0af              B        |L4.1010|
000292  7960              LDRB     r0,[r4,#5]            ;912
000294  b120              CBZ      r0,|L4.672|
000296  f44f7099          MOV      r0,#0x132             ;923
00029a  f7fffffe          BL       STATE_SwitchStep
00029e  e0a8              B        |L4.1010|
                  |L4.672|
0002a0  4610              MOV      r0,r2                 ;918
0002a2  f7fffffe          BL       STATE_SwitchStep
0002a6  e0a4              B        |L4.1010|
0002a8  7960              LDRB     r0,[r4,#5]            ;927
0002aa  b390              CBZ      r0,|L4.786|
0002ac  9802              LDR      r0,[sp,#8]            ;935
0002ae  42b8              CMP      r0,r7                 ;935
0002b0  d204              BCS      |L4.700|
0002b2  f2401033          MOV      r0,#0x133             ;937
0002b6  f7fffffe          BL       STATE_SwitchStep
0002ba  e09a              B        |L4.1010|
                  |L4.700|
0002bc  f44f709a          MOV      r0,#0x134             ;941
0002c0  f7fffffe          BL       STATE_SwitchStep
0002c4  e095              B        |L4.1010|
0002c6  f2401035          MOV      r0,#0x135             ;947
0002ca  f7fffffe          BL       STATE_SwitchStep
0002ce  e090              B        |L4.1010|
                  |L4.720|
0002d0  2701              MOVS     r7,#1                 ;644
0002d2  2901              CMP      r1,#1                 ;958
0002d4  d00a              BEQ      |L4.748|
0002d6  f240183b          MOV      r8,#0x13b             ;981
0002da  f44f799f          MOV      r9,#0x13e             ;992
0002de  2902              CMP      r1,#2                 ;958
0002e0  d018              BEQ      |L4.788|
0002e2  2903              CMP      r1,#3                 ;958
0002e4  d038              BEQ      |L4.856|
0002e6  2904              CMP      r1,#4                 ;958
0002e8  d113              BNE      |L4.786|
0002ea  e062              B        |L4.946|
                  |L4.748|
0002ec  f1b80f00          CMP      r8,#0                 ;962
0002f0  d17f              BNE      |L4.1010|
0002f2  b902              CBNZ     r2,|L4.758|
0002f4  b120              CBZ      r0,|L4.768|
                  |L4.758|
0002f6  f44f709d          MOV      r0,#0x13a             ;966
0002fa  f7fffffe          BL       STATE_SwitchStep
0002fe  e006              B        |L4.782|
                  |L4.768|
000300  f1bc0f00          CMP      r12,#0                ;968
000304  d003              BEQ      |L4.782|
000306  f240104d          MOV      r0,#0x14d             ;970
00030a  f7fffffe          BL       STATE_SwitchStep
                  |L4.782|
00030e  f8857064          STRB     r7,[r5,#0x64]         ;972
                  |L4.786|
000312  e06e              B        |L4.1010|
                  |L4.788|
000314  f04f34ff          MOV      r4,#0xffffffff        ;982
000318  f44f7a7a          MOV      r10,#0x3e8            ;982
00031c  b168              CBZ      r0,|L4.826|
00031e  65ab              STR      r3,[r5,#0x58]         ;980  ; dut_info
000320  4640              MOV      r0,r8                 ;981
000322  f7fffffe          BL       STATE_SwitchStep
000326  e9cd4700          STRD     r4,r7,[sp,#0]         ;982
00032a  f44f739e          MOV      r3,#0x13c             ;982
00032e  4a38              LDR      r2,|L4.1040|
000330  4651              MOV      r1,r10                ;982
000332  2009              MOVS     r0,#9                 ;982
000334  f7fffffe          BL       TIMER_AddTask
000338  e05b              B        |L4.1010|
                  |L4.826|
00033a  b30a              CBZ      r2,|L4.896|
00033c  65eb              STR      r3,[r5,#0x5c]         ;991  ; dut_info
00033e  4648              MOV      r0,r9                 ;992
000340  f7fffffe          BL       STATE_SwitchStep
000344  e9cd4700          STRD     r4,r7,[sp,#0]         ;993
000348  f240133f          MOV      r3,#0x13f             ;993
00034c  4a30              LDR      r2,|L4.1040|
00034e  4651              MOV      r1,r10                ;993
000350  2009              MOVS     r0,#9                 ;993
000352  f7fffffe          BL       TIMER_AddTask
000356  e04c              B        |L4.1010|
                  |L4.856|
000358  2008              MOVS     r0,#8                 ;1003
00035a  f7fffffe          BL       TIMER_ResetTimer
00035e  f8950025          LDRB     r0,[r5,#0x25]         ;1004  ; dut_info
000362  f240113d          MOV      r1,#0x13d             ;1016
000366  b180              CBZ      r0,|L4.906|
000368  6cea              LDR      r2,[r5,#0x4c]         ;1006  ; dut_info
00036a  6da8              LDR      r0,[r5,#0x58]         ;1006  ; dut_info
00036c  1e52              SUBS     r2,r2,#1              ;1006
00036e  4290              CMP      r0,r2                 ;1006
000370  d207              BCS      |L4.898|
000372  7961              LDRB     r1,[r4,#5]            ;1008
000374  b109              CBZ      r1,|L4.890|
000376  1c40              ADDS     r0,r0,#1              ;1010
000378  65a8              STR      r0,[r5,#0x58]         ;1010  ; dut_info
                  |L4.890|
00037a  4640              MOV      r0,r8                 ;1012
00037c  f7fffffe          BL       STATE_SwitchStep
                  |L4.896|
000380  e037              B        |L4.1010|
                  |L4.898|
000382  4608              MOV      r0,r1                 ;1016
000384  f7fffffe          BL       STATE_SwitchStep
000388  e033              B        |L4.1010|
                  |L4.906|
00038a  f8950027          LDRB     r0,[r5,#0x27]         ;1019  ; dut_info
00038e  b380              CBZ      r0,|L4.1010|
000390  6d2a              LDR      r2,[r5,#0x50]         ;1021  ; dut_info
000392  6de8              LDR      r0,[r5,#0x5c]         ;1021  ; dut_info
000394  1e52              SUBS     r2,r2,#1              ;1021
000396  4290              CMP      r0,r2                 ;1021
000398  d207              BCS      |L4.938|
00039a  7961              LDRB     r1,[r4,#5]            ;1023
00039c  b109              CBZ      r1,|L4.930|
00039e  1c40              ADDS     r0,r0,#1              ;1025
0003a0  65e8              STR      r0,[r5,#0x5c]         ;1025  ; dut_info
                  |L4.930|
0003a2  4648              MOV      r0,r9                 ;1027
0003a4  f7fffffe          BL       STATE_SwitchStep
0003a8  e023              B        |L4.1010|
                  |L4.938|
0003aa  4608              MOV      r0,r1                 ;1031
0003ac  f7fffffe          BL       STATE_SwitchStep
0003b0  e01f              B        |L4.1010|
                  |L4.946|
0003b2  7961              LDRB     r1,[r4,#5]            ;1037
0003b4  b159              CBZ      r1,|L4.974|
0003b6  b120              CBZ      r0,|L4.962|
0003b8  f8857067          STRB     r7,[r5,#0x67]         ;1042
0003bc  f8853025          STRB     r3,[r5,#0x25]         ;1043
0003c0  e010              B        |L4.996|
                  |L4.962|
0003c2  b17a              CBZ      r2,|L4.996|
0003c4  f8857066          STRB     r7,[r5,#0x66]         ;1047
0003c8  f8853027          STRB     r3,[r5,#0x27]         ;1048
0003cc  e00a              B        |L4.996|
                  |L4.974|
0003ce  b120              CBZ      r0,|L4.986|
0003d0  f8857061          STRB     r7,[r5,#0x61]         ;1055
0003d4  f8853025          STRB     r3,[r5,#0x25]         ;1056
0003d8  e004              B        |L4.996|
                  |L4.986|
0003da  b11a              CBZ      r2,|L4.996|
0003dc  f8857061          STRB     r7,[r5,#0x61]         ;1060
0003e0  f8853027          STRB     r3,[r5,#0x27]         ;1061
                  |L4.996|
0003e4  2008              MOVS     r0,#8                 ;1064
0003e6  f7fffffe          BL       TIMER_KillTask
0003ea  f2401041          MOV      r0,#0x141             ;1065
0003ee  f7fffffe          BL       STATE_SwitchStep
                  |L4.1010|
0003f2  f8b6029c          LDRH     r0,[r6,#0x29c]        ;1078
0003f6  1c40              ADDS     r0,r0,#1              ;1078
0003f8  b280              UXTH     r0,r0                 ;1078
0003fa  2103              MOVS     r1,#3                 ;1079
0003fc  fbb0f2f1          UDIV     r2,r0,r1              ;1079
000400  fb010012          MLS      r0,r1,r2,r0           ;1079
000404  f8a6029c          STRH     r0,[r6,#0x29c]        ;1079
000408  e616              B        |L4.56|
;;;1081   
                          ENDP

00040a  0000              DCW      0x0000
                  |L4.1036|
                          DCD      dut_info
                  |L4.1040|
                          DCD      STATE_SwitchStep

                          AREA ||i.UART_PROTOCOL_ConfirmTempCmdFrameBuff||, CODE, READONLY, ALIGN=1

                  UART_PROTOCOL_ConfirmTempCmdFrameBuff PROC
;;;276    // 将临时缓冲区添加到命令帧缓冲区中，其本质操作是承认临时缓冲区数据有效
;;;277    BOOL UART_PROTOCOL_ConfirmTempCmdFrameBuff(UART_PROTOCOL_CB *pCB)
000000  2800              CMP      r0,#0
;;;278    {
000002  d01a              BEQ      |L5.58|
;;;279    	UART_PROTOCOL_RX_CMD_FRAME *pCmdFrame = NULL;
;;;280    
;;;281    	// 参数合法性检验
;;;282    	if (NULL == pCB)
;;;283    	{
;;;284    		return FALSE;
;;;285    	}
;;;286    
;;;287    	// 临时缓冲区为空，不予添加
;;;288    	pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.end];
000004  f8b0129e          LDRH     r1,[r0,#0x29e]
000008  224d              MOVS     r2,#0x4d
00000a  434a              MULS     r2,r1,r2
00000c  eb000242          ADD      r2,r0,r2,LSL #1
;;;289    	if (0 == pCmdFrame->length)
000010  f8b22166          LDRH     r2,[r2,#0x166]
000014  b19a              CBZ      r2,|L5.62|
;;;290    	{
;;;291    		return FALSE;
;;;292    	}
;;;293    
;;;294    	// 添加
;;;295    	pCB->rx.end++;
000016  1c49              ADDS     r1,r1,#1
000018  b289              UXTH     r1,r1
;;;296    	pCB->rx.end %= UART_PROTOCOL_RX_QUEUE_SIZE;
00001a  2203              MOVS     r2,#3
00001c  fbb1f3f2          UDIV     r3,r1,r2
000020  fb021113          MLS      r1,r2,r3,r1
000024  f8a0129e          STRH     r1,[r0,#0x29e]
;;;297    	pCB->rx.cmdQueue[pCB->rx.end].length = 0; // 该行的作用是将新的添加位置有效数据个数清零，以便将这个位置当做临时帧缓冲区
000028  2200              MOVS     r2,#0
00002a  234d              MOVS     r3,#0x4d
00002c  4359              MULS     r1,r3,r1
00002e  eb000041          ADD      r0,r0,r1,LSL #1
000032  f8a02166          STRH     r2,[r0,#0x166]
;;;298    
;;;299    	return TRUE;
000036  2001              MOVS     r0,#1
;;;300    }
000038  4770              BX       lr
                  |L5.58|
00003a  2000              MOVS     r0,#0                 ;284
00003c  4770              BX       lr
                  |L5.62|
00003e  2000              MOVS     r0,#0                 ;291
000040  4770              BX       lr
;;;301    
                          ENDP


                          AREA ||i.UART_PROTOCOL_DataStructInit||, CODE, READONLY, ALIGN=1

                  UART_PROTOCOL_DataStructInit PROC
;;;213    // 数据结构初始化
;;;214    void UART_PROTOCOL_DataStructInit(UART_PROTOCOL_CB *pCB)
000000  2800              CMP      r0,#0
;;;215    {
000002  d027              BEQ      |L6.84|
;;;216    	uint16 i;
;;;217    
;;;218    	// 参数合法性检验
;;;219    	if (NULL == pCB)
;;;220    	{
;;;221    		return;
;;;222    	}
;;;223    
;;;224    	pCB->tx.txBusy = FALSE;
000004  2200              MOVS     r2,#0
000006  f8802474          STRB     r2,[r0,#0x474]
;;;225    	pCB->tx.index = 0;
00000a  f8a02472          STRH     r2,[r0,#0x472]
;;;226    	pCB->tx.head = 0;
00000e  f8a0246e          STRH     r2,[r0,#0x46e]
;;;227    	pCB->tx.end = 0;
000012  f8a02470          STRH     r2,[r0,#0x470]
;;;228    	for (i = 0; i < UART_PROTOCOL_TX_QUEUE_SIZE; i++)
000016  2100              MOVS     r1,#0
                  |L6.24|
;;;229    	{
;;;230    		pCB->tx.cmdQueue[i].length = 0;
000018  234d              MOVS     r3,#0x4d
00001a  434b              MULS     r3,r1,r3
00001c  eb000343          ADD      r3,r0,r3,LSL #1
000020  f8a32338          STRH     r2,[r3,#0x338]
000024  1c49              ADDS     r1,r1,#1              ;228
000026  b289              UXTH     r1,r1                 ;228
000028  2903              CMP      r1,#3                 ;228
00002a  d3f5              BCC      |L6.24|
;;;231    	}
;;;232    
;;;233    	pCB->rxFIFO.head = 0;
00002c  f8202fc8          STRH     r2,[r0,#0xc8]!
;;;234    	pCB->rxFIFO.end = 0;
000030  8042              STRH     r2,[r0,#2]
;;;235    	pCB->rxFIFO.currentProcessIndex = 0;
000032  8082              STRH     r2,[r0,#4]
;;;236    
;;;237    	pCB->rx.head = 0;
000034  f8a021d4          STRH     r2,[r0,#0x1d4]
;;;238    	pCB->rx.end = 0;
000038  f8a021d6          STRH     r2,[r0,#0x1d6]
00003c  38c8              SUBS     r0,r0,#0xc8
;;;239    	for (i = 0; i < UART_PROTOCOL_RX_QUEUE_SIZE; i++)
00003e  2100              MOVS     r1,#0
                  |L6.64|
;;;240    	{
;;;241    		pCB->rx.cmdQueue[i].length = 0;
000040  234d              MOVS     r3,#0x4d
000042  434b              MULS     r3,r1,r3
000044  eb000343          ADD      r3,r0,r3,LSL #1
000048  f8a32166          STRH     r2,[r3,#0x166]
00004c  1c49              ADDS     r1,r1,#1              ;239
00004e  b289              UXTH     r1,r1                 ;239
000050  2903              CMP      r1,#3                 ;239
000052  d3f5              BCC      |L6.64|
                  |L6.84|
;;;242    	}
;;;243    }
000054  4770              BX       lr
;;;244    
                          ENDP


                          AREA ||i.UART_PROTOCOL_Init||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL_Init PROC
;;;54     // 协议初始化
;;;55     void UART_PROTOCOL_Init(void)
000000  b500              PUSH     {lr}
;;;56     {
;;;57     	// 协议层数据结构初始化
;;;58     	UART_PROTOCOL_DataStructInit(&uartProtocolCB);
000002  4804              LDR      r0,|L7.20|
000004  f7fffffe          BL       UART_PROTOCOL_DataStructInit
;;;59     
;;;60     	// 向驱动层注册数据接收接口
;;;61     	// UART_DRIVE_RegisterDataSendService(UART_PROTOCOL_MacProcess);
;;;62     
;;;63     	// 向驱动层注册数据发送接口
;;;64     	UART_PROTOCOL_RegisterDataSendService(UART_DRIVE_AddTxArray);
000008  4803              LDR      r0,|L7.24|
00000a  f85deb04          POP      {lr}
00000e  f7ffbffe          B.W      UART_PROTOCOL_RegisterDataSendService
;;;65     
;;;66     	// 注册间隔参数设置时间
;;;67     	//	TIMER_AddTask(TIMER_ID_PROTOCOL_55_PARAM_TX,
;;;68     	//					300,
;;;69     	//					UART_PROTOCOL_SendCmdAging,
;;;70     	//					TRUE,
;;;71     	//					TIMER_LOOP_FOREVER,
;;;72     	//					ACTION_MODE_ADD_TO_QUEUE);
;;;73     }
;;;74     
                          ENDP

000012  0000              DCW      0x0000
                  |L7.20|
                          DCD      ||.bss||
                  |L7.24|
                          DCD      UART_DRIVE_AddTxArray

                          AREA ||i.UART_PROTOCOL_MacProcess||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL_MacProcess PROC
;;;245    // UART报文接收处理函数(注意根据具体模块修改)
;;;246    void UART_PROTOCOL_MacProcess(uint16 standarID, uint8 *pData, uint16 length)
000000  b570              PUSH     {r4-r6,lr}
;;;247    {
;;;248    	uint16 end = uartProtocolCB.rxFIFO.end;
000002  480d              LDR      r0,|L8.56|
000004  f8b020ca          LDRH     r2,[r0,#0xca]  ; uartProtocolCB
;;;249    	uint16 head = uartProtocolCB.rxFIFO.head;
000008  f8b040c8          LDRH     r4,[r0,#0xc8]  ; uartProtocolCB
;;;250    	uint8 rxdata = 0x00;
;;;251    
;;;252    	// 接收数据
;;;253    	rxdata = *pData;
00000c  780d              LDRB     r5,[r1,#0]
;;;254    
;;;255    	// 一级缓冲区已满，不予接收
;;;256    	if ((end + 1) % UART_PROTOCOL_RX_FIFO_SIZE == head)
00000e  1c53              ADDS     r3,r2,#1
000010  21c8              MOVS     r1,#0xc8
000012  fbb3f6f1          UDIV     r6,r3,r1
000016  fb013316          MLS      r3,r1,r6,r3
00001a  42a3              CMP      r3,r4
00001c  d00a              BEQ      |L8.52|
;;;257    	{
;;;258    		return;
;;;259    	}
;;;260    	// 一级缓冲区未满，接收
;;;261    	else
;;;262    	{
;;;263    		// 将接收到的数据放到临时缓冲区中
;;;264    		uartProtocolCB.rxFIFO.buff[end] = rxdata;
00001e  5485              STRB     r5,[r0,r2]
;;;265    		uartProtocolCB.rxFIFO.end++;
000020  f8302fca          LDRH     r2,[r0,#0xca]!  ; uartProtocolCB
000024  1c52              ADDS     r2,r2,#1
000026  8002              STRH     r2,[r0,#0]
;;;266    		uartProtocolCB.rxFIFO.end %= UART_PROTOCOL_RX_FIFO_SIZE;
000028  8802              LDRH     r2,[r0,#0]  ; uartProtocolCB
00002a  fbb2f3f1          UDIV     r3,r2,r1
00002e  fb012113          MLS      r1,r1,r3,r2
000032  8001              STRH     r1,[r0,#0]
                  |L8.52|
;;;267    	}
;;;268    }
000034  bd70              POP      {r4-r6,pc}
;;;269    
                          ENDP

000036  0000              DCW      0x0000
                  |L8.56|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOL_Process||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL_Process PROC
;;;75     // UART协议层过程处理
;;;76     void UART_PROTOCOL_Process(void)
000000  b510              PUSH     {r4,lr}
;;;77     {
;;;78     //	// 55升级协议
;;;79     //	//  UART接收FIFO缓冲区处理
;;;80     //	UART_PROTOCOL_RxFIFOProcess(&uartProtocolCB);
;;;81     
;;;82     //	// UART接收命令缓冲区处理
;;;83     //	UART_PROTOCOL_CmdFrameProcess(&uartProtocolCB);
;;;84     
;;;85     //	// UART协议层发送处理过程
;;;86     //	UART_PROTOCOL_TxStateProcess();
;;;87     
;;;88     	// 3A配置协议
;;;89     	// UART接收FIFO缓冲区处理
;;;90     	UART_PROTOCOL4_RxFIFOProcess(&uartProtocolCB4);
000002  4805              LDR      r0,|L9.24|
000004  f7fffffe          BL       UART_PROTOCOL4_RxFIFOProcess
;;;91     
;;;92     	// UART接收命令缓冲区处理
;;;93     	UART_PROTOCOL4_CmdFrameProcess(&uartProtocolCB4); // km5s协议，在app中升级config
000008  4803              LDR      r0,|L9.24|
00000a  f7fffffe          BL       UART_PROTOCOL4_CmdFrameProcess
;;;94     
;;;95     	// UART协议层发送处理过程
;;;96     	UART_PROTOCOL4_TxStateProcess();
00000e  e8bd4010          POP      {r4,lr}
000012  f7ffbffe          B.W      UART_PROTOCOL4_TxStateProcess
;;;97     }
;;;98     
                          ENDP

000016  0000              DCW      0x0000
                  |L9.24|
                          DCD      uartProtocolCB4

                          AREA ||i.UART_PROTOCOL_RegisterDataSendService||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL_RegisterDataSendService PROC
;;;270    // UART协议层向驱动层注册数据发送接口
;;;271    void UART_PROTOCOL_RegisterDataSendService(BOOL (*service)(uint16 id, uint8 *pData, uint16 length))
000000  4901              LDR      r1,|L10.8|
;;;272    {
;;;273    	uartProtocolCB.sendDataThrowService = service;
000002  f8c10478          STR      r0,[r1,#0x478]  ; uartProtocolCB
;;;274    }
000006  4770              BX       lr
;;;275    
                          ENDP

                  |L10.8|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOL_ReportWriteParamResult||, CODE, READONLY, ALIGN=1

                  UART_PROTOCOL_ReportWriteParamResult PROC
;;;1132   // 上报写配置参数结果
;;;1133   void UART_PROTOCOL_ReportWriteParamResult(uint32 param)
000000  b510              PUSH     {r4,lr}
;;;1134   {
000002  4604              MOV      r4,r0
;;;1135   	// 添加命令头
;;;1136   	UART_PROTOCOL_TxAddData(UART_PROTOCOL_CMD_HEAD);
000004  2055              MOVS     r0,#0x55
000006  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;1137   
;;;1138   	// 添加设备地址
;;;1139   	UART_PROTOCOL_TxAddData(UART_PROTOCOL_CMD_DEVICE_ADDR);
00000a  201a              MOVS     r0,#0x1a
00000c  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;1140   
;;;1141   	// 添加命令字
;;;1142   	UART_PROTOCOL_TxAddData(UART_PROTOCOL_CMD_WRITE_CONTROL_PARAM_RESULT);
000010  20c1              MOVS     r0,#0xc1
000012  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;1143   
;;;1144   	// 添加数据长度
;;;1145   	UART_PROTOCOL_TxAddData(1);
000016  2001              MOVS     r0,#1
000018  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;1146   
;;;1147   	// 写入结果
;;;1148   	UART_PROTOCOL_TxAddData(param);
00001c  b2e0              UXTB     r0,r4
00001e  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;1149   
;;;1150   	// 添加检验和与结束符，并添加至发送
;;;1151   	UART_PROTOCOL_TxAddFrame();
000022  e8bd4010          POP      {r4,lr}
000026  f7ffbffe          B.W      UART_PROTOCOL_TxAddFrame
;;;1152   }
;;;1153   
                          ENDP


                          AREA ||i.UART_PROTOCOL_RxFIFOProcess||, CODE, READONLY, ALIGN=1

                  UART_PROTOCOL_RxFIFOProcess PROC
;;;335    // 一级接收缓冲区处理，从一级接收缓冲区中取出一个字节添加到命令帧缓冲区中
;;;336    void UART_PROTOCOL_RxFIFOProcess(UART_PROTOCOL_CB *pCB)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;337    {
000004  4604              MOV      r4,r0
;;;338    	uint16 end = pCB->rxFIFO.end;
000006  f8b410ca          LDRH     r1,[r4,#0xca]
;;;339    	uint16 head = pCB->rxFIFO.head;
00000a  f8b400c8          LDRH     r0,[r4,#0xc8]
;;;340    	UART_PROTOCOL_RX_CMD_FRAME *pCmdFrame = NULL;
;;;341    	uint16 length = 0;
;;;342    	uint8 currentData = 0;
;;;343    
;;;344    	// 参数合法性检验
;;;345    	if (NULL == pCB)
00000e  2c00              CMP      r4,#0
000010  d021              BEQ      |L12.86|
;;;346    	{
;;;347    		return;
;;;348    	}
;;;349    
;;;350    	// 一级缓冲区为空，退出
;;;351    	if (head == end)
000012  4288              CMP      r0,r1
000014  d01f              BEQ      |L12.86|
;;;352    	{
;;;353    		return;
;;;354    	}
;;;355    
;;;356    	// 获取临时缓冲区指针
;;;357    	pCmdFrame = &pCB->rx.cmdQueue[pCB->rx.end];
000016  f8b4229e          LDRH     r2,[r4,#0x29e]
00001a  204d              MOVS     r0,#0x4d
00001c  4350              MULS     r0,r2,r0
00001e  eb040540          ADD      r5,r4,r0,LSL #1
000022  35ce              ADDS     r5,r5,#0xce
;;;358    	// 取出当前要处理的字节
;;;359    	currentData = pCB->rxFIFO.buff[pCB->rxFIFO.currentProcessIndex];
000024  f8b400cc          LDRH     r0,[r4,#0xcc]
000028  5c20              LDRB     r0,[r4,r0]
;;;360    
;;;361    	// 临时缓冲区长度为0时，搜索首字节
;;;362    	if (0 == pCmdFrame->length)
00002a  f8b53098          LDRH     r3,[r5,#0x98]
;;;363    	{
;;;364    		// 命令头错误，删除当前字节并退出
;;;365    		if (UART_PROTOCOL_CMD_HEAD != currentData)
;;;366    		{
;;;367    			pCB->rxFIFO.head++;
;;;368    			pCB->rxFIFO.head %= UART_PROTOCOL_RX_FIFO_SIZE;
00002e  27c8              MOVS     r7,#0xc8
000030  b19b              CBZ      r3,|L12.90|
;;;369    			pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;370    
;;;371    			return;
;;;372    		}
;;;373    
;;;374    		// 命令头正确，但无临时缓冲区可用，退出
;;;375    		if ((pCB->rx.end + 1) % UART_PROTOCOL_RX_QUEUE_SIZE == pCB->rx.head)
;;;376    		{
;;;377    			return;
;;;378    		}
;;;379    
;;;380    		// 添加UART通讯超时时间设置-2016.1.5增加
;;;381    #if UART_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;382    		TIMER_AddTask(TIMER_ID_UART_RX_TIME_OUT_CONTROL,
;;;383    					  UART_PROTOCOL_BUS_UNIDIRECTIONAL_TIME_OUT,
;;;384    					  UART_PROTOCOL_CALLBACK_RxTimeOut,
;;;385    					  0,
;;;386    					  1,
;;;387    					  ACTION_MODE_ADD_TO_QUEUE);
;;;388    #endif
;;;389    
;;;390    		// 命令头正确，有临时缓冲区可用，则将其添加到命令帧临时缓冲区中
;;;391    		pCmdFrame->buff[pCmdFrame->length++] = currentData;
;;;392    		pCB->rxFIFO.currentProcessIndex++;
;;;393    		pCB->rxFIFO.currentProcessIndex %= UART_PROTOCOL_RX_FIFO_SIZE;
;;;394    	}
;;;395    	// 非首字节，将数据添加到命令帧临时缓冲区中，但暂不删除当前数据
;;;396    	else
;;;397    	{
;;;398    		// 临时缓冲区溢出，说明当前正在接收的命令帧是错误的，正确的命令帧不会出现长度溢出的情况
;;;399    		if (pCmdFrame->length >= UART_PROTOCOL_RX_CMD_FRAME_LENGTH_MAX)
000032  f04f0800          MOV      r8,#0
000036  2b96              CMP      r3,#0x96
000038  d37e              BCC      |L12.312|
;;;400    		{
;;;401    #if UART_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;402    			// 停止RX通讯超时检测
;;;403    			UART_PROTOCOL_StopRxTimeOutCheck();
;;;404    #endif
;;;405    
;;;406    			// 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;407    			pCmdFrame->length = 0; // 2016.1.5增加
00003a  f8a58098          STRH     r8,[r5,#0x98]
;;;408    			// 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;409    			pCB->rxFIFO.head++;
00003e  f8340fc8          LDRH     r0,[r4,#0xc8]!
000042  1c40              ADDS     r0,r0,#1
000044  8020              STRH     r0,[r4,#0]
;;;410    			pCB->rxFIFO.head %= UART_PROTOCOL_RX_FIFO_SIZE;
000046  8820              LDRH     r0,[r4,#0]
000048  fbb0f1f7          UDIV     r1,r0,r7
00004c  fb070011          MLS      r0,r7,r1,r0
000050  8020              STRH     r0,[r4,#0]
;;;411    			pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
000052  8820              LDRH     r0,[r4,#0]
000054  80a0              STRH     r0,[r4,#4]
                  |L12.86|
;;;412    
;;;413    			return;
;;;414    		}
;;;415    
;;;416    		// 一直取到末尾
;;;417    		while (end != pCB->rxFIFO.currentProcessIndex)
;;;418    		{
;;;419    			// 取出当前要处理的字节
;;;420    			currentData = pCB->rxFIFO.buff[pCB->rxFIFO.currentProcessIndex];
;;;421    			// 缓冲区未溢出，正常接收，将数据添加到临时缓冲区中
;;;422    			pCmdFrame->buff[pCmdFrame->length++] = currentData;
;;;423    			pCB->rxFIFO.currentProcessIndex++;
;;;424    			pCB->rxFIFO.currentProcessIndex %= UART_PROTOCOL_RX_FIFO_SIZE;
;;;425    
;;;426    			// ■■接下来，需要检查命令帧是否完整，如果完整，则将命令帧临时缓冲区扶正■■
;;;427    
;;;428    			// 首先判断命令帧最小长度，一个完整的命令字至少包括8个字节: 命令头、设备地址、命令字、数据长度、校验和L、校验和H、结束标识0xD、结束标识OxA，因此不足8个字节的必定不完整
;;;429    			if (pCmdFrame->length < UART_PROTOCOL_CMD_FRAME_LENGTH_MIN)
;;;430    			{
;;;431    				// 继续接收
;;;432    				continue;
;;;433    			}
;;;434    
;;;435    			// 命令帧长度数值越界，说明当前命令帧错误，停止接收
;;;436    			if (pCmdFrame->buff[UART_PROTOCOL_CMD_LENGTH_INDEX] > UART_PROTOCOL_RX_CMD_FRAME_LENGTH_MAX - UART_PROTOCOL_CMD_FRAME_LENGTH_MIN)
;;;437    			{
;;;438    #if UART_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;439    				// 停止RX通讯超时检测
;;;440    				UART_PROTOCOL_StopRxTimeOutCheck();
;;;441    #endif
;;;442    
;;;443    				// 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;444    				pCmdFrame->length = 0;
;;;445    				// 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;446    				pCB->rxFIFO.head++;
;;;447    				pCB->rxFIFO.head %= UART_PROTOCOL_RX_FIFO_SIZE;
;;;448    				pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;449    
;;;450    				return;
;;;451    			}
;;;452    
;;;453    			// 命令帧长度校验，在命令长度描述字的数值上，增加命令头、设备地址、命令字、数据长度、校验和L、校验和H、结束标识0xD、结束标识OxA，即为命令帧实际长度
;;;454    			length = pCmdFrame->length;
;;;455    			if (length < pCmdFrame->buff[UART_PROTOCOL_CMD_LENGTH_INDEX] + UART_PROTOCOL_CMD_FRAME_LENGTH_MIN)
;;;456    			{
;;;457    				// 长度要求不一致，说明未接收完毕，退出继续
;;;458    				continue;
;;;459    			}
;;;460    
;;;461    			// 命令帧长度OK，则进行校验，失败时删除命令头
;;;462    			if (!UART_PROTOCOL_CheckSUM(pCmdFrame))
;;;463    			{
;;;464    #if UART_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;465    				// 停止RX通讯超时检测
;;;466    				UART_PROTOCOL_StopRxTimeOutCheck();
;;;467    #endif
;;;468    
;;;469    				// 校验失败，将命令帧长度清零，即认为抛弃该命令帧
;;;470    				pCmdFrame->length = 0;
;;;471    				// 删除当前的命令头，而不是删除已分析完的所有数据，因为数据中可能会有命令头
;;;472    				pCB->rxFIFO.head++;
;;;473    				pCB->rxFIFO.head %= UART_PROTOCOL_RX_FIFO_SIZE;
;;;474    				pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;475    
;;;476    				return;
;;;477    			}
;;;478    
;;;479    #if UART_PROTOCOL_RX_TIME_OUT_CHECK_ENABLE
;;;480    			// 停止RX通讯超时检测
;;;481    			UART_PROTOCOL_StopRxTimeOutCheck();
;;;482    #endif
;;;483    
;;;484    			// 执行到这里，即说明接收到了一个完整并且正确的命令帧，此时需将处理过的数据从一级缓冲区中删除，并将该命令帧扶正
;;;485    			pCB->rxFIFO.head += length;
;;;486    			pCB->rxFIFO.head %= UART_PROTOCOL_RX_FIFO_SIZE;
;;;487    			pCB->rxFIFO.currentProcessIndex = pCB->rxFIFO.head;
;;;488    			UART_PROTOCOL_ConfirmTempCmdFrameBuff(pCB);
;;;489    
;;;490    			return;
;;;491    		}
;;;492    	}
;;;493    }
000056  e8bd81f0          POP      {r4-r8,pc}
                  |L12.90|
00005a  2855              CMP      r0,#0x55              ;365
00005c  d00c              BEQ      |L12.120|
00005e  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;367
000062  1c40              ADDS     r0,r0,#1              ;367
000064  8020              STRH     r0,[r4,#0]            ;367
000066  8820              LDRH     r0,[r4,#0]            ;368
000068  fbb0f1f7          UDIV     r1,r0,r7              ;368
00006c  fb070011          MLS      r0,r7,r1,r0           ;368
000070  8020              STRH     r0,[r4,#0]            ;368
000072  8820              LDRH     r0,[r4,#0]            ;369
000074  80a0              STRH     r0,[r4,#4]            ;369
000076  e7ee              B        |L12.86|
                  |L12.120|
000078  1c52              ADDS     r2,r2,#1              ;375
00007a  2103              MOVS     r1,#3                 ;375
00007c  fbb2f3f1          UDIV     r3,r2,r1              ;375
000080  fb012113          MLS      r1,r1,r3,r2           ;375
000084  f8b4229c          LDRH     r2,[r4,#0x29c]        ;375
000088  4291              CMP      r1,r2                 ;375
00008a  d0e4              BEQ      |L12.86|
00008c  2101              MOVS     r1,#1                 ;391
00008e  f8a51098          STRH     r1,[r5,#0x98]         ;391
000092  70a8              STRB     r0,[r5,#2]            ;391
000094  f8340fcc          LDRH     r0,[r4,#0xcc]!        ;392
000098  1c40              ADDS     r0,r0,#1              ;392
00009a  b280              UXTH     r0,r0                 ;392
00009c  fbb0f1f7          UDIV     r1,r0,r7              ;393
0000a0  fb070011          MLS      r0,r7,r1,r0           ;393
0000a4  8020              STRH     r0,[r4,#0]            ;393
0000a6  e7d6              B        |L12.86|
                  |L12.168|
0000a8  5c22              LDRB     r2,[r4,r0]            ;420
0000aa  f8b50098          LDRH     r0,[r5,#0x98]         ;422
0000ae  1c43              ADDS     r3,r0,#1              ;422
0000b0  4428              ADD      r0,r0,r5              ;422
0000b2  f8a53098          STRH     r3,[r5,#0x98]         ;422
0000b6  7082              STRB     r2,[r0,#2]            ;422
0000b8  f8b400cc          LDRH     r0,[r4,#0xcc]         ;423
0000bc  1c40              ADDS     r0,r0,#1              ;423
0000be  b280              UXTH     r0,r0                 ;423
0000c0  fbb0f2f7          UDIV     r2,r0,r7              ;424
0000c4  fb070012          MLS      r0,r7,r2,r0           ;424
0000c8  f8a400cc          STRH     r0,[r4,#0xcc]         ;424
0000cc  f8b56098          LDRH     r6,[r5,#0x98]         ;429
0000d0  2e04              CMP      r6,#4                 ;429
0000d2  d33b              BCC      |L12.332|
0000d4  7928              LDRB     r0,[r5,#4]            ;436
0000d6  2892              CMP      r0,#0x92              ;436
0000d8  d90e              BLS      |L12.248|
0000da  f8a58098          STRH     r8,[r5,#0x98]         ;444
0000de  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;446
0000e2  1c40              ADDS     r0,r0,#1              ;446
0000e4  8020              STRH     r0,[r4,#0]            ;446
0000e6  8820              LDRH     r0,[r4,#0]            ;447
0000e8  fbb0f1f7          UDIV     r1,r0,r7              ;447
0000ec  fb070011          MLS      r0,r7,r1,r0           ;447
0000f0  8020              STRH     r0,[r4,#0]            ;447
0000f2  8820              LDRH     r0,[r4,#0]            ;448
0000f4  80a0              STRH     r0,[r4,#4]            ;448
0000f6  e7ae              B        |L12.86|
                  |L12.248|
0000f8  1d00              ADDS     r0,r0,#4              ;455
0000fa  42b0              CMP      r0,r6                 ;455
0000fc  d826              BHI      |L12.332|
0000fe  4628              MOV      r0,r5                 ;462
000100  f7fffffe          BL       UART_PROTOCOL_CheckSUM
000104  b188              CBZ      r0,|L12.298|
000106  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;485
00010a  4430              ADD      r0,r0,r6              ;485
00010c  8020              STRH     r0,[r4,#0]            ;485
00010e  8820              LDRH     r0,[r4,#0]            ;486
000110  fbb0f1f7          UDIV     r1,r0,r7              ;486
000114  fb070011          MLS      r0,r7,r1,r0           ;486
000118  8020              STRH     r0,[r4,#0]            ;486
00011a  8820              LDRH     r0,[r4,#0]            ;487
00011c  80a0              STRH     r0,[r4,#4]            ;487
00011e  3cc8              SUBS     r4,r4,#0xc8           ;487
000120  4620              MOV      r0,r4                 ;488
000122  e8bd41f0          POP      {r4-r8,lr}            ;488
000126  f7ffbffe          B.W      UART_PROTOCOL_ConfirmTempCmdFrameBuff
                  |L12.298|
00012a  f8a58098          STRH     r8,[r5,#0x98]         ;470
00012e  f8340fc8          LDRH     r0,[r4,#0xc8]!        ;472
000132  1c40              ADDS     r0,r0,#1              ;472
000134  8020              STRH     r0,[r4,#0]            ;472
000136  e000              B        |L12.314|
                  |L12.312|
000138  e008              B        |L12.332|
                  |L12.314|
00013a  8820              LDRH     r0,[r4,#0]            ;473
00013c  fbb0f1f7          UDIV     r1,r0,r7              ;473
000140  fb070011          MLS      r0,r7,r1,r0           ;473
000144  8020              STRH     r0,[r4,#0]            ;473
000146  8820              LDRH     r0,[r4,#0]            ;474
000148  80a0              STRH     r0,[r4,#4]            ;474
00014a  e784              B        |L12.86|
                  |L12.332|
00014c  f8b400cc          LDRH     r0,[r4,#0xcc]         ;417
000150  4288              CMP      r0,r1                 ;417
000152  d1a9              BNE      |L12.168|
000154  e77f              B        |L12.86|
;;;494    
                          ENDP


                          AREA ||i.UART_PROTOCOL_SendCmdNoResult||, CODE, READONLY, ALIGN=1

                  UART_PROTOCOL_SendCmdNoResult PROC
;;;1197   // 发送命令无结果
;;;1198   void UART_PROTOCOL_SendCmdNoResult(uint8 cmdWord)
000000  b510              PUSH     {r4,lr}
;;;1199   {
000002  4604              MOV      r4,r0
;;;1200   	// 添加命令头
;;;1201   	UART_PROTOCOL_TxAddData(UART_PROTOCOL_CMD_HEAD);
000004  2055              MOVS     r0,#0x55
000006  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;1202   
;;;1203   	// 添加设备地址
;;;1204   	UART_PROTOCOL_TxAddData(UART_PROTOCOL_CMD_DEVICE_ADDR);
00000a  201a              MOVS     r0,#0x1a
00000c  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;1205   
;;;1206   	// 添加命令字
;;;1207   	UART_PROTOCOL_TxAddData(cmdWord);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;1208   
;;;1209   	UART_PROTOCOL_TxAddData(0); // 数据长度
000016  2000              MOVS     r0,#0
000018  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;1210   
;;;1211   	UART_PROTOCOL_TxAddFrame();
00001c  e8bd4010          POP      {r4,lr}
000020  f7ffbffe          B.W      UART_PROTOCOL_TxAddFrame
;;;1212   }
                          ENDP


                          AREA ||i.UART_PROTOCOL_SendCmdParamAck||, CODE, READONLY, ALIGN=1

                  UART_PROTOCOL_SendCmdParamAck PROC
;;;1082   // 发送命令回复，带一个参数
;;;1083   void UART_PROTOCOL_SendCmdParamAck(uint8 ackCmd, uint8 ackParam)
000000  b530              PUSH     {r4,r5,lr}
;;;1084   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1085   	UART_PROTOCOL_TxAddData(0x55);
000006  2055              MOVS     r0,#0x55
000008  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;1086   	UART_PROTOCOL_TxAddData(ackCmd);
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;1087   	UART_PROTOCOL_TxAddData(0x01);
000012  2001              MOVS     r0,#1
000014  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;1088   	UART_PROTOCOL_TxAddData(ackParam);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;1089   	UART_PROTOCOL_TxAddFrame();
00001e  e8bd4030          POP      {r4,r5,lr}
000022  f7ffbffe          B.W      UART_PROTOCOL_TxAddFrame
;;;1090   }
;;;1091   
                          ENDP


                          AREA ||i.UART_PROTOCOL_SendCmdWithResult||, CODE, READONLY, ALIGN=1

                  UART_PROTOCOL_SendCmdWithResult PROC
;;;1177   // 发送命令带结果
;;;1178   void UART_PROTOCOL_SendCmdWithResult(uint8 cmdWord, uint8 result)
000000  b530              PUSH     {r4,r5,lr}
;;;1179   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1180   	// 添加命令头
;;;1181   	UART_PROTOCOL_TxAddData(UART_PROTOCOL_CMD_HEAD);
000006  2055              MOVS     r0,#0x55
000008  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;1182   
;;;1183   	// 添加设备地址
;;;1184   	UART_PROTOCOL_TxAddData(UART_PROTOCOL_CMD_DEVICE_ADDR);
00000c  201a              MOVS     r0,#0x1a
00000e  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;1185   
;;;1186   	// 添加命令字
;;;1187   	UART_PROTOCOL_TxAddData(cmdWord);
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;1188   
;;;1189   	// 添加数据长度
;;;1190   	UART_PROTOCOL_TxAddData(1);
000018  2001              MOVS     r0,#1
00001a  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;1191   
;;;1192   	UART_PROTOCOL_TxAddData(result);
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;1193   
;;;1194   	UART_PROTOCOL_TxAddFrame();
000024  e8bd4030          POP      {r4,r5,lr}
000028  f7ffbffe          B.W      UART_PROTOCOL_TxAddFrame
;;;1195   }
;;;1196   
                          ENDP


                          AREA ||i.UART_PROTOCOL_SendLdoV||, CODE, READONLY, ALIGN=1

                  UART_PROTOCOL_SendLdoV PROC
;;;1154   // 发送命令带结果
;;;1155   void UART_PROTOCOL_SendLdoV(uint8 cmdWord, uint32 result)
000000  b530              PUSH     {r4,r5,lr}
;;;1156   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1157   	// 添加命令头
;;;1158   	UART_PROTOCOL_TxAddData(UART_PROTOCOL_CMD_HEAD);
000006  2055              MOVS     r0,#0x55
000008  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;1159   
;;;1160   	// 添加设备地址
;;;1161   	UART_PROTOCOL_TxAddData(UART_PROTOCOL_CMD_DEVICE_ADDR);
00000c  201a              MOVS     r0,#0x1a
00000e  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;1162   
;;;1163   	// 添加命令字
;;;1164   	UART_PROTOCOL_TxAddData(cmdWord);
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;1165   
;;;1166   	// 添加数据长度
;;;1167   	UART_PROTOCOL_TxAddData(4);
000018  2004              MOVS     r0,#4
00001a  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;1168   
;;;1169   	UART_PROTOCOL_TxAddData((result >> 24) & 0xFF);
00001e  0e20              LSRS     r0,r4,#24
000020  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;1170   	UART_PROTOCOL_TxAddData((result >> 16) & 0xFF);
000024  f3c44007          UBFX     r0,r4,#16,#8
000028  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;1171   	UART_PROTOCOL_TxAddData((result >> 8) & 0xFF);
00002c  f3c42007          UBFX     r0,r4,#8,#8
000030  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;1172   	UART_PROTOCOL_TxAddData((result >> 0) & 0xFF);
000034  b2e0              UXTB     r0,r4
000036  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;1173   
;;;1174   	UART_PROTOCOL_TxAddFrame();
00003a  e8bd4030          POP      {r4,r5,lr}
00003e  f7ffbffe          B.W      UART_PROTOCOL_TxAddFrame
;;;1175   }
;;;1176   
                          ENDP


                          AREA ||i.UART_PROTOCOL_SetTxAtOnceRequest||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL_SetTxAtOnceRequest PROC
;;;1115   // 码表设置立刻下发数据请求标志
;;;1116   void UART_PROTOCOL_SetTxAtOnceRequest(uint32 param)
000000  4901              LDR      r1,|L17.8|
;;;1117   {
;;;1118   	uartProtocolCB.txAtOnceRequest = (BOOL)param;
000002  f881047d          STRB     r0,[r1,#0x47d]
;;;1119   }
000006  4770              BX       lr
;;;1120   
                          ENDP

                  |L17.8|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOL_TxAddData||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL_TxAddData PROC
;;;99     // 向发送命令帧队列中添加数据
;;;100    void UART_PROTOCOL_TxAddData(uint8 data)
000000  b530              PUSH     {r4,r5,lr}
;;;101    {
;;;102    	uint16 head = uartProtocolCB.tx.head;
000002  490f              LDR      r1,|L18.64|
000004  f8b1446e          LDRH     r4,[r1,#0x46e]  ; uartProtocolCB
;;;103    	uint16 end = uartProtocolCB.tx.end;
000008  f8b12470          LDRH     r2,[r1,#0x470]  ; uartProtocolCB
;;;104    	UART_PROTOCOL_TX_CMD_FRAME *pCmdFrame = &uartProtocolCB.tx.cmdQueue[uartProtocolCB.tx.end];
00000c  234d              MOVS     r3,#0x4d
00000e  4353              MULS     r3,r2,r3
000010  eb010143          ADD      r1,r1,r3,LSL #1
000014  f5017128          ADD      r1,r1,#0x2a0
;;;105    
;;;106    	// 发送缓冲区已满，不予接收
;;;107    	if ((end + 1) % UART_PROTOCOL_TX_QUEUE_SIZE == head)
000018  1c52              ADDS     r2,r2,#1
00001a  2303              MOVS     r3,#3
00001c  fbb2f5f3          UDIV     r5,r2,r3
000020  fb032215          MLS      r2,r3,r5,r2
000024  42a2              CMP      r2,r4
000026  d009              BEQ      |L18.60|
;;;108    	{
;;;109    		return;
;;;110    	}
;;;111    
;;;112    	// 队尾命令帧已满，退出
;;;113    	if (pCmdFrame->length >= UART_PROTOCOL_TX_CMD_FRAME_LENGTH_MAX)
000028  f8b12098          LDRH     r2,[r1,#0x98]
00002c  2a96              CMP      r2,#0x96
00002e  d205              BCS      |L18.60|
;;;114    	{
;;;115    		return;
;;;116    	}
;;;117    	// 数据添加到帧末尾，并更新帧长度
;;;118    	pCmdFrame->buff[pCmdFrame->length] = data;
000030  1c8b              ADDS     r3,r1,#2
000032  54d0              STRB     r0,[r2,r3]
;;;119    	pCmdFrame->length++;
000034  f8310f98          LDRH     r0,[r1,#0x98]!
000038  1c40              ADDS     r0,r0,#1
00003a  8008              STRH     r0,[r1,#0]
                  |L18.60|
;;;120    }
00003c  bd30              POP      {r4,r5,pc}
;;;121    
                          ENDP

00003e  0000              DCW      0x0000
                  |L18.64|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOL_TxAddFrame||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL_TxAddFrame PROC
;;;122    // 确认添加命令帧，即承认之前填充的数据为命令帧，将其添加到发送队列中，由main进行调度发送，本函数内会自动校正命令长度，并添加校验码
;;;123    void UART_PROTOCOL_TxAddFrame(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;124    {
;;;125    	uint16 cc = 0;
000002  2300              MOVS     r3,#0
;;;126    	uint16 i = 0;
000004  2100              MOVS     r1,#0
;;;127    	uint16 head = uartProtocolCB.tx.head;
000006  4d1c              LDR      r5,|L19.120|
000008  f8b5746e          LDRH     r7,[r5,#0x46e]  ; uartProtocolCB
;;;128    	uint16 end = uartProtocolCB.tx.end;
00000c  f8b54470          LDRH     r4,[r5,#0x470]  ; uartProtocolCB
;;;129    	UART_PROTOCOL_TX_CMD_FRAME *pCmdFrame = &uartProtocolCB.tx.cmdQueue[uartProtocolCB.tx.end];
000010  204d              MOVS     r0,#0x4d
000012  4360              MULS     r0,r4,r0
000014  eb050040          ADD      r0,r5,r0,LSL #1
000018  f5007028          ADD      r0,r0,#0x2a0
;;;130    	uint16 length = pCmdFrame->length;
00001c  f8b02098          LDRH     r2,[r0,#0x98]
;;;131    
;;;132    	// 发送缓冲区已满，不予接收
;;;133    	if ((end + 1) % UART_PROTOCOL_TX_QUEUE_SIZE == head)
000020  1c64              ADDS     r4,r4,#1
000022  2603              MOVS     r6,#3
000024  fbb4fcf6          UDIV     r12,r4,r6
000028  fb06441c          MLS      r4,r6,r12,r4
00002c  42bc              CMP      r4,r7
00002e  d003              BEQ      |L19.56|
;;;134    	{
;;;135    		return;
;;;136    	}
;;;137    
;;;138    	// 命令帧长度不足，清除已填充的数据，退出
;;;139    	if (UART_PROTOCOL_CMD_FRAME_LENGTH_MIN - 1 > length) // 减去"校验和"1个字节
000030  2a03              CMP      r2,#3
000032  d202              BCS      |L19.58|
;;;140    	{
;;;141    		pCmdFrame->length = 0;
000034  f8a01098          STRH     r1,[r0,#0x98]
                  |L19.56|
;;;142    
;;;143    		return;
;;;144    	}
;;;145    
;;;146    	// 队尾命令帧已满，退出
;;;147    	if (length >= UART_PROTOCOL_TX_CMD_FRAME_LENGTH_MAX)
;;;148    	{
;;;149    		return;
;;;150    	}
;;;151    
;;;152    	// 重新设置数据长度，系统在准备数据时，填充的"数据长度"可以为任意值，并且不需要添加校验码，在这里重新设置为正确的值
;;;153    	pCmdFrame->buff[UART_PROTOCOL_CMD_LENGTH_INDEX] = length - 3; // 重设数据长度
;;;154    
;;;155    	for (i = 0; i < length; i++)
;;;156    	{
;;;157    		cc ^= pCmdFrame->buff[i];
;;;158    	}
;;;159    	pCmdFrame->buff[pCmdFrame->length++] = ~cc;
;;;160    
;;;161    	uartProtocolCB.tx.end++;
;;;162    	uartProtocolCB.tx.end %= UART_PROTOCOL_TX_QUEUE_SIZE;
;;;163    
;;;164    	// pCB->tx.cmdQueue[pCB->tx.end].length = 0;   //2015.12.2修改
;;;165    }
000038  bdf0              POP      {r4-r7,pc}
                  |L19.58|
00003a  2a96              CMP      r2,#0x96              ;147
00003c  d2fc              BCS      |L19.56|
00003e  1ed4              SUBS     r4,r2,#3              ;153
000040  7104              STRB     r4,[r0,#4]            ;153
000042  e004              B        |L19.78|
                  |L19.68|
000044  1844              ADDS     r4,r0,r1              ;157
000046  78a4              LDRB     r4,[r4,#2]            ;157
000048  4063              EORS     r3,r3,r4              ;157
00004a  1c49              ADDS     r1,r1,#1              ;155
00004c  b289              UXTH     r1,r1                 ;155
                  |L19.78|
00004e  4291              CMP      r1,r2                 ;155
000050  d3f8              BCC      |L19.68|
000052  f8b01098          LDRH     r1,[r0,#0x98]         ;159
000056  43db              MVNS     r3,r3                 ;159
000058  1c4a              ADDS     r2,r1,#1              ;159
00005a  f8a02098          STRH     r2,[r0,#0x98]         ;159
00005e  4408              ADD      r0,r0,r1              ;159
000060  7083              STRB     r3,[r0,#2]            ;159
000062  f8b50470          LDRH     r0,[r5,#0x470]        ;161  ; uartProtocolCB
000066  1c40              ADDS     r0,r0,#1              ;161
000068  b280              UXTH     r0,r0                 ;161
00006a  fbb0f1f6          UDIV     r1,r0,r6              ;162
00006e  fb060011          MLS      r0,r6,r1,r0           ;162
000072  f8a50470          STRH     r0,[r5,#0x470]        ;162
000076  bdf0              POP      {r4-r7,pc}
;;;166    
                          ENDP

                  |L19.120|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOL_TxAddFrame_3A||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL_TxAddFrame_3A PROC
;;;166    
;;;167    void UART_PROTOCOL_TxAddFrame_3A(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;168    {
;;;169    	uint16 checkSum = 0;
000002  2300              MOVS     r3,#0
;;;170    	uint16 i = 0;
;;;171    	uint16 head = uartProtocolCB4.tx.head;
000004  4c2f              LDR      r4,|L20.196|
000006  f8b46470          LDRH     r6,[r4,#0x470]  ; uartProtocolCB4
;;;172    	uint16 end = uartProtocolCB4.tx.end;
00000a  f8b42472          LDRH     r2,[r4,#0x472]  ; uartProtocolCB4
;;;173    	UART_PROTOCOL4_TX_CMD_FRAME *pCmdFrame = &uartProtocolCB4.tx.cmdQueue[uartProtocolCB.tx.end];
00000e  482e              LDR      r0,|L20.200|
000010  214d              MOVS     r1,#0x4d
000012  f8b00470          LDRH     r0,[r0,#0x470]  ; uartProtocolCB
000016  4348              MULS     r0,r1,r0
000018  eb040040          ADD      r0,r4,r0,LSL #1
00001c  f20020a2          ADD      r0,r0,#0x2a2
;;;174    	uint16 length = pCmdFrame->length;
000020  f8b01098          LDRH     r1,[r0,#0x98]
;;;175    
;;;176    	// 发送缓冲区已满，不予接收
;;;177    	if ((end + 1) % UART_PROTOCOL4_TX_QUEUE_SIZE == head)
000024  1c52              ADDS     r2,r2,#1
000026  2503              MOVS     r5,#3
000028  fbb2f7f5          UDIV     r7,r2,r5
00002c  fb052217          MLS      r2,r5,r7,r2
000030  42b2              CMP      r2,r6
000032  d004              BEQ      |L20.62|
;;;178    	{
;;;179    		return;
;;;180    	}
;;;181    
;;;182    	// 命令帧长度不足，清除已填充的数据，退出
;;;183    	if (UART_PROTOCOL4_CMD_FRAME_LENGTH_MIN - 4 > length) // 减去"校验和L、校验和H、结束标识0xD、结束标识OxA"4个字节
000034  2904              CMP      r1,#4
000036  d203              BCS      |L20.64|
;;;184    	{
;;;185    		pCmdFrame->length = 0;
000038  2100              MOVS     r1,#0
00003a  f8a01098          STRH     r1,[r0,#0x98]
                  |L20.62|
;;;186    
;;;187    		return;
;;;188    	}
;;;189    
;;;190    	// 队尾命令帧已满，退出
;;;191    	if ((length >= UART_PROTOCOL4_TX_CMD_FRAME_LENGTH_MAX) || (length + 1 >= UART_PROTOCOL4_TX_CMD_FRAME_LENGTH_MAX) || (length + 2 >= UART_PROTOCOL4_TX_CMD_FRAME_LENGTH_MAX) || (length + 3 >= UART_PROTOCOL4_TX_CMD_FRAME_LENGTH_MAX))
;;;192    	{
;;;193    		return;
;;;194    	}
;;;195    
;;;196    	// 重新设置数据长度，系统在准备数据时，填充的"数据长度"可以为任意值，并且不需要添加校验码，在这里重新设置为正确的值
;;;197    	pCmdFrame->buff[UART_PROTOCOL4_CMD_LENGTH_INDEX] = length - 4; // 重设数据长度，减去"命令头、设备地址、命令字、数据长度"4个字节
;;;198    	for (i = 1; i < length; i++)
;;;199    	{
;;;200    		checkSum += pCmdFrame->buff[i];
;;;201    	}
;;;202    	pCmdFrame->buff[pCmdFrame->length++] = (checkSum & 0x00FF);		   // 低字节在前
;;;203    	pCmdFrame->buff[pCmdFrame->length++] = ((checkSum >> 8) & 0x00FF); // 高字节在后
;;;204    
;;;205    	// 结束标识
;;;206    	pCmdFrame->buff[pCmdFrame->length++] = 0x0D;
;;;207    	pCmdFrame->buff[pCmdFrame->length++] = 0x0A;
;;;208    
;;;209    	uartProtocolCB4.tx.end++;
;;;210    	uartProtocolCB4.tx.end %= UART_PROTOCOL4_TX_QUEUE_SIZE;
;;;211    }
00003e  bdf0              POP      {r4-r7,pc}
                  |L20.64|
000040  2996              CMP      r1,#0x96              ;191
000042  d2fc              BCS      |L20.62|
000044  1c4a              ADDS     r2,r1,#1              ;191
000046  2a96              CMP      r2,#0x96              ;191
000048  d2f9              BCS      |L20.62|
00004a  1c8a              ADDS     r2,r1,#2              ;191
00004c  2a96              CMP      r2,#0x96              ;191
00004e  d2f6              BCS      |L20.62|
000050  1cca              ADDS     r2,r1,#3              ;191
000052  2a96              CMP      r2,#0x96              ;191
000054  d2f3              BCS      |L20.62|
000056  1f0a              SUBS     r2,r1,#4              ;197
000058  7142              STRB     r2,[r0,#5]            ;197
00005a  2201              MOVS     r2,#1                 ;198
00005c  e005              B        |L20.106|
                  |L20.94|
00005e  1886              ADDS     r6,r0,r2              ;200
000060  78b6              LDRB     r6,[r6,#2]            ;200
000062  4433              ADD      r3,r3,r6              ;200
000064  b29b              UXTH     r3,r3                 ;200
000066  1c52              ADDS     r2,r2,#1              ;198
000068  b292              UXTH     r2,r2                 ;198
                  |L20.106|
00006a  428a              CMP      r2,r1                 ;198
00006c  d3f7              BCC      |L20.94|
00006e  f8b01098          LDRH     r1,[r0,#0x98]         ;202
000072  1c4a              ADDS     r2,r1,#1              ;202
000074  4401              ADD      r1,r1,r0              ;202
000076  f8a02098          STRH     r2,[r0,#0x98]         ;202
00007a  708b              STRB     r3,[r1,#2]            ;202
00007c  f8b01098          LDRH     r1,[r0,#0x98]         ;203
000080  0a1b              LSRS     r3,r3,#8              ;203
000082  1c4a              ADDS     r2,r1,#1              ;203
000084  4401              ADD      r1,r1,r0              ;203
000086  f8a02098          STRH     r2,[r0,#0x98]         ;203
00008a  708b              STRB     r3,[r1,#2]            ;203
00008c  f8b01098          LDRH     r1,[r0,#0x98]         ;206
000090  230d              MOVS     r3,#0xd               ;206
000092  1c4a              ADDS     r2,r1,#1              ;206
000094  4401              ADD      r1,r1,r0              ;206
000096  f8a02098          STRH     r2,[r0,#0x98]         ;206
00009a  708b              STRB     r3,[r1,#2]            ;206
00009c  f8b01098          LDRH     r1,[r0,#0x98]         ;207
0000a0  230a              MOVS     r3,#0xa               ;207
0000a2  1c4a              ADDS     r2,r1,#1              ;207
0000a4  f8a02098          STRH     r2,[r0,#0x98]         ;207
0000a8  4408              ADD      r0,r0,r1              ;207
0000aa  7083              STRB     r3,[r0,#2]            ;207
0000ac  f8b40472          LDRH     r0,[r4,#0x472]        ;209  ; uartProtocolCB4
0000b0  1c40              ADDS     r0,r0,#1              ;209
0000b2  b280              UXTH     r0,r0                 ;209
0000b4  fbb0f1f5          UDIV     r1,r0,r5              ;210
0000b8  fb050011          MLS      r0,r5,r1,r0           ;210
0000bc  f8a40472          STRH     r0,[r4,#0x472]        ;210
0000c0  bdf0              POP      {r4-r7,pc}
;;;212    
                          ENDP

0000c2  0000              DCW      0x0000
                  |L20.196|
                          DCD      uartProtocolCB4
                  |L20.200|
                          DCD      ||.bss||

                          AREA ||i.UART_PROTOCOL_TxStateProcess||, CODE, READONLY, ALIGN=2

                  UART_PROTOCOL_TxStateProcess PROC
;;;302    // 协议层发送处理过程
;;;303    void UART_PROTOCOL_TxStateProcess(void)
000000  b570              PUSH     {r4-r6,lr}
;;;304    {
;;;305    	uint16 head = uartProtocolCB.tx.head;
000002  4c14              LDR      r4,|L21.84|
000004  f8b4346e          LDRH     r3,[r4,#0x46e]  ; uartProtocolCB
;;;306    	uint16 end = uartProtocolCB.tx.end;
000008  f8b46470          LDRH     r6,[r4,#0x470]  ; uartProtocolCB
;;;307    	uint16 length = uartProtocolCB.tx.cmdQueue[head].length;
00000c  204d              MOVS     r0,#0x4d
00000e  4358              MULS     r0,r3,r0
000010  eb040040          ADD      r0,r4,r0,LSL #1
000014  4605              MOV      r5,r0
000016  f8b02338          LDRH     r2,[r0,#0x338]
;;;308    	uint8 *pCmd = uartProtocolCB.tx.cmdQueue[head].buff;
00001a  f20021a2          ADD      r1,r0,#0x2a2
;;;309    	uint16 localDeviceID = uartProtocolCB.tx.cmdQueue[head].deviceID;
00001e  f8b002a0          LDRH     r0,[r0,#0x2a0]
;;;310    
;;;311    	// 发送缓冲区为空，说明无数据
;;;312    	if (head == end)
000022  42b3              CMP      r3,r6
000024  d014              BEQ      |L21.80|
;;;313    	{
;;;314    		return;
;;;315    	}
;;;316    
;;;317    	// 发送函数没有注册直接返回
;;;318    	if (NULL == uartProtocolCB.sendDataThrowService)
000026  f8d43478          LDR      r3,[r4,#0x478]  ; uartProtocolCB
00002a  2b00              CMP      r3,#0
00002c  d010              BEQ      |L21.80|
;;;319    	{
;;;320    		return;
;;;321    	}
;;;322    
;;;323    	// 协议层有数据需要发送到驱动层
;;;324    	if (!(*uartProtocolCB.sendDataThrowService)(localDeviceID, pCmd, length))
00002e  4798              BLX      r3
000030  2800              CMP      r0,#0
000032  d00d              BEQ      |L21.80|
;;;325    	{
;;;326    		return;
;;;327    	}
;;;328    
;;;329    	// 发送环形队列更新位置
;;;330    	uartProtocolCB.tx.cmdQueue[head].length = 0;
000034  2000              MOVS     r0,#0
000036  f8a50338          STRH     r0,[r5,#0x338]
;;;331    	uartProtocolCB.tx.head++;
00003a  f8b4046e          LDRH     r0,[r4,#0x46e]  ; uartProtocolCB
00003e  1c40              ADDS     r0,r0,#1
000040  b280              UXTH     r0,r0
;;;332    	uartProtocolCB.tx.head %= UART_PROTOCOL_TX_QUEUE_SIZE;
000042  2103              MOVS     r1,#3
000044  fbb0f2f1          UDIV     r2,r0,r1
000048  fb010012          MLS      r0,r1,r2,r0
00004c  f8a4046e          STRH     r0,[r4,#0x46e]
                  |L21.80|
;;;333    }
000050  bd70              POP      {r4-r6,pc}
;;;334    
                          ENDP

000052  0000              DCW      0x0000
                  |L21.84|
                          DCD      ||.bss||

                          AREA ||i.uartProtocol_SendOnePacket||, CODE, READONLY, ALIGN=2

                  uartProtocol_SendOnePacket PROC
;;;555    
;;;556    void uartProtocol_SendOnePacket(uint32 flashAddr, uint32 addr)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;557    {
000004  b0a6              SUB      sp,sp,#0x98
000006  4606              MOV      r6,r0
000008  460d              MOV      r5,r1
;;;558    	uint8 addr1, addr2, addr3, addr4;
;;;559    	uint8 appUpdateOnePacket[150] = {0};
00000a  2198              MOVS     r1,#0x98
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       __aeabi_memclr4
;;;560    	uint8 appUpdateOnePacket_i = 0;
000012  2400              MOVS     r4,#0
;;;561    	addr1 = (addr & 0xFF000000) >> 24;
000014  0e2f              LSRS     r7,r5,#24
;;;562    	addr2 = (addr & 0x00FF0000) >> 16;
000016  f3c54807          UBFX     r8,r5,#16,#8
;;;563    	addr3 = (addr & 0x0000FF00) >> 8;
00001a  f3c52907          UBFX     r9,r5,#8,#8
;;;564    	addr4 = (addr & 0x000000FF);
00001e  f0050aff          AND      r10,r5,#0xff
;;;565    	SPI_FLASH_ReadArray(appUpdateOnePacket, flashAddr + addr, 128); // 工具读取128字节
000022  1971              ADDS     r1,r6,r5
000024  2280              MOVS     r2,#0x80
000026  4668              MOV      r0,sp
000028  f7fffffe          BL       SPI_FLASH_ReadArray
;;;566    
;;;567    	UART_PROTOCOL_TxAddData(UART_PROTOCOL_CMD_HEAD); // 头
00002c  2055              MOVS     r0,#0x55
00002e  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;568    	if (dut_info.appUpFlag)
000032  4815              LDR      r0,|L22.136|
000034  f8901025          LDRB     r1,[r0,#0x25]  ; dut_info
000038  b119              CBZ      r1,|L22.66|
;;;569    	{
;;;570    		UART_PROTOCOL_TxAddData(UART_CMD_UP_APP_UP); // 命令0x06
00003a  2006              MOVS     r0,#6
00003c  f7fffffe          BL       UART_PROTOCOL_TxAddData
000040  e005              B        |L22.78|
                  |L22.66|
;;;571    	}
;;;572    	else if (dut_info.uiUpFlag)
000042  f8900027          LDRB     r0,[r0,#0x27]  ; dut_info
000046  b110              CBZ      r0,|L22.78|
;;;573    	{
;;;574    		UART_PROTOCOL_TxAddData(UART_CMD_DUT_UI_DATA_WRITE); // 命令0x14
000048  2014              MOVS     r0,#0x14
00004a  f7fffffe          BL       UART_PROTOCOL_TxAddData
                  |L22.78|
;;;575    	}
;;;576    	UART_PROTOCOL_TxAddData(0x00);													   // 长度暂时为0
00004e  2000              MOVS     r0,#0
000050  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;577    	UART_PROTOCOL_TxAddData(addr1);													   // 添加地址
000054  4638              MOV      r0,r7
000056  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;578    	UART_PROTOCOL_TxAddData(addr2);													   // 添加地址
00005a  4640              MOV      r0,r8
00005c  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;579    	UART_PROTOCOL_TxAddData(addr3);													   // 添加地址
000060  4648              MOV      r0,r9
000062  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;580    	UART_PROTOCOL_TxAddData(addr4);													   // 添加地址
000066  4650              MOV      r0,r10
000068  f7fffffe          BL       UART_PROTOCOL_TxAddData
00006c  466d              MOV      r5,sp                 ;559
                  |L22.110|
;;;581    	for (appUpdateOnePacket_i = 0; appUpdateOnePacket_i < 128; appUpdateOnePacket_i++) // 添加数据
;;;582    	{
;;;583    		UART_PROTOCOL_TxAddData(appUpdateOnePacket[appUpdateOnePacket_i]);
00006e  5d28              LDRB     r0,[r5,r4]
000070  f7fffffe          BL       UART_PROTOCOL_TxAddData
000074  1c64              ADDS     r4,r4,#1              ;581
000076  b2e4              UXTB     r4,r4                 ;581
000078  2c80              CMP      r4,#0x80              ;581
00007a  d3f8              BCC      |L22.110|
;;;584    	}
;;;585    	UART_PROTOCOL_TxAddFrame(); // 调整帧格式,修改长度和添加校验
00007c  f7fffffe          BL       UART_PROTOCOL_TxAddFrame
;;;586    }
000080  b026              ADD      sp,sp,#0x98
000082  e8bd87f0          POP      {r4-r10,pc}
;;;587    
                          ENDP

000086  0000              DCW      0x0000
                  |L22.136|
                          DCD      dut_info

                          AREA ||i.uartProtocol_SendOnePacket_Hex||, CODE, READONLY, ALIGN=2

                  uartProtocol_SendOnePacket_Hex PROC
;;;587    
;;;588    void uartProtocol_SendOnePacket_Hex(uint32 flashAddr)
000000  b530              PUSH     {r4,r5,lr}
;;;589    {
000002  b0a7              SUB      sp,sp,#0x9c
000004  4605              MOV      r5,r0
;;;590    	uint8 appUpdateOnePacket[150] = {0};
000006  2198              MOVS     r1,#0x98
000008  a801              ADD      r0,sp,#4
00000a  f7fffffe          BL       __aeabi_memclr4
;;;591    	uint8 appUpdateOnePacket_i = 0;															 // app起始地址
00000e  2400              MOVS     r4,#0
;;;592    	SPI_FLASH_ReadArray(appUpdateOnePacket, flashAddr + dut_info.currentAppSize * 116, 116); // 工具读取 4+112 个字节
000010  491b              LDR      r1,|L23.128|
000012  a801              ADD      r0,sp,#4
000014  6d89              LDR      r1,[r1,#0x58]  ; dut_info
000016  eb010241          ADD      r2,r1,r1,LSL #1
00001a  ebc21141          RSB      r1,r2,r1,LSL #5
00001e  eb050181          ADD      r1,r5,r1,LSL #2
000022  2274              MOVS     r2,#0x74
000024  f7fffffe          BL       SPI_FLASH_ReadArray
;;;593    	UART_PROTOCOL_TxAddData(UART_PROTOCOL_CMD_HEAD);										 // 添加命令头;//头
000028  2055              MOVS     r0,#0x55
00002a  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;594    	UART_PROTOCOL_TxAddData(UART_CMD_DUT_APP_WRITE_FLASH);									 // 命令
00002e  2026              MOVS     r0,#0x26
000030  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;595    	UART_PROTOCOL_TxAddData(0x00);															 // 添加临时数据长度
000034  2000              MOVS     r0,#0
000036  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;596    	UART_PROTOCOL_TxAddData(0);																 // 添加是否加密
00003a  2000              MOVS     r0,#0
00003c  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;597    	UART_PROTOCOL_TxAddData(0);																 // 添加密钥
000040  2000              MOVS     r0,#0
000042  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;598    	UART_PROTOCOL_TxAddData(appUpdateOnePacket[0]);											 // 添加地址
000046  f89d0004          LDRB     r0,[sp,#4]
00004a  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;599    	UART_PROTOCOL_TxAddData(appUpdateOnePacket[1]);											 // 添加地址
00004e  f89d0005          LDRB     r0,[sp,#5]
000052  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;600    	UART_PROTOCOL_TxAddData(appUpdateOnePacket[2]);											 // 添加地址
000056  f89d0006          LDRB     r0,[sp,#6]
00005a  f7fffffe          BL       UART_PROTOCOL_TxAddData
;;;601    	UART_PROTOCOL_TxAddData(appUpdateOnePacket[3]);											 // 添加地址
00005e  f89d0007          LDRB     r0,[sp,#7]
000062  f7fffffe          BL       UART_PROTOCOL_TxAddData
000066  ad01              ADD      r5,sp,#4              ;590
                  |L23.104|
;;;602    
;;;603    	for (appUpdateOnePacket_i = 0; appUpdateOnePacket_i < 112; appUpdateOnePacket_i++) // 添加数据
;;;604    	{
;;;605    		UART_PROTOCOL_TxAddData(appUpdateOnePacket[appUpdateOnePacket_i + 4]);
000068  1928              ADDS     r0,r5,r4
00006a  7900              LDRB     r0,[r0,#4]
00006c  f7fffffe          BL       UART_PROTOCOL_TxAddData
000070  1c64              ADDS     r4,r4,#1              ;603
000072  b2e4              UXTB     r4,r4                 ;603
000074  2c70              CMP      r4,#0x70              ;603
000076  d3f7              BCC      |L23.104|
;;;606    	}
;;;607    	UART_PROTOCOL_TxAddFrame(); // 调整帧格式,修改长度和添加校验
000078  f7fffffe          BL       UART_PROTOCOL_TxAddFrame
;;;608    }
00007c  b027              ADD      sp,sp,#0x9c
00007e  bd30              POP      {r4,r5,pc}
;;;609    
                          ENDP

                  |L23.128|
                          DCD      dut_info

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  uartProtocolCB
                          %        1152

;*** Start embedded assembler ***

#line 1 "User\\UartProtocol.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_UartProtocol_c_4a880db2____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___14_UartProtocol_c_4a880db2____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_UartProtocol_c_4a880db2____REVSH|
#line 128
|__asm___14_UartProtocol_c_4a880db2____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
