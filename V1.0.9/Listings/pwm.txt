; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\pwm.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\pwm.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -I.\User\qrencode -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.3\Device\Include -D__MICROLIB -D__UVISION_VERSION=539 -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\pwm.crf User\pwm.c]
                          THUMB

                          AREA ||i.PWM_OUT1_Init||, CODE, READONLY, ALIGN=2

                  PWM_OUT1_Init PROC
;;;8      *********************************************************/
;;;9      void PWM_OUT1_Init(void)
000000  b530              PUSH     {r4,r5,lr}
;;;10     {	
000002  b087              SUB      sp,sp,#0x1c
;;;11     	timer_oc_parameter_struct timer_ocintpara;
;;;12     	timer_parameter_struct timer_initpara;
;;;13     
;;;14     	// 打开APB总线上的GPIOA时钟
;;;15     	rcu_periph_clock_enable(RCU_GPIOA);
000004  f2406002          MOV      r0,#0x602
000008  f7fffffe          BL       rcu_periph_clock_enable
;;;16     	rcu_periph_clock_enable(RCU_AF);
00000c  f44f60c0          MOV      r0,#0x600
000010  f7fffffe          BL       rcu_periph_clock_enable
;;;17     
;;;18     	// 设置GPIOA上的TIM0 1通道对应引脚PA.8为第二功能推挽输出 
;;;19     	gpio_init(GPIOA, GPIO_MODE_AF_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_0);
000014  2301              MOVS     r3,#1
000016  2203              MOVS     r2,#3
000018  2118              MOVS     r1,#0x18
00001a  4825              LDR      r0,|L1.176|
00001c  f7fffffe          BL       gpio_init
;;;20     
;;;21     	// 打开TIM0时钟
;;;22     	rcu_periph_clock_enable(RCU_TIMER4);
000020  f2407003          MOV      r0,#0x703
000024  f7fffffe          BL       rcu_periph_clock_enable
;;;23     
;;;24     	timer_initpara.period            = 100-1;
000028  2063              MOVS     r0,#0x63
00002a  9002              STR      r0,[sp,#8]
;;;25     	timer_initpara.prescaler         = 72-1;
00002c  2047              MOVS     r0,#0x47
00002e  f8ad0000          STRH     r0,[sp,#0]
;;;26     	timer_initpara.clockdivision     = TIMER_CKDIV_DIV1;
000032  2400              MOVS     r4,#0
000034  f8ad400c          STRH     r4,[sp,#0xc]
;;;27     	timer_initpara.counterdirection  = TIMER_COUNTER_UP;
000038  f8ad4004          STRH     r4,[sp,#4]
;;;28     	timer_initpara.alignedmode       = TIMER_COUNTER_EDGE;
00003c  f8ad4002          STRH     r4,[sp,#2]
;;;29     	timer_initpara.repetitioncounter = 0;
000040  f88d400e          STRB     r4,[sp,#0xe]
;;;30     	timer_init(TIMER4,&timer_initpara);
000044  4d1b              LDR      r5,|L1.180|
000046  4669              MOV      r1,sp
000048  4628              MOV      r0,r5
00004a  f7fffffe          BL       timer_init
;;;31     
;;;32     	timer_ocintpara.outputstate  = TIMER_CCX_ENABLE;
00004e  2101              MOVS     r1,#1
000050  f8ad1010          STRH     r1,[sp,#0x10]
;;;33     	timer_ocintpara.outputnstate = TIMER_CCXN_DISABLE;
000054  f8ad4012          STRH     r4,[sp,#0x12]
;;;34     	timer_ocintpara.ocpolarity   = TIMER_OC_POLARITY_HIGH;
000058  f8ad4014          STRH     r4,[sp,#0x14]
;;;35     	timer_ocintpara.ocnpolarity  = TIMER_OCN_POLARITY_HIGH;
00005c  f8ad4016          STRH     r4,[sp,#0x16]
;;;36     	timer_ocintpara.ocidlestate  = TIMER_OC_IDLE_STATE_LOW;
000060  f8ad4018          STRH     r4,[sp,#0x18]
;;;37     	timer_ocintpara.ocnidlestate = TIMER_OCN_IDLE_STATE_LOW;
000064  f8ad401a          STRH     r4,[sp,#0x1a]
;;;38     	timer_channel_output_config(TIMER4,TIMER_CH_0,&timer_ocintpara);
000068  aa04              ADD      r2,sp,#0x10
00006a  2100              MOVS     r1,#0
00006c  4628              MOV      r0,r5
00006e  f7fffffe          BL       timer_channel_output_config
;;;39     
;;;40     	timer_channel_output_mode_config(TIMER4,TIMER_CH_0,TIMER_OC_MODE_PWM0);
000072  2260              MOVS     r2,#0x60
000074  2100              MOVS     r1,#0
000076  4628              MOV      r0,r5
000078  f7fffffe          BL       timer_channel_output_mode_config
;;;41     	timer_channel_output_pulse_value_config(TIMER4, TIMER_CH_0, 0);      //占空比为0
00007c  2200              MOVS     r2,#0
00007e  4611              MOV      r1,r2
000080  4628              MOV      r0,r5
000082  f7fffffe          BL       timer_channel_output_pulse_value_config
;;;42     	timer_channel_output_shadow_config(TIMER4,TIMER_CH_0,TIMER_OC_SHADOW_DISABLE);
000086  2200              MOVS     r2,#0
000088  4611              MOV      r1,r2
00008a  4628              MOV      r0,r5
00008c  f7fffffe          BL       timer_channel_output_shadow_config
;;;43     
;;;44     	timer_auto_reload_shadow_enable(TIMER4);
000090  4628              MOV      r0,r5
000092  f7fffffe          BL       timer_auto_reload_shadow_enable
;;;45     	timer_enable(TIMER4);
000096  4628              MOV      r0,r5
000098  f7fffffe          BL       timer_enable
;;;46     	timer_primary_output_config(TIMER4, ENABLE);
00009c  2101              MOVS     r1,#1
00009e  4628              MOV      r0,r5
0000a0  f7fffffe          BL       timer_primary_output_config
;;;47     
;;;48     	// 初始化关掉背光
;;;49     	PWM_OUT1_Start(PWM_OUT1_LEVEL_OFF);
0000a4  2000              MOVS     r0,#0
0000a6  f7fffffe          BL       PWM_OUT1_Start
;;;50     
;;;51     }
0000aa  b007              ADD      sp,sp,#0x1c
0000ac  bd30              POP      {r4,r5,pc}
;;;52     
                          ENDP

0000ae  0000              DCW      0x0000
                  |L1.176|
                          DCD      0x40010800
                  |L1.180|
                          DCD      0x40000c00

                          AREA ||i.PWM_OUT1_Start||, CODE, READONLY, ALIGN=1

                  PWM_OUT1_Start PROC
;;;53     // 启动定时器，并指定工作模式
;;;54     void PWM_OUT1_Start(PWM_OUT1_LEVEL_E level)
000000  4770              BX       lr
;;;55     {
;;;56     //	if (level >= PWM_OUT1_LEVEL_AUTO)
;;;57     //	{
;;;58     //		return;
;;;59     //	}
;;;60     
;;;61     //	// 新模式与当前工作中的模式相同，不予执行
;;;62     //	if (pwmout1CB.level == level)
;;;63     //	{
;;;64     //		return;
;;;65     //	}
;;;66     //	pwmout1CB.level = level;
;;;67     
;;;68     //	switch (level)
;;;69     //	{
;;;70     //		case PWM_OUT1_LEVEL_OFF:
;;;71     //			PWM_OUT1_OFF();
;;;72     //			break;
;;;73     
;;;74     //		case PWM_OUT1_LEVEL_ON:
;;;75     //			PWM_OUT1_ON();
;;;76     //			break;
;;;77     
;;;78     //	/*	case PWM_OUT1_LEVEL_5_100:
;;;79     //			PWM_OUT1_PWM(5);
;;;80     //			break;
;;;81     
;;;82     //		case PWM_OUT1_LEVEL_10_100:
;;;83     //			PWM_OUT1_PWM(10);
;;;84     //			break;
;;;85     
;;;86     //		case PWM_OUT1_LEVEL_15_100:
;;;87     //			PWM_OUT1_PWM(15);
;;;88     //			break;
;;;89     //*/
;;;90     //		case PWM_OUT1_LEVEL_20_100:
;;;91     //			PWM_OUT1_PWM(20);
;;;92     //			break;
;;;93     ///*
;;;94     //		case PWM_OUT1_LEVEL_25_100:
;;;95     //			PWM_OUT1_PWM(25);
;;;96     //			break;
;;;97     
;;;98     //		case PWM_OUT1_LEVEL_30_100:
;;;99     //			PWM_OUT1_PWM(30);
;;;100    //			break;
;;;101    
;;;102    //		case PWM_OUT1_LEVEL_35_100:
;;;103    //			PWM_OUT1_PWM(35);
;;;104    //			break;
;;;105    //*/
;;;106    //		case PWM_OUT1_LEVEL_40_100:
;;;107    //			PWM_OUT1_PWM(40);
;;;108    //			break;
;;;109    ///*
;;;110    //		case PWM_OUT1_LEVEL_45_100:
;;;111    //			PWM_OUT1_PWM(45);
;;;112    //			break;
;;;113    
;;;114    //		case PWM_OUT1_LEVEL_50_100:
;;;115    //			PWM_OUT1_PWM(50);
;;;116    //			break;
;;;117    
;;;118    //		case PWM_OUT1_LEVEL_55_100:
;;;119    //			PWM_OUT1_PWM(55);
;;;120    //			break;
;;;121    //*/
;;;122    //		case PWM_OUT1_LEVEL_60_100:
;;;123    //			PWM_OUT1_PWM(60);
;;;124    //			break;
;;;125    ///*
;;;126    //		case PWM_OUT1_LEVEL_65_100:
;;;127    //			PWM_OUT1_PWM(65);
;;;128    //			break;
;;;129    
;;;130    //		case PWM_OUT1_LEVEL_70_100:
;;;131    //			PWM_OUT1_PWM(70);
;;;132    //			break;
;;;133    
;;;134    //		case PWM_OUT1_LEVEL_75_100:
;;;135    //			PWM_OUT1_PWM(75);
;;;136    //			break;
;;;137    //*/
;;;138    //		case PWM_OUT1_LEVEL_80_100:
;;;139    //			PWM_OUT1_PWM(80);
;;;140    //			break;
;;;141    ///*
;;;142    //		case PWM_OUT1_LEVEL_85_100:
;;;143    //			PWM_OUT1_PWM(85);
;;;144    //			break;
;;;145    
;;;146    //		case PWM_OUT1_LEVEL_90_100:
;;;147    //			PWM_OUT1_PWM(90);
;;;148    //			break;
;;;149    
;;;150    //		case PWM_OUT1_LEVEL_95_100:
;;;151    //			PWM_OUT1_PWM(95);
;;;152    //			break;
;;;153    //*/			
;;;154    //		default:
;;;155    //			PWM_OUT1_OFF();
;;;156    //			break;
;;;157    //	}
;;;158    }
                          ENDP


                          AREA ||.data||, DATA, ALIGN=1

                  pwmout1CB
                          DCDU     0x00000000

;*** Start embedded assembler ***

#line 1 "User\\pwm.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_pwm_c_e2ceafc9____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___5_pwm_c_e2ceafc9____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_pwm_c_e2ceafc9____REVSH|
#line 128
|__asm___5_pwm_c_e2ceafc9____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
