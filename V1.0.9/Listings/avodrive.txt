; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\avodrive.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\output\avodrive.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I.\User -I.\Libraries\inc -I.\Libraries\src -I.\CMSIS -I.\Startup -I.\User\qrencode -ID:\Keil_v5\Packs\GigaDevice\GD32F10x_DFP\2.0.3\Device\Include -D__MICROLIB -D__UVISION_VERSION=539 -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER -DGD32F10X_XD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\avodrive.crf User\AvoDrive.c]
                          THUMB

                          AREA ||i.AVO_UART_AddTxArray||, CODE, READONLY, ALIGN=2

                  AVO_UART_AddTxArray PROC
;;;301    // 向发送缓冲区中添加一条待发送序列
;;;302    BOOL AVO_UART_AddTxArray(uint16 id, uint8 *pArray, uint16 length)
000000  b570              PUSH     {r4-r6,lr}
;;;303    {
;;;304    	uint16 i;
;;;305    	uint16 head = AVOUartCB.tx.head;
000002  4c1b              LDR      r4,|L1.112|
000004  f8b454d4          LDRH     r5,[r4,#0x4d4]  ; AVOUartCB
;;;306    	uint16 end = AVOUartCB.tx.end;
000008  f8b434d6          LDRH     r3,[r4,#0x4d6]  ; AVOUartCB
;;;307    
;;;308    	// 参数检验
;;;309    	if ((NULL == pArray) || (0 == length))
00000c  2900              CMP      r1,#0
00000e  d007              BEQ      |L1.32|
000010  b132              CBZ      r2,|L1.32|
;;;310    	{
;;;311    		return FALSE;
;;;312    	}
;;;313    
;;;314    	// 发送缓冲区已满，不予接收
;;;315    	if ((end + 1) % AVO_UART_DRIVE_TX_QUEUE_SIZE == head)
000012  1c5e              ADDS     r6,r3,#1
000014  f0060607          AND      r6,r6,#7
000018  42ae              CMP      r6,r5
00001a  d103              BNE      |L1.36|
;;;316    	{
;;;317    		return FALSE;
00001c  2000              MOVS     r0,#0
;;;318    	}
;;;319    
;;;320    	AVOUartCB.tx.cmdQueue[end].deviceID = id;
;;;321    	for (i = 0; i < length; i++)
;;;322    	{
;;;323    		AVOUartCB.tx.cmdQueue[end].buff[i] = *pArray++;
;;;324    	}
;;;325    	AVOUartCB.tx.cmdQueue[end].length = length;
;;;326    
;;;327    	// 发送环形队列更新位置
;;;328    	AVOUartCB.tx.end++;
;;;329    	AVOUartCB.tx.end %= AVO_UART_DRIVE_TX_QUEUE_SIZE;
;;;330    	AVOUartCB.tx.cmdQueue[AVOUartCB.tx.end].length = 0;
;;;331    
;;;332    	return TRUE;
;;;333    }
00001e  bd70              POP      {r4-r6,pc}
                  |L1.32|
000020  2000              MOVS     r0,#0                 ;311
000022  bd70              POP      {r4-r6,pc}
                  |L1.36|
000024  254d              MOVS     r5,#0x4d              ;320
000026  436b              MULS     r3,r5,r3              ;320
000028  eb040343          ADD      r3,r4,r3,LSL #1       ;320
00002c  8098              STRH     r0,[r3,#4]            ;320
00002e  2000              MOVS     r0,#0                 ;321
000030  e005              B        |L1.62|
                  |L1.50|
000032  181e              ADDS     r6,r3,r0              ;323
000034  f8115b01          LDRB     r5,[r1],#1            ;323
000038  71b5              STRB     r5,[r6,#6]            ;323
00003a  1c40              ADDS     r0,r0,#1              ;321
00003c  b280              UXTH     r0,r0                 ;321
                  |L1.62|
00003e  4290              CMP      r0,r2                 ;321
000040  d3f7              BCC      |L1.50|
000042  f8a3209c          STRH     r2,[r3,#0x9c]         ;325
000046  f20444d6          ADD      r4,r4,#0x4d6          ;328
00004a  8820              LDRH     r0,[r4,#0]            ;328  ; AVOUartCB
00004c  1c40              ADDS     r0,r0,#1              ;328
00004e  8020              STRH     r0,[r4,#0]            ;328
000050  8820              LDRH     r0,[r4,#0]            ;329  ; AVOUartCB
000052  f0000007          AND      r0,r0,#7              ;329
000056  8020              STRH     r0,[r4,#0]            ;329
000058  8820              LDRH     r0,[r4,#0]            ;330  ; AVOUartCB
00005a  2100              MOVS     r1,#0                 ;330
00005c  224d              MOVS     r2,#0x4d              ;330
00005e  f2a444d6          SUB      r4,r4,#0x4d6          ;330
000062  4350              MULS     r0,r2,r0              ;330
000064  eb040040          ADD      r0,r4,r0,LSL #1       ;330
000068  f8a0109c          STRH     r1,[r0,#0x9c]         ;330
00006c  2001              MOVS     r0,#1                 ;332
00006e  bd70              POP      {r4-r6,pc}
                          ENDP

                  |L1.112|
                          DCD      ||area_number.14||

                          AREA ||i.AVO_UART_BC_SendData||, CODE, READONLY, ALIGN=2

                  AVO_UART_BC_SendData PROC
;;;174    // 阻塞发送一个字节数据
;;;175    void AVO_UART_BC_SendData(uint8 data)
000000  b510              PUSH     {r4,lr}
;;;176    {
;;;177    	// 防止丢失第一个字节(清除空标志位,务必加)
;;;178    //	usart_flag_get(AVO_UART_TYPE_DEF, USART_FLAG_TC);
;;;179    
;;;180    	// 填充数据
;;;181    	usart_data_transmit(AVO_UART_TYPE_DEF, data);
000002  4c06              LDR      r4,|L2.28|
000004  4601              MOV      r1,r0
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       usart_data_transmit
                  |L2.12|
;;;182    
;;;183    	// 未发送完，持续等待
;;;184    	while (usart_flag_get(AVO_UART_TYPE_DEF, USART_FLAG_TC) != SET);
00000c  2106              MOVS     r1,#6
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       usart_flag_get
000014  2801              CMP      r0,#1
000016  d1f9              BNE      |L2.12|
;;;185    }
000018  bd10              POP      {r4,pc}
;;;186    
                          ENDP

00001a  0000              DCW      0x0000
                  |L2.28|
                          DCD      0x40013800

                          AREA ||i.AVO_UART_DataStructureInit||, CODE, READONLY, ALIGN=2

                  AVO_UART_DataStructureInit PROC
;;;64     // 数据结构初始化
;;;65     void AVO_UART_DataStructureInit(AVO_UART_CB *pCB)
000000  2800              CMP      r0,#0
;;;66     {
000002  d016              BEQ      |L3.50|
;;;67     	uint16 i;
;;;68     
;;;69     	// 参数合法性检验
;;;70     	if (NULL == pCB)
;;;71     	{
;;;72     		return;
;;;73     	}
;;;74     
;;;75     	pCB->tx.txBusy = FALSE;
000004  2200              MOVS     r2,#0
000006  f88024da          STRB     r2,[r0,#0x4da]
;;;76     	pCB->tx.index = 0;
00000a  f8a024d8          STRH     r2,[r0,#0x4d8]
;;;77     	pCB->tx.head = 0;
00000e  f8a024d4          STRH     r2,[r0,#0x4d4]
;;;78     	pCB->tx.end = 0;
000012  f8a024d6          STRH     r2,[r0,#0x4d6]
;;;79     	for (i = 0; i < AVO_UART_DRIVE_TX_QUEUE_SIZE; i++)
000016  2100              MOVS     r1,#0
                  |L3.24|
;;;80     	{
;;;81     		pCB->tx.cmdQueue[i].length = 0;
000018  234d              MOVS     r3,#0x4d
00001a  434b              MULS     r3,r1,r3
00001c  eb000343          ADD      r3,r0,r3,LSL #1
000020  f8a3209c          STRH     r2,[r3,#0x9c]
000024  1c49              ADDS     r1,r1,#1              ;79
000026  b289              UXTH     r1,r1                 ;79
000028  2908              CMP      r1,#8                 ;79
00002a  d3f5              BCC      |L3.24|
;;;82     	}
;;;83     
;;;84     	AVOUartCB.rcvBleMacOK = FALSE;
00002c  4801              LDR      r0,|L3.52|
00002e  f8802524          STRB     r2,[r0,#0x524]
                  |L3.50|
;;;85     }
000032  4770              BX       lr
;;;86     
                          ENDP

                  |L3.52|
                          DCD      ||area_number.14||

                          AREA ||i.AVO_UART_HwInit||, CODE, READONLY, ALIGN=2

                  AVO_UART_HwInit PROC
;;;33     // UART初始化
;;;34     void AVO_UART_HwInit(uint32 baud)
000000  b570              PUSH     {r4-r6,lr}
;;;35     {
000002  4605              MOV      r5,r0
;;;36     	// 打开时钟
;;;37     	rcu_periph_clock_enable(RCU_GPIOA);
000004  f2406002          MOV      r0,#0x602
000008  f7fffffe          BL       rcu_periph_clock_enable
;;;38     	gpio_init(GPIOA, GPIO_MODE_AF_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_9); // TX
00000c  4c22              LDR      r4,|L4.152|
00000e  f44f7300          MOV      r3,#0x200
000012  2203              MOVS     r2,#3
000014  2118              MOVS     r1,#0x18
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       gpio_init
;;;39       
;;;40     	gpio_init(GPIOA, GPIO_MODE_IPU, GPIO_OSPEED_50MHZ, GPIO_PIN_10);  //RX
00001c  1523              ASRS     r3,r4,#20
00001e  2203              MOVS     r2,#3
000020  2148              MOVS     r1,#0x48
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       gpio_init
;;;41     
;;;42     	// UART时钟配置
;;;43     	rcu_periph_clock_enable(RCU_USART0);
000028  f240600e          MOV      r0,#0x60e
00002c  f7fffffe          BL       rcu_periph_clock_enable
;;;44     	usart_deinit(AVO_UART_TYPE_DEF); // 复位串口
000030  4c1a              LDR      r4,|L4.156|
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       usart_deinit
;;;45     
;;;46     	// 串口配置
;;;47     	usart_baudrate_set(AVO_UART_TYPE_DEF, baud);						  // 波特率
000038  4629              MOV      r1,r5
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       usart_baudrate_set
;;;48     	usart_word_length_set(AVO_UART_TYPE_DEF, USART_WL_8BIT);			  // 8位数据位
000040  2100              MOVS     r1,#0
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       usart_word_length_set
;;;49     	usart_stop_bit_set(AVO_UART_TYPE_DEF, USART_STB_1BIT);				  // 一个停止位
000048  2100              MOVS     r1,#0
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       usart_stop_bit_set
;;;50     	usart_parity_config(AVO_UART_TYPE_DEF, USART_PM_NONE);				  // 无奇偶校验
000050  2100              MOVS     r1,#0
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       usart_parity_config
;;;51     	usart_hardware_flow_rts_config(AVO_UART_TYPE_DEF, USART_RTS_DISABLE); // 无硬件数据流控制
000058  2100              MOVS     r1,#0
00005a  4620              MOV      r0,r4
00005c  f7fffffe          BL       usart_hardware_flow_rts_config
;;;52     	usart_hardware_flow_cts_config(AVO_UART_TYPE_DEF, USART_CTS_DISABLE);
000060  2100              MOVS     r1,#0
000062  4620              MOV      r0,r4
000064  f7fffffe          BL       usart_hardware_flow_cts_config
;;;53     	usart_transmit_config(AVO_UART_TYPE_DEF, USART_TRANSMIT_ENABLE); // 使能发射
000068  2108              MOVS     r1,#8
00006a  4620              MOV      r0,r4
00006c  f7fffffe          BL       usart_transmit_config
;;;54     	usart_receive_config(AVO_UART_TYPE_DEF, USART_RECEIVE_ENABLE);	 // 使能接收
000070  2104              MOVS     r1,#4
000072  4620              MOV      r0,r4
000074  f7fffffe          BL       usart_receive_config
;;;55     
;;;56     	// 中断配置
;;;57     	nvic_irq_enable(AVO_UART_IRQn_DEF, 2, 1);
000078  2201              MOVS     r2,#1
00007a  2102              MOVS     r1,#2
00007c  2025              MOVS     r0,#0x25
00007e  f7fffffe          BL       nvic_irq_enable
;;;58     
;;;59     	usart_interrupt_enable(AVO_UART_TYPE_DEF, USART_INT_RBNE); // 开启中断
000082  f2403105          MOV      r1,#0x305
000086  4620              MOV      r0,r4
000088  f7fffffe          BL       usart_interrupt_enable
;;;60     
;;;61     	usart_enable(AVO_UART_TYPE_DEF); // 使能串口
00008c  4620              MOV      r0,r4
00008e  e8bd4070          POP      {r4-r6,lr}
000092  f7ffbffe          B.W      usart_enable
;;;62     }
;;;63     
                          ENDP

000096  0000              DCW      0x0000
                  |L4.152|
                          DCD      0x40010800
                  |L4.156|
                          DCD      0x40013800

                          AREA ||i.AVO_UART_IR_StartSendData||, CODE, READONLY, ALIGN=2

                  AVO_UART_IR_StartSendData PROC
;;;161    // 启动中断字节发送
;;;162    void AVO_UART_IR_StartSendData(uint8 data)
000000  b510              PUSH     {r4,lr}
;;;163    {
;;;164    	// 先读SR，再填充DR会把TC标志清掉
;;;165    //	usart_flag_get(AVO_UART_TYPE_DEF, USART_FLAG_TC);
;;;166    
;;;167    	// 发送一个字节
;;;168    	usart_data_transmit(AVO_UART_TYPE_DEF, data);
000002  4c06              LDR      r4,|L5.28|
000004  4601              MOV      r1,r0
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       usart_data_transmit
;;;169    
;;;170    	// 打开发送完成中断
;;;171    	usart_interrupt_enable(AVO_UART_TYPE_DEF, USART_INT_TC);
00000c  4620              MOV      r0,r4
00000e  e8bd4010          POP      {r4,lr}
000012  f2403106          MOV      r1,#0x306
000016  f7ffbffe          B.W      usart_interrupt_enable
;;;172    }
;;;173    
                          ENDP

00001a  0000              DCW      0x0000
                  |L5.28|
                          DCD      0x40013800

                          AREA ||i.AVO_UART_Init||, CODE, READONLY, ALIGN=2

                  AVO_UART_Init PROC
;;;278    // UART初始化
;;;279    void AVO_UART_Init(void)
000000  b510              PUSH     {r4,lr}
;;;280    {
;;;281    	// AVO串口初始化
;;;282    	AVO_UART_HwInit(AVO_UART_BAUD_RATE);
000002  f44f5016          MOV      r0,#0x2580
000006  f7fffffe          BL       AVO_UART_HwInit
;;;283    
;;;284    	// AVO数据结构初始化
;;;285    	AVO_UART_DataStructureInit(&AVOUartCB);
00000a  e8bd4010          POP      {r4,lr}
00000e  4801              LDR      r0,|L6.20|
000010  f7ffbffe          B.W      AVO_UART_DataStructureInit
;;;286    }
;;;287    
                          ENDP

                  |L6.20|
                          DCD      ||area_number.14||

                          AREA ||i.AVO_UART_Process||, CODE, READONLY, ALIGN=2

                  AVO_UART_Process PROC
;;;288    // UART模块处理入口
;;;289    void AVO_UART_Process(void)
000000  4801              LDR      r0,|L7.8|
;;;290    {
;;;291    	// 发送处理
;;;292    	AVO_UART_TxProcess(&AVOUartCB);
000002  f7ffbffe          B.W      AVO_UART_TxProcess
;;;293    }
;;;294    
                          ENDP

000006  0000              DCW      0x0000
                  |L7.8|
                          DCD      ||area_number.14||

                          AREA ||i.AVO_UART_RegisterDataSendService||, CODE, READONLY, ALIGN=2

                  AVO_UART_RegisterDataSendService PROC
;;;295    // 注册数据抛出接口服务
;;;296    void AVO_UART_RegisterDataSendService(void (*service)(uint16 id, uint8 *pData, uint16 length))
000000  4901              LDR      r1,|L8.8|
;;;297    {
;;;298    	AVOUartCB.receiveDataThrowService = service;
000002  6008              STR      r0,[r1,#0]  ; AVOUartCB
;;;299    }
000004  4770              BX       lr
;;;300    
                          ENDP

000006  0000              DCW      0x0000
                  |L8.8|
                          DCD      ||area_number.14||

                          AREA ||i.AVO_UART_TxProcess||, CODE, READONLY, ALIGN=1

                  AVO_UART_TxProcess PROC
;;;87     // 发送处理
;;;88     void AVO_UART_TxProcess(AVO_UART_CB *pCB)
000000  b510              PUSH     {r4,lr}
;;;89     {
000002  4604              MOV      r4,r0
;;;90     // 中断方式
;;;91     #if (AVO_UART_TX_MODE == AVO_UART_INTERRUPT_TX_MODE)
;;;92     	uint16 index = pCB->tx.index;						   // 当前发送数据的索引号
000004  f8b404d8          LDRH     r0,[r4,#0x4d8]
;;;93     	uint16 length = pCB->tx.cmdQueue[pCB->tx.head].length; // 当前发送的命令帧的长度
000008  f8b414d4          LDRH     r1,[r4,#0x4d4]
00000c  224d              MOVS     r2,#0x4d
00000e  4351              MULS     r1,r2,r1
000010  eb040141          ADD      r1,r4,r1,LSL #1
000014  f8b1209c          LDRH     r2,[r1,#0x9c]
;;;94     	uint16 head = pCB->tx.head;							   // 发送命令帧队列头索引号
000018  f8b414d4          LDRH     r1,[r4,#0x4d4]
;;;95     	uint16 end = pCB->tx.end;							   // 发送命令帧队列尾索引号
00001c  f8b434d6          LDRH     r3,[r4,#0x4d6]
;;;96     
;;;97     	// 参数合法性检验
;;;98     	if (NULL == pCB)
000020  2c00              CMP      r4,#0
000022  d017              BEQ      |L9.84|
;;;99     	{
;;;100    		return;
;;;101    	}
;;;102    
;;;103    	// 队列为空，不处理
;;;104    	if (head == end)
000024  4299              CMP      r1,r3
000026  d015              BEQ      |L9.84|
;;;105    	{
;;;106    		return;
;;;107    	}
;;;108    
;;;109    	// 发送忙，退出
;;;110    	if (pCB->tx.txBusy)
000028  f89434da          LDRB     r3,[r4,#0x4da]
00002c  2b00              CMP      r3,#0
00002e  d111              BNE      |L9.84|
;;;111    	{
;;;112    		return;
;;;113    	}
;;;114    
;;;115    	// ■■执行到这里，说明队列非空■■
;;;116    
;;;117    	// 当前命令帧未发送完时，取出一个字节放到发送寄存器中
;;;118    	if (index < length)
000030  4290              CMP      r0,r2
000032  d20f              BCS      |L9.84|
;;;119    	{
;;;120    		AVO_UART_IR_StartSendData(pCB->tx.cmdQueue[head].buff[pCB->tx.index++]);
000034  f8b404d8          LDRH     r0,[r4,#0x4d8]
000038  1c42              ADDS     r2,r0,#1
00003a  f8a424d8          STRH     r2,[r4,#0x4d8]
00003e  224d              MOVS     r2,#0x4d
000040  4351              MULS     r1,r2,r1
000042  eb040141          ADD      r1,r4,r1,LSL #1
000046  4408              ADD      r0,r0,r1
000048  7980              LDRB     r0,[r0,#6]
00004a  f7fffffe          BL       AVO_UART_IR_StartSendData
;;;121    
;;;122    		// 设置发送忙状态
;;;123    		pCB->tx.txBusy = TRUE;
00004e  2001              MOVS     r0,#1
000050  f88404da          STRB     r0,[r4,#0x4da]
                  |L9.84|
;;;124    	}
;;;125    
;;;126    // 阻塞方式时启动发送
;;;127    #else
;;;128    	uint16 index = pCB->tx.index;
;;;129    	uint16 head = pCB->tx.head;
;;;130    	uint16 end = pCB->tx.end;
;;;131    
;;;132    	// 参数合法性检验
;;;133    	if (NULL == pCB)
;;;134    	{
;;;135    		return;
;;;136    	}
;;;137    
;;;138    	// 队列为空，不处理
;;;139    	if (head == end)
;;;140    	{
;;;141    		return;
;;;142    	}
;;;143    
;;;144    	// 当前命令帧未发送完时，持续发送
;;;145    	while (index < pCB->tx.cmdQueue[head].length)
;;;146    	{
;;;147    		// 一直填充发送
;;;148    		AVO_UART_BC_SendData(pCB->tx.cmdQueue[head].buff[pCB->tx.index++]);
;;;149    
;;;150    		index = pCB->tx.index;
;;;151    	}
;;;152    
;;;153    	// 当前命令帧发送完时，删除之
;;;154    	pCB->tx.cmdQueue[head].length = 0;
;;;155    	pCB->tx.head++;
;;;156    	pCB->tx.head %= AVO_UART_DRIVE_TX_QUEUE_SIZE;
;;;157    	pCB->tx.index = 0;
;;;158    #endif
;;;159    }
000054  bd10              POP      {r4,pc}
;;;160    
                          ENDP


                          AREA ||i.USART0_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART0_IRQHandler PROC
;;;204     *************************************************************/
;;;205    void USART0_IRQHandler(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;206    {
;;;207    	// 判断DR是否有数据，中断接收
;;;208    	if (usart_interrupt_flag_get(AVO_UART_TYPE_DEF, USART_INT_FLAG_RBNE) != RESET)
000002  4d35              LDR      r5,|L10.216|
000004  4933              LDR      r1,|L10.212|
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       usart_interrupt_flag_get
;;;209    	{
;;;210    		uint8 rxdata = 0x00;
;;;211    
;;;212    		// 接收数据
;;;213    		rxdata = (uint8)usart_data_receive(AVO_UART_TYPE_DEF);
;;;214    
;;;215    		if (NULL != AVOUartCB.receiveDataThrowService)
00000c  4c33              LDR      r4,|L10.220|
00000e  2600              MOVS     r6,#0                 ;208
000010  b158              CBZ      r0,|L10.42|
000012  9600              STR      r6,[sp,#0]            ;210
000014  4628              MOV      r0,r5                 ;213
000016  f7fffffe          BL       usart_data_receive
00001a  9000              STR      r0,[sp,#0]            ;213
00001c  6823              LDR      r3,[r4,#0]  ; AVOUartCB
00001e  b123              CBZ      r3,|L10.42|
;;;216    		{
;;;217    			(*AVOUartCB.receiveDataThrowService)(0xFFF, &rxdata, 1);
000020  2201              MOVS     r2,#1
000022  4669              MOV      r1,sp
000024  f64070ff          MOV      r0,#0xfff
000028  4798              BLX      r3
                  |L10.42|
;;;218    		}
;;;219    	}
;;;220    
;;;221    // 中断模式发送
;;;222    #if (AVO_UART_TX_MODE == AVO_UART_INTERRUPT_TX_MODE)
;;;223    	// 判断DR是否有数据，中断发送
;;;224    	if (usart_interrupt_flag_get(AVO_UART_TYPE_DEF, USART_INT_FLAG_TC) != RESET)
00002a  492d              LDR      r1,|L10.224|
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       usart_interrupt_flag_get
000032  b3b0              CBZ      r0,|L10.162|
;;;225    	{
;;;226    		uint16 head = AVOUartCB.tx.head;
000034  f8b404d4          LDRH     r0,[r4,#0x4d4]  ; AVOUartCB
;;;227    		uint16 end;
;;;228    		uint16 index = AVOUartCB.tx.index;
000038  f8b414d8          LDRH     r1,[r4,#0x4d8]  ; AVOUartCB
;;;229    		uint8 txdata = 0x00;
;;;230    
;;;231    		// 执行到这里，说明上一个数据已经发送完毕，当前命令帧未发送完时，取出一个字节放到发送寄存器中
;;;232    		if (index < AVOUartCB.tx.cmdQueue[head].length)
00003c  224d              MOVS     r2,#0x4d
00003e  4350              MULS     r0,r2,r0
000040  eb040240          ADD      r2,r4,r0,LSL #1
000044  f8b2009c          LDRH     r0,[r2,#0x9c]
000048  4288              CMP      r0,r1
00004a  d90a              BLS      |L10.98|
;;;233    		{
;;;234    			txdata = AVOUartCB.tx.cmdQueue[head].buff[AVOUartCB.tx.index++];
00004c  f8b414d8          LDRH     r1,[r4,#0x4d8]  ; AVOUartCB
000050  1c48              ADDS     r0,r1,#1
000052  f8a404d8          STRH     r0,[r4,#0x4d8]
000056  1888              ADDS     r0,r1,r2
000058  7981              LDRB     r1,[r0,#6]
;;;235    
;;;236    			// 填充数据
;;;237    			usart_data_transmit(AVO_UART_TYPE_DEF, txdata);
00005a  4628              MOV      r0,r5
00005c  f7fffffe          BL       usart_data_transmit
000060  e027              B        |L10.178|
                  |L10.98|
;;;238    		}
;;;239    		// 当前命令帧发送完时，删除之
;;;240    		else
;;;241    		{
;;;242    			AVOUartCB.tx.cmdQueue[head].length = 0;
000062  f8a2609c          STRH     r6,[r2,#0x9c]
;;;243    			AVOUartCB.tx.head++;
000066  f20444d4          ADD      r4,r4,#0x4d4
00006a  8820              LDRH     r0,[r4,#0]  ; AVOUartCB
00006c  1c40              ADDS     r0,r0,#1
00006e  8020              STRH     r0,[r4,#0]
;;;244    			AVOUartCB.tx.head %= AVO_UART_DRIVE_TX_QUEUE_SIZE;
000070  8820              LDRH     r0,[r4,#0]  ; AVOUartCB
000072  f0000007          AND      r0,r0,#7
000076  8020              STRH     r0,[r4,#0]
;;;245    			AVOUartCB.tx.index = 0;
000078  80a6              STRH     r6,[r4,#4]
;;;246    
;;;247    			head = AVOUartCB.tx.head;
00007a  8822              LDRH     r2,[r4,#0]  ; AVOUartCB
;;;248    			end = AVOUartCB.tx.end;
00007c  8860              LDRH     r0,[r4,#2]  ; AVOUartCB
00007e  f2a444d4          SUB      r4,r4,#0x4d4
;;;249    
;;;250    			// 命令帧队列非空，继续发送下一个命令帧
;;;251    			if (head != end)
000082  4282              CMP      r2,r0
000084  d00e              BEQ      |L10.164|
;;;252    			{
;;;253    				txdata = AVOUartCB.tx.cmdQueue[head].buff[AVOUartCB.tx.index++];
000086  f8b414d8          LDRH     r1,[r4,#0x4d8]  ; AVOUartCB
00008a  1c48              ADDS     r0,r1,#1
00008c  f8a404d8          STRH     r0,[r4,#0x4d8]
000090  204d              MOVS     r0,#0x4d
000092  4342              MULS     r2,r0,r2
000094  eb040042          ADD      r0,r4,r2,LSL #1
000098  4408              ADD      r0,r0,r1
00009a  7981              LDRB     r1,[r0,#6]
;;;254    
;;;255    				// 填充数据
;;;256    				usart_data_transmit(AVO_UART_TYPE_DEF, txdata);
00009c  4628              MOV      r0,r5
00009e  f7fffffe          BL       usart_data_transmit
                  |L10.162|
0000a2  e006              B        |L10.178|
                  |L10.164|
;;;257    			}
;;;258    			// 命令帧队列为空停止发送，设置空闲
;;;259    			else
;;;260    			{
;;;261    				// 关闭发送完成中断
;;;262    				usart_interrupt_disable(AVO_UART_TYPE_DEF, USART_INT_TC);
0000a4  f2403106          MOV      r1,#0x306
0000a8  4628              MOV      r0,r5
0000aa  f7fffffe          BL       usart_interrupt_disable
;;;263    
;;;264    				AVOUartCB.tx.txBusy = FALSE;
0000ae  f88464da          STRB     r6,[r4,#0x4da]
                  |L10.178|
;;;265    			}
;;;266    		}
;;;267    	}
;;;268    #endif
;;;269    
;;;270    	// Other USARTx interrupts handler can go here ...
;;;271    	if (usart_interrupt_flag_get(AVO_UART_TYPE_DEF, USART_INT_FLAG_ERR_ORERR) != RESET) //----------------------- 接收溢出中断
0000b2  490c              LDR      r1,|L10.228|
0000b4  4628              MOV      r0,r5
0000b6  f7fffffe          BL       usart_interrupt_flag_get
0000ba  2800              CMP      r0,#0
0000bc  d008              BEQ      |L10.208|
;;;272    	{
;;;273    		usart_flag_get(AVO_UART_TYPE_DEF, USART_FLAG_ORERR); 							//----------------------- 清除接收溢出中断标志位
0000be  2103              MOVS     r1,#3
0000c0  4628              MOV      r0,r5
0000c2  f7fffffe          BL       usart_flag_get
;;;274    		usart_data_receive(AVO_UART_TYPE_DEF);				 							//----------------------- 清空寄存器
0000c6  4628              MOV      r0,r5
0000c8  e8bd40f8          POP      {r3-r7,lr}
0000cc  f7ffbffe          B.W      usart_data_receive
                  |L10.208|
;;;275    	}
;;;276    }
0000d0  bdf8              POP      {r3-r7,pc}
;;;277    
                          ENDP

0000d2  0000              DCW      0x0000
                  |L10.212|
                          DCD      0x00050305
                  |L10.216|
                          DCD      0x40013800
                  |L10.220|
                          DCD      ||area_number.14||
                  |L10.224|
                          DCD      0x00060306
                  |L10.228|
                          DCD      0x00030500

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  AVORxBuff
                          %        200

                          AREA ||area_number.13||, DATA, NOINIT, ALIGN=0

                          EXPORTAS ||area_number.13||, ||.bss||
                  callringBuff
                          %        20

                          AREA ||area_number.14||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.14||, ||.bss||
                  AVOUartCB
                          %        1320

                          AREA ||.data||, DATA, ALIGN=0

                  bleIndex
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "User\\AvoDrive.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_AvoDrive_c_60379258____REV16|
#line 114 ".\\CMSIS\\core_cmInstr.h"
|__asm___10_AvoDrive_c_60379258____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_AvoDrive_c_60379258____REVSH|
#line 128
|__asm___10_AvoDrive_c_60379258____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
